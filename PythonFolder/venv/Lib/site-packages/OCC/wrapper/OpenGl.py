# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_OpenGl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_OpenGl')
    _OpenGl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_OpenGl', [dirname(__file__)])
        except ImportError:
            import _OpenGl
            return _OpenGl
        try:
            _mod = imp.load_module('_OpenGl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _OpenGl = swig_import_helper()
    del swig_import_helper
else:
    import _OpenGl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _OpenGl.delete_SwigPyIterator

    def value(self):
        return _OpenGl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _OpenGl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _OpenGl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _OpenGl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _OpenGl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _OpenGl.SwigPyIterator_copy(self)

    def next(self):
        return _OpenGl.SwigPyIterator_next(self)

    def __next__(self):
        return _OpenGl.SwigPyIterator___next__(self)

    def previous(self):
        return _OpenGl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _OpenGl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _OpenGl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _OpenGl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _OpenGl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _OpenGl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _OpenGl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _OpenGl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _OpenGl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _OpenGl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_OpenGl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _OpenGl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _OpenGl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _OpenGl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _OpenGl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _OpenGl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _OpenGl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_OpenGl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _OpenGl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _OpenGl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _OpenGl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _OpenGl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _OpenGl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _OpenGl.ptr_to_number(item)
ptr_to_number = _OpenGl.ptr_to_number

def HashCode(*args):
    return _OpenGl.HashCode(*args)
HashCode = _OpenGl.HashCode

def ptr_equal(a, b):
    return _OpenGl.ptr_equal(a, b)
ptr_equal = _OpenGl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
OpenGl_MaterialFlag_Front = _OpenGl.OpenGl_MaterialFlag_Front
OpenGl_MaterialFlag_Back = _OpenGl.OpenGl_MaterialFlag_Back
OpenGl_FeatureNotAvailable = _OpenGl.OpenGl_FeatureNotAvailable
OpenGl_FeatureInExtensions = _OpenGl.OpenGl_FeatureInExtensions
OpenGl_FeatureInCore = _OpenGl.OpenGl_FeatureInCore
OpenGl_OCC_MODEL_WORLD_MATRIX = _OpenGl.OpenGl_OCC_MODEL_WORLD_MATRIX
OpenGl_OCC_WORLD_VIEW_MATRIX = _OpenGl.OpenGl_OCC_WORLD_VIEW_MATRIX
OpenGl_OCC_PROJECTION_MATRIX = _OpenGl.OpenGl_OCC_PROJECTION_MATRIX
OpenGl_OCC_MODEL_WORLD_MATRIX_INVERSE = _OpenGl.OpenGl_OCC_MODEL_WORLD_MATRIX_INVERSE
OpenGl_OCC_WORLD_VIEW_MATRIX_INVERSE = _OpenGl.OpenGl_OCC_WORLD_VIEW_MATRIX_INVERSE
OpenGl_OCC_PROJECTION_MATRIX_INVERSE = _OpenGl.OpenGl_OCC_PROJECTION_MATRIX_INVERSE
OpenGl_OCC_MODEL_WORLD_MATRIX_TRANSPOSE = _OpenGl.OpenGl_OCC_MODEL_WORLD_MATRIX_TRANSPOSE
OpenGl_OCC_WORLD_VIEW_MATRIX_TRANSPOSE = _OpenGl.OpenGl_OCC_WORLD_VIEW_MATRIX_TRANSPOSE
OpenGl_OCC_PROJECTION_MATRIX_TRANSPOSE = _OpenGl.OpenGl_OCC_PROJECTION_MATRIX_TRANSPOSE
OpenGl_OCC_MODEL_WORLD_MATRIX_INVERSE_TRANSPOSE = _OpenGl.OpenGl_OCC_MODEL_WORLD_MATRIX_INVERSE_TRANSPOSE
OpenGl_OCC_WORLD_VIEW_MATRIX_INVERSE_TRANSPOSE = _OpenGl.OpenGl_OCC_WORLD_VIEW_MATRIX_INVERSE_TRANSPOSE
OpenGl_OCC_PROJECTION_MATRIX_INVERSE_TRANSPOSE = _OpenGl.OpenGl_OCC_PROJECTION_MATRIX_INVERSE_TRANSPOSE
OpenGl_OCC_CLIP_PLANE_EQUATIONS = _OpenGl.OpenGl_OCC_CLIP_PLANE_EQUATIONS
OpenGl_OCC_CLIP_PLANE_COUNT = _OpenGl.OpenGl_OCC_CLIP_PLANE_COUNT
OpenGl_OCC_LIGHT_SOURCE_COUNT = _OpenGl.OpenGl_OCC_LIGHT_SOURCE_COUNT
OpenGl_OCC_LIGHT_SOURCE_TYPES = _OpenGl.OpenGl_OCC_LIGHT_SOURCE_TYPES
OpenGl_OCC_LIGHT_SOURCE_PARAMS = _OpenGl.OpenGl_OCC_LIGHT_SOURCE_PARAMS
OpenGl_OCC_LIGHT_AMBIENT = _OpenGl.OpenGl_OCC_LIGHT_AMBIENT
OpenGl_OCCT_TEXTURE_ENABLE = _OpenGl.OpenGl_OCCT_TEXTURE_ENABLE
OpenGl_OCCT_DISTINGUISH_MODE = _OpenGl.OpenGl_OCCT_DISTINGUISH_MODE
OpenGl_OCCT_FRONT_MATERIAL = _OpenGl.OpenGl_OCCT_FRONT_MATERIAL
OpenGl_OCCT_BACK_MATERIAL = _OpenGl.OpenGl_OCCT_BACK_MATERIAL
OpenGl_OCCT_ALPHA_CUTOFF = _OpenGl.OpenGl_OCCT_ALPHA_CUTOFF
OpenGl_OCCT_COLOR = _OpenGl.OpenGl_OCCT_COLOR
OpenGl_OCCT_OIT_OUTPUT = _OpenGl.OpenGl_OCCT_OIT_OUTPUT
OpenGl_OCCT_OIT_DEPTH_FACTOR = _OpenGl.OpenGl_OCCT_OIT_DEPTH_FACTOR
OpenGl_OCCT_TEXTURE_TRSF2D = _OpenGl.OpenGl_OCCT_TEXTURE_TRSF2D
OpenGl_OCCT_POINT_SIZE = _OpenGl.OpenGl_OCCT_POINT_SIZE
OpenGl_OCCT_NUMBER_OF_STATE_VARIABLES = _OpenGl.OpenGl_OCCT_NUMBER_OF_STATE_VARIABLES
OpenGl_LIGHT_SOURCES_STATE = _OpenGl.OpenGl_LIGHT_SOURCES_STATE
OpenGl_CLIP_PLANES_STATE = _OpenGl.OpenGl_CLIP_PLANES_STATE
OpenGl_MODEL_WORLD_STATE = _OpenGl.OpenGl_MODEL_WORLD_STATE
OpenGl_WORLD_VIEW_STATE = _OpenGl.OpenGl_WORLD_VIEW_STATE
OpenGl_PROJECTION_STATE = _OpenGl.OpenGl_PROJECTION_STATE
OpenGl_MATERIAL_STATE = _OpenGl.OpenGl_MATERIAL_STATE
OpenGl_SURF_DETAIL_STATE = _OpenGl.OpenGl_SURF_DETAIL_STATE
OpenGL_OIT_STATE = _OpenGl.OpenGL_OIT_STATE
OpenGl_UniformStateType_NB = _OpenGl.OpenGl_UniformStateType_NB
OpenGl_LF_All = _OpenGl.OpenGl_LF_All
OpenGl_LF_Upper = _OpenGl.OpenGl_LF_Upper
OpenGl_LF_Bottom = _OpenGl.OpenGl_LF_Bottom
OpenGl_LF_Default = _OpenGl.OpenGl_LF_Default
OpenGl_PO_Point = _OpenGl.OpenGl_PO_Point
OpenGl_PO_VertColor = _OpenGl.OpenGl_PO_VertColor
OpenGl_PO_TextureRGB = _OpenGl.OpenGl_PO_TextureRGB
OpenGl_PO_TextureA = _OpenGl.OpenGl_PO_TextureA
OpenGl_PO_TextureEnv = _OpenGl.OpenGl_PO_TextureEnv
OpenGl_PO_StippleLine = _OpenGl.OpenGl_PO_StippleLine
OpenGl_PO_ClipPlanes1 = _OpenGl.OpenGl_PO_ClipPlanes1
OpenGl_PO_ClipPlanes2 = _OpenGl.OpenGl_PO_ClipPlanes2
OpenGl_PO_ClipPlanesN = _OpenGl.OpenGl_PO_ClipPlanesN
OpenGl_PO_AlphaTest = _OpenGl.OpenGl_PO_AlphaTest
OpenGl_PO_WriteOit = _OpenGl.OpenGl_PO_WriteOit
OpenGl_PO_NB = _OpenGl.OpenGl_PO_NB
class OpenGl_TmplCore14_OpenGl_GlCore13Fwd(object):
    """OpenGL 1.4 core based on 1.3 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.4 core based on 1.3 version."""
        this = _OpenGl.new_OpenGl_TmplCore14_OpenGl_GlCore13Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore14_OpenGl_GlCore13Fwd
OpenGl_TmplCore14_OpenGl_GlCore13Fwd_swigregister = _OpenGl.OpenGl_TmplCore14_OpenGl_GlCore13Fwd_swigregister
OpenGl_TmplCore14_OpenGl_GlCore13Fwd_swigregister(OpenGl_TmplCore14_OpenGl_GlCore13Fwd)


try:
	OpenGl_GlCore14Fwd = OpenGl_TmplCore14_OpenGl_GlCore13Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore15_OpenGl_GlCore14Fwd(object):
    """OpenGL 1.5 core based on 1.4 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.5 core based on 1.4 version."""
        this = _OpenGl.new_OpenGl_TmplCore15_OpenGl_GlCore14Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore15_OpenGl_GlCore14Fwd
OpenGl_TmplCore15_OpenGl_GlCore14Fwd_swigregister = _OpenGl.OpenGl_TmplCore15_OpenGl_GlCore14Fwd_swigregister
OpenGl_TmplCore15_OpenGl_GlCore14Fwd_swigregister(OpenGl_TmplCore15_OpenGl_GlCore14Fwd)


try:
	OpenGl_GlCore15Fwd = OpenGl_TmplCore15_OpenGl_GlCore14Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore20_OpenGl_GlCore15Fwd(object):
    """OpenGL 2.0 core based on 1.5 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 2.0 core based on 1.5 version."""
        this = _OpenGl.new_OpenGl_TmplCore20_OpenGl_GlCore15Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore20_OpenGl_GlCore15Fwd
OpenGl_TmplCore20_OpenGl_GlCore15Fwd_swigregister = _OpenGl.OpenGl_TmplCore20_OpenGl_GlCore15Fwd_swigregister
OpenGl_TmplCore20_OpenGl_GlCore15Fwd_swigregister(OpenGl_TmplCore20_OpenGl_GlCore15Fwd)


try:
	OpenGl_GlCore20Fwd = OpenGl_TmplCore20_OpenGl_GlCore15Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore14_OpenGl_GlCore13(object):
    """OpenGL 1.4 core based on 1.3 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.4 core based on 1.3 version."""
        this = _OpenGl.new_OpenGl_TmplCore14_OpenGl_GlCore13()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore14_OpenGl_GlCore13
OpenGl_TmplCore14_OpenGl_GlCore13_swigregister = _OpenGl.OpenGl_TmplCore14_OpenGl_GlCore13_swigregister
OpenGl_TmplCore14_OpenGl_GlCore13_swigregister(OpenGl_TmplCore14_OpenGl_GlCore13)


try:
	OpenGl_GlCore14 = OpenGl_TmplCore14_OpenGl_GlCore13
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore15_OpenGl_GlCore14(object):
    """OpenGL 1.5 core based on 1.4 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.5 core based on 1.4 version."""
        this = _OpenGl.new_OpenGl_TmplCore15_OpenGl_GlCore14()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore15_OpenGl_GlCore14
OpenGl_TmplCore15_OpenGl_GlCore14_swigregister = _OpenGl.OpenGl_TmplCore15_OpenGl_GlCore14_swigregister
OpenGl_TmplCore15_OpenGl_GlCore14_swigregister(OpenGl_TmplCore15_OpenGl_GlCore14)


try:
	OpenGl_GlCore15 = OpenGl_TmplCore15_OpenGl_GlCore14
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore21_OpenGl_GlCore20Fwd(object):
    """OpenGL 2.1 core based on 2.0 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 2.1 core based on 2.0 version."""
        this = _OpenGl.new_OpenGl_TmplCore21_OpenGl_GlCore20Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore21_OpenGl_GlCore20Fwd
OpenGl_TmplCore21_OpenGl_GlCore20Fwd_swigregister = _OpenGl.OpenGl_TmplCore21_OpenGl_GlCore20Fwd_swigregister
OpenGl_TmplCore21_OpenGl_GlCore20Fwd_swigregister(OpenGl_TmplCore21_OpenGl_GlCore20Fwd)


try:
	OpenGl_GlCore21Fwd = OpenGl_TmplCore21_OpenGl_GlCore20Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore20_OpenGl_GlCore15(object):
    """OpenGL 2.0 core based on 1.5 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 2.0 core based on 1.5 version."""
        this = _OpenGl.new_OpenGl_TmplCore20_OpenGl_GlCore15()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore20_OpenGl_GlCore15
OpenGl_TmplCore20_OpenGl_GlCore15_swigregister = _OpenGl.OpenGl_TmplCore20_OpenGl_GlCore15_swigregister
OpenGl_TmplCore20_OpenGl_GlCore15_swigregister(OpenGl_TmplCore20_OpenGl_GlCore15)


try:
	OpenGl_GlCore20 = OpenGl_TmplCore20_OpenGl_GlCore15
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore30_OpenGl_GlCore21Fwd(object):
    """
    OpenGL 3.0 core.
    This is first version with deprecation model introduced
    - a lot of functionality regarding to fixed pipeline were marked deprecated.
    Notice that nothing were actually removed in this version (unless Forward context loaded)!
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """
        OpenGL 3.0 core.
        This is first version with deprecation model introduced
        - a lot of functionality regarding to fixed pipeline were marked deprecated.
        Notice that nothing were actually removed in this version (unless Forward context loaded)!
        """
        this = _OpenGl.new_OpenGl_TmplCore30_OpenGl_GlCore21Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore30_OpenGl_GlCore21Fwd
OpenGl_TmplCore30_OpenGl_GlCore21Fwd_swigregister = _OpenGl.OpenGl_TmplCore30_OpenGl_GlCore21Fwd_swigregister
OpenGl_TmplCore30_OpenGl_GlCore21Fwd_swigregister(OpenGl_TmplCore30_OpenGl_GlCore21Fwd)


try:
	OpenGl_GlCore30Fwd = OpenGl_TmplCore30_OpenGl_GlCore21Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore21_OpenGl_GlCore20(object):
    """OpenGL 2.1 core based on 2.0 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 2.1 core based on 2.0 version."""
        this = _OpenGl.new_OpenGl_TmplCore21_OpenGl_GlCore20()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore21_OpenGl_GlCore20
OpenGl_TmplCore21_OpenGl_GlCore20_swigregister = _OpenGl.OpenGl_TmplCore21_OpenGl_GlCore20_swigregister
OpenGl_TmplCore21_OpenGl_GlCore20_swigregister(OpenGl_TmplCore21_OpenGl_GlCore20)


try:
	OpenGl_GlCore21 = OpenGl_TmplCore21_OpenGl_GlCore20
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore31_OpenGl_GlCore30Fwd(object):
    """OpenGL 3.1 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.1 definition."""
        this = _OpenGl.new_OpenGl_TmplCore31_OpenGl_GlCore30Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore31_OpenGl_GlCore30Fwd
OpenGl_TmplCore31_OpenGl_GlCore30Fwd_swigregister = _OpenGl.OpenGl_TmplCore31_OpenGl_GlCore30Fwd_swigregister
OpenGl_TmplCore31_OpenGl_GlCore30Fwd_swigregister(OpenGl_TmplCore31_OpenGl_GlCore30Fwd)


try:
	OpenGl_GlCore31 = OpenGl_TmplCore31_OpenGl_GlCore30Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore30_OpenGl_GlCore21(object):
    """
    OpenGL 3.0 core.
    This is first version with deprecation model introduced
    - a lot of functionality regarding to fixed pipeline were marked deprecated.
    Notice that nothing were actually removed in this version (unless Forward context loaded)!
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """
        OpenGL 3.0 core.
        This is first version with deprecation model introduced
        - a lot of functionality regarding to fixed pipeline were marked deprecated.
        Notice that nothing were actually removed in this version (unless Forward context loaded)!
        """
        this = _OpenGl.new_OpenGl_TmplCore30_OpenGl_GlCore21()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore30_OpenGl_GlCore21
OpenGl_TmplCore30_OpenGl_GlCore21_swigregister = _OpenGl.OpenGl_TmplCore30_OpenGl_GlCore21_swigregister
OpenGl_TmplCore30_OpenGl_GlCore21_swigregister(OpenGl_TmplCore30_OpenGl_GlCore21)


try:
	OpenGl_GlCore30 = OpenGl_TmplCore30_OpenGl_GlCore21
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore32_OpenGl_GlCore31(object):
    """OpenGL 3.2 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.2 definition."""
        this = _OpenGl.new_OpenGl_TmplCore32_OpenGl_GlCore31()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore32_OpenGl_GlCore31
OpenGl_TmplCore32_OpenGl_GlCore31_swigregister = _OpenGl.OpenGl_TmplCore32_OpenGl_GlCore31_swigregister
OpenGl_TmplCore32_OpenGl_GlCore31_swigregister(OpenGl_TmplCore32_OpenGl_GlCore31)


try:
	OpenGl_GlCore32 = OpenGl_TmplCore32_OpenGl_GlCore31
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore31_OpenGl_GlCore30(object):
    """OpenGL 3.1 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.1 definition."""
        this = _OpenGl.new_OpenGl_TmplCore31_OpenGl_GlCore30()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore31_OpenGl_GlCore30
OpenGl_TmplCore31_OpenGl_GlCore30_swigregister = _OpenGl.OpenGl_TmplCore31_OpenGl_GlCore30_swigregister
OpenGl_TmplCore31_OpenGl_GlCore30_swigregister(OpenGl_TmplCore31_OpenGl_GlCore30)


try:
	OpenGl_GlCore31Back = OpenGl_TmplCore31_OpenGl_GlCore30
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore33_OpenGl_GlCore32(object):
    """OpenGL 3.3 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.3 definition."""
        this = _OpenGl.new_OpenGl_TmplCore33_OpenGl_GlCore32()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore33_OpenGl_GlCore32
OpenGl_TmplCore33_OpenGl_GlCore32_swigregister = _OpenGl.OpenGl_TmplCore33_OpenGl_GlCore32_swigregister
OpenGl_TmplCore33_OpenGl_GlCore32_swigregister(OpenGl_TmplCore33_OpenGl_GlCore32)


try:
	OpenGl_GlCore33 = OpenGl_TmplCore33_OpenGl_GlCore32
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore40_OpenGl_GlCore33(object):
    """OpenGL 4.0 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.0 definition."""
        this = _OpenGl.new_OpenGl_TmplCore40_OpenGl_GlCore33()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore40_OpenGl_GlCore33
OpenGl_TmplCore40_OpenGl_GlCore33_swigregister = _OpenGl.OpenGl_TmplCore40_OpenGl_GlCore33_swigregister
OpenGl_TmplCore40_OpenGl_GlCore33_swigregister(OpenGl_TmplCore40_OpenGl_GlCore33)


try:
	OpenGl_GlCore40 = OpenGl_TmplCore40_OpenGl_GlCore33
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore32_OpenGl_GlCore31Back(object):
    """OpenGL 3.2 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.2 definition."""
        this = _OpenGl.new_OpenGl_TmplCore32_OpenGl_GlCore31Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore32_OpenGl_GlCore31Back
OpenGl_TmplCore32_OpenGl_GlCore31Back_swigregister = _OpenGl.OpenGl_TmplCore32_OpenGl_GlCore31Back_swigregister
OpenGl_TmplCore32_OpenGl_GlCore31Back_swigregister(OpenGl_TmplCore32_OpenGl_GlCore31Back)


try:
	OpenGl_GlCore32Back = OpenGl_TmplCore32_OpenGl_GlCore31Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore41_OpenGl_GlCore40(object):
    """OpenGL 4.1 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.1 definition."""
        this = _OpenGl.new_OpenGl_TmplCore41_OpenGl_GlCore40()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore41_OpenGl_GlCore40
OpenGl_TmplCore41_OpenGl_GlCore40_swigregister = _OpenGl.OpenGl_TmplCore41_OpenGl_GlCore40_swigregister
OpenGl_TmplCore41_OpenGl_GlCore40_swigregister(OpenGl_TmplCore41_OpenGl_GlCore40)


try:
	OpenGl_GlCore41 = OpenGl_TmplCore41_OpenGl_GlCore40
except NameError:
	pass # does not exist, probably ignored

class OpenGl_Resource(Standard.Standard_Transient):
    """
    Interface for OpenGl resource with following meaning:
    - object can be constructed at any time;
    - should be explicitly Initialized within active OpenGL context;
    - should be explicitly Released    within active OpenGL context (virtual Release() method);
    - can be destroyed at any time.
    Destruction of object with unreleased GPU resources will cause leaks
    which will be ignored in release mode and will immediately stop program execution in debug mode using assert.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Resource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Resource(self) 
            return h


    def Release(self, *args):
        """
        Release(OpenGl_Resource self, OpenGl_Context theGlCtx)

        Release GPU resources.
        Notice that implementation should be SAFE for several consecutive calls
        (thus should invalidate internal structures / ids to avoid multiple-free errors).
        @param theGlCtx - bound GL context, shouldn't be NULL.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Resource_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_Resource self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Resource_EstimatedDataSize(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Resource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Resource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Resource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Resource
OpenGl_Resource_swigregister = _OpenGl.OpenGl_Resource_swigregister
OpenGl_Resource_swigregister(OpenGl_Resource)

def OpenGl_Resource_get_type_name(*args):
    """
    OpenGl_Resource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Resource_get_type_name(*args)

def OpenGl_Resource_get_type_descriptor(*args):
    """
    OpenGl_Resource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Resource_get_type_descriptor(*args)

class OpenGl_TmplCore33_OpenGl_GlCore32Back(object):
    """OpenGL 3.3 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 3.3 definition."""
        this = _OpenGl.new_OpenGl_TmplCore33_OpenGl_GlCore32Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore33_OpenGl_GlCore32Back
OpenGl_TmplCore33_OpenGl_GlCore32Back_swigregister = _OpenGl.OpenGl_TmplCore33_OpenGl_GlCore32Back_swigregister
OpenGl_TmplCore33_OpenGl_GlCore32Back_swigregister(OpenGl_TmplCore33_OpenGl_GlCore32Back)


try:
	OpenGl_GlCore33Back = OpenGl_TmplCore33_OpenGl_GlCore32Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_NamedResource(OpenGl_Resource):
    """Named resource object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_NamedResource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_NamedResource(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_NamedResource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_NamedResource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_NamedResource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResourceId(self, *args):
        """
        Return resource name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.OpenGl_NamedResource_ResourceId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_NamedResource
OpenGl_NamedResource_swigregister = _OpenGl.OpenGl_NamedResource_swigregister
OpenGl_NamedResource_swigregister(OpenGl_NamedResource)

def OpenGl_NamedResource_get_type_name(*args):
    """
    OpenGl_NamedResource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_NamedResource_get_type_name(*args)

def OpenGl_NamedResource_get_type_descriptor(*args):
    """
    OpenGl_NamedResource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_NamedResource_get_type_descriptor(*args)

class OpenGl_TmplCore40_OpenGl_GlCore33Back(object):
    """OpenGL 4.0 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.0 definition."""
        this = _OpenGl.new_OpenGl_TmplCore40_OpenGl_GlCore33Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore40_OpenGl_GlCore33Back
OpenGl_TmplCore40_OpenGl_GlCore33Back_swigregister = _OpenGl.OpenGl_TmplCore40_OpenGl_GlCore33Back_swigregister
OpenGl_TmplCore40_OpenGl_GlCore33Back_swigregister(OpenGl_TmplCore40_OpenGl_GlCore33Back)


try:
	OpenGl_GlCore40Back = OpenGl_TmplCore40_OpenGl_GlCore33Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore42_OpenGl_GlCore41(object):
    """OpenGL 4.2 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.2 definition."""
        this = _OpenGl.new_OpenGl_TmplCore42_OpenGl_GlCore41()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore42_OpenGl_GlCore41
OpenGl_TmplCore42_OpenGl_GlCore41_swigregister = _OpenGl.OpenGl_TmplCore42_OpenGl_GlCore41_swigregister
OpenGl_TmplCore42_OpenGl_GlCore41_swigregister(OpenGl_TmplCore42_OpenGl_GlCore41)


try:
	OpenGl_GlCore42 = OpenGl_TmplCore42_OpenGl_GlCore41
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore41_OpenGl_GlCore40Back(object):
    """OpenGL 4.1 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.1 definition."""
        this = _OpenGl.new_OpenGl_TmplCore41_OpenGl_GlCore40Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore41_OpenGl_GlCore40Back
OpenGl_TmplCore41_OpenGl_GlCore40Back_swigregister = _OpenGl.OpenGl_TmplCore41_OpenGl_GlCore40Back_swigregister
OpenGl_TmplCore41_OpenGl_GlCore40Back_swigregister(OpenGl_TmplCore41_OpenGl_GlCore40Back)


try:
	OpenGl_GlCore41Back = OpenGl_TmplCore41_OpenGl_GlCore40Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_Texture(OpenGl_NamedResource):
    """Texture resource."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Texture
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Texture(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Texture_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Texture_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Texture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PixelSizeOfPixelFormat(*args):
        """
        PixelSizeOfPixelFormat(Standard_Integer theInternalFormat) -> Standard_Size

        Return pixel size of pixel format in bytes.
        Note that this method considers that OpenGL natively supports this pixel format,
        which might be not the case - in the latter case, actual pixel size might differ!

        :type theInternalFormat: int
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Texture_PixelSizeOfPixelFormat(*args)

    PixelSizeOfPixelFormat = staticmethod(PixelSizeOfPixelFormat)

    def __init__(self, *args):
        """
        __init__(OpenGl_Texture self, TCollection_AsciiString theResourceId, Handle_Graphic3d_TextureParams theParams) -> OpenGl_Texture

        Create uninitialized texture.

        :type theResourceId: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        this = _OpenGl.new_OpenGl_Texture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsValid(self, *args):
        """
        IsValid(OpenGl_Texture self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_IsValid(self, *args)


    def GetTarget(self, *args):
        """
        GetTarget(OpenGl_Texture self) -> GLenum

        @return target to which the texture is bound (GL_TEXTURE_1D, GL_TEXTURE_2D)

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_Texture_GetTarget(self, *args)


    def SizeX(self, *args):
        """
        SizeX(OpenGl_Texture self) -> GLsizei

        @return texture width (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_Texture_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(OpenGl_Texture self) -> GLsizei

        @return texture height (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_Texture_SizeY(self, *args)


    def TextureId(self, *args):
        """
        TextureId(OpenGl_Texture self) -> GLuint

        @return texture ID

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_Texture_TextureId(self, *args)


    def GetFormat(self, *args):
        """
        GetFormat(OpenGl_Texture self) -> GLenum

        @return texture format (not sized)

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_Texture_GetFormat(self, *args)


    def IsAlpha(self, *args):
        """
        IsAlpha(OpenGl_Texture self) -> bool

        Return true for GL_RED and GL_ALPHA formats.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_IsAlpha(self, *args)


    def SetAlpha(self, *args):
        """
        SetAlpha(OpenGl_Texture self, bool const theValue)

        Setup to interprete the format as Alpha by Shader Manager
        (should be GL_ALPHA within compatible context or GL_RED otherwise).

        :type theValue: const bool

        """
        return _OpenGl.OpenGl_Texture_SetAlpha(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_Texture self, Handle_OpenGl_Context theCtx) -> bool

        Creates Texture id if not yet generated.
        Data should be initialized by another method.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_Create(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_Texture self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Texture_Release(self, *args)


    def Sampler(self, *args):
        """
        Return texture sampler.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        res = _OpenGl.OpenGl_Texture_Sampler(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSampler(self, *args):
        """
        SetSampler(OpenGl_Texture self, Handle_OpenGl_Sampler theSampler)

        Set texture sampler.

        :type theSampler: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        return _OpenGl.OpenGl_Texture_SetSampler(self, *args)


    def InitSamplerObject(self, *args):
        """
        InitSamplerObject(OpenGl_Texture self, Handle_OpenGl_Context theCtx) -> bool

        Initialize the Sampler Object (as OpenGL object).
        @param theCtx currently bound OpenGL context

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_InitSamplerObject(self, *args)


    def Bind(self, *args):
        """
        Bind(OpenGl_Texture self, Handle_OpenGl_Context theCtx)
        Bind(OpenGl_Texture self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Bind this Texture to specified unit.
        Also binds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_Texture_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(OpenGl_Texture self, Handle_OpenGl_Context theCtx)
        Unbind(OpenGl_Texture self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Unbind texture from specified unit.
        Also unbinds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_Texture_Unbind(self, *args)


    def Revision(self, *args):
        """
        Revision(OpenGl_Texture self) -> Standard_Size

        Revision of associated data source.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Texture_Revision(self, *args)


    def SetRevision(self, *args):
        """
        SetRevision(OpenGl_Texture self, Standard_Size const theRevision)

        Set revision of associated data source.

        :type theRevision: int

        """
        return _OpenGl.OpenGl_Texture_SetRevision(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_Texture self, Handle_OpenGl_Context theCtx, Image_PixMap theImage, Graphic3d_TypeOfTexture const theType) -> bool
        Init(OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, GLsizei const theSizeX, GLsizei const theSizeY, Graphic3d_TypeOfTexture const theType, Image_PixMap theImage=None) -> bool

        Initialize the texture with specified format, size and texture type.
        If theImage is empty the texture data will contain trash.
        Notice that texture will be unbound after this call.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfTexture
        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_Init(self, *args)


    def Init2DMultisample(self, *args):
        """
        Init2DMultisample(OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLsizei const theNbSamples, GLint const theTextFormat, GLsizei const theSizeX, GLsizei const theSizeY) -> bool

        Initialize the 2D multisampling texture using glTexImage2DMultisample().

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theNbSamples: GLsizei
        :type theTextFormat: GLint
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_Init2DMultisample(self, *args)


    def InitRectangle(self, *args):
        """
        InitRectangle(OpenGl_Texture self, Handle_OpenGl_Context theCtx, Standard_Integer const theSizeX, Standard_Integer const theSizeY, OpenGl_TextureFormat theFormat) -> bool

        Allocates texture rectangle with specified format and size.

        ote Texture data is not initialized (will contain trash).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: int
        :type theSizeY: int
        :type theFormat: OCC.wrapper.OpenGl.OpenGl_TextureFormat
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_InitRectangle(self, *args)


    def Init3D(self, *args):
        """
        Init3D(OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, Standard_Integer const theSizeX, Standard_Integer const theSizeY, Standard_Integer const theSizeZ, void const * thePixels) -> bool

        Initializes 3D texture rectangle with specified format and size.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeZ: int
        :type thePixels: const void *
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_Init3D(self, *args)


    def HasMipmaps(self, *args):
        """
        HasMipmaps(OpenGl_Texture self) -> Standard_Boolean

        @return true if texture was generated within mipmaps

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Texture_HasMipmaps(self, *args)


    def GetDataFormat(*args):
        """
        GetDataFormat(Handle_OpenGl_Context theCtx, Image_PixMap theData, GLint & theTextFormat, GLenum & thePixelFormat, GLenum & theDataType) -> bool

        Return texture type and format by Image_PixMap data format.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theData: OCC.wrapper.Image.Image_PixMap
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.OpenGl_Texture_GetDataFormat(*args)

    GetDataFormat = staticmethod(GetDataFormat)

    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_Texture self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Texture_EstimatedDataSize(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_Texture
OpenGl_Texture_swigregister = _OpenGl.OpenGl_Texture_swigregister
OpenGl_Texture_swigregister(OpenGl_Texture)

def OpenGl_Texture_get_type_name(*args):
    """
    OpenGl_Texture_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Texture_get_type_name(*args)

def OpenGl_Texture_get_type_descriptor(*args):
    """
    OpenGl_Texture_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Texture_get_type_descriptor(*args)

def OpenGl_Texture_PixelSizeOfPixelFormat(*args):
    """
    OpenGl_Texture_PixelSizeOfPixelFormat(Standard_Integer theInternalFormat) -> Standard_Size

    Return pixel size of pixel format in bytes.
    Note that this method considers that OpenGL natively supports this pixel format,
    which might be not the case - in the latter case, actual pixel size might differ!

    :type theInternalFormat: int
    :rtype: OCC.wrapper.Standard.Standard_Size

    """
    return _OpenGl.OpenGl_Texture_PixelSizeOfPixelFormat(*args)

def OpenGl_Texture_GetDataFormat(*args):
    """
    OpenGl_Texture_GetDataFormat(Handle_OpenGl_Context theCtx, Image_PixMap theData, GLint & theTextFormat, GLenum & thePixelFormat, GLenum & theDataType) -> bool

    Return texture type and format by Image_PixMap data format.

    :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theData: OCC.wrapper.Image.Image_PixMap
    :type theTextFormat: GLint
    :type thePixelFormat: GLenum
    :type theDataType: GLenum
    :rtype: bool

    """
    return _OpenGl.OpenGl_Texture_GetDataFormat(*args)

class OpenGl_Structure(Graphic3d.Graphic3d_CStructure):
    """Implementation of low-level graphic structure."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Structure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Structure(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Structure self, Handle_Graphic3d_StructureManager theManager) -> OpenGl_Structure

        Create empty structure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager

        """
        this = _OpenGl.new_OpenGl_Structure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def OnVisibilityChanged(self, *args):
        """
        OnVisibilityChanged(OpenGl_Structure self)

        Setup structure graphic state


        """
        return _OpenGl.OpenGl_Structure_OnVisibilityChanged(self, *args)


    def Connect(self, *args):
        """
        Connect(OpenGl_Structure self, Graphic3d_CStructure theStructure)

        Connect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.OpenGl_Structure_Connect(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(OpenGl_Structure self, Graphic3d_CStructure theStructure)

        Disconnect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.OpenGl_Structure_Disconnect(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(OpenGl_Structure self, Handle_Geom_Transformation theTrsf)

        Synchronize structure transformation

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _OpenGl.OpenGl_Structure_SetTransformation(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(OpenGl_Structure self, Handle_Graphic3d_TransformPers theTrsfPers)

        Set transformation persistence.

        :type theTrsfPers: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        return _OpenGl.OpenGl_Structure_SetTransformPersistence(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(OpenGl_Structure self, Graphic3d_ZLayerId const theLayerIndex)

        Set z layer ID to display the structure in specified layer

        :type theLayerIndex: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_Structure_SetZLayer(self, *args)


    def GraphicHighlight(self, *args):
        """
        GraphicHighlight(OpenGl_Structure self, Handle_Graphic3d_PresentationAttributes theStyle, Handle_Graphic3d_Structure theStruct)

        Highlights structure according to the given style and updates corresponding class fields
        (highlight status and style)

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        return _OpenGl.OpenGl_Structure_GraphicHighlight(self, *args)


    def GraphicUnhighlight(self, *args):
        """
        GraphicUnhighlight(OpenGl_Structure self)

        Unighlights structure and updates corresponding class fields (highlight status and style)


        """
        return _OpenGl.OpenGl_Structure_GraphicUnhighlight(self, *args)


    def ShadowLink(self, *args):
        """
        ShadowLink(OpenGl_Structure self, Handle_Graphic3d_StructureManager theManager) -> Handle_Graphic3d_CStructure

        Create shadow link to this structure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.OpenGl_Structure_ShadowLink(self, *args)


    def NewGroup(self, *args):
        """
        NewGroup(OpenGl_Structure self, Handle_Graphic3d_Structure theStruct) -> Handle_Graphic3d_Group

        Create new group within this structure

        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.OpenGl_Structure_NewGroup(self, *args)


    def RemoveGroup(self, *args):
        """
        RemoveGroup(OpenGl_Structure self, Handle_Graphic3d_Group theGroup)

        Remove group from this structure

        :type theGroup: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.OpenGl_Structure_RemoveGroup(self, *args)


    def GlDriver(self, *args):
        """
        GlDriver(OpenGl_Structure self) -> OpenGl_GraphicDriver

        Access graphic driver

        :rtype: OCC.wrapper.OpenGl.OpenGl_GraphicDriver

        """
        return _OpenGl.OpenGl_Structure_GlDriver(self, *args)


    def Clear(self, *args):
        """
        Clear(OpenGl_Structure self)
        Clear(OpenGl_Structure self, Handle_OpenGl_Context theGlCtx)

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Structure_Clear(self, *args)


    def SetCulled(self, *args):
        """
        SetCulled(OpenGl_Structure self, Standard_Boolean theIsCulled)

        Marks structure as culled/not culled - note that IsAlwaysRendered() is ignored here!

        :type theIsCulled: bool

        """
        return _OpenGl.OpenGl_Structure_SetCulled(self, *args)


    def MarkAsNotCulled(self, *args):
        """
        MarkAsNotCulled(OpenGl_Structure self)

        Marks structure as overlapping the current view volume one.
        The method is called during traverse of BVH tree.


        """
        return _OpenGl.OpenGl_Structure_MarkAsNotCulled(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(OpenGl_Structure self) -> Standard_Boolean

        Returns Standard_False if the structure hits the current view volume, otherwise
        returns Standard_True. The default value for all structures before each traverse
        of BVH tree is Standard_True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Structure_IsCulled(self, *args)


    def IsAlwaysRendered(self, *args):
        """
        IsAlwaysRendered(OpenGl_Structure self) -> Standard_Boolean

        Checks if the structure should be included into BVH tree or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Structure_IsAlwaysRendered(self, *args)


    def ReleaseGlResources(self, *args):
        """
        ReleaseGlResources(OpenGl_Structure self, Handle_OpenGl_Context theGlCtx)

        This method releases GL resources without actual elements destruction.
        As result structure could be correctly destroyed layer without GL context
        (after last window was closed for example).

        Notice however that reusage of this structure after calling this method is incorrect
        and will lead to broken visualization due to loosed data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Structure_ReleaseGlResources(self, *args)


    def InstancedStructure(self, *args):
        """
        InstancedStructure(OpenGl_Structure self) -> OpenGl_Structure

        Returns instanced OpenGL structure.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.OpenGl_Structure_InstancedStructure(self, *args)


    def ModificationState(self, *args):
        """
        ModificationState(OpenGl_Structure self) -> Standard_Size

        Returns structure modification state (for ray-tracing).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Structure_ModificationState(self, *args)


    def ResetModificationState(self, *args):
        """
        ResetModificationState(OpenGl_Structure self)

        Resets structure modification state (for ray-tracing).


        """
        return _OpenGl.OpenGl_Structure_ResetModificationState(self, *args)


    def updateLayerTransformation(self, *args):
        """
        updateLayerTransformation(OpenGl_Structure self)

        Update render transformation matrix.


        """
        return _OpenGl.OpenGl_Structure_updateLayerTransformation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Structure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Structure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Structure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


OpenGl_Structure_swigregister = _OpenGl.OpenGl_Structure_swigregister
OpenGl_Structure_swigregister(OpenGl_Structure)

def OpenGl_Structure_get_type_name(*args):
    """
    OpenGl_Structure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Structure_get_type_name(*args)

def OpenGl_Structure_get_type_descriptor(*args):
    """
    OpenGl_Structure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Structure_get_type_descriptor(*args)

class OpenGl_StateInterface(object):
    """Defines interface for OpenGL state."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Index(self, *args):
        """
        Index(OpenGl_StateInterface self) -> Standard_Size

        Returns current state index.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_StateInterface_Index(self, *args)


    def Update(self, *args):
        """
        Update(OpenGl_StateInterface self)

        Increment current state.


        """
        return _OpenGl.OpenGl_StateInterface_Update(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_StateInterface
OpenGl_StateInterface_swigregister = _OpenGl.OpenGl_StateInterface_swigregister
OpenGl_StateInterface_swigregister(OpenGl_StateInterface)

class OpenGl_TmplCore43_OpenGl_GlCore42(object):
    """OpenGL 4.3 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.3 definition."""
        this = _OpenGl.new_OpenGl_TmplCore43_OpenGl_GlCore42()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore43_OpenGl_GlCore42
OpenGl_TmplCore43_OpenGl_GlCore42_swigregister = _OpenGl.OpenGl_TmplCore43_OpenGl_GlCore42_swigregister
OpenGl_TmplCore43_OpenGl_GlCore42_swigregister(OpenGl_TmplCore43_OpenGl_GlCore42)


try:
	OpenGl_GlCore43 = OpenGl_TmplCore43_OpenGl_GlCore42
except NameError:
	pass # does not exist, probably ignored

class OpenGl_PrimitiveArray(object):
    """Class for rendering of arbitrary primitive array."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    DRAW_MODE_NONE = _OpenGl.OpenGl_PrimitiveArray_DRAW_MODE_NONE

    def __init__(self, *args):
        """
        __init__(OpenGl_PrimitiveArray self, OpenGl_GraphicDriver theDriver) -> OpenGl_PrimitiveArray
        __init__(OpenGl_PrimitiveArray self, OpenGl_GraphicDriver theDriver, Graphic3d_TypeOfPrimitiveArray const theType, Handle_Graphic3d_IndexBuffer theIndices, Handle_Graphic3d_Buffer theAttribs, Handle_Graphic3d_BoundBuffer theBounds) -> OpenGl_PrimitiveArray

        Default constructor

        :type theDriver: OCC.wrapper.OpenGl.OpenGl_GraphicDriver
        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfPrimitiveArray
        :type theIndices: OCC.wrapper.Graphic3d.Handle_Graphic3d_IndexBuffer
        :type theAttribs: OCC.wrapper.Graphic3d.Handle_Graphic3d_Buffer
        :type theBounds: OCC.wrapper.Graphic3d.Handle_Graphic3d_BoundBuffer

        """
        this = _OpenGl.new_OpenGl_PrimitiveArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Render(self, *args):
        """
        Render(OpenGl_PrimitiveArray self, Handle_OpenGl_Workspace theWorkspace)

        Render primitives to the window

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_PrimitiveArray_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_PrimitiveArray self, OpenGl_Context theContext)

        Release OpenGL resources (VBOs)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_PrimitiveArray_Release(self, *args)


    def IsInitialized(self, *args):
        """
        IsInitialized(OpenGl_PrimitiveArray self) -> Standard_Boolean

        Return true if VBOs initialization has been performed.
        VBO initialization is performed during first Render() call.
        Notice that this flag does not indicate VBOs validity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_PrimitiveArray_IsInitialized(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(OpenGl_PrimitiveArray self)

        Invalidate VBO content without destruction.


        """
        return _OpenGl.OpenGl_PrimitiveArray_Invalidate(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(OpenGl_PrimitiveArray self) -> GLint

        @return primitive type (GL_LINES, GL_TRIANGLES and others)

        :rtype: GLint

        """
        return _OpenGl.OpenGl_PrimitiveArray_DrawMode(self, *args)


    def IsFillDrawMode(self, *args):
        """
        IsFillDrawMode(OpenGl_PrimitiveArray self) -> Standard_Boolean

        Return TRUE if primitive type generates shaded triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_PrimitiveArray_IsFillDrawMode(self, *args)


    def Indices(self, *args):
        """
        @return indices array

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_IndexBuffer

        """
        res = _OpenGl.OpenGl_PrimitiveArray_Indices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Attributes(self, *args):
        """
        @return attributes array

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Buffer

        """
        res = _OpenGl.OpenGl_PrimitiveArray_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bounds(self, *args):
        """
        @return bounds array

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_BoundBuffer

        """
        res = _OpenGl.OpenGl_PrimitiveArray_Bounds(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetUID(self, *args):
        """
        GetUID(OpenGl_PrimitiveArray self) -> Standard_Size

        Returns unique ID of primitive array. 

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_PrimitiveArray_GetUID(self, *args)


    def InitBuffers(self, *args):
        """
        InitBuffers(OpenGl_PrimitiveArray self, Handle_OpenGl_Context theContext, Graphic3d_TypeOfPrimitiveArray const theType, Handle_Graphic3d_IndexBuffer theIndices, Handle_Graphic3d_Buffer theAttribs, Handle_Graphic3d_BoundBuffer theBounds)

        Initialize indices, attributes and bounds with new data.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfPrimitiveArray
        :type theIndices: OCC.wrapper.Graphic3d.Handle_Graphic3d_IndexBuffer
        :type theAttribs: OCC.wrapper.Graphic3d.Handle_Graphic3d_Buffer
        :type theBounds: OCC.wrapper.Graphic3d.Handle_Graphic3d_BoundBuffer

        """
        return _OpenGl.OpenGl_PrimitiveArray_InitBuffers(self, *args)


    def IndexVbo(self, *args):
        """
        Returns index VBO.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_VertexBuffer

        """
        res = _OpenGl.OpenGl_PrimitiveArray_IndexVbo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AttributesVbo(self, *args):
        """
        Returns attributes VBO.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_VertexBuffer

        """
        res = _OpenGl.OpenGl_PrimitiveArray_AttributesVbo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_PrimitiveArray
OpenGl_PrimitiveArray_swigregister = _OpenGl.OpenGl_PrimitiveArray_swigregister
OpenGl_PrimitiveArray_swigregister(OpenGl_PrimitiveArray)

class OpenGl_VertexBuffer(OpenGl_Resource):
    """
    Vertex Buffer Object - is a general storage object for vertex attributes (position, normal, color).
    Notice that you should use OpenGl_IndexBuffer specialization for array of indices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_VertexBuffer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_VertexBuffer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_VertexBuffer self) -> OpenGl_VertexBuffer

        Create uninitialized VBO.


        """
        this = _OpenGl.new_OpenGl_VertexBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetTarget(self, *args):
        """
        GetTarget(OpenGl_VertexBuffer self) -> GLenum

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_VertexBuffer_GetTarget(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_VertexBuffer self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_IsValid(self, *args)


    def GetComponentsNb(self, *args):
        """
        GetComponentsNb(OpenGl_VertexBuffer self) -> GLuint

        @return the number of components per generic vertex attribute.

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_VertexBuffer_GetComponentsNb(self, *args)


    def GetElemsNb(self, *args):
        """
        GetElemsNb(OpenGl_VertexBuffer self) -> GLsizei

        @return number of vertex attributes / number of vertices.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_VertexBuffer_GetElemsNb(self, *args)


    def GetDataType(self, *args):
        """
        GetDataType(OpenGl_VertexBuffer self) -> GLenum

        @return data type of each component in the array.

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_VertexBuffer_GetDataType(self, *args)


    def GetDataOffset(self, *args):
        """
        GetDataOffset(OpenGl_VertexBuffer self) -> GLubyte *

        @return offset to data, NULL by default

        :rtype: GLubyte

        """
        return _OpenGl.OpenGl_VertexBuffer_GetDataOffset(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO name (id) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_Create(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_VertexBuffer self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_Release(self, *args)


    def Bind(self, *args):
        """
        Bind(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_Unbind(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        @param theComponentsNb - specifies the number of components per generic vertex attribute; must be 1, 2, 3, or 4;
        @param theElemsNb      - elements count;
        @param theData         - pointer to GLubyte data (indices/colors etc.).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_Init(self, *args)


    def SubData(self, *args):
        """
        SubData(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        SubData(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLuint const * theData) -> bool
        SubData(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLushort const * theData) -> bool
        SubData(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        Function replaces portion of data within this VBO using glBufferSubData().
        The VBO should be initialized before call.
        @param theElemFrom element id from which replace buffer data (>=0);
        @param theElemsNb  elements count (theElemFrom + theElemsNb <= GetElemsNb());
        @param theData     pointer to GLubyte data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_SubData(self, *args)


    def BindVertexAttrib(self, *args):
        """
        BindVertexAttrib(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Bind this VBO to active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.OpenGl_VertexBuffer_BindVertexAttrib(self, *args)


    def UnbindVertexAttrib(self, *args):
        """
        UnbindVertexAttrib(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Unbind any VBO from active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.OpenGl_VertexBuffer_UnbindVertexAttrib(self, *args)


    def BindAttribute(self, *args):
        """
        BindAttribute(OpenGl_VertexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Bind this VBO and enable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theGlCtx - handle to bound GL context;
        @param theMode  - array mode (GL_VERTEX_ARRAY, GL_NORMAL_ARRAY, GL_COLOR_ARRAY, GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.OpenGl_VertexBuffer_BindAttribute(self, *args)


    def UnbindAttribute(self, *args):
        """
        UnbindAttribute(OpenGl_VertexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Unbind this VBO and disable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theCtx handle to bound GL context
        @param theMode  array mode

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.OpenGl_VertexBuffer_UnbindAttribute(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_VertexBuffer self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_VertexBuffer_EstimatedDataSize(self, *args)


    def sizeOfGlType(*args):
        """
        sizeOfGlType(GLenum const theType) -> size_t

        @return size of specified GL type

        :type theType: GLenum
        :rtype: size_t

        """
        return _OpenGl.OpenGl_VertexBuffer_sizeOfGlType(*args)

    sizeOfGlType = staticmethod(sizeOfGlType)

    def init(self, *args):
        """
        init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool
        init(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Initialize buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_init(self, *args)


    def subData(self, *args):
        """
        subData(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_subData(self, *args)


    def bindAttribute(*args):
        """
        bindAttribute(Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

        Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using bindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
        :type theNbComp: GLint
        :type theDataType: GLenum
        :type theStride: GLsizei
        :type theOffset: GLvoid

        """
        return _OpenGl.OpenGl_VertexBuffer_bindAttribute(*args)

    bindAttribute = staticmethod(bindAttribute)

    def unbindAttribute(*args):
        """
        unbindAttribute(Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

        Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using unbindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.OpenGl_VertexBuffer_unbindAttribute(*args)

    unbindAttribute = staticmethod(unbindAttribute)

    def HasColorAttribute(self, *args):
        """
        HasColorAttribute(OpenGl_VertexBuffer self) -> bool

        @return true if buffer contains per-vertex color attribute

        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_HasColorAttribute(self, *args)


    def HasNormalAttribute(self, *args):
        """
        HasNormalAttribute(OpenGl_VertexBuffer self) -> bool

        @return true if buffer contains per-vertex normal attribute

        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBuffer_HasNormalAttribute(self, *args)


    def BindAllAttributes(self, *args):
        """
        BindAllAttributes(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind all vertex attributes to active program OpenGl_Context::ActiveProgram() or for FFP.
        Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_BindAllAttributes(self, *args)


    def BindPositionAttribute(self, *args):
        """
        BindPositionAttribute(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind vertex position attribute only. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_BindPositionAttribute(self, *args)


    def UnbindAllAttributes(self, *args):
        """
        UnbindAllAttributes(OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind all vertex attributes. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBuffer_UnbindAllAttributes(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_VertexBuffer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_VertexBuffer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_VertexBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_VertexBuffer
OpenGl_VertexBuffer_swigregister = _OpenGl.OpenGl_VertexBuffer_swigregister
OpenGl_VertexBuffer_swigregister(OpenGl_VertexBuffer)

def OpenGl_VertexBuffer_sizeOfGlType(*args):
    """
    OpenGl_VertexBuffer_sizeOfGlType(GLenum const theType) -> size_t

    @return size of specified GL type

    :type theType: GLenum
    :rtype: size_t

    """
    return _OpenGl.OpenGl_VertexBuffer_sizeOfGlType(*args)

def OpenGl_VertexBuffer_bindAttribute(*args):
    """
    OpenGl_VertexBuffer_bindAttribute(Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

    Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
    or for FFP using bindFixed() when no program bound.

    :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
    :type theNbComp: GLint
    :type theDataType: GLenum
    :type theStride: GLsizei
    :type theOffset: GLvoid

    """
    return _OpenGl.OpenGl_VertexBuffer_bindAttribute(*args)

def OpenGl_VertexBuffer_unbindAttribute(*args):
    """
    OpenGl_VertexBuffer_unbindAttribute(Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

    Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
    or for FFP using unbindFixed() when no program bound.

    :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

    """
    return _OpenGl.OpenGl_VertexBuffer_unbindAttribute(*args)

def OpenGl_VertexBuffer_get_type_name(*args):
    """
    OpenGl_VertexBuffer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_VertexBuffer_get_type_name(*args)

def OpenGl_VertexBuffer_get_type_descriptor(*args):
    """
    OpenGl_VertexBuffer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_VertexBuffer_get_type_descriptor(*args)

class OpenGl_Text(object):
    """Text rendering"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetPosition(self, *args):
        """
        SetPosition(OpenGl_Text self, NCollection_Vec3_Standard_ShortReal thePoint)

        Setup new position

        :type thePoint: OCC.wrapper.OpenGl.OpenGl_Vec3

        """
        return _OpenGl.OpenGl_Text_SetPosition(self, *args)


    def SetFontSize(self, *args):
        """
        SetFontSize(OpenGl_Text self, Handle_OpenGl_Context theContext, Standard_Integer const theFontSize)

        Setup new font size

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFontSize: int

        """
        return _OpenGl.OpenGl_Text_SetFontSize(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_Text self, OpenGl_Context theContext)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Text_Release(self, *args)


    def __init__(self, *args):
        """
        __init__(OpenGl_Text self, Standard_Utf8Char const * theText, NCollection_Vec3_Standard_ShortReal thePoint, OpenGl_TextParam const & theParams) -> OpenGl_Text
        __init__(OpenGl_Text self, Standard_Utf8Char const * theText, gp_Ax2 theOrientation, OpenGl_TextParam const & theParams, bool const theHasOwnAnchor=True) -> OpenGl_Text
        __init__(OpenGl_Text self) -> OpenGl_Text

        Empty constructor


        """
        this = _OpenGl.new_OpenGl_Text(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FontKey(*args):
        """
        FontKey(OpenGl_AspectText theAspect, Standard_Integer const theHeight, unsigned int const theResolution) -> TCollection_AsciiString

        Create key for shared resource

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :type theHeight: int
        :type theResolution: const unsigned int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.OpenGl_Text_FontKey(*args)

    FontKey = staticmethod(FontKey)

    def FindFont(*args):
        """
        FindFont(Handle_OpenGl_Context theCtx, OpenGl_AspectText theAspect, Standard_Integer const theHeight, unsigned int const theResolution, TCollection_AsciiString theKey) -> Handle_OpenGl_Font

        Find shared resource for specified font or initialize new one

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :type theHeight: int
        :type theResolution: const unsigned int
        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Font

        """
        return _OpenGl.OpenGl_Text_FindFont(*args)

    FindFont = staticmethod(FindFont)

    def StringSize(*args):
        """
        StringSize(Handle_OpenGl_Context theCtx, NCollection_UtfString_Standard_Utf8Char theText, OpenGl_AspectText theTextAspect, OpenGl_TextParam const & theParams, unsigned int const theResolution)

        Compute text width

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theText: OCC.wrapper.NCollection.NCollection_String
        :type theTextAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :type theParams: OCC.wrapper.OpenGl.OpenGl_TextParam
        :type theResolution: const unsigned int
        :type theWidth: float
        :type theAscent: float
        :type theDescent: float

        """
        return _OpenGl.OpenGl_Text_StringSize(*args)

    StringSize = staticmethod(StringSize)

    def Init(self, *args):
        """
        Init(OpenGl_Text self, Handle_OpenGl_Context theCtx, Standard_Utf8Char const * theText, NCollection_Vec3_Standard_ShortReal thePoint)
        Init(OpenGl_Text self, Handle_OpenGl_Context theCtx, Standard_Utf8Char const * theText, NCollection_Vec3_Standard_ShortReal thePoint, OpenGl_TextParam const & theParams)
        Init(OpenGl_Text self, Handle_OpenGl_Context theCtx, TCollection_ExtendedString theText, NCollection_Vec2_Standard_ShortReal thePoint, OpenGl_TextParam const & theParams)

        Setup new string and parameters

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type thePoint: OCC.wrapper.OpenGl.OpenGl_Vec2
        :type theParams: OCC.wrapper.OpenGl.OpenGl_TextParam

        """
        return _OpenGl.OpenGl_Text_Init(self, *args)


    def Render(self, *args):
        """
        Render(OpenGl_Text self, Handle_OpenGl_Workspace theWorkspace)
        Render(OpenGl_Text self, Handle_OpenGl_Context theCtx, OpenGl_AspectText theTextAspect, unsigned int const theResolution)

        Perform rendering

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :type theResolution: const unsigned int

        """
        return _OpenGl.OpenGl_Text_Render(self, *args)

OpenGl_Text_swigregister = _OpenGl.OpenGl_Text_swigregister
OpenGl_Text_swigregister(OpenGl_Text)

def OpenGl_Text_FontKey(*args):
    """
    OpenGl_Text_FontKey(OpenGl_AspectText theAspect, Standard_Integer const theHeight, unsigned int const theResolution) -> TCollection_AsciiString

    Create key for shared resource

    :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
    :type theHeight: int
    :type theResolution: const unsigned int
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _OpenGl.OpenGl_Text_FontKey(*args)

def OpenGl_Text_FindFont(*args):
    """
    OpenGl_Text_FindFont(Handle_OpenGl_Context theCtx, OpenGl_AspectText theAspect, Standard_Integer const theHeight, unsigned int const theResolution, TCollection_AsciiString theKey) -> Handle_OpenGl_Font

    Find shared resource for specified font or initialize new one

    :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
    :type theHeight: int
    :type theResolution: const unsigned int
    :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Font

    """
    return _OpenGl.OpenGl_Text_FindFont(*args)

def OpenGl_Text_StringSize(*args):
    """
    OpenGl_Text_StringSize(Handle_OpenGl_Context theCtx, NCollection_UtfString_Standard_Utf8Char theText, OpenGl_AspectText theTextAspect, OpenGl_TextParam const & theParams, unsigned int const theResolution)

    Compute text width

    :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theText: OCC.wrapper.NCollection.NCollection_String
    :type theTextAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
    :type theParams: OCC.wrapper.OpenGl.OpenGl_TextParam
    :type theResolution: const unsigned int
    :type theWidth: float
    :type theAscent: float
    :type theDescent: float

    """
    return _OpenGl.OpenGl_Text_StringSize(*args)

class OpenGl_PointSprite(OpenGl_Texture):
    """
    Point sprite resource. On modern hardware it will be texture with extra parameters.
    On ancient hardware sprites will be drawn using bitmaps.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_PointSprite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_PointSprite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_PointSprite self, TCollection_AsciiString theResourceId) -> OpenGl_PointSprite

        Create uninitialized resource.

        :type theResourceId: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OpenGl.new_OpenGl_PointSprite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Release(self, *args):
        """
        Release(OpenGl_PointSprite self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_PointSprite_Release(self, *args)


    def IsDisplayList(self, *args):
        """
        IsDisplayList(OpenGl_PointSprite self) -> Standard_Boolean

        @return true if this is display list bitmap

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_PointSprite_IsDisplayList(self, *args)


    def DrawBitmap(self, *args):
        """
        DrawBitmap(OpenGl_PointSprite self, Handle_OpenGl_Context theCtx)

        Draw sprite using glBitmap.
        Please call glRasterPos3fv() before to setup sprite position.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_PointSprite_DrawBitmap(self, *args)


    def SetDisplayList(self, *args):
        """
        SetDisplayList(OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, GLuint const theBitmapList)

        Initialize point sprite as display list

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theBitmapList: GLuint

        """
        return _OpenGl.OpenGl_PointSprite_SetDisplayList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_PointSprite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_PointSprite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_PointSprite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_PointSprite
OpenGl_PointSprite_swigregister = _OpenGl.OpenGl_PointSprite_swigregister
OpenGl_PointSprite_swigregister(OpenGl_PointSprite)

def OpenGl_PointSprite_get_type_name(*args):
    """
    OpenGl_PointSprite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_PointSprite_get_type_name(*args)

def OpenGl_PointSprite_get_type_descriptor(*args):
    """
    OpenGl_PointSprite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_PointSprite_get_type_descriptor(*args)

class OpenGl_Layer(Standard.Standard_Transient):
    """Presentations list sorted within priorities."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Layer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Layer(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Layer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Layer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Layer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FrustumCullingBVHBuilder(self, *args):
        """
        Returns BVH tree builder for frustom culling.

        :rtype: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        res = _OpenGl.OpenGl_Layer_FrustumCullingBVHBuilder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFrustumCullingBVHBuilder(self, *args):
        """
        SetFrustumCullingBVHBuilder(OpenGl_Layer self, Handle_Select3D_BVHBuilder3d theBuilder)

        Assigns BVH tree builder for frustom culling.

        :type theBuilder: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        return _OpenGl.OpenGl_Layer_SetFrustumCullingBVHBuilder(self, *args)


    def IsImmediate(self, *args):
        """
        IsImmediate(OpenGl_Layer self) -> Standard_Boolean

        Return true if layer was marked with immediate flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Layer_IsImmediate(self, *args)


    def LayerSettings(self, *args):
        """
        Returns settings of the layer object.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        res = _OpenGl.OpenGl_Layer_LayerSettings(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbStructures(self, *args):
        """
        NbStructures(OpenGl_Layer self) -> Standard_Integer

        @return the number of structures

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Layer_NbStructures(self, *args)


    def NbStructuresNotCulled(self, *args):
        """
        NbStructuresNotCulled(OpenGl_Layer self) -> Standard_Integer

        Number of NOT culled structures in the layer.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Layer_NbStructuresNotCulled(self, *args)


    def NbPriorities(self, *args):
        """
        NbPriorities(OpenGl_Layer self) -> Standard_Integer

        Returns the number of available priority levels

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Layer_NbPriorities(self, *args)


    def ArrayOfStructures(self, *args):
        """
        Returns array of OpenGL structures.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ArrayOfIndexedMapOfStructure

        """
        res = _OpenGl.OpenGl_Layer_ArrayOfStructures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InvalidateBoundingBox(self, *args):
        """
        InvalidateBoundingBox(OpenGl_Layer self)

        Marks cached bounding box as obsolete.


        """
        return _OpenGl.OpenGl_Layer_InvalidateBoundingBox(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(OpenGl_Layer self) -> bool

        Returns TRUE if layer is empty or has been discarded entirely by culling test.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Layer_IsCulled(self, *args)


    def NbOfTransformPersistenceObjects(self, *args):
        """
        NbOfTransformPersistenceObjects(OpenGl_Layer self) -> Standard_Integer

        Returns number of transform persistence objects.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Layer_NbOfTransformPersistenceObjects(self, *args)


    def CullableStructuresBVH(self, *args):
        """
        Returns set of OpenGl_Structures structures for building BVH tree.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHClipPrimitiveSet

        """
        res = _OpenGl.OpenGl_Layer_CullableStructuresBVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CullableTrsfPersStructuresBVH(self, *args):
        """
        Returns set of transform persistent OpenGl_Structures for building BVH tree.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet

        """
        res = _OpenGl.OpenGl_Layer_CullableTrsfPersStructuresBVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NonCullableStructures(self, *args):
        """
        Returns indexed map of always rendered structures.

        :rtype: OCC.wrapper.OpenGl.NCollection_IndexedMap_OpenGl_Structure

        """
        res = _OpenGl.OpenGl_Layer_NonCullableStructures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Layer
OpenGl_Layer_swigregister = _OpenGl.OpenGl_Layer_swigregister
OpenGl_Layer_swigregister(OpenGl_Layer)

def OpenGl_Layer_get_type_name(*args):
    """
    OpenGl_Layer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Layer_get_type_name(*args)

def OpenGl_Layer_get_type_descriptor(*args):
    """
    OpenGl_Layer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Layer_get_type_descriptor(*args)

class OpenGl_TextureSet(Standard.Standard_Transient):
    """Class holding array of textures to be mapped as a set."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_TextureSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_TextureSet(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_TextureSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_TextureSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_TextureSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_TextureSet self) -> OpenGl_TextureSet
        __init__(OpenGl_TextureSet self, Standard_Integer theNbTextures) -> OpenGl_TextureSet
        __init__(OpenGl_TextureSet self, Handle_OpenGl_Texture theTexture) -> OpenGl_TextureSet

        Constructor for a single texture.

        :type theTexture: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        this = _OpenGl.new_OpenGl_TextureSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(OpenGl_TextureSet self) -> Standard_Boolean

        Return TRUE if texture array is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_TextureSet_IsEmpty(self, *args)


    def Size(self, *args):
        """
        Size(OpenGl_TextureSet self) -> Standard_Integer

        Return number of textures.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_TextureSet_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(OpenGl_TextureSet self) -> Standard_Integer

        Return the lower index in texture set.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_TextureSet_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(OpenGl_TextureSet self) -> Standard_Integer

        Return the upper index in texture set.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_TextureSet_Upper(self, *args)


    def First(self, *args):
        """
        Return the first texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.OpenGl_TextureSet_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(OpenGl_TextureSet self) -> Handle_OpenGl_Texture

        Return the first texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        return _OpenGl.OpenGl_TextureSet_ChangeFirst(self, *args)


    def Value(self, *args):
        """
        Return the texture at specified position within [0, Size()) range.

        :type theIndex: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.OpenGl_TextureSet_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(OpenGl_TextureSet self, Standard_Integer theIndex) -> Handle_OpenGl_Texture

        Return the texture at specified position within [0, Size()) range.

        :type theIndex: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        return _OpenGl.OpenGl_TextureSet_ChangeValue(self, *args)


    def IsModulate(self, *args):
        """
        IsModulate(OpenGl_TextureSet self) -> bool

        Return TRUE if texture color modulation has been enabled for the first texture
        or if texture is not set at all.

        :rtype: bool

        """
        return _OpenGl.OpenGl_TextureSet_IsModulate(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_TextureSet
OpenGl_TextureSet_swigregister = _OpenGl.OpenGl_TextureSet_swigregister
OpenGl_TextureSet_swigregister(OpenGl_TextureSet)

def OpenGl_TextureSet_get_type_name(*args):
    """
    OpenGl_TextureSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_TextureSet_get_type_name(*args)

def OpenGl_TextureSet_get_type_descriptor(*args):
    """
    OpenGl_TextureSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_TextureSet_get_type_descriptor(*args)

class OpenGl_FrameStats(Standard.Standard_Transient):
    """Class storing the frame statistics."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_FrameStats
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_FrameStats(self) 
            return h

    Counter_NbLayers = _OpenGl.OpenGl_FrameStats_Counter_NbLayers
    Counter_NbLayersNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbLayersNotCulled
    Counter_NbStructs = _OpenGl.OpenGl_FrameStats_Counter_NbStructs
    Counter_NbStructsNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbStructsNotCulled
    Counter_NbGroupsNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbGroupsNotCulled
    Counter_NbElemsNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbElemsNotCulled
    Counter_NbElemsFillNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbElemsFillNotCulled
    Counter_NbElemsLineNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbElemsLineNotCulled
    Counter_NbElemsPointNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbElemsPointNotCulled
    Counter_NbElemsTextNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbElemsTextNotCulled
    Counter_NbTrianglesNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbTrianglesNotCulled
    Counter_NbPointsNotCulled = _OpenGl.OpenGl_FrameStats_Counter_NbPointsNotCulled
    Counter_EstimatedBytesGeom = _OpenGl.OpenGl_FrameStats_Counter_EstimatedBytesGeom
    Counter_EstimatedBytesFbos = _OpenGl.OpenGl_FrameStats_Counter_EstimatedBytesFbos
    Counter_EstimatedBytesTextures = _OpenGl.OpenGl_FrameStats_Counter_EstimatedBytesTextures
    Counter_NB = _OpenGl.OpenGl_FrameStats_Counter_NB

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_FrameStats_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_FrameStats_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_FrameStats_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_FrameStats self) -> OpenGl_FrameStats

        Default constructor.


        """
        this = _OpenGl.new_OpenGl_FrameStats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def UpdateInterval(self, *args):
        """
        UpdateInterval(OpenGl_FrameStats self) -> Standard_Real

        Returns interval in seconds for updating meters across several frames; 1 second by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.OpenGl_FrameStats_UpdateInterval(self, *args)


    def SetUpdateInterval(self, *args):
        """
        SetUpdateInterval(OpenGl_FrameStats self, Standard_Real theInterval)

        Sets interval in seconds for updating values.

        :type theInterval: float

        """
        return _OpenGl.OpenGl_FrameStats_SetUpdateInterval(self, *args)


    def IsLongLineFormat(self, *args):
        """
        IsLongLineFormat(OpenGl_FrameStats self) -> Standard_Boolean

        Prefer longer lines over more greater of lines.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameStats_IsLongLineFormat(self, *args)


    def SetLongLineFormat(self, *args):
        """
        SetLongLineFormat(OpenGl_FrameStats self, Standard_Boolean theValue)

        Set if format should prefer longer lines over greater number of lines.

        :type theValue: bool

        """
        return _OpenGl.OpenGl_FrameStats_SetLongLineFormat(self, *args)


    def FrameStart(self, *args):
        """
        FrameStart(OpenGl_FrameStats self, Handle_OpenGl_Workspace theWorkspace)

        Frame redraw started.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_FrameStats_FrameStart(self, *args)


    def FrameEnd(self, *args):
        """
        FrameEnd(OpenGl_FrameStats self, Handle_OpenGl_Workspace theWorkspace)

        Frame redraw finished.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_FrameStats_FrameEnd(self, *args)


    def FormatStats(self, *args):
        """
        FormatStats(OpenGl_FrameStats self, Graphic3d_RenderingParams::PerfCounters theFlags) -> TCollection_AsciiString

        Returns formatted string.

        :type theFlags: PerfCounters
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.OpenGl_FrameStats_FormatStats(self, *args)


    def FrameDuration(self, *args):
        """
        FrameDuration(OpenGl_FrameStats self) -> Standard_Real

        Returns duration of the last frame in seconds.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.OpenGl_FrameStats_FrameDuration(self, *args)


    def FrameRate(self, *args):
        """
        FrameRate(OpenGl_FrameStats self) -> Standard_Real

        Returns FPS (frames per seconds, elapsed time).
        This number indicates an actual frame rate averaged for several frames within UpdateInterval() duration,
        basing on a real elapsed time between updates.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.OpenGl_FrameStats_FrameRate(self, *args)


    def FrameRateCpu(self, *args):
        """
        FrameRateCpu(OpenGl_FrameStats self) -> Standard_Real

        Returns CPU FPS (frames per seconds, CPU time).
        This number indicates a PREDICTED frame rate,
        basing on CPU elapsed time between updates and NOT real elapsed time (which might include periods of CPU inactivity).
        Number is expected to be greater then actual frame rate returned by FrameRate().
        Values significantly greater actual frame rate indicate that rendering is limited by GPU performance (CPU is stalled in-between),
        while values around actual frame rate indicate rendering being limited by CPU performance (GPU is stalled in-between).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.OpenGl_FrameStats_FrameRateCpu(self, *args)


    def CounterValue(self, *args):
        """
        CounterValue(OpenGl_FrameStats self, OpenGl_FrameStats::Counter theCounter) -> Standard_Size

        Returns value of specified counter, cached between stats updates.
        Should NOT be called between ::FrameStart() and ::FrameEnd() calls.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_FrameStats_CounterValue(self, *args)


    def HasCulledLayers(self, *args):
        """
        HasCulledLayers(OpenGl_FrameStats self) -> Standard_Boolean

        Returns TRUE if some Layers have been culled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameStats_HasCulledLayers(self, *args)


    def HasCulledStructs(self, *args):
        """
        HasCulledStructs(OpenGl_FrameStats self) -> Standard_Boolean

        Returns TRUE if some structures have been culled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameStats_HasCulledStructs(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(OpenGl_FrameStats self, Handle_OpenGl_FrameStats theOther) -> Standard_Boolean

        Returns TRUE if this stats are equal to another.

        :type theOther: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameStats_IsEqual(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(OpenGl_FrameStats self, Handle_OpenGl_FrameStats theOther)

        Copy stats values from another instance

        :type theOther: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats

        """
        return _OpenGl.OpenGl_FrameStats_CopyFrom(self, *args)


    def ChangeCounter(self, *args):
        """
        ChangeCounter(OpenGl_FrameStats self, OpenGl_FrameStats::Counter theCounter) -> Standard_Size &

        Returns value of specified counter for modification, should be called between ::FrameStart() and ::FrameEnd() calls.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_FrameStats_ChangeCounter(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_FrameStats
OpenGl_FrameStats_swigregister = _OpenGl.OpenGl_FrameStats_swigregister
OpenGl_FrameStats_swigregister(OpenGl_FrameStats)

def OpenGl_FrameStats_get_type_name(*args):
    """
    OpenGl_FrameStats_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_FrameStats_get_type_name(*args)

def OpenGl_FrameStats_get_type_descriptor(*args):
    """
    OpenGl_FrameStats_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_FrameStats_get_type_descriptor(*args)

class OpenGl_IndexBuffer(OpenGl_VertexBuffer):
    """Index buffer is just a VBO with special target (GL_ELEMENT_ARRAY_BUFFER)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_IndexBuffer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_IndexBuffer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_IndexBuffer self) -> OpenGl_IndexBuffer

        Index buffer is just a VBO with special target (GL_ELEMENT_ARRAY_BUFFER).
        """
        this = _OpenGl.new_OpenGl_IndexBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetTarget(self, *args):
        """
        GetTarget(OpenGl_IndexBuffer self) -> GLenum

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_IndexBuffer_GetTarget(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_IndexBuffer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_IndexBuffer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_IndexBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_IndexBuffer
OpenGl_IndexBuffer_swigregister = _OpenGl.OpenGl_IndexBuffer_swigregister
OpenGl_IndexBuffer_swigregister(OpenGl_IndexBuffer)

def OpenGl_IndexBuffer_get_type_name(*args):
    """
    OpenGl_IndexBuffer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_IndexBuffer_get_type_name(*args)

def OpenGl_IndexBuffer_get_type_descriptor(*args):
    """
    OpenGl_IndexBuffer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_IndexBuffer_get_type_descriptor(*args)

class OpenGl_FrameBuffer(OpenGl_Resource):
    """
    Class implements FrameBuffer Object (FBO) resource
    intended for off-screen rendering.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_FrameBuffer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_FrameBuffer(self) 
            return h


    def BufferDump(*args):
        """
        BufferDump(Handle_OpenGl_Context theGlCtx, Handle_OpenGl_FrameBuffer theFbo, Image_PixMap theImage, Graphic3d_BufferType theBufferType) -> Standard_Boolean

        Dump content into image.
        @param theGlCtx      bound OpenGL context
        @param theFbo        FBO to dump (or window buffer, if NULL)
        @param theImage      target image
        @param theBufferType buffer type (attachment) to dump
        @return TRUE on success

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer
        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_BufferDump(*args)

    BufferDump = staticmethod(BufferDump)

    def __init__(self, *args):
        """
        __init__(OpenGl_FrameBuffer self) -> OpenGl_FrameBuffer

        Empty constructor


        """
        this = _OpenGl.new_OpenGl_FrameBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Release(self, *args):
        """
        Release(OpenGl_FrameBuffer self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_Release(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(OpenGl_FrameBuffer self) -> GLsizei

        Number of multisampling samples.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_NbSamples(self, *args)


    def NbColorBuffers(self, *args):
        """
        NbColorBuffers(OpenGl_FrameBuffer self) -> GLsizei

        Number of color buffers.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_NbColorBuffers(self, *args)


    def HasColor(self, *args):
        """
        HasColor(OpenGl_FrameBuffer self) -> bool

        Return true if FBO has been created with color attachment.

        :rtype: bool

        """
        return _OpenGl.OpenGl_FrameBuffer_HasColor(self, *args)


    def HasDepth(self, *args):
        """
        HasDepth(OpenGl_FrameBuffer self) -> bool

        Return true if FBO has been created with depth attachment.

        :rtype: bool

        """
        return _OpenGl.OpenGl_FrameBuffer_HasDepth(self, *args)


    def GetSizeX(self, *args):
        """
        GetSizeX(OpenGl_FrameBuffer self) -> GLsizei

        Textures width.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetSizeX(self, *args)


    def GetSizeY(self, *args):
        """
        GetSizeY(OpenGl_FrameBuffer self) -> GLsizei

        Textures height.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetSizeY(self, *args)


    def GetVPSizeX(self, *args):
        """
        GetVPSizeX(OpenGl_FrameBuffer self) -> GLsizei

        Viewport width.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetVPSizeX(self, *args)


    def GetVPSizeY(self, *args):
        """
        GetVPSizeY(OpenGl_FrameBuffer self) -> GLsizei

        Viewport height.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetVPSizeY(self, *args)


    def GetInitVPSizeX(self, *args):
        """
        GetInitVPSizeX(OpenGl_FrameBuffer self) -> GLsizei

        Viewport width.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetInitVPSizeX(self, *args)


    def GetInitVPSizeY(self, *args):
        """
        GetInitVPSizeY(OpenGl_FrameBuffer self) -> GLsizei

        Viewport height.

        :rtype: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_GetInitVPSizeY(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_FrameBuffer self) -> Standard_Boolean

        Returns true if current object was initialized

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_IsValid(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, NCollection_Vector_GLint theColorFormats, Handle_OpenGl_Texture theDepthStencilTexture, GLsizei const theNbSamples=0) -> Standard_Boolean
        Init(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        Init(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, NCollection_Vector_GLint theColorFormats, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean

        Initialize FBO for rendering into single/multiple color buffer and depth textures.
        @param theGlCtx        currently bound OpenGL context
        @param theSizeX        texture width
        @param theSizeY        texture height
        @param theColorFormats list of color texture sized format (0 means no color attachment), e.g. GL_RGBA8
        @param theDepthFormat  depth-stencil texture sized format (0 means no depth attachment), e.g. GL_DEPTH24_STENCIL8
        @param theNbSamples    MSAA number of samples (0 means normal texture)
        @return true on success

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theColorFormats: OCC.wrapper.OpenGl.OpenGl_ColorFormats
        :type theDepthFormat: GLint
        :type theNbSamples: GLsizei
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_Init(self, *args)


    def InitLazy(self, *args):
        """
        InitLazy(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theViewportSizeX, GLsizei const theViewportSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        InitLazy(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theViewportSizeX, GLsizei const theViewportSizeY, NCollection_Vector_GLint theColorFormats, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        InitLazy(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, OpenGl_FrameBuffer theFbo) -> Standard_Boolean

        (Re-)initialize FBO with properties taken from another FBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFbo: OCC.wrapper.OpenGl.OpenGl_FrameBuffer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_InitLazy(self, *args)


    def InitWithRB(self, *args):
        """
        InitWithRB(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLuint const theColorRBufferFromWindow=0) -> Standard_Boolean

        (Re-)initialize FBO with specified dimensions.
        The Render Buffer Objects will be used for Color, Depth and Stencil attachments (as opposite to textures).
        @param theGlCtx       currently bound OpenGL context
        @param theSizeX       render buffer width
        @param theSizeY       render buffer height
        @param theColorFormat color         render buffer sized format, e.g. GL_RGBA8
        @param theDepthFormat depth-stencil render buffer sized format, e.g. GL_DEPTH24_STENCIL8
        @param theColorRBufferFromWindow when specified - should be ID of already initialized RB object, which will be released within this class

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theColorFormat: GLint
        :type theDepthFormat: GLint
        :type theColorRBufferFromWindow: GLuint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_InitWithRB(self, *args)


    def InitWrapper(self, *args):
        """
        InitWrapper(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx) -> Standard_Boolean

        Initialize class from currently bound FBO.
        Retrieved OpenGL objects will not be destroyed on Release.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_FrameBuffer_InitWrapper(self, *args)


    def SetupViewport(self, *args):
        """
        SetupViewport(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Setup viewport to render into FBO

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_SetupViewport(self, *args)


    def ChangeViewport(self, *args):
        """
        ChangeViewport(OpenGl_FrameBuffer self, GLsizei const theVPSizeX, GLsizei const theVPSizeY)

        Override viewport settings

        :type theVPSizeX: GLsizei
        :type theVPSizeY: GLsizei

        """
        return _OpenGl.OpenGl_FrameBuffer_ChangeViewport(self, *args)


    def BindBuffer(self, *args):
        """
        BindBuffer(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for drawing and reading (to render into the texture).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_BindBuffer(self, *args)


    def BindDrawBuffer(self, *args):
        """
        BindDrawBuffer(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for drawing GL_DRAW_FRAMEBUFFER (to render into the texture).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_BindDrawBuffer(self, *args)


    def BindReadBuffer(self, *args):
        """
        BindReadBuffer(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for reading GL_READ_FRAMEBUFFER

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_BindReadBuffer(self, *args)


    def UnbindBuffer(self, *args):
        """
        UnbindBuffer(OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind frame buffer.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameBuffer_UnbindBuffer(self, *args)


    def ColorTexture(self, *args):
        """
        Returns the color texture for the given color buffer index.

        :type theColorBufferIndex: GLint
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.OpenGl_FrameBuffer_ColorTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DepthStencilTexture(self, *args):
        """
        Returns the depth-stencil texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.OpenGl_FrameBuffer_DepthStencilTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ColorRenderBuffer(self, *args):
        """
        ColorRenderBuffer(OpenGl_FrameBuffer self) -> GLuint

        Returns the color Render Buffer.

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_FrameBuffer_ColorRenderBuffer(self, *args)


    def DepthStencilRenderBuffer(self, *args):
        """
        DepthStencilRenderBuffer(OpenGl_FrameBuffer self) -> GLuint

        Returns the depth Render Buffer.

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_FrameBuffer_DepthStencilRenderBuffer(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_FrameBuffer self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_FrameBuffer_EstimatedDataSize(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_FrameBuffer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_FrameBuffer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_FrameBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_FrameBuffer
OpenGl_FrameBuffer_swigregister = _OpenGl.OpenGl_FrameBuffer_swigregister
OpenGl_FrameBuffer_swigregister(OpenGl_FrameBuffer)

def OpenGl_FrameBuffer_BufferDump(*args):
    """
    OpenGl_FrameBuffer_BufferDump(Handle_OpenGl_Context theGlCtx, Handle_OpenGl_FrameBuffer theFbo, Image_PixMap theImage, Graphic3d_BufferType theBufferType) -> Standard_Boolean

    Dump content into image.
    @param theGlCtx      bound OpenGL context
    @param theFbo        FBO to dump (or window buffer, if NULL)
    @param theImage      target image
    @param theBufferType buffer type (attachment) to dump
    @return TRUE on success

    :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
    :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer
    :type theImage: OCC.wrapper.Image.Image_PixMap
    :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _OpenGl.OpenGl_FrameBuffer_BufferDump(*args)

def OpenGl_FrameBuffer_get_type_name(*args):
    """
    OpenGl_FrameBuffer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_FrameBuffer_get_type_name(*args)

def OpenGl_FrameBuffer_get_type_descriptor(*args):
    """
    OpenGl_FrameBuffer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_FrameBuffer_get_type_descriptor(*args)

class OpenGl_TmplCore42_OpenGl_GlCore41Back(object):
    """OpenGL 4.2 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.2 definition."""
        this = _OpenGl.new_OpenGl_TmplCore42_OpenGl_GlCore41Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore42_OpenGl_GlCore41Back
OpenGl_TmplCore42_OpenGl_GlCore41Back_swigregister = _OpenGl.OpenGl_TmplCore42_OpenGl_GlCore41Back_swigregister
OpenGl_TmplCore42_OpenGl_GlCore41Back_swigregister(OpenGl_TmplCore42_OpenGl_GlCore41Back)


try:
	OpenGl_GlCore42Back = OpenGl_TmplCore42_OpenGl_GlCore41Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_Font(OpenGl_Resource):
    """Texture font."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Font
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Font(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Font self, Handle_Font_FTFont theFont, TCollection_AsciiString theKey) -> OpenGl_Font

        Main constructor.

        :type theFont: OCC.wrapper.Font.Handle_Font_FTFont
        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OpenGl.new_OpenGl_Font(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Release(self, *args):
        """
        Release(OpenGl_Font self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Font_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_Font self) -> Standard_Size

        Returns estimated GPU memory usage.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Font_EstimatedDataSize(self, *args)


    def ResourceKey(self, *args):
        """
        @return key of shared resource

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.OpenGl_Font_ResourceKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FTFont(self, *args):
        """
        @return FreeType font instance specified on construction.

        :rtype: OCC.wrapper.Font.Handle_Font_FTFont

        """
        res = _OpenGl.OpenGl_Font_FTFont(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsValid(self, *args):
        """
        IsValid(OpenGl_Font self) -> bool

        @return true if font was loaded successfully.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Font_IsValid(self, *args)


    def WasInitialized(self, *args):
        """
        WasInitialized(OpenGl_Font self) -> bool

        Notice that this method doesn't return initialization success state.
        Use IsValid() instead.
        @return true if initialization was already called.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Font_WasInitialized(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_Font self, Handle_OpenGl_Context theCtx) -> bool

        Initialize GL resources.
        FreeType font instance should be already initialized!

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_Font_Init(self, *args)


    def Ascender(self, *args):
        """
        Ascender(OpenGl_Font self) -> float

        @return vertical distance from the horizontal baseline to the highest character coordinate

        :rtype: float

        """
        return _OpenGl.OpenGl_Font_Ascender(self, *args)


    def Descender(self, *args):
        """
        Descender(OpenGl_Font self) -> float

        @return vertical distance from the horizontal baseline to the lowest character coordinate

        :rtype: float

        """
        return _OpenGl.OpenGl_Font_Descender(self, *args)


    def LineSpacing(self, *args):
        """
        LineSpacing(OpenGl_Font self) -> float

        @return default line spacing (the baseline-to-baseline distance)

        :rtype: float

        """
        return _OpenGl.OpenGl_Font_LineSpacing(self, *args)


    def RenderGlyph(self, *args):
        """
        RenderGlyph(OpenGl_Font self, Handle_OpenGl_Context theCtx, Standard_Utf32Char const theUChar, OpenGl_Font::Tile & theGlyph) -> bool

        Render glyph to texture if not already.
        @param theCtx       active context
        @param theUChar     unicode symbol to render
        @param theGlyph     computed glyph position rectangle, texture ID and UV coordinates

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUChar: OCC.wrapper.Standard.Standard_Utf32Char
        :type theGlyph: Tile
        :rtype: bool

        """
        return _OpenGl.OpenGl_Font_RenderGlyph(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Font_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Font_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Font_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Font
OpenGl_Font_swigregister = _OpenGl.OpenGl_Font_swigregister
OpenGl_Font_swigregister(OpenGl_Font)

def OpenGl_Font_get_type_name(*args):
    """
    OpenGl_Font_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Font_get_type_name(*args)

def OpenGl_Font_get_type_descriptor(*args):
    """
    OpenGl_Font_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Font_get_type_descriptor(*args)

class OpenGl_ShaderManager(Standard.Standard_Transient):
    """This class is responsible for managing shader programs."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_ShaderManager
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_ShaderManager(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_ShaderManager_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_ShaderManager_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_ShaderManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_ShaderManager self, OpenGl_Context theContext) -> OpenGl_ShaderManager

        Creates new empty shader manager.

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        this = _OpenGl.new_OpenGl_ShaderManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def clear(self, *args):
        """
        clear(OpenGl_ShaderManager self)

        Release all resources.


        """
        return _OpenGl.OpenGl_ShaderManager_clear(self, *args)


    def LocalOrigin(self, *args):
        """
        Return local camera transformation.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _OpenGl.OpenGl_ShaderManager_LocalOrigin(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalOrigin(self, *args):
        """
        SetLocalOrigin(OpenGl_ShaderManager self, gp_XYZ theOrigin)

        Setup local camera transformation for compensating float precision issues.

        :type theOrigin: OCC.wrapper.gp.gp_XYZ

        """
        return _OpenGl.OpenGl_ShaderManager_SetLocalOrigin(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_ShaderManager self, Handle_Graphic3d_ShaderProgram theProxy, TCollection_AsciiString theShareKey, Handle_OpenGl_ShaderProgram theProgram) -> Standard_Boolean

        Creates new shader program or re-use shared instance.
        @param theProxy    [IN]  program definition
        @param theShareKey [OUT] sharing key
        @param theProgram  [OUT] OpenGL program
        @return true on success

        :type theProxy: OCC.wrapper.Graphic3d.Handle_Graphic3d_ShaderProgram
        :type theShareKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_Create(self, *args)


    def Unregister(self, *args):
        """
        Unregister(OpenGl_ShaderManager self, TCollection_AsciiString theShareKey, Handle_OpenGl_ShaderProgram theProgram)

        Unregisters specified shader program.

        :type theShareKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_Unregister(self, *args)


    def ShaderPrograms(self, *args):
        """
        Returns list of registered shader programs.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ShaderProgramList

        """
        res = _OpenGl.OpenGl_ShaderManager_ShaderPrograms(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(OpenGl_ShaderManager self) -> Standard_Boolean

        Returns true if no program objects are registered in the manager.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_IsEmpty(self, *args)


    def BindFaceProgram(self, *args):
        """
        BindFaceProgram(OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Standard_Boolean const theEnableEnvMap, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for filled primitives rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theEnableEnvMap: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindFaceProgram(self, *args)


    def BindLineProgram(self, *args):
        """
        BindLineProgram(OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Aspect_TypeOfLine const theLineType, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for line rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theLineType: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindLineProgram(self, *args)


    def BindMarkerProgram(self, *args):
        """
        BindMarkerProgram(OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for point rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindMarkerProgram(self, *args)


    def BindFontProgram(self, *args):
        """
        BindFontProgram(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for rendering alpha-textured font.

        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindFontProgram(self, *args)


    def BindFboBlitProgram(self, *args):
        """
        BindFboBlitProgram(OpenGl_ShaderManager self) -> Standard_Boolean

        Bind program for FBO blit operation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindFboBlitProgram(self, *args)


    def BindOitCompositingProgram(self, *args):
        """
        BindOitCompositingProgram(OpenGl_ShaderManager self, Standard_Boolean const theIsMSAAEnabled) -> Standard_Boolean

        Bind program for blended order-independent transparency buffers compositing.

        :type theIsMSAAEnabled: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindOitCompositingProgram(self, *args)


    def BindStereoProgram(self, *args):
        """
        BindStereoProgram(OpenGl_ShaderManager self, Graphic3d_StereoMode const theStereoMode) -> Standard_Boolean

        Bind program for rendering stereoscopic image.

        :type theStereoMode: OCC.wrapper.Graphic3d.Graphic3d_StereoMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderManager_BindStereoProgram(self, *args)


    def LightSourceState(self, *args):
        """
        Returns current state of OCCT light sources.

        :rtype: OCC.wrapper.OpenGl.OpenGl_LightSourceState

        """
        res = _OpenGl.OpenGl_ShaderManager_LightSourceState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateLightSourceStateTo(self, *args):
        """
        UpdateLightSourceStateTo(OpenGl_ShaderManager self, Handle_Graphic3d_LightSet theLights)

        Updates state of OCCT light sources.

        :type theLights: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        return _OpenGl.OpenGl_ShaderManager_UpdateLightSourceStateTo(self, *args)


    def UpdateLightSourceState(self, *args):
        """
        UpdateLightSourceState(OpenGl_ShaderManager self)

        Invalidate state of OCCT light sources.


        """
        return _OpenGl.OpenGl_ShaderManager_UpdateLightSourceState(self, *args)


    def PushLightSourceState(self, *args):
        """
        PushLightSourceState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT light sources to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushLightSourceState(self, *args)


    def ProjectionState(self, *args):
        """
        Returns current state of OCCT projection transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ProjectionState

        """
        res = _OpenGl.OpenGl_ShaderManager_ProjectionState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateProjectionStateTo(self, *args):
        """
        UpdateProjectionStateTo(OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theProjectionMatrix)

        Updates state of OCCT projection transform.

        :type theProjectionMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_ShaderManager_UpdateProjectionStateTo(self, *args)


    def PushProjectionState(self, *args):
        """
        PushProjectionState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT projection transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushProjectionState(self, *args)


    def ModelWorldState(self, *args):
        """
        Returns current state of OCCT model-world transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ModelWorldState

        """
        res = _OpenGl.OpenGl_ShaderManager_ModelWorldState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateModelWorldStateTo(self, *args):
        """
        UpdateModelWorldStateTo(OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theModelWorldMatrix)

        Updates state of OCCT model-world transform.

        :type theModelWorldMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_ShaderManager_UpdateModelWorldStateTo(self, *args)


    def PushModelWorldState(self, *args):
        """
        PushModelWorldState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT model-world transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushModelWorldState(self, *args)


    def WorldViewState(self, *args):
        """
        Returns current state of OCCT world-view transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_WorldViewState

        """
        res = _OpenGl.OpenGl_ShaderManager_WorldViewState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateWorldViewStateTo(self, *args):
        """
        UpdateWorldViewStateTo(OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theWorldViewMatrix)

        Updates state of OCCT world-view transform.

        :type theWorldViewMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_ShaderManager_UpdateWorldViewStateTo(self, *args)


    def PushWorldViewState(self, *args):
        """
        PushWorldViewState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT world-view transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushWorldViewState(self, *args)


    def UpdateClippingState(self, *args):
        """
        UpdateClippingState(OpenGl_ShaderManager self)

        Updates state of OCCT clipping planes.


        """
        return _OpenGl.OpenGl_ShaderManager_UpdateClippingState(self, *args)


    def RevertClippingState(self, *args):
        """
        RevertClippingState(OpenGl_ShaderManager self)

        Reverts state of OCCT clipping planes.


        """
        return _OpenGl.OpenGl_ShaderManager_RevertClippingState(self, *args)


    def PushClippingState(self, *args):
        """
        PushClippingState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT clipping planes to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushClippingState(self, *args)


    def MaterialState(self, *args):
        """
        Returns current state of material.

        :rtype: OCC.wrapper.OpenGl.OpenGl_MaterialState

        """
        res = _OpenGl.OpenGl_ShaderManager_MaterialState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateMaterialStateTo(self, *args):
        """
        UpdateMaterialStateTo(OpenGl_ShaderManager self, OpenGl_Material const & theFrontMat, OpenGl_Material const & theBackMat, float const theAlphaCutoff, bool const theToDistinguish, bool const theToMapTexture)

        Updates state of material.

        :type theFrontMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theBackMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theAlphaCutoff: const float
        :type theToDistinguish: const bool
        :type theToMapTexture: const bool

        """
        return _OpenGl.OpenGl_ShaderManager_UpdateMaterialStateTo(self, *args)


    def UpdateMaterialState(self, *args):
        """
        UpdateMaterialState(OpenGl_ShaderManager self)

        Updates state of material.


        """
        return _OpenGl.OpenGl_ShaderManager_UpdateMaterialState(self, *args)


    def OitState(self, *args):
        """
        Returns state of OIT uniforms.

        :rtype: OCC.wrapper.OpenGl.OpenGl_OitState

        """
        res = _OpenGl.OpenGl_ShaderManager_OitState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOitState(self, *args):
        """
        SetOitState(OpenGl_ShaderManager self, bool const theToEnableOitWrite, float const theDepthFactor)

        Set the state of OIT rendering pass.
        @param theToEnableOitWrite [in] flag indicating whether the special output should be written for OIT algorithm.
        @param theDepthFactor [in] the scalar factor of depth influence to the fragment's coverage.

        :type theToEnableOitWrite: const bool
        :type theDepthFactor: const float

        """
        return _OpenGl.OpenGl_ShaderManager_SetOitState(self, *args)


    def PushOitState(self, *args):
        """
        PushOitState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes state of OIT uniforms to the specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushOitState(self, *args)


    def PushState(self, *args):
        """
        PushState(OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT graphics parameters to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_ShaderManager_PushState(self, *args)


    def SetContext(self, *args):
        """
        SetContext(OpenGl_ShaderManager self, OpenGl_Context theCtx)

        Overwrites context

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_ShaderManager_SetContext(self, *args)


    def IsSameContext(self, *args):
        """
        IsSameContext(OpenGl_ShaderManager self, OpenGl_Context theCtx) -> bool

        Returns true when provided context is the same as used one by shader manager.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_ShaderManager_IsSameContext(self, *args)


    def ChooseFaceShadingModel(self, *args):
        """
        ChooseFaceShadingModel(OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for filled primitives.
        Fallbacks to FACET model if there are no normal attributes.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_ShaderManager_ChooseFaceShadingModel(self, *args)


    def ChooseLineShadingModel(self, *args):
        """
        ChooseLineShadingModel(OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for line primitives.
        Fallbacks to UNLIT model if there are no normal attributes.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_ShaderManager_ChooseLineShadingModel(self, *args)


    def ChooseMarkerShadingModel(self, *args):
        """
        ChooseMarkerShadingModel(OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for Marker primitives.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_ShaderManager_ChooseMarkerShadingModel(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(OpenGl_ShaderManager self) -> Graphic3d_TypeOfShadingModel

        Returns default Shading Model.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_ShaderManager_ShadingModel(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel const theModel)

        Sets shading model.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_ShaderManager_SetShadingModel(self, *args)


    def SetLastView(self, *args):
        """
        SetLastView(OpenGl_ShaderManager self, OpenGl_View theLastView)

        Sets last view manger used with.
        Helps to handle matrix states in multi-view configurations.

        :type theLastView: OCC.wrapper.OpenGl.OpenGl_View

        """
        return _OpenGl.OpenGl_ShaderManager_SetLastView(self, *args)


    def IsSameView(self, *args):
        """
        IsSameView(OpenGl_ShaderManager self, OpenGl_View theView) -> bool

        Returns true when provided view is the same as cached one.

        :type theView: OCC.wrapper.OpenGl.OpenGl_View
        :rtype: bool

        """
        return _OpenGl.OpenGl_ShaderManager_IsSameView(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_ShaderManager
OpenGl_ShaderManager_swigregister = _OpenGl.OpenGl_ShaderManager_swigregister
OpenGl_ShaderManager_swigregister(OpenGl_ShaderManager)

def OpenGl_ShaderManager_get_type_name(*args):
    """
    OpenGl_ShaderManager_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_ShaderManager_get_type_name(*args)

def OpenGl_ShaderManager_get_type_descriptor(*args):
    """
    OpenGl_ShaderManager_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_ShaderManager_get_type_descriptor(*args)

class OpenGl_CappingPlaneResource(OpenGl_Resource):
    """
    Container of graphical resources for rendering capping plane
    associated to graphical clipping plane.
    This resource holds data necessary for OpenGl_CappingAlgo.
    This object is implemented as OpenGl resource for the following reasons:
    - one instance should be shared between contexts.
    - instance associated to Graphic3d_ClipPlane data by id.
    - should created and released within context (owns OpenGl elements and resources).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_CappingPlaneResource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_CappingPlaneResource(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_CappingPlaneResource self, Handle_Graphic3d_ClipPlane thePlane) -> OpenGl_CappingPlaneResource

        Constructor.
        Create capping plane presentation associated to clipping plane data.
        @param thePlane [in] the plane data.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        this = _OpenGl.new_OpenGl_CappingPlaneResource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Update(self, *args):
        """
        Update(OpenGl_CappingPlaneResource self, Handle_OpenGl_Context theContext, Handle_Graphic3d_AspectFillArea3d theObjAspect)

        Update resource data in the passed context.
        @param theContext   [in] the context
        @param theObjAspect [in] object aspect

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theObjAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.OpenGl_CappingPlaneResource_Update(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_CappingPlaneResource self, OpenGl_Context theContext)

        Release associated OpenGl resources.
        @param theContext [in] the resource context.

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_CappingPlaneResource_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_CappingPlaneResource self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_CappingPlaneResource_EstimatedDataSize(self, *args)


    def Plane(self, *args):
        """
        Return parent clipping plane structure.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        res = _OpenGl.OpenGl_CappingPlaneResource_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AspectFace(self, *args):
        """
        AspectFace(OpenGl_CappingPlaneResource self) -> OpenGl_AspectFace

        @return aspect face for rendering capping surface.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.OpenGl_CappingPlaneResource_AspectFace(self, *args)


    def Orientation(self, *args):
        """
        Orientation(OpenGl_CappingPlaneResource self) -> OpenGl_Matrix const *

        @return evaluated orientation matrix to transform infinite plane.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.OpenGl_CappingPlaneResource_Orientation(self, *args)


    def Primitives(self, *args):
        """
        @return primitive array of vertices to render infinite plane.

        :rtype: OCC.wrapper.OpenGl.OpenGl_PrimitiveArray

        """
        res = _OpenGl.OpenGl_CappingPlaneResource_Primitives(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_CappingPlaneResource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_CappingPlaneResource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_CappingPlaneResource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_CappingPlaneResource
OpenGl_CappingPlaneResource_swigregister = _OpenGl.OpenGl_CappingPlaneResource_swigregister
OpenGl_CappingPlaneResource_swigregister(OpenGl_CappingPlaneResource)

def OpenGl_CappingPlaneResource_get_type_name(*args):
    """
    OpenGl_CappingPlaneResource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_CappingPlaneResource_get_type_name(*args)

def OpenGl_CappingPlaneResource_get_type_descriptor(*args):
    """
    OpenGl_CappingPlaneResource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_CappingPlaneResource_get_type_descriptor(*args)

class OpenGl_ShaderObject(OpenGl_Resource):
    """Wrapper for OpenGL shader object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_ShaderObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_ShaderObject(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_ShaderObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_ShaderObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_ShaderObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_ShaderObject self, GLenum theType) -> OpenGl_ShaderObject

        Creates uninitialized shader object.

        :type theType: GLenum

        """
        this = _OpenGl.new_OpenGl_ShaderObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def LoadSource(self, *args):
        """
        LoadSource(OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theSource) -> Standard_Boolean

        Loads shader source code.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSource: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderObject_LoadSource(self, *args)


    def Compile(self, *args):
        """
        Compile(OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Compiles the shader object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderObject_Compile(self, *args)


    def FetchInfoLog(self, *args):
        """
        FetchInfoLog(OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theLog) -> Standard_Boolean

        Fetches information log of the last compile operation.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLog: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderObject_FetchInfoLog(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Creates new empty shader object of specified type.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderObject_Create(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_ShaderObject self, OpenGl_Context theCtx)

        Destroys shader object.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_ShaderObject_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_ShaderObject self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_ShaderObject_EstimatedDataSize(self, *args)


    def Type(self, *args):
        """
        Type(OpenGl_ShaderObject self) -> GLenum

        Returns type of shader object.

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_ShaderObject_Type(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_ShaderObject
OpenGl_ShaderObject_swigregister = _OpenGl.OpenGl_ShaderObject_swigregister
OpenGl_ShaderObject_swigregister(OpenGl_ShaderObject)

def OpenGl_ShaderObject_get_type_name(*args):
    """
    OpenGl_ShaderObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_ShaderObject_get_type_name(*args)

def OpenGl_ShaderObject_get_type_descriptor(*args):
    """
    OpenGl_ShaderObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_ShaderObject_get_type_descriptor(*args)

class OpenGl_Group(Graphic3d.Graphic3d_Group):
    """Implementation of low-level graphic group."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Group
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Group(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Group self, Handle_Graphic3d_Structure theStruct) -> OpenGl_Group

        Create empty group.
        Will throw exception if not created by OpenGl_Structure.

        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        this = _OpenGl.new_OpenGl_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(OpenGl_Group self, Standard_Boolean const theToUpdateStructureMgr)

        :type theToUpdateStructureMgr: bool

        """
        return _OpenGl.OpenGl_Group_Clear(self, *args)


    def LineAspect(self, *args):
        """
        LineAspect(OpenGl_Group self) -> Handle_Graphic3d_AspectLine3d

        Return line aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        return _OpenGl.OpenGl_Group_LineAspect(self, *args)


    def MarkerAspect(self, *args):
        """
        MarkerAspect(OpenGl_Group self) -> Handle_Graphic3d_AspectMarker3d

        Return marker aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _OpenGl.OpenGl_Group_MarkerAspect(self, *args)


    def FillAreaAspect(self, *args):
        """
        FillAreaAspect(OpenGl_Group self) -> Handle_Graphic3d_AspectFillArea3d

        Return fill area aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.OpenGl_Group_FillAreaAspect(self, *args)


    def TextAspect(self, *args):
        """
        TextAspect(OpenGl_Group self) -> Handle_Graphic3d_AspectText3d

        Return marker aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.OpenGl_Group_TextAspect(self, *args)


    def SetGroupPrimitivesAspect(self, *args):
        """
        SetGroupPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspect)
        SetGroupPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectMarker3d theAspect)
        SetGroupPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectFillArea3d theAspect)
        SetGroupPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectText3d theAspect)

        Update text aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.OpenGl_Group_SetGroupPrimitivesAspect(self, *args)


    def SetPrimitivesAspect(self, *args):
        """
        SetPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspect)
        SetPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectMarker3d theAspect)
        SetPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectFillArea3d theAspect)
        SetPrimitivesAspect(OpenGl_Group self, Handle_Graphic3d_AspectText3d theAspect)

        Append text aspect as an element.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.OpenGl_Group_SetPrimitivesAspect(self, *args)


    def AddPrimitiveArray(self, *args):
        """
        AddPrimitiveArray(OpenGl_Group self, Graphic3d_TypeOfPrimitiveArray const theType, Handle_Graphic3d_IndexBuffer theIndices, Handle_Graphic3d_Buffer theAttribs, Handle_Graphic3d_BoundBuffer theBounds, Standard_Boolean const theToEvalMinMax)

        Add primitive array element

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfPrimitiveArray
        :type theIndices: OCC.wrapper.Graphic3d.Handle_Graphic3d_IndexBuffer
        :type theAttribs: OCC.wrapper.Graphic3d.Handle_Graphic3d_Buffer
        :type theBounds: OCC.wrapper.Graphic3d.Handle_Graphic3d_BoundBuffer
        :type theToEvalMinMax: bool

        """
        return _OpenGl.OpenGl_Group_AddPrimitiveArray(self, *args)


    def Text(self, *args):
        """
        Text(OpenGl_Group self, Standard_CString const theTextUtf, Graphic3d_Vertex thePoint, Standard_Real const theHeight, Standard_Real const theAngle, Graphic3d_TextPath const theTp, Graphic3d_HorizontalTextAlignment const theHta, Graphic3d_VerticalTextAlignment const theVta, Standard_Boolean const theToEvalMinMax)
        Text(OpenGl_Group self, Standard_CString const theTextUtf, gp_Ax2 theOrientation, Standard_Real const theHeight, Standard_Real const theAngle, Graphic3d_TextPath const theTp, Graphic3d_HorizontalTextAlignment const theHTA, Graphic3d_VerticalTextAlignment const theVTA, Standard_Boolean const theToEvalMinMax, Standard_Boolean const theHasOwnAnchor)

        Add text element in 3D space.

        :type theTextUtf: OCC.wrapper.Standard.Standard_CString
        :type theOrientation: OCC.wrapper.gp.gp_Ax2
        :type theHeight: float
        :type theAngle: float
        :type theTp: OCC.wrapper.Graphic3d.Graphic3d_TextPath
        :type theHTA: OCC.wrapper.Graphic3d.Graphic3d_HorizontalTextAlignment
        :type theVTA: OCC.wrapper.Graphic3d.Graphic3d_VerticalTextAlignment
        :type theToEvalMinMax: bool
        :type theHasOwnAnchor: bool

        """
        return _OpenGl.OpenGl_Group_Text(self, *args)


    def SetFlippingOptions(self, *args):
        """
        SetFlippingOptions(OpenGl_Group self, Standard_Boolean const theIsEnabled, gp_Ax2 theRefPlane)

        Add flipping element

        :type theIsEnabled: bool
        :type theRefPlane: OCC.wrapper.gp.gp_Ax2

        """
        return _OpenGl.OpenGl_Group_SetFlippingOptions(self, *args)


    def SetStencilTestOptions(self, *args):
        """
        SetStencilTestOptions(OpenGl_Group self, Standard_Boolean const theIsEnabled)

        Add stencil test element

        :type theIsEnabled: bool

        """
        return _OpenGl.OpenGl_Group_SetStencilTestOptions(self, *args)


    def GlStruct(self, *args):
        """
        GlStruct(OpenGl_Group self) -> OpenGl_Structure

        :rtype: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.OpenGl_Group_GlStruct(self, *args)


    def AddElement(self, *args):
        """
        AddElement(OpenGl_Group self, OpenGl_Element * theElem)

        :type theElem: OCC.wrapper.OpenGl.OpenGl_Element

        """
        return _OpenGl.OpenGl_Group_AddElement(self, *args)


    def Render(self, *args):
        """
        Render(OpenGl_Group self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_Group_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_Group self, Handle_OpenGl_Context theGlCtx)

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Group_Release(self, *args)


    def FirstNode(self, *args):
        """
        FirstNode(OpenGl_Group self) -> OpenGl_ElementNode const *

        Returns first OpenGL element node of the group.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ElementNode

        """
        return _OpenGl.OpenGl_Group_FirstNode(self, *args)


    def AspectFace(self, *args):
        """
        AspectFace(OpenGl_Group self) -> OpenGl_AspectFace

        Returns OpenGL face aspect.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.OpenGl_Group_AspectFace(self, *args)


    def IsRaytracable(self, *args):
        """
        IsRaytracable(OpenGl_Group self) -> Standard_Boolean

        Is the group ray-tracable (contains ray-tracable elements)?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Group_IsRaytracable(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Group_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Group_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


OpenGl_Group_swigregister = _OpenGl.OpenGl_Group_swigregister
OpenGl_Group_swigregister(OpenGl_Group)

def OpenGl_Group_get_type_name(*args):
    """
    OpenGl_Group_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Group_get_type_name(*args)

def OpenGl_Group_get_type_descriptor(*args):
    """
    OpenGl_Group_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Group_get_type_descriptor(*args)

class OpenGl_TextureBufferArb(OpenGl_VertexBuffer):
    """
    Texture Buffer Object.
    This is a special 1D texture that VBO-style initialized.
    The main differences from general 1D texture:
    - no interpolation between field;
    - greater sizes;
    - special sampler object in GLSL shader to access data by index.

    Notice that though TBO is inherited from VBO this is to unify design
    user shouldn't cast it to base class and all really useful methods
    are declared in this class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_TextureBufferArb
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_TextureBufferArb(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_TextureBufferArb_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_TextureBufferArb_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_TextureBufferArb_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_TextureBufferArb self) -> OpenGl_TextureBufferArb

        Create uninitialized TBO.


        """
        this = _OpenGl.new_OpenGl_TextureBufferArb(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetTarget(self, *args):
        """
        GetTarget(OpenGl_TextureBufferArb self) -> GLenum

        Override VBO target

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_TextureBufferArb_GetTarget(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_TextureBufferArb self) -> bool

        Returns true if TBO is valid.
        Notice that no any real GL call is performed!

        :rtype: bool

        """
        return _OpenGl.OpenGl_TextureBufferArb_IsValid(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_TextureBufferArb self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_TextureBufferArb_Release(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO and Texture names (ids) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_TextureBufferArb_Create(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Perform TBO initialization with specified data.
        Existing data will be deleted.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.OpenGl_TextureBufferArb_Init(self, *args)


    def BindTexture(self, *args):
        """
        BindTexture(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TextureUnit const theTextureUnit)

        Bind TBO to specified Texture Unit.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_TextureBufferArb_BindTexture(self, *args)


    def UnbindTexture(self, *args):
        """
        UnbindTexture(OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TextureUnit const theTextureUnit)

        Unbind TBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_TextureBufferArb_UnbindTexture(self, *args)


    def TextureId(self, *args):
        """
        TextureId(OpenGl_TextureBufferArb self) -> GLuint

        Returns name of TBO.

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_TextureBufferArb_TextureId(self, *args)


    def TextureFormat(self, *args):
        """
        TextureFormat(OpenGl_TextureBufferArb self) -> GLenum

        Returns internal texture format.

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_TextureBufferArb_TextureFormat(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_TextureBufferArb
OpenGl_TextureBufferArb_swigregister = _OpenGl.OpenGl_TextureBufferArb_swigregister
OpenGl_TextureBufferArb_swigregister(OpenGl_TextureBufferArb)

def OpenGl_TextureBufferArb_get_type_name(*args):
    """
    OpenGl_TextureBufferArb_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_TextureBufferArb_get_type_name(*args)

def OpenGl_TextureBufferArb_get_type_descriptor(*args):
    """
    OpenGl_TextureBufferArb_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_TextureBufferArb_get_type_descriptor(*args)

class OpenGl_Context(Standard.Standard_Transient):
    """
    This class generalize access to the GL context and available extensions.

    Functions related to specific OpenGL version or extension are grouped into structures which can be accessed as fields of this class.
    The most simple way to check that required functionality is available - is NULL check for the group:
    @code
    if (myContext->core20 != NULL)
    {
    myGlProgram = myContext->core20->glCreateProgram();
    .. do more stuff ..
    }
    else
    {
    .. compatibility with outdated configurations ..
    }
    @endcode

    Current implementation provide access to OpenGL core functionality up to 4.4 version (core12, core13, core14, core15, fields core20)
    as well as several extensions (arbTBO, arbFBO, etc.).

    OpenGL context might be initialized in Core Profile. In this case deprecated functionality become unavailable.
    To make code easily adaptable to wide range of OpenGL versions, function sets related to each version has two kinds of suffixes:
    - "back" for version 3.2+.
    Represents function set for Backward-Compatible Profile.
    Function sets without this suffix represents core profile.
    - "fwd"  for version 3.0-.
    Represents non-deprecated function set of earlier OpenGL versions, which are still available within OpenGL 3.2 Core Profile.
    Function sets without this suffix represents complete list of functions related to specific OpenGL version.

    To select which core** function set should be used in specific case:
    - Determine the minimal OpenGL version required for implemented functionality and use it to access all functions.
    For example, if algorithm requires OpenGL 2.1+, it is better to write core20fwd->glEnable() rather than core11fwd->glEnable() for uniformity.
    - If functionality will work within Core Profile, use function sets with appropriate suffix.
    - Validate minimal requirements at initialization/creation time and omit checks within code where algorithm should be already initialized.
    Properly escape code incompatible with Core Profile. The simplest way to check Core Profile is "if (core11 == NULL)".

    Simplified extensions classification:
    - prefixed with NV, AMD, ATI are vendor-specific (however may be provided by other vendors in some cases);
    - prefixed with EXT are accepted by 2+ vendors;
    - prefixed with ARB are accepted by Architecture Review Board and are candidates
    for inclusion into GL core functionality.
    Some functionality can be represented in several extensions simultaneously.
    In this case developer should be careful because different specification may differ
    in aspects (like enumeration values and error-handling).

    Notice that some systems provide mechanisms to simultaneously incorporate with GL contexts with different capabilities.
    For this reason OpenGl_Context should be initialized and used for each GL context independently.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Context
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Context(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Context_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Context_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Context_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPowerOfTwo(*args):
        """
        GetPowerOfTwo(Standard_Integer const theNumber, Standard_Integer const theThreshold) -> Standard_Integer

        Function for getting power of to number larger or equal to input number.
        @param theNumber    number to 'power of two'
        @param theThreshold upper threshold
        @return power of two number

        :type theNumber: int
        :type theThreshold: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_GetPowerOfTwo(*args)

    GetPowerOfTwo = staticmethod(GetPowerOfTwo)

    def __init__(self, *args):
        """
        __init__(OpenGl_Context self, Handle_OpenGl_Caps theCaps=0) -> OpenGl_Context

        Empty constructor. You should call Init() to perform initialization with bound GL context.

        :type theCaps: OCC.wrapper.OpenGl.Handle_OpenGl_Caps

        """
        this = _OpenGl.new_OpenGl_Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def forcedRelease(self, *args):
        """
        forcedRelease(OpenGl_Context self)

        Release all resources, including shared ones


        """
        return _OpenGl.OpenGl_Context_forcedRelease(self, *args)


    def Share(self, *args):
        """
        Share(OpenGl_Context self, Handle_OpenGl_Context theShareCtx)

        Share GL context resources.
        theShareCtx - handle to context to retrieve handles to shared resources.

        :type theShareCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Context_Share(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_Context self) -> Standard_Boolean

        @return true if this context is valid (has been initialized)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsValid(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_Context self, Standard_Boolean const theIsCoreProfile) -> Standard_Boolean
        Init(OpenGl_Context self, Aspect_Handle const theWindow, Aspect_Handle const theWindowDC, Aspect_RenderingContext const theGContext, Standard_Boolean const theIsCoreProfile) -> Standard_Boolean

        Initialize class from specified window and rendering context. Method should be called only once.
        @return false if OpenGL context can not be bound to specified window

        :type theWindow: OCC.wrapper.Aspect.Aspect_Handle
        :type theWindowDC: OCC.wrapper.Aspect.Aspect_Handle
        :type theGContext: OCC.wrapper.Aspect.Aspect_RenderingContext
        :type theIsCoreProfile: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_Init(self, *args)


    def ReadGlVersion(*args):
        """
        ReadGlVersion()

        Read OpenGL version information from active context.

        :type theGlVerMajor: int
        :type theGlVerMinor: int

        """
        return _OpenGl.OpenGl_Context_ReadGlVersion(*args)

    ReadGlVersion = staticmethod(ReadGlVersion)

    def CheckExtension(*args):
        """
        CheckExtension(char const * theExtName) -> Standard_Boolean
        CheckExtension(char const * theExtString, char const * theExtName) -> Standard_Boolean

        Check if theExtName extension is in extensions string.

        :type theExtString: const char *
        :type theExtName: const char *
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_CheckExtension(*args)

    CheckExtension = staticmethod(CheckExtension)

    def IsGlGreaterEqual(self, *args):
        """
        IsGlGreaterEqual(OpenGl_Context self, Standard_Integer const theVerMajor, Standard_Integer const theVerMinor) -> Standard_Boolean

        @return true if detected GL version is greater or equal to requested one.

        :type theVerMajor: int
        :type theVerMinor: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsGlGreaterEqual(self, *args)


    def VersionMajor(self, *args):
        """
        VersionMajor(OpenGl_Context self) -> Standard_Integer

        Return cached GL version major number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_VersionMajor(self, *args)


    def VersionMinor(self, *args):
        """
        VersionMinor(OpenGl_Context self) -> Standard_Integer

        Return cached GL version minor number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_VersionMinor(self, *args)


    def Functions(self, *args):
        """
        Functions(OpenGl_Context self) -> OpenGl_GlFunctions const *

        Access entire map of loaded OpenGL functions.

        :rtype: OCC.wrapper.OpenGl.OpenGl_GlFunctions

        """
        return _OpenGl.OpenGl_Context_Functions(self, *args)


    def ResetErrors(self, *args):
        """
        ResetErrors(OpenGl_Context self, bool const theToPrintErrors=False) -> bool

        Clean up errors stack for this GL context (glGetError() in loop).
        @return true if some error has been cleared

        :type theToPrintErrors: const bool
        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_ResetErrors(self, *args)


    def IsCurrent(self, *args):
        """
        IsCurrent(OpenGl_Context self) -> Standard_Boolean

        This method uses system-dependent API to retrieve information
        about GL context bound to the current thread.
        @return true if current thread is bound to this GL context

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsCurrent(self, *args)


    def MakeCurrent(self, *args):
        """
        MakeCurrent(OpenGl_Context self) -> Standard_Boolean

        Activates current context.
        Class should be initialized with appropriate info.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_MakeCurrent(self, *args)


    def SwapBuffers(self, *args):
        """
        SwapBuffers(OpenGl_Context self)

        Swap front/back buffers for this GL context (should be activated before!).


        """
        return _OpenGl.OpenGl_Context_SwapBuffers(self, *args)


    def SetSwapInterval(self, *args):
        """
        SetSwapInterval(OpenGl_Context self, Standard_Integer const theInterval) -> Standard_Boolean

        Setup swap interval (VSync).

        :type theInterval: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_SetSwapInterval(self, *args)


    def IsRender(self, *args):
        """
        IsRender(OpenGl_Context self) -> Standard_Boolean

        Return true if active mode is GL_RENDER (cached state)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsRender(self, *args)


    def IsFeedback(self, *args):
        """
        IsFeedback(OpenGl_Context self) -> Standard_Boolean

        Return true if active mode is GL_FEEDBACK (cached state)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsFeedback(self, *args)


    def AvailableMemory(self, *args):
        """
        AvailableMemory(OpenGl_Context self) -> Standard_Size

        This function retrieves information from GL about free GPU memory that is:
        - OS-dependent. On some OS it is per-process and on others - for entire system.
        - Vendor-dependent. Currently available only on NVIDIA and AMD/ATi drivers only.
        - Numbers meaning may vary.
        You should use this info only for diagnostics purposes.
        @return free GPU dedicated memory in bytes.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Context_AvailableMemory(self, *args)


    def MemoryInfo(self, *args):
        """
        MemoryInfo(OpenGl_Context self) -> TCollection_AsciiString
        MemoryInfo(OpenGl_Context self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict)

        This function retrieves information from GL about GPU memory.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString

        """
        return _OpenGl.OpenGl_Context_MemoryInfo(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(OpenGl_Context self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with OpenGL info.
        Should be called with bound context.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _OpenGl.OpenGl_Context_DiagnosticInformation(self, *args)


    def GetResource(self, *args):
        """
        Access shared resource by its name.
        @param  theKey - unique identifier;
        @return handle to shared resource or NULL.

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Resource

        """
        res = _OpenGl.OpenGl_Context_GetResource(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShareResource(self, *args):
        """
        ShareResource(OpenGl_Context self, TCollection_AsciiString theKey, Handle_OpenGl_Resource theResource) -> Standard_Boolean

        Register shared resource.
        Notice that after registration caller shouldn't release it by himself -
        it will be automatically released on context destruction.
        @param theKey      - unique identifier, shouldn't be empty;
        @param theResource - new resource to register, shouldn't be NULL.

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theResource: OCC.wrapper.OpenGl.Handle_OpenGl_Resource
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_ShareResource(self, *args)


    def ReleaseResource(self, *args):
        """
        ReleaseResource(OpenGl_Context self, TCollection_AsciiString theKey, Standard_Boolean const theToDelay)

        Release shared resource.
        If there are more than one reference to this resource
        (also used by some other existing object) then call will be ignored.
        This means that current object itself should nullify handle before this call.
        Notice that this is unrecommended operation at all and should be used
        only in case of fat resources to release memory for other needs.
        @param theKey     unique identifier
        @param theToDelay postpone release until next redraw call

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theToDelay: bool

        """
        return _OpenGl.OpenGl_Context_ReleaseResource(self, *args)


    def ReleaseDelayed(self, *args):
        """
        ReleaseDelayed(OpenGl_Context self)

        Clean up the delayed release queue.


        """
        return _OpenGl.OpenGl_Context_ReleaseDelayed(self, *args)


    def SharedResources(self, *args):
        """
        Return map of shared resources.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ResourcesMap

        """
        res = _OpenGl.OpenGl_Context_SharedResources(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeClipping(self, *args):
        """
        ChangeClipping(OpenGl_Context self) -> OpenGl_Clipping

        @return tool for management of clippings within this context.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Clipping

        """
        return _OpenGl.OpenGl_Context_ChangeClipping(self, *args)


    def Clipping(self, *args):
        """
        @return tool for management of clippings within this context.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Clipping

        """
        res = _OpenGl.OpenGl_Context_Clipping(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShaderManager(self, *args):
        """
        @return tool for management of shader programs within this context.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderManager

        """
        res = _OpenGl.OpenGl_Context_ShaderManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureWrapClamp(self, *args):
        """
        TextureWrapClamp(OpenGl_Context self) -> Standard_Integer

        Either GL_CLAMP_TO_EDGE (1.2+) or GL_CLAMP (1.1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_TextureWrapClamp(self, *args)


    def MaxDegreeOfAnisotropy(self, *args):
        """
        MaxDegreeOfAnisotropy(OpenGl_Context self) -> Standard_Integer

        @return maximum degree of anisotropy texture filter

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxDegreeOfAnisotropy(self, *args)


    def MaxTextureSize(self, *args):
        """
        MaxTextureSize(OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_TEXTURE_SIZE

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxTextureSize(self, *args)


    def MaxCombinedTextureUnits(self, *args):
        """
        MaxCombinedTextureUnits(OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxCombinedTextureUnits(self, *args)


    def MaxMsaaSamples(self, *args):
        """
        MaxMsaaSamples(OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_SAMPLES

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxMsaaSamples(self, *args)


    def MaxDrawBuffers(self, *args):
        """
        MaxDrawBuffers(OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_DRAW_BUFFERS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxDrawBuffers(self, *args)


    def MaxColorAttachments(self, *args):
        """
        MaxColorAttachments(OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_COLOR_ATTACHMENTS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxColorAttachments(self, *args)


    def MaxClipPlanes(self, *args):
        """
        MaxClipPlanes(OpenGl_Context self) -> Standard_Integer

        Get maximum number of clip planes supported by OpenGl.
        This value is implementation dependent. At least 6
        planes should be supported by OpenGl (see specs).
        @return value for GL_MAX_CLIP_PLANES

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_MaxClipPlanes(self, *args)


    def HasRayTracing(self, *args):
        """
        HasRayTracing(OpenGl_Context self) -> Standard_Boolean

        @return TRUE if ray tracing mode is supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_HasRayTracing(self, *args)


    def HasRayTracingTextures(self, *args):
        """
        HasRayTracingTextures(OpenGl_Context self) -> Standard_Boolean

        @return TRUE if textures in ray tracing mode are supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_HasRayTracingTextures(self, *args)


    def HasRayTracingAdaptiveSampling(self, *args):
        """
        HasRayTracingAdaptiveSampling(OpenGl_Context self) -> Standard_Boolean

        @return TRUE if adaptive screen sampling in ray tracing mode is supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_HasRayTracingAdaptiveSampling(self, *args)


    def ToUseVbo(self, *args):
        """
        ToUseVbo(OpenGl_Context self) -> bool

        Returns true if VBO is supported and permitted.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_ToUseVbo(self, *args)


    def IsGlNormalizeEnabled(self, *args):
        """
        IsGlNormalizeEnabled(OpenGl_Context self) -> Standard_Boolean

        @return cached state of GL_NORMALIZE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsGlNormalizeEnabled(self, *args)


    def SetGlNormalizeEnabled(self, *args):
        """
        SetGlNormalizeEnabled(OpenGl_Context self, Standard_Boolean isEnabled) -> Standard_Boolean

        Sets GL_NORMALIZE enabled or disabled.
        @return old value of the flag

        :type isEnabled: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_SetGlNormalizeEnabled(self, *args)


    def PolygonMode(self, *args):
        """
        PolygonMode(OpenGl_Context self) -> Standard_Integer

        @return cached state of polygon rasterization mode (glPolygonMode()).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_PolygonMode(self, *args)


    def SetPolygonMode(self, *args):
        """
        SetPolygonMode(OpenGl_Context self, Standard_Integer const theMode) -> Standard_Integer

        Sets polygon rasterization mode (glPolygonMode() function).
        @return old value of the rasterization mode.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_SetPolygonMode(self, *args)


    def IsPolygonHatchEnabled(self, *args):
        """
        IsPolygonHatchEnabled(OpenGl_Context self) -> bool

        @return cached enabled state of polygon hatching rasterization.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_IsPolygonHatchEnabled(self, *args)


    def SetPolygonHatchEnabled(self, *args):
        """
        SetPolygonHatchEnabled(OpenGl_Context self, bool const theIsEnabled) -> bool

        Sets enabled state of polygon hatching rasterization
        without affecting currently selected hatching pattern.
        @return previous state of polygon hatching mode.

        :type theIsEnabled: const bool
        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_SetPolygonHatchEnabled(self, *args)


    def PolygonHatchStyle(self, *args):
        """
        PolygonHatchStyle(OpenGl_Context self) -> Standard_Integer

        @return cached state of polygon hatch type.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_PolygonHatchStyle(self, *args)


    def SetPolygonHatchStyle(self, *args):
        """
        SetPolygonHatchStyle(OpenGl_Context self, Handle_Graphic3d_HatchStyle theStyle) -> Standard_Integer

        Sets polygon hatch pattern.
        Zero-index value is a default alias for solid filling.
        @param the type of hatch supported by base implementation of
        OpenGl_LineAttributes (Aspect_HatchStyle) or the type supported by custom
        implementation derived from OpenGl_LineAttributes class.
        @return old type of hatch.

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_HatchStyle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_SetPolygonHatchStyle(self, *args)


    def SetPolygonOffset(self, *args):
        """
        SetPolygonOffset(OpenGl_Context self, Graphic3d_PolygonOffset const & theOffset)

        Sets and applies current polygon offset.

        :type theOffset: OCC.wrapper.Graphic3d.Graphic3d_PolygonOffset

        """
        return _OpenGl.OpenGl_Context_SetPolygonOffset(self, *args)


    def PolygonOffset(self, *args):
        """
        Returns currently applied polygon offset parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_PolygonOffset

        """
        res = _OpenGl.OpenGl_Context_PolygonOffset(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ApplyModelWorldMatrix(self, *args):
        """
        ApplyModelWorldMatrix(OpenGl_Context self)

        Applies matrix stored in ModelWorldState to OpenGl.


        """
        return _OpenGl.OpenGl_Context_ApplyModelWorldMatrix(self, *args)


    def ApplyWorldViewMatrix(self, *args):
        """
        ApplyWorldViewMatrix(OpenGl_Context self)

        Applies matrix stored in WorldViewState to OpenGl.


        """
        return _OpenGl.OpenGl_Context_ApplyWorldViewMatrix(self, *args)


    def ApplyModelViewMatrix(self, *args):
        """
        ApplyModelViewMatrix(OpenGl_Context self)

        Applies combination of matrices stored in ModelWorldState and WorldViewState to OpenGl.


        """
        return _OpenGl.OpenGl_Context_ApplyModelViewMatrix(self, *args)


    def ApplyProjectionMatrix(self, *args):
        """
        ApplyProjectionMatrix(OpenGl_Context self)

        Applies matrix stored in ProjectionState to OpenGl.


        """
        return _OpenGl.OpenGl_Context_ApplyProjectionMatrix(self, *args)


    def Messenger(self, *args):
        """
        @return messenger instance

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        res = _OpenGl.OpenGl_Context_Messenger(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PushMessage(self, *args):
        """
        PushMessage(OpenGl_Context self, unsigned int const theSource, unsigned int const theType, unsigned int const theId, unsigned int const theSeverity, TCollection_ExtendedString theMessage)

        Callback for GL_ARB_debug_output extension
        @param theSource   message source   within GL_DEBUG_SOURCE_   enumeration
        @param theType     message type     within GL_DEBUG_TYPE_     enumeration
        @param theId       message ID       within source
        @param theSeverity message severity within GL_DEBUG_SEVERITY_ enumeration
        @param theMessage  the message itself

        :type theSource: const unsigned int
        :type theType: const unsigned int
        :type theId: const unsigned int
        :type theSeverity: const unsigned int
        :type theMessage: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _OpenGl.OpenGl_Context_PushMessage(self, *args)


    def ExcludeMessage(self, *args):
        """
        ExcludeMessage(OpenGl_Context self, unsigned int const theSource, unsigned int const theId) -> Standard_Boolean

        Adds a filter for messages with theId and theSource (GL_DEBUG_SOURCE_)

        :type theSource: const unsigned int
        :type theId: const unsigned int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_ExcludeMessage(self, *args)


    def IncludeMessage(self, *args):
        """
        IncludeMessage(OpenGl_Context self, unsigned int const theSource, unsigned int const theId) -> Standard_Boolean

        Removes a filter for messages with theId and theSource (GL_DEBUG_SOURCE_)

        :type theSource: const unsigned int
        :type theId: const unsigned int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IncludeMessage(self, *args)


    def HasStereoBuffers(self, *args):
        """
        HasStereoBuffers(OpenGl_Context self) -> Standard_Boolean

        @return true if OpenGl context supports left and
        right rendering buffers.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_HasStereoBuffers(self, *args)


    def FrameStats(self, *args):
        """
        Return structure holding frame statistics.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats

        """
        res = _OpenGl.OpenGl_Context_FrameStats(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Viewport(self, *args):
        """
        Viewport(OpenGl_Context self) -> Standard_Integer const *

        Return cached viewport definition (x, y, width, height).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_Viewport(self, *args)


    def ResizeViewport(self, *args):
        """
        ResizeViewport(OpenGl_Context self, Standard_Integer const * theRect)

        Resize the viewport (alias for glViewport).
        @param theRect viewport definition (x, y, width, height)

        :type theRect: const Standard_Integer [4]

        """
        return _OpenGl.OpenGl_Context_ResizeViewport(self, *args)


    def VirtualViewport(self, *args):
        """
        VirtualViewport(OpenGl_Context self) -> Standard_Integer const *

        Return virtual viewport definition (x, y, width, height).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_VirtualViewport(self, *args)


    def ReadBuffer(self, *args):
        """
        ReadBuffer(OpenGl_Context self) -> Standard_Integer

        Return active read buffer.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_ReadBuffer(self, *args)


    def SetReadBuffer(self, *args):
        """
        SetReadBuffer(OpenGl_Context self, Standard_Integer const theReadBuffer)

        Switch read buffer, wrapper for ::glReadBuffer().

        :type theReadBuffer: int

        """
        return _OpenGl.OpenGl_Context_SetReadBuffer(self, *args)


    def DrawBuffer(self, *args):
        """
        DrawBuffer(OpenGl_Context self, Standard_Integer const theIndex=0) -> Standard_Integer

        Return active draw buffer attached to a render target referred by index (layout location).

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Context_DrawBuffer(self, *args)


    def SetDrawBuffer(self, *args):
        """
        SetDrawBuffer(OpenGl_Context self, Standard_Integer const theDrawBuffer)

        Switch draw buffer, wrapper for ::glDrawBuffer().

        :type theDrawBuffer: int

        """
        return _OpenGl.OpenGl_Context_SetDrawBuffer(self, *args)


    def SetDrawBuffers(self, *args):
        """
        SetDrawBuffers(OpenGl_Context self, Standard_Integer const theNb, Standard_Integer const * theDrawBuffers)

        Switch draw buffer, wrapper for ::glDrawBuffers (GLsizei, const GLenum*).

        :type theNb: int
        :type theDrawBuffers: int

        """
        return _OpenGl.OpenGl_Context_SetDrawBuffers(self, *args)


    def SetReadDrawBuffer(self, *args):
        """
        SetReadDrawBuffer(OpenGl_Context self, Standard_Integer const theBuffer)

        Switch read/draw buffers.

        :type theBuffer: int

        """
        return _OpenGl.OpenGl_Context_SetReadDrawBuffer(self, *args)


    def ColorMask(self, *args):
        """
        ColorMask(OpenGl_Context self) -> bool

        Return cached flag indicating writing into color buffer is enabled or disabled (glColorMask).

        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_ColorMask(self, *args)


    def SetColorMask(self, *args):
        """
        SetColorMask(OpenGl_Context self, bool theToWriteColor) -> bool

        Enable/disable writing into color buffer (wrapper for glColorMask).

        :type theToWriteColor: bool
        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_SetColorMask(self, *args)


    def SampleAlphaToCoverage(self, *args):
        """
        SampleAlphaToCoverage(OpenGl_Context self) -> bool

        Return GL_SAMPLE_ALPHA_TO_COVERAGE state.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_SampleAlphaToCoverage(self, *args)


    def SetSampleAlphaToCoverage(self, *args):
        """
        SetSampleAlphaToCoverage(OpenGl_Context self, bool theToEnable) -> bool

        Enable/disable GL_SAMPLE_ALPHA_TO_COVERAGE.

        :type theToEnable: bool
        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_SetSampleAlphaToCoverage(self, *args)


    def ToCullBackFaces(self, *args):
        """
        ToCullBackFaces(OpenGl_Context self) -> bool

        Return back face culling state.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Context_ToCullBackFaces(self, *args)


    def SetCullBackFaces(self, *args):
        """
        SetCullBackFaces(OpenGl_Context self, bool theToEnable)

        Enable or disable back face culling (glEnable (GL_CULL_FACE)).

        :type theToEnable: bool

        """
        return _OpenGl.OpenGl_Context_SetCullBackFaces(self, *args)


    def FetchState(self, *args):
        """
        FetchState(OpenGl_Context self)

        Fetch OpenGl context state. This class tracks value of several OpenGl
        state variables. Consulting the cached values is quicker than
        doing the same via OpenGl API. Call this method if any of the controlled
        OpenGl state variables has a possibility of being out-of-date.


        """
        return _OpenGl.OpenGl_Context_FetchState(self, *args)


    def ActiveTextures(self, *args):
        """
        @return active textures

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_Context_ActiveTextures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindTextures(self, *args):
        """
        BindTextures(OpenGl_Context self, Handle_OpenGl_TextureSet theTextures) -> Handle_OpenGl_TextureSet

        Bind specified texture set to current context,
        or unbind previous one when NULL specified.

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        return _OpenGl.OpenGl_Context_BindTextures(self, *args)


    def ActiveProgram(self, *args):
        """
        @return active GLSL program

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.OpenGl_Context_ActiveProgram(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindProgram(self, *args):
        """
        BindProgram(OpenGl_Context self, Handle_OpenGl_ShaderProgram theProgram) -> Standard_Boolean

        Bind specified program to current context,
        or unbind previous one when NULL specified.
        @return true if some program is bound to context

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_BindProgram(self, *args)


    def SetShadingMaterial(self, *args):
        """
        SetShadingMaterial(OpenGl_Context self, OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight)

        Setup current shading material.

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :type theHighlight: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        return _OpenGl.OpenGl_Context_SetShadingMaterial(self, *args)


    def CheckIsTransparent(*args):
        """
        CheckIsTransparent(OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean
        CheckIsTransparent(OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean

        Checks if transparency is required for the given aspect and highlight style.

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :type theHighlight: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_CheckIsTransparent(*args)

    CheckIsTransparent = staticmethod(CheckIsTransparent)

    def SetColor4fv(self, *args):
        """
        SetColor4fv(OpenGl_Context self, OpenGl_Vec4 const & theColor)

        Setup current color.

        :type theColor: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        return _OpenGl.OpenGl_Context_SetColor4fv(self, *args)


    def SetTypeOfLine(self, *args):
        """
        SetTypeOfLine(OpenGl_Context self, Aspect_TypeOfLine const theType, Standard_ShortReal const theFactor=1.0)

        Setup type of line.

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type theFactor: float

        """
        return _OpenGl.OpenGl_Context_SetTypeOfLine(self, *args)


    def SetLineWidth(self, *args):
        """
        SetLineWidth(OpenGl_Context self, Standard_ShortReal const theWidth)

        Setup width of line.

        :type theWidth: float

        """
        return _OpenGl.OpenGl_Context_SetLineWidth(self, *args)


    def SetPointSize(self, *args):
        """
        SetPointSize(OpenGl_Context self, Standard_ShortReal const theSize)

        Setup point size.

        :type theSize: float

        """
        return _OpenGl.OpenGl_Context_SetPointSize(self, *args)


    def SetPointSpriteOrigin(self, *args):
        """
        SetPointSpriteOrigin(OpenGl_Context self)

        Setup point sprite origin using GL_POINT_SPRITE_COORD_ORIGIN state:
        - GL_UPPER_LEFT when GLSL program is active;
        flipping should be handled in GLSL program for compatibility with OpenGL ES
        - GL_LOWER_LEFT for FFP


        """
        return _OpenGl.OpenGl_Context_SetPointSpriteOrigin(self, *args)


    def SetTextureMatrix(self, *args):
        """
        SetTextureMatrix(OpenGl_Context self, Handle_Graphic3d_TextureParams theParams)

        Setup texture matrix to active GLSL program or to FFP global state using glMatrixMode (GL_TEXTURE).

        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        return _OpenGl.OpenGl_Context_SetTextureMatrix(self, *args)


    def BindDefaultVao(self, *args):
        """
        BindDefaultVao(OpenGl_Context self)

        Bind default Vertex Array Object


        """
        return _OpenGl.OpenGl_Context_BindDefaultVao(self, *args)


    def DefaultFrameBuffer(self, *args):
        """
        Default Frame Buffer Object.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        res = _OpenGl.OpenGl_Context_DefaultFrameBuffer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultFrameBuffer(self, *args):
        """
        SetDefaultFrameBuffer(OpenGl_Context self, Handle_OpenGl_FrameBuffer theFbo) -> Handle_OpenGl_FrameBuffer

        Setup new Default Frame Buffer Object and return previously set.
        This call doesn't change Active FBO!

        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.OpenGl_Context_SetDefaultFrameBuffer(self, *args)


    def IsDebugContext(self, *args):
        """
        IsDebugContext(OpenGl_Context self) -> Standard_Boolean

        Return debug context initialization state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_IsDebugContext(self, *args)


    def EnableFeatures(self, *args):
        """EnableFeatures(OpenGl_Context self)"""
        return _OpenGl.OpenGl_Context_EnableFeatures(self, *args)


    def DisableFeatures(self, *args):
        """DisableFeatures(OpenGl_Context self)"""
        return _OpenGl.OpenGl_Context_DisableFeatures(self, *args)


    def Resolution(self, *args):
        """
        Resolution(OpenGl_Context self) -> unsigned int

        Return resolution for rendering text.

        :rtype: unsigned int

        """
        return _OpenGl.OpenGl_Context_Resolution(self, *args)


    def ResolutionRatio(self, *args):
        """
        ResolutionRatio(OpenGl_Context self) -> Standard_ShortReal

        Resolution scale factor (rendered resolution to standard resolution).
        This scaling factor for parameters like text size to be properly displayed on device (screen / printer).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_Context_ResolutionRatio(self, *args)


    def RenderScale(self, *args):
        """
        RenderScale(OpenGl_Context self) -> Standard_ShortReal

        Rendering scale factor (rendering viewport height to real window buffer height).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_Context_RenderScale(self, *args)


    def HasRenderScale(self, *args):
        """
        HasRenderScale(OpenGl_Context self) -> Standard_Boolean

        Return TRUE if rendering scale factor is not 1.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Context_HasRenderScale(self, *args)


    def RenderScaleInv(self, *args):
        """
        RenderScaleInv(OpenGl_Context self) -> Standard_ShortReal

        Rendering scale factor (inverted value).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_Context_RenderScaleInv(self, *args)


    def SetResolution(self, *args):
        """
        SetResolution(OpenGl_Context self, unsigned int theResolution, Standard_ShortReal theRatio, Standard_ShortReal theScale)

        Set resolution ratio.
        Note that this method rounds @theRatio to nearest integer.

        :type theResolution: unsigned int
        :type theRatio: float
        :type theScale: float

        """
        return _OpenGl.OpenGl_Context_SetResolution(self, *args)


    def SetResolutionRatio(self, *args):
        """
        SetResolutionRatio(OpenGl_Context self, Standard_ShortReal const theRatio)

        Set resolution ratio.
        Note that this method rounds @theRatio to nearest integer.

        :type theRatio: float

        """
        return _OpenGl.OpenGl_Context_SetResolutionRatio(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_Context
OpenGl_Context_swigregister = _OpenGl.OpenGl_Context_swigregister
OpenGl_Context_swigregister(OpenGl_Context)

def OpenGl_Context_get_type_name(*args):
    """
    OpenGl_Context_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Context_get_type_name(*args)

def OpenGl_Context_get_type_descriptor(*args):
    """
    OpenGl_Context_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Context_get_type_descriptor(*args)

def OpenGl_Context_GetPowerOfTwo(*args):
    """
    OpenGl_Context_GetPowerOfTwo(Standard_Integer const theNumber, Standard_Integer const theThreshold) -> Standard_Integer

    Function for getting power of to number larger or equal to input number.
    @param theNumber    number to 'power of two'
    @param theThreshold upper threshold
    @return power of two number

    :type theNumber: int
    :type theThreshold: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _OpenGl.OpenGl_Context_GetPowerOfTwo(*args)

def OpenGl_Context_ReadGlVersion(*args):
    """
    OpenGl_Context_ReadGlVersion()

    Read OpenGL version information from active context.

    :type theGlVerMajor: int
    :type theGlVerMinor: int

    """
    return _OpenGl.OpenGl_Context_ReadGlVersion(*args)

def OpenGl_Context_CheckExtension(*args):
    """
    CheckExtension(char const * theExtName) -> Standard_Boolean
    OpenGl_Context_CheckExtension(char const * theExtString, char const * theExtName) -> Standard_Boolean

    Check if theExtName extension is in extensions string.

    :type theExtString: const char *
    :type theExtName: const char *
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _OpenGl.OpenGl_Context_CheckExtension(*args)

def OpenGl_Context_CheckIsTransparent(*args):
    """
    CheckIsTransparent(OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean
    OpenGl_Context_CheckIsTransparent(OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean

    Checks if transparency is required for the given aspect and highlight style.

    :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
    :type theHighlight: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _OpenGl.OpenGl_Context_CheckIsTransparent(*args)

class OpenGl_View(Graphic3d.Graphic3d_CView):
    """Implementation of OpenGl view."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_View
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_View(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_View self, Handle_Graphic3d_StructureManager theMgr, Handle_OpenGl_GraphicDriver theDriver, Handle_OpenGl_Caps theCaps, OpenGl_StateCounter theCounter) -> OpenGl_View

        Constructor.

        :type theMgr: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :type theDriver: OCC.wrapper.OpenGl.Handle_OpenGl_GraphicDriver
        :type theCaps: OCC.wrapper.OpenGl.Handle_OpenGl_Caps
        :type theCounter: OCC.wrapper.OpenGl.OpenGl_StateCounter

        """
        this = _OpenGl.new_OpenGl_View(*args)
        try:
            self.this.append(this[0])
        except __builtin__.Exception:
            self.this = this[0]

        self.handle




    def ReleaseGlResources(self, *args):
        """
        ReleaseGlResources(OpenGl_View self, Handle_OpenGl_Context theCtx)

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_View_ReleaseGlResources(self, *args)


    def Remove(self, *args):
        """
        Remove(OpenGl_View self)

        Deletes and erases the view.


        """
        return _OpenGl.OpenGl_View_Remove(self, *args)


    def SetImmediateModeDrawToFront(self, *args):
        """
        SetImmediateModeDrawToFront(OpenGl_View self, Standard_Boolean const theDrawToFrontBuffer) -> Standard_Boolean

        @param theDrawToFrontBuffer Advanced option to modify rendering mode:
        1. TRUE.  Drawing immediate mode structures directly to the front buffer over the scene image.
        Fast, so preferred for interactive work (used by default).
        However these extra drawings will be missed in image dump since it is performed from back buffer.
        Notice that since no pre-buffering used the V-Sync will be ignored and rendering could be seen
        in run-time (in case of slow hardware) and/or tearing may appear.
        So this is strongly recommended to draw only simple (fast) structures.
        2. FALSE. Drawing immediate mode structures to the back buffer.
        The complete scene is redrawn first, so this mode is slower if scene contains complex data and/or V-Sync
        is turned on. But it works in any case and is especially useful for view dump because the dump image is read
        from the back buffer.
        @return previous mode.

        :type theDrawToFrontBuffer: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_SetImmediateModeDrawToFront(self, *args)


    def SetWindow(self, *args):
        """
        SetWindow(OpenGl_View self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext)

        Creates and maps rendering window to the view.
        @param theWindow [in] the window.
        @param theContext [in] the rendering context. If NULL the context will be created internally.

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext

        """
        return _OpenGl.OpenGl_View_SetWindow(self, *args)


    def Window(self, *args):
        """
        Window(OpenGl_View self) -> Handle_Aspect_Window

        Returns window associated with the view.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _OpenGl.OpenGl_View_Window(self, *args)


    def IsDefined(self, *args):
        """
        IsDefined(OpenGl_View self) -> Standard_Boolean

        Returns True if the window associated to the view is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_IsDefined(self, *args)


    def Resized(self, *args):
        """
        Resized(OpenGl_View self)

        Handle changing size of the rendering window.


        """
        return _OpenGl.OpenGl_View_Resized(self, *args)


    def Redraw(self, *args):
        """
        Redraw(OpenGl_View self)

        Redraw content of the view.


        """
        return _OpenGl.OpenGl_View_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(OpenGl_View self)

        Redraw immediate content of the view.


        """
        return _OpenGl.OpenGl_View_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(OpenGl_View self)

        Marks BVH tree for given priority list as dirty and marks primitive set for rebuild.


        """
        return _OpenGl.OpenGl_View_Invalidate(self, *args)


    def IsInvalidated(self, *args):
        """
        IsInvalidated(OpenGl_View self) -> Standard_Boolean

        Return true if view content cache has been invalidated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_IsInvalidated(self, *args)


    def GetGraduatedTrihedron(self, *args):
        """
        Returns data of a graduated trihedron

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        res = _OpenGl.OpenGl_View_GetGraduatedTrihedron(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GraduatedTrihedronDisplay(self, *args):
        """
        GraduatedTrihedronDisplay(OpenGl_View self, Graphic3d_GraduatedTrihedron theTrihedronData)

        Displays Graduated Trihedron.

        :type theTrihedronData: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        return _OpenGl.OpenGl_View_GraduatedTrihedronDisplay(self, *args)


    def GraduatedTrihedronErase(self, *args):
        """
        GraduatedTrihedronErase(OpenGl_View self)

        Erases Graduated Trihedron.


        """
        return _OpenGl.OpenGl_View_GraduatedTrihedronErase(self, *args)


    def GraduatedTrihedronMinMaxValues(self, *args):
        """
        GraduatedTrihedronMinMaxValues(OpenGl_View self, NCollection_Vec3_Standard_ShortReal theMin, NCollection_Vec3_Standard_ShortReal theMax)

        Sets minimum and maximum points of scene bounding box for Graduated Trihedron stored in graphic view object.
        @param theMin [in] the minimum point of scene.
        @param theMax [in] the maximum point of scene.

        :type theMin: OCC.wrapper.Graphic3d.Graphic3d_Vec3
        :type theMax: OCC.wrapper.Graphic3d.Graphic3d_Vec3

        """
        return _OpenGl.OpenGl_View_GraduatedTrihedronMinMaxValues(self, *args)


    def BufferDump(self, *args):
        """
        BufferDump(OpenGl_View self, Image_PixMap theImage, Graphic3d_BufferType const & theBufferType) -> Standard_Boolean

        Dump active rendering buffer into specified memory buffer.
        In Ray-Tracing allow to get a raw HDR buffer using Graphic3d_BT_RGB_RayTraceHdrLeft buffer type,
        only Left view will be dumped ignoring stereoscopic parameter.

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_BufferDump(self, *args)


    def Export(self, *args):
        """
        Export(OpenGl_View self, Standard_CString const theFileName, Graphic3d_ExportFormat const theFormat, Graphic3d_SortType const theSortType=Graphic3d_ST_BSP_Tree) -> Standard_Boolean

        Export scene into the one of the Vector graphics formats (SVG, PS, PDF...).
        In contrast to Bitmaps, Vector graphics is scalable (so you may got quality benefits
        on printing to laser printer). Notice however that results may differ a lot and
        do not contain some elements.

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFormat: OCC.wrapper.Graphic3d.Graphic3d_ExportFormat
        :type theSortType: OCC.wrapper.Graphic3d.Graphic3d_SortType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_Export(self, *args)


    def InvalidateBVHData(self, *args):
        """
        InvalidateBVHData(OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Marks BVH tree and the set of BVH primitives of correspondent priority list with id theLayerId as outdated.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_View_InvalidateBVHData(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Insert a new top-level z layer with the given ID.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_View_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Remove a z layer with the given ID.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_View_RemoveZLayer(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(OpenGl_View self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer of specified view.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _OpenGl.OpenGl_View_SetZLayerSettings(self, *args)


    def ZLayerMax(self, *args):
        """
        ZLayerMax(OpenGl_View self) -> Standard_Integer

        Returns the maximum Z layer ID.
        First layer ID is Graphic3d_ZLayerId_Default, last ID is ZLayerMax().

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_View_ZLayerMax(self, *args)


    def InvalidateZLayerBoundingBox(self, *args):
        """
        InvalidateZLayerBoundingBox(OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Returns the bounding box of all structures displayed in the Z layer.
        Never fails. If Z layer does not exist nothing happens.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_View_InvalidateZLayerBoundingBox(self, *args)


    def ZLayerBoundingBox(self, *args):
        """
        ZLayerBoundingBox(OpenGl_View self, Graphic3d_ZLayerId const theLayerId, Handle_Graphic3d_Camera theCamera, Standard_Integer const theWindowWidth, Standard_Integer const theWindowHeight, Standard_Boolean const theToIncludeAuxiliary) -> Bnd_Box

        Returns the bounding box of all structures displayed in the Z layer.
        If Z layer does not exist the empty box is returned.
        @param theLayerId            layer identifier
        @param theCamera             camera definition
        @param theWindowWidth        viewport width  (for applying transformation-persistence)
        @param theWindowHeight       viewport height (for applying transformation-persistence)
        @param theToIncludeAuxiliary consider also auxiliary presentations (with infinite flag or with trihedron transformation persistence)
        @return computed bounding box

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera
        :type theWindowWidth: int
        :type theWindowHeight: int
        :type theToIncludeAuxiliary: bool
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _OpenGl.OpenGl_View_ZLayerBoundingBox(self, *args)


    def FBO(self, *args):
        """
        FBO(OpenGl_View self) -> Handle_Standard_Transient

        Returns pointer to an assigned framebuffer object.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.OpenGl_View_FBO(self, *args)


    def SetFBO(self, *args):
        """
        SetFBO(OpenGl_View self, Handle_Standard_Transient theFbo)

        Sets framebuffer object for offscreen rendering.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.OpenGl_View_SetFBO(self, *args)


    def FBOCreate(self, *args):
        """
        FBOCreate(OpenGl_View self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Handle_Standard_Transient

        Generate offscreen FBO in the graphic library.
        If not supported on hardware returns NULL.

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.OpenGl_View_FBOCreate(self, *args)


    def FBORelease(self, *args):
        """
        FBORelease(OpenGl_View self, Handle_Standard_Transient theFbo)

        Remove offscreen FBO from the graphic library

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.OpenGl_View_FBORelease(self, *args)


    def FBOGetDimensions(self, *args):
        """
        FBOGetDimensions(OpenGl_View self, Handle_Standard_Transient theFbo)

        Read offscreen FBO configuration.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theWidth: int
        :type theHeight: int
        :type theWidthMax: int
        :type theHeightMax: int

        """
        return _OpenGl.OpenGl_View_FBOGetDimensions(self, *args)


    def FBOChangeViewport(self, *args):
        """
        FBOChangeViewport(OpenGl_View self, Handle_Standard_Transient theFbo, Standard_Integer const theWidth, Standard_Integer const theHeight)

        Change offscreen FBO viewport.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theWidth: int
        :type theHeight: int

        """
        return _OpenGl.OpenGl_View_FBOChangeViewport(self, *args)


    def Background(self, *args):
        """
        Background(OpenGl_View self) -> Aspect_Background

        Returns background  fill color.

        :rtype: OCC.wrapper.Aspect.Aspect_Background

        """
        return _OpenGl.OpenGl_View_Background(self, *args)


    def SetBackground(self, *args):
        """
        SetBackground(OpenGl_View self, Aspect_Background theBackground)

        Sets background fill color.

        :type theBackground: OCC.wrapper.Aspect.Aspect_Background

        """
        return _OpenGl.OpenGl_View_SetBackground(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(OpenGl_View self) -> Aspect_GradientBackground

        Returns gradient background fill colors.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _OpenGl.OpenGl_View_GradientBackground(self, *args)


    def SetGradientBackground(self, *args):
        """
        SetGradientBackground(OpenGl_View self, Aspect_GradientBackground theBackground)

        Sets gradient background fill colors.

        :type theBackground: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _OpenGl.OpenGl_View_SetGradientBackground(self, *args)


    def BackgroundImage(self, *args):
        """
        BackgroundImage(OpenGl_View self) -> TCollection_AsciiString

        Returns background image texture file path.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.OpenGl_View_BackgroundImage(self, *args)


    def SetBackgroundImage(self, *args):
        """
        SetBackgroundImage(OpenGl_View self, TCollection_AsciiString theFilePath)

        Sets background image texture file path.

        :type theFilePath: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.OpenGl_View_SetBackgroundImage(self, *args)


    def BackgroundImageStyle(self, *args):
        """
        BackgroundImageStyle(OpenGl_View self) -> Aspect_FillMethod

        Returns background image fill style.

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.OpenGl_View_BackgroundImageStyle(self, *args)


    def SetBackgroundImageStyle(self, *args):
        """
        SetBackgroundImageStyle(OpenGl_View self, Aspect_FillMethod const theFillStyle)

        Sets background image fill style.

        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.OpenGl_View_SetBackgroundImageStyle(self, *args)


    def TextureEnv(self, *args):
        """
        TextureEnv(OpenGl_View self) -> Handle_Graphic3d_TextureEnv

        Returns environment texture set for the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _OpenGl.OpenGl_View_TextureEnv(self, *args)


    def SetTextureEnv(self, *args):
        """
        SetTextureEnv(OpenGl_View self, Handle_Graphic3d_TextureEnv theTextureEnv)

        Sets environment texture for the view.

        :type theTextureEnv: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _OpenGl.OpenGl_View_SetTextureEnv(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(OpenGl_View self) -> Standard_Boolean

        Returns the state of frustum culling optimization.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_View_IsCullingEnabled(self, *args)


    def SetCullingEnabled(self, *args):
        """
        SetCullingEnabled(OpenGl_View self, Standard_Boolean const theIsEnabled)

        Enables or disables frustum culling optimization.

        :type theIsEnabled: bool

        """
        return _OpenGl.OpenGl_View_SetCullingEnabled(self, *args)


    def BackfacingModel(self, *args):
        """
        BackfacingModel(OpenGl_View self) -> Graphic3d_TypeOfBackfacingModel

        Return backfacing model used for the view.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfBackfacingModel

        """
        return _OpenGl.OpenGl_View_BackfacingModel(self, *args)


    def SetBackfacingModel(self, *args):
        """
        SetBackfacingModel(OpenGl_View self, Graphic3d_TypeOfBackfacingModel const theModel)

        Sets backfacing model for the view.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfBackfacingModel

        """
        return _OpenGl.OpenGl_View_SetBackfacingModel(self, *args)


    def Camera(self, *args):
        """
        Returns camera object of the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _OpenGl.OpenGl_View_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalOrigin(self, *args):
        """
        Returns local camera origin currently set for rendering, might be modified during rendering.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _OpenGl.OpenGl_View_LocalOrigin(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalOrigin(self, *args):
        """
        SetLocalOrigin(OpenGl_View self, gp_XYZ theOrigin)

        Setup local camera origin currently set for rendering.

        :type theOrigin: OCC.wrapper.gp.gp_XYZ

        """
        return _OpenGl.OpenGl_View_SetLocalOrigin(self, *args)


    def SetCamera(self, *args):
        """
        SetCamera(OpenGl_View self, Handle_Graphic3d_Camera theCamera)

        Sets camera used by the view.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _OpenGl.OpenGl_View_SetCamera(self, *args)


    def Lights(self, *args):
        """
        Returns list of lights of the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        res = _OpenGl.OpenGl_View_Lights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLights(self, *args):
        """
        SetLights(OpenGl_View self, Handle_Graphic3d_LightSet theLights)

        Sets list of lights for the view.

        :type theLights: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        return _OpenGl.OpenGl_View_SetLights(self, *args)


    def ClipPlanes(self, *args):
        """
        Returns list of clip planes set for the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _OpenGl.OpenGl_View_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(OpenGl_View self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Sets list of clip planes for the view.

        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.OpenGl_View_SetClipPlanes(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(OpenGl_View self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with diagnostic info.
        Should be called within rendering thread.

        This API should be used only for user output or for creating automated reports.
        The format of returned information (e.g. key-value layout)
        is NOT part of this API and can be changed at any time.
        Thus application should not parse returned information to weed out specific parameters.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _OpenGl.OpenGl_View_DiagnosticInformation(self, *args)


    def BackgroundColor(self, *args):
        """
        Returns background color.

        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        res = _OpenGl.OpenGl_View_BackgroundColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeGraduatedTrihedron(self, *args):
        """
        ChangeGraduatedTrihedron(OpenGl_View self) -> OpenGl_GraduatedTrihedron

        Change graduated trihedron.

        :rtype: OCC.wrapper.OpenGl.OpenGl_GraduatedTrihedron

        """
        return _OpenGl.OpenGl_View_ChangeGraduatedTrihedron(self, *args)


    def LayerList(self, *args):
        """
        Returns list of OpenGL Z-layers.

        :rtype: OCC.wrapper.OpenGl.OpenGl_LayerList

        """
        res = _OpenGl.OpenGl_View_LayerList(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GlWindow(self, *args):
        """
        GlWindow(OpenGl_View self) -> Handle_OpenGl_Window

        Returns OpenGL window implementation.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Window

        """
        return _OpenGl.OpenGl_View_GlWindow(self, *args)


    def GlTextureEnv(self, *args):
        """
        Returns OpenGL environment map.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_View_GlTextureEnv(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVHTreeSelector(self, *args):
        """
        Returns selector for BVH tree, providing a possibility to store information
        about current view volume and to detect which objects are overlapping it.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHTreeSelector

        """
        res = _OpenGl.OpenGl_View_BVHTreeSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasImmediateStructures(self, *args):
        """
        HasImmediateStructures(OpenGl_View self) -> bool

        Returns true if there are immediate structures to display

        :rtype: bool

        """
        return _OpenGl.OpenGl_View_HasImmediateStructures(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_View_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_View_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_View_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_View
OpenGl_View_swigregister = _OpenGl.OpenGl_View_swigregister
OpenGl_View_swigregister(OpenGl_View)

def OpenGl_View_get_type_name(*args):
    """
    OpenGl_View_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_View_get_type_name(*args)

def OpenGl_View_get_type_descriptor(*args):
    """
    OpenGl_View_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_View_get_type_descriptor(*args)

class OpenGl_ShaderProgram(OpenGl_NamedResource):
    """Wrapper for OpenGL program object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_ShaderProgram
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_ShaderProgram(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_ShaderProgram_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_ShaderProgram_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_ShaderProgram_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_ShaderProgram self, Handle_Graphic3d_ShaderProgram theProxy=0) -> OpenGl_ShaderProgram

        Creates uninitialized shader program.

        WARNING! This constructor is not intended to be called anywhere but from OpenGl_ShaderManager::Create().
        Manager has been designed to synchronize camera position, lights definition and other aspects of the program implicitly,
        as well as sharing same program across rendering groups.

        Program created outside the manager will be left detached from these routines,
        and them should be performed manually by caller.

        This constructor has been made public to provide more flexibility to re-use OCCT OpenGL classes without OCCT Viewer itself.
        If this is not the case - create the program using shared OpenGl_ShaderManager instance instead.

        :type theProxy: OCC.wrapper.Graphic3d.Handle_Graphic3d_ShaderProgram

        """
        this = _OpenGl.new_OpenGl_ShaderProgram(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Create(self, *args):
        """
        Create(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Creates new empty shader program of specified type.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_Create(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_ShaderProgram self, OpenGl_Context theCtx)

        Destroys shader program.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_ShaderProgram_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_ShaderProgram self) -> Standard_Size

        Returns estimated GPU memory usage - cannot be easily estimated.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_ShaderProgram_EstimatedDataSize(self, *args)


    def AttachShader(self, *args):
        """
        AttachShader(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, Handle_OpenGl_ShaderObject theShader) -> Standard_Boolean

        Attaches shader object to the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShader: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_AttachShader(self, *args)


    def DetachShader(self, *args):
        """
        DetachShader(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, Handle_OpenGl_ShaderObject theShader) -> Standard_Boolean

        Detaches shader object to the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShader: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_DetachShader(self, *args)


    def Initialize(self, *args):
        """
        Initialize(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, NCollection_Sequence_Handle_Graphic3d_ShaderObject theShaders) -> Standard_Boolean

        Initializes program object with the list of shader objects.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShaders: OCC.wrapper.Graphic3d.Graphic3d_ShaderObjectList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_Initialize(self, *args)


    def Link(self, *args):
        """
        Link(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Links the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_Link(self, *args)


    def FetchInfoLog(self, *args):
        """
        FetchInfoLog(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theLog) -> Standard_Boolean

        Fetches information log of the last link operation.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLog: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_FetchInfoLog(self, *args)


    def ApplyVariables(self, *args):
        """
        ApplyVariables(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Fetches uniform variables from proxy shader program.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_ApplyVariables(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_ShaderProgram self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.OpenGl_ShaderProgram_IsValid(self, *args)


    def ProgramId(self, *args):
        """
        ProgramId(OpenGl_ShaderProgram self) -> GLuint

        @return program ID

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_ShaderProgram_ProgramId(self, *args)


    def HasTessellationStage(self, *args):
        """
        HasTessellationStage(OpenGl_ShaderProgram self) -> Standard_Boolean

        Return TRUE if program defines tessellation stage.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_HasTessellationStage(self, *args)


    def NbLightsMax(self, *args):
        """
        NbLightsMax(OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of light sources (THE_MAX_LIGHTS),
        to be used for initialization occLightSources (OpenGl_OCC_LIGHT_SOURCE_PARAMS).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_ShaderProgram_NbLightsMax(self, *args)


    def NbClipPlanesMax(self, *args):
        """
        NbClipPlanesMax(OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of clipping planes (THE_MAX_CLIP_PLANES),
        to be used for initialization occClipPlaneEquations (OpenGl_OCC_CLIP_PLANE_EQUATIONS).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_ShaderProgram_NbClipPlanesMax(self, *args)


    def NbFragmentOutputs(self, *args):
        """
        NbFragmentOutputs(OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of Fragment Shader outputs (THE_NB_FRAG_OUTPUTS),
        to be used for initialization occFragColorArray/occFragColorN.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_ShaderProgram_NbFragmentOutputs(self, *args)


    def HasAlphaTest(self, *args):
        """
        HasAlphaTest(OpenGl_ShaderProgram self) -> Standard_Boolean

        Return true if Fragment Shader should perform alpha test; FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_HasAlphaTest(self, *args)


    def HasWeightOitOutput(self, *args):
        """
        HasWeightOitOutput(OpenGl_ShaderProgram self) -> Standard_Boolean

        Return true if Fragment Shader color should output the weighted OIT coverage; FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_HasWeightOitOutput(self, *args)


    def GetUniformLocation(self, *args):
        """
        GetUniformLocation(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName) -> GLint

        Returns location of the specific uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theName: GLchar
        :rtype: GLint

        """
        return _OpenGl.OpenGl_ShaderProgram_GetUniformLocation(self, *args)


    def GetAttributeLocation(self, *args):
        """
        GetAttributeLocation(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName) -> GLint

        Returns index of the generic vertex attribute by variable name.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theName: GLchar
        :rtype: GLint

        """
        return _OpenGl.OpenGl_ShaderProgram_GetAttributeLocation(self, *args)


    def GetStateLocation(self, *args):
        """
        GetStateLocation(OpenGl_ShaderProgram self, GLuint const theVariable) -> GLint

        Returns location of the OCCT state uniform variable.

        :type theVariable: GLuint
        :rtype: GLint

        """
        return _OpenGl.OpenGl_ShaderProgram_GetStateLocation(self, *args)


    def GetUniform(self, *args):
        """
        GetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 & theValue) -> Standard_Boolean
        GetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4 & theValue) -> Standard_Boolean

        Returns the value of the float uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_GetUniform(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 & theValue) -> Standard_Boolean
        GetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4 & theValue) -> Standard_Boolean

        Returns the float vertex attribute.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_GetAttribute(self, *args)


    def SetAttributeName(self, *args):
        """
        SetAttributeName(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, GLchar const * theName) -> Standard_Boolean

        Wrapper for glBindAttribLocation()

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theName: GLchar
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_SetAttributeName(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLfloat theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, GLfloat theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetAttribute(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4 const & theValue) -> Standard_Boolean

        Wrapper for glVertexAttrib4fv()

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_SetAttribute(self, *args)


    def SetUniform(self, *args):
        """
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLint theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLint theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec2_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec3_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4i const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec2u const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec2u const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLsizei const theCount, OpenGl_Vec2u const * theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLsizei const theCount, OpenGl_Vec2u const * theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLfloat theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLfloat theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Mat4_Standard_ShortReal theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Mat4_Standard_ShortReal theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Matrix const & theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Matrix const & theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, Standard_ShortReal const * theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec2_Standard_ShortReal theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec3_Standard_ShortReal theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, OpenGl_Vec4 const * theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, Standard_Integer const * theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec2_Standard_Integer theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec3_Standard_Integer theData) -> Standard_Boolean
        SetUniform(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, OpenGl_Vec4i const * theData) -> Standard_Boolean

        Specifies the value of the int4 uniform array

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theCount: GLuint
        :type theData: OCC.wrapper.OpenGl.OpenGl_Vec4i
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_SetUniform(self, *args)


    def SetSampler(self, *args):
        """
        SetSampler(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, Graphic3d_TextureUnit const theTextureUnit) -> Standard_Boolean
        SetSampler(OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, Graphic3d_TextureUnit const theTextureUnit) -> Standard_Boolean

        Specifies the value of the sampler uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_ShaderProgram_SetSampler(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_ShaderProgram
OpenGl_ShaderProgram_swigregister = _OpenGl.OpenGl_ShaderProgram_swigregister
OpenGl_ShaderProgram_swigregister(OpenGl_ShaderProgram)

def OpenGl_ShaderProgram_get_type_name(*args):
    """
    OpenGl_ShaderProgram_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_ShaderProgram_get_type_name(*args)

def OpenGl_ShaderProgram_get_type_descriptor(*args):
    """
    OpenGl_ShaderProgram_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_ShaderProgram_get_type_descriptor(*args)

class OpenGl_StructureShadow(OpenGl_Structure):
    """Dummy structure which just redirects to groups of another structure."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_StructureShadow
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_StructureShadow(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_StructureShadow self, Handle_Graphic3d_StructureManager theManager, Handle_OpenGl_Structure theStructure) -> OpenGl_StructureShadow

        Create empty structure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :type theStructure: OCC.wrapper.OpenGl.Handle_OpenGl_Structure

        """
        this = _OpenGl.new_OpenGl_StructureShadow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_StructureShadow_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_StructureShadow_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_StructureShadow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_StructureShadow
OpenGl_StructureShadow_swigregister = _OpenGl.OpenGl_StructureShadow_swigregister
OpenGl_StructureShadow_swigregister(OpenGl_StructureShadow)

def OpenGl_StructureShadow_get_type_name(*args):
    """
    OpenGl_StructureShadow_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_StructureShadow_get_type_name(*args)

def OpenGl_StructureShadow_get_type_descriptor(*args):
    """
    OpenGl_StructureShadow_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_StructureShadow_get_type_descriptor(*args)

class OpenGl_LineAttributes(OpenGl_Resource):
    """
    Utility class to manage OpenGL state of polygon hatching rasterization
    and keeping its cached state. The hatching rasterization is implemented
    using glPolygonStipple function of OpenGL. State of hatching is controlled
    by two parameters - type of hatching and IsEnabled parameter.
    The hatching rasterization is enabled only if non-zero index pattern type
    is selected (zero by default is reserved for solid filling) and if
    IsEnabled flag is set to true. The IsEnabled parameter is useful for temporarily
    turning on/off the hatching rasterization without making any costly GL calls
    for changing the hatch pattern. This is a sharable resource class - it creates
    OpenGL context objects for each hatch pattern to achieve quicker switching between
    them, thesse GL objects are freed when the resource is released by owner context.
    @note The implementation is not supported by Core Profile and by ES version.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_LineAttributes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_LineAttributes(self) 
            return h


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_LineAttributes self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_LineAttributes_EstimatedDataSize(self, *args)


    def TypeOfHatch(self, *args):
        """
        TypeOfHatch(OpenGl_LineAttributes self) -> int

        Index of currently selected type of hatch.

        :rtype: int

        """
        return _OpenGl.OpenGl_LineAttributes_TypeOfHatch(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(OpenGl_LineAttributes self) -> bool

        Current enabled state of the hatching rasterization.

        :rtype: bool

        """
        return _OpenGl.OpenGl_LineAttributes_IsEnabled(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_LineAttributes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_LineAttributes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_LineAttributes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_LineAttributes
OpenGl_LineAttributes_swigregister = _OpenGl.OpenGl_LineAttributes_swigregister
OpenGl_LineAttributes_swigregister(OpenGl_LineAttributes)

def OpenGl_LineAttributes_get_type_name(*args):
    """
    OpenGl_LineAttributes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_LineAttributes_get_type_name(*args)

def OpenGl_LineAttributes_get_type_descriptor(*args):
    """
    OpenGl_LineAttributes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_LineAttributes_get_type_descriptor(*args)

class OpenGl_Caps(Standard.Standard_Transient):
    """
    Class to define graphic driver capabilities.
    Notice that these options will be ignored if particular functionality does not provided by GL driver
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Caps
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Caps(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Caps self) -> OpenGl_Caps

        Default constructor - initialize with most optimal values.


        """
        this = _OpenGl.new_OpenGl_Caps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def assign(self, *args):
        """
        assign(OpenGl_Caps self, OpenGl_Caps theCopy) -> OpenGl_Caps

        Copy maker.

        :type theCopy: OCC.wrapper.OpenGl.OpenGl_Caps
        :rtype: OCC.wrapper.OpenGl.OpenGl_Caps

        """
        return _OpenGl.OpenGl_Caps_assign(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Caps_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Caps_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Caps_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Caps
OpenGl_Caps_swigregister = _OpenGl.OpenGl_Caps_swigregister
OpenGl_Caps_swigregister(OpenGl_Caps)

def OpenGl_Caps_get_type_name(*args):
    """
    OpenGl_Caps_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Caps_get_type_name(*args)

def OpenGl_Caps_get_type_descriptor(*args):
    """
    OpenGl_Caps_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Caps_get_type_descriptor(*args)

class OpenGl_VertexBufferCompat(OpenGl_VertexBuffer):
    """
    Compatibility layer for old OpenGL without VBO.
    Make sure to pass pointer from GetDataOffset() instead of NULL.
    Method GetDataOffset() returns pointer to real data in this class
    (while base class OpenGl_VertexBuffer always return NULL).

    Methods Bind()/Unbind() do nothing (do not affect OpenGL state)
    and ::GetTarget() is never used.
    For this reason there is no analog for OpenGl_IndexBuffer.
    Just pass GetDataOffset() to glDrawElements() directly as last argument.

    Class overrides methods init() and subData() to copy data into own memory buffer.
    Extra method initLink() might be used to pass existing buffer through handle without copying the data.

    Method Create() creates dummy identifier for this object which should NOT be passed to OpenGL functions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_VertexBufferCompat
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_VertexBufferCompat(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_VertexBufferCompat self) -> OpenGl_VertexBufferCompat

        Create uninitialized VBO.


        """
        this = _OpenGl.new_OpenGl_VertexBufferCompat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Create(self, *args):
        """
        Create(OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO name (id) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBufferCompat_Create(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_VertexBufferCompat self, OpenGl_Context theGlCtx)

        Destroy object - will release memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBufferCompat_Release(self, *args)


    def Bind(self, *args):
        """
        Bind(OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBufferCompat_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_VertexBufferCompat_Unbind(self, *args)


    def initLink(self, *args):
        """
        initLink(OpenGl_VertexBufferCompat self, Handle_NCollection_Buffer theData, GLuint const theComponentsNb, GLsizei const theElemsNb, GLenum const theDataType) -> bool

        Initialize buffer with existing data.
        Data will NOT be copied by this method!

        :type theData: OCC.wrapper.NCollection.Handle_NCollection_Buffer
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBufferCompat_initLink(self, *args)


    def init(self, *args):
        """
        init(OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool

        Initialize buffer with new data (data will be copied).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :type theStride: GLsizei
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBufferCompat_init(self, *args)


    def subData(self, *args):
        """
        subData(OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.OpenGl_VertexBufferCompat_subData(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_VertexBufferCompat_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_VertexBufferCompat_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_VertexBufferCompat_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_VertexBufferCompat
OpenGl_VertexBufferCompat_swigregister = _OpenGl.OpenGl_VertexBufferCompat_swigregister
OpenGl_VertexBufferCompat_swigregister(OpenGl_VertexBufferCompat)

def OpenGl_VertexBufferCompat_get_type_name(*args):
    """
    OpenGl_VertexBufferCompat_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_VertexBufferCompat_get_type_name(*args)

def OpenGl_VertexBufferCompat_get_type_descriptor(*args):
    """
    OpenGl_VertexBufferCompat_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_VertexBufferCompat_get_type_descriptor(*args)

class OpenGl_Workspace(Standard.Standard_Transient):
    """
    Rendering workspace.
    Provides methods to render primitives and maintain GL state.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Workspace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Workspace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Workspace self, OpenGl_View theView, Handle_OpenGl_Window theWindow) -> OpenGl_Workspace

        Constructor of rendering workspace.

        :type theView: OCC.wrapper.OpenGl.OpenGl_View
        :type theWindow: OCC.wrapper.OpenGl.Handle_OpenGl_Window

        """
        this = _OpenGl.new_OpenGl_Workspace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Activate(self, *args):
        """
        Activate(OpenGl_Workspace self) -> Standard_Boolean

        Activate rendering context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Workspace_Activate(self, *args)


    def View(self, *args):
        """
        View(OpenGl_Workspace self) -> OpenGl_View

        :rtype: OCC.wrapper.OpenGl.OpenGl_View

        """
        return _OpenGl.OpenGl_Workspace_View(self, *args)


    def GetGlContext(self, *args):
        """
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.OpenGl_Workspace_GetGlContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FBOCreate(self, *args):
        """
        FBOCreate(OpenGl_Workspace self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Handle_OpenGl_FrameBuffer

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.OpenGl_Workspace_FBOCreate(self, *args)


    def FBORelease(self, *args):
        """
        FBORelease(OpenGl_Workspace self, Handle_OpenGl_FrameBuffer theFbo)

        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.OpenGl_Workspace_FBORelease(self, *args)


    def Width(self, *args):
        """
        Width(OpenGl_Workspace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Workspace_Width(self, *args)


    def Height(self, *args):
        """
        Height(OpenGl_Workspace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Workspace_Height(self, *args)


    def SetUseZBuffer(self, *args):
        """
        SetUseZBuffer(OpenGl_Workspace self, Standard_Boolean const theToUse) -> Standard_Boolean

        Setup Z-buffer usage flag (without affecting GL state!).
        Returns previously set flag.

        :type theToUse: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Workspace_SetUseZBuffer(self, *args)


    def UseZBuffer(self, *args):
        """
        UseZBuffer(OpenGl_Workspace self) -> Standard_Boolean &

        @return true if usage of Z buffer is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Workspace_UseZBuffer(self, *args)


    def UseDepthWrite(self, *args):
        """
        UseDepthWrite(OpenGl_Workspace self) -> Standard_Boolean &

        @return true if depth writing is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Workspace_UseDepthWrite(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(OpenGl_Workspace self) -> Standard_Boolean

        @return true if clipping algorithm enabled

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Workspace_IsCullingEnabled(self, *args)


    def ToAllowFaceCulling(self, *args):
        """
        ToAllowFaceCulling(OpenGl_Workspace self) -> bool

        Return true if active group might activate face culling (e.g. primitives are closed).

        :rtype: bool

        """
        return _OpenGl.OpenGl_Workspace_ToAllowFaceCulling(self, *args)


    def SetAllowFaceCulling(self, *args):
        """
        SetAllowFaceCulling(OpenGl_Workspace self, bool theToAllow)

        Allow or disallow face culling.
        This call does NOT affect current state of back face culling;
        ApplyAspectFace() should be called to update state.

        :type theToAllow: bool

        """
        return _OpenGl.OpenGl_Workspace_SetAllowFaceCulling(self, *args)


    def ToHighlight(self, *args):
        """
        ToHighlight(OpenGl_Workspace self) -> bool

        Return true if following structures should apply highlight color.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Workspace_ToHighlight(self, *args)


    def HighlightStyle(self, *args):
        """
        Return highlight style.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        res = _OpenGl.OpenGl_Workspace_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHighlightStyle(self, *args):
        """
        SetHighlightStyle(OpenGl_Workspace self, Handle_Graphic3d_PresentationAttributes theStyle)

        Set highlight style.

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        return _OpenGl.OpenGl_Workspace_SetHighlightStyle(self, *args)


    def LineColor(self, *args):
        """
        Return line color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_LineColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeColor(self, *args):
        """
        Return edge color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_EdgeColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MarkerColor(self, *args):
        """
        Return marker color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_MarkerColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InteriorColor(self, *args):
        """
        Return Interior color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_InteriorColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextColor(self, *args):
        """
        Return text color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_TextColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextSubtitleColor(self, *args):
        """
        Return text Subtitle color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_Workspace_TextSubtitleColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AspectLine(self, *args):
        """
        AspectLine(OpenGl_Workspace self) -> OpenGl_AspectLine

        Currently set line aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.OpenGl_Workspace_AspectLine(self, *args)


    def AspectFace(self, *args):
        """
        AspectFace(OpenGl_Workspace self) -> OpenGl_AspectFace

        Currently set face aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.OpenGl_Workspace_AspectFace(self, *args)


    def AspectMarker(self, *args):
        """
        AspectMarker(OpenGl_Workspace self) -> OpenGl_AspectMarker

        Currently set marker aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.OpenGl_Workspace_AspectMarker(self, *args)


    def AspectText(self, *args):
        """
        AspectText(OpenGl_Workspace self) -> OpenGl_AspectText

        Currently set text aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.OpenGl_Workspace_AspectText(self, *args)


    def SetAspectLine(self, *args):
        """
        SetAspectLine(OpenGl_Workspace self, OpenGl_AspectLine theAspect) -> OpenGl_AspectLine

        Assign new line aspect (will be applied within ApplyAspectLine()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectLine
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.OpenGl_Workspace_SetAspectLine(self, *args)


    def SetAspectFace(self, *args):
        """
        SetAspectFace(OpenGl_Workspace self, OpenGl_AspectFace theAspect) -> OpenGl_AspectFace

        Assign new face aspect (will be applied within ApplyAspectFace()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.OpenGl_Workspace_SetAspectFace(self, *args)


    def SetAspectMarker(self, *args):
        """
        SetAspectMarker(OpenGl_Workspace self, OpenGl_AspectMarker theAspect) -> OpenGl_AspectMarker

        Assign new marker aspect (will be applied within ApplyAspectMarker()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectMarker
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.OpenGl_Workspace_SetAspectMarker(self, *args)


    def SetAspectText(self, *args):
        """
        SetAspectText(OpenGl_Workspace self, OpenGl_AspectText theAspect) -> OpenGl_AspectText

        Assign new text aspect (will be applied within ApplyAspectText()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.OpenGl_Workspace_SetAspectText(self, *args)


    def ApplyAspectLine(self, *args):
        """
        ApplyAspectLine(OpenGl_Workspace self) -> OpenGl_AspectLine

        Apply line aspect.
        @return aspect set by SetAspectLine()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.OpenGl_Workspace_ApplyAspectLine(self, *args)


    def ApplyAspectFace(self, *args):
        """
        ApplyAspectFace(OpenGl_Workspace self) -> OpenGl_AspectFace

        Apply face aspect.
        @return aspect set by SetAspectFace()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.OpenGl_Workspace_ApplyAspectFace(self, *args)


    def ApplyAspectMarker(self, *args):
        """
        ApplyAspectMarker(OpenGl_Workspace self) -> OpenGl_AspectMarker

        Apply marker aspect.
        @return aspect set by SetAspectMarker()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.OpenGl_Workspace_ApplyAspectMarker(self, *args)


    def ApplyAspectText(self, *args):
        """
        ApplyAspectText(OpenGl_Workspace self) -> OpenGl_AspectText

        Apply text aspect.
        @return aspect set by SetAspectText()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.OpenGl_Workspace_ApplyAspectText(self, *args)


    def SetRenderFilter(self, *args):
        """
        SetRenderFilter(OpenGl_Workspace self, Handle_OpenGl_RenderFilter theFilter)

        Set filter for restricting rendering of particular elements.
        Filter can be applied for rendering passes used by recursive
        rendering algorithms for rendering elements of groups.
        @param theFilter [in] the filter instance.

        :type theFilter: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        return _OpenGl.OpenGl_Workspace_SetRenderFilter(self, *args)


    def GetRenderFilter(self, *args):
        """
        Get rendering filter.
        @return filter instance.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        res = _OpenGl.OpenGl_Workspace_GetRenderFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ViewMatrix(self, *args):
        """
        ViewMatrix(OpenGl_Workspace self) -> OpenGl_Matrix const *

        @return applied view matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.OpenGl_Workspace_ViewMatrix(self, *args)


    def ModelMatrix(self, *args):
        """
        ModelMatrix(OpenGl_Workspace self) -> OpenGl_Matrix const *

        @return applied model structure matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.OpenGl_Workspace_ModelMatrix(self, *args)


    def FontFaceAspect(self, *args):
        """
        Returns face aspect for textured font rendering.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.OpenGl_Workspace_FontFaceAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefaultCappingAlgoFilter(self, *args):
        """
        Returns capping algorithm rendering filter.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_CappingAlgoFilter

        """
        res = _OpenGl.OpenGl_Workspace_DefaultCappingAlgoFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NoneCulling(self, *args):
        """
        Returns face aspect for none culling mode.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.OpenGl_Workspace_NoneCulling(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FrontCulling(self, *args):
        """
        Returns face aspect for front face culling mode.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.OpenGl_Workspace_FrontCulling(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEnvironmentTexture(self, *args):
        """
        SetEnvironmentTexture(OpenGl_Workspace self, Handle_OpenGl_TextureSet theTexture)

        Sets a new environment texture.

        :type theTexture: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        return _OpenGl.OpenGl_Workspace_SetEnvironmentTexture(self, *args)


    def EnvironmentTexture(self, *args):
        """
        Returns environment texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_Workspace_EnvironmentTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Workspace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Workspace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Workspace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Workspace
OpenGl_Workspace_swigregister = _OpenGl.OpenGl_Workspace_swigregister
OpenGl_Workspace_swigregister(OpenGl_Workspace)

def OpenGl_Workspace_get_type_name(*args):
    """
    OpenGl_Workspace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Workspace_get_type_name(*args)

def OpenGl_Workspace_get_type_descriptor(*args):
    """
    OpenGl_Workspace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Workspace_get_type_descriptor(*args)

class OpenGl_Window(Standard.Standard_Transient):
    """
    This class represents low-level wrapper over window with GL context.
    The window itself should be provided to constructor.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Window
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Window(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OpenGl_Window self, Handle_OpenGl_GraphicDriver theDriver, Handle_Aspect_Window thePlatformWindow, Aspect_RenderingContext theGContext, Handle_OpenGl_Caps theCaps, Handle_OpenGl_Context theShareCtx) -> OpenGl_Window

        Main constructor - prepare GL context for specified window.

        :type theDriver: OCC.wrapper.OpenGl.Handle_OpenGl_GraphicDriver
        :type thePlatformWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theGContext: OCC.wrapper.Aspect.Aspect_RenderingContext
        :type theCaps: OCC.wrapper.OpenGl.Handle_OpenGl_Caps
        :type theShareCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        this = _OpenGl.new_OpenGl_Window(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Resize(self, *args):
        """
        Resize(OpenGl_Window self)

        Resizes the window.


        """
        return _OpenGl.OpenGl_Window_Resize(self, *args)


    def PlatformWindow(self, *args):
        """
        PlatformWindow(OpenGl_Window self) -> Handle_Aspect_Window

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _OpenGl.OpenGl_Window_PlatformWindow(self, *args)


    def Width(self, *args):
        """
        Width(OpenGl_Window self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Window_Width(self, *args)


    def Height(self, *args):
        """
        Height(OpenGl_Window self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Window_Height(self, *args)


    def GetGlContext(self, *args):
        """
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.OpenGl_Window_GetGlContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(OpenGl_Window self)

        Activates GL context and setup viewport.


        """
        return _OpenGl.OpenGl_Window_Init(self, *args)


    def Activate(self, *args):
        """
        Activate(OpenGl_Window self) -> Standard_Boolean

        Makes GL context for this window active in current thread

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Window_Activate(self, *args)


    def SetSwapInterval(self, *args):
        """
        SetSwapInterval(OpenGl_Window self)

        Sets swap interval for this window according to the context's settings.


        """
        return _OpenGl.OpenGl_Window_SetSwapInterval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Window_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Window_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Window_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_Window
OpenGl_Window_swigregister = _OpenGl.OpenGl_Window_swigregister
OpenGl_Window_swigregister(OpenGl_Window)

def OpenGl_Window_get_type_name(*args):
    """
    OpenGl_Window_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Window_get_type_name(*args)

def OpenGl_Window_get_type_descriptor(*args):
    """
    OpenGl_Window_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Window_get_type_descriptor(*args)

class OpenGl_GraphicDriver(Graphic3d.Graphic3d_GraphicDriver):
    """This class defines an OpenGl graphic driver"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_GraphicDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_GraphicDriver(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_GraphicDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_GraphicDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_GraphicDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_GraphicDriver self, Handle_Aspect_DisplayConnection theDisp, Standard_Boolean const theToInitialize) -> OpenGl_GraphicDriver

        Constructor.
        @param theDisp connection to display, required on Linux but optional on other systems
        @param theToInitialize perform initialization of default OpenGL context on construction

        :type theDisp: OCC.wrapper.Aspect.Handle_Aspect_DisplayConnection
        :type theToInitialize: bool

        """
        this = _OpenGl.new_OpenGl_GraphicDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ReleaseContext(self, *args):
        """
        ReleaseContext(OpenGl_GraphicDriver self)

        Release default context.


        """
        return _OpenGl.OpenGl_GraphicDriver_ReleaseContext(self, *args)


    def InitContext(self, *args):
        """
        InitContext(OpenGl_GraphicDriver self) -> Standard_Boolean

        Perform initialization of default OpenGL context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_GraphicDriver_InitContext(self, *args)


    def InquireLimit(self, *args):
        """
        InquireLimit(OpenGl_GraphicDriver self, Graphic3d_TypeOfLimit const theType) -> Standard_Integer

        Request limit of graphic resource of specific type.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLimit
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_GraphicDriver_InquireLimit(self, *args)


    def CreateStructure(self, *args):
        """
        CreateStructure(OpenGl_GraphicDriver self, Handle_Graphic3d_StructureManager theManager) -> Handle_Graphic3d_CStructure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.OpenGl_GraphicDriver_CreateStructure(self, *args)


    def RemoveStructure(self, *args):
        """
        RemoveStructure(OpenGl_GraphicDriver self, Handle_Graphic3d_CStructure theCStructure)

        :type theCStructure: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.OpenGl_GraphicDriver_RemoveStructure(self, *args)


    def CreateView(self, *args):
        """
        CreateView(OpenGl_GraphicDriver self, Handle_Graphic3d_StructureManager theMgr) -> Handle_Graphic3d_CView

        :type theMgr: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _OpenGl.OpenGl_GraphicDriver_CreateView(self, *args)


    def RemoveView(self, *args):
        """
        RemoveView(OpenGl_GraphicDriver self, Handle_Graphic3d_CView theView)

        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _OpenGl.OpenGl_GraphicDriver_RemoveView(self, *args)


    def CreateRenderWindow(self, *args):
        """
        CreateRenderWindow(OpenGl_GraphicDriver self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext) -> Handle_OpenGl_Window

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Window

        """
        return _OpenGl.OpenGl_GraphicDriver_CreateRenderWindow(self, *args)


    def TextSize(self, *args):
        """
        TextSize(OpenGl_GraphicDriver self, Handle_Graphic3d_CView theView, Standard_CString const theText, Standard_ShortReal const theHeight)

        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView
        :type theText: OCC.wrapper.Standard.Standard_CString
        :type theHeight: float
        :type theWidth: float
        :type theAscent: float
        :type theDescent: float

        """
        return _OpenGl.OpenGl_GraphicDriver_TextSize(self, *args)


    def DefaultTextHeight(self, *args):
        """
        DefaultTextHeight(OpenGl_GraphicDriver self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_GraphicDriver_DefaultTextHeight(self, *args)


    def ViewExists(self, *args):
        """
        ViewExists(OpenGl_GraphicDriver self, Handle_Aspect_Window theWindow, Handle_Graphic3d_CView theView) -> Standard_Boolean

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_GraphicDriver_ViewExists(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Adds a new top-level z layer with ID theLayerId for all views. Z layers allow drawing structures in higher layers
        in foreground of structures in lower layers. To add a structure to desired layer on display it is necessary to
        set the layer index for the structure. The passed theLayerId should be not less than 0 (reserved for default layers).

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_GraphicDriver_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Removes Z layer. All structures displayed at the moment in layer will be displayed in
        default layer (the bottom-level z layer). By default, there are always default
        bottom-level layer that can't be removed.  The passed theLayerId should be not less than 0
        (reserved for default layers that can not be removed).

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_GraphicDriver_RemoveZLayer(self, *args)


    def ZLayers(self, *args):
        """
        ZLayers(OpenGl_GraphicDriver self, NCollection_Sequence_Standard_Integer theLayerSeq)

        Returns list of Z layers defined for the graphical driver.

        :type theLayerSeq: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _OpenGl.OpenGl_GraphicDriver_ZLayers(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _OpenGl.OpenGl_GraphicDriver_SetZLayerSettings(self, *args)


    def ZLayerSettings(self, *args):
        """
        Returns the settings of a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        res = _OpenGl.OpenGl_GraphicDriver_ZLayerSettings(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Options(self, *args):
        """
        @return the visualization options

        :rtype: OCC.wrapper.OpenGl.OpenGl_Caps

        """
        res = _OpenGl.OpenGl_GraphicDriver_Options(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeOptions(self, *args):
        """
        ChangeOptions(OpenGl_GraphicDriver self) -> OpenGl_Caps

        @return the visualization options

        :rtype: OCC.wrapper.OpenGl.OpenGl_Caps

        """
        return _OpenGl.OpenGl_GraphicDriver_ChangeOptions(self, *args)


    def SetBuffersNoSwap(self, *args):
        """
        SetBuffersNoSwap(OpenGl_GraphicDriver self, Standard_Boolean const theIsNoSwap)

        Specify swap buffer behavior.

        :type theIsNoSwap: bool

        """
        return _OpenGl.OpenGl_GraphicDriver_SetBuffersNoSwap(self, *args)


    def EnableVBO(self, *args):
        """
        EnableVBO(OpenGl_GraphicDriver self, Standard_Boolean const theToTurnOn)

        VBO usage can be forbidden by this method even if it is supported by GL driver.
        Notice that disabling of VBO will cause rendering performance degradation.
        Warning! This method should be called only before any primitives are displayed in GL scene!

        :type theToTurnOn: bool

        """
        return _OpenGl.OpenGl_GraphicDriver_EnableVBO(self, *args)


    def MemoryInfo(self, *args):
        """
        MemoryInfo(OpenGl_GraphicDriver self, TCollection_AsciiString theInfo) -> Standard_Boolean

        Returns information about GPU memory usage.
        Please read OpenGl_Context::MemoryInfo() for more description.

        :type theFreeBytes: int
        :type theInfo: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_GraphicDriver_MemoryInfo(self, *args)


    def GetSharedContext(self, *args):
        """
        Method to retrieve valid GL context.
        Could return NULL-handle if no window created by this driver.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.OpenGl_GraphicDriver_GetSharedContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def addZLayerIndex(self, *args):
        """
        addZLayerIndex(OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Insert index layer at proper position.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.OpenGl_GraphicDriver_addZLayerIndex(self, *args)


    def setDeviceLost(self, *args):
        """
        setDeviceLost(OpenGl_GraphicDriver self)

        Set device lost flag for redrawn views.


        """
        return _OpenGl.OpenGl_GraphicDriver_setDeviceLost(self, *args)


    def GetStateCounter(self, *args):
        """
        GetStateCounter(OpenGl_GraphicDriver self) -> OpenGl_StateCounter

        State counter for OpenGl structures.

        :rtype: OCC.wrapper.OpenGl.OpenGl_StateCounter

        """
        return _OpenGl.OpenGl_GraphicDriver_GetStateCounter(self, *args)


    def GetNextPrimitiveArrayUID(self, *args):
        """
        GetNextPrimitiveArrayUID(OpenGl_GraphicDriver self) -> Standard_Size

        Returns unique ID for primitive arrays.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_GraphicDriver_GetNextPrimitiveArrayUID(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_GraphicDriver
OpenGl_GraphicDriver_swigregister = _OpenGl.OpenGl_GraphicDriver_swigregister
OpenGl_GraphicDriver_swigregister(OpenGl_GraphicDriver)

def OpenGl_GraphicDriver_get_type_name(*args):
    """
    OpenGl_GraphicDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_GraphicDriver_get_type_name(*args)

def OpenGl_GraphicDriver_get_type_descriptor(*args):
    """
    OpenGl_GraphicDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_GraphicDriver_get_type_descriptor(*args)

class BVH_Tree_Standard_ShortReal__BVH_QuadTree(object):
    """BVH tree with given arity (2 or 4)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """BVH tree with given arity (2 or 4)."""
        this = _OpenGl.new_BVH_Tree_Standard_ShortReal__BVH_QuadTree()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_BVH_Tree_Standard_ShortReal__BVH_QuadTree
BVH_Tree_Standard_ShortReal__BVH_QuadTree_swigregister = _OpenGl.BVH_Tree_Standard_ShortReal__BVH_QuadTree_swigregister
BVH_Tree_Standard_ShortReal__BVH_QuadTree_swigregister(BVH_Tree_Standard_ShortReal__BVH_QuadTree)

class OpenGl_AspectMarker(object):
    """The element holding Graphic3d_AspectMarker3d."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_AspectMarker self) -> OpenGl_AspectMarker
        __init__(OpenGl_AspectMarker self, Handle_Graphic3d_AspectMarker3d theAspect) -> OpenGl_AspectMarker

        Create and assign parameters.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        this = _OpenGl.new_OpenGl_AspectMarker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Aspect(self, *args):
        """
        Return the aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        res = _OpenGl.OpenGl_AspectMarker_Aspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAspect(self, *args):
        """
        SetAspect(OpenGl_AspectMarker self, Handle_Graphic3d_AspectMarker3d theAspect)

        Assign new aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _OpenGl.OpenGl_AspectMarker_SetAspect(self, *args)


    def MarkerSize(self, *args):
        """
        MarkerSize(OpenGl_AspectMarker self) -> Standard_ShortReal

        @return marker size

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_AspectMarker_MarkerSize(self, *args)


    def SpriteRes(self, *args):
        """
        Init and return OpenGl point sprite resource.
        @return point sprite texture.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_AspectMarker_SpriteRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SpriteHighlightRes(self, *args):
        """
        Init and return OpenGl highlight point sprite resource.
        @return point sprite texture for highlight.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_AspectMarker_SpriteHighlightRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShaderProgramRes(self, *args):
        """
        Init and return OpenGl shader program resource.
        @return shader program resource.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.OpenGl_AspectMarker_ShaderProgramRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Render(self, *args):
        """
        Render(OpenGl_AspectMarker self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_AspectMarker_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_AspectMarker self, OpenGl_Context theContext)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_AspectMarker_Release(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_AspectMarker
OpenGl_AspectMarker_swigregister = _OpenGl.OpenGl_AspectMarker_swigregister
OpenGl_AspectMarker_swigregister(OpenGl_AspectMarker)

class OpenGl_BVHClipPrimitiveSet(object):
    """Set of OpenGl_Structures for building BVH tree."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_BVHClipPrimitiveSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_BVHClipPrimitiveSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_BVHClipPrimitiveSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Structures(self, *args):
        """
        Access directly a collection of structures.

        :rtype: OCC.wrapper.OpenGl.NCollection_IndexedMap_OpenGl_Structure

        """
        res = _OpenGl.OpenGl_BVHClipPrimitiveSet_Structures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_BVHClipPrimitiveSet
OpenGl_BVHClipPrimitiveSet_swigregister = _OpenGl.OpenGl_BVHClipPrimitiveSet_swigregister
OpenGl_BVHClipPrimitiveSet_swigregister(OpenGl_BVHClipPrimitiveSet)

def OpenGl_BVHClipPrimitiveSet_get_type_name(*args):
    """
    OpenGl_BVHClipPrimitiveSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_BVHClipPrimitiveSet_get_type_name(*args)

def OpenGl_BVHClipPrimitiveSet_get_type_descriptor(*args):
    """
    OpenGl_BVHClipPrimitiveSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_BVHClipPrimitiveSet_get_type_descriptor(*args)

class OpenGl_ModelWorldState(OpenGl_StateInterface):
    """Defines state of OCCT model-world transformation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_ModelWorldState self, NCollection_Mat4_Standard_ShortReal theModelWorldMatrix)

        Sets new model-world matrix.

        :type theModelWorldMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_ModelWorldState_Set(self, *args)


    def ModelWorldMatrix(self, *args):
        """
        Returns current model-world matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_ModelWorldState_ModelWorldMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModelWorldMatrixInverse(self, *args):
        """
        Returns inverse of current model-world matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_ModelWorldState_ModelWorldMatrixInverse(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_ModelWorldState
OpenGl_ModelWorldState_swigregister = _OpenGl.OpenGl_ModelWorldState_swigregister
OpenGl_ModelWorldState_swigregister(OpenGl_ModelWorldState)

class OpenGl_TmplCore43_OpenGl_GlCore42Back(object):
    """OpenGL 4.3 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.3 definition."""
        this = _OpenGl.new_OpenGl_TmplCore43_OpenGl_GlCore42Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore43_OpenGl_GlCore42Back
OpenGl_TmplCore43_OpenGl_GlCore42Back_swigregister = _OpenGl.OpenGl_TmplCore43_OpenGl_GlCore42Back_swigregister
OpenGl_TmplCore43_OpenGl_GlCore42Back_swigregister(OpenGl_TmplCore43_OpenGl_GlCore42Back)


try:
	OpenGl_GlCore43Back = OpenGl_TmplCore43_OpenGl_GlCore42Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_StencilTest(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
OpenGl_StencilTest_swigregister = _OpenGl.OpenGl_StencilTest_swigregister
OpenGl_StencilTest_swigregister(OpenGl_StencilTest)

class Handle_OpenGl_PointSprite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_PointSprite self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_PointSprite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_PointSprite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_PointSprite self, OpenGl_PointSprite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_PointSprite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_PointSprite self, Handle_OpenGl_PointSprite theHandle) -> Handle_OpenGl_PointSprite
        assign(Handle_OpenGl_PointSprite self, OpenGl_PointSprite thePtr) -> Handle_OpenGl_PointSprite
        assign(Handle_OpenGl_PointSprite self, Handle_OpenGl_PointSprite theHandle) -> Handle_OpenGl_PointSprite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_PointSprite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_PointSprite self) -> OpenGl_PointSprite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_PointSprite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_PointSprite self) -> OpenGl_PointSprite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_PointSprite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_PointSprite self) -> OpenGl_PointSprite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_PointSprite___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_PointSprite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_PointSprite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_PointSprite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_PointSprite_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_PointSprite

    def Release(self, *args):
        """
        Release(Handle_OpenGl_PointSprite self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Release(self, *args)


    def IsDisplayList(self, *args):
        """
        IsDisplayList(Handle_OpenGl_PointSprite self) -> Standard_Boolean

        @return true if this is display list bitmap

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsDisplayList(self, *args)


    def DrawBitmap(self, *args):
        """
        DrawBitmap(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx)

        Draw sprite using glBitmap.
        Please call glRasterPos3fv() before to setup sprite position.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_PointSprite_DrawBitmap(self, *args)


    def SetDisplayList(self, *args):
        """
        SetDisplayList(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, GLuint const theBitmapList)

        Initialize point sprite as display list

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theBitmapList: GLuint

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SetDisplayList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_PointSprite self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_PointSprite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_PointSprite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_PointSprite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PixelSizeOfPixelFormat(self, *args):
        """
        PixelSizeOfPixelFormat(Handle_OpenGl_PointSprite self, Standard_Integer theInternalFormat) -> Standard_Size

        Return pixel size of pixel format in bytes.
        Note that this method considers that OpenGL natively supports this pixel format,
        which might be not the case - in the latter case, actual pixel size might differ!

        :type theInternalFormat: int
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_PointSprite_PixelSizeOfPixelFormat(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_PointSprite self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsValid(self, *args)


    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_PointSprite self) -> GLenum

        @return target to which the texture is bound (GL_TEXTURE_1D, GL_TEXTURE_2D)

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_PointSprite_GetTarget(self, *args)


    def SizeX(self, *args):
        """
        SizeX(Handle_OpenGl_PointSprite self) -> GLsizei

        @return texture width (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(Handle_OpenGl_PointSprite self) -> GLsizei

        @return texture height (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SizeY(self, *args)


    def TextureId(self, *args):
        """
        TextureId(Handle_OpenGl_PointSprite self) -> GLuint

        @return texture ID

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_PointSprite_TextureId(self, *args)


    def GetFormat(self, *args):
        """
        GetFormat(Handle_OpenGl_PointSprite self) -> GLenum

        @return texture format (not sized)

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_PointSprite_GetFormat(self, *args)


    def IsAlpha(self, *args):
        """
        IsAlpha(Handle_OpenGl_PointSprite self) -> bool

        Return true for GL_RED and GL_ALPHA formats.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsAlpha(self, *args)


    def SetAlpha(self, *args):
        """
        SetAlpha(Handle_OpenGl_PointSprite self, bool const theValue)

        Setup to interprete the format as Alpha by Shader Manager
        (should be GL_ALPHA within compatible context or GL_RED otherwise).

        :type theValue: const bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SetAlpha(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx) -> bool

        Creates Texture id if not yet generated.
        Data should be initialized by another method.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Create(self, *args)


    def Sampler(self, *args):
        """
        Return texture sampler.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        res = _OpenGl.Handle_OpenGl_PointSprite_Sampler(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSampler(self, *args):
        """
        SetSampler(Handle_OpenGl_PointSprite self, Handle_OpenGl_Sampler theSampler)

        Set texture sampler.

        :type theSampler: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SetSampler(self, *args)


    def InitSamplerObject(self, *args):
        """
        InitSamplerObject(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx) -> bool

        Initialize the Sampler Object (as OpenGL object).
        @param theCtx currently bound OpenGL context

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_InitSamplerObject(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx)
        Bind(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Bind this Texture to specified unit.
        Also binds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx)
        Unbind(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Unbind texture from specified unit.
        Also unbinds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Unbind(self, *args)


    def Revision(self, *args):
        """
        Revision(Handle_OpenGl_PointSprite self) -> Standard_Size

        Revision of associated data source.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Revision(self, *args)


    def SetRevision(self, *args):
        """
        SetRevision(Handle_OpenGl_PointSprite self, Standard_Size const theRevision)

        Set revision of associated data source.

        :type theRevision: int

        """
        return _OpenGl.Handle_OpenGl_PointSprite_SetRevision(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, Image_PixMap theImage, Graphic3d_TypeOfTexture const theType) -> bool
        Init(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, GLsizei const theSizeX, GLsizei const theSizeY, Graphic3d_TypeOfTexture const theType, Image_PixMap theImage=None) -> bool

        Initialize the texture with specified format, size and texture type.
        If theImage is empty the texture data will contain trash.
        Notice that texture will be unbound after this call.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfTexture
        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Init(self, *args)


    def Init2DMultisample(self, *args):
        """
        Init2DMultisample(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, GLsizei const theNbSamples, GLint const theTextFormat, GLsizei const theSizeX, GLsizei const theSizeY) -> bool

        Initialize the 2D multisampling texture using glTexImage2DMultisample().

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theNbSamples: GLsizei
        :type theTextFormat: GLint
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Init2DMultisample(self, *args)


    def InitRectangle(self, *args):
        """
        InitRectangle(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, Standard_Integer const theSizeX, Standard_Integer const theSizeY, OpenGl_TextureFormat theFormat) -> bool

        Allocates texture rectangle with specified format and size.

        ote Texture data is not initialized (will contain trash).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: int
        :type theSizeY: int
        :type theFormat: OCC.wrapper.OpenGl.OpenGl_TextureFormat
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_InitRectangle(self, *args)


    def Init3D(self, *args):
        """
        Init3D(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, Standard_Integer const theSizeX, Standard_Integer const theSizeY, Standard_Integer const theSizeZ, void const * thePixels) -> bool

        Initializes 3D texture rectangle with specified format and size.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeZ: int
        :type thePixels: const void *
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_Init3D(self, *args)


    def HasMipmaps(self, *args):
        """
        HasMipmaps(Handle_OpenGl_PointSprite self) -> Standard_Boolean

        @return true if texture was generated within mipmaps

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_PointSprite_HasMipmaps(self, *args)


    def GetDataFormat(self, *args):
        """
        GetDataFormat(Handle_OpenGl_PointSprite self, Handle_OpenGl_Context theCtx, Image_PixMap theData, GLint & theTextFormat, GLenum & thePixelFormat, GLenum & theDataType) -> bool

        Return texture type and format by Image_PixMap data format.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theData: OCC.wrapper.Image.Image_PixMap
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_PointSprite_GetDataFormat(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_PointSprite self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_PointSprite_EstimatedDataSize(self, *args)


    def ResourceId(self, *args):
        """
        Return resource name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.Handle_OpenGl_PointSprite_ResourceId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_PointSprite self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_PointSprite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_PointSprite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_PointSprite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_PointSprite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_PointSprite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_PointSprite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_PointSprite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_PointSprite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_PointSprite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_PointSprite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_PointSprite self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_PointSprite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_PointSprite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_PointSprite_DecrementRefCounter(self, *args)

Handle_OpenGl_PointSprite_swigregister = _OpenGl.Handle_OpenGl_PointSprite_swigregister
Handle_OpenGl_PointSprite_swigregister(Handle_OpenGl_PointSprite)

def Handle_OpenGl_PointSprite_DownCast(thing):
    return _OpenGl.Handle_OpenGl_PointSprite_DownCast(thing)
Handle_OpenGl_PointSprite_DownCast = _OpenGl.Handle_OpenGl_PointSprite_DownCast

class NCollection_Sequence_Handle_OpenGl_Layer(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_OpenGl_Layer self) -> NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_OpenGl_Layer self) -> NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_OpenGl_Layer self) -> NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_OpenGl_Layer self) -> NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_Layer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_OpenGl_Layer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_OpenGl_Layer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_OpenGl_Layer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_OpenGl_Layer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_OpenGl_Layer self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_OpenGl_Layer self)

        Reverse sequence


        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_OpenGl_Layer self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence_Handle_OpenGl_Layer theOther) -> NCollection_Sequence_Handle_OpenGl_Layer

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence_Handle_OpenGl_Layer theOther) -> NCollection_Sequence_Handle_OpenGl_Layer

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_OpenGl_Layer self, Handle_OpenGl_Layer theItem)
        Append(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence_Handle_OpenGl_Layer theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_OpenGl_Layer self, Handle_OpenGl_Layer theItem)
        Prepend(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence_Handle_OpenGl_Layer theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, Handle_OpenGl_Layer theItem)
        InsertBefore(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_Layer theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_OpenGl_Layer self, NCollection_Sequence< opencascade::handle< OpenGl_Layer > >::Iterator & thePosition, Handle_OpenGl_Layer theItem)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_Layer theSeq)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, Handle_OpenGl_Layer theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_Layer theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_OpenGl_Layer self) -> Handle_OpenGl_Layer

        First item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_OpenGl_Layer self) -> Handle_OpenGl_Layer

        Last item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex) -> Handle_OpenGl_Layer

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_OpenGl_Layer self, Standard_Integer const theIndex, Handle_OpenGl_Layer theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_SetValue(self, *args)


    def __iter__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer___iter__(self)
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_Layer
NCollection_Sequence_Handle_OpenGl_Layer_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_swigregister
NCollection_Sequence_Handle_OpenGl_Layer_swigregister(NCollection_Sequence_Handle_OpenGl_Layer)

def NCollection_Sequence_Handle_OpenGl_Layer_delNode(*args):
    """
    NCollection_Sequence_Handle_OpenGl_Layer_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_delNode(*args)

class NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper

    def __next__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper___next__(self)
NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper_swigregister
NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper_swigregister(NCollection_Sequence_Handle_OpenGl_Layer_IteratorHelper)


try:
	OpenGl_SequenceOfLayers = NCollection_Sequence_Handle_OpenGl_Layer
except NameError:
	pass # does not exist, probably ignored

class OpenGl_FrameStatsPrs(OpenGl_Text):
    """Element rendering frame statistics."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_FrameStatsPrs self) -> OpenGl_FrameStatsPrs

        Default constructor.


        """
        this = _OpenGl.new_OpenGl_FrameStatsPrs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Render(self, *args):
        """
        Render(OpenGl_FrameStatsPrs self, Handle_OpenGl_Workspace theWorkspace)

        Render element.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_FrameStatsPrs_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_FrameStatsPrs self, OpenGl_Context theCtx)

        Release OpenGL resources.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_FrameStatsPrs_Release(self, *args)


    def Update(self, *args):
        """
        Update(OpenGl_FrameStatsPrs self, Handle_OpenGl_Workspace theWorkspace)

        Update text.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_FrameStatsPrs_Update(self, *args)


    def SetTextAspect(self, *args):
        """
        SetTextAspect(OpenGl_FrameStatsPrs self, Handle_Graphic3d_AspectText3d theAspect)

        Assign text aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.OpenGl_FrameStatsPrs_SetTextAspect(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_FrameStatsPrs
OpenGl_FrameStatsPrs_swigregister = _OpenGl.OpenGl_FrameStatsPrs_swigregister
OpenGl_FrameStatsPrs_swigregister(OpenGl_FrameStatsPrs)

class OpenGl_AspectLine(object):
    """The element holding Graphic3d_AspectLine3d."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_AspectLine self) -> OpenGl_AspectLine
        __init__(OpenGl_AspectLine self, Handle_Graphic3d_AspectLine3d theAspect) -> OpenGl_AspectLine

        Create and assign line aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        this = _OpenGl.new_OpenGl_AspectLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Aspect(self, *args):
        """
        Return line aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        res = _OpenGl.OpenGl_AspectLine_Aspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAspect(self, *args):
        """
        SetAspect(OpenGl_AspectLine self, Handle_Graphic3d_AspectLine3d theAspect)

        Assign line aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        return _OpenGl.OpenGl_AspectLine_SetAspect(self, *args)


    def ShaderProgramRes(self, *args):
        """
        Init and return OpenGl shader program resource.
        @return shader program resource.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.OpenGl_AspectLine_ShaderProgramRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Render(self, *args):
        """
        Render(OpenGl_AspectLine self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_AspectLine_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_AspectLine self, OpenGl_Context theContext)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_AspectLine_Release(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_AspectLine
OpenGl_AspectLine_swigregister = _OpenGl.OpenGl_AspectLine_swigregister
OpenGl_AspectLine_swigregister(OpenGl_AspectLine)

class Handle_OpenGl_Texture(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Texture self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Texture_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Texture self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Texture self, OpenGl_Texture thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Texture_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Texture self, Handle_OpenGl_Texture theHandle) -> Handle_OpenGl_Texture
        assign(Handle_OpenGl_Texture self, OpenGl_Texture thePtr) -> Handle_OpenGl_Texture
        assign(Handle_OpenGl_Texture self, Handle_OpenGl_Texture theHandle) -> Handle_OpenGl_Texture

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Texture_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Texture self) -> OpenGl_Texture

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Texture_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Texture self) -> OpenGl_Texture

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Texture___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Texture self) -> OpenGl_Texture

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Texture___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Texture___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Texture___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Texture(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Texture_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Texture

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Texture self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Texture_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Texture_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Texture_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PixelSizeOfPixelFormat(self, *args):
        """
        PixelSizeOfPixelFormat(Handle_OpenGl_Texture self, Standard_Integer theInternalFormat) -> Standard_Size

        Return pixel size of pixel format in bytes.
        Note that this method considers that OpenGL natively supports this pixel format,
        which might be not the case - in the latter case, actual pixel size might differ!

        :type theInternalFormat: int
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Texture_PixelSizeOfPixelFormat(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_Texture self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_IsValid(self, *args)


    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_Texture self) -> GLenum

        @return target to which the texture is bound (GL_TEXTURE_1D, GL_TEXTURE_2D)

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_Texture_GetTarget(self, *args)


    def SizeX(self, *args):
        """
        SizeX(Handle_OpenGl_Texture self) -> GLsizei

        @return texture width (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_Texture_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(Handle_OpenGl_Texture self) -> GLsizei

        @return texture height (0 LOD)

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_Texture_SizeY(self, *args)


    def TextureId(self, *args):
        """
        TextureId(Handle_OpenGl_Texture self) -> GLuint

        @return texture ID

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_Texture_TextureId(self, *args)


    def GetFormat(self, *args):
        """
        GetFormat(Handle_OpenGl_Texture self) -> GLenum

        @return texture format (not sized)

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_Texture_GetFormat(self, *args)


    def IsAlpha(self, *args):
        """
        IsAlpha(Handle_OpenGl_Texture self) -> bool

        Return true for GL_RED and GL_ALPHA formats.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_IsAlpha(self, *args)


    def SetAlpha(self, *args):
        """
        SetAlpha(Handle_OpenGl_Texture self, bool const theValue)

        Setup to interprete the format as Alpha by Shader Manager
        (should be GL_ALPHA within compatible context or GL_RED otherwise).

        :type theValue: const bool

        """
        return _OpenGl.Handle_OpenGl_Texture_SetAlpha(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx) -> bool

        Creates Texture id if not yet generated.
        Data should be initialized by another method.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_Texture self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Texture_Release(self, *args)


    def Sampler(self, *args):
        """
        Return texture sampler.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        res = _OpenGl.Handle_OpenGl_Texture_Sampler(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSampler(self, *args):
        """
        SetSampler(Handle_OpenGl_Texture self, Handle_OpenGl_Sampler theSampler)

        Set texture sampler.

        :type theSampler: OCC.wrapper.OpenGl.Handle_OpenGl_Sampler

        """
        return _OpenGl.Handle_OpenGl_Texture_SetSampler(self, *args)


    def InitSamplerObject(self, *args):
        """
        InitSamplerObject(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx) -> bool

        Initialize the Sampler Object (as OpenGL object).
        @param theCtx currently bound OpenGL context

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_InitSamplerObject(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx)
        Bind(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Bind this Texture to specified unit.
        Also binds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_Texture_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx)
        Unbind(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theTextureUnit)

        Unbind texture from specified unit.
        Also unbinds Sampler Object if it is allocated.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_Texture_Unbind(self, *args)


    def Revision(self, *args):
        """
        Revision(Handle_OpenGl_Texture self) -> Standard_Size

        Revision of associated data source.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Texture_Revision(self, *args)


    def SetRevision(self, *args):
        """
        SetRevision(Handle_OpenGl_Texture self, Standard_Size const theRevision)

        Set revision of associated data source.

        :type theRevision: int

        """
        return _OpenGl.Handle_OpenGl_Texture_SetRevision(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, Image_PixMap theImage, Graphic3d_TypeOfTexture const theType) -> bool
        Init(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, GLsizei const theSizeX, GLsizei const theSizeY, Graphic3d_TypeOfTexture const theType, Image_PixMap theImage=None) -> bool

        Initialize the texture with specified format, size and texture type.
        If theImage is empty the texture data will contain trash.
        Notice that texture will be unbound after this call.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfTexture
        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_Init(self, *args)


    def Init2DMultisample(self, *args):
        """
        Init2DMultisample(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLsizei const theNbSamples, GLint const theTextFormat, GLsizei const theSizeX, GLsizei const theSizeY) -> bool

        Initialize the 2D multisampling texture using glTexImage2DMultisample().

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theNbSamples: GLsizei
        :type theTextFormat: GLint
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_Init2DMultisample(self, *args)


    def InitRectangle(self, *args):
        """
        InitRectangle(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, Standard_Integer const theSizeX, Standard_Integer const theSizeY, OpenGl_TextureFormat theFormat) -> bool

        Allocates texture rectangle with specified format and size.

        ote Texture data is not initialized (will contain trash).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: int
        :type theSizeY: int
        :type theFormat: OCC.wrapper.OpenGl.OpenGl_TextureFormat
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_InitRectangle(self, *args)


    def Init3D(self, *args):
        """
        Init3D(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, GLint const theTextFormat, GLenum const thePixelFormat, GLenum const theDataType, Standard_Integer const theSizeX, Standard_Integer const theSizeY, Standard_Integer const theSizeZ, void const * thePixels) -> bool

        Initializes 3D texture rectangle with specified format and size.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeZ: int
        :type thePixels: const void *
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_Init3D(self, *args)


    def HasMipmaps(self, *args):
        """
        HasMipmaps(Handle_OpenGl_Texture self) -> Standard_Boolean

        @return true if texture was generated within mipmaps

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Texture_HasMipmaps(self, *args)


    def GetDataFormat(self, *args):
        """
        GetDataFormat(Handle_OpenGl_Texture self, Handle_OpenGl_Context theCtx, Image_PixMap theData, GLint & theTextFormat, GLenum & thePixelFormat, GLenum & theDataType) -> bool

        Return texture type and format by Image_PixMap data format.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theData: OCC.wrapper.Image.Image_PixMap
        :type theTextFormat: GLint
        :type thePixelFormat: GLenum
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Texture_GetDataFormat(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_Texture self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Texture_EstimatedDataSize(self, *args)


    def ResourceId(self, *args):
        """
        Return resource name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.Handle_OpenGl_Texture_ResourceId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Texture self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Texture_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Texture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Texture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Texture_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Texture self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Texture self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Texture_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Texture self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Texture_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Texture self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Texture_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Texture self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Texture_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Texture self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Texture_DecrementRefCounter(self, *args)

Handle_OpenGl_Texture_swigregister = _OpenGl.Handle_OpenGl_Texture_swigregister
Handle_OpenGl_Texture_swigregister(Handle_OpenGl_Texture)

def Handle_OpenGl_Texture_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Texture_DownCast(thing)
Handle_OpenGl_Texture_DownCast = _OpenGl.Handle_OpenGl_Texture_DownCast

class OpenGl_TmplCore44_OpenGl_GlCore43(object):
    """OpenGL 4.4 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.4 definition."""
        this = _OpenGl.new_OpenGl_TmplCore44_OpenGl_GlCore43()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore44_OpenGl_GlCore43
OpenGl_TmplCore44_OpenGl_GlCore43_swigregister = _OpenGl.OpenGl_TmplCore44_OpenGl_GlCore43_swigregister
OpenGl_TmplCore44_OpenGl_GlCore43_swigregister(OpenGl_TmplCore44_OpenGl_GlCore43)


try:
	OpenGl_GlCore44 = OpenGl_TmplCore44_OpenGl_GlCore43
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_OpenGl_Resource(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_OpenGl_Resource self) -> NCollection_List< opencascade::handle< OpenGl_Resource > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_OpenGl_Resource self) -> NCollection_List< opencascade::handle< OpenGl_Resource > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_OpenGl_Resource self) -> NCollection_List< opencascade::handle< OpenGl_Resource > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_OpenGl_Resource self) -> NCollection_List< opencascade::handle< OpenGl_Resource > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _OpenGl.new_NCollection_List_Handle_OpenGl_Resource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_OpenGl_Resource self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther) -> NCollection_List_Handle_OpenGl_Resource

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther) -> NCollection_List_Handle_OpenGl_Resource

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_OpenGl_Resource self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_List_Handle_OpenGl_Resource_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_List_Handle_OpenGl_Resource_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_OpenGl_Resource self, Handle_OpenGl_Resource theItem) -> Handle_OpenGl_Resource
        Append(NCollection_List_Handle_OpenGl_Resource self, Handle_OpenGl_Resource theItem, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter)
        Append(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_OpenGl_Resource self, Handle_OpenGl_Resource theItem) -> Handle_OpenGl_Resource
        Prepend(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_OpenGl_Resource self)

        RemoveFirst item


        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_OpenGl_Resource self, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_OpenGl_Resource self, Handle_OpenGl_Resource theItem, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter) -> Handle_OpenGl_Resource
        InsertBefore(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_OpenGl_Resource self, Handle_OpenGl_Resource theItem, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter) -> Handle_OpenGl_Resource
        InsertAfter(NCollection_List_Handle_OpenGl_Resource self, NCollection_List_Handle_OpenGl_Resource theOther, NCollection_List< opencascade::handle< OpenGl_Resource > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_OpenGl_Resource self)

        Reverse the list


        """
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_Reverse(self, *args)


    def __iter__(self):
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource___iter__(self)
    __swig_destroy__ = _OpenGl.delete_NCollection_List_Handle_OpenGl_Resource
NCollection_List_Handle_OpenGl_Resource_swigregister = _OpenGl.NCollection_List_Handle_OpenGl_Resource_swigregister
NCollection_List_Handle_OpenGl_Resource_swigregister(NCollection_List_Handle_OpenGl_Resource)

class NCollection_List_Handle_OpenGl_Resource_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _OpenGl.new_NCollection_List_Handle_OpenGl_Resource_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_List_Handle_OpenGl_Resource_IteratorHelper

    def __next__(self):
        return _OpenGl.NCollection_List_Handle_OpenGl_Resource_IteratorHelper___next__(self)
NCollection_List_Handle_OpenGl_Resource_IteratorHelper_swigregister = _OpenGl.NCollection_List_Handle_OpenGl_Resource_IteratorHelper_swigregister
NCollection_List_Handle_OpenGl_Resource_IteratorHelper_swigregister(NCollection_List_Handle_OpenGl_Resource_IteratorHelper)

class OpenGl_SetOfShaderPrograms(Standard.Standard_Transient):
    """Alias to programs array of predefined length"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_SetOfShaderPrograms
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_SetOfShaderPrograms(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_SetOfShaderPrograms_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_SetOfShaderPrograms_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_SetOfShaderPrograms_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_SetOfShaderPrograms self) -> OpenGl_SetOfShaderPrograms

        Empty constructor


        """
        this = _OpenGl.new_OpenGl_SetOfShaderPrograms(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ChangeValue(self, *args):
        """
        ChangeValue(OpenGl_SetOfShaderPrograms self, Graphic3d_TypeOfShadingModel theShadingModel, Standard_Integer theProgramBits) -> Handle_OpenGl_ShaderProgram

        Access program by index

        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theProgramBits: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.OpenGl_SetOfShaderPrograms_ChangeValue(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_SetOfShaderPrograms
OpenGl_SetOfShaderPrograms_swigregister = _OpenGl.OpenGl_SetOfShaderPrograms_swigregister
OpenGl_SetOfShaderPrograms_swigregister(OpenGl_SetOfShaderPrograms)

def OpenGl_SetOfShaderPrograms_get_type_name(*args):
    """
    OpenGl_SetOfShaderPrograms_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_SetOfShaderPrograms_get_type_name(*args)

def OpenGl_SetOfShaderPrograms_get_type_descriptor(*args):
    """
    OpenGl_SetOfShaderPrograms_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_SetOfShaderPrograms_get_type_descriptor(*args)

class OpenGl_BackgroundArray(OpenGl_PrimitiveArray):
    """
    Tool class for generating reusable data for
    gradient or texture background rendering.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_BackgroundArray self, Graphic3d_TypeOfBackground const theType) -> OpenGl_BackgroundArray

        Main constructor.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfBackground

        """
        this = _OpenGl.new_OpenGl_BackgroundArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Render(self, *args):
        """
        Render(OpenGl_BackgroundArray self, Handle_OpenGl_Workspace theWorkspace)

        Render primitives to the window

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_BackgroundArray_Render(self, *args)


    def IsDefined(self, *args):
        """
        IsDefined(OpenGl_BackgroundArray self) -> bool

        Check if background parameters are set properly

        :rtype: bool

        """
        return _OpenGl.OpenGl_BackgroundArray_IsDefined(self, *args)


    def SetTextureParameters(self, *args):
        """
        SetTextureParameters(OpenGl_BackgroundArray self, Aspect_FillMethod const theFillMethod)

        Sets background texture parameters

        :type theFillMethod: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_SetTextureParameters(self, *args)


    def SetTextureFillMethod(self, *args):
        """
        SetTextureFillMethod(OpenGl_BackgroundArray self, Aspect_FillMethod const theFillMethod)

        Sets texture fill method

        :type theFillMethod: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_SetTextureFillMethod(self, *args)


    def TextureFillMethod(self, *args):
        """
        TextureFillMethod(OpenGl_BackgroundArray self) -> Aspect_FillMethod

        Gets background texture fill method

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_TextureFillMethod(self, *args)


    def GradientFillMethod(self, *args):
        """
        GradientFillMethod(OpenGl_BackgroundArray self) -> Aspect_GradientFillMethod

        Gets background gradient fill method

        :rtype: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_GradientFillMethod(self, *args)


    def GradientColor(self, *args):
        """
        Returns color of gradient background for the given index.

        :type theIndex: int
        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.OpenGl_BackgroundArray_GradientColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGradientFillMethod(self, *args):
        """
        SetGradientFillMethod(OpenGl_BackgroundArray self, Aspect_GradientFillMethod const theType)

        Sets type of gradient fill method

        :type theType: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_SetGradientFillMethod(self, *args)


    def SetGradientParameters(self, *args):
        """
        SetGradientParameters(OpenGl_BackgroundArray self, Quantity_Color theColor1, Quantity_Color theColor2, Aspect_GradientFillMethod const theType)

        Sets background gradient parameters

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :type theType: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _OpenGl.OpenGl_BackgroundArray_SetGradientParameters(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_BackgroundArray
OpenGl_BackgroundArray_swigregister = _OpenGl.OpenGl_BackgroundArray_swigregister
OpenGl_BackgroundArray_swigregister(OpenGl_BackgroundArray)

class OpenGl_BVHClipPrimitiveTrsfPersSet(object):
    """
    Set of transformation persistent OpenGl_Structure for building BVH tree.
    Provides built-in mechanism to invalidate tree when world view projection state changes.
    Due to frequent invalidation of BVH tree the choice of BVH tree builder is made
    in favor of BVH linear builder (quick rebuild).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Structures(self, *args):
        """
        Access directly a collection of structures.

        :rtype: OCC.wrapper.OpenGl.NCollection_IndexedMap_OpenGl_Structure

        """
        res = _OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet_Structures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MarkDirty(self, *args):
        """
        MarkDirty(OpenGl_BVHClipPrimitiveTrsfPersSet self)

        Marks object state as outdated (needs BVH rebuilding).


        """
        return _OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet_MarkDirty(self, *args)


    def Builder(self, *args):
        """
        Returns builder for bottom-level BVH.

        :rtype: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        res = _OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBuilder(self, *args):
        """
        SetBuilder(OpenGl_BVHClipPrimitiveTrsfPersSet self, Handle_Select3D_BVHBuilder3d theBuilder)

        Assigns builder for bottom-level BVH.

        :type theBuilder: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        return _OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet_SetBuilder(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_BVHClipPrimitiveTrsfPersSet
OpenGl_BVHClipPrimitiveTrsfPersSet_swigregister = _OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet_swigregister
OpenGl_BVHClipPrimitiveTrsfPersSet_swigregister(OpenGl_BVHClipPrimitiveTrsfPersSet)

class OpenGl_RaytraceMaterial(object):
    """Stores properties of surface material."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Packed(self, *args):
        """
        Packed(OpenGl_RaytraceMaterial self) -> Standard_ShortReal const *

        Returns packed (serialized) representation of material.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_RaytraceMaterial_Packed(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_RaytraceMaterial
OpenGl_RaytraceMaterial_swigregister = _OpenGl.OpenGl_RaytraceMaterial_swigregister
OpenGl_RaytraceMaterial_swigregister(OpenGl_RaytraceMaterial)

class Handle_OpenGl_Resource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Resource self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Resource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Resource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Resource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Resource self, OpenGl_Resource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Resource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Resource self, Handle_OpenGl_Resource theHandle) -> Handle_OpenGl_Resource
        assign(Handle_OpenGl_Resource self, OpenGl_Resource thePtr) -> Handle_OpenGl_Resource
        assign(Handle_OpenGl_Resource self, Handle_OpenGl_Resource theHandle) -> Handle_OpenGl_Resource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Resource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Resource self) -> OpenGl_Resource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Resource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Resource self) -> OpenGl_Resource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Resource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Resource self) -> OpenGl_Resource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Resource___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Resource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Resource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Resource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Resource_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Resource

    def Release(self, *args):
        """
        Release(Handle_OpenGl_Resource self, OpenGl_Context theGlCtx)

        Release GPU resources.
        Notice that implementation should be SAFE for several consecutive calls
        (thus should invalidate internal structures / ids to avoid multiple-free errors).
        @param theGlCtx - bound GL context, shouldn't be NULL.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Resource_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_Resource self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Resource_EstimatedDataSize(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Resource self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Resource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Resource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Resource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Resource self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Resource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Resource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Resource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Resource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Resource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Resource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Resource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Resource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Resource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Resource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Resource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Resource self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Resource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Resource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Resource_DecrementRefCounter(self, *args)

Handle_OpenGl_Resource_swigregister = _OpenGl.Handle_OpenGl_Resource_swigregister
Handle_OpenGl_Resource_swigregister(Handle_OpenGl_Resource)

def Handle_OpenGl_Resource_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Resource_DownCast(thing)
Handle_OpenGl_Resource_DownCast = _OpenGl.Handle_OpenGl_Resource_DownCast

class Handle_OpenGl_FrameStats(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_FrameStats self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_FrameStats_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_FrameStats self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_FrameStats_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_FrameStats self, OpenGl_FrameStats thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_FrameStats_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_FrameStats self, Handle_OpenGl_FrameStats theHandle) -> Handle_OpenGl_FrameStats
        assign(Handle_OpenGl_FrameStats self, OpenGl_FrameStats thePtr) -> Handle_OpenGl_FrameStats
        assign(Handle_OpenGl_FrameStats self, Handle_OpenGl_FrameStats theHandle) -> Handle_OpenGl_FrameStats

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_FrameStats_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_FrameStats self) -> OpenGl_FrameStats

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_FrameStats_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_FrameStats self) -> OpenGl_FrameStats

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_FrameStats___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_FrameStats self) -> OpenGl_FrameStats

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_FrameStats___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_FrameStats___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_FrameStats___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_FrameStats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_FrameStats_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_FrameStats

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_FrameStats self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_FrameStats_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_FrameStats_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_FrameStats_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateInterval(self, *args):
        """
        UpdateInterval(Handle_OpenGl_FrameStats self) -> Standard_Real

        Returns interval in seconds for updating meters across several frames; 1 second by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.Handle_OpenGl_FrameStats_UpdateInterval(self, *args)


    def SetUpdateInterval(self, *args):
        """
        SetUpdateInterval(Handle_OpenGl_FrameStats self, Standard_Real theInterval)

        Sets interval in seconds for updating values.

        :type theInterval: float

        """
        return _OpenGl.Handle_OpenGl_FrameStats_SetUpdateInterval(self, *args)


    def IsLongLineFormat(self, *args):
        """
        IsLongLineFormat(Handle_OpenGl_FrameStats self) -> Standard_Boolean

        Prefer longer lines over more greater of lines.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_IsLongLineFormat(self, *args)


    def SetLongLineFormat(self, *args):
        """
        SetLongLineFormat(Handle_OpenGl_FrameStats self, Standard_Boolean theValue)

        Set if format should prefer longer lines over greater number of lines.

        :type theValue: bool

        """
        return _OpenGl.Handle_OpenGl_FrameStats_SetLongLineFormat(self, *args)


    def FrameStart(self, *args):
        """
        FrameStart(Handle_OpenGl_FrameStats self, Handle_OpenGl_Workspace theWorkspace)

        Frame redraw started.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FrameStart(self, *args)


    def FrameEnd(self, *args):
        """
        FrameEnd(Handle_OpenGl_FrameStats self, Handle_OpenGl_Workspace theWorkspace)

        Frame redraw finished.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FrameEnd(self, *args)


    def FormatStats(self, *args):
        """
        FormatStats(Handle_OpenGl_FrameStats self, Graphic3d_RenderingParams::PerfCounters theFlags) -> TCollection_AsciiString

        Returns formatted string.

        :type theFlags: PerfCounters
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FormatStats(self, *args)


    def FrameDuration(self, *args):
        """
        FrameDuration(Handle_OpenGl_FrameStats self) -> Standard_Real

        Returns duration of the last frame in seconds.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FrameDuration(self, *args)


    def FrameRate(self, *args):
        """
        FrameRate(Handle_OpenGl_FrameStats self) -> Standard_Real

        Returns FPS (frames per seconds, elapsed time).
        This number indicates an actual frame rate averaged for several frames within UpdateInterval() duration,
        basing on a real elapsed time between updates.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FrameRate(self, *args)


    def FrameRateCpu(self, *args):
        """
        FrameRateCpu(Handle_OpenGl_FrameStats self) -> Standard_Real

        Returns CPU FPS (frames per seconds, CPU time).
        This number indicates a PREDICTED frame rate,
        basing on CPU elapsed time between updates and NOT real elapsed time (which might include periods of CPU inactivity).
        Number is expected to be greater then actual frame rate returned by FrameRate().
        Values significantly greater actual frame rate indicate that rendering is limited by GPU performance (CPU is stalled in-between),
        while values around actual frame rate indicate rendering being limited by CPU performance (GPU is stalled in-between).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.Handle_OpenGl_FrameStats_FrameRateCpu(self, *args)


    def CounterValue(self, *args):
        """
        CounterValue(Handle_OpenGl_FrameStats self, OpenGl_FrameStats::Counter theCounter) -> Standard_Size

        Returns value of specified counter, cached between stats updates.
        Should NOT be called between ::FrameStart() and ::FrameEnd() calls.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_FrameStats_CounterValue(self, *args)


    def HasCulledLayers(self, *args):
        """
        HasCulledLayers(Handle_OpenGl_FrameStats self) -> Standard_Boolean

        Returns TRUE if some Layers have been culled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_HasCulledLayers(self, *args)


    def HasCulledStructs(self, *args):
        """
        HasCulledStructs(Handle_OpenGl_FrameStats self) -> Standard_Boolean

        Returns TRUE if some structures have been culled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_HasCulledStructs(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_OpenGl_FrameStats self, Handle_OpenGl_FrameStats theOther) -> Standard_Boolean

        Returns TRUE if this stats are equal to another.

        :type theOther: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_IsEqual(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(Handle_OpenGl_FrameStats self, Handle_OpenGl_FrameStats theOther)

        Copy stats values from another instance

        :type theOther: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats

        """
        return _OpenGl.Handle_OpenGl_FrameStats_CopyFrom(self, *args)


    def ChangeCounter(self, *args):
        """
        ChangeCounter(Handle_OpenGl_FrameStats self, OpenGl_FrameStats::Counter theCounter) -> Standard_Size &

        Returns value of specified counter for modification, should be called between ::FrameStart() and ::FrameEnd() calls.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_FrameStats_ChangeCounter(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_FrameStats self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_FrameStats_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_FrameStats self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_FrameStats self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_FrameStats self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_FrameStats self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameStats_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_FrameStats self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_FrameStats_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_FrameStats self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_FrameStats_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_FrameStats self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_FrameStats_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_FrameStats self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_FrameStats_DecrementRefCounter(self, *args)

Handle_OpenGl_FrameStats_swigregister = _OpenGl.Handle_OpenGl_FrameStats_swigregister
Handle_OpenGl_FrameStats_swigregister(Handle_OpenGl_FrameStats)

def Handle_OpenGl_FrameStats_DownCast(thing):
    return _OpenGl.Handle_OpenGl_FrameStats_DownCast(thing)
Handle_OpenGl_FrameStats_DownCast = _OpenGl.Handle_OpenGl_FrameStats_DownCast

class Handle_OpenGl_RenderFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_RenderFilter self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_RenderFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_RenderFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_RenderFilter self, OpenGl_RenderFilter * thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_RenderFilter self, Handle_OpenGl_RenderFilter theHandle) -> Handle_OpenGl_RenderFilter
        assign(Handle_OpenGl_RenderFilter self, OpenGl_RenderFilter const * thePtr) -> Handle_OpenGl_RenderFilter
        assign(Handle_OpenGl_RenderFilter self, Handle_OpenGl_RenderFilter theHandle) -> Handle_OpenGl_RenderFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_RenderFilter self) -> OpenGl_RenderFilter *

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_RenderFilter self) -> OpenGl_RenderFilter *

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_RenderFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_RenderFilter self) -> OpenGl_RenderFilter &

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_RenderFilter___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_RenderFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_RenderFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_RenderFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_RenderFilter_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_RenderFilter

    def ShouldRender(self, *args):
        """
        ShouldRender(Handle_OpenGl_RenderFilter self, Handle_OpenGl_Workspace theWorkspace, OpenGl_Element const * theElement) -> Standard_Boolean

        Checks whether the element can be rendered or not.
        @param theWorkspace [in] the current workspace.
        @param theElement [in] the element to check.
        @return True if element can be rendered.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace
        :type theElement: OCC.wrapper.OpenGl.OpenGl_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_ShouldRender(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_RenderFilter self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_RenderFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_RenderFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_RenderFilter self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_RenderFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_RenderFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_RenderFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_RenderFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_RenderFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_RenderFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_RenderFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_RenderFilter self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_RenderFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_RenderFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_RenderFilter_DecrementRefCounter(self, *args)

Handle_OpenGl_RenderFilter_swigregister = _OpenGl.Handle_OpenGl_RenderFilter_swigregister
Handle_OpenGl_RenderFilter_swigregister(Handle_OpenGl_RenderFilter)

def Handle_OpenGl_RenderFilter_DownCast(thing):
    return _OpenGl.Handle_OpenGl_RenderFilter_DownCast(thing)
Handle_OpenGl_RenderFilter_DownCast = _OpenGl.Handle_OpenGl_RenderFilter_DownCast

class OpenGl_CappingAlgo(object):
    """Capping surface rendering algorithm."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def RenderCapping(*args):
        """
        RenderCapping(Handle_OpenGl_Workspace theWorkspace, OpenGl_Structure theStructure)

        Draw capping surfaces by OpenGl for the clipping planes enabled in current context state.
        Depth buffer must be generated  for the passed groups.
        @param theWorkspace [in] the GL workspace, context state
        @param theStructure [in] the structure to be capped

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace
        :type theStructure: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.OpenGl_CappingAlgo_RenderCapping(*args)

    RenderCapping = staticmethod(RenderCapping)

    def __init__(self):
        """Capping surface rendering algorithm."""
        this = _OpenGl.new_OpenGl_CappingAlgo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_CappingAlgo
OpenGl_CappingAlgo_swigregister = _OpenGl.OpenGl_CappingAlgo_swigregister
OpenGl_CappingAlgo_swigregister(OpenGl_CappingAlgo)

def OpenGl_CappingAlgo_RenderCapping(*args):
    """
    OpenGl_CappingAlgo_RenderCapping(Handle_OpenGl_Workspace theWorkspace, OpenGl_Structure theStructure)

    Draw capping surfaces by OpenGl for the clipping planes enabled in current context state.
    Depth buffer must be generated  for the passed groups.
    @param theWorkspace [in] the GL workspace, context state
    @param theStructure [in] the structure to be capped

    :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace
    :type theStructure: OCC.wrapper.OpenGl.OpenGl_Structure

    """
    return _OpenGl.OpenGl_CappingAlgo_RenderCapping(*args)

class OpenGl_Sampler(OpenGl_Resource):
    """
    Class implements OpenGL sampler object resource that
    stores the sampling parameters for a texture access.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OpenGl_Sampler
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OpenGl_Sampler(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OpenGl.OpenGl_Sampler_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OpenGl.OpenGl_Sampler_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.OpenGl_Sampler_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(OpenGl_Sampler self, Handle_Graphic3d_TextureParams theParams) -> OpenGl_Sampler

        Creates new sampler object.

        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        this = _OpenGl.new_OpenGl_Sampler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Release(self, *args):
        """
        Release(OpenGl_Sampler self, OpenGl_Context theContext)

        Destroys object - will release GPU memory if any.

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Sampler_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(OpenGl_Sampler self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_Sampler_EstimatedDataSize(self, *args)


    def Create(self, *args):
        """
        Create(OpenGl_Sampler self, Handle_OpenGl_Context theContext) -> Standard_Boolean

        Creates an uninitialized sampler object.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Sampler_Create(self, *args)


    def Init(self, *args):
        """
        Init(OpenGl_Sampler self, Handle_OpenGl_Context theContext, OpenGl_Texture theTexture) -> Standard_Boolean

        Creates and initializes sampler object.
        Existing object will be reused if possible, however if existing Sampler Object has Immutable flag
        and texture parameters should be re-initialized, then Sampler Object will be recreated.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTexture: OCC.wrapper.OpenGl.OpenGl_Texture
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Sampler_Init(self, *args)


    def IsValid(self, *args):
        """
        IsValid(OpenGl_Sampler self) -> Standard_Boolean

        Returns true if current object was initialized.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Sampler_IsValid(self, *args)


    def Bind(self, *args):
        """
        Bind(OpenGl_Sampler self, Handle_OpenGl_Context theCtx)
        Bind(OpenGl_Sampler self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theUnit)

        Binds sampler object to the given texture unit.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_Sampler_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(OpenGl_Sampler self, Handle_OpenGl_Context theCtx)
        Unbind(OpenGl_Sampler self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theUnit)

        Unbinds sampler object from the given texture unit.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.OpenGl_Sampler_Unbind(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(OpenGl_Sampler self, Handle_OpenGl_Context theCtx, GLenum theTarget, GLenum theParam, GLint theValue)

        Sets specific sampler parameter.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTarget: GLenum
        :type theParam: GLenum
        :type theValue: GLint

        """
        return _OpenGl.OpenGl_Sampler_SetParameter(self, *args)


    def SamplerID(self, *args):
        """
        SamplerID(OpenGl_Sampler self) -> GLuint

        Returns OpenGL sampler ID.

        :rtype: GLuint

        """
        return _OpenGl.OpenGl_Sampler_SamplerID(self, *args)


    def IsImmutable(self, *args):
        """
        IsImmutable(OpenGl_Sampler self) -> bool

        Return immutable flag preventing further modifications of sampler parameters, FALSE by default.
        Immutable flag might be set when Sampler Object is used within Bindless Texture.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Sampler_IsImmutable(self, *args)


    def SetImmutable(self, *args):
        """
        SetImmutable(OpenGl_Sampler self)

        Setup immutable flag. It is not possible unsetting this flag without Sampler destruction.


        """
        return _OpenGl.OpenGl_Sampler_SetImmutable(self, *args)


    def Parameters(self, *args):
        """
        Returns texture parameters.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        res = _OpenGl.OpenGl_Sampler_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetParameters(self, *args):
        """
        SetParameters(OpenGl_Sampler self, Handle_Graphic3d_TextureParams theParams)

        Sets texture parameters.

        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        return _OpenGl.OpenGl_Sampler_SetParameters(self, *args)


    def ToUpdateParameters(self, *args):
        """
        ToUpdateParameters(OpenGl_Sampler self) -> bool

        Returns texture parameters initialization state.

        :rtype: bool

        """
        return _OpenGl.OpenGl_Sampler_ToUpdateParameters(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_Sampler
OpenGl_Sampler_swigregister = _OpenGl.OpenGl_Sampler_swigregister
OpenGl_Sampler_swigregister(OpenGl_Sampler)

def OpenGl_Sampler_get_type_name(*args):
    """
    OpenGl_Sampler_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OpenGl.OpenGl_Sampler_get_type_name(*args)

def OpenGl_Sampler_get_type_descriptor(*args):
    """
    OpenGl_Sampler_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OpenGl.OpenGl_Sampler_get_type_descriptor(*args)

class OpenGl_LightSourceState(OpenGl_StateInterface):
    """Defines state of OCCT light sources."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_LightSourceState self, Handle_Graphic3d_LightSet theLightSources)

        Sets new light sources.

        :type theLightSources: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        return _OpenGl.OpenGl_LightSourceState_Set(self, *args)


    def LightSources(self, *args):
        """
        Returns current list of light sources.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        res = _OpenGl.OpenGl_LightSourceState_LightSources(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_LightSourceState
OpenGl_LightSourceState_swigregister = _OpenGl.OpenGl_LightSourceState_swigregister
OpenGl_LightSourceState_swigregister(OpenGl_LightSourceState)

class Handle_OpenGl_IndexBuffer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_IndexBuffer self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_IndexBuffer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_IndexBuffer self, OpenGl_IndexBuffer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_IndexBuffer theHandle) -> Handle_OpenGl_IndexBuffer
        assign(Handle_OpenGl_IndexBuffer self, OpenGl_IndexBuffer thePtr) -> Handle_OpenGl_IndexBuffer
        assign(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_IndexBuffer theHandle) -> Handle_OpenGl_IndexBuffer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_IndexBuffer self) -> OpenGl_IndexBuffer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_IndexBuffer self) -> OpenGl_IndexBuffer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_IndexBuffer self) -> OpenGl_IndexBuffer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_IndexBuffer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_IndexBuffer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_IndexBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_IndexBuffer_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_IndexBuffer

    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_IndexBuffer self) -> GLenum

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetTarget(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_IndexBuffer self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_IndexBuffer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_IndexBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_IndexBuffer self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_IsValid(self, *args)


    def GetComponentsNb(self, *args):
        """
        GetComponentsNb(Handle_OpenGl_IndexBuffer self) -> GLuint

        @return the number of components per generic vertex attribute.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetComponentsNb(self, *args)


    def GetElemsNb(self, *args):
        """
        GetElemsNb(Handle_OpenGl_IndexBuffer self) -> GLsizei

        @return number of vertex attributes / number of vertices.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetElemsNb(self, *args)


    def GetDataType(self, *args):
        """
        GetDataType(Handle_OpenGl_IndexBuffer self) -> GLenum

        @return data type of each component in the array.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetDataType(self, *args)


    def GetDataOffset(self, *args):
        """
        GetDataOffset(Handle_OpenGl_IndexBuffer self) -> GLubyte *

        @return offset to data, NULL by default

        :rtype: GLubyte

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetDataOffset(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO name (id) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_IndexBuffer self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Release(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Unbind(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        @param theComponentsNb - specifies the number of components per generic vertex attribute; must be 1, 2, 3, or 4;
        @param theElemsNb      - elements count;
        @param theData         - pointer to GLubyte data (indices/colors etc.).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Init(self, *args)


    def SubData(self, *args):
        """
        SubData(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        SubData(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLuint const * theData) -> bool
        SubData(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLushort const * theData) -> bool
        SubData(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        Function replaces portion of data within this VBO using glBufferSubData().
        The VBO should be initialized before call.
        @param theElemFrom element id from which replace buffer data (>=0);
        @param theElemsNb  elements count (theElemFrom + theElemsNb <= GetElemsNb());
        @param theData     pointer to GLubyte data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_SubData(self, *args)


    def BindVertexAttrib(self, *args):
        """
        BindVertexAttrib(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Bind this VBO to active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_BindVertexAttrib(self, *args)


    def UnbindVertexAttrib(self, *args):
        """
        UnbindVertexAttrib(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Unbind any VBO from active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_UnbindVertexAttrib(self, *args)


    def BindAttribute(self, *args):
        """
        BindAttribute(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Bind this VBO and enable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theGlCtx - handle to bound GL context;
        @param theMode  - array mode (GL_VERTEX_ARRAY, GL_NORMAL_ARRAY, GL_COLOR_ARRAY, GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_BindAttribute(self, *args)


    def UnbindAttribute(self, *args):
        """
        UnbindAttribute(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Unbind this VBO and disable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theCtx handle to bound GL context
        @param theMode  array mode

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_UnbindAttribute(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_IndexBuffer self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_EstimatedDataSize(self, *args)


    def sizeOfGlType(self, *args):
        """
        sizeOfGlType(Handle_OpenGl_IndexBuffer self, GLenum const theType) -> size_t

        @return size of specified GL type

        :type theType: GLenum
        :rtype: size_t

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_sizeOfGlType(self, *args)


    def init(self, *args):
        """
        init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool
        init(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Initialize buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_init(self, *args)


    def subData(self, *args):
        """
        subData(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_subData(self, *args)


    def bindAttribute(self, *args):
        """
        bindAttribute(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

        Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using bindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
        :type theNbComp: GLint
        :type theDataType: GLenum
        :type theStride: GLsizei
        :type theOffset: GLvoid

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_bindAttribute(self, *args)


    def unbindAttribute(self, *args):
        """
        unbindAttribute(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

        Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using unbindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_unbindAttribute(self, *args)


    def HasColorAttribute(self, *args):
        """
        HasColorAttribute(Handle_OpenGl_IndexBuffer self) -> bool

        @return true if buffer contains per-vertex color attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_HasColorAttribute(self, *args)


    def HasNormalAttribute(self, *args):
        """
        HasNormalAttribute(Handle_OpenGl_IndexBuffer self) -> bool

        @return true if buffer contains per-vertex normal attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_HasNormalAttribute(self, *args)


    def BindAllAttributes(self, *args):
        """
        BindAllAttributes(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind all vertex attributes to active program OpenGl_Context::ActiveProgram() or for FFP.
        Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_BindAllAttributes(self, *args)


    def BindPositionAttribute(self, *args):
        """
        BindPositionAttribute(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind vertex position attribute only. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_BindPositionAttribute(self, *args)


    def UnbindAllAttributes(self, *args):
        """
        UnbindAllAttributes(Handle_OpenGl_IndexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind all vertex attributes. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_UnbindAllAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_IndexBuffer self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_IndexBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_IndexBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_IndexBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_IndexBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_IndexBuffer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_IndexBuffer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_IndexBuffer self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_IndexBuffer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_IndexBuffer_DecrementRefCounter(self, *args)

Handle_OpenGl_IndexBuffer_swigregister = _OpenGl.Handle_OpenGl_IndexBuffer_swigregister
Handle_OpenGl_IndexBuffer_swigregister(Handle_OpenGl_IndexBuffer)

def Handle_OpenGl_IndexBuffer_DownCast(thing):
    return _OpenGl.Handle_OpenGl_IndexBuffer_DownCast(thing)
Handle_OpenGl_IndexBuffer_DownCast = _OpenGl.Handle_OpenGl_IndexBuffer_DownCast

class Handle_OpenGl_Font(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Font self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Font_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Font self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Font_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Font self, OpenGl_Font thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Font_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Font self, Handle_OpenGl_Font theHandle) -> Handle_OpenGl_Font
        assign(Handle_OpenGl_Font self, OpenGl_Font thePtr) -> Handle_OpenGl_Font
        assign(Handle_OpenGl_Font self, Handle_OpenGl_Font theHandle) -> Handle_OpenGl_Font

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Font_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Font self) -> OpenGl_Font

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Font_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Font self) -> OpenGl_Font

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Font___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Font self) -> OpenGl_Font

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Font___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Font___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Font___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Font(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Font_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Font

    def Release(self, *args):
        """
        Release(Handle_OpenGl_Font self, OpenGl_Context theCtx)

        Destroy object - will release GPU memory if any

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Font_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_Font self) -> Standard_Size

        Returns estimated GPU memory usage.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Font_EstimatedDataSize(self, *args)


    def ResourceKey(self, *args):
        """
        @return key of shared resource

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.Handle_OpenGl_Font_ResourceKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FTFont(self, *args):
        """
        @return FreeType font instance specified on construction.

        :rtype: OCC.wrapper.Font.Handle_Font_FTFont

        """
        res = _OpenGl.Handle_OpenGl_Font_FTFont(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_Font self) -> bool

        @return true if font was loaded successfully.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Font_IsValid(self, *args)


    def WasInitialized(self, *args):
        """
        WasInitialized(Handle_OpenGl_Font self) -> bool

        Notice that this method doesn't return initialization success state.
        Use IsValid() instead.
        @return true if initialization was already called.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Font_WasInitialized(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_Font self, Handle_OpenGl_Context theCtx) -> bool

        Initialize GL resources.
        FreeType font instance should be already initialized!

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Font_Init(self, *args)


    def Ascender(self, *args):
        """
        Ascender(Handle_OpenGl_Font self) -> float

        @return vertical distance from the horizontal baseline to the highest character coordinate

        :rtype: float

        """
        return _OpenGl.Handle_OpenGl_Font_Ascender(self, *args)


    def Descender(self, *args):
        """
        Descender(Handle_OpenGl_Font self) -> float

        @return vertical distance from the horizontal baseline to the lowest character coordinate

        :rtype: float

        """
        return _OpenGl.Handle_OpenGl_Font_Descender(self, *args)


    def LineSpacing(self, *args):
        """
        LineSpacing(Handle_OpenGl_Font self) -> float

        @return default line spacing (the baseline-to-baseline distance)

        :rtype: float

        """
        return _OpenGl.Handle_OpenGl_Font_LineSpacing(self, *args)


    def RenderGlyph(self, *args):
        """
        RenderGlyph(Handle_OpenGl_Font self, Handle_OpenGl_Context theCtx, Standard_Utf32Char const theUChar, OpenGl_Font::Tile & theGlyph) -> bool

        Render glyph to texture if not already.
        @param theCtx       active context
        @param theUChar     unicode symbol to render
        @param theGlyph     computed glyph position rectangle, texture ID and UV coordinates

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUChar: OCC.wrapper.Standard.Standard_Utf32Char
        :type theGlyph: Tile
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Font_RenderGlyph(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Font self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Font_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Font_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Font_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Font self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Font_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Font self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Font self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Font_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Font self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Font self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Font_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Font self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Font_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Font self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Font_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Font self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Font_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Font self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Font_DecrementRefCounter(self, *args)

Handle_OpenGl_Font_swigregister = _OpenGl.Handle_OpenGl_Font_swigregister
Handle_OpenGl_Font_swigregister(Handle_OpenGl_Font)

def Handle_OpenGl_Font_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Font_DownCast(thing)
Handle_OpenGl_Font_DownCast = _OpenGl.Handle_OpenGl_Font_DownCast

class Handle_OpenGl_ShaderManager(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_ShaderManager self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_ShaderManager self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_ShaderManager self, OpenGl_ShaderManager thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderManager theHandle) -> Handle_OpenGl_ShaderManager
        assign(Handle_OpenGl_ShaderManager self, OpenGl_ShaderManager thePtr) -> Handle_OpenGl_ShaderManager
        assign(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderManager theHandle) -> Handle_OpenGl_ShaderManager

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_ShaderManager self) -> OpenGl_ShaderManager

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_ShaderManager self) -> OpenGl_ShaderManager

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderManager___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_ShaderManager self) -> OpenGl_ShaderManager

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_ShaderManager___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_ShaderManager___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_ShaderManager___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_ShaderManager(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_ShaderManager_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_ShaderManager

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_ShaderManager self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def clear(self, *args):
        """
        clear(Handle_OpenGl_ShaderManager self)

        Release all resources.


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_clear(self, *args)


    def LocalOrigin(self, *args):
        """
        Return local camera transformation.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_LocalOrigin(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalOrigin(self, *args):
        """
        SetLocalOrigin(Handle_OpenGl_ShaderManager self, gp_XYZ theOrigin)

        Setup local camera transformation for compensating float precision issues.

        :type theOrigin: OCC.wrapper.gp.gp_XYZ

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_SetLocalOrigin(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_ShaderManager self, Handle_Graphic3d_ShaderProgram theProxy, TCollection_AsciiString theShareKey, Handle_OpenGl_ShaderProgram theProgram) -> Standard_Boolean

        Creates new shader program or re-use shared instance.
        @param theProxy    [IN]  program definition
        @param theShareKey [OUT] sharing key
        @param theProgram  [OUT] OpenGL program
        @return true on success

        :type theProxy: OCC.wrapper.Graphic3d.Handle_Graphic3d_ShaderProgram
        :type theShareKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_Create(self, *args)


    def Unregister(self, *args):
        """
        Unregister(Handle_OpenGl_ShaderManager self, TCollection_AsciiString theShareKey, Handle_OpenGl_ShaderProgram theProgram)

        Unregisters specified shader program.

        :type theShareKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_Unregister(self, *args)


    def ShaderPrograms(self, *args):
        """
        Returns list of registered shader programs.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ShaderProgramList

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_ShaderPrograms(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_OpenGl_ShaderManager self) -> Standard_Boolean

        Returns true if no program objects are registered in the manager.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsEmpty(self, *args)


    def BindFaceProgram(self, *args):
        """
        BindFaceProgram(Handle_OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Standard_Boolean const theEnableEnvMap, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for filled primitives rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theEnableEnvMap: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindFaceProgram(self, *args)


    def BindLineProgram(self, *args):
        """
        BindLineProgram(Handle_OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Aspect_TypeOfLine const theLineType, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for line rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theLineType: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindLineProgram(self, *args)


    def BindMarkerProgram(self, *args):
        """
        BindMarkerProgram(Handle_OpenGl_ShaderManager self, Handle_OpenGl_TextureSet theTextures, Graphic3d_TypeOfShadingModel const theShadingModel, Graphic3d_AlphaMode const theAlphaMode, Standard_Boolean const theHasVertColor, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for point rendering

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theAlphaMode: OCC.wrapper.Graphic3d.Graphic3d_AlphaMode
        :type theHasVertColor: bool
        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindMarkerProgram(self, *args)


    def BindFontProgram(self, *args):
        """
        BindFontProgram(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theCustomProgram) -> Standard_Boolean

        Bind program for rendering alpha-textured font.

        :type theCustomProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindFontProgram(self, *args)


    def BindFboBlitProgram(self, *args):
        """
        BindFboBlitProgram(Handle_OpenGl_ShaderManager self) -> Standard_Boolean

        Bind program for FBO blit operation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindFboBlitProgram(self, *args)


    def BindOitCompositingProgram(self, *args):
        """
        BindOitCompositingProgram(Handle_OpenGl_ShaderManager self, Standard_Boolean const theIsMSAAEnabled) -> Standard_Boolean

        Bind program for blended order-independent transparency buffers compositing.

        :type theIsMSAAEnabled: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindOitCompositingProgram(self, *args)


    def BindStereoProgram(self, *args):
        """
        BindStereoProgram(Handle_OpenGl_ShaderManager self, Graphic3d_StereoMode const theStereoMode) -> Standard_Boolean

        Bind program for rendering stereoscopic image.

        :type theStereoMode: OCC.wrapper.Graphic3d.Graphic3d_StereoMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_BindStereoProgram(self, *args)


    def LightSourceState(self, *args):
        """
        Returns current state of OCCT light sources.

        :rtype: OCC.wrapper.OpenGl.OpenGl_LightSourceState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_LightSourceState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateLightSourceStateTo(self, *args):
        """
        UpdateLightSourceStateTo(Handle_OpenGl_ShaderManager self, Handle_Graphic3d_LightSet theLights)

        Updates state of OCCT light sources.

        :type theLights: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateLightSourceStateTo(self, *args)


    def UpdateLightSourceState(self, *args):
        """
        UpdateLightSourceState(Handle_OpenGl_ShaderManager self)

        Invalidate state of OCCT light sources.


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateLightSourceState(self, *args)


    def PushLightSourceState(self, *args):
        """
        PushLightSourceState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT light sources to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushLightSourceState(self, *args)


    def ProjectionState(self, *args):
        """
        Returns current state of OCCT projection transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ProjectionState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_ProjectionState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateProjectionStateTo(self, *args):
        """
        UpdateProjectionStateTo(Handle_OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theProjectionMatrix)

        Updates state of OCCT projection transform.

        :type theProjectionMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateProjectionStateTo(self, *args)


    def PushProjectionState(self, *args):
        """
        PushProjectionState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT projection transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushProjectionState(self, *args)


    def ModelWorldState(self, *args):
        """
        Returns current state of OCCT model-world transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ModelWorldState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_ModelWorldState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateModelWorldStateTo(self, *args):
        """
        UpdateModelWorldStateTo(Handle_OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theModelWorldMatrix)

        Updates state of OCCT model-world transform.

        :type theModelWorldMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateModelWorldStateTo(self, *args)


    def PushModelWorldState(self, *args):
        """
        PushModelWorldState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT model-world transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushModelWorldState(self, *args)


    def WorldViewState(self, *args):
        """
        Returns current state of OCCT world-view transform.

        :rtype: OCC.wrapper.OpenGl.OpenGl_WorldViewState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_WorldViewState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateWorldViewStateTo(self, *args):
        """
        UpdateWorldViewStateTo(Handle_OpenGl_ShaderManager self, NCollection_Mat4_Standard_ShortReal theWorldViewMatrix)

        Updates state of OCCT world-view transform.

        :type theWorldViewMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateWorldViewStateTo(self, *args)


    def PushWorldViewState(self, *args):
        """
        PushWorldViewState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT world-view transform to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushWorldViewState(self, *args)


    def UpdateClippingState(self, *args):
        """
        UpdateClippingState(Handle_OpenGl_ShaderManager self)

        Updates state of OCCT clipping planes.


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateClippingState(self, *args)


    def RevertClippingState(self, *args):
        """
        RevertClippingState(Handle_OpenGl_ShaderManager self)

        Reverts state of OCCT clipping planes.


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_RevertClippingState(self, *args)


    def PushClippingState(self, *args):
        """
        PushClippingState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT clipping planes to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushClippingState(self, *args)


    def MaterialState(self, *args):
        """
        Returns current state of material.

        :rtype: OCC.wrapper.OpenGl.OpenGl_MaterialState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_MaterialState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateMaterialStateTo(self, *args):
        """
        UpdateMaterialStateTo(Handle_OpenGl_ShaderManager self, OpenGl_Material const & theFrontMat, OpenGl_Material const & theBackMat, float const theAlphaCutoff, bool const theToDistinguish, bool const theToMapTexture)

        Updates state of material.

        :type theFrontMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theBackMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theAlphaCutoff: const float
        :type theToDistinguish: const bool
        :type theToMapTexture: const bool

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateMaterialStateTo(self, *args)


    def UpdateMaterialState(self, *args):
        """
        UpdateMaterialState(Handle_OpenGl_ShaderManager self)

        Updates state of material.


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_UpdateMaterialState(self, *args)


    def OitState(self, *args):
        """
        Returns state of OIT uniforms.

        :rtype: OCC.wrapper.OpenGl.OpenGl_OitState

        """
        res = _OpenGl.Handle_OpenGl_ShaderManager_OitState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOitState(self, *args):
        """
        SetOitState(Handle_OpenGl_ShaderManager self, bool const theToEnableOitWrite, float const theDepthFactor)

        Set the state of OIT rendering pass.
        @param theToEnableOitWrite [in] flag indicating whether the special output should be written for OIT algorithm.
        @param theDepthFactor [in] the scalar factor of depth influence to the fragment's coverage.

        :type theToEnableOitWrite: const bool
        :type theDepthFactor: const float

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_SetOitState(self, *args)


    def PushOitState(self, *args):
        """
        PushOitState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes state of OIT uniforms to the specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushOitState(self, *args)


    def PushState(self, *args):
        """
        PushState(Handle_OpenGl_ShaderManager self, Handle_OpenGl_ShaderProgram theProgram)

        Pushes current state of OCCT graphics parameters to specified program.

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_PushState(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_OpenGl_ShaderManager self, OpenGl_Context theCtx)

        Overwrites context

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_SetContext(self, *args)


    def IsSameContext(self, *args):
        """
        IsSameContext(Handle_OpenGl_ShaderManager self, OpenGl_Context theCtx) -> bool

        Returns true when provided context is the same as used one by shader manager.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsSameContext(self, *args)


    def ChooseFaceShadingModel(self, *args):
        """
        ChooseFaceShadingModel(Handle_OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for filled primitives.
        Fallbacks to FACET model if there are no normal attributes.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_ChooseFaceShadingModel(self, *args)


    def ChooseLineShadingModel(self, *args):
        """
        ChooseLineShadingModel(Handle_OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for line primitives.
        Fallbacks to UNLIT model if there are no normal attributes.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_ChooseLineShadingModel(self, *args)


    def ChooseMarkerShadingModel(self, *args):
        """
        ChooseMarkerShadingModel(Handle_OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel theCustomModel, bool theHasNodalNormals) -> Graphic3d_TypeOfShadingModel

        Choose Shading Model for Marker primitives.

        :type theCustomModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theHasNodalNormals: bool
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_ChooseMarkerShadingModel(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(Handle_OpenGl_ShaderManager self) -> Graphic3d_TypeOfShadingModel

        Returns default Shading Model.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_ShadingModel(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(Handle_OpenGl_ShaderManager self, Graphic3d_TypeOfShadingModel const theModel)

        Sets shading model.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_SetShadingModel(self, *args)


    def SetLastView(self, *args):
        """
        SetLastView(Handle_OpenGl_ShaderManager self, OpenGl_View theLastView)

        Sets last view manger used with.
        Helps to handle matrix states in multi-view configurations.

        :type theLastView: OCC.wrapper.OpenGl.OpenGl_View

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_SetLastView(self, *args)


    def IsSameView(self, *args):
        """
        IsSameView(Handle_OpenGl_ShaderManager self, OpenGl_View theView) -> bool

        Returns true when provided view is the same as cached one.

        :type theView: OCC.wrapper.OpenGl.OpenGl_View
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsSameView(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_ShaderManager self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_ShaderManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_ShaderManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_ShaderManager self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_ShaderManager self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_ShaderManager self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_ShaderManager self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_ShaderManager self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_ShaderManager_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_ShaderManager self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderManager_DecrementRefCounter(self, *args)

Handle_OpenGl_ShaderManager_swigregister = _OpenGl.Handle_OpenGl_ShaderManager_swigregister
Handle_OpenGl_ShaderManager_swigregister(Handle_OpenGl_ShaderManager)

def Handle_OpenGl_ShaderManager_DownCast(thing):
    return _OpenGl.Handle_OpenGl_ShaderManager_DownCast(thing)
Handle_OpenGl_ShaderManager_DownCast = _OpenGl.Handle_OpenGl_ShaderManager_DownCast

class OpenGl_TextureFormat(object):
    """Stores parameters of OpenGL texture format."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Format(self, *args):
        """
        Format(OpenGl_TextureFormat self) -> GLenum

        Returns OpenGL format of the pixel data.

        :rtype: GLenum

        """
        return _OpenGl.OpenGl_TextureFormat_Format(self, *args)


    def Internal(self, *args):
        """
        Internal(OpenGl_TextureFormat self) -> GLint

        Returns OpenGL internal format of the pixel data.

        :rtype: GLint

        """
        return _OpenGl.OpenGl_TextureFormat_Internal(self, *args)


    def DataType(self, *args):
        """
        DataType(OpenGl_TextureFormat self) -> GLint

        Returns OpenGL data type of the pixel data.

        :rtype: GLint

        """
        return _OpenGl.OpenGl_TextureFormat_DataType(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_TextureFormat
OpenGl_TextureFormat_swigregister = _OpenGl.OpenGl_TextureFormat_swigregister
OpenGl_TextureFormat_swigregister(OpenGl_TextureFormat)

class NCollection_Sequence_Handle_OpenGl_ShaderObject(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_ShaderObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_OpenGl_ShaderObject self)

        Reverse sequence


        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence_Handle_OpenGl_ShaderObject theOther) -> NCollection_Sequence_Handle_OpenGl_ShaderObject

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence_Handle_OpenGl_ShaderObject theOther) -> NCollection_Sequence_Handle_OpenGl_ShaderObject

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Handle_OpenGl_ShaderObject theItem)
        Append(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence_Handle_OpenGl_ShaderObject theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Handle_OpenGl_ShaderObject theItem)
        Prepend(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence_Handle_OpenGl_ShaderObject theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, Handle_OpenGl_ShaderObject theItem)
        InsertBefore(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderObject theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderObject self, NCollection_Sequence< opencascade::handle< OpenGl_ShaderObject > >::Iterator & thePosition, Handle_OpenGl_ShaderObject theItem)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderObject theSeq)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, Handle_OpenGl_ShaderObject theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderObject theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Handle_OpenGl_ShaderObject

        First item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_OpenGl_ShaderObject self) -> Handle_OpenGl_ShaderObject

        Last item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex) -> Handle_OpenGl_ShaderObject

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_OpenGl_ShaderObject self, Standard_Integer const theIndex, Handle_OpenGl_ShaderObject theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_SetValue(self, *args)


    def __iter__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject___iter__(self)
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_ShaderObject
NCollection_Sequence_Handle_OpenGl_ShaderObject_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_swigregister
NCollection_Sequence_Handle_OpenGl_ShaderObject_swigregister(NCollection_Sequence_Handle_OpenGl_ShaderObject)

def NCollection_Sequence_Handle_OpenGl_ShaderObject_delNode(*args):
    """
    NCollection_Sequence_Handle_OpenGl_ShaderObject_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_delNode(*args)

class NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper

    def __next__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper___next__(self)
NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper_swigregister
NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper_swigregister(NCollection_Sequence_Handle_OpenGl_ShaderObject_IteratorHelper)


try:
	OpenGl_ShaderList = NCollection_Sequence_Handle_OpenGl_ShaderObject
except NameError:
	pass # does not exist, probably ignored

class Handle_OpenGl_View(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_View self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_View_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_View self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_View_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_View self, OpenGl_View thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_View_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_View self, Handle_OpenGl_View theHandle) -> Handle_OpenGl_View
        assign(Handle_OpenGl_View self, OpenGl_View thePtr) -> Handle_OpenGl_View
        assign(Handle_OpenGl_View self, Handle_OpenGl_View theHandle) -> Handle_OpenGl_View

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_View_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_View self) -> OpenGl_View

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_View_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_View self) -> OpenGl_View

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_View___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_View self) -> OpenGl_View

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_View___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_View___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_View___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_View(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_View_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_View

    def ReleaseGlResources(self, *args):
        """
        ReleaseGlResources(Handle_OpenGl_View self, Handle_OpenGl_Context theCtx)

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_View_ReleaseGlResources(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_OpenGl_View self)

        Deletes and erases the view.


        """
        return _OpenGl.Handle_OpenGl_View_Remove(self, *args)


    def SetImmediateModeDrawToFront(self, *args):
        """
        SetImmediateModeDrawToFront(Handle_OpenGl_View self, Standard_Boolean const theDrawToFrontBuffer) -> Standard_Boolean

        @param theDrawToFrontBuffer Advanced option to modify rendering mode:
        1. TRUE.  Drawing immediate mode structures directly to the front buffer over the scene image.
        Fast, so preferred for interactive work (used by default).
        However these extra drawings will be missed in image dump since it is performed from back buffer.
        Notice that since no pre-buffering used the V-Sync will be ignored and rendering could be seen
        in run-time (in case of slow hardware) and/or tearing may appear.
        So this is strongly recommended to draw only simple (fast) structures.
        2. FALSE. Drawing immediate mode structures to the back buffer.
        The complete scene is redrawn first, so this mode is slower if scene contains complex data and/or V-Sync
        is turned on. But it works in any case and is especially useful for view dump because the dump image is read
        from the back buffer.
        @return previous mode.

        :type theDrawToFrontBuffer: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_SetImmediateModeDrawToFront(self, *args)


    def SetWindow(self, *args):
        """
        SetWindow(Handle_OpenGl_View self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext)

        Creates and maps rendering window to the view.
        @param theWindow [in] the window.
        @param theContext [in] the rendering context. If NULL the context will be created internally.

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext

        """
        return _OpenGl.Handle_OpenGl_View_SetWindow(self, *args)


    def Window(self, *args):
        """
        Window(Handle_OpenGl_View self) -> Handle_Aspect_Window

        Returns window associated with the view.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _OpenGl.Handle_OpenGl_View_Window(self, *args)


    def IsDefined(self, *args):
        """
        IsDefined(Handle_OpenGl_View self) -> Standard_Boolean

        Returns True if the window associated to the view is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsDefined(self, *args)


    def Resized(self, *args):
        """
        Resized(Handle_OpenGl_View self)

        Handle changing size of the rendering window.


        """
        return _OpenGl.Handle_OpenGl_View_Resized(self, *args)


    def Redraw(self, *args):
        """
        Redraw(Handle_OpenGl_View self)

        Redraw content of the view.


        """
        return _OpenGl.Handle_OpenGl_View_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(Handle_OpenGl_View self)

        Redraw immediate content of the view.


        """
        return _OpenGl.Handle_OpenGl_View_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(Handle_OpenGl_View self)

        Marks BVH tree for given priority list as dirty and marks primitive set for rebuild.


        """
        return _OpenGl.Handle_OpenGl_View_Invalidate(self, *args)


    def IsInvalidated(self, *args):
        """
        IsInvalidated(Handle_OpenGl_View self) -> Standard_Boolean

        Return true if view content cache has been invalidated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsInvalidated(self, *args)


    def GetGraduatedTrihedron(self, *args):
        """
        Returns data of a graduated trihedron

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        res = _OpenGl.Handle_OpenGl_View_GetGraduatedTrihedron(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GraduatedTrihedronDisplay(self, *args):
        """
        GraduatedTrihedronDisplay(Handle_OpenGl_View self, Graphic3d_GraduatedTrihedron theTrihedronData)

        Displays Graduated Trihedron.

        :type theTrihedronData: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        return _OpenGl.Handle_OpenGl_View_GraduatedTrihedronDisplay(self, *args)


    def GraduatedTrihedronErase(self, *args):
        """
        GraduatedTrihedronErase(Handle_OpenGl_View self)

        Erases Graduated Trihedron.


        """
        return _OpenGl.Handle_OpenGl_View_GraduatedTrihedronErase(self, *args)


    def GraduatedTrihedronMinMaxValues(self, *args):
        """
        GraduatedTrihedronMinMaxValues(Handle_OpenGl_View self, NCollection_Vec3_Standard_ShortReal theMin, NCollection_Vec3_Standard_ShortReal theMax)

        Sets minimum and maximum points of scene bounding box for Graduated Trihedron stored in graphic view object.
        @param theMin [in] the minimum point of scene.
        @param theMax [in] the maximum point of scene.

        :type theMin: OCC.wrapper.Graphic3d.Graphic3d_Vec3
        :type theMax: OCC.wrapper.Graphic3d.Graphic3d_Vec3

        """
        return _OpenGl.Handle_OpenGl_View_GraduatedTrihedronMinMaxValues(self, *args)


    def BufferDump(self, *args):
        """
        BufferDump(Handle_OpenGl_View self, Image_PixMap theImage, Graphic3d_BufferType const & theBufferType) -> Standard_Boolean

        Dump active rendering buffer into specified memory buffer.
        In Ray-Tracing allow to get a raw HDR buffer using Graphic3d_BT_RGB_RayTraceHdrLeft buffer type,
        only Left view will be dumped ignoring stereoscopic parameter.

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_BufferDump(self, *args)


    def Export(self, *args):
        """
        Export(Handle_OpenGl_View self, Standard_CString const theFileName, Graphic3d_ExportFormat const theFormat, Graphic3d_SortType const theSortType=Graphic3d_ST_BSP_Tree) -> Standard_Boolean

        Export scene into the one of the Vector graphics formats (SVG, PS, PDF...).
        In contrast to Bitmaps, Vector graphics is scalable (so you may got quality benefits
        on printing to laser printer). Notice however that results may differ a lot and
        do not contain some elements.

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFormat: OCC.wrapper.Graphic3d.Graphic3d_ExportFormat
        :type theSortType: OCC.wrapper.Graphic3d.Graphic3d_SortType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_Export(self, *args)


    def InvalidateBVHData(self, *args):
        """
        InvalidateBVHData(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Marks BVH tree and the set of BVH primitives of correspondent priority list with id theLayerId as outdated.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_View_InvalidateBVHData(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Insert a new top-level z layer with the given ID.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_View_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Remove a z layer with the given ID.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_View_RemoveZLayer(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer of specified view.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _OpenGl.Handle_OpenGl_View_SetZLayerSettings(self, *args)


    def ZLayerMax(self, *args):
        """
        ZLayerMax(Handle_OpenGl_View self) -> Standard_Integer

        Returns the maximum Z layer ID.
        First layer ID is Graphic3d_ZLayerId_Default, last ID is ZLayerMax().

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_View_ZLayerMax(self, *args)


    def InvalidateZLayerBoundingBox(self, *args):
        """
        InvalidateZLayerBoundingBox(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId)

        Returns the bounding box of all structures displayed in the Z layer.
        Never fails. If Z layer does not exist nothing happens.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_View_InvalidateZLayerBoundingBox(self, *args)


    def ZLayerBoundingBox(self, *args):
        """
        ZLayerBoundingBox(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId, Handle_Graphic3d_Camera theCamera, Standard_Integer const theWindowWidth, Standard_Integer const theWindowHeight, Standard_Boolean const theToIncludeAuxiliary) -> Bnd_Box

        Returns the bounding box of all structures displayed in the Z layer.
        If Z layer does not exist the empty box is returned.
        @param theLayerId            layer identifier
        @param theCamera             camera definition
        @param theWindowWidth        viewport width  (for applying transformation-persistence)
        @param theWindowHeight       viewport height (for applying transformation-persistence)
        @param theToIncludeAuxiliary consider also auxiliary presentations (with infinite flag or with trihedron transformation persistence)
        @return computed bounding box

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera
        :type theWindowWidth: int
        :type theWindowHeight: int
        :type theToIncludeAuxiliary: bool
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _OpenGl.Handle_OpenGl_View_ZLayerBoundingBox(self, *args)


    def FBO(self, *args):
        """
        FBO(Handle_OpenGl_View self) -> Handle_Standard_Transient

        Returns pointer to an assigned framebuffer object.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_View_FBO(self, *args)


    def SetFBO(self, *args):
        """
        SetFBO(Handle_OpenGl_View self, Handle_Standard_Transient theFbo)

        Sets framebuffer object for offscreen rendering.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_View_SetFBO(self, *args)


    def FBOCreate(self, *args):
        """
        FBOCreate(Handle_OpenGl_View self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Handle_Standard_Transient

        Generate offscreen FBO in the graphic library.
        If not supported on hardware returns NULL.

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_View_FBOCreate(self, *args)


    def FBORelease(self, *args):
        """
        FBORelease(Handle_OpenGl_View self, Handle_Standard_Transient theFbo)

        Remove offscreen FBO from the graphic library

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_View_FBORelease(self, *args)


    def FBOGetDimensions(self, *args):
        """
        FBOGetDimensions(Handle_OpenGl_View self, Handle_Standard_Transient theFbo)

        Read offscreen FBO configuration.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theWidth: int
        :type theHeight: int
        :type theWidthMax: int
        :type theHeightMax: int

        """
        return _OpenGl.Handle_OpenGl_View_FBOGetDimensions(self, *args)


    def FBOChangeViewport(self, *args):
        """
        FBOChangeViewport(Handle_OpenGl_View self, Handle_Standard_Transient theFbo, Standard_Integer const theWidth, Standard_Integer const theHeight)

        Change offscreen FBO viewport.

        :type theFbo: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theWidth: int
        :type theHeight: int

        """
        return _OpenGl.Handle_OpenGl_View_FBOChangeViewport(self, *args)


    def Background(self, *args):
        """
        Background(Handle_OpenGl_View self) -> Aspect_Background

        Returns background  fill color.

        :rtype: OCC.wrapper.Aspect.Aspect_Background

        """
        return _OpenGl.Handle_OpenGl_View_Background(self, *args)


    def SetBackground(self, *args):
        """
        SetBackground(Handle_OpenGl_View self, Aspect_Background theBackground)

        Sets background fill color.

        :type theBackground: OCC.wrapper.Aspect.Aspect_Background

        """
        return _OpenGl.Handle_OpenGl_View_SetBackground(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(Handle_OpenGl_View self) -> Aspect_GradientBackground

        Returns gradient background fill colors.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _OpenGl.Handle_OpenGl_View_GradientBackground(self, *args)


    def SetGradientBackground(self, *args):
        """
        SetGradientBackground(Handle_OpenGl_View self, Aspect_GradientBackground theBackground)

        Sets gradient background fill colors.

        :type theBackground: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _OpenGl.Handle_OpenGl_View_SetGradientBackground(self, *args)


    def BackgroundImage(self, *args):
        """
        BackgroundImage(Handle_OpenGl_View self) -> TCollection_AsciiString

        Returns background image texture file path.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.Handle_OpenGl_View_BackgroundImage(self, *args)


    def SetBackgroundImage(self, *args):
        """
        SetBackgroundImage(Handle_OpenGl_View self, TCollection_AsciiString theFilePath)

        Sets background image texture file path.

        :type theFilePath: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OpenGl.Handle_OpenGl_View_SetBackgroundImage(self, *args)


    def BackgroundImageStyle(self, *args):
        """
        BackgroundImageStyle(Handle_OpenGl_View self) -> Aspect_FillMethod

        Returns background image fill style.

        :rtype: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.Handle_OpenGl_View_BackgroundImageStyle(self, *args)


    def SetBackgroundImageStyle(self, *args):
        """
        SetBackgroundImageStyle(Handle_OpenGl_View self, Aspect_FillMethod const theFillStyle)

        Sets background image fill style.

        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod

        """
        return _OpenGl.Handle_OpenGl_View_SetBackgroundImageStyle(self, *args)


    def TextureEnv(self, *args):
        """
        TextureEnv(Handle_OpenGl_View self) -> Handle_Graphic3d_TextureEnv

        Returns environment texture set for the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _OpenGl.Handle_OpenGl_View_TextureEnv(self, *args)


    def SetTextureEnv(self, *args):
        """
        SetTextureEnv(Handle_OpenGl_View self, Handle_Graphic3d_TextureEnv theTextureEnv)

        Sets environment texture for the view.

        :type theTextureEnv: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _OpenGl.Handle_OpenGl_View_SetTextureEnv(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(Handle_OpenGl_View self) -> Standard_Boolean

        Returns the state of frustum culling optimization.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsCullingEnabled(self, *args)


    def SetCullingEnabled(self, *args):
        """
        SetCullingEnabled(Handle_OpenGl_View self, Standard_Boolean const theIsEnabled)

        Enables or disables frustum culling optimization.

        :type theIsEnabled: bool

        """
        return _OpenGl.Handle_OpenGl_View_SetCullingEnabled(self, *args)


    def BackfacingModel(self, *args):
        """
        BackfacingModel(Handle_OpenGl_View self) -> Graphic3d_TypeOfBackfacingModel

        Return backfacing model used for the view.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfBackfacingModel

        """
        return _OpenGl.Handle_OpenGl_View_BackfacingModel(self, *args)


    def SetBackfacingModel(self, *args):
        """
        SetBackfacingModel(Handle_OpenGl_View self, Graphic3d_TypeOfBackfacingModel const theModel)

        Sets backfacing model for the view.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfBackfacingModel

        """
        return _OpenGl.Handle_OpenGl_View_SetBackfacingModel(self, *args)


    def Camera(self, *args):
        """
        Returns camera object of the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _OpenGl.Handle_OpenGl_View_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalOrigin(self, *args):
        """
        Returns local camera origin currently set for rendering, might be modified during rendering.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _OpenGl.Handle_OpenGl_View_LocalOrigin(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalOrigin(self, *args):
        """
        SetLocalOrigin(Handle_OpenGl_View self, gp_XYZ theOrigin)

        Setup local camera origin currently set for rendering.

        :type theOrigin: OCC.wrapper.gp.gp_XYZ

        """
        return _OpenGl.Handle_OpenGl_View_SetLocalOrigin(self, *args)


    def SetCamera(self, *args):
        """
        SetCamera(Handle_OpenGl_View self, Handle_Graphic3d_Camera theCamera)

        Sets camera used by the view.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _OpenGl.Handle_OpenGl_View_SetCamera(self, *args)


    def Lights(self, *args):
        """
        Returns list of lights of the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        res = _OpenGl.Handle_OpenGl_View_Lights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLights(self, *args):
        """
        SetLights(Handle_OpenGl_View self, Handle_Graphic3d_LightSet theLights)

        Sets list of lights for the view.

        :type theLights: OCC.wrapper.Graphic3d.Handle_Graphic3d_LightSet

        """
        return _OpenGl.Handle_OpenGl_View_SetLights(self, *args)


    def ClipPlanes(self, *args):
        """
        Returns list of clip planes set for the view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _OpenGl.Handle_OpenGl_View_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_OpenGl_View self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Sets list of clip planes for the view.

        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.Handle_OpenGl_View_SetClipPlanes(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(Handle_OpenGl_View self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with diagnostic info.
        Should be called within rendering thread.

        This API should be used only for user output or for creating automated reports.
        The format of returned information (e.g. key-value layout)
        is NOT part of this API and can be changed at any time.
        Thus application should not parse returned information to weed out specific parameters.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _OpenGl.Handle_OpenGl_View_DiagnosticInformation(self, *args)


    def BackgroundColor(self, *args):
        """
        Returns background color.

        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        res = _OpenGl.Handle_OpenGl_View_BackgroundColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeGraduatedTrihedron(self, *args):
        """
        ChangeGraduatedTrihedron(Handle_OpenGl_View self) -> OpenGl_GraduatedTrihedron

        Change graduated trihedron.

        :rtype: OCC.wrapper.OpenGl.OpenGl_GraduatedTrihedron

        """
        return _OpenGl.Handle_OpenGl_View_ChangeGraduatedTrihedron(self, *args)


    def LayerList(self, *args):
        """
        Returns list of OpenGL Z-layers.

        :rtype: OCC.wrapper.OpenGl.OpenGl_LayerList

        """
        res = _OpenGl.Handle_OpenGl_View_LayerList(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GlWindow(self, *args):
        """
        GlWindow(Handle_OpenGl_View self) -> Handle_OpenGl_Window

        Returns OpenGL window implementation.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Window

        """
        return _OpenGl.Handle_OpenGl_View_GlWindow(self, *args)


    def GlTextureEnv(self, *args):
        """
        Returns OpenGL environment map.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.Handle_OpenGl_View_GlTextureEnv(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVHTreeSelector(self, *args):
        """
        Returns selector for BVH tree, providing a possibility to store information
        about current view volume and to detect which objects are overlapping it.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHTreeSelector

        """
        res = _OpenGl.Handle_OpenGl_View_BVHTreeSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasImmediateStructures(self, *args):
        """
        HasImmediateStructures(Handle_OpenGl_View self) -> bool

        Returns true if there are immediate structures to display

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_View_HasImmediateStructures(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_View self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_View_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_View_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_View_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Identification(self, *args):
        """
        Identification(Handle_OpenGl_View self) -> Standard_Integer

        Returns the identification number of the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_View_Identification(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_OpenGl_View self)

        Activates the view. Maps presentations defined within structure manager onto this view.


        """
        return _OpenGl.Handle_OpenGl_View_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_OpenGl_View self)

        Deactivates the view. Unmaps presentations defined within structure manager.
        The view in deactivated state will ignore actions on structures such as Display().


        """
        return _OpenGl.Handle_OpenGl_View_Deactivate(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_OpenGl_View self) -> Standard_Boolean

        Returns the activity flag of the view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsActive(self, *args)


    def IsRemoved(self, *args):
        """
        IsRemoved(Handle_OpenGl_View self) -> Standard_Boolean

        Returns true if the view was removed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsRemoved(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(Handle_OpenGl_View self) -> Graphic3d_TypeOfShadingModel

        Returns default Shading Model of the view; Graphic3d_TOSM_FRAGMENT by default.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_View_ShadingModel(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(Handle_OpenGl_View self, Graphic3d_TypeOfShadingModel theModel)

        Sets default Shading Model of the view.
        Will throw an exception on attempt to set Graphic3d_TOSM_DEFAULT.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.Handle_OpenGl_View_SetShadingModel(self, *args)


    def VisualizationType(self, *args):
        """
        VisualizationType(Handle_OpenGl_View self) -> Graphic3d_TypeOfVisualization

        Returns visualization type of the view.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfVisualization

        """
        return _OpenGl.Handle_OpenGl_View_VisualizationType(self, *args)


    def SetVisualizationType(self, *args):
        """
        SetVisualizationType(Handle_OpenGl_View self, Graphic3d_TypeOfVisualization const theType)

        Sets visualization type of the view.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfVisualization

        """
        return _OpenGl.Handle_OpenGl_View_SetVisualizationType(self, *args)


    def SetComputedMode(self, *args):
        """
        SetComputedMode(Handle_OpenGl_View self, Standard_Boolean const theMode)

        Switches computed HLR mode in the view

        :type theMode: bool

        """
        return _OpenGl.Handle_OpenGl_View_SetComputedMode(self, *args)


    def ComputedMode(self, *args):
        """
        ComputedMode(Handle_OpenGl_View self) -> Standard_Boolean

        Returns the computed HLR mode state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_ComputedMode(self, *args)


    def ReCompute(self, *args):
        """
        ReCompute(Handle_OpenGl_View self, Handle_Graphic3d_Structure theStructure)

        Computes the new presentation of the structure  displayed in this view with the type Graphic3d_TOS_COMPUTED.

        :type theStructure: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        return _OpenGl.Handle_OpenGl_View_ReCompute(self, *args)


    def Update(self, *args):
        """
        Update(Handle_OpenGl_View self, Graphic3d_ZLayerId const theLayerId=Graphic3d_ZLayerId_UNKNOWN)

        Invalidates bounding box of specified ZLayerId.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_View_Update(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_OpenGl_View self)

        Computes the new presentation of the structures displayed in this view with the type Graphic3d_TOS_COMPUTED.


        """
        return _OpenGl.Handle_OpenGl_View_Compute(self, *args)


    def ContainsFacet(self, *args):
        """
        ContainsFacet(Handle_OpenGl_View self) -> Standard_Boolean
        ContainsFacet(Handle_OpenGl_View self, Graphic3d_MapOfStructure const & theSet) -> Standard_Boolean

        Returns Standard_True if one of the structures in the set contains Polygons, Triangles or Quadrangles.

        :type theSet: OCC.wrapper.Graphic3d.Graphic3d_MapOfStructure
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_ContainsFacet(self, *args)


    def DisplayedStructures(self, *args):
        """
        DisplayedStructures(Handle_OpenGl_View self, Graphic3d_MapOfStructure & theStructures)

        Returns the set of structures displayed in this view.

        :type theStructures: OCC.wrapper.Graphic3d.Graphic3d_MapOfStructure

        """
        return _OpenGl.Handle_OpenGl_View_DisplayedStructures(self, *args)


    def NumberOfDisplayedStructures(self, *args):
        """
        NumberOfDisplayedStructures(Handle_OpenGl_View self) -> Standard_Integer

        Returns number of displayed structures in the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_View_NumberOfDisplayedStructures(self, *args)


    def HiddenObjects(self, *args):
        """
        Returns map of objects hidden within this specific view (not viewer-wise).

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_NMapOfTransient

        """
        res = _OpenGl.Handle_OpenGl_View_HiddenObjects(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeHiddenObjects(self, *args):
        """
        ChangeHiddenObjects(Handle_OpenGl_View self) -> Handle_Graphic3d_NMapOfTransient

        Returns map of objects hidden within this specific view (not viewer-wise).

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_NMapOfTransient

        """
        return _OpenGl.Handle_OpenGl_View_ChangeHiddenObjects(self, *args)


    def IsComputed(self, *args):
        """
        IsComputed(Handle_OpenGl_View self, Standard_Integer const theStructId, Handle_Graphic3d_Structure theComputedStruct) -> Standard_Boolean

        Returns Standard_True in case if the structure with the given <theStructId> is
        in list of structures to be computed and stores computed struct to <theComputedStruct>.

        :type theStructId: int
        :type theComputedStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsComputed(self, *args)


    def MinMaxValues(self, *args):
        """
        MinMaxValues(Handle_OpenGl_View self, Standard_Boolean const theToIncludeAuxiliary) -> Bnd_Box
        MinMaxValues(Handle_OpenGl_View self, Graphic3d_MapOfStructure const & theSet, Standard_Boolean const theToIncludeAuxiliary) -> Bnd_Box

        Returns the coordinates of the boundary box of all structures in the set <theSet>.
        If <theToIgnoreInfiniteFlag> is TRUE, then the boundary box
        also includes minimum and maximum limits of graphical elements
        forming parts of infinite structures.

        :type theSet: OCC.wrapper.Graphic3d.Graphic3d_MapOfStructure
        :type theToIncludeAuxiliary: bool
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _OpenGl.Handle_OpenGl_View_MinMaxValues(self, *args)


    def StructureManager(self, *args):
        """
        Returns the structure manager handle which manage structures associated with this view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager

        """
        res = _OpenGl.Handle_OpenGl_View_StructureManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConsiderZoomPersistenceObjects(self, *args):
        """
        ConsiderZoomPersistenceObjects(Handle_OpenGl_View self) -> Standard_Real

        Returns zoom-scale factor.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OpenGl.Handle_OpenGl_View_ConsiderZoomPersistenceObjects(self, *args)


    def CopySettings(self, *args):
        """
        CopySettings(Handle_OpenGl_View self, Handle_Graphic3d_CView theOther)

        Copy visualization settings from another view.
        Method is used for cloning views in viewer when its required to create view
        with same view properties.

        :type theOther: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _OpenGl.Handle_OpenGl_View_CopySettings(self, *args)


    def RenderingParams(self, *args):
        """
        Returns current rendering parameters and effect settings.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        res = _OpenGl.Handle_OpenGl_View_RenderingParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeRenderingParams(self, *args):
        """
        ChangeRenderingParams(Handle_OpenGl_View self) -> Graphic3d_RenderingParams

        Returns reference to current rendering parameters and effect settings.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        return _OpenGl.Handle_OpenGl_View_ChangeRenderingParams(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_View self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_View_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_View self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_View self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_View self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_View self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_View_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_View self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_View_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_View self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_View_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_View self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_View_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_View self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_View_DecrementRefCounter(self, *args)

Handle_OpenGl_View_swigregister = _OpenGl.Handle_OpenGl_View_swigregister
Handle_OpenGl_View_swigregister(Handle_OpenGl_View)

def Handle_OpenGl_View_DownCast(thing):
    return _OpenGl.Handle_OpenGl_View_DownCast(thing)
Handle_OpenGl_View_DownCast = _OpenGl.Handle_OpenGl_View_DownCast

class Handle_OpenGl_VertexBuffer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_VertexBuffer self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_VertexBuffer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_VertexBuffer self, OpenGl_VertexBuffer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_VertexBuffer theHandle) -> Handle_OpenGl_VertexBuffer
        assign(Handle_OpenGl_VertexBuffer self, OpenGl_VertexBuffer thePtr) -> Handle_OpenGl_VertexBuffer
        assign(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_VertexBuffer theHandle) -> Handle_OpenGl_VertexBuffer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_VertexBuffer self) -> OpenGl_VertexBuffer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_VertexBuffer self) -> OpenGl_VertexBuffer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_VertexBuffer self) -> OpenGl_VertexBuffer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_VertexBuffer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_VertexBuffer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_VertexBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_VertexBuffer_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_VertexBuffer

    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_VertexBuffer self) -> GLenum

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetTarget(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_VertexBuffer self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_IsValid(self, *args)


    def GetComponentsNb(self, *args):
        """
        GetComponentsNb(Handle_OpenGl_VertexBuffer self) -> GLuint

        @return the number of components per generic vertex attribute.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetComponentsNb(self, *args)


    def GetElemsNb(self, *args):
        """
        GetElemsNb(Handle_OpenGl_VertexBuffer self) -> GLsizei

        @return number of vertex attributes / number of vertices.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetElemsNb(self, *args)


    def GetDataType(self, *args):
        """
        GetDataType(Handle_OpenGl_VertexBuffer self) -> GLenum

        @return data type of each component in the array.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetDataType(self, *args)


    def GetDataOffset(self, *args):
        """
        GetDataOffset(Handle_OpenGl_VertexBuffer self) -> GLubyte *

        @return offset to data, NULL by default

        :rtype: GLubyte

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetDataOffset(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO name (id) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_VertexBuffer self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Release(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Unbind(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        @param theComponentsNb - specifies the number of components per generic vertex attribute; must be 1, 2, 3, or 4;
        @param theElemsNb      - elements count;
        @param theData         - pointer to GLubyte data (indices/colors etc.).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Init(self, *args)


    def SubData(self, *args):
        """
        SubData(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        SubData(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLuint const * theData) -> bool
        SubData(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLushort const * theData) -> bool
        SubData(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        Function replaces portion of data within this VBO using glBufferSubData().
        The VBO should be initialized before call.
        @param theElemFrom element id from which replace buffer data (>=0);
        @param theElemsNb  elements count (theElemFrom + theElemsNb <= GetElemsNb());
        @param theData     pointer to GLubyte data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_SubData(self, *args)


    def BindVertexAttrib(self, *args):
        """
        BindVertexAttrib(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Bind this VBO to active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_BindVertexAttrib(self, *args)


    def UnbindVertexAttrib(self, *args):
        """
        UnbindVertexAttrib(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Unbind any VBO from active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_UnbindVertexAttrib(self, *args)


    def BindAttribute(self, *args):
        """
        BindAttribute(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Bind this VBO and enable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theGlCtx - handle to bound GL context;
        @param theMode  - array mode (GL_VERTEX_ARRAY, GL_NORMAL_ARRAY, GL_COLOR_ARRAY, GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_BindAttribute(self, *args)


    def UnbindAttribute(self, *args):
        """
        UnbindAttribute(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Unbind this VBO and disable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theCtx handle to bound GL context
        @param theMode  array mode

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_UnbindAttribute(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_VertexBuffer self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_EstimatedDataSize(self, *args)


    def sizeOfGlType(self, *args):
        """
        sizeOfGlType(Handle_OpenGl_VertexBuffer self, GLenum const theType) -> size_t

        @return size of specified GL type

        :type theType: GLenum
        :rtype: size_t

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_sizeOfGlType(self, *args)


    def init(self, *args):
        """
        init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool
        init(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Initialize buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_init(self, *args)


    def subData(self, *args):
        """
        subData(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_subData(self, *args)


    def bindAttribute(self, *args):
        """
        bindAttribute(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

        Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using bindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
        :type theNbComp: GLint
        :type theDataType: GLenum
        :type theStride: GLsizei
        :type theOffset: GLvoid

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_bindAttribute(self, *args)


    def unbindAttribute(self, *args):
        """
        unbindAttribute(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

        Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using unbindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_unbindAttribute(self, *args)


    def HasColorAttribute(self, *args):
        """
        HasColorAttribute(Handle_OpenGl_VertexBuffer self) -> bool

        @return true if buffer contains per-vertex color attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_HasColorAttribute(self, *args)


    def HasNormalAttribute(self, *args):
        """
        HasNormalAttribute(Handle_OpenGl_VertexBuffer self) -> bool

        @return true if buffer contains per-vertex normal attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_HasNormalAttribute(self, *args)


    def BindAllAttributes(self, *args):
        """
        BindAllAttributes(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind all vertex attributes to active program OpenGl_Context::ActiveProgram() or for FFP.
        Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_BindAllAttributes(self, *args)


    def BindPositionAttribute(self, *args):
        """
        BindPositionAttribute(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind vertex position attribute only. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_BindPositionAttribute(self, *args)


    def UnbindAllAttributes(self, *args):
        """
        UnbindAllAttributes(Handle_OpenGl_VertexBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind all vertex attributes. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_UnbindAllAttributes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_VertexBuffer self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_VertexBuffer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_VertexBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_VertexBuffer self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_VertexBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_VertexBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_VertexBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_VertexBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_VertexBuffer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_VertexBuffer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_VertexBuffer self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_VertexBuffer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_VertexBuffer_DecrementRefCounter(self, *args)

Handle_OpenGl_VertexBuffer_swigregister = _OpenGl.Handle_OpenGl_VertexBuffer_swigregister
Handle_OpenGl_VertexBuffer_swigregister(Handle_OpenGl_VertexBuffer)

def Handle_OpenGl_VertexBuffer_DownCast(thing):
    return _OpenGl.Handle_OpenGl_VertexBuffer_DownCast(thing)
Handle_OpenGl_VertexBuffer_DownCast = _OpenGl.Handle_OpenGl_VertexBuffer_DownCast

class OpenGl_OitState(OpenGl_StateInterface):
    """Defines generic state of order-independent transparency rendering properties."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_OitState self, bool const theToEnableWrite, float const theDepthFactor)

        Sets the uniform values.
        @param theToEnableWrite [in] flag indicating whether color and coverage
        values for OIT processing should be written by shader program.
        @param theDepthFactor [in] scalar factor [0-1] defining influence of depth
        component of a fragment to its final coverage coefficient.

        :type theToEnableWrite: const bool
        :type theDepthFactor: const float

        """
        return _OpenGl.OpenGl_OitState_Set(self, *args)


    def ToEnableWrite(self, *args):
        """
        ToEnableWrite(OpenGl_OitState self) -> bool

        Returns flag indicating whether writing of output for OIT processing
        should be enabled/disabled.

        :rtype: bool

        """
        return _OpenGl.OpenGl_OitState_ToEnableWrite(self, *args)


    def DepthFactor(self, *args):
        """
        DepthFactor(OpenGl_OitState self) -> float

        Returns factor defining influence of depth component of a fragment
        to its final coverage coefficient.

        :rtype: float

        """
        return _OpenGl.OpenGl_OitState_DepthFactor(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_OitState
OpenGl_OitState_swigregister = _OpenGl.OpenGl_OitState_swigregister
OpenGl_OitState_swigregister(OpenGl_OitState)

class Handle_OpenGl_TextureSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_TextureSet self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_TextureSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_TextureSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_TextureSet self, OpenGl_TextureSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_TextureSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_TextureSet self, Handle_OpenGl_TextureSet theHandle) -> Handle_OpenGl_TextureSet
        assign(Handle_OpenGl_TextureSet self, OpenGl_TextureSet thePtr) -> Handle_OpenGl_TextureSet
        assign(Handle_OpenGl_TextureSet self, Handle_OpenGl_TextureSet theHandle) -> Handle_OpenGl_TextureSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_TextureSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_TextureSet self) -> OpenGl_TextureSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_TextureSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_TextureSet self) -> OpenGl_TextureSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_TextureSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_TextureSet self) -> OpenGl_TextureSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_TextureSet___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_TextureSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_TextureSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_TextureSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_TextureSet_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_TextureSet

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_TextureSet self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_TextureSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_TextureSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_TextureSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_OpenGl_TextureSet self) -> Standard_Boolean

        Return TRUE if texture array is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_TextureSet_IsEmpty(self, *args)


    def Size(self, *args):
        """
        Size(Handle_OpenGl_TextureSet self) -> Standard_Integer

        Return number of textures.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureSet_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_OpenGl_TextureSet self) -> Standard_Integer

        Return the lower index in texture set.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureSet_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_OpenGl_TextureSet self) -> Standard_Integer

        Return the upper index in texture set.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureSet_Upper(self, *args)


    def First(self, *args):
        """
        Return the first texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.Handle_OpenGl_TextureSet_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_OpenGl_TextureSet self) -> Handle_OpenGl_Texture

        Return the first texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        return _OpenGl.Handle_OpenGl_TextureSet_ChangeFirst(self, *args)


    def Value(self, *args):
        """
        Return the texture at specified position within [0, Size()) range.

        :type theIndex: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.Handle_OpenGl_TextureSet_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_OpenGl_TextureSet self, Standard_Integer theIndex) -> Handle_OpenGl_Texture

        Return the texture at specified position within [0, Size()) range.

        :type theIndex: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        return _OpenGl.Handle_OpenGl_TextureSet_ChangeValue(self, *args)


    def IsModulate(self, *args):
        """
        IsModulate(Handle_OpenGl_TextureSet self) -> bool

        Return TRUE if texture color modulation has been enabled for the first texture
        or if texture is not set at all.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureSet_IsModulate(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_TextureSet self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_TextureSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_TextureSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_TextureSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_TextureSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_TextureSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_TextureSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_TextureSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_TextureSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_TextureSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_TextureSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_TextureSet self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_TextureSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_TextureSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureSet_DecrementRefCounter(self, *args)

Handle_OpenGl_TextureSet_swigregister = _OpenGl.Handle_OpenGl_TextureSet_swigregister
Handle_OpenGl_TextureSet_swigregister(Handle_OpenGl_TextureSet)

def Handle_OpenGl_TextureSet_DownCast(thing):
    return _OpenGl.Handle_OpenGl_TextureSet_DownCast(thing)
Handle_OpenGl_TextureSet_DownCast = _OpenGl.Handle_OpenGl_TextureSet_DownCast

class NCollection_List_OpenGl_Structure(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_OpenGl_Structure self) -> NCollection_List< OpenGl_Structure const * >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_OpenGl_Structure self) -> NCollection_List< OpenGl_Structure const * >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_OpenGl_Structure self) -> NCollection_List< OpenGl_Structure const * >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_OpenGl_Structure self) -> NCollection_List< OpenGl_Structure const * >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _OpenGl.new_NCollection_List_OpenGl_Structure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_OpenGl_Structure self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther) -> NCollection_List_OpenGl_Structure

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther) -> NCollection_List_OpenGl_Structure

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_OpenGl_Structure self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_List_OpenGl_Structure_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_List_OpenGl_Structure_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_OpenGl_Structure self, OpenGl_Structure theItem) -> OpenGl_Structure
        Append(NCollection_List_OpenGl_Structure self, OpenGl_Structure theItem, NCollection_List< OpenGl_Structure const * >::Iterator & theIter)
        Append(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_OpenGl_Structure self, OpenGl_Structure theItem) -> OpenGl_Structure
        Prepend(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_OpenGl_Structure self)

        RemoveFirst item


        """
        return _OpenGl.NCollection_List_OpenGl_Structure_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_OpenGl_Structure self, NCollection_List< OpenGl_Structure const * >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_OpenGl_Structure self, OpenGl_Structure theItem, NCollection_List< OpenGl_Structure const * >::Iterator & theIter) -> OpenGl_Structure
        InsertBefore(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther, NCollection_List< OpenGl_Structure const * >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_OpenGl_Structure self, OpenGl_Structure theItem, NCollection_List< OpenGl_Structure const * >::Iterator & theIter) -> OpenGl_Structure
        InsertAfter(NCollection_List_OpenGl_Structure self, NCollection_List_OpenGl_Structure theOther, NCollection_List< OpenGl_Structure const * >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _OpenGl.NCollection_List_OpenGl_Structure_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_OpenGl_Structure self)

        Reverse the list


        """
        return _OpenGl.NCollection_List_OpenGl_Structure_Reverse(self, *args)


    def __iter__(self):
        return _OpenGl.NCollection_List_OpenGl_Structure___iter__(self)
    __swig_destroy__ = _OpenGl.delete_NCollection_List_OpenGl_Structure
NCollection_List_OpenGl_Structure_swigregister = _OpenGl.NCollection_List_OpenGl_Structure_swigregister
NCollection_List_OpenGl_Structure_swigregister(NCollection_List_OpenGl_Structure)

class NCollection_List_OpenGl_Structure_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _OpenGl.new_NCollection_List_OpenGl_Structure_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_List_OpenGl_Structure_IteratorHelper

    def __next__(self):
        return _OpenGl.NCollection_List_OpenGl_Structure_IteratorHelper___next__(self)
NCollection_List_OpenGl_Structure_IteratorHelper_swigregister = _OpenGl.NCollection_List_OpenGl_Structure_IteratorHelper_swigregister
NCollection_List_OpenGl_Structure_IteratorHelper_swigregister(NCollection_List_OpenGl_Structure_IteratorHelper)


try:
	OpenGl_ListOfStructure = NCollection_List_OpenGl_Structure
except NameError:
	pass # does not exist, probably ignored

class Handle_OpenGl_FrameBuffer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_FrameBuffer self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_FrameBuffer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_FrameBuffer self, OpenGl_FrameBuffer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_FrameBuffer theHandle) -> Handle_OpenGl_FrameBuffer
        assign(Handle_OpenGl_FrameBuffer self, OpenGl_FrameBuffer thePtr) -> Handle_OpenGl_FrameBuffer
        assign(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_FrameBuffer theHandle) -> Handle_OpenGl_FrameBuffer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_FrameBuffer self) -> OpenGl_FrameBuffer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_FrameBuffer self) -> OpenGl_FrameBuffer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_FrameBuffer self) -> OpenGl_FrameBuffer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_FrameBuffer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_FrameBuffer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_FrameBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_FrameBuffer_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_FrameBuffer

    def BufferDump(self, *args):
        """
        BufferDump(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, Handle_OpenGl_FrameBuffer theFbo, Image_PixMap theImage, Graphic3d_BufferType theBufferType) -> Standard_Boolean

        Dump content into image.
        @param theGlCtx      bound OpenGL context
        @param theFbo        FBO to dump (or window buffer, if NULL)
        @param theImage      target image
        @param theBufferType buffer type (attachment) to dump
        @return TRUE on success

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer
        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_BufferDump(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_FrameBuffer self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_Release(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Number of multisampling samples.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_NbSamples(self, *args)


    def NbColorBuffers(self, *args):
        """
        NbColorBuffers(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Number of color buffers.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_NbColorBuffers(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_OpenGl_FrameBuffer self) -> bool

        Return true if FBO has been created with color attachment.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_HasColor(self, *args)


    def HasDepth(self, *args):
        """
        HasDepth(Handle_OpenGl_FrameBuffer self) -> bool

        Return true if FBO has been created with depth attachment.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_HasDepth(self, *args)


    def GetSizeX(self, *args):
        """
        GetSizeX(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Textures width.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetSizeX(self, *args)


    def GetSizeY(self, *args):
        """
        GetSizeY(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Textures height.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetSizeY(self, *args)


    def GetVPSizeX(self, *args):
        """
        GetVPSizeX(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Viewport width.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetVPSizeX(self, *args)


    def GetVPSizeY(self, *args):
        """
        GetVPSizeY(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Viewport height.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetVPSizeY(self, *args)


    def GetInitVPSizeX(self, *args):
        """
        GetInitVPSizeX(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Viewport width.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetInitVPSizeX(self, *args)


    def GetInitVPSizeY(self, *args):
        """
        GetInitVPSizeY(Handle_OpenGl_FrameBuffer self) -> GLsizei

        Viewport height.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetInitVPSizeY(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_FrameBuffer self) -> Standard_Boolean

        Returns true if current object was initialized

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_IsValid(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, NCollection_Vector_GLint theColorFormats, Handle_OpenGl_Texture theDepthStencilTexture, GLsizei const theNbSamples=0) -> Standard_Boolean
        Init(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        Init(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, NCollection_Vector_GLint theColorFormats, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean

        Initialize FBO for rendering into single/multiple color buffer and depth textures.
        @param theGlCtx        currently bound OpenGL context
        @param theSizeX        texture width
        @param theSizeY        texture height
        @param theColorFormats list of color texture sized format (0 means no color attachment), e.g. GL_RGBA8
        @param theDepthFormat  depth-stencil texture sized format (0 means no depth attachment), e.g. GL_DEPTH24_STENCIL8
        @param theNbSamples    MSAA number of samples (0 means normal texture)
        @return true on success

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theColorFormats: OCC.wrapper.OpenGl.OpenGl_ColorFormats
        :type theDepthFormat: GLint
        :type theNbSamples: GLsizei
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_Init(self, *args)


    def InitLazy(self, *args):
        """
        InitLazy(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theViewportSizeX, GLsizei const theViewportSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        InitLazy(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theViewportSizeX, GLsizei const theViewportSizeY, NCollection_Vector_GLint theColorFormats, GLint const theDepthFormat, GLsizei const theNbSamples=0) -> Standard_Boolean
        InitLazy(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, OpenGl_FrameBuffer theFbo) -> Standard_Boolean

        (Re-)initialize FBO with properties taken from another FBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFbo: OCC.wrapper.OpenGl.OpenGl_FrameBuffer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_InitLazy(self, *args)


    def InitWithRB(self, *args):
        """
        InitWithRB(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx, GLsizei const theSizeX, GLsizei const theSizeY, GLint const theColorFormat, GLint const theDepthFormat, GLuint const theColorRBufferFromWindow=0) -> Standard_Boolean

        (Re-)initialize FBO with specified dimensions.
        The Render Buffer Objects will be used for Color, Depth and Stencil attachments (as opposite to textures).
        @param theGlCtx       currently bound OpenGL context
        @param theSizeX       render buffer width
        @param theSizeY       render buffer height
        @param theColorFormat color         render buffer sized format, e.g. GL_RGBA8
        @param theDepthFormat depth-stencil render buffer sized format, e.g. GL_DEPTH24_STENCIL8
        @param theColorRBufferFromWindow when specified - should be ID of already initialized RB object, which will be released within this class

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSizeX: GLsizei
        :type theSizeY: GLsizei
        :type theColorFormat: GLint
        :type theDepthFormat: GLint
        :type theColorRBufferFromWindow: GLuint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_InitWithRB(self, *args)


    def InitWrapper(self, *args):
        """
        InitWrapper(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx) -> Standard_Boolean

        Initialize class from currently bound FBO.
        Retrieved OpenGL objects will not be destroyed on Release.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_InitWrapper(self, *args)


    def SetupViewport(self, *args):
        """
        SetupViewport(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Setup viewport to render into FBO

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_SetupViewport(self, *args)


    def ChangeViewport(self, *args):
        """
        ChangeViewport(Handle_OpenGl_FrameBuffer self, GLsizei const theVPSizeX, GLsizei const theVPSizeY)

        Override viewport settings

        :type theVPSizeX: GLsizei
        :type theVPSizeY: GLsizei

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_ChangeViewport(self, *args)


    def BindBuffer(self, *args):
        """
        BindBuffer(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for drawing and reading (to render into the texture).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_BindBuffer(self, *args)


    def BindDrawBuffer(self, *args):
        """
        BindDrawBuffer(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for drawing GL_DRAW_FRAMEBUFFER (to render into the texture).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_BindDrawBuffer(self, *args)


    def BindReadBuffer(self, *args):
        """
        BindReadBuffer(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Bind frame buffer for reading GL_READ_FRAMEBUFFER

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_BindReadBuffer(self, *args)


    def UnbindBuffer(self, *args):
        """
        UnbindBuffer(Handle_OpenGl_FrameBuffer self, Handle_OpenGl_Context theGlCtx)

        Unbind frame buffer.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_UnbindBuffer(self, *args)


    def ColorTexture(self, *args):
        """
        Returns the color texture for the given color buffer index.

        :type theColorBufferIndex: GLint
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.Handle_OpenGl_FrameBuffer_ColorTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DepthStencilTexture(self, *args):
        """
        Returns the depth-stencil texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Texture

        """
        res = _OpenGl.Handle_OpenGl_FrameBuffer_DepthStencilTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ColorRenderBuffer(self, *args):
        """
        ColorRenderBuffer(Handle_OpenGl_FrameBuffer self) -> GLuint

        Returns the color Render Buffer.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_ColorRenderBuffer(self, *args)


    def DepthStencilRenderBuffer(self, *args):
        """
        DepthStencilRenderBuffer(Handle_OpenGl_FrameBuffer self) -> GLuint

        Returns the depth Render Buffer.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_DepthStencilRenderBuffer(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_FrameBuffer self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_EstimatedDataSize(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_FrameBuffer self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_FrameBuffer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_FrameBuffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_FrameBuffer self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_FrameBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_FrameBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_FrameBuffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_FrameBuffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_FrameBuffer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_FrameBuffer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_FrameBuffer self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_FrameBuffer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_FrameBuffer_DecrementRefCounter(self, *args)

Handle_OpenGl_FrameBuffer_swigregister = _OpenGl.Handle_OpenGl_FrameBuffer_swigregister
Handle_OpenGl_FrameBuffer_swigregister(Handle_OpenGl_FrameBuffer)

def Handle_OpenGl_FrameBuffer_DownCast(thing):
    return _OpenGl.Handle_OpenGl_FrameBuffer_DownCast(thing)
Handle_OpenGl_FrameBuffer_DownCast = _OpenGl.Handle_OpenGl_FrameBuffer_DownCast

class OpenGl_GraduatedTrihedron(object):
    """
    This class allows to render Graduated Trihedron, i.e. trihedron with grid.
    it is based on Graphic3d_GraduatedTrihedron parameters and support its customization
    on construction level only.
    @sa Graphic3d_GraduatedTrihedron
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _OpenGl.delete_OpenGl_GraduatedTrihedron
OpenGl_GraduatedTrihedron_swigregister = _OpenGl.OpenGl_GraduatedTrihedron_swigregister
OpenGl_GraduatedTrihedron_swigregister(OpenGl_GraduatedTrihedron)

class BVH_Geometry_Standard_ShortReal_(object):
    """
    BVH geometry as a set of abstract geometric objects
    organized with bounding volume hierarchy (BVH).
    	param T Numeric data type
    	param N Vector dimension
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        BVH geometry as a set of abstract geometric objects
        organized with bounding volume hierarchy (BVH).
        	param T Numeric data type
        	param N Vector dimension
        """
        this = _OpenGl.new_BVH_Geometry_Standard_ShortReal_(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDirty(self, *args):
        """
        IsDirty(BVH_Geometry_Standard_ShortReal_ self) -> Standard_Boolean

        Returns TRUE if geometry state should be updated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.BVH_Geometry_Standard_ShortReal__IsDirty(self, *args)


    def MarkDirty(self, *args):
        """
        MarkDirty(BVH_Geometry_Standard_ShortReal_ self)

        Marks geometry as outdated.


        """
        return _OpenGl.BVH_Geometry_Standard_ShortReal__MarkDirty(self, *args)


    def Box(self, *args):
        """
        Box(BVH_Geometry_Standard_ShortReal_ self) -> BVH_Box< float,3 >

        Returns AABB of the whole geometry.

        :rtype: OCC.wrapper.BVH.BVH_Box_T

        """
        return _OpenGl.BVH_Geometry_Standard_ShortReal__Box(self, *args)


    def BVH(self, *args):
        """
        Returns BVH tree (and builds it if necessary).

        :rtype: OCC.wrapper.BVH.Handle_BVH_Tree_T

        """
        res = _OpenGl.BVH_Geometry_Standard_ShortReal__BVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Builder(self, *args):
        """
        Returns the method (builder) used to construct BVH.

        :rtype: OCC.wrapper.BVH.Handle_BVH_Builder_T

        """
        res = _OpenGl.BVH_Geometry_Standard_ShortReal__Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBuilder(self, *args):
        """
        SetBuilder(BVH_Geometry_Standard_ShortReal_ self, opencascade::handle< BVH_Builder< float,3 > > const & theBuilder)

        Sets the method (builder) used to construct BVH.

        :type theBuilder: OCC.wrapper.BVH.Handle_BVH_Builder_T

        """
        return _OpenGl.BVH_Geometry_Standard_ShortReal__SetBuilder(self, *args)

    __swig_destroy__ = _OpenGl.delete_BVH_Geometry_Standard_ShortReal_
BVH_Geometry_Standard_ShortReal__swigregister = _OpenGl.BVH_Geometry_Standard_ShortReal__swigregister
BVH_Geometry_Standard_ShortReal__swigregister(BVH_Geometry_Standard_ShortReal_)

class NCollection_Sequence_Handle_OpenGl_ShaderProgram(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_ShaderProgram(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_OpenGl_ShaderProgram self)

        Reverse sequence


        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence_Handle_OpenGl_ShaderProgram theOther) -> NCollection_Sequence_Handle_OpenGl_ShaderProgram

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence_Handle_OpenGl_ShaderProgram theOther) -> NCollection_Sequence_Handle_OpenGl_ShaderProgram

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Handle_OpenGl_ShaderProgram theItem)
        Append(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence_Handle_OpenGl_ShaderProgram theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Handle_OpenGl_ShaderProgram theItem)
        Prepend(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence_Handle_OpenGl_ShaderProgram theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, Handle_OpenGl_ShaderProgram theItem)
        InsertBefore(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderProgram theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, NCollection_Sequence< opencascade::handle< OpenGl_ShaderProgram > >::Iterator & thePosition, Handle_OpenGl_ShaderProgram theItem)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderProgram theSeq)
        InsertAfter(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, Handle_OpenGl_ShaderProgram theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, NCollection_Sequence_Handle_OpenGl_ShaderProgram theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Handle_OpenGl_ShaderProgram

        First item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_OpenGl_ShaderProgram self) -> Handle_OpenGl_ShaderProgram

        Last item access

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex) -> Handle_OpenGl_ShaderProgram

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_OpenGl_ShaderProgram self, Standard_Integer const theIndex, Handle_OpenGl_ShaderProgram theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_SetValue(self, *args)


    def __iter__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram___iter__(self)
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_ShaderProgram
NCollection_Sequence_Handle_OpenGl_ShaderProgram_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_swigregister
NCollection_Sequence_Handle_OpenGl_ShaderProgram_swigregister(NCollection_Sequence_Handle_OpenGl_ShaderProgram)

def NCollection_Sequence_Handle_OpenGl_ShaderProgram_delNode(*args):
    """
    NCollection_Sequence_Handle_OpenGl_ShaderProgram_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_delNode(*args)

class NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _OpenGl.new_NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper

    def __next__(self):
        return _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper___next__(self)
NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper_swigregister = _OpenGl.NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper_swigregister
NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper_swigregister(NCollection_Sequence_Handle_OpenGl_ShaderProgram_IteratorHelper)


try:
	OpenGl_ShaderProgramList = NCollection_Sequence_Handle_OpenGl_ShaderProgram
except NameError:
	pass # does not exist, probably ignored

class OpenGl_Flipper(object):
    """
    Being rendered, the elements modifies current model-view matrix such that the axes of
    the specified reference system (in model space) become oriented in the following way:
    - X    - heads to the right side of view.
    - Y    - heads to the up side of view.
    - N(Z) - heads towards the screen.
    Originally, this element serves for need of flipping the 3D text of dimension presentations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_Flipper self, gp_Ax2 theReferenceSystem) -> OpenGl_Flipper

        Construct rendering element to flip model-view matrix
        along the reference system to ensure up-Y, right-X orientation.
        @param theReferenceSystem [in] the reference coordinate system.

        :type theReferenceSystem: OCC.wrapper.gp.gp_Ax2

        """
        this = _OpenGl.new_OpenGl_Flipper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetOptions(self, *args):
        """
        SetOptions(OpenGl_Flipper self, Standard_Boolean const theIsEnabled)

        Set options for the element.
        @param theIsEnabled [in] flag indicates whether the flipper
        matrix modification should be set up or restored back.

        :type theIsEnabled: bool

        """
        return _OpenGl.OpenGl_Flipper_SetOptions(self, *args)


    def Render(self, *args):
        """
        Render(OpenGl_Flipper self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_Flipper_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_Flipper self, OpenGl_Context theCtx)

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_Flipper_Release(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_Flipper
OpenGl_Flipper_swigregister = _OpenGl.OpenGl_Flipper_swigregister
OpenGl_Flipper_swigregister(OpenGl_Flipper)

class Handle_OpenGl_Context(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Context self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Context_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Context self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Context self, OpenGl_Context thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Context_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Context self, Handle_OpenGl_Context theHandle) -> Handle_OpenGl_Context
        assign(Handle_OpenGl_Context self, OpenGl_Context thePtr) -> Handle_OpenGl_Context
        assign(Handle_OpenGl_Context self, Handle_OpenGl_Context theHandle) -> Handle_OpenGl_Context

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Context_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Context self) -> OpenGl_Context

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Context_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Context self) -> OpenGl_Context

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Context___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Context self) -> OpenGl_Context

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Context___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Context___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Context___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Context_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Context

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Context self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Context_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Context_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Context_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPowerOfTwo(self, *args):
        """
        GetPowerOfTwo(Handle_OpenGl_Context self, Standard_Integer const theNumber, Standard_Integer const theThreshold) -> Standard_Integer

        Function for getting power of to number larger or equal to input number.
        @param theNumber    number to 'power of two'
        @param theThreshold upper threshold
        @return power of two number

        :type theNumber: int
        :type theThreshold: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_GetPowerOfTwo(self, *args)


    def forcedRelease(self, *args):
        """
        forcedRelease(Handle_OpenGl_Context self)

        Release all resources, including shared ones


        """
        return _OpenGl.Handle_OpenGl_Context_forcedRelease(self, *args)


    def Share(self, *args):
        """
        Share(Handle_OpenGl_Context self, Handle_OpenGl_Context theShareCtx)

        Share GL context resources.
        theShareCtx - handle to context to retrieve handles to shared resources.

        :type theShareCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Context_Share(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_Context self, Standard_Boolean const theIsCoreProfile) -> Standard_Boolean
        Init(Handle_OpenGl_Context self, Aspect_Handle const theWindow, Aspect_Handle const theWindowDC, Aspect_RenderingContext const theGContext, Standard_Boolean const theIsCoreProfile) -> Standard_Boolean

        Initialize class from specified window and rendering context. Method should be called only once.
        @return false if OpenGL context can not be bound to specified window

        :type theWindow: OCC.wrapper.Aspect.Aspect_Handle
        :type theWindowDC: OCC.wrapper.Aspect.Aspect_Handle
        :type theGContext: OCC.wrapper.Aspect.Aspect_RenderingContext
        :type theIsCoreProfile: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_Init(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_Context self) -> Standard_Boolean

        @return true if this context is valid (has been initialized)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsValid(self, *args)


    def ReadGlVersion(self, *args):
        """
        ReadGlVersion(Handle_OpenGl_Context self)

        Read OpenGL version information from active context.

        :type theGlVerMajor: int
        :type theGlVerMinor: int

        """
        return _OpenGl.Handle_OpenGl_Context_ReadGlVersion(self, *args)


    def CheckExtension(self, *args):
        """
        CheckExtension(Handle_OpenGl_Context self, char const * theExtName) -> Standard_Boolean
        CheckExtension(Handle_OpenGl_Context self, char const * theExtString, char const * theExtName) -> Standard_Boolean

        Check if theExtName extension is in extensions string.

        :type theExtString: const char *
        :type theExtName: const char *
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_CheckExtension(self, *args)


    def IsGlGreaterEqual(self, *args):
        """
        IsGlGreaterEqual(Handle_OpenGl_Context self, Standard_Integer const theVerMajor, Standard_Integer const theVerMinor) -> Standard_Boolean

        @return true if detected GL version is greater or equal to requested one.

        :type theVerMajor: int
        :type theVerMinor: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsGlGreaterEqual(self, *args)


    def VersionMajor(self, *args):
        """
        VersionMajor(Handle_OpenGl_Context self) -> Standard_Integer

        Return cached GL version major number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_VersionMajor(self, *args)


    def VersionMinor(self, *args):
        """
        VersionMinor(Handle_OpenGl_Context self) -> Standard_Integer

        Return cached GL version minor number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_VersionMinor(self, *args)


    def Functions(self, *args):
        """
        Functions(Handle_OpenGl_Context self) -> OpenGl_GlFunctions const *

        Access entire map of loaded OpenGL functions.

        :rtype: OCC.wrapper.OpenGl.OpenGl_GlFunctions

        """
        return _OpenGl.Handle_OpenGl_Context_Functions(self, *args)


    def ResetErrors(self, *args):
        """
        ResetErrors(Handle_OpenGl_Context self, bool const theToPrintErrors=False) -> bool

        Clean up errors stack for this GL context (glGetError() in loop).
        @return true if some error has been cleared

        :type theToPrintErrors: const bool
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_ResetErrors(self, *args)


    def IsCurrent(self, *args):
        """
        IsCurrent(Handle_OpenGl_Context self) -> Standard_Boolean

        This method uses system-dependent API to retrieve information
        about GL context bound to the current thread.
        @return true if current thread is bound to this GL context

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsCurrent(self, *args)


    def MakeCurrent(self, *args):
        """
        MakeCurrent(Handle_OpenGl_Context self) -> Standard_Boolean

        Activates current context.
        Class should be initialized with appropriate info.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_MakeCurrent(self, *args)


    def SwapBuffers(self, *args):
        """
        SwapBuffers(Handle_OpenGl_Context self)

        Swap front/back buffers for this GL context (should be activated before!).


        """
        return _OpenGl.Handle_OpenGl_Context_SwapBuffers(self, *args)


    def SetSwapInterval(self, *args):
        """
        SetSwapInterval(Handle_OpenGl_Context self, Standard_Integer const theInterval) -> Standard_Boolean

        Setup swap interval (VSync).

        :type theInterval: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_SetSwapInterval(self, *args)


    def IsRender(self, *args):
        """
        IsRender(Handle_OpenGl_Context self) -> Standard_Boolean

        Return true if active mode is GL_RENDER (cached state)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsRender(self, *args)


    def IsFeedback(self, *args):
        """
        IsFeedback(Handle_OpenGl_Context self) -> Standard_Boolean

        Return true if active mode is GL_FEEDBACK (cached state)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsFeedback(self, *args)


    def AvailableMemory(self, *args):
        """
        AvailableMemory(Handle_OpenGl_Context self) -> Standard_Size

        This function retrieves information from GL about free GPU memory that is:
        - OS-dependent. On some OS it is per-process and on others - for entire system.
        - Vendor-dependent. Currently available only on NVIDIA and AMD/ATi drivers only.
        - Numbers meaning may vary.
        You should use this info only for diagnostics purposes.
        @return free GPU dedicated memory in bytes.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Context_AvailableMemory(self, *args)


    def MemoryInfo(self, *args):
        """
        MemoryInfo(Handle_OpenGl_Context self) -> TCollection_AsciiString
        MemoryInfo(Handle_OpenGl_Context self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict)

        This function retrieves information from GL about GPU memory.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString

        """
        return _OpenGl.Handle_OpenGl_Context_MemoryInfo(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(Handle_OpenGl_Context self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with OpenGL info.
        Should be called with bound context.

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _OpenGl.Handle_OpenGl_Context_DiagnosticInformation(self, *args)


    def GetResource(self, *args):
        """
        Access shared resource by its name.
        @param  theKey - unique identifier;
        @return handle to shared resource or NULL.

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Resource

        """
        res = _OpenGl.Handle_OpenGl_Context_GetResource(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShareResource(self, *args):
        """
        ShareResource(Handle_OpenGl_Context self, TCollection_AsciiString theKey, Handle_OpenGl_Resource theResource) -> Standard_Boolean

        Register shared resource.
        Notice that after registration caller shouldn't release it by himself -
        it will be automatically released on context destruction.
        @param theKey      - unique identifier, shouldn't be empty;
        @param theResource - new resource to register, shouldn't be NULL.

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theResource: OCC.wrapper.OpenGl.Handle_OpenGl_Resource
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_ShareResource(self, *args)


    def ReleaseResource(self, *args):
        """
        ReleaseResource(Handle_OpenGl_Context self, TCollection_AsciiString theKey, Standard_Boolean const theToDelay)

        Release shared resource.
        If there are more than one reference to this resource
        (also used by some other existing object) then call will be ignored.
        This means that current object itself should nullify handle before this call.
        Notice that this is unrecommended operation at all and should be used
        only in case of fat resources to release memory for other needs.
        @param theKey     unique identifier
        @param theToDelay postpone release until next redraw call

        :type theKey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theToDelay: bool

        """
        return _OpenGl.Handle_OpenGl_Context_ReleaseResource(self, *args)


    def ReleaseDelayed(self, *args):
        """
        ReleaseDelayed(Handle_OpenGl_Context self)

        Clean up the delayed release queue.


        """
        return _OpenGl.Handle_OpenGl_Context_ReleaseDelayed(self, *args)


    def SharedResources(self, *args):
        """
        Return map of shared resources.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ResourcesMap

        """
        res = _OpenGl.Handle_OpenGl_Context_SharedResources(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeClipping(self, *args):
        """
        ChangeClipping(Handle_OpenGl_Context self) -> OpenGl_Clipping

        @return tool for management of clippings within this context.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Clipping

        """
        return _OpenGl.Handle_OpenGl_Context_ChangeClipping(self, *args)


    def Clipping(self, *args):
        """
        @return tool for management of clippings within this context.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Clipping

        """
        res = _OpenGl.Handle_OpenGl_Context_Clipping(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShaderManager(self, *args):
        """
        @return tool for management of shader programs within this context.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderManager

        """
        res = _OpenGl.Handle_OpenGl_Context_ShaderManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextureWrapClamp(self, *args):
        """
        TextureWrapClamp(Handle_OpenGl_Context self) -> Standard_Integer

        Either GL_CLAMP_TO_EDGE (1.2+) or GL_CLAMP (1.1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_TextureWrapClamp(self, *args)


    def MaxDegreeOfAnisotropy(self, *args):
        """
        MaxDegreeOfAnisotropy(Handle_OpenGl_Context self) -> Standard_Integer

        @return maximum degree of anisotropy texture filter

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxDegreeOfAnisotropy(self, *args)


    def MaxTextureSize(self, *args):
        """
        MaxTextureSize(Handle_OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_TEXTURE_SIZE

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxTextureSize(self, *args)


    def MaxCombinedTextureUnits(self, *args):
        """
        MaxCombinedTextureUnits(Handle_OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxCombinedTextureUnits(self, *args)


    def MaxMsaaSamples(self, *args):
        """
        MaxMsaaSamples(Handle_OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_SAMPLES

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxMsaaSamples(self, *args)


    def MaxDrawBuffers(self, *args):
        """
        MaxDrawBuffers(Handle_OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_DRAW_BUFFERS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxDrawBuffers(self, *args)


    def MaxColorAttachments(self, *args):
        """
        MaxColorAttachments(Handle_OpenGl_Context self) -> Standard_Integer

        @return value for GL_MAX_COLOR_ATTACHMENTS

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxColorAttachments(self, *args)


    def MaxClipPlanes(self, *args):
        """
        MaxClipPlanes(Handle_OpenGl_Context self) -> Standard_Integer

        Get maximum number of clip planes supported by OpenGl.
        This value is implementation dependent. At least 6
        planes should be supported by OpenGl (see specs).
        @return value for GL_MAX_CLIP_PLANES

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_MaxClipPlanes(self, *args)


    def HasRayTracing(self, *args):
        """
        HasRayTracing(Handle_OpenGl_Context self) -> Standard_Boolean

        @return TRUE if ray tracing mode is supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_HasRayTracing(self, *args)


    def HasRayTracingTextures(self, *args):
        """
        HasRayTracingTextures(Handle_OpenGl_Context self) -> Standard_Boolean

        @return TRUE if textures in ray tracing mode are supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_HasRayTracingTextures(self, *args)


    def HasRayTracingAdaptiveSampling(self, *args):
        """
        HasRayTracingAdaptiveSampling(Handle_OpenGl_Context self) -> Standard_Boolean

        @return TRUE if adaptive screen sampling in ray tracing mode is supported

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_HasRayTracingAdaptiveSampling(self, *args)


    def ToUseVbo(self, *args):
        """
        ToUseVbo(Handle_OpenGl_Context self) -> bool

        Returns true if VBO is supported and permitted.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_ToUseVbo(self, *args)


    def IsGlNormalizeEnabled(self, *args):
        """
        IsGlNormalizeEnabled(Handle_OpenGl_Context self) -> Standard_Boolean

        @return cached state of GL_NORMALIZE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsGlNormalizeEnabled(self, *args)


    def SetGlNormalizeEnabled(self, *args):
        """
        SetGlNormalizeEnabled(Handle_OpenGl_Context self, Standard_Boolean isEnabled) -> Standard_Boolean

        Sets GL_NORMALIZE enabled or disabled.
        @return old value of the flag

        :type isEnabled: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_SetGlNormalizeEnabled(self, *args)


    def PolygonMode(self, *args):
        """
        PolygonMode(Handle_OpenGl_Context self) -> Standard_Integer

        @return cached state of polygon rasterization mode (glPolygonMode()).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_PolygonMode(self, *args)


    def SetPolygonMode(self, *args):
        """
        SetPolygonMode(Handle_OpenGl_Context self, Standard_Integer const theMode) -> Standard_Integer

        Sets polygon rasterization mode (glPolygonMode() function).
        @return old value of the rasterization mode.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_SetPolygonMode(self, *args)


    def IsPolygonHatchEnabled(self, *args):
        """
        IsPolygonHatchEnabled(Handle_OpenGl_Context self) -> bool

        @return cached enabled state of polygon hatching rasterization.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_IsPolygonHatchEnabled(self, *args)


    def SetPolygonHatchEnabled(self, *args):
        """
        SetPolygonHatchEnabled(Handle_OpenGl_Context self, bool const theIsEnabled) -> bool

        Sets enabled state of polygon hatching rasterization
        without affecting currently selected hatching pattern.
        @return previous state of polygon hatching mode.

        :type theIsEnabled: const bool
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_SetPolygonHatchEnabled(self, *args)


    def PolygonHatchStyle(self, *args):
        """
        PolygonHatchStyle(Handle_OpenGl_Context self) -> Standard_Integer

        @return cached state of polygon hatch type.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_PolygonHatchStyle(self, *args)


    def SetPolygonHatchStyle(self, *args):
        """
        SetPolygonHatchStyle(Handle_OpenGl_Context self, Handle_Graphic3d_HatchStyle theStyle) -> Standard_Integer

        Sets polygon hatch pattern.
        Zero-index value is a default alias for solid filling.
        @param the type of hatch supported by base implementation of
        OpenGl_LineAttributes (Aspect_HatchStyle) or the type supported by custom
        implementation derived from OpenGl_LineAttributes class.
        @return old type of hatch.

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_HatchStyle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_SetPolygonHatchStyle(self, *args)


    def SetPolygonOffset(self, *args):
        """
        SetPolygonOffset(Handle_OpenGl_Context self, Graphic3d_PolygonOffset const & theOffset)

        Sets and applies current polygon offset.

        :type theOffset: OCC.wrapper.Graphic3d.Graphic3d_PolygonOffset

        """
        return _OpenGl.Handle_OpenGl_Context_SetPolygonOffset(self, *args)


    def PolygonOffset(self, *args):
        """
        Returns currently applied polygon offset parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_PolygonOffset

        """
        res = _OpenGl.Handle_OpenGl_Context_PolygonOffset(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ApplyModelWorldMatrix(self, *args):
        """
        ApplyModelWorldMatrix(Handle_OpenGl_Context self)

        Applies matrix stored in ModelWorldState to OpenGl.


        """
        return _OpenGl.Handle_OpenGl_Context_ApplyModelWorldMatrix(self, *args)


    def ApplyWorldViewMatrix(self, *args):
        """
        ApplyWorldViewMatrix(Handle_OpenGl_Context self)

        Applies matrix stored in WorldViewState to OpenGl.


        """
        return _OpenGl.Handle_OpenGl_Context_ApplyWorldViewMatrix(self, *args)


    def ApplyModelViewMatrix(self, *args):
        """
        ApplyModelViewMatrix(Handle_OpenGl_Context self)

        Applies combination of matrices stored in ModelWorldState and WorldViewState to OpenGl.


        """
        return _OpenGl.Handle_OpenGl_Context_ApplyModelViewMatrix(self, *args)


    def ApplyProjectionMatrix(self, *args):
        """
        ApplyProjectionMatrix(Handle_OpenGl_Context self)

        Applies matrix stored in ProjectionState to OpenGl.


        """
        return _OpenGl.Handle_OpenGl_Context_ApplyProjectionMatrix(self, *args)


    def Messenger(self, *args):
        """
        @return messenger instance

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        res = _OpenGl.Handle_OpenGl_Context_Messenger(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PushMessage(self, *args):
        """
        PushMessage(Handle_OpenGl_Context self, unsigned int const theSource, unsigned int const theType, unsigned int const theId, unsigned int const theSeverity, TCollection_ExtendedString theMessage)

        Callback for GL_ARB_debug_output extension
        @param theSource   message source   within GL_DEBUG_SOURCE_   enumeration
        @param theType     message type     within GL_DEBUG_TYPE_     enumeration
        @param theId       message ID       within source
        @param theSeverity message severity within GL_DEBUG_SEVERITY_ enumeration
        @param theMessage  the message itself

        :type theSource: const unsigned int
        :type theType: const unsigned int
        :type theId: const unsigned int
        :type theSeverity: const unsigned int
        :type theMessage: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _OpenGl.Handle_OpenGl_Context_PushMessage(self, *args)


    def ExcludeMessage(self, *args):
        """
        ExcludeMessage(Handle_OpenGl_Context self, unsigned int const theSource, unsigned int const theId) -> Standard_Boolean

        Adds a filter for messages with theId and theSource (GL_DEBUG_SOURCE_)

        :type theSource: const unsigned int
        :type theId: const unsigned int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_ExcludeMessage(self, *args)


    def IncludeMessage(self, *args):
        """
        IncludeMessage(Handle_OpenGl_Context self, unsigned int const theSource, unsigned int const theId) -> Standard_Boolean

        Removes a filter for messages with theId and theSource (GL_DEBUG_SOURCE_)

        :type theSource: const unsigned int
        :type theId: const unsigned int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IncludeMessage(self, *args)


    def HasStereoBuffers(self, *args):
        """
        HasStereoBuffers(Handle_OpenGl_Context self) -> Standard_Boolean

        @return true if OpenGl context supports left and
        right rendering buffers.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_HasStereoBuffers(self, *args)


    def FrameStats(self, *args):
        """
        Return structure holding frame statistics.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameStats

        """
        res = _OpenGl.Handle_OpenGl_Context_FrameStats(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Viewport(self, *args):
        """
        Viewport(Handle_OpenGl_Context self) -> Standard_Integer const *

        Return cached viewport definition (x, y, width, height).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_Viewport(self, *args)


    def ResizeViewport(self, *args):
        """
        ResizeViewport(Handle_OpenGl_Context self, Standard_Integer const * theRect)

        Resize the viewport (alias for glViewport).
        @param theRect viewport definition (x, y, width, height)

        :type theRect: const Standard_Integer [4]

        """
        return _OpenGl.Handle_OpenGl_Context_ResizeViewport(self, *args)


    def VirtualViewport(self, *args):
        """
        VirtualViewport(Handle_OpenGl_Context self) -> Standard_Integer const *

        Return virtual viewport definition (x, y, width, height).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_VirtualViewport(self, *args)


    def ReadBuffer(self, *args):
        """
        ReadBuffer(Handle_OpenGl_Context self) -> Standard_Integer

        Return active read buffer.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_ReadBuffer(self, *args)


    def SetReadBuffer(self, *args):
        """
        SetReadBuffer(Handle_OpenGl_Context self, Standard_Integer const theReadBuffer)

        Switch read buffer, wrapper for ::glReadBuffer().

        :type theReadBuffer: int

        """
        return _OpenGl.Handle_OpenGl_Context_SetReadBuffer(self, *args)


    def DrawBuffer(self, *args):
        """
        DrawBuffer(Handle_OpenGl_Context self, Standard_Integer const theIndex=0) -> Standard_Integer

        Return active draw buffer attached to a render target referred by index (layout location).

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_DrawBuffer(self, *args)


    def SetDrawBuffer(self, *args):
        """
        SetDrawBuffer(Handle_OpenGl_Context self, Standard_Integer const theDrawBuffer)

        Switch draw buffer, wrapper for ::glDrawBuffer().

        :type theDrawBuffer: int

        """
        return _OpenGl.Handle_OpenGl_Context_SetDrawBuffer(self, *args)


    def SetDrawBuffers(self, *args):
        """
        SetDrawBuffers(Handle_OpenGl_Context self, Standard_Integer const theNb, Standard_Integer const * theDrawBuffers)

        Switch draw buffer, wrapper for ::glDrawBuffers (GLsizei, const GLenum*).

        :type theNb: int
        :type theDrawBuffers: int

        """
        return _OpenGl.Handle_OpenGl_Context_SetDrawBuffers(self, *args)


    def SetReadDrawBuffer(self, *args):
        """
        SetReadDrawBuffer(Handle_OpenGl_Context self, Standard_Integer const theBuffer)

        Switch read/draw buffers.

        :type theBuffer: int

        """
        return _OpenGl.Handle_OpenGl_Context_SetReadDrawBuffer(self, *args)


    def ColorMask(self, *args):
        """
        ColorMask(Handle_OpenGl_Context self) -> bool

        Return cached flag indicating writing into color buffer is enabled or disabled (glColorMask).

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_ColorMask(self, *args)


    def SetColorMask(self, *args):
        """
        SetColorMask(Handle_OpenGl_Context self, bool theToWriteColor) -> bool

        Enable/disable writing into color buffer (wrapper for glColorMask).

        :type theToWriteColor: bool
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_SetColorMask(self, *args)


    def SampleAlphaToCoverage(self, *args):
        """
        SampleAlphaToCoverage(Handle_OpenGl_Context self) -> bool

        Return GL_SAMPLE_ALPHA_TO_COVERAGE state.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_SampleAlphaToCoverage(self, *args)


    def SetSampleAlphaToCoverage(self, *args):
        """
        SetSampleAlphaToCoverage(Handle_OpenGl_Context self, bool theToEnable) -> bool

        Enable/disable GL_SAMPLE_ALPHA_TO_COVERAGE.

        :type theToEnable: bool
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_SetSampleAlphaToCoverage(self, *args)


    def ToCullBackFaces(self, *args):
        """
        ToCullBackFaces(Handle_OpenGl_Context self) -> bool

        Return back face culling state.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Context_ToCullBackFaces(self, *args)


    def SetCullBackFaces(self, *args):
        """
        SetCullBackFaces(Handle_OpenGl_Context self, bool theToEnable)

        Enable or disable back face culling (glEnable (GL_CULL_FACE)).

        :type theToEnable: bool

        """
        return _OpenGl.Handle_OpenGl_Context_SetCullBackFaces(self, *args)


    def FetchState(self, *args):
        """
        FetchState(Handle_OpenGl_Context self)

        Fetch OpenGl context state. This class tracks value of several OpenGl
        state variables. Consulting the cached values is quicker than
        doing the same via OpenGl API. Call this method if any of the controlled
        OpenGl state variables has a possibility of being out-of-date.


        """
        return _OpenGl.Handle_OpenGl_Context_FetchState(self, *args)


    def ActiveTextures(self, *args):
        """
        @return active textures

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.Handle_OpenGl_Context_ActiveTextures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindTextures(self, *args):
        """
        BindTextures(Handle_OpenGl_Context self, Handle_OpenGl_TextureSet theTextures) -> Handle_OpenGl_TextureSet

        Bind specified texture set to current context,
        or unbind previous one when NULL specified.

        :type theTextures: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        return _OpenGl.Handle_OpenGl_Context_BindTextures(self, *args)


    def ActiveProgram(self, *args):
        """
        @return active GLSL program

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.Handle_OpenGl_Context_ActiveProgram(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindProgram(self, *args):
        """
        BindProgram(Handle_OpenGl_Context self, Handle_OpenGl_ShaderProgram theProgram) -> Standard_Boolean

        Bind specified program to current context,
        or unbind previous one when NULL specified.
        @return true if some program is bound to context

        :type theProgram: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_BindProgram(self, *args)


    def SetShadingMaterial(self, *args):
        """
        SetShadingMaterial(Handle_OpenGl_Context self, OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight)

        Setup current shading material.

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :type theHighlight: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        return _OpenGl.Handle_OpenGl_Context_SetShadingMaterial(self, *args)


    def CheckIsTransparent(self, *args):
        """
        CheckIsTransparent(Handle_OpenGl_Context self, OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean
        CheckIsTransparent(Handle_OpenGl_Context self, OpenGl_AspectFace theAspect, Handle_Graphic3d_PresentationAttributes theHighlight) -> Standard_Boolean

        Checks if transparency is required for the given aspect and highlight style.

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :type theHighlight: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_CheckIsTransparent(self, *args)


    def SetColor4fv(self, *args):
        """
        SetColor4fv(Handle_OpenGl_Context self, OpenGl_Vec4 const & theColor)

        Setup current color.

        :type theColor: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        return _OpenGl.Handle_OpenGl_Context_SetColor4fv(self, *args)


    def SetTypeOfLine(self, *args):
        """
        SetTypeOfLine(Handle_OpenGl_Context self, Aspect_TypeOfLine const theType, Standard_ShortReal const theFactor=1.0)

        Setup type of line.

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type theFactor: float

        """
        return _OpenGl.Handle_OpenGl_Context_SetTypeOfLine(self, *args)


    def SetLineWidth(self, *args):
        """
        SetLineWidth(Handle_OpenGl_Context self, Standard_ShortReal const theWidth)

        Setup width of line.

        :type theWidth: float

        """
        return _OpenGl.Handle_OpenGl_Context_SetLineWidth(self, *args)


    def SetPointSize(self, *args):
        """
        SetPointSize(Handle_OpenGl_Context self, Standard_ShortReal const theSize)

        Setup point size.

        :type theSize: float

        """
        return _OpenGl.Handle_OpenGl_Context_SetPointSize(self, *args)


    def SetPointSpriteOrigin(self, *args):
        """
        SetPointSpriteOrigin(Handle_OpenGl_Context self)

        Setup point sprite origin using GL_POINT_SPRITE_COORD_ORIGIN state:
        - GL_UPPER_LEFT when GLSL program is active;
        flipping should be handled in GLSL program for compatibility with OpenGL ES
        - GL_LOWER_LEFT for FFP


        """
        return _OpenGl.Handle_OpenGl_Context_SetPointSpriteOrigin(self, *args)


    def SetTextureMatrix(self, *args):
        """
        SetTextureMatrix(Handle_OpenGl_Context self, Handle_Graphic3d_TextureParams theParams)

        Setup texture matrix to active GLSL program or to FFP global state using glMatrixMode (GL_TEXTURE).

        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        return _OpenGl.Handle_OpenGl_Context_SetTextureMatrix(self, *args)


    def BindDefaultVao(self, *args):
        """
        BindDefaultVao(Handle_OpenGl_Context self)

        Bind default Vertex Array Object


        """
        return _OpenGl.Handle_OpenGl_Context_BindDefaultVao(self, *args)


    def DefaultFrameBuffer(self, *args):
        """
        Default Frame Buffer Object.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        res = _OpenGl.Handle_OpenGl_Context_DefaultFrameBuffer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultFrameBuffer(self, *args):
        """
        SetDefaultFrameBuffer(Handle_OpenGl_Context self, Handle_OpenGl_FrameBuffer theFbo) -> Handle_OpenGl_FrameBuffer

        Setup new Default Frame Buffer Object and return previously set.
        This call doesn't change Active FBO!

        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.Handle_OpenGl_Context_SetDefaultFrameBuffer(self, *args)


    def IsDebugContext(self, *args):
        """
        IsDebugContext(Handle_OpenGl_Context self) -> Standard_Boolean

        Return debug context initialization state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsDebugContext(self, *args)


    def EnableFeatures(self, *args):
        """EnableFeatures(Handle_OpenGl_Context self)"""
        return _OpenGl.Handle_OpenGl_Context_EnableFeatures(self, *args)


    def DisableFeatures(self, *args):
        """DisableFeatures(Handle_OpenGl_Context self)"""
        return _OpenGl.Handle_OpenGl_Context_DisableFeatures(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_OpenGl_Context self) -> unsigned int

        Return resolution for rendering text.

        :rtype: unsigned int

        """
        return _OpenGl.Handle_OpenGl_Context_Resolution(self, *args)


    def ResolutionRatio(self, *args):
        """
        ResolutionRatio(Handle_OpenGl_Context self) -> Standard_ShortReal

        Resolution scale factor (rendered resolution to standard resolution).
        This scaling factor for parameters like text size to be properly displayed on device (screen / printer).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.Handle_OpenGl_Context_ResolutionRatio(self, *args)


    def RenderScale(self, *args):
        """
        RenderScale(Handle_OpenGl_Context self) -> Standard_ShortReal

        Rendering scale factor (rendering viewport height to real window buffer height).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.Handle_OpenGl_Context_RenderScale(self, *args)


    def HasRenderScale(self, *args):
        """
        HasRenderScale(Handle_OpenGl_Context self) -> Standard_Boolean

        Return TRUE if rendering scale factor is not 1.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_HasRenderScale(self, *args)


    def RenderScaleInv(self, *args):
        """
        RenderScaleInv(Handle_OpenGl_Context self) -> Standard_ShortReal

        Rendering scale factor (inverted value).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.Handle_OpenGl_Context_RenderScaleInv(self, *args)


    def SetResolution(self, *args):
        """
        SetResolution(Handle_OpenGl_Context self, unsigned int theResolution, Standard_ShortReal theRatio, Standard_ShortReal theScale)

        Set resolution ratio.
        Note that this method rounds @theRatio to nearest integer.

        :type theResolution: unsigned int
        :type theRatio: float
        :type theScale: float

        """
        return _OpenGl.Handle_OpenGl_Context_SetResolution(self, *args)


    def SetResolutionRatio(self, *args):
        """
        SetResolutionRatio(Handle_OpenGl_Context self, Standard_ShortReal const theRatio)

        Set resolution ratio.
        Note that this method rounds @theRatio to nearest integer.

        :type theRatio: float

        """
        return _OpenGl.Handle_OpenGl_Context_SetResolutionRatio(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Context self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Context_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Context self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Context self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Context self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Context self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Context_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Context self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Context_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Context self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Context self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Context_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Context self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Context_DecrementRefCounter(self, *args)

Handle_OpenGl_Context_swigregister = _OpenGl.Handle_OpenGl_Context_swigregister
Handle_OpenGl_Context_swigregister(Handle_OpenGl_Context)

def Handle_OpenGl_Context_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Context_DownCast(thing)
Handle_OpenGl_Context_DownCast = _OpenGl.Handle_OpenGl_Context_DownCast

class Handle_OpenGl_CappingPlaneResource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_CappingPlaneResource self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_CappingPlaneResource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_CappingPlaneResource self, OpenGl_CappingPlaneResource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_CappingPlaneResource self, Handle_OpenGl_CappingPlaneResource theHandle) -> Handle_OpenGl_CappingPlaneResource
        assign(Handle_OpenGl_CappingPlaneResource self, OpenGl_CappingPlaneResource thePtr) -> Handle_OpenGl_CappingPlaneResource
        assign(Handle_OpenGl_CappingPlaneResource self, Handle_OpenGl_CappingPlaneResource theHandle) -> Handle_OpenGl_CappingPlaneResource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_CappingPlaneResource self) -> OpenGl_CappingPlaneResource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_CappingPlaneResource self) -> OpenGl_CappingPlaneResource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_CappingPlaneResource self) -> OpenGl_CappingPlaneResource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_CappingPlaneResource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_CappingPlaneResource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_CappingPlaneResource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_CappingPlaneResource_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_CappingPlaneResource

    def Update(self, *args):
        """
        Update(Handle_OpenGl_CappingPlaneResource self, Handle_OpenGl_Context theContext, Handle_Graphic3d_AspectFillArea3d theObjAspect)

        Update resource data in the passed context.
        @param theContext   [in] the context
        @param theObjAspect [in] object aspect

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theObjAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_Update(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_CappingPlaneResource self, OpenGl_Context theContext)

        Release associated OpenGl resources.
        @param theContext [in] the resource context.

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_CappingPlaneResource self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_EstimatedDataSize(self, *args)


    def Plane(self, *args):
        """
        Return parent clipping plane structure.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        res = _OpenGl.Handle_OpenGl_CappingPlaneResource_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AspectFace(self, *args):
        """
        AspectFace(Handle_OpenGl_CappingPlaneResource self) -> OpenGl_AspectFace

        @return aspect face for rendering capping surface.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_AspectFace(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_OpenGl_CappingPlaneResource self) -> OpenGl_Matrix const *

        @return evaluated orientation matrix to transform infinite plane.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_Orientation(self, *args)


    def Primitives(self, *args):
        """
        @return primitive array of vertices to render infinite plane.

        :rtype: OCC.wrapper.OpenGl.OpenGl_PrimitiveArray

        """
        res = _OpenGl.Handle_OpenGl_CappingPlaneResource_Primitives(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_CappingPlaneResource self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_CappingPlaneResource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_CappingPlaneResource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_CappingPlaneResource self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_CappingPlaneResource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_CappingPlaneResource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_CappingPlaneResource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_CappingPlaneResource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_CappingPlaneResource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_CappingPlaneResource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_CappingPlaneResource self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_CappingPlaneResource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_CappingPlaneResource_DecrementRefCounter(self, *args)

Handle_OpenGl_CappingPlaneResource_swigregister = _OpenGl.Handle_OpenGl_CappingPlaneResource_swigregister
Handle_OpenGl_CappingPlaneResource_swigregister(Handle_OpenGl_CappingPlaneResource)

def Handle_OpenGl_CappingPlaneResource_DownCast(thing):
    return _OpenGl.Handle_OpenGl_CappingPlaneResource_DownCast(thing)
Handle_OpenGl_CappingPlaneResource_DownCast = _OpenGl.Handle_OpenGl_CappingPlaneResource_DownCast

class Handle_OpenGl_LineAttributes(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_LineAttributes self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_LineAttributes_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_LineAttributes self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_LineAttributes self, OpenGl_LineAttributes thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_LineAttributes self, Handle_OpenGl_LineAttributes theHandle) -> Handle_OpenGl_LineAttributes
        assign(Handle_OpenGl_LineAttributes self, OpenGl_LineAttributes thePtr) -> Handle_OpenGl_LineAttributes
        assign(Handle_OpenGl_LineAttributes self, Handle_OpenGl_LineAttributes theHandle) -> Handle_OpenGl_LineAttributes

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_LineAttributes self) -> OpenGl_LineAttributes

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_LineAttributes self) -> OpenGl_LineAttributes

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_LineAttributes___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_LineAttributes self) -> OpenGl_LineAttributes

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_LineAttributes___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_LineAttributes___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_LineAttributes___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_LineAttributes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_LineAttributes_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_LineAttributes

    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_LineAttributes self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_EstimatedDataSize(self, *args)


    def TypeOfHatch(self, *args):
        """
        TypeOfHatch(Handle_OpenGl_LineAttributes self) -> int

        Index of currently selected type of hatch.

        :rtype: int

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_TypeOfHatch(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_OpenGl_LineAttributes self) -> bool

        Current enabled state of the hatching rasterization.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_IsEnabled(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_LineAttributes self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_LineAttributes_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_LineAttributes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Release(self, *args):
        """
        Release(Handle_OpenGl_LineAttributes self, OpenGl_Context theGlCtx)

        Release GPU resources.
        Notice that implementation should be SAFE for several consecutive calls
        (thus should invalidate internal structures / ids to avoid multiple-free errors).
        @param theGlCtx - bound GL context, shouldn't be NULL.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_Release(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_LineAttributes self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_LineAttributes_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_LineAttributes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_LineAttributes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_LineAttributes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_LineAttributes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_LineAttributes self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_LineAttributes self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_LineAttributes self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_LineAttributes_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_LineAttributes self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_LineAttributes_DecrementRefCounter(self, *args)

Handle_OpenGl_LineAttributes_swigregister = _OpenGl.Handle_OpenGl_LineAttributes_swigregister
Handle_OpenGl_LineAttributes_swigregister(Handle_OpenGl_LineAttributes)

def Handle_OpenGl_LineAttributes_DownCast(thing):
    return _OpenGl.Handle_OpenGl_LineAttributes_DownCast(thing)
Handle_OpenGl_LineAttributes_DownCast = _OpenGl.Handle_OpenGl_LineAttributes_DownCast

class OpenGl_ClippingState(object):
    """Defines generic state of OCCT clipping state."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_ClippingState self) -> OpenGl_ClippingState

        Creates new clipping state.


        """
        this = _OpenGl.new_OpenGl_ClippingState(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Index(self, *args):
        """
        Index(OpenGl_ClippingState self) -> Standard_Size

        Returns current state index.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_ClippingState_Index(self, *args)


    def Update(self, *args):
        """
        Update(OpenGl_ClippingState self)

        Updates current state.


        """
        return _OpenGl.OpenGl_ClippingState_Update(self, *args)


    def Revert(self, *args):
        """
        Revert(OpenGl_ClippingState self)

        Reverts current state.


        """
        return _OpenGl.OpenGl_ClippingState_Revert(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_ClippingState
OpenGl_ClippingState_swigregister = _OpenGl.OpenGl_ClippingState_swigregister
OpenGl_ClippingState_swigregister(OpenGl_ClippingState)

class OpenGl_VariableSetterSelector(object):
    """Support tool for setting user-defined uniform variables."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
OpenGl_VariableSetterSelector_swigregister = _OpenGl.OpenGl_VariableSetterSelector_swigregister
OpenGl_VariableSetterSelector_swigregister(OpenGl_VariableSetterSelector)

class Handle_OpenGl_SetOfShaderPrograms(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_SetOfShaderPrograms self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_SetOfShaderPrograms self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_SetOfShaderPrograms self, OpenGl_SetOfShaderPrograms thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_SetOfShaderPrograms self, Handle_OpenGl_SetOfShaderPrograms theHandle) -> Handle_OpenGl_SetOfShaderPrograms
        assign(Handle_OpenGl_SetOfShaderPrograms self, OpenGl_SetOfShaderPrograms thePtr) -> Handle_OpenGl_SetOfShaderPrograms
        assign(Handle_OpenGl_SetOfShaderPrograms self, Handle_OpenGl_SetOfShaderPrograms theHandle) -> Handle_OpenGl_SetOfShaderPrograms

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_SetOfShaderPrograms self) -> OpenGl_SetOfShaderPrograms

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_SetOfShaderPrograms self) -> OpenGl_SetOfShaderPrograms

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_SetOfShaderPrograms self) -> OpenGl_SetOfShaderPrograms

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_SetOfShaderPrograms___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_SetOfShaderPrograms(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_SetOfShaderPrograms_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_SetOfShaderPrograms

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_SetOfShaderPrograms self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_SetOfShaderPrograms_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_SetOfShaderPrograms_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_OpenGl_SetOfShaderPrograms self, Graphic3d_TypeOfShadingModel theShadingModel, Standard_Integer theProgramBits) -> Handle_OpenGl_ShaderProgram

        Access program by index

        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theProgramBits: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_ChangeValue(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_SetOfShaderPrograms self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_SetOfShaderPrograms self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_SetOfShaderPrograms self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_SetOfShaderPrograms self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_SetOfShaderPrograms self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_SetOfShaderPrograms self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_SetOfShaderPrograms self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_SetOfShaderPrograms self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_SetOfShaderPrograms self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_DecrementRefCounter(self, *args)

Handle_OpenGl_SetOfShaderPrograms_swigregister = _OpenGl.Handle_OpenGl_SetOfShaderPrograms_swigregister
Handle_OpenGl_SetOfShaderPrograms_swigregister(Handle_OpenGl_SetOfShaderPrograms)

def Handle_OpenGl_SetOfShaderPrograms_DownCast(thing):
    return _OpenGl.Handle_OpenGl_SetOfShaderPrograms_DownCast(thing)
Handle_OpenGl_SetOfShaderPrograms_DownCast = _OpenGl.Handle_OpenGl_SetOfShaderPrograms_DownCast

class Handle_OpenGl_StructureShadow(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_StructureShadow self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_StructureShadow self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_StructureShadow self, OpenGl_StructureShadow thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_StructureShadow self, Handle_OpenGl_StructureShadow theHandle) -> Handle_OpenGl_StructureShadow
        assign(Handle_OpenGl_StructureShadow self, OpenGl_StructureShadow thePtr) -> Handle_OpenGl_StructureShadow
        assign(Handle_OpenGl_StructureShadow self, Handle_OpenGl_StructureShadow theHandle) -> Handle_OpenGl_StructureShadow

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_StructureShadow self) -> OpenGl_StructureShadow

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_StructureShadow self) -> OpenGl_StructureShadow

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_StructureShadow___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_StructureShadow self) -> OpenGl_StructureShadow

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_StructureShadow___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_StructureShadow___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_StructureShadow___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_StructureShadow(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_StructureShadow_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_StructureShadow

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_StructureShadow self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OnVisibilityChanged(self, *args):
        """
        OnVisibilityChanged(Handle_OpenGl_StructureShadow self)

        Setup structure graphic state


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_OnVisibilityChanged(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_OpenGl_StructureShadow self)
        Clear(Handle_OpenGl_StructureShadow self, Handle_OpenGl_Context theGlCtx)

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_Clear(self, *args)


    def Connect(self, *args):
        """
        Connect(Handle_OpenGl_StructureShadow self, Graphic3d_CStructure theStructure)

        Connect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_Connect(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(Handle_OpenGl_StructureShadow self, Graphic3d_CStructure theStructure)

        Disconnect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_Disconnect(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Handle_OpenGl_StructureShadow self, Handle_Geom_Transformation theTrsf)

        Synchronize structure transformation

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_SetTransformation(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_TransformPers theTrsfPers)

        Set transformation persistence.

        :type theTrsfPers: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_SetTransformPersistence(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_OpenGl_StructureShadow self, Graphic3d_ZLayerId const theLayerIndex)

        Set z layer ID to display the structure in specified layer

        :type theLayerIndex: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_SetZLayer(self, *args)


    def GraphicHighlight(self, *args):
        """
        GraphicHighlight(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_PresentationAttributes theStyle, Handle_Graphic3d_Structure theStruct)

        Highlights structure according to the given style and updates corresponding class fields
        (highlight status and style)

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_GraphicHighlight(self, *args)


    def GraphicUnhighlight(self, *args):
        """
        GraphicUnhighlight(Handle_OpenGl_StructureShadow self)

        Unighlights structure and updates corresponding class fields (highlight status and style)


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_GraphicUnhighlight(self, *args)


    def ShadowLink(self, *args):
        """
        ShadowLink(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_StructureManager theManager) -> Handle_Graphic3d_CStructure

        Create shadow link to this structure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ShadowLink(self, *args)


    def NewGroup(self, *args):
        """
        NewGroup(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_Structure theStruct) -> Handle_Graphic3d_Group

        Create new group within this structure

        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_NewGroup(self, *args)


    def RemoveGroup(self, *args):
        """
        RemoveGroup(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_Group theGroup)

        Remove group from this structure

        :type theGroup: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_RemoveGroup(self, *args)


    def GlDriver(self, *args):
        """
        GlDriver(Handle_OpenGl_StructureShadow self) -> OpenGl_GraphicDriver

        Access graphic driver

        :rtype: OCC.wrapper.OpenGl.OpenGl_GraphicDriver

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_GlDriver(self, *args)


    def SetCulled(self, *args):
        """
        SetCulled(Handle_OpenGl_StructureShadow self, Standard_Boolean theIsCulled)

        Marks structure as culled/not culled - note that IsAlwaysRendered() is ignored here!

        :type theIsCulled: bool

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_SetCulled(self, *args)


    def MarkAsNotCulled(self, *args):
        """
        MarkAsNotCulled(Handle_OpenGl_StructureShadow self)

        Marks structure as overlapping the current view volume one.
        The method is called during traverse of BVH tree.


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_MarkAsNotCulled(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(Handle_OpenGl_StructureShadow self) -> Standard_Boolean

        Returns Standard_False if the structure hits the current view volume, otherwise
        returns Standard_True. The default value for all structures before each traverse
        of BVH tree is Standard_True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsCulled(self, *args)


    def IsAlwaysRendered(self, *args):
        """
        IsAlwaysRendered(Handle_OpenGl_StructureShadow self) -> Standard_Boolean

        Checks if the structure should be included into BVH tree or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsAlwaysRendered(self, *args)


    def ReleaseGlResources(self, *args):
        """
        ReleaseGlResources(Handle_OpenGl_StructureShadow self, Handle_OpenGl_Context theGlCtx)

        This method releases GL resources without actual elements destruction.
        As result structure could be correctly destroyed layer without GL context
        (after last window was closed for example).

        Notice however that reusage of this structure after calling this method is incorrect
        and will lead to broken visualization due to loosed data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ReleaseGlResources(self, *args)


    def InstancedStructure(self, *args):
        """
        InstancedStructure(Handle_OpenGl_StructureShadow self) -> OpenGl_Structure

        Returns instanced OpenGL structure.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_InstancedStructure(self, *args)


    def ModificationState(self, *args):
        """
        ModificationState(Handle_OpenGl_StructureShadow self) -> Standard_Size

        Returns structure modification state (for ray-tracing).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ModificationState(self, *args)


    def ResetModificationState(self, *args):
        """
        ResetModificationState(Handle_OpenGl_StructureShadow self)

        Resets structure modification state (for ray-tracing).


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ResetModificationState(self, *args)


    def updateLayerTransformation(self, *args):
        """
        updateLayerTransformation(Handle_OpenGl_StructureShadow self)

        Update render transformation matrix.


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_updateLayerTransformation(self, *args)


    def GraphicDriver(self, *args):
        """
        @return graphic driver created this structure

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_GraphicDriver

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_GraphicDriver(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Groups(self, *args):
        """
        @return graphic groups

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfGroup

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_Groups(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformPersistence(self, *args):
        """
        Return transformation persistence.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClipPlanes(self, *args):
        """
        @return associated clip planes

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_OpenGl_StructureShadow self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Pass clip planes to the associated graphic driver structure

        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_SetClipPlanes(self, *args)


    def BoundingBox(self, *args):
        """
        @return bounding box of this presentation

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox3d

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBoundingBox(self, *args):
        """
        ChangeBoundingBox(Handle_OpenGl_StructureShadow self) -> BVH_Box_Standard_Real_

        @return bounding box of this presentation
        without transformation matrix applied

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox3d

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ChangeBoundingBox(self, *args)


    def IsVisible(self, *args):
        """
        IsVisible(Handle_OpenGl_StructureShadow self) -> bool
        IsVisible(Handle_OpenGl_StructureShadow self, Standard_Integer const theViewId) -> bool

        Return structure visibility considering both View Affinity and global visibility state.

        :type theViewId: int
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsVisible(self, *args)


    def ZLayer(self, *args):
        """
        ZLayer(Handle_OpenGl_StructureShadow self) -> Graphic3d_ZLayerId

        Get z layer ID

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_ZLayer(self, *args)


    def HighlightStyle(self, *args):
        """
        Returns valid handle to highlight style of the structure in case if
        highlight flag is set to true

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        res = _OpenGl.Handle_OpenGl_StructureShadow_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_StructureShadow self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_StructureShadow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_StructureShadow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_StructureShadow self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_StructureShadow self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_StructureShadow self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_StructureShadow self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_StructureShadow self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_StructureShadow_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_StructureShadow self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_StructureShadow_DecrementRefCounter(self, *args)

Handle_OpenGl_StructureShadow_swigregister = _OpenGl.Handle_OpenGl_StructureShadow_swigregister
Handle_OpenGl_StructureShadow_swigregister(Handle_OpenGl_StructureShadow)

def Handle_OpenGl_StructureShadow_DownCast(thing):
    return _OpenGl.Handle_OpenGl_StructureShadow_DownCast(thing)
Handle_OpenGl_StructureShadow_DownCast = _OpenGl.Handle_OpenGl_StructureShadow_DownCast

class OpenGl_TextBuilder(object):
    """This class generates primitive array required for rendering textured text using OpenGl_Font instance."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_TextBuilder self) -> OpenGl_TextBuilder

        Creates empty object.


        """
        this = _OpenGl.new_OpenGl_TextBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(OpenGl_TextBuilder self, Font_TextFormatter theFormatter, Handle_OpenGl_Context theContext, OpenGl_Font theFont, NCollection_Vector< GLuint > & theTextures, NCollection_Vector< opencascade::handle< OpenGl_VertexBuffer > > & theVertsPerTexture, NCollection_Vector< opencascade::handle< OpenGl_VertexBuffer > > & theTCrdsPerTexture)

        Creates texture quads for the given text.

        :type theFormatter: OCC.wrapper.Font.Font_TextFormatter
        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theFont: OCC.wrapper.OpenGl.OpenGl_Font
        :type theTextures: OCC.wrapper.OpenGl.NCollection_Vector_GLuint
        :type theVertsPerTexture: OCC.wrapper.OpenGl.NCollection_Vector_Handle_OpenGl_VertexBuffer
        :type theTCrdsPerTexture: OCC.wrapper.OpenGl.NCollection_Vector_Handle_OpenGl_VertexBuffer

        """
        return _OpenGl.OpenGl_TextBuilder_Perform(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_TextBuilder
OpenGl_TextBuilder_swigregister = _OpenGl.OpenGl_TextBuilder_swigregister
OpenGl_TextBuilder_swigregister(OpenGl_TextBuilder)

class Handle_OpenGl_Group(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Group self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Group_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Group self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Group_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Group self, OpenGl_Group thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Group_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Group self, Handle_OpenGl_Group theHandle) -> Handle_OpenGl_Group
        assign(Handle_OpenGl_Group self, OpenGl_Group thePtr) -> Handle_OpenGl_Group
        assign(Handle_OpenGl_Group self, Handle_OpenGl_Group theHandle) -> Handle_OpenGl_Group

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Group_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Group self) -> OpenGl_Group

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Group_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Group self) -> OpenGl_Group

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Group___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Group self) -> OpenGl_Group

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Group___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Group___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Group___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Group_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Group

    def Clear(self, *args):
        """
        Clear(Handle_OpenGl_Group self, Standard_Boolean const theToUpdateStructureMgr)

        :type theToUpdateStructureMgr: bool

        """
        return _OpenGl.Handle_OpenGl_Group_Clear(self, *args)


    def LineAspect(self, *args):
        """
        LineAspect(Handle_OpenGl_Group self) -> Handle_Graphic3d_AspectLine3d

        Return line aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        return _OpenGl.Handle_OpenGl_Group_LineAspect(self, *args)


    def SetGroupPrimitivesAspect(self, *args):
        """
        SetGroupPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspect)
        SetGroupPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectMarker3d theAspect)
        SetGroupPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectFillArea3d theAspect)
        SetGroupPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectText3d theAspect)

        Update text aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.Handle_OpenGl_Group_SetGroupPrimitivesAspect(self, *args)


    def SetPrimitivesAspect(self, *args):
        """
        SetPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspect)
        SetPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectMarker3d theAspect)
        SetPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectFillArea3d theAspect)
        SetPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectText3d theAspect)

        Append text aspect as an element.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.Handle_OpenGl_Group_SetPrimitivesAspect(self, *args)


    def MarkerAspect(self, *args):
        """
        MarkerAspect(Handle_OpenGl_Group self) -> Handle_Graphic3d_AspectMarker3d

        Return marker aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _OpenGl.Handle_OpenGl_Group_MarkerAspect(self, *args)


    def FillAreaAspect(self, *args):
        """
        FillAreaAspect(Handle_OpenGl_Group self) -> Handle_Graphic3d_AspectFillArea3d

        Return fill area aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.Handle_OpenGl_Group_FillAreaAspect(self, *args)


    def TextAspect(self, *args):
        """
        TextAspect(Handle_OpenGl_Group self) -> Handle_Graphic3d_AspectText3d

        Return marker aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.Handle_OpenGl_Group_TextAspect(self, *args)


    def AddPrimitiveArray(self, *args):
        """
        AddPrimitiveArray(Handle_OpenGl_Group self, Graphic3d_TypeOfPrimitiveArray const theType, Handle_Graphic3d_IndexBuffer theIndices, Handle_Graphic3d_Buffer theAttribs, Handle_Graphic3d_BoundBuffer theBounds, Standard_Boolean const theToEvalMinMax)

        Add primitive array element

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfPrimitiveArray
        :type theIndices: OCC.wrapper.Graphic3d.Handle_Graphic3d_IndexBuffer
        :type theAttribs: OCC.wrapper.Graphic3d.Handle_Graphic3d_Buffer
        :type theBounds: OCC.wrapper.Graphic3d.Handle_Graphic3d_BoundBuffer
        :type theToEvalMinMax: bool

        """
        return _OpenGl.Handle_OpenGl_Group_AddPrimitiveArray(self, *args)


    def Text(self, *args):
        """
        Text(Handle_OpenGl_Group self, Standard_CString const theTextUtf, Graphic3d_Vertex thePoint, Standard_Real const theHeight, Standard_Real const theAngle, Graphic3d_TextPath const theTp, Graphic3d_HorizontalTextAlignment const theHta, Graphic3d_VerticalTextAlignment const theVta, Standard_Boolean const theToEvalMinMax)
        Text(Handle_OpenGl_Group self, Standard_CString const theTextUtf, gp_Ax2 theOrientation, Standard_Real const theHeight, Standard_Real const theAngle, Graphic3d_TextPath const theTp, Graphic3d_HorizontalTextAlignment const theHTA, Graphic3d_VerticalTextAlignment const theVTA, Standard_Boolean const theToEvalMinMax, Standard_Boolean const theHasOwnAnchor)

        Add text element in 3D space.

        :type theTextUtf: OCC.wrapper.Standard.Standard_CString
        :type theOrientation: OCC.wrapper.gp.gp_Ax2
        :type theHeight: float
        :type theAngle: float
        :type theTp: OCC.wrapper.Graphic3d.Graphic3d_TextPath
        :type theHTA: OCC.wrapper.Graphic3d.Graphic3d_HorizontalTextAlignment
        :type theVTA: OCC.wrapper.Graphic3d.Graphic3d_VerticalTextAlignment
        :type theToEvalMinMax: bool
        :type theHasOwnAnchor: bool

        """
        return _OpenGl.Handle_OpenGl_Group_Text(self, *args)


    def SetFlippingOptions(self, *args):
        """
        SetFlippingOptions(Handle_OpenGl_Group self, Standard_Boolean const theIsEnabled, gp_Ax2 theRefPlane)

        Add flipping element

        :type theIsEnabled: bool
        :type theRefPlane: OCC.wrapper.gp.gp_Ax2

        """
        return _OpenGl.Handle_OpenGl_Group_SetFlippingOptions(self, *args)


    def SetStencilTestOptions(self, *args):
        """
        SetStencilTestOptions(Handle_OpenGl_Group self, Standard_Boolean const theIsEnabled)

        Add stencil test element

        :type theIsEnabled: bool

        """
        return _OpenGl.Handle_OpenGl_Group_SetStencilTestOptions(self, *args)


    def GlStruct(self, *args):
        """
        GlStruct(Handle_OpenGl_Group self) -> OpenGl_Structure

        :rtype: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.Handle_OpenGl_Group_GlStruct(self, *args)


    def AddElement(self, *args):
        """
        AddElement(Handle_OpenGl_Group self, OpenGl_Element * theElem)

        :type theElem: OCC.wrapper.OpenGl.OpenGl_Element

        """
        return _OpenGl.Handle_OpenGl_Group_AddElement(self, *args)


    def Render(self, *args):
        """
        Render(Handle_OpenGl_Group self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.Handle_OpenGl_Group_Render(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_Group self, Handle_OpenGl_Context theGlCtx)

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Group_Release(self, *args)


    def FirstNode(self, *args):
        """
        FirstNode(Handle_OpenGl_Group self) -> OpenGl_ElementNode const *

        Returns first OpenGL element node of the group.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ElementNode

        """
        return _OpenGl.Handle_OpenGl_Group_FirstNode(self, *args)


    def AspectFace(self, *args):
        """
        AspectFace(Handle_OpenGl_Group self) -> OpenGl_AspectFace

        Returns OpenGL face aspect.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.Handle_OpenGl_Group_AspectFace(self, *args)


    def IsRaytracable(self, *args):
        """
        IsRaytracable(Handle_OpenGl_Group self) -> Standard_Boolean

        Is the group ray-tracable (contains ray-tracable elements)?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsRaytracable(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Group self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Group_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Group_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Group_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(Handle_OpenGl_Group self)

        Supress the group <me> in the structure.
        Warning: No more graphic operations in <me> after this call.
        Modifies the current modelling transform persistence (pan, zoom or rotate)
        Get the current modelling transform persistence (pan, zoom or rotate)


        """
        return _OpenGl.Handle_OpenGl_Group_Remove(self, *args)


    def IsGroupPrimitivesAspectSet(self, *args):
        """
        IsGroupPrimitivesAspectSet(Handle_OpenGl_Group self, Graphic3d_GroupAspect const theAspect) -> Standard_Boolean

        Returns TRUE if aspect is set for the group.

        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_GroupAspect
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsGroupPrimitivesAspectSet(self, *args)


    def GroupPrimitivesAspect(self, *args):
        """
        GroupPrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspLine, Handle_Graphic3d_AspectText3d theAspText, Handle_Graphic3d_AspectMarker3d theAspMarker, Handle_Graphic3d_AspectFillArea3d theAspFill)

        Returns the context of all the primitives of the group.

        :type theAspLine: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d
        :type theAspText: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d
        :type theAspMarker: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d
        :type theAspFill: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.Handle_OpenGl_Group_GroupPrimitivesAspect(self, *args)


    def PrimitivesAspect(self, *args):
        """
        PrimitivesAspect(Handle_OpenGl_Group self, Handle_Graphic3d_AspectLine3d theAspLine, Handle_Graphic3d_AspectText3d theAspText, Handle_Graphic3d_AspectMarker3d theAspMarker, Handle_Graphic3d_AspectFillArea3d theAspFill)

        Returns the last inserted context in the group for each kind of primitives.

        :type theAspLine: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d
        :type theAspText: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d
        :type theAspMarker: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d
        :type theAspFill: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.Handle_OpenGl_Group_PrimitivesAspect(self, *args)


    def Marker(self, *args):
        """
        Marker(Handle_OpenGl_Group self, Graphic3d_Vertex thePoint, Standard_Boolean const theToEvalMinMax)

        Creates a primitive array with single marker using AddPrimitiveArray().

        :type thePoint: OCC.wrapper.Graphic3d.Graphic3d_Vertex
        :type theToEvalMinMax: bool

        """
        return _OpenGl.Handle_OpenGl_Group_Marker(self, *args)


    def ContainsFacet(self, *args):
        """
        ContainsFacet(Handle_OpenGl_Group self) -> bool

        Returns true if the group contains Polygons, Triangles or Quadrangles.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Group_ContainsFacet(self, *args)


    def IsDeleted(self, *args):
        """
        IsDeleted(Handle_OpenGl_Group self) -> Standard_Boolean

        Returns Standard_True if the group <me> is deleted.
        <me> is deleted after the call Remove (me) or the
        associated structure is deleted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsDeleted(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_OpenGl_Group self) -> Standard_Boolean

        Returns Standard_True if the group <me> is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsEmpty(self, *args)


    def MinMaxValues(self, *args):
        """
        MinMaxValues(Handle_OpenGl_Group self)

        Returns the coordinates of the boundary box of the group.

        :type theXMin: float
        :type theYMin: float
        :type theZMin: float
        :type theXMax: float
        :type theYMax: float
        :type theZMax: float

        """
        return _OpenGl.Handle_OpenGl_Group_MinMaxValues(self, *args)


    def SetMinMaxValues(self, *args):
        """
        SetMinMaxValues(Handle_OpenGl_Group self, Standard_Real const theXMin, Standard_Real const theYMin, Standard_Real const theZMin, Standard_Real const theXMax, Standard_Real const theYMax, Standard_Real const theZMax)

        Sets the coordinates of the boundary box of the group.

        :type theXMin: float
        :type theYMin: float
        :type theZMin: float
        :type theXMax: float
        :type theYMax: float
        :type theZMax: float

        """
        return _OpenGl.Handle_OpenGl_Group_SetMinMaxValues(self, *args)


    def BoundingBox(self, *args):
        """
        Returns boundary box of the group <me> without transformation applied,

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox4f

        """
        res = _OpenGl.Handle_OpenGl_Group_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBoundingBox(self, *args):
        """
        ChangeBoundingBox(Handle_OpenGl_Group self) -> BVH_Box_Standard_ShortReal_

        Returns non-const boundary box of the group <me> without transformation applied,

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox4f

        """
        return _OpenGl.Handle_OpenGl_Group_ChangeBoundingBox(self, *args)


    def Structure(self, *args):
        """
        Structure(Handle_OpenGl_Group self) -> Handle_Graphic3d_Structure

        Returns the structure containing the group <me>.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        return _OpenGl.Handle_OpenGl_Group_Structure(self, *args)


    def SetClosed(self, *args):
        """
        SetClosed(Handle_OpenGl_Group self, bool const theIsClosed)

        Changes property shown that primitive arrays within this group form closed volume (do no contain open shells).

        :type theIsClosed: const bool

        """
        return _OpenGl.Handle_OpenGl_Group_SetClosed(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_OpenGl_Group self) -> bool

        Return true if primitive arrays within this graphic group form closed volume (do no contain open shells).

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Group_IsClosed(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Group self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Group_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Group self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Group self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Group_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Group self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Group_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Group self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Group_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Group self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Group_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Group self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Group_DecrementRefCounter(self, *args)

Handle_OpenGl_Group_swigregister = _OpenGl.Handle_OpenGl_Group_swigregister
Handle_OpenGl_Group_swigregister(Handle_OpenGl_Group)

def Handle_OpenGl_Group_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Group_DownCast(thing)
Handle_OpenGl_Group_DownCast = _OpenGl.Handle_OpenGl_Group_DownCast


try:
	Graphic3d_BndBox3d = BVH_Box_Standard_Real_
except NameError:
	pass # does not exist, probably ignored

class Handle_OpenGl_Caps(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Caps self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Caps_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Caps self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Caps_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Caps self, OpenGl_Caps thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Caps_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Caps self, Handle_OpenGl_Caps theHandle) -> Handle_OpenGl_Caps
        assign(Handle_OpenGl_Caps self, OpenGl_Caps thePtr) -> Handle_OpenGl_Caps
        assign(Handle_OpenGl_Caps self, Handle_OpenGl_Caps theHandle) -> Handle_OpenGl_Caps

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Caps_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Caps self) -> OpenGl_Caps

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Caps_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Caps self) -> OpenGl_Caps

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Caps___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Caps self) -> OpenGl_Caps

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Caps___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Caps___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Caps___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Caps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Caps_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Caps

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Caps self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Caps_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Caps_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Caps_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Caps self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Caps_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Caps self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Caps self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Caps_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Caps self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Caps self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Caps_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Caps self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Caps_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Caps self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Caps_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Caps self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Caps_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Caps self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Caps_DecrementRefCounter(self, *args)

Handle_OpenGl_Caps_swigregister = _OpenGl.Handle_OpenGl_Caps_swigregister
Handle_OpenGl_Caps_swigregister(Handle_OpenGl_Caps)

def Handle_OpenGl_Caps_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Caps_DownCast(thing)
Handle_OpenGl_Caps_DownCast = _OpenGl.Handle_OpenGl_Caps_DownCast

class Handle_OpenGl_CappingAlgoFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_CappingAlgoFilter self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_CappingAlgoFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_CappingAlgoFilter self, OpenGl_CappingAlgoFilter * thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_CappingAlgoFilter self, Handle_OpenGl_CappingAlgoFilter theHandle) -> Handle_OpenGl_CappingAlgoFilter
        assign(Handle_OpenGl_CappingAlgoFilter self, OpenGl_CappingAlgoFilter const * thePtr) -> Handle_OpenGl_CappingAlgoFilter
        assign(Handle_OpenGl_CappingAlgoFilter self, Handle_OpenGl_CappingAlgoFilter theHandle) -> Handle_OpenGl_CappingAlgoFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_CappingAlgoFilter self) -> OpenGl_CappingAlgoFilter *

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_CappingAlgoFilter self) -> OpenGl_CappingAlgoFilter *

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_CappingAlgoFilter self) -> OpenGl_CappingAlgoFilter &

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_CappingAlgoFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_CappingAlgoFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_CappingAlgoFilter_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_CappingAlgoFilter

    def SetPreviousFilter(self, *args):
        """
        SetPreviousFilter(Handle_OpenGl_CappingAlgoFilter self, Handle_OpenGl_RenderFilter thePrevFitler)

        Sets the current active filter in workspace.
        @param thePrevFilter [in] the previously active filter that should have additive effect.

        :type thePrevFitler: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_SetPreviousFilter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_CappingAlgoFilter self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_CappingAlgoFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_CappingAlgoFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShouldRender(self, *args):
        """
        ShouldRender(Handle_OpenGl_CappingAlgoFilter self, Handle_OpenGl_Workspace theWorkspace, OpenGl_Element const * theElement) -> Standard_Boolean

        Checks whether the element can be rendered or not.
        @param theWorkspace [in] the current workspace.
        @param theElement [in] the element to check.
        @return True if element can be rendered.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace
        :type theElement: OCC.wrapper.OpenGl.OpenGl_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_ShouldRender(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_CappingAlgoFilter self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_CappingAlgoFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_CappingAlgoFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_CappingAlgoFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_CappingAlgoFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_CappingAlgoFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_CappingAlgoFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_CappingAlgoFilter self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_CappingAlgoFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_CappingAlgoFilter_DecrementRefCounter(self, *args)

Handle_OpenGl_CappingAlgoFilter_swigregister = _OpenGl.Handle_OpenGl_CappingAlgoFilter_swigregister
Handle_OpenGl_CappingAlgoFilter_swigregister(Handle_OpenGl_CappingAlgoFilter)

def Handle_OpenGl_CappingAlgoFilter_DownCast(thing):
    return _OpenGl.Handle_OpenGl_CappingAlgoFilter_DownCast(thing)
Handle_OpenGl_CappingAlgoFilter_DownCast = _OpenGl.Handle_OpenGl_CappingAlgoFilter_DownCast

class NCollection_Vector_GLint(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_GLint self) -> NCollection_Vector< GLint >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Vector_GLint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_GLint self) -> NCollection_Vector< GLint >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Vector_GLint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_GLint self) -> NCollection_Vector< GLint >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Vector_GLint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_GLint self) -> NCollection_Vector< GLint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Vector_GLint_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _OpenGl.new_NCollection_Vector_GLint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_GLint self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Vector_GLint_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_GLint self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Vector_GLint_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_GLint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Vector_GLint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_GLint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Vector_GLint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_GLint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Vector_GLint_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_GLint self, NCollection_Vector_GLint theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _OpenGl.NCollection_Vector_GLint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_GLint self, NCollection_Vector_GLint theOther) -> NCollection_Vector_GLint

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _OpenGl.NCollection_Vector_GLint_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_GLint self, GLint const & theValue) -> GLint &

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_GLint self) -> GLint &

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Vector_GLint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Vector_GLint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_GLint self) -> GLint &

        @return first element

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Vector_GLint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_GLint self) -> GLint &

        @return last element

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Vector_GLint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Vector_GLint_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_GLint self, Standard_Integer const theIndex) -> GLint &

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_GLint self, Standard_Integer const theIndex, GLint const & theValue) -> GLint &

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Vector_GLint_SetValue(self, *args)

    __swig_destroy__ = _OpenGl.delete_NCollection_Vector_GLint
NCollection_Vector_GLint_swigregister = _OpenGl.NCollection_Vector_GLint_swigregister
NCollection_Vector_GLint_swigregister(NCollection_Vector_GLint)


try:
	OpenGl_ColorFormats = NCollection_Vector_GLint
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore44_OpenGl_GlCore43Back(object):
    """OpenGL 4.4 definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 4.4 definition."""
        this = _OpenGl.new_OpenGl_TmplCore44_OpenGl_GlCore43Back()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore44_OpenGl_GlCore43Back
OpenGl_TmplCore44_OpenGl_GlCore43Back_swigregister = _OpenGl.OpenGl_TmplCore44_OpenGl_GlCore43Back_swigregister
OpenGl_TmplCore44_OpenGl_GlCore43Back_swigregister(OpenGl_TmplCore44_OpenGl_GlCore43Back)


try:
	OpenGl_GlCore44Back = OpenGl_TmplCore44_OpenGl_GlCore43Back
except NameError:
	pass # does not exist, probably ignored

class OpenGl_BVHTreeSelector(object):
    """
    BVHTreeSelector class provides a possibility to store parameters of view volume,
    such as its vertices and equations, and contains methods detecting if given AABB overlaps
    view volume.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_BVHTreeSelector self) -> OpenGl_BVHTreeSelector

        Creates an empty selector object with parallel projection type by default.


        """
        this = _OpenGl.new_OpenGl_BVHTreeSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetViewVolume(self, *args):
        """
        SetViewVolume(OpenGl_BVHTreeSelector self, Handle_Graphic3d_Camera theCamera)

        Retrieves view volume's planes equations and its vertices from projection and world-view matrices.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _OpenGl.OpenGl_BVHTreeSelector_SetViewVolume(self, *args)


    def SetViewportSize(self, *args):
        """
        SetViewportSize(OpenGl_BVHTreeSelector self, Standard_Integer theViewportWidth, Standard_Integer theViewportHeight, Standard_Real theResolutionRatio)

        :type theViewportWidth: int
        :type theViewportHeight: int
        :type theResolutionRatio: float

        """
        return _OpenGl.OpenGl_BVHTreeSelector_SetViewportSize(self, *args)


    def SetCullingDistance(self, *args):
        """
        SetCullingDistance(OpenGl_BVHTreeSelector self, OpenGl_BVHTreeSelector::CullingContext & theCtx, Standard_Real theDistance)

        Setup distance culling.

        :type theCtx: CullingContext
        :type theDistance: float

        """
        return _OpenGl.OpenGl_BVHTreeSelector_SetCullingDistance(self, *args)


    def SetCullingSize(self, *args):
        """
        SetCullingSize(OpenGl_BVHTreeSelector self, OpenGl_BVHTreeSelector::CullingContext & theCtx, Standard_Real theSize)

        Setup size culling.

        :type theCtx: CullingContext
        :type theSize: float

        """
        return _OpenGl.OpenGl_BVHTreeSelector_SetCullingSize(self, *args)


    def CacheClipPtsProjections(self, *args):
        """
        CacheClipPtsProjections(OpenGl_BVHTreeSelector self)

        Caches view volume's vertices projections along its normals and AABBs dimensions.
        Must be called at the beginning of each BVH tree traverse loop.


        """
        return _OpenGl.OpenGl_BVHTreeSelector_CacheClipPtsProjections(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(OpenGl_BVHTreeSelector self, OpenGl_BVHTreeSelector::CullingContext const & theCtx, NCollection_Vec3_Standard_Real theMinPt, NCollection_Vec3_Standard_Real theMaxPt) -> bool

        Checks whether given AABB should be entirely culled or not.
        @param theCtx   [in] culling properties
        @param theMinPt [in] maximum point of AABB
        @param theMaxPt [in] minimum point of AABB
        @return Standard_True, if AABB is in viewing area, Standard_False otherwise

        :type theCtx: CullingContext
        :type theMinPt: OCC.wrapper.OpenGl.OpenGl_Vec3d
        :type theMaxPt: OCC.wrapper.OpenGl.OpenGl_Vec3d
        :rtype: bool

        """
        return _OpenGl.OpenGl_BVHTreeSelector_IsCulled(self, *args)


    def Camera(self, *args):
        """
        Return the camera definition.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _OpenGl.OpenGl_BVHTreeSelector_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ProjectionMatrix(self, *args):
        """
        Returns current projection matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4d

        """
        res = _OpenGl.OpenGl_BVHTreeSelector_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorldViewMatrix(self, *args):
        """
        Returns current world view transformation matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4d

        """
        res = _OpenGl.OpenGl_BVHTreeSelector_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ViewportWidth(self, *args):
        """
        ViewportWidth(OpenGl_BVHTreeSelector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_BVHTreeSelector_ViewportWidth(self, *args)


    def ViewportHeight(self, *args):
        """
        ViewportHeight(OpenGl_BVHTreeSelector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_BVHTreeSelector_ViewportHeight(self, *args)


    def WorldViewProjState(self, *args):
        """
        Returns state of current world view projection transformation matrices.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_WorldViewProjState

        """
        res = _OpenGl.OpenGl_BVHTreeSelector_WorldViewProjState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_BVHTreeSelector
OpenGl_BVHTreeSelector_swigregister = _OpenGl.OpenGl_BVHTreeSelector_swigregister
OpenGl_BVHTreeSelector_swigregister(OpenGl_BVHTreeSelector)

class Handle_OpenGl_ShaderProgram(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_ShaderProgram self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_ShaderProgram self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_ShaderProgram self, OpenGl_ShaderProgram thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_ShaderProgram theHandle) -> Handle_OpenGl_ShaderProgram
        assign(Handle_OpenGl_ShaderProgram self, OpenGl_ShaderProgram thePtr) -> Handle_OpenGl_ShaderProgram
        assign(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_ShaderProgram theHandle) -> Handle_OpenGl_ShaderProgram

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_ShaderProgram self) -> OpenGl_ShaderProgram

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_ShaderProgram self) -> OpenGl_ShaderProgram

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_ShaderProgram self) -> OpenGl_ShaderProgram

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_ShaderProgram___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_ShaderProgram___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_ShaderProgram(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_ShaderProgram_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_ShaderProgram

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_ShaderProgram self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderProgram_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderProgram_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Create(self, *args):
        """
        Create(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Creates new empty shader program of specified type.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_ShaderProgram self, OpenGl_Context theCtx)

        Destroys shader program.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_ShaderProgram self) -> Standard_Size

        Returns estimated GPU memory usage - cannot be easily estimated.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_EstimatedDataSize(self, *args)


    def AttachShader(self, *args):
        """
        AttachShader(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, Handle_OpenGl_ShaderObject theShader) -> Standard_Boolean

        Attaches shader object to the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShader: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_AttachShader(self, *args)


    def DetachShader(self, *args):
        """
        DetachShader(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, Handle_OpenGl_ShaderObject theShader) -> Standard_Boolean

        Detaches shader object to the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShader: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_DetachShader(self, *args)


    def Initialize(self, *args):
        """
        Initialize(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, NCollection_Sequence_Handle_Graphic3d_ShaderObject theShaders) -> Standard_Boolean

        Initializes program object with the list of shader objects.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theShaders: OCC.wrapper.Graphic3d.Graphic3d_ShaderObjectList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Initialize(self, *args)


    def Link(self, *args):
        """
        Link(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Links the program object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Link(self, *args)


    def FetchInfoLog(self, *args):
        """
        FetchInfoLog(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theLog) -> Standard_Boolean

        Fetches information log of the last link operation.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLog: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_FetchInfoLog(self, *args)


    def ApplyVariables(self, *args):
        """
        ApplyVariables(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Fetches uniform variables from proxy shader program.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_ApplyVariables(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_ShaderProgram self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_IsValid(self, *args)


    def ProgramId(self, *args):
        """
        ProgramId(Handle_OpenGl_ShaderProgram self) -> GLuint

        @return program ID

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_ProgramId(self, *args)


    def HasTessellationStage(self, *args):
        """
        HasTessellationStage(Handle_OpenGl_ShaderProgram self) -> Standard_Boolean

        Return TRUE if program defines tessellation stage.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_HasTessellationStage(self, *args)


    def NbLightsMax(self, *args):
        """
        NbLightsMax(Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of light sources (THE_MAX_LIGHTS),
        to be used for initialization occLightSources (OpenGl_OCC_LIGHT_SOURCE_PARAMS).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_NbLightsMax(self, *args)


    def NbClipPlanesMax(self, *args):
        """
        NbClipPlanesMax(Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of clipping planes (THE_MAX_CLIP_PLANES),
        to be used for initialization occClipPlaneEquations (OpenGl_OCC_CLIP_PLANE_EQUATIONS).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_NbClipPlanesMax(self, *args)


    def NbFragmentOutputs(self, *args):
        """
        NbFragmentOutputs(Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Return the length of array of Fragment Shader outputs (THE_NB_FRAG_OUTPUTS),
        to be used for initialization occFragColorArray/occFragColorN.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_NbFragmentOutputs(self, *args)


    def HasAlphaTest(self, *args):
        """
        HasAlphaTest(Handle_OpenGl_ShaderProgram self) -> Standard_Boolean

        Return true if Fragment Shader should perform alpha test; FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_HasAlphaTest(self, *args)


    def HasWeightOitOutput(self, *args):
        """
        HasWeightOitOutput(Handle_OpenGl_ShaderProgram self) -> Standard_Boolean

        Return true if Fragment Shader color should output the weighted OIT coverage; FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_HasWeightOitOutput(self, *args)


    def GetUniformLocation(self, *args):
        """
        GetUniformLocation(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName) -> GLint

        Returns location of the specific uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theName: GLchar
        :rtype: GLint

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetUniformLocation(self, *args)


    def GetAttributeLocation(self, *args):
        """
        GetAttributeLocation(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName) -> GLint

        Returns index of the generic vertex attribute by variable name.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theName: GLchar
        :rtype: GLint

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetAttributeLocation(self, *args)


    def GetStateLocation(self, *args):
        """
        GetStateLocation(Handle_OpenGl_ShaderProgram self, GLuint const theVariable) -> GLint

        Returns location of the OCCT state uniform variable.

        :type theVariable: GLuint
        :rtype: GLint

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetStateLocation(self, *args)


    def GetUniform(self, *args):
        """
        GetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 & theValue) -> Standard_Boolean
        GetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4 & theValue) -> Standard_Boolean

        Returns the value of the float uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetUniform(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4i & theValue) -> Standard_Boolean
        GetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 & theValue) -> Standard_Boolean
        GetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4 & theValue) -> Standard_Boolean

        Returns the float vertex attribute.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetAttribute(self, *args)


    def SetAttributeName(self, *args):
        """
        SetAttributeName(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, GLchar const * theName) -> Standard_Boolean

        Wrapper for glBindAttribLocation()

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theName: GLchar
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_SetAttributeName(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLfloat theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, GLfloat theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetAttribute(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theIndex, OpenGl_Vec4 const & theValue) -> Standard_Boolean

        Wrapper for glVertexAttrib4fv()

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theIndex: GLint
        :type theValue: OCC.wrapper.OpenGl.OpenGl_Vec4
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_SetAttribute(self, *args)


    def SetUniform(self, *args):
        """
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLint theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLint theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec2_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec3_Standard_Integer theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4i const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4i const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec2u const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec2u const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLsizei const theCount, OpenGl_Vec2u const * theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLsizei const theCount, OpenGl_Vec2u const * theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, GLfloat theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLfloat theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec2_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Vec3_Standard_ShortReal theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Vec4 const & theValue) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, NCollection_Mat4_Standard_ShortReal theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, NCollection_Mat4_Standard_ShortReal theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, OpenGl_Matrix const & theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, OpenGl_Matrix const & theValue, GLboolean theTranspose) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, Standard_ShortReal const * theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec2_Standard_ShortReal theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec3_Standard_ShortReal theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, OpenGl_Vec4 const * theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, Standard_Integer const * theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec2_Standard_Integer theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, NCollection_Vec3_Standard_Integer theData) -> Standard_Boolean
        SetUniform(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, GLuint theCount, OpenGl_Vec4i const * theData) -> Standard_Boolean

        Specifies the value of the int4 uniform array

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theCount: GLuint
        :type theData: OCC.wrapper.OpenGl.OpenGl_Vec4i
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_SetUniform(self, *args)


    def SetSampler(self, *args):
        """
        SetSampler(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLchar const * theName, Graphic3d_TextureUnit const theTextureUnit) -> Standard_Boolean
        SetSampler(Handle_OpenGl_ShaderProgram self, Handle_OpenGl_Context theCtx, GLint theLocation, Graphic3d_TextureUnit const theTextureUnit) -> Standard_Boolean

        Specifies the value of the sampler uniform variable.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLocation: GLint
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_SetSampler(self, *args)


    def ResourceId(self, *args):
        """
        Return resource name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _OpenGl.Handle_OpenGl_ShaderProgram_ResourceId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_ShaderProgram self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_ShaderProgram self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_ShaderProgram self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_ShaderProgram self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_ShaderProgram self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_ShaderProgram self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_ShaderProgram self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_ShaderProgram self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderProgram_DecrementRefCounter(self, *args)

Handle_OpenGl_ShaderProgram_swigregister = _OpenGl.Handle_OpenGl_ShaderProgram_swigregister
Handle_OpenGl_ShaderProgram_swigregister(Handle_OpenGl_ShaderProgram)

def Handle_OpenGl_ShaderProgram_DownCast(thing):
    return _OpenGl.Handle_OpenGl_ShaderProgram_DownCast(thing)
Handle_OpenGl_ShaderProgram_DownCast = _OpenGl.Handle_OpenGl_ShaderProgram_DownCast

class Handle_OpenGl_GraphicDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_GraphicDriver self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_GraphicDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_GraphicDriver self, OpenGl_GraphicDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_GraphicDriver self, Handle_OpenGl_GraphicDriver theHandle) -> Handle_OpenGl_GraphicDriver
        assign(Handle_OpenGl_GraphicDriver self, OpenGl_GraphicDriver thePtr) -> Handle_OpenGl_GraphicDriver
        assign(Handle_OpenGl_GraphicDriver self, Handle_OpenGl_GraphicDriver theHandle) -> Handle_OpenGl_GraphicDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_GraphicDriver self) -> OpenGl_GraphicDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_GraphicDriver self) -> OpenGl_GraphicDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_GraphicDriver self) -> OpenGl_GraphicDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_GraphicDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_GraphicDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_GraphicDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_GraphicDriver_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_GraphicDriver

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_GraphicDriver self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReleaseContext(self, *args):
        """
        ReleaseContext(Handle_OpenGl_GraphicDriver self)

        Release default context.


        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_ReleaseContext(self, *args)


    def InitContext(self, *args):
        """
        InitContext(Handle_OpenGl_GraphicDriver self) -> Standard_Boolean

        Perform initialization of default OpenGL context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_InitContext(self, *args)


    def InquireLimit(self, *args):
        """
        InquireLimit(Handle_OpenGl_GraphicDriver self, Graphic3d_TypeOfLimit const theType) -> Standard_Integer

        Request limit of graphic resource of specific type.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLimit
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_InquireLimit(self, *args)


    def CreateStructure(self, *args):
        """
        CreateStructure(Handle_OpenGl_GraphicDriver self, Handle_Graphic3d_StructureManager theManager) -> Handle_Graphic3d_CStructure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_CreateStructure(self, *args)


    def RemoveStructure(self, *args):
        """
        RemoveStructure(Handle_OpenGl_GraphicDriver self, Handle_Graphic3d_CStructure theCStructure)

        :type theCStructure: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_RemoveStructure(self, *args)


    def CreateView(self, *args):
        """
        CreateView(Handle_OpenGl_GraphicDriver self, Handle_Graphic3d_StructureManager theMgr) -> Handle_Graphic3d_CView

        :type theMgr: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_CreateView(self, *args)


    def RemoveView(self, *args):
        """
        RemoveView(Handle_OpenGl_GraphicDriver self, Handle_Graphic3d_CView theView)

        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_RemoveView(self, *args)


    def CreateRenderWindow(self, *args):
        """
        CreateRenderWindow(Handle_OpenGl_GraphicDriver self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext) -> Handle_OpenGl_Window

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Window

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_CreateRenderWindow(self, *args)


    def TextSize(self, *args):
        """
        TextSize(Handle_OpenGl_GraphicDriver self, Handle_Graphic3d_CView theView, Standard_CString const theText, Standard_ShortReal const theHeight)

        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView
        :type theText: OCC.wrapper.Standard.Standard_CString
        :type theHeight: float
        :type theWidth: float
        :type theAscent: float
        :type theDescent: float

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_TextSize(self, *args)


    def DefaultTextHeight(self, *args):
        """
        DefaultTextHeight(Handle_OpenGl_GraphicDriver self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_DefaultTextHeight(self, *args)


    def ViewExists(self, *args):
        """
        ViewExists(Handle_OpenGl_GraphicDriver self, Handle_Aspect_Window theWindow, Handle_Graphic3d_CView theView) -> Standard_Boolean

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theView: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_ViewExists(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(Handle_OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Adds a new top-level z layer with ID theLayerId for all views. Z layers allow drawing structures in higher layers
        in foreground of structures in lower layers. To add a structure to desired layer on display it is necessary to
        set the layer index for the structure. The passed theLayerId should be not less than 0 (reserved for default layers).

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(Handle_OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Removes Z layer. All structures displayed at the moment in layer will be displayed in
        default layer (the bottom-level z layer). By default, there are always default
        bottom-level layer that can't be removed.  The passed theLayerId should be not less than 0
        (reserved for default layers that can not be removed).

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_RemoveZLayer(self, *args)


    def ZLayers(self, *args):
        """
        ZLayers(Handle_OpenGl_GraphicDriver self, NCollection_Sequence_Standard_Integer theLayerSeq)

        Returns list of Z layers defined for the graphical driver.

        :type theLayerSeq: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_ZLayers(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(Handle_OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_SetZLayerSettings(self, *args)


    def ZLayerSettings(self, *args):
        """
        Returns the settings of a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_ZLayerSettings(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Options(self, *args):
        """
        @return the visualization options

        :rtype: OCC.wrapper.OpenGl.OpenGl_Caps

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_Options(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeOptions(self, *args):
        """
        ChangeOptions(Handle_OpenGl_GraphicDriver self) -> OpenGl_Caps

        @return the visualization options

        :rtype: OCC.wrapper.OpenGl.OpenGl_Caps

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_ChangeOptions(self, *args)


    def SetBuffersNoSwap(self, *args):
        """
        SetBuffersNoSwap(Handle_OpenGl_GraphicDriver self, Standard_Boolean const theIsNoSwap)

        Specify swap buffer behavior.

        :type theIsNoSwap: bool

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_SetBuffersNoSwap(self, *args)


    def EnableVBO(self, *args):
        """
        EnableVBO(Handle_OpenGl_GraphicDriver self, Standard_Boolean const theToTurnOn)

        VBO usage can be forbidden by this method even if it is supported by GL driver.
        Notice that disabling of VBO will cause rendering performance degradation.
        Warning! This method should be called only before any primitives are displayed in GL scene!

        :type theToTurnOn: bool

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_EnableVBO(self, *args)


    def MemoryInfo(self, *args):
        """
        MemoryInfo(Handle_OpenGl_GraphicDriver self, TCollection_AsciiString theInfo) -> Standard_Boolean

        Returns information about GPU memory usage.
        Please read OpenGl_Context::MemoryInfo() for more description.

        :type theFreeBytes: int
        :type theInfo: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_MemoryInfo(self, *args)


    def GetSharedContext(self, *args):
        """
        Method to retrieve valid GL context.
        Could return NULL-handle if no window created by this driver.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_GetSharedContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def addZLayerIndex(self, *args):
        """
        addZLayerIndex(Handle_OpenGl_GraphicDriver self, Graphic3d_ZLayerId const theLayerId)

        Insert index layer at proper position.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_addZLayerIndex(self, *args)


    def setDeviceLost(self, *args):
        """
        setDeviceLost(Handle_OpenGl_GraphicDriver self)

        Set device lost flag for redrawn views.


        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_setDeviceLost(self, *args)


    def GetStateCounter(self, *args):
        """
        GetStateCounter(Handle_OpenGl_GraphicDriver self) -> OpenGl_StateCounter

        State counter for OpenGl structures.

        :rtype: OCC.wrapper.OpenGl.OpenGl_StateCounter

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_GetStateCounter(self, *args)


    def GetNextPrimitiveArrayUID(self, *args):
        """
        GetNextPrimitiveArrayUID(Handle_OpenGl_GraphicDriver self) -> Standard_Size

        Returns unique ID for primitive arrays.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_GetNextPrimitiveArrayUID(self, *args)


    def InquireLightLimit(self, *args):
        """
        InquireLightLimit(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Request maximum number of active light sources supported by driver and hardware.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_InquireLightLimit(self, *args)


    def InquirePlaneLimit(self, *args):
        """
        InquirePlaneLimit(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Request maximum number of active clipping planes supported by driver and hardware.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_InquirePlaneLimit(self, *args)


    def InquireViewLimit(self, *args):
        """
        InquireViewLimit(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Request maximum number of views supported by driver.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_InquireViewLimit(self, *args)


    def GetDisplayConnection(self, *args):
        """
        returns Handle to display connection

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_DisplayConnection

        """
        res = _OpenGl.Handle_OpenGl_GraphicDriver_GetDisplayConnection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewIdentification(self, *args):
        """
        NewIdentification(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Returns a new identification number for a new structure.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_NewIdentification(self, *args)


    def RemoveIdentification(self, *args):
        """
        RemoveIdentification(Handle_OpenGl_GraphicDriver self, Standard_Integer const theId)

        Frees the identifier of a structure.

        :type theId: int

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_RemoveIdentification(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_GraphicDriver self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_GraphicDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_GraphicDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_GraphicDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_GraphicDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_GraphicDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_GraphicDriver self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_GraphicDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_GraphicDriver_DecrementRefCounter(self, *args)

Handle_OpenGl_GraphicDriver_swigregister = _OpenGl.Handle_OpenGl_GraphicDriver_swigregister
Handle_OpenGl_GraphicDriver_swigregister(Handle_OpenGl_GraphicDriver)

def Handle_OpenGl_GraphicDriver_DownCast(thing):
    return _OpenGl.Handle_OpenGl_GraphicDriver_DownCast(thing)
Handle_OpenGl_GraphicDriver_DownCast = _OpenGl.Handle_OpenGl_GraphicDriver_DownCast

class Handle_OpenGl_TextureBufferArb(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_TextureBufferArb self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_TextureBufferArb self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_TextureBufferArb self, OpenGl_TextureBufferArb thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_TextureBufferArb theHandle) -> Handle_OpenGl_TextureBufferArb
        assign(Handle_OpenGl_TextureBufferArb self, OpenGl_TextureBufferArb thePtr) -> Handle_OpenGl_TextureBufferArb
        assign(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_TextureBufferArb theHandle) -> Handle_OpenGl_TextureBufferArb

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_TextureBufferArb self) -> OpenGl_TextureBufferArb

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_TextureBufferArb self) -> OpenGl_TextureBufferArb

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_TextureBufferArb self) -> OpenGl_TextureBufferArb

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_TextureBufferArb___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_TextureBufferArb___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_TextureBufferArb(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_TextureBufferArb_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_TextureBufferArb

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_TextureBufferArb self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_TextureBufferArb_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_TextureBufferArb_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_TextureBufferArb self) -> GLenum

        Override VBO target

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetTarget(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_TextureBufferArb self) -> bool

        Returns true if TBO is valid.
        Notice that no any real GL call is performed!

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_IsValid(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_TextureBufferArb self, OpenGl_Context theGlCtx)

        Destroy object - will release GPU memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Release(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO and Texture names (ids) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Create(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Perform TBO initialization with specified data.
        Existing data will be deleted.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Init(self, *args)


    def BindTexture(self, *args):
        """
        BindTexture(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TextureUnit const theTextureUnit)

        Bind TBO to specified Texture Unit.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_BindTexture(self, *args)


    def UnbindTexture(self, *args):
        """
        UnbindTexture(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TextureUnit const theTextureUnit)

        Unbind TBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTextureUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_UnbindTexture(self, *args)


    def TextureId(self, *args):
        """
        TextureId(Handle_OpenGl_TextureBufferArb self) -> GLuint

        Returns name of TBO.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_TextureId(self, *args)


    def TextureFormat(self, *args):
        """
        TextureFormat(Handle_OpenGl_TextureBufferArb self) -> GLenum

        Returns internal texture format.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_TextureFormat(self, *args)


    def GetComponentsNb(self, *args):
        """
        GetComponentsNb(Handle_OpenGl_TextureBufferArb self) -> GLuint

        @return the number of components per generic vertex attribute.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetComponentsNb(self, *args)


    def GetElemsNb(self, *args):
        """
        GetElemsNb(Handle_OpenGl_TextureBufferArb self) -> GLsizei

        @return number of vertex attributes / number of vertices.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetElemsNb(self, *args)


    def GetDataType(self, *args):
        """
        GetDataType(Handle_OpenGl_TextureBufferArb self) -> GLenum

        @return data type of each component in the array.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetDataType(self, *args)


    def GetDataOffset(self, *args):
        """
        GetDataOffset(Handle_OpenGl_TextureBufferArb self) -> GLubyte *

        @return offset to data, NULL by default

        :rtype: GLubyte

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetDataOffset(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Unbind(self, *args)


    def SubData(self, *args):
        """
        SubData(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        SubData(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLuint const * theData) -> bool
        SubData(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLushort const * theData) -> bool
        SubData(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        Function replaces portion of data within this VBO using glBufferSubData().
        The VBO should be initialized before call.
        @param theElemFrom element id from which replace buffer data (>=0);
        @param theElemsNb  elements count (theElemFrom + theElemsNb <= GetElemsNb());
        @param theData     pointer to GLubyte data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_SubData(self, *args)


    def BindVertexAttrib(self, *args):
        """
        BindVertexAttrib(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Bind this VBO to active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_BindVertexAttrib(self, *args)


    def UnbindVertexAttrib(self, *args):
        """
        UnbindVertexAttrib(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Unbind any VBO from active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_UnbindVertexAttrib(self, *args)


    def BindAttribute(self, *args):
        """
        BindAttribute(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Bind this VBO and enable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theGlCtx - handle to bound GL context;
        @param theMode  - array mode (GL_VERTEX_ARRAY, GL_NORMAL_ARRAY, GL_COLOR_ARRAY, GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_BindAttribute(self, *args)


    def UnbindAttribute(self, *args):
        """
        UnbindAttribute(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Unbind this VBO and disable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theCtx handle to bound GL context
        @param theMode  array mode

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_UnbindAttribute(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_TextureBufferArb self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_EstimatedDataSize(self, *args)


    def sizeOfGlType(self, *args):
        """
        sizeOfGlType(Handle_OpenGl_TextureBufferArb self, GLenum const theType) -> size_t

        @return size of specified GL type

        :type theType: GLenum
        :rtype: size_t

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_sizeOfGlType(self, *args)


    def init(self, *args):
        """
        init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool
        init(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Initialize buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_init(self, *args)


    def subData(self, *args):
        """
        subData(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_subData(self, *args)


    def bindAttribute(self, *args):
        """
        bindAttribute(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

        Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using bindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
        :type theNbComp: GLint
        :type theDataType: GLenum
        :type theStride: GLsizei
        :type theOffset: GLvoid

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_bindAttribute(self, *args)


    def unbindAttribute(self, *args):
        """
        unbindAttribute(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

        Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using unbindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_unbindAttribute(self, *args)


    def HasColorAttribute(self, *args):
        """
        HasColorAttribute(Handle_OpenGl_TextureBufferArb self) -> bool

        @return true if buffer contains per-vertex color attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_HasColorAttribute(self, *args)


    def HasNormalAttribute(self, *args):
        """
        HasNormalAttribute(Handle_OpenGl_TextureBufferArb self) -> bool

        @return true if buffer contains per-vertex normal attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_HasNormalAttribute(self, *args)


    def BindAllAttributes(self, *args):
        """
        BindAllAttributes(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx)

        Bind all vertex attributes to active program OpenGl_Context::ActiveProgram() or for FFP.
        Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_BindAllAttributes(self, *args)


    def BindPositionAttribute(self, *args):
        """
        BindPositionAttribute(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx)

        Bind vertex position attribute only. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_BindPositionAttribute(self, *args)


    def UnbindAllAttributes(self, *args):
        """
        UnbindAllAttributes(Handle_OpenGl_TextureBufferArb self, Handle_OpenGl_Context theGlCtx)

        Unbind all vertex attributes. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_UnbindAllAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_TextureBufferArb self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_TextureBufferArb self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_TextureBufferArb self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_TextureBufferArb self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_TextureBufferArb self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_TextureBufferArb self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_TextureBufferArb self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_TextureBufferArb self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_TextureBufferArb self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_TextureBufferArb_DecrementRefCounter(self, *args)

Handle_OpenGl_TextureBufferArb_swigregister = _OpenGl.Handle_OpenGl_TextureBufferArb_swigregister
Handle_OpenGl_TextureBufferArb_swigregister(Handle_OpenGl_TextureBufferArb)

def Handle_OpenGl_TextureBufferArb_DownCast(thing):
    return _OpenGl.Handle_OpenGl_TextureBufferArb_DownCast(thing)
Handle_OpenGl_TextureBufferArb_DownCast = _OpenGl.Handle_OpenGl_TextureBufferArb_DownCast

class NCollection_Array1_OpenGl_IndexedMapOfStructure(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_Array1< OpenGl_IndexedMapOfStructure >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_Array1< OpenGl_IndexedMapOfStructure >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_Array1< OpenGl_IndexedMapOfStructure >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_Array1< OpenGl_IndexedMapOfStructure >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _OpenGl.new_NCollection_Array1_OpenGl_IndexedMapOfStructure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_OpenGl_IndexedMapOfStructure self, NCollection_IndexedMap< OpenGl_Structure const *,NCollection_DefaultHasher< OpenGl_Structure const * > > const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_OpenGl_IndexedMapOfStructure self, NCollection_Array1_OpenGl_IndexedMapOfStructure theOther) -> NCollection_Array1_OpenGl_IndexedMapOfStructure

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_OpenGl_IndexedMapOfStructure self, NCollection_Array1_OpenGl_IndexedMapOfStructure theOther) -> NCollection_Array1_OpenGl_IndexedMapOfStructure

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_OpenGl_IndexedMapOfStructure self, NCollection_Array1_OpenGl_IndexedMapOfStructure theOther) -> NCollection_Array1_OpenGl_IndexedMapOfStructure
        assign(NCollection_Array1_OpenGl_IndexedMapOfStructure self, NCollection_Array1_OpenGl_IndexedMapOfStructure theOther) -> NCollection_Array1_OpenGl_IndexedMapOfStructure

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_IndexedMap< OpenGl_Structure const *,NCollection_DefaultHasher< OpenGl_Structure const * > > &

        @return first element

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_OpenGl_IndexedMapOfStructure self) -> NCollection_IndexedMap< OpenGl_Structure const *,NCollection_DefaultHasher< OpenGl_Structure const * > > &

        @return last element

        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_OpenGl_IndexedMapOfStructure self, Standard_Integer const theIndex) -> NCollection_IndexedMap< OpenGl_Structure const *,NCollection_DefaultHasher< OpenGl_Structure const * > > &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_OpenGl_IndexedMapOfStructure self, Standard_Integer const theIndex, NCollection_IndexedMap< OpenGl_Structure const *,NCollection_DefaultHasher< OpenGl_Structure const * > > const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_OpenGl_IndexedMapOfStructure self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_Resize(self, *args)

    __swig_destroy__ = _OpenGl.delete_NCollection_Array1_OpenGl_IndexedMapOfStructure
NCollection_Array1_OpenGl_IndexedMapOfStructure_swigregister = _OpenGl.NCollection_Array1_OpenGl_IndexedMapOfStructure_swigregister
NCollection_Array1_OpenGl_IndexedMapOfStructure_swigregister(NCollection_Array1_OpenGl_IndexedMapOfStructure)


try:
	OpenGl_ArrayOfIndexedMapOfStructure = NCollection_Array1_OpenGl_IndexedMapOfStructure
except NameError:
	pass # does not exist, probably ignored

class Handle_OpenGl_VertexBufferCompat(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_VertexBufferCompat self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_VertexBufferCompat self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_VertexBufferCompat self, OpenGl_VertexBufferCompat thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_VertexBufferCompat theHandle) -> Handle_OpenGl_VertexBufferCompat
        assign(Handle_OpenGl_VertexBufferCompat self, OpenGl_VertexBufferCompat thePtr) -> Handle_OpenGl_VertexBufferCompat
        assign(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_VertexBufferCompat theHandle) -> Handle_OpenGl_VertexBufferCompat

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_VertexBufferCompat self) -> OpenGl_VertexBufferCompat

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_VertexBufferCompat self) -> OpenGl_VertexBufferCompat

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_VertexBufferCompat self) -> OpenGl_VertexBufferCompat

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_VertexBufferCompat___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_VertexBufferCompat___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_VertexBufferCompat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_VertexBufferCompat_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_VertexBufferCompat

    def Create(self, *args):
        """
        Create(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx) -> bool

        Creates VBO name (id) if not yet generated.
        Data should be initialized by another method.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_VertexBufferCompat self, OpenGl_Context theGlCtx)

        Destroy object - will release memory if any.

        :type theGlCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Release(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Bind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Unbind this VBO.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Unbind(self, *args)


    def initLink(self, *args):
        """
        initLink(Handle_OpenGl_VertexBufferCompat self, Handle_NCollection_Buffer theData, GLuint const theComponentsNb, GLsizei const theElemsNb, GLenum const theDataType) -> bool

        Initialize buffer with existing data.
        Data will NOT be copied by this method!

        :type theData: OCC.wrapper.NCollection.Handle_NCollection_Buffer
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_initLink(self, *args)


    def init(self, *args):
        """
        init(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, void const * theData, GLenum const theDataType, GLsizei const theStride) -> bool

        Initialize buffer with new data (data will be copied).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :type theStride: GLsizei
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_init(self, *args)


    def subData(self, *args):
        """
        subData(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, void const * theData, GLenum const theDataType) -> bool

        Update part of the buffer with new data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: const void *
        :type theDataType: GLenum
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_subData(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_VertexBufferCompat self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_VertexBufferCompat_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_VertexBufferCompat_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTarget(self, *args):
        """
        GetTarget(Handle_OpenGl_VertexBufferCompat self) -> GLenum

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetTarget(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_VertexBufferCompat self) -> bool

        @return true if current object was initialized

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_IsValid(self, *args)


    def GetComponentsNb(self, *args):
        """
        GetComponentsNb(Handle_OpenGl_VertexBufferCompat self) -> GLuint

        @return the number of components per generic vertex attribute.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetComponentsNb(self, *args)


    def GetElemsNb(self, *args):
        """
        GetElemsNb(Handle_OpenGl_VertexBufferCompat self) -> GLsizei

        @return number of vertex attributes / number of vertices.

        :rtype: GLsizei

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetElemsNb(self, *args)


    def GetDataType(self, *args):
        """
        GetDataType(Handle_OpenGl_VertexBufferCompat self) -> GLenum

        @return data type of each component in the array.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetDataType(self, *args)


    def GetDataOffset(self, *args):
        """
        GetDataOffset(Handle_OpenGl_VertexBufferCompat self) -> GLubyte *

        @return offset to data, NULL by default

        :rtype: GLubyte

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetDataOffset(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        Init(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLuint const * theData) -> bool
        Init(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLushort const * theData) -> bool
        Init(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theComponentsNb, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        @param theComponentsNb - specifies the number of components per generic vertex attribute; must be 1, 2, 3, or 4;
        @param theElemsNb      - elements count;
        @param theData         - pointer to GLubyte data (indices/colors etc.).

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theComponentsNb: GLuint
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Init(self, *args)


    def SubData(self, *args):
        """
        SubData(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLfloat const * theData) -> bool
        SubData(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLuint const * theData) -> bool
        SubData(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLushort const * theData) -> bool
        SubData(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLsizei const theElemFrom, GLsizei const theElemsNb, GLubyte const * theData) -> bool

        Notice that VBO will be unbound after this call.
        Function replaces portion of data within this VBO using glBufferSubData().
        The VBO should be initialized before call.
        @param theElemFrom element id from which replace buffer data (>=0);
        @param theElemsNb  elements count (theElemFrom + theElemsNb <= GetElemsNb());
        @param theData     pointer to GLubyte data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theElemFrom: GLsizei
        :type theElemsNb: GLsizei
        :type theData: GLubyte
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_SubData(self, *args)


    def BindVertexAttrib(self, *args):
        """
        BindVertexAttrib(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Bind this VBO to active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_BindVertexAttrib(self, *args)


    def UnbindVertexAttrib(self, *args):
        """
        UnbindVertexAttrib(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, GLuint const theAttribLoc)

        Unbind any VBO from active GLSL program.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theAttribLoc: GLuint

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_UnbindVertexAttrib(self, *args)


    def BindAttribute(self, *args):
        """
        BindAttribute(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Bind this VBO and enable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theGlCtx - handle to bound GL context;
        @param theMode  - array mode (GL_VERTEX_ARRAY, GL_NORMAL_ARRAY, GL_COLOR_ARRAY, GL_INDEX_ARRAY, GL_TEXTURE_COORD_ARRAY).

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_BindAttribute(self, *args)


    def UnbindAttribute(self, *args):
        """
        UnbindAttribute(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theCtx, Graphic3d_TypeOfAttribute const theMode)

        Unbind this VBO and disable specified attribute in OpenGl_Context::ActiveProgram() or FFP.
        @param theCtx handle to bound GL context
        @param theMode  array mode

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_UnbindAttribute(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_VertexBufferCompat self) -> Standard_Size

        Returns estimated GPU memory usage for holding data without considering overheads and allocation alignment rules.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_EstimatedDataSize(self, *args)


    def sizeOfGlType(self, *args):
        """
        sizeOfGlType(Handle_OpenGl_VertexBufferCompat self, GLenum const theType) -> size_t

        @return size of specified GL type

        :type theType: GLenum
        :rtype: size_t

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_sizeOfGlType(self, *args)


    def bindAttribute(self, *args):
        """
        bindAttribute(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode, GLint const theNbComp, GLenum const theDataType, GLsizei const theStride, GLvoid const * theOffset)

        Setup array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using bindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute
        :type theNbComp: GLint
        :type theDataType: GLenum
        :type theStride: GLsizei
        :type theOffset: GLvoid

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_bindAttribute(self, *args)


    def unbindAttribute(self, *args):
        """
        unbindAttribute(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx, Graphic3d_TypeOfAttribute const theMode)

        Disable GLSL array pointer - either for active GLSL program OpenGl_Context::ActiveProgram()
        or for FFP using unbindFixed() when no program bound.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TypeOfAttribute

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_unbindAttribute(self, *args)


    def HasColorAttribute(self, *args):
        """
        HasColorAttribute(Handle_OpenGl_VertexBufferCompat self) -> bool

        @return true if buffer contains per-vertex color attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_HasColorAttribute(self, *args)


    def HasNormalAttribute(self, *args):
        """
        HasNormalAttribute(Handle_OpenGl_VertexBufferCompat self) -> bool

        @return true if buffer contains per-vertex normal attribute

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_HasNormalAttribute(self, *args)


    def BindAllAttributes(self, *args):
        """
        BindAllAttributes(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Bind all vertex attributes to active program OpenGl_Context::ActiveProgram() or for FFP.
        Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_BindAllAttributes(self, *args)


    def BindPositionAttribute(self, *args):
        """
        BindPositionAttribute(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Bind vertex position attribute only. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_BindPositionAttribute(self, *args)


    def UnbindAllAttributes(self, *args):
        """
        UnbindAllAttributes(Handle_OpenGl_VertexBufferCompat self, Handle_OpenGl_Context theGlCtx)

        Unbind all vertex attributes. Default implementation does nothing.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_UnbindAllAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_VertexBufferCompat self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_VertexBufferCompat self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_VertexBufferCompat self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_VertexBufferCompat self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_VertexBufferCompat self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_VertexBufferCompat self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_VertexBufferCompat self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_VertexBufferCompat self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_VertexBufferCompat self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_VertexBufferCompat_DecrementRefCounter(self, *args)

Handle_OpenGl_VertexBufferCompat_swigregister = _OpenGl.Handle_OpenGl_VertexBufferCompat_swigregister
Handle_OpenGl_VertexBufferCompat_swigregister(Handle_OpenGl_VertexBufferCompat)

def Handle_OpenGl_VertexBufferCompat_DownCast(thing):
    return _OpenGl.Handle_OpenGl_VertexBufferCompat_DownCast(thing)
Handle_OpenGl_VertexBufferCompat_DownCast = _OpenGl.Handle_OpenGl_VertexBufferCompat_DownCast

class OpenGl_TileSampler(object):
    """
    Tool object used for sampling screen tiles according to estimated pixel variance (used in path tracing engine).
    To improve GPU thread coherency, rendering window is split into pixel blocks or tiles. The important feature of
    this approach is that it is possible to keep the same number of tiles for any screen resolution (e.g. 256 tiles
    can be used for both 512 x 512 window and 1920 x 1080 window). So, a smaller number of tiles allows to increase
    interactivity (FPS), but at the cost of higher per-frame variance ('noise'). On the contrary a larger number of
    tiles decrease interactivity, but leads to lower per-frame variance. Note that the total time needed to produce
    final final image is the same for both cases.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def TileSize(*args):
        """
        TileSize() -> int

        Size of individual tile in pixels.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_TileSize(*args)

    TileSize = staticmethod(TileSize)

    def __init__(self, *args):
        """
        __init__(OpenGl_TileSampler self) -> OpenGl_TileSampler

        Creates new tile sampler.


        """
        this = _OpenGl.new_OpenGl_TileSampler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SizeX(self, *args):
        """
        SizeX(OpenGl_TileSampler self) -> int

        Returns width of ray-tracing viewport.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(OpenGl_TileSampler self) -> int

        Returns height of ray-tracing viewport.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_SizeY(self, *args)


    def NbTilesX(self, *args):
        """
        NbTilesX(OpenGl_TileSampler self) -> int

        Returns number of tiles in X dimension.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_NbTilesX(self, *args)


    def NbTilesY(self, *args):
        """
        NbTilesY(OpenGl_TileSampler self) -> int

        Returns number of tiles in Y dimension.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_NbTilesY(self, *args)


    def NbTiles(self, *args):
        """
        NbTiles(OpenGl_TileSampler self) -> int

        Returns total number of tiles in viewport.

        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_NbTiles(self, *args)


    def SetSize(self, *args):
        """
        SetSize(OpenGl_TileSampler self, int const theSizeX, int const theSizeY)

        Specifies size of ray-tracing viewport.

        :type theSizeX: const int
        :type theSizeY: const int

        """
        return _OpenGl.OpenGl_TileSampler_SetSize(self, *args)


    def TileArea(self, *args):
        """
        TileArea(OpenGl_TileSampler self, int const theX, int const theY) -> int

        Returns number of pixels in the given tile.

        :type theX: const int
        :type theY: const int
        :rtype: int

        """
        return _OpenGl.OpenGl_TileSampler_TileArea(self, *args)


    def GrabVarianceMap(self, *args):
        """
        GrabVarianceMap(OpenGl_TileSampler self, Handle_OpenGl_Context theContext)

        Fetches current error estimation from the GPU and
        builds 2D discrete distribution for tile sampling.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_TileSampler_GrabVarianceMap(self, *args)


    def Sample(self, *args):
        """
        Sample(OpenGl_TileSampler self)

        Samples tile location according to estimated error.

        :type theOffsetX: int &
        :type theOffsetY: int &

        """
        return _OpenGl.OpenGl_TileSampler_Sample(self, *args)


    def Reset(self, *args):
        """
        Reset(OpenGl_TileSampler self)

        Resets tile sampler to initial state.


        """
        return _OpenGl.OpenGl_TileSampler_Reset(self, *args)


    def Upload(self, *args):
        """
        Upload(OpenGl_TileSampler self, Handle_OpenGl_Context theContext, Handle_OpenGl_Texture theTexture, int const theNbTilesX, int const theNbTilesY, bool const theAdaptive)

        Uploads offsets of sampled tiles to the given OpenGL texture.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTexture: OCC.wrapper.OpenGl.Handle_OpenGl_Texture
        :type theNbTilesX: const int
        :type theNbTilesY: const int
        :type theAdaptive: const bool

        """
        return _OpenGl.OpenGl_TileSampler_Upload(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_TileSampler
OpenGl_TileSampler_swigregister = _OpenGl.OpenGl_TileSampler_swigregister
OpenGl_TileSampler_swigregister(OpenGl_TileSampler)

def OpenGl_TileSampler_TileSize(*args):
    """
    OpenGl_TileSampler_TileSize() -> int

    Size of individual tile in pixels.

    :rtype: int

    """
    return _OpenGl.OpenGl_TileSampler_TileSize(*args)

class Handle_OpenGl_Structure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Structure self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Structure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Structure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Structure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Structure self, OpenGl_Structure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Structure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Structure self, Handle_OpenGl_Structure theHandle) -> Handle_OpenGl_Structure
        assign(Handle_OpenGl_Structure self, OpenGl_Structure thePtr) -> Handle_OpenGl_Structure
        assign(Handle_OpenGl_Structure self, Handle_OpenGl_Structure theHandle) -> Handle_OpenGl_Structure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Structure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Structure self) -> OpenGl_Structure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Structure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Structure self) -> OpenGl_Structure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Structure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Structure self) -> OpenGl_Structure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Structure___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Structure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Structure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Structure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Structure_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Structure

    def OnVisibilityChanged(self, *args):
        """
        OnVisibilityChanged(Handle_OpenGl_Structure self)

        Setup structure graphic state


        """
        return _OpenGl.Handle_OpenGl_Structure_OnVisibilityChanged(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_OpenGl_Structure self)
        Clear(Handle_OpenGl_Structure self, Handle_OpenGl_Context theGlCtx)

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Structure_Clear(self, *args)


    def Connect(self, *args):
        """
        Connect(Handle_OpenGl_Structure self, Graphic3d_CStructure theStructure)

        Connect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_Structure_Connect(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(Handle_OpenGl_Structure self, Graphic3d_CStructure theStructure)

        Disconnect other structure to this one

        :type theStructure: OCC.wrapper.Graphic3d.Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_Structure_Disconnect(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Handle_OpenGl_Structure self, Handle_Geom_Transformation theTrsf)

        Synchronize structure transformation

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _OpenGl.Handle_OpenGl_Structure_SetTransformation(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_OpenGl_Structure self, Handle_Graphic3d_TransformPers theTrsfPers)

        Set transformation persistence.

        :type theTrsfPers: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        return _OpenGl.Handle_OpenGl_Structure_SetTransformPersistence(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_OpenGl_Structure self, Graphic3d_ZLayerId const theLayerIndex)

        Set z layer ID to display the structure in specified layer

        :type theLayerIndex: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_Structure_SetZLayer(self, *args)


    def GraphicHighlight(self, *args):
        """
        GraphicHighlight(Handle_OpenGl_Structure self, Handle_Graphic3d_PresentationAttributes theStyle, Handle_Graphic3d_Structure theStruct)

        Highlights structure according to the given style and updates corresponding class fields
        (highlight status and style)

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes
        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure

        """
        return _OpenGl.Handle_OpenGl_Structure_GraphicHighlight(self, *args)


    def GraphicUnhighlight(self, *args):
        """
        GraphicUnhighlight(Handle_OpenGl_Structure self)

        Unighlights structure and updates corresponding class fields (highlight status and style)


        """
        return _OpenGl.Handle_OpenGl_Structure_GraphicUnhighlight(self, *args)


    def ShadowLink(self, *args):
        """
        ShadowLink(Handle_OpenGl_Structure self, Handle_Graphic3d_StructureManager theManager) -> Handle_Graphic3d_CStructure

        Create shadow link to this structure

        :type theManager: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CStructure

        """
        return _OpenGl.Handle_OpenGl_Structure_ShadowLink(self, *args)


    def NewGroup(self, *args):
        """
        NewGroup(Handle_OpenGl_Structure self, Handle_Graphic3d_Structure theStruct) -> Handle_Graphic3d_Group

        Create new group within this structure

        :type theStruct: OCC.wrapper.Graphic3d.Handle_Graphic3d_Structure
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.Handle_OpenGl_Structure_NewGroup(self, *args)


    def RemoveGroup(self, *args):
        """
        RemoveGroup(Handle_OpenGl_Structure self, Handle_Graphic3d_Group theGroup)

        Remove group from this structure

        :type theGroup: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group

        """
        return _OpenGl.Handle_OpenGl_Structure_RemoveGroup(self, *args)


    def GlDriver(self, *args):
        """
        GlDriver(Handle_OpenGl_Structure self) -> OpenGl_GraphicDriver

        Access graphic driver

        :rtype: OCC.wrapper.OpenGl.OpenGl_GraphicDriver

        """
        return _OpenGl.Handle_OpenGl_Structure_GlDriver(self, *args)


    def SetCulled(self, *args):
        """
        SetCulled(Handle_OpenGl_Structure self, Standard_Boolean theIsCulled)

        Marks structure as culled/not culled - note that IsAlwaysRendered() is ignored here!

        :type theIsCulled: bool

        """
        return _OpenGl.Handle_OpenGl_Structure_SetCulled(self, *args)


    def MarkAsNotCulled(self, *args):
        """
        MarkAsNotCulled(Handle_OpenGl_Structure self)

        Marks structure as overlapping the current view volume one.
        The method is called during traverse of BVH tree.


        """
        return _OpenGl.Handle_OpenGl_Structure_MarkAsNotCulled(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(Handle_OpenGl_Structure self) -> Standard_Boolean

        Returns Standard_False if the structure hits the current view volume, otherwise
        returns Standard_True. The default value for all structures before each traverse
        of BVH tree is Standard_True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Structure_IsCulled(self, *args)


    def IsAlwaysRendered(self, *args):
        """
        IsAlwaysRendered(Handle_OpenGl_Structure self) -> Standard_Boolean

        Checks if the structure should be included into BVH tree or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Structure_IsAlwaysRendered(self, *args)


    def ReleaseGlResources(self, *args):
        """
        ReleaseGlResources(Handle_OpenGl_Structure self, Handle_OpenGl_Context theGlCtx)

        This method releases GL resources without actual elements destruction.
        As result structure could be correctly destroyed layer without GL context
        (after last window was closed for example).

        Notice however that reusage of this structure after calling this method is incorrect
        and will lead to broken visualization due to loosed data.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Structure_ReleaseGlResources(self, *args)


    def InstancedStructure(self, *args):
        """
        InstancedStructure(Handle_OpenGl_Structure self) -> OpenGl_Structure

        Returns instanced OpenGL structure.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Structure

        """
        return _OpenGl.Handle_OpenGl_Structure_InstancedStructure(self, *args)


    def ModificationState(self, *args):
        """
        ModificationState(Handle_OpenGl_Structure self) -> Standard_Size

        Returns structure modification state (for ray-tracing).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Structure_ModificationState(self, *args)


    def ResetModificationState(self, *args):
        """
        ResetModificationState(Handle_OpenGl_Structure self)

        Resets structure modification state (for ray-tracing).


        """
        return _OpenGl.Handle_OpenGl_Structure_ResetModificationState(self, *args)


    def updateLayerTransformation(self, *args):
        """
        updateLayerTransformation(Handle_OpenGl_Structure self)

        Update render transformation matrix.


        """
        return _OpenGl.Handle_OpenGl_Structure_updateLayerTransformation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Structure self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Structure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Structure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Structure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GraphicDriver(self, *args):
        """
        @return graphic driver created this structure

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_GraphicDriver

        """
        res = _OpenGl.Handle_OpenGl_Structure_GraphicDriver(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Groups(self, *args):
        """
        @return graphic groups

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfGroup

        """
        res = _OpenGl.Handle_OpenGl_Structure_Groups(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _OpenGl.Handle_OpenGl_Structure_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformPersistence(self, *args):
        """
        Return transformation persistence.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _OpenGl.Handle_OpenGl_Structure_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClipPlanes(self, *args):
        """
        @return associated clip planes

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _OpenGl.Handle_OpenGl_Structure_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_OpenGl_Structure self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Pass clip planes to the associated graphic driver structure

        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.Handle_OpenGl_Structure_SetClipPlanes(self, *args)


    def BoundingBox(self, *args):
        """
        @return bounding box of this presentation

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox3d

        """
        res = _OpenGl.Handle_OpenGl_Structure_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBoundingBox(self, *args):
        """
        ChangeBoundingBox(Handle_OpenGl_Structure self) -> BVH_Box_Standard_Real_

        @return bounding box of this presentation
        without transformation matrix applied

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_BndBox3d

        """
        return _OpenGl.Handle_OpenGl_Structure_ChangeBoundingBox(self, *args)


    def IsVisible(self, *args):
        """
        IsVisible(Handle_OpenGl_Structure self) -> bool
        IsVisible(Handle_OpenGl_Structure self, Standard_Integer const theViewId) -> bool

        Return structure visibility considering both View Affinity and global visibility state.

        :type theViewId: int
        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Structure_IsVisible(self, *args)


    def ZLayer(self, *args):
        """
        ZLayer(Handle_OpenGl_Structure self) -> Graphic3d_ZLayerId

        Get z layer ID

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _OpenGl.Handle_OpenGl_Structure_ZLayer(self, *args)


    def HighlightStyle(self, *args):
        """
        Returns valid handle to highlight style of the structure in case if
        highlight flag is set to true

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        res = _OpenGl.Handle_OpenGl_Structure_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Structure self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Structure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Structure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Structure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Structure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Structure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Structure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Structure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Structure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Structure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Structure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Structure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Structure self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Structure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Structure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Structure_DecrementRefCounter(self, *args)

Handle_OpenGl_Structure_swigregister = _OpenGl.Handle_OpenGl_Structure_swigregister
Handle_OpenGl_Structure_swigregister(Handle_OpenGl_Structure)

def Handle_OpenGl_Structure_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Structure_DownCast(thing)
Handle_OpenGl_Structure_DownCast = _OpenGl.Handle_OpenGl_Structure_DownCast

class Handle_OpenGl_Layer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Layer self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Layer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Layer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Layer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Layer self, OpenGl_Layer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Layer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Layer self, Handle_OpenGl_Layer theHandle) -> Handle_OpenGl_Layer
        assign(Handle_OpenGl_Layer self, OpenGl_Layer thePtr) -> Handle_OpenGl_Layer
        assign(Handle_OpenGl_Layer self, Handle_OpenGl_Layer theHandle) -> Handle_OpenGl_Layer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Layer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Layer self) -> OpenGl_Layer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Layer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Layer self) -> OpenGl_Layer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Layer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Layer self) -> OpenGl_Layer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Layer___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Layer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Layer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Layer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Layer_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Layer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Layer self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Layer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Layer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Layer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FrustumCullingBVHBuilder(self, *args):
        """
        Returns BVH tree builder for frustom culling.

        :rtype: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        res = _OpenGl.Handle_OpenGl_Layer_FrustumCullingBVHBuilder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFrustumCullingBVHBuilder(self, *args):
        """
        SetFrustumCullingBVHBuilder(Handle_OpenGl_Layer self, Handle_Select3D_BVHBuilder3d theBuilder)

        Assigns BVH tree builder for frustom culling.

        :type theBuilder: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        return _OpenGl.Handle_OpenGl_Layer_SetFrustumCullingBVHBuilder(self, *args)


    def IsImmediate(self, *args):
        """
        IsImmediate(Handle_OpenGl_Layer self) -> Standard_Boolean

        Return true if layer was marked with immediate flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Layer_IsImmediate(self, *args)


    def LayerSettings(self, *args):
        """
        Returns settings of the layer object.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        res = _OpenGl.Handle_OpenGl_Layer_LayerSettings(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbStructures(self, *args):
        """
        NbStructures(Handle_OpenGl_Layer self) -> Standard_Integer

        @return the number of structures

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_NbStructures(self, *args)


    def NbStructuresNotCulled(self, *args):
        """
        NbStructuresNotCulled(Handle_OpenGl_Layer self) -> Standard_Integer

        Number of NOT culled structures in the layer.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_NbStructuresNotCulled(self, *args)


    def NbPriorities(self, *args):
        """
        NbPriorities(Handle_OpenGl_Layer self) -> Standard_Integer

        Returns the number of available priority levels

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_NbPriorities(self, *args)


    def ArrayOfStructures(self, *args):
        """
        Returns array of OpenGL structures.

        :rtype: OCC.wrapper.OpenGl.OpenGl_ArrayOfIndexedMapOfStructure

        """
        res = _OpenGl.Handle_OpenGl_Layer_ArrayOfStructures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InvalidateBoundingBox(self, *args):
        """
        InvalidateBoundingBox(Handle_OpenGl_Layer self)

        Marks cached bounding box as obsolete.


        """
        return _OpenGl.Handle_OpenGl_Layer_InvalidateBoundingBox(self, *args)


    def IsCulled(self, *args):
        """
        IsCulled(Handle_OpenGl_Layer self) -> bool

        Returns TRUE if layer is empty or has been discarded entirely by culling test.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Layer_IsCulled(self, *args)


    def NbOfTransformPersistenceObjects(self, *args):
        """
        NbOfTransformPersistenceObjects(Handle_OpenGl_Layer self) -> Standard_Integer

        Returns number of transform persistence objects.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_NbOfTransformPersistenceObjects(self, *args)


    def CullableStructuresBVH(self, *args):
        """
        Returns set of OpenGl_Structures structures for building BVH tree.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHClipPrimitiveSet

        """
        res = _OpenGl.Handle_OpenGl_Layer_CullableStructuresBVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CullableTrsfPersStructuresBVH(self, *args):
        """
        Returns set of transform persistent OpenGl_Structures for building BVH tree.

        :rtype: OCC.wrapper.OpenGl.OpenGl_BVHClipPrimitiveTrsfPersSet

        """
        res = _OpenGl.Handle_OpenGl_Layer_CullableTrsfPersStructuresBVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NonCullableStructures(self, *args):
        """
        Returns indexed map of always rendered structures.

        :rtype: OCC.wrapper.OpenGl.NCollection_IndexedMap_OpenGl_Structure

        """
        res = _OpenGl.Handle_OpenGl_Layer_NonCullableStructures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Layer self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Layer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Layer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Layer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Layer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Layer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Layer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Layer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Layer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Layer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Layer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Layer self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Layer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Layer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Layer_DecrementRefCounter(self, *args)

Handle_OpenGl_Layer_swigregister = _OpenGl.Handle_OpenGl_Layer_swigregister
Handle_OpenGl_Layer_swigregister(Handle_OpenGl_Layer)

def Handle_OpenGl_Layer_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Layer_DownCast(thing)
Handle_OpenGl_Layer_DownCast = _OpenGl.Handle_OpenGl_Layer_DownCast


try:
	Select3D_BVHBuilder3d = BVH_Builder_Standard_Real_
except NameError:
	pass # does not exist, probably ignored

class Handle_OpenGl_ShaderObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_ShaderObject self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_ShaderObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_ShaderObject self, OpenGl_ShaderObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_ShaderObject self, Handle_OpenGl_ShaderObject theHandle) -> Handle_OpenGl_ShaderObject
        assign(Handle_OpenGl_ShaderObject self, OpenGl_ShaderObject thePtr) -> Handle_OpenGl_ShaderObject
        assign(Handle_OpenGl_ShaderObject self, Handle_OpenGl_ShaderObject theHandle) -> Handle_OpenGl_ShaderObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_ShaderObject self) -> OpenGl_ShaderObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_ShaderObject self) -> OpenGl_ShaderObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_ShaderObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_ShaderObject self) -> OpenGl_ShaderObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_ShaderObject___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_ShaderObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_ShaderObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_ShaderObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_ShaderObject_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_ShaderObject

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_ShaderObject self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_ShaderObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LoadSource(self, *args):
        """
        LoadSource(Handle_OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theSource) -> Standard_Boolean

        Loads shader source code.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theSource: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_LoadSource(self, *args)


    def Compile(self, *args):
        """
        Compile(Handle_OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Compiles the shader object.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Compile(self, *args)


    def FetchInfoLog(self, *args):
        """
        FetchInfoLog(Handle_OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx, TCollection_AsciiString theLog) -> Standard_Boolean

        Fetches information log of the last compile operation.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theLog: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_FetchInfoLog(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_ShaderObject self, Handle_OpenGl_Context theCtx) -> Standard_Boolean

        Creates new empty shader object of specified type.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Create(self, *args)


    def Release(self, *args):
        """
        Release(Handle_OpenGl_ShaderObject self, OpenGl_Context theCtx)

        Destroys shader object.

        :type theCtx: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_ShaderObject self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_EstimatedDataSize(self, *args)


    def Type(self, *args):
        """
        Type(Handle_OpenGl_ShaderObject self) -> GLenum

        Returns type of shader object.

        :rtype: GLenum

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Type(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_ShaderObject self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_ShaderObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_ShaderObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_ShaderObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_ShaderObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_ShaderObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_ShaderObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_ShaderObject self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_ShaderObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_ShaderObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_ShaderObject_DecrementRefCounter(self, *args)

Handle_OpenGl_ShaderObject_swigregister = _OpenGl.Handle_OpenGl_ShaderObject_swigregister
Handle_OpenGl_ShaderObject_swigregister(Handle_OpenGl_ShaderObject)

def Handle_OpenGl_ShaderObject_DownCast(thing):
    return _OpenGl.Handle_OpenGl_ShaderObject_DownCast(thing)
Handle_OpenGl_ShaderObject_DownCast = _OpenGl.Handle_OpenGl_ShaderObject_DownCast

class OpenGl_MaterialState(OpenGl_StateInterface):
    """Defines generic state of material properties."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_MaterialState self, OpenGl_Material const & theFrontMat, OpenGl_Material const & theBackMat, float const theAlphaCutoff, bool const theToDistinguish, bool const theToMapTexture)

        Sets new material aspect.

        :type theFrontMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theBackMat: OCC.wrapper.OpenGl.OpenGl_Material
        :type theAlphaCutoff: const float
        :type theToDistinguish: const bool
        :type theToMapTexture: const bool

        """
        return _OpenGl.OpenGl_MaterialState_Set(self, *args)


    def FrontMaterial(self, *args):
        """
        Return front material.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Material

        """
        res = _OpenGl.OpenGl_MaterialState_FrontMaterial(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BackMaterial(self, *args):
        """
        Return back material.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Material

        """
        res = _OpenGl.OpenGl_MaterialState_BackMaterial(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AlphaCutoff(self, *args):
        """
        AlphaCutoff(OpenGl_MaterialState self) -> float

        Alpha cutoff value.

        :rtype: float

        """
        return _OpenGl.OpenGl_MaterialState_AlphaCutoff(self, *args)


    def ToDistinguish(self, *args):
        """
        ToDistinguish(OpenGl_MaterialState self) -> bool

        Distinguish front/back flag.

        :rtype: bool

        """
        return _OpenGl.OpenGl_MaterialState_ToDistinguish(self, *args)


    def ToMapTexture(self, *args):
        """
        ToMapTexture(OpenGl_MaterialState self) -> bool

        Flag for mapping a texture.

        :rtype: bool

        """
        return _OpenGl.OpenGl_MaterialState_ToMapTexture(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_MaterialState
OpenGl_MaterialState_swigregister = _OpenGl.OpenGl_MaterialState_swigregister
OpenGl_MaterialState_swigregister(OpenGl_MaterialState)

class OpenGl_RaytraceLight(object):
    """Stores properties of OpenGL light source."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_RaytraceLight self) -> OpenGl_RaytraceLight

        Creates new light source.


        """
        this = _OpenGl.new_OpenGl_RaytraceLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Packed(self, *args):
        """
        Packed(OpenGl_RaytraceLight self) -> Standard_ShortReal const *

        Returns packed (serialized) representation of light source.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _OpenGl.OpenGl_RaytraceLight_Packed(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_RaytraceLight
OpenGl_RaytraceLight_swigregister = _OpenGl.OpenGl_RaytraceLight_swigregister
OpenGl_RaytraceLight_swigregister(OpenGl_RaytraceLight)

class Handle_OpenGl_RaytraceFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_RaytraceFilter self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_RaytraceFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_RaytraceFilter self, OpenGl_RaytraceFilter * thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_RaytraceFilter self, Handle_OpenGl_RaytraceFilter theHandle) -> Handle_OpenGl_RaytraceFilter
        assign(Handle_OpenGl_RaytraceFilter self, OpenGl_RaytraceFilter const * thePtr) -> Handle_OpenGl_RaytraceFilter
        assign(Handle_OpenGl_RaytraceFilter self, Handle_OpenGl_RaytraceFilter theHandle) -> Handle_OpenGl_RaytraceFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_RaytraceFilter self) -> OpenGl_RaytraceFilter *

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_RaytraceFilter self) -> OpenGl_RaytraceFilter *

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_RaytraceFilter self) -> OpenGl_RaytraceFilter &

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_RaytraceFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_RaytraceFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_RaytraceFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_RaytraceFilter_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_RaytraceFilter

    def PrevRenderFilter(self, *args):
        """
        Returns the previously set filter.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        res = _OpenGl.Handle_OpenGl_RaytraceFilter_PrevRenderFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrevRenderFilter(self, *args):
        """
        SetPrevRenderFilter(Handle_OpenGl_RaytraceFilter self, Handle_OpenGl_RenderFilter theFilter)

        Remembers the previously set filter.

        :type theFilter: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_SetPrevRenderFilter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_RaytraceFilter self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_RaytraceFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_RaytraceFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShouldRender(self, *args):
        """
        ShouldRender(Handle_OpenGl_RaytraceFilter self, Handle_OpenGl_Workspace theWorkspace, OpenGl_Element const * theElement) -> Standard_Boolean

        Checks whether the element can be rendered or not.
        @param theWorkspace [in] the current workspace.
        @param theElement [in] the element to check.
        @return True if element can be rendered.

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace
        :type theElement: OCC.wrapper.OpenGl.OpenGl_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_ShouldRender(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_RaytraceFilter self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_RaytraceFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_RaytraceFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_RaytraceFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_RaytraceFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_RaytraceFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_RaytraceFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_RaytraceFilter self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_RaytraceFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_RaytraceFilter_DecrementRefCounter(self, *args)

Handle_OpenGl_RaytraceFilter_swigregister = _OpenGl.Handle_OpenGl_RaytraceFilter_swigregister
Handle_OpenGl_RaytraceFilter_swigregister(Handle_OpenGl_RaytraceFilter)

def Handle_OpenGl_RaytraceFilter_DownCast(thing):
    return _OpenGl.Handle_OpenGl_RaytraceFilter_DownCast(thing)
Handle_OpenGl_RaytraceFilter_DownCast = _OpenGl.Handle_OpenGl_RaytraceFilter_DownCast

class OpenGl_WorldViewState(OpenGl_StateInterface):
    """Defines state of OCCT world-view transformation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_WorldViewState self, NCollection_Mat4_Standard_ShortReal theWorldViewMatrix)

        Sets new world-view matrix.

        :type theWorldViewMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_WorldViewState_Set(self, *args)


    def WorldViewMatrix(self, *args):
        """
        Returns current world-view matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_WorldViewState_WorldViewMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorldViewMatrixInverse(self, *args):
        """
        Returns inverse of current world-view matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_WorldViewState_WorldViewMatrixInverse(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_WorldViewState
OpenGl_WorldViewState_swigregister = _OpenGl.OpenGl_WorldViewState_swigregister
OpenGl_WorldViewState_swigregister(OpenGl_WorldViewState)

class OpenGl_Clipping(object):
    """
    This class contains logics related to tracking and modification of clipping plane
    state for particular OpenGl context. It contains information about enabled
    clipping planes and provides method to change clippings in context. The methods
    should be executed within OpenGl context associated with instance of this
    class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_Clipping self) -> OpenGl_Clipping

        Default constructor.


        """
        this = _OpenGl.new_OpenGl_Clipping(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(OpenGl_Clipping self, Standard_Integer const theMaxPlanes)

        Initialize.
        @param theMaxPlanes [in] number of clipping planes supported by OpenGl context.

        :type theMaxPlanes: int

        """
        return _OpenGl.OpenGl_Clipping_Init(self, *args)


    def Reset(self, *args):
        """
        Reset(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Setup list of global (for entire view) clipping planes
        and clears local plane list if it was not released before.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.OpenGl_Clipping_Reset(self, *args)


    def SetLocalPlanes(self, *args):
        """
        SetLocalPlanes(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)

        Setup list of local (for current object) clipping planes.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type thePlanes: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        return _OpenGl.OpenGl_Clipping_SetLocalPlanes(self, *args)


    def IsClippingOn(self, *args):
        """
        IsClippingOn(OpenGl_Clipping self) -> Standard_Boolean

        @return true if there are enabled clipping planes (NOT capping)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Clipping_IsClippingOn(self, *args)


    def IsCappingOn(self, *args):
        """
        IsCappingOn(OpenGl_Clipping self) -> Standard_Boolean

        @return true if there are enabled capping planes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Clipping_IsCappingOn(self, *args)


    def IsClippingOrCappingOn(self, *args):
        """
        IsClippingOrCappingOn(OpenGl_Clipping self) -> Standard_Boolean

        @return true if there are enabled clipping or capping planes

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Clipping_IsClippingOrCappingOn(self, *args)


    def NbClippingOrCappingOn(self, *args):
        """
        NbClippingOrCappingOn(OpenGl_Clipping self) -> Standard_Integer

        @return number of enabled clipping + capping planes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_Clipping_NbClippingOrCappingOn(self, *args)


    def HasDisabled(self, *args):
        """
        HasDisabled(OpenGl_Clipping self) -> Standard_Boolean

        Return true if some clipping planes have been temporarily disabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Clipping_HasDisabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx, OpenGl_ClippingIterator thePlane, Standard_Boolean const theIsEnabled) -> Standard_Boolean

        Disable plane temporarily.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type thePlane: OCC.wrapper.OpenGl.OpenGl_ClippingIterator
        :type theIsEnabled: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.OpenGl_Clipping_SetEnabled(self, *args)


    def DisableGlobal(self, *args):
        """
        DisableGlobal(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx)

        Temporarily disable all planes from the global (view) list, keep only local (object) list.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Clipping_DisableGlobal(self, *args)


    def RestoreDisabled(self, *args):
        """
        RestoreDisabled(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx)

        Restore all temporarily disabled planes.
        Does NOT affect constantly disabled planes Graphic3d_ClipPlane::IsOn().

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        return _OpenGl.OpenGl_Clipping_RestoreDisabled(self, *args)


    def DisableAllExcept(self, *args):
        """
        DisableAllExcept(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx, OpenGl_ClippingIterator thePlane)

        Temporarily disable all planes except specified one.
        Does not affect already disabled planes.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type thePlane: OCC.wrapper.OpenGl.OpenGl_ClippingIterator

        """
        return _OpenGl.OpenGl_Clipping_DisableAllExcept(self, *args)


    def EnableAllExcept(self, *args):
        """
        EnableAllExcept(OpenGl_Clipping self, Handle_OpenGl_Context theGlCtx, OpenGl_ClippingIterator thePlane)

        Enable back planes disabled by ::DisableAllExcept().
        Keeps only specified plane enabled.

        :type theGlCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type thePlane: OCC.wrapper.OpenGl.OpenGl_ClippingIterator

        """
        return _OpenGl.OpenGl_Clipping_EnableAllExcept(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_Clipping
OpenGl_Clipping_swigregister = _OpenGl.OpenGl_Clipping_swigregister
OpenGl_Clipping_swigregister(OpenGl_Clipping)


try:
	OpenGl_BVHTriangulation3f = BVH_Triangulation_Standard_ShortReal_
except NameError:
	pass # does not exist, probably ignored

class OpenGl_TmplCore12_OpenGl_GlCore11(object):
    """OpenGL 1.2 core based on 1.1 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.2 core based on 1.1 version."""
        this = _OpenGl.new_OpenGl_TmplCore12_OpenGl_GlCore11()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore12_OpenGl_GlCore11
OpenGl_TmplCore12_OpenGl_GlCore11_swigregister = _OpenGl.OpenGl_TmplCore12_OpenGl_GlCore11_swigregister
OpenGl_TmplCore12_OpenGl_GlCore11_swigregister(OpenGl_TmplCore12_OpenGl_GlCore11)


try:
	OpenGl_GlCore12 = OpenGl_TmplCore12_OpenGl_GlCore11
except NameError:
	pass # does not exist, probably ignored

class OpenGl_HaltonSampler(object):
    """Compute points of the Halton sequence with with digit-permutations for different bases."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def get_num_dimensions(*args):
        """
        get_num_dimensions() -> unsigned int

        Return the number of supported dimensions.

        :rtype: unsigned int

        """
        return _OpenGl.OpenGl_HaltonSampler_get_num_dimensions(*args)

    get_num_dimensions = staticmethod(get_num_dimensions)

    def initFaure(self, *args):
        """
        initFaure(OpenGl_HaltonSampler self)

        Init the permutation arrays using Faure-permutations.
        Alternatively, initRandom() can be called before the sampling functionality can be used.


        """
        return _OpenGl.OpenGl_HaltonSampler_initFaure(self, *args)


    def sample(self, *args):
        """
        sample(OpenGl_HaltonSampler self, unsigned int theDimension, unsigned int theIndex) -> float

        Return the Halton sample for the given dimension (component) and index.
        The client must have called initRandom or initFaure() at least once before.
        dimension must be smaller than the value returned by get_num_dimensions().

        :type theDimension: unsigned int
        :type theIndex: unsigned int
        :rtype: float

        """
        return _OpenGl.OpenGl_HaltonSampler_sample(self, *args)


    def __init__(self):
        """Compute points of the Halton sequence with with digit-permutations for different bases."""
        this = _OpenGl.new_OpenGl_HaltonSampler()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_HaltonSampler
OpenGl_HaltonSampler_swigregister = _OpenGl.OpenGl_HaltonSampler_swigregister
OpenGl_HaltonSampler_swigregister(OpenGl_HaltonSampler)

def OpenGl_HaltonSampler_get_num_dimensions(*args):
    """
    OpenGl_HaltonSampler_get_num_dimensions() -> unsigned int

    Return the number of supported dimensions.

    :rtype: unsigned int

    """
    return _OpenGl.OpenGl_HaltonSampler_get_num_dimensions(*args)

class OpenGl_StateCounter(object):
    """
    Tool class to implement consistent state counter
    for objects inside the same driver instance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_StateCounter self) -> OpenGl_StateCounter

        Tool class to implement consistent state counter
        for objects inside the same driver instance.
        """
        this = _OpenGl.new_OpenGl_StateCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Increment(self, *args):
        """
        Increment(OpenGl_StateCounter self) -> Standard_Size

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_StateCounter_Increment(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_StateCounter
OpenGl_StateCounter_swigregister = _OpenGl.OpenGl_StateCounter_swigregister
OpenGl_StateCounter_swigregister(OpenGl_StateCounter)

class Handle_OpenGl_Sampler(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Sampler self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Sampler_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Sampler self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Sampler_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Sampler self, OpenGl_Sampler thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Sampler_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Sampler self, Handle_OpenGl_Sampler theHandle) -> Handle_OpenGl_Sampler
        assign(Handle_OpenGl_Sampler self, OpenGl_Sampler thePtr) -> Handle_OpenGl_Sampler
        assign(Handle_OpenGl_Sampler self, Handle_OpenGl_Sampler theHandle) -> Handle_OpenGl_Sampler

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Sampler_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Sampler self) -> OpenGl_Sampler

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Sampler_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Sampler self) -> OpenGl_Sampler

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Sampler___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Sampler self) -> OpenGl_Sampler

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Sampler___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Sampler___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Sampler___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Sampler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Sampler_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Sampler

    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Sampler self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Sampler_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Sampler_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Sampler_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Release(self, *args):
        """
        Release(Handle_OpenGl_Sampler self, OpenGl_Context theContext)

        Destroys object - will release GPU memory if any.

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.Handle_OpenGl_Sampler_Release(self, *args)


    def EstimatedDataSize(self, *args):
        """
        EstimatedDataSize(Handle_OpenGl_Sampler self) -> Standard_Size

        Returns estimated GPU memory usage - not implemented.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.Handle_OpenGl_Sampler_EstimatedDataSize(self, *args)


    def Create(self, *args):
        """
        Create(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theContext) -> Standard_Boolean

        Creates an uninitialized sampler object.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Sampler_Create(self, *args)


    def Init(self, *args):
        """
        Init(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theContext, OpenGl_Texture theTexture) -> Standard_Boolean

        Creates and initializes sampler object.
        Existing object will be reused if possible, however if existing Sampler Object has Immutable flag
        and texture parameters should be re-initialized, then Sampler Object will be recreated.

        :type theContext: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTexture: OCC.wrapper.OpenGl.OpenGl_Texture
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Sampler_Init(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_OpenGl_Sampler self) -> Standard_Boolean

        Returns true if current object was initialized.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Sampler_IsValid(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theCtx)
        Bind(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theUnit)

        Binds sampler object to the given texture unit.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_Sampler_Bind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theCtx)
        Unbind(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theCtx, Graphic3d_TextureUnit const theUnit)

        Unbinds sampler object from the given texture unit.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theUnit: OCC.wrapper.Graphic3d.Graphic3d_TextureUnit

        """
        return _OpenGl.Handle_OpenGl_Sampler_Unbind(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(Handle_OpenGl_Sampler self, Handle_OpenGl_Context theCtx, GLenum theTarget, GLenum theParam, GLint theValue)

        Sets specific sampler parameter.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :type theTarget: GLenum
        :type theParam: GLenum
        :type theValue: GLint

        """
        return _OpenGl.Handle_OpenGl_Sampler_SetParameter(self, *args)


    def SamplerID(self, *args):
        """
        SamplerID(Handle_OpenGl_Sampler self) -> GLuint

        Returns OpenGL sampler ID.

        :rtype: GLuint

        """
        return _OpenGl.Handle_OpenGl_Sampler_SamplerID(self, *args)


    def IsImmutable(self, *args):
        """
        IsImmutable(Handle_OpenGl_Sampler self) -> bool

        Return immutable flag preventing further modifications of sampler parameters, FALSE by default.
        Immutable flag might be set when Sampler Object is used within Bindless Texture.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Sampler_IsImmutable(self, *args)


    def SetImmutable(self, *args):
        """
        SetImmutable(Handle_OpenGl_Sampler self)

        Setup immutable flag. It is not possible unsetting this flag without Sampler destruction.


        """
        return _OpenGl.Handle_OpenGl_Sampler_SetImmutable(self, *args)


    def Parameters(self, *args):
        """
        Returns texture parameters.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        res = _OpenGl.Handle_OpenGl_Sampler_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetParameters(self, *args):
        """
        SetParameters(Handle_OpenGl_Sampler self, Handle_Graphic3d_TextureParams theParams)

        Sets texture parameters.

        :type theParams: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureParams

        """
        return _OpenGl.Handle_OpenGl_Sampler_SetParameters(self, *args)


    def ToUpdateParameters(self, *args):
        """
        ToUpdateParameters(Handle_OpenGl_Sampler self) -> bool

        Returns texture parameters initialization state.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Sampler_ToUpdateParameters(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Sampler self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Sampler_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Sampler self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Sampler self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Sampler_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Sampler self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Sampler self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Sampler_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Sampler self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Sampler_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Sampler self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Sampler_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Sampler self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Sampler_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Sampler self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Sampler_DecrementRefCounter(self, *args)

Handle_OpenGl_Sampler_swigregister = _OpenGl.Handle_OpenGl_Sampler_swigregister
Handle_OpenGl_Sampler_swigregister(Handle_OpenGl_Sampler)

def Handle_OpenGl_Sampler_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Sampler_DownCast(thing)
Handle_OpenGl_Sampler_DownCast = _OpenGl.Handle_OpenGl_Sampler_DownCast

class OpenGl_TmplCore12_OpenGl_GlCore11Fwd(object):
    """OpenGL 1.2 core based on 1.1 version."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """OpenGL 1.2 core based on 1.1 version."""
        this = _OpenGl.new_OpenGl_TmplCore12_OpenGl_GlCore11Fwd()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OpenGl.delete_OpenGl_TmplCore12_OpenGl_GlCore11Fwd
OpenGl_TmplCore12_OpenGl_GlCore11Fwd_swigregister = _OpenGl.OpenGl_TmplCore12_OpenGl_GlCore11Fwd_swigregister
OpenGl_TmplCore12_OpenGl_GlCore11Fwd_swigregister(OpenGl_TmplCore12_OpenGl_GlCore11Fwd)


try:
	OpenGl_GlCore12Fwd = OpenGl_TmplCore12_OpenGl_GlCore11Fwd
except NameError:
	pass # does not exist, probably ignored

class OpenGl_LayerList(object):
    """Class defining the list of layers."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbPriorities(self, *args):
        """
        NbPriorities(OpenGl_LayerList self) -> Standard_Integer

        Method returns the number of available priorities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_LayerList_NbPriorities(self, *args)


    def NbStructures(self, *args):
        """
        NbStructures(OpenGl_LayerList self) -> Standard_Integer

        Number of displayed structures

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_LayerList_NbStructures(self, *args)


    def NbImmediateStructures(self, *args):
        """
        NbImmediateStructures(OpenGl_LayerList self) -> Standard_Integer

        Return number of structures within immediate layers

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_LayerList_NbImmediateStructures(self, *args)


    def Layers(self, *args):
        """
        Returns the set of OpenGL Z-layers.

        :rtype: OCC.wrapper.OpenGl.OpenGl_SequenceOfLayers

        """
        res = _OpenGl.OpenGl_LayerList_Layers(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LayerIDs(self, *args):
        """
        Returns the map of Z-layer IDs to indexes.

        :rtype: OCC.wrapper.OpenGl.OpenGl_LayerSeqIds

        """
        res = _OpenGl.OpenGl_LayerList_LayerIDs(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModificationStateOfRaytracable(self, *args):
        """
        ModificationStateOfRaytracable(OpenGl_LayerList self) -> Standard_Size

        Returns structure modification state (for ray-tracing).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OpenGl.OpenGl_LayerList_ModificationStateOfRaytracable(self, *args)


    def FrustumCullingBVHBuilder(self, *args):
        """
        Returns BVH tree builder for frustom culling.

        :rtype: OCC.wrapper.OpenGl.Handle_Select3D_BVHBuilder3d

        """
        res = _OpenGl.OpenGl_LayerList_FrustumCullingBVHBuilder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_LayerList
OpenGl_LayerList_swigregister = _OpenGl.OpenGl_LayerList_swigregister
OpenGl_LayerList_swigregister(OpenGl_LayerList)

class Handle_OpenGl_Window(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Window self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Window_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Window self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Window_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Window self, OpenGl_Window thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Window_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Window self, Handle_OpenGl_Window theHandle) -> Handle_OpenGl_Window
        assign(Handle_OpenGl_Window self, OpenGl_Window thePtr) -> Handle_OpenGl_Window
        assign(Handle_OpenGl_Window self, Handle_OpenGl_Window theHandle) -> Handle_OpenGl_Window

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Window_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Window self) -> OpenGl_Window

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Window_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Window self) -> OpenGl_Window

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Window___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Window self) -> OpenGl_Window

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Window___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Window___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Window___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Window(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Window_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Window

    def Resize(self, *args):
        """
        Resize(Handle_OpenGl_Window self)

        Resizes the window.


        """
        return _OpenGl.Handle_OpenGl_Window_Resize(self, *args)


    def PlatformWindow(self, *args):
        """
        PlatformWindow(Handle_OpenGl_Window self) -> Handle_Aspect_Window

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _OpenGl.Handle_OpenGl_Window_PlatformWindow(self, *args)


    def Width(self, *args):
        """
        Width(Handle_OpenGl_Window self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Window_Width(self, *args)


    def Height(self, *args):
        """
        Height(Handle_OpenGl_Window self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Window_Height(self, *args)


    def GetGlContext(self, *args):
        """
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.Handle_OpenGl_Window_GetGlContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_OpenGl_Window self)

        Activates GL context and setup viewport.


        """
        return _OpenGl.Handle_OpenGl_Window_Init(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_OpenGl_Window self) -> Standard_Boolean

        Makes GL context for this window active in current thread

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Window_Activate(self, *args)


    def SetSwapInterval(self, *args):
        """
        SetSwapInterval(Handle_OpenGl_Window self)

        Sets swap interval for this window according to the context's settings.


        """
        return _OpenGl.Handle_OpenGl_Window_SetSwapInterval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Window self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Window_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Window_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Window_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Window self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Window_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Window self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Window self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Window_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Window self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Window self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Window_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Window self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Window_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Window self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Window_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Window self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Window_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Window self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Window_DecrementRefCounter(self, *args)

Handle_OpenGl_Window_swigregister = _OpenGl.Handle_OpenGl_Window_swigregister
Handle_OpenGl_Window_swigregister(Handle_OpenGl_Window)

def Handle_OpenGl_Window_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Window_DownCast(thing)
Handle_OpenGl_Window_DownCast = _OpenGl.Handle_OpenGl_Window_DownCast

class OpenGl_AspectText(object):
    """Text representation parameters"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_AspectText self) -> OpenGl_AspectText
        __init__(OpenGl_AspectText self, Handle_Graphic3d_AspectText3d theAspect) -> OpenGl_AspectText

        Create and assign parameters.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        this = _OpenGl.new_OpenGl_AspectText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Aspect(self, *args):
        """
        Return text aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        res = _OpenGl.OpenGl_AspectText_Aspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAspect(self, *args):
        """
        SetAspect(OpenGl_AspectText self, Handle_Graphic3d_AspectText3d theAspect)

        Assign new parameters.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _OpenGl.OpenGl_AspectText_SetAspect(self, *args)


    def ShaderProgramRes(self, *args):
        """
        Init and return OpenGl shader program resource.
        @return shader program resource.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.OpenGl_AspectText_ShaderProgramRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Render(self, *args):
        """
        Render(OpenGl_AspectText self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_AspectText_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_AspectText self, OpenGl_Context theContext)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_AspectText_Release(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_AspectText
OpenGl_AspectText_swigregister = _OpenGl.OpenGl_AspectText_swigregister
OpenGl_AspectText_swigregister(OpenGl_AspectText)

class OpenGl_ClippingIterator(object):
    """The iterator through clipping planes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_ClippingIterator self, OpenGl_Clipping theClipping) -> OpenGl_ClippingIterator

        Main constructor.

        :type theClipping: OCC.wrapper.OpenGl.OpenGl_Clipping

        """
        this = _OpenGl.new_OpenGl_ClippingIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(OpenGl_ClippingIterator self) -> bool

        Return true if iterator points to the valid clipping plane.

        :rtype: bool

        """
        return _OpenGl.OpenGl_ClippingIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(OpenGl_ClippingIterator self)

        Go to the next clipping plane.


        """
        return _OpenGl.OpenGl_ClippingIterator_Next(self, *args)


    def IsDisabled(self, *args):
        """
        IsDisabled(OpenGl_ClippingIterator self) -> bool

        Return true if plane has been temporarily disabled
        either by Graphic3d_ClipPlane->IsOn() property or by temporary filter.

        :rtype: bool

        """
        return _OpenGl.OpenGl_ClippingIterator_IsDisabled(self, *args)


    def Value(self, *args):
        """
        Return the plane at current iterator position.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        res = _OpenGl.OpenGl_ClippingIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsGlobal(self, *args):
        """
        IsGlobal(OpenGl_ClippingIterator self) -> bool

        Return true if plane from the global (view) list.

        :rtype: bool

        """
        return _OpenGl.OpenGl_ClippingIterator_IsGlobal(self, *args)


    def PlaneIndex(self, *args):
        """
        PlaneIndex(OpenGl_ClippingIterator self) -> Standard_Integer

        Return the plane index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.OpenGl_ClippingIterator_PlaneIndex(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_ClippingIterator
OpenGl_ClippingIterator_swigregister = _OpenGl.OpenGl_ClippingIterator_swigregister
OpenGl_ClippingIterator_swigregister(OpenGl_ClippingIterator)

class OpenGl_AspectFace(object):
    """The element holding Graphic3d_AspectFillArea3d."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OpenGl_AspectFace self) -> OpenGl_AspectFace
        __init__(OpenGl_AspectFace self, Handle_Graphic3d_AspectFillArea3d theAspect) -> OpenGl_AspectFace

        Create and assign parameters.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        this = _OpenGl.new_OpenGl_AspectFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Aspect(self, *args):
        """
        Return aspect.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        res = _OpenGl.OpenGl_AspectFace_Aspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAspect(self, *args):
        """
        SetAspect(OpenGl_AspectFace self, Handle_Graphic3d_AspectFillArea3d theAspect)

        Assign parameters.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _OpenGl.OpenGl_AspectFace_SetAspect(self, *args)


    def SetAspectEdge(self, *args):
        """
        SetAspectEdge(OpenGl_AspectFace self, OpenGl_AspectLine theAspectEdge)

        Set edge aspect.

        :type theAspectEdge: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.OpenGl_AspectFace_SetAspectEdge(self, *args)


    def AspectEdge(self, *args):
        """
        AspectEdge(OpenGl_AspectFace self) -> OpenGl_AspectLine

        @return edge aspect.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.OpenGl_AspectFace_AspectEdge(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(OpenGl_AspectFace self) -> Graphic3d_TypeOfShadingModel

        Returns Shading Model.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _OpenGl.OpenGl_AspectFace_ShadingModel(self, *args)


    def SetNoLighting(self, *args):
        """
        SetNoLighting(OpenGl_AspectFace self)

        Set if lighting should be disabled or not.


        """
        return _OpenGl.OpenGl_AspectFace_SetNoLighting(self, *args)


    def TextureSet(self, *args):
        """
        Returns textures map.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.OpenGl_AspectFace_TextureSet(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShaderProgramRes(self, *args):
        """
        Init and return OpenGl shader program resource.
        @return shader program resource.

        :type theCtx: OCC.wrapper.OpenGl.Handle_OpenGl_Context
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_ShaderProgram

        """
        res = _OpenGl.OpenGl_AspectFace_ShaderProgramRes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Render(self, *args):
        """
        Render(OpenGl_AspectFace self, Handle_OpenGl_Workspace theWorkspace)

        :type theWorkspace: OCC.wrapper.OpenGl.Handle_OpenGl_Workspace

        """
        return _OpenGl.OpenGl_AspectFace_Render(self, *args)


    def Release(self, *args):
        """
        Release(OpenGl_AspectFace self, OpenGl_Context theContext)

        :type theContext: OCC.wrapper.OpenGl.OpenGl_Context

        """
        return _OpenGl.OpenGl_AspectFace_Release(self, *args)

    __swig_destroy__ = _OpenGl.delete_OpenGl_AspectFace
OpenGl_AspectFace_swigregister = _OpenGl.OpenGl_AspectFace_swigregister
OpenGl_AspectFace_swigregister(OpenGl_AspectFace)

class OpenGl_ProjectionState(OpenGl_StateInterface):
    """Defines state of OCCT projection transformation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Set(self, *args):
        """
        Set(OpenGl_ProjectionState self, NCollection_Mat4_Standard_ShortReal theProjectionMatrix)

        Sets new projection matrix.

        :type theProjectionMatrix: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        return _OpenGl.OpenGl_ProjectionState_Set(self, *args)


    def ProjectionMatrix(self, *args):
        """
        Returns current projection matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_ProjectionState_ProjectionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ProjectionMatrixInverse(self, *args):
        """
        Returns inverse of current projection matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Mat4

        """
        res = _OpenGl.OpenGl_ProjectionState_ProjectionMatrixInverse(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OpenGl.delete_OpenGl_ProjectionState
OpenGl_ProjectionState_swigregister = _OpenGl.OpenGl_ProjectionState_swigregister
OpenGl_ProjectionState_swigregister(OpenGl_ProjectionState)

class Handle_OpenGl_Workspace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OpenGl_Workspace self)

        Nullify the handle


        """
        return _OpenGl.Handle_OpenGl_Workspace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OpenGl_Workspace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Workspace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OpenGl_Workspace self, OpenGl_Workspace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OpenGl.Handle_OpenGl_Workspace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OpenGl_Workspace self, Handle_OpenGl_Workspace theHandle) -> Handle_OpenGl_Workspace
        assign(Handle_OpenGl_Workspace self, OpenGl_Workspace thePtr) -> Handle_OpenGl_Workspace
        assign(Handle_OpenGl_Workspace self, Handle_OpenGl_Workspace theHandle) -> Handle_OpenGl_Workspace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OpenGl.Handle_OpenGl_Workspace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OpenGl_Workspace self) -> OpenGl_Workspace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Workspace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OpenGl_Workspace self) -> OpenGl_Workspace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OpenGl.Handle_OpenGl_Workspace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OpenGl_Workspace self) -> OpenGl_Workspace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OpenGl.Handle_OpenGl_Workspace___ref__(self, *args)


    def __hash__(self):
        return _OpenGl.Handle_OpenGl_Workspace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OpenGl.Handle_OpenGl_Workspace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OpenGl.new_Handle_OpenGl_Workspace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OpenGl.Handle_OpenGl_Workspace_DownCast)
    __swig_destroy__ = _OpenGl.delete_Handle_OpenGl_Workspace

    def Activate(self, *args):
        """
        Activate(Handle_OpenGl_Workspace self) -> Standard_Boolean

        Activate rendering context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_Activate(self, *args)


    def View(self, *args):
        """
        View(Handle_OpenGl_Workspace self) -> OpenGl_View

        :rtype: OCC.wrapper.OpenGl.OpenGl_View

        """
        return _OpenGl.Handle_OpenGl_Workspace_View(self, *args)


    def GetGlContext(self, *args):
        """
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_Context

        """
        res = _OpenGl.Handle_OpenGl_Workspace_GetGlContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FBOCreate(self, *args):
        """
        FBOCreate(Handle_OpenGl_Workspace self, Standard_Integer const theWidth, Standard_Integer const theHeight) -> Handle_OpenGl_FrameBuffer

        :type theWidth: int
        :type theHeight: int
        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.Handle_OpenGl_Workspace_FBOCreate(self, *args)


    def FBORelease(self, *args):
        """
        FBORelease(Handle_OpenGl_Workspace self, Handle_OpenGl_FrameBuffer theFbo)

        :type theFbo: OCC.wrapper.OpenGl.Handle_OpenGl_FrameBuffer

        """
        return _OpenGl.Handle_OpenGl_Workspace_FBORelease(self, *args)


    def Width(self, *args):
        """
        Width(Handle_OpenGl_Workspace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Workspace_Width(self, *args)


    def Height(self, *args):
        """
        Height(Handle_OpenGl_Workspace self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Workspace_Height(self, *args)


    def SetUseZBuffer(self, *args):
        """
        SetUseZBuffer(Handle_OpenGl_Workspace self, Standard_Boolean const theToUse) -> Standard_Boolean

        Setup Z-buffer usage flag (without affecting GL state!).
        Returns previously set flag.

        :type theToUse: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetUseZBuffer(self, *args)


    def UseZBuffer(self, *args):
        """
        UseZBuffer(Handle_OpenGl_Workspace self) -> Standard_Boolean &

        @return true if usage of Z buffer is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_UseZBuffer(self, *args)


    def UseDepthWrite(self, *args):
        """
        UseDepthWrite(Handle_OpenGl_Workspace self) -> Standard_Boolean &

        @return true if depth writing is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_UseDepthWrite(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(Handle_OpenGl_Workspace self) -> Standard_Boolean

        @return true if clipping algorithm enabled

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_IsCullingEnabled(self, *args)


    def ToAllowFaceCulling(self, *args):
        """
        ToAllowFaceCulling(Handle_OpenGl_Workspace self) -> bool

        Return true if active group might activate face culling (e.g. primitives are closed).

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Workspace_ToAllowFaceCulling(self, *args)


    def SetAllowFaceCulling(self, *args):
        """
        SetAllowFaceCulling(Handle_OpenGl_Workspace self, bool theToAllow)

        Allow or disallow face culling.
        This call does NOT affect current state of back face culling;
        ApplyAspectFace() should be called to update state.

        :type theToAllow: bool

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetAllowFaceCulling(self, *args)


    def ToHighlight(self, *args):
        """
        ToHighlight(Handle_OpenGl_Workspace self) -> bool

        Return true if following structures should apply highlight color.

        :rtype: bool

        """
        return _OpenGl.Handle_OpenGl_Workspace_ToHighlight(self, *args)


    def HighlightStyle(self, *args):
        """
        Return highlight style.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        res = _OpenGl.Handle_OpenGl_Workspace_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHighlightStyle(self, *args):
        """
        SetHighlightStyle(Handle_OpenGl_Workspace self, Handle_Graphic3d_PresentationAttributes theStyle)

        Set highlight style.

        :type theStyle: OCC.wrapper.Graphic3d.Handle_Graphic3d_PresentationAttributes

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetHighlightStyle(self, *args)


    def LineColor(self, *args):
        """
        Return line color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_LineColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeColor(self, *args):
        """
        Return edge color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_EdgeColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MarkerColor(self, *args):
        """
        Return marker color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_MarkerColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InteriorColor(self, *args):
        """
        Return Interior color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_InteriorColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextColor(self, *args):
        """
        Return text color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_TextColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextSubtitleColor(self, *args):
        """
        Return text Subtitle color taking into account highlight flag.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Vec4

        """
        res = _OpenGl.Handle_OpenGl_Workspace_TextSubtitleColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AspectLine(self, *args):
        """
        AspectLine(Handle_OpenGl_Workspace self) -> OpenGl_AspectLine

        Currently set line aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.Handle_OpenGl_Workspace_AspectLine(self, *args)


    def AspectFace(self, *args):
        """
        AspectFace(Handle_OpenGl_Workspace self) -> OpenGl_AspectFace

        Currently set face aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.Handle_OpenGl_Workspace_AspectFace(self, *args)


    def AspectMarker(self, *args):
        """
        AspectMarker(Handle_OpenGl_Workspace self) -> OpenGl_AspectMarker

        Currently set marker aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.Handle_OpenGl_Workspace_AspectMarker(self, *args)


    def AspectText(self, *args):
        """
        AspectText(Handle_OpenGl_Workspace self) -> OpenGl_AspectText

        Currently set text aspect (can differ from applied).

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.Handle_OpenGl_Workspace_AspectText(self, *args)


    def SetAspectLine(self, *args):
        """
        SetAspectLine(Handle_OpenGl_Workspace self, OpenGl_AspectLine theAspect) -> OpenGl_AspectLine

        Assign new line aspect (will be applied within ApplyAspectLine()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectLine
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetAspectLine(self, *args)


    def SetAspectFace(self, *args):
        """
        SetAspectFace(Handle_OpenGl_Workspace self, OpenGl_AspectFace theAspect) -> OpenGl_AspectFace

        Assign new face aspect (will be applied within ApplyAspectFace()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectFace
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetAspectFace(self, *args)


    def SetAspectMarker(self, *args):
        """
        SetAspectMarker(Handle_OpenGl_Workspace self, OpenGl_AspectMarker theAspect) -> OpenGl_AspectMarker

        Assign new marker aspect (will be applied within ApplyAspectMarker()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectMarker
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetAspectMarker(self, *args)


    def SetAspectText(self, *args):
        """
        SetAspectText(Handle_OpenGl_Workspace self, OpenGl_AspectText theAspect) -> OpenGl_AspectText

        Assign new text aspect (will be applied within ApplyAspectText()).

        :type theAspect: OCC.wrapper.OpenGl.OpenGl_AspectText
        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetAspectText(self, *args)


    def ApplyAspectLine(self, *args):
        """
        ApplyAspectLine(Handle_OpenGl_Workspace self) -> OpenGl_AspectLine

        Apply line aspect.
        @return aspect set by SetAspectLine()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectLine

        """
        return _OpenGl.Handle_OpenGl_Workspace_ApplyAspectLine(self, *args)


    def ApplyAspectFace(self, *args):
        """
        ApplyAspectFace(Handle_OpenGl_Workspace self) -> OpenGl_AspectFace

        Apply face aspect.
        @return aspect set by SetAspectFace()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        return _OpenGl.Handle_OpenGl_Workspace_ApplyAspectFace(self, *args)


    def ApplyAspectMarker(self, *args):
        """
        ApplyAspectMarker(Handle_OpenGl_Workspace self) -> OpenGl_AspectMarker

        Apply marker aspect.
        @return aspect set by SetAspectMarker()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectMarker

        """
        return _OpenGl.Handle_OpenGl_Workspace_ApplyAspectMarker(self, *args)


    def ApplyAspectText(self, *args):
        """
        ApplyAspectText(Handle_OpenGl_Workspace self) -> OpenGl_AspectText

        Apply text aspect.
        @return aspect set by SetAspectText()

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectText

        """
        return _OpenGl.Handle_OpenGl_Workspace_ApplyAspectText(self, *args)


    def SetRenderFilter(self, *args):
        """
        SetRenderFilter(Handle_OpenGl_Workspace self, Handle_OpenGl_RenderFilter theFilter)

        Set filter for restricting rendering of particular elements.
        Filter can be applied for rendering passes used by recursive
        rendering algorithms for rendering elements of groups.
        @param theFilter [in] the filter instance.

        :type theFilter: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetRenderFilter(self, *args)


    def GetRenderFilter(self, *args):
        """
        Get rendering filter.
        @return filter instance.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_RenderFilter

        """
        res = _OpenGl.Handle_OpenGl_Workspace_GetRenderFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ViewMatrix(self, *args):
        """
        ViewMatrix(Handle_OpenGl_Workspace self) -> OpenGl_Matrix const *

        @return applied view matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.Handle_OpenGl_Workspace_ViewMatrix(self, *args)


    def ModelMatrix(self, *args):
        """
        ModelMatrix(Handle_OpenGl_Workspace self) -> OpenGl_Matrix const *

        @return applied model structure matrix.

        :rtype: OCC.wrapper.OpenGl.OpenGl_Matrix

        """
        return _OpenGl.Handle_OpenGl_Workspace_ModelMatrix(self, *args)


    def FontFaceAspect(self, *args):
        """
        Returns face aspect for textured font rendering.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.Handle_OpenGl_Workspace_FontFaceAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefaultCappingAlgoFilter(self, *args):
        """
        Returns capping algorithm rendering filter.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_CappingAlgoFilter

        """
        res = _OpenGl.Handle_OpenGl_Workspace_DefaultCappingAlgoFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NoneCulling(self, *args):
        """
        Returns face aspect for none culling mode.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.Handle_OpenGl_Workspace_NoneCulling(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FrontCulling(self, *args):
        """
        Returns face aspect for front face culling mode.

        :rtype: OCC.wrapper.OpenGl.OpenGl_AspectFace

        """
        res = _OpenGl.Handle_OpenGl_Workspace_FrontCulling(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEnvironmentTexture(self, *args):
        """
        SetEnvironmentTexture(Handle_OpenGl_Workspace self, Handle_OpenGl_TextureSet theTexture)

        Sets a new environment texture.

        :type theTexture: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        return _OpenGl.Handle_OpenGl_Workspace_SetEnvironmentTexture(self, *args)


    def EnvironmentTexture(self, *args):
        """
        Returns environment texture.

        :rtype: OCC.wrapper.OpenGl.Handle_OpenGl_TextureSet

        """
        res = _OpenGl.Handle_OpenGl_Workspace_EnvironmentTexture(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_OpenGl_Workspace self) -> char const *

        :rtype: const char *

        """
        return _OpenGl.Handle_OpenGl_Workspace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Workspace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OpenGl.Handle_OpenGl_Workspace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_OpenGl_Workspace self)

        Memory deallocator for transient classes


        """
        return _OpenGl.Handle_OpenGl_Workspace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OpenGl_Workspace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OpenGl_Workspace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OpenGl_Workspace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OpenGl_Workspace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OpenGl.Handle_OpenGl_Workspace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OpenGl_Workspace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OpenGl.Handle_OpenGl_Workspace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OpenGl_Workspace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Workspace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OpenGl_Workspace self)

        Increments the reference counter of this object


        """
        return _OpenGl.Handle_OpenGl_Workspace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OpenGl_Workspace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OpenGl.Handle_OpenGl_Workspace_DecrementRefCounter(self, *args)

Handle_OpenGl_Workspace_swigregister = _OpenGl.Handle_OpenGl_Workspace_swigregister
Handle_OpenGl_Workspace_swigregister(Handle_OpenGl_Workspace)

def Handle_OpenGl_Workspace_DownCast(thing):
    return _OpenGl.Handle_OpenGl_Workspace_DownCast(thing)
Handle_OpenGl_Workspace_DownCast = _OpenGl.Handle_OpenGl_Workspace_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2dGcc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2dGcc')
    _Geom2dGcc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dGcc', [dirname(__file__)])
        except ImportError:
            import _Geom2dGcc
            return _Geom2dGcc
        try:
            _mod = imp.load_module('_Geom2dGcc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2dGcc = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dGcc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dGcc.delete_SwigPyIterator

    def value(self):
        return _Geom2dGcc.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2dGcc.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2dGcc.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2dGcc.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2dGcc.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2dGcc.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2dGcc.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2dGcc.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2dGcc.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2dGcc.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2dGcc.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2dGcc.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2dGcc.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2dGcc.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2dGcc.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2dGcc.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2dGcc.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dGcc.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2dGcc.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dGcc.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dGcc.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dGcc.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2dGcc.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2dGcc.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2dGcc.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dGcc.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2dGcc.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dGcc.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dGcc.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dGcc.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2dGcc.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2dGcc.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2dGcc.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2dGcc.ptr_to_number(item)
ptr_to_number = _Geom2dGcc.ptr_to_number

def HashCode(*args):
    return _Geom2dGcc.HashCode(*args)
HashCode = _Geom2dGcc.HashCode

def ptr_equal(a, b):
    return _Geom2dGcc.ptr_equal(a, b)
ptr_equal = _Geom2dGcc.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccEnt
else:
    import GccEnt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccAna
else:
    import GccAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
Geom2dGcc_CuCu = _Geom2dGcc.Geom2dGcc_CuCu
Geom2dGcc_CiCu = _Geom2dGcc.Geom2dGcc_CiCu
Geom2dGcc_CuCuCu = _Geom2dGcc.Geom2dGcc_CuCuCu
Geom2dGcc_CiCuCu = _Geom2dGcc.Geom2dGcc_CiCuCu
Geom2dGcc_CiCiCu = _Geom2dGcc.Geom2dGcc_CiCiCu
Geom2dGcc_CiLiCu = _Geom2dGcc.Geom2dGcc_CiLiCu
Geom2dGcc_LiLiCu = _Geom2dGcc.Geom2dGcc_LiLiCu
Geom2dGcc_LiCuCu = _Geom2dGcc.Geom2dGcc_LiCuCu
Geom2dGcc_CuCuOnCu = _Geom2dGcc.Geom2dGcc_CuCuOnCu
Geom2dGcc_CiCuOnCu = _Geom2dGcc.Geom2dGcc_CiCuOnCu
Geom2dGcc_LiCuOnCu = _Geom2dGcc.Geom2dGcc_LiCuOnCu
Geom2dGcc_CuPtOnCu = _Geom2dGcc.Geom2dGcc_CuPtOnCu
Geom2dGcc_CuCuOnLi = _Geom2dGcc.Geom2dGcc_CuCuOnLi
Geom2dGcc_CiCuOnLi = _Geom2dGcc.Geom2dGcc_CiCuOnLi
Geom2dGcc_LiCuOnLi = _Geom2dGcc.Geom2dGcc_LiCuOnLi
Geom2dGcc_CuPtOnLi = _Geom2dGcc.Geom2dGcc_CuPtOnLi
Geom2dGcc_CuCuOnCi = _Geom2dGcc.Geom2dGcc_CuCuOnCi
Geom2dGcc_CiCuOnCi = _Geom2dGcc.Geom2dGcc_CiCuOnCi
Geom2dGcc_LiCuOnCi = _Geom2dGcc.Geom2dGcc_LiCuOnCi
Geom2dGcc_CuPtOnCi = _Geom2dGcc.Geom2dGcc_CuPtOnCi
class Geom2dGcc_IsParallel(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom2dGcc_IsParallel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom2dGcc_IsParallel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom2dGcc_IsParallel self) -> Geom2dGcc_IsParallel
        __init__(Geom2dGcc_IsParallel self, Standard_CString const theMessage) -> Geom2dGcc_IsParallel

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Geom2dGcc.new_Geom2dGcc_IsParallel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Geom2dGcc_IsParallel

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2dGcc.Handle_Geom2dGcc_IsParallel

        """
        return _Geom2dGcc.Geom2dGcc_IsParallel_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom2dGcc.Geom2dGcc_IsParallel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom2dGcc.Geom2dGcc_IsParallel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2dGcc.Geom2dGcc_IsParallel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_IsParallel
Geom2dGcc_IsParallel_swigregister = _Geom2dGcc.Geom2dGcc_IsParallel_swigregister
Geom2dGcc_IsParallel_swigregister(Geom2dGcc_IsParallel)

def Geom2dGcc_IsParallel_NewInstance(*args):
    """
    Geom2dGcc_IsParallel_NewInstance(Standard_CString const theMessage) -> Handle_Geom2dGcc_IsParallel

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Geom2dGcc.Handle_Geom2dGcc_IsParallel

    """
    return _Geom2dGcc.Geom2dGcc_IsParallel_NewInstance(*args)

def Geom2dGcc_IsParallel_get_type_name(*args):
    """
    Geom2dGcc_IsParallel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom2dGcc.Geom2dGcc_IsParallel_get_type_name(*args)

def Geom2dGcc_IsParallel_get_type_descriptor(*args):
    """
    Geom2dGcc_IsParallel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom2dGcc.Geom2dGcc_IsParallel_get_type_descriptor(*args)

class Geom2dGcc_FunctionTanObl(math.math_FunctionWithDerivative):
    """This class describe a function of a single variable."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanObl self, Geom2dAdaptor_Curve Curve, gp_Dir2d Dir) -> Geom2dGcc_FunctionTanObl

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Dir: OCC.wrapper.gp.gp_Dir2d

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanObl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanObl self, Standard_Real const X) -> Standard_Boolean

        Computes the value of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanObl_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Geom2dGcc_FunctionTanObl self, Standard_Real const X) -> Standard_Boolean

        Computes the derivative of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanObl_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanObl self, Standard_Real const X) -> Standard_Boolean

        Computes the value and the derivative of the function F
        for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanObl_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanObl
Geom2dGcc_FunctionTanObl_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanObl_swigregister
Geom2dGcc_FunctionTanObl_swigregister(Geom2dGcc_FunctionTanObl)

class Geom2dGcc_Circ2d2TanOnGeo(object):
    """
    This class implements the algorithms used to
    create 2d circles TANgent to 2 entities and
    having the center ON a curve.
    The order of the tangency argument is always
    QualifiedCirc, QualifiedLin, QualifiedCurv, Pnt2d.
    the arguments are :
    - The two tangency arguments (lines, circles or points).
    - The center line (a curve).
    - The parameter for each tangency argument which
    is a curve.
    - The tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Point2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, GccEnt_QualifiedLin Qualified1, gp_Pnt2d Qualified2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo
        __init__(Geom2dGcc_Circ2d2TanOnGeo self, gp_Pnt2d Point1, gp_Pnt2d Point2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnGeo

        This method implements the algorithms used to
        create 2d circles TANgent to two points
        having the center ON a 2d line.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type OnCurv: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d2TanOnGeo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d2TanOnGeo self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2d2TanOnGeo self) -> Standard_Integer

        This method returns the number of solutions.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the
        context of the algorithm-object.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index)

        It returns the informations about the qualifiers of
        the tangency
        arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        PntSol is the tangency point on the solution curv.
        PntArg is the tangency point on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        PntSol is the tangency point on the solution curv.
        PntArg is the tangency point on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_Tangency2(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the center (on the curv)
        of the result.
        ParArg is the intrinsic parameter of the point on
        the argument curv.
        PntSol is the center point of the solution curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument and False in the other cases.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d2TanOnGeo self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the second argument and False in the other cases.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_IsTheSame2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d2TanOnGeo
Geom2dGcc_Circ2d2TanOnGeo_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo_swigregister
Geom2dGcc_Circ2d2TanOnGeo_swigregister(Geom2dGcc_Circ2d2TanOnGeo)

class Geom2dGcc_Circ2d2TanRad(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to one curve and a
    point/line/circle/curv and with a given radius.
    For each construction methods arguments are:
    - Two Qualified elements for tangency constrains.
    (for example EnclosedCirc if we want the
    solution inside the argument EnclosedCirc).
    - Two Reals. One (Radius) for the radius and the
    other (Tolerance) for the tolerance.
    Tolerance is only used for the limit cases.
    For example :
    We want to create a circle inside a circle C1 and
    inside a curve Cu2 with a radius Radius and a
    tolerance Tolerance.
    If we did not used Tolerance it is impossible to
    find a solution in the the following case : Cu2 is
    inside C1 and there is no intersection point
    between the two elements.
    with Tolerance we will give a solution if the
    lowest distance between C1 and Cu2 is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d2TanRad self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRad
        __init__(Geom2dGcc_Circ2d2TanRad self, Geom2dGcc_QualifiedCurve Qualified1, Handle_Geom2d_Point Point, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRad
        __init__(Geom2dGcc_Circ2d2TanRad self, Handle_Geom2d_Point Point1, Handle_Geom2d_Point Point2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRad

        These constructors create one or more 2D circles of radius Radius either
        -   tangential to the 2 curves Qualified1 and Qualified2,   or
        -   tangential to the curve Qualified1 and passing through the point Point, or
        -   passing through two points Point1 and Point2.
        Tolerance is a tolerance criterion used by the algorithm
        to find a solution when, mathematically, the problem
        posed does not have a solution, but where there is
        numeric uncertainty attached to the arguments.
        For example, take two circles C1 and C2, such that C2
        is inside C1, and almost tangential to C1. There is, in
        fact, no point of intersection between C1 and C2. You
        now want to find a circle of radius R (smaller than the
        radius of C2), which is tangential to C1 and C2, and
        inside these two circles: a pure mathematical resolution
        will not find a solution. This is where the tolerance
        criterion is used: the algorithm considers that C1 and
        C2 are tangential if the shortest distance between these
        two circles is less than or equal to Tolerance. Thus, a
        solution is found by the algorithm.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosing for a line).
        Standard_NegativeValue if Radius is negative.

        :type Point1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Point2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Radius: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d2TanRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Results(self, *args):
        """
        Results(Geom2dGcc_Circ2d2TanRad self, GccAna_Circ2d2TanRad Circ)
        Results(Geom2dGcc_Circ2d2TanRad self, Geom2dGcc_Circ2d2TanRadGeo Circ)

        :type Circ: OCC.wrapper.Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_Results(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d2TanRad self) -> Standard_Boolean

        This method returns True if the algorithm succeeded.
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2d2TanRad self) -> Standard_Integer

        This method returns the number of solutions.
        NotDone is raised if the algorithm failed.
        Exceptions
        StdFail_NotDone if the construction fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the context of the algorithm-object.
        Warning
        This indexing simply provides a means of consulting the
        solutions. The index values are not associated with
        these solutions outside the context of the algorithm object.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index)

        Returns the qualifiers Qualif1 and Qualif2 of the
        tangency arguments for the solution of index Index
        computed by this algorithm.
        The returned qualifiers are:
        -   those specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        outside with respect to the arguments, or
        -   those computed during construction (i.e. enclosed,
        enclosing or outside) when the solutions are defined
        as unqualified with respect to the arguments, or
        -   GccEnt_noqualifier if the tangency argument is a point, or
        -   GccEnt_unqualified in certain limit cases where it
        is impossible to qualify the solution as enclosed, enclosing or outside.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.
        OutOfRange is raised if Index is greater than the number of solutions.
        notDone is raised if the construction algorithm did not succeed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.
        OutOfRange is raised if Index is greater than the number of solutions.
        notDone is raised if the construction algorithm did not succeed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_Tangency2(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and,
        respectively, the first or second argument of this
        algorithm are the same (i.e. there are 2 identical circles).
        If Rarg is the radius of the first or second argument,
        Rsol is the radius of the solution and dist is the
        distance between the two centers, we consider the two
        circles to be identical if |Rarg - Rsol| and dist
        are less than or equal to the tolerance criterion given at
        the time of construction of this algorithm.
        OutOfRange is raised if Index is greater than the number of solutions.
        notDone is raised if the construction algorithm did not succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d2TanRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and,
        respectively, the first or second argument of this
        algorithm are the same (i.e. there are 2 identical circles).
        If Rarg is the radius of the first or second argument,
        Rsol is the radius of the solution and dist is the
        distance between the two centers, we consider the two
        circles to be identical if |Rarg - Rsol| and dist
        are less than or equal to the tolerance criterion given at
        the time of construction of this algorithm.
        OutOfRange is raised if Index is greater than the number of solutions.
        notDone is raised if the construction algorithm did not succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_IsTheSame2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d2TanRad
Geom2dGcc_Circ2d2TanRad_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d2TanRad_swigregister
Geom2dGcc_Circ2d2TanRad_swigregister(Geom2dGcc_Circ2d2TanRad)

class Geom2dGcc_Lin2d2Tan(object):
    """
    This class implements the algorithms used to
    create 2d lines tangent to 2 other elements which
    can be circles, curves or points.
    More than one argument must be a curve.
    Describes functions for building a 2D line:
    -   tangential to 2 curves, or
    -   tangential to a curve and passing through a point.
    A Lin2d2Tan object provides a framework for:
    -   defining the construction of 2D line(s),
    -   implementing the construction algorithm, and
    -   consulting the result(s).

    Note: Some constructors may check the type of the qualified argument
    and raise BadQualifier Error in case of incorrect couple (qualifier, curv).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Lin2d2Tan self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Standard_Real const Tolang) -> Geom2dGcc_Lin2d2Tan
        __init__(Geom2dGcc_Lin2d2Tan self, Geom2dGcc_QualifiedCurve Qualified1, gp_Pnt2d ThePoint, Standard_Real const Tolang) -> Geom2dGcc_Lin2d2Tan
        __init__(Geom2dGcc_Lin2d2Tan self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Standard_Real const Tolang, Standard_Real const Param1, Standard_Real const Param2) -> Geom2dGcc_Lin2d2Tan
        __init__(Geom2dGcc_Lin2d2Tan self, Geom2dGcc_QualifiedCurve Qualified1, gp_Pnt2d ThePoint, Standard_Real const Tolang, Standard_Real const Param1) -> Geom2dGcc_Lin2d2Tan

        This class implements the algorithms used to create 2d
        lines passing thrue a point and tangent to a curve.
        Tolang is used to determine the tolerance for the tangency points.
        Param2 is used for the initial guess on the curve.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve
        :type ThePoint: OCC.wrapper.gp.gp_Pnt2d
        :type Tolang: float
        :type Param1: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Lin2d2Tan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Lin2d2Tan self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has
        reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Lin2d2Tan self) -> Standard_Integer

        Returns the number of lines, representing solutions computed by this algorithm.
        Exceptions StdFail_NotDone if the construction fails.R

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Lin2d2Tan self, Standard_Integer const Index) -> gp_Lin2d

        Returns a line, representing the solution of index Index computed by this algorithm.
        Warning
        This indexing simply provides a means of consulting the
        solutions. The index values are not associated with
        these solutions outside the context of the algorithm object.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Lin2d2Tan self, Standard_Integer const Index)

        Returns the qualifiers Qualif1 and Qualif2 of the
        tangency arguments for the solution of index Index
        computed by this algorithm.
        The returned qualifiers are:
        -   those specified at the start of construction when the
        solutions are defined as enclosing or outside with
        respect to the arguments, or
        -   those computed during construction (i.e. enclosing or
        outside) when the solutions are defined as unqualified
        with respect to the arguments, or
        -   GccEnt_noqualifier if the tangency argument is a   point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Lin2d2Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Lin2d2Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2Tan_Tangency2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Lin2d2Tan
Geom2dGcc_Lin2d2Tan_swigregister = _Geom2dGcc.Geom2dGcc_Lin2d2Tan_swigregister
Geom2dGcc_Lin2d2Tan_swigregister(Geom2dGcc_Lin2d2Tan)

class Geom2dGcc_FunctionTanCuPnt(math.math_FunctionWithDerivative):
    """
    This abstract class describes a Function of 1 Variable
    used to find a line tangent to a curve and passing
    through a point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanCuPnt self, Geom2dAdaptor_Curve C, gp_Pnt2d Point) -> Geom2dGcc_FunctionTanCuPnt

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Point: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanCuPnt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanCuPnt self, Standard_Real const X) -> Standard_Boolean

        Computes the value of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuPnt_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Geom2dGcc_FunctionTanCuPnt self, Standard_Real const X) -> Standard_Boolean

        Computes the derivative of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuPnt_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanCuPnt self, Standard_Real const X) -> Standard_Boolean

        Computes the value and the derivative of the function F
        for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuPnt_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanCuPnt
Geom2dGcc_FunctionTanCuPnt_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanCuPnt_swigregister
Geom2dGcc_FunctionTanCuPnt_swigregister(Geom2dGcc_FunctionTanCuPnt)

class Handle_Geom2dGcc_IsParallel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom2dGcc_IsParallel self)

        Nullify the handle


        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom2dGcc_IsParallel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom2dGcc_IsParallel self, Geom2dGcc_IsParallel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom2dGcc_IsParallel self, Handle_Geom2dGcc_IsParallel theHandle) -> Handle_Geom2dGcc_IsParallel
        assign(Handle_Geom2dGcc_IsParallel self, Geom2dGcc_IsParallel thePtr) -> Handle_Geom2dGcc_IsParallel
        assign(Handle_Geom2dGcc_IsParallel self, Handle_Geom2dGcc_IsParallel theHandle) -> Handle_Geom2dGcc_IsParallel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom2dGcc_IsParallel self) -> Geom2dGcc_IsParallel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom2dGcc_IsParallel self) -> Geom2dGcc_IsParallel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom2dGcc_IsParallel self) -> Geom2dGcc_IsParallel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel___ref__(self, *args)


    def __hash__(self):
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom2dGcc.Handle_Geom2dGcc_IsParallel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom2dGcc.new_Handle_Geom2dGcc_IsParallel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom2dGcc.Handle_Geom2dGcc_IsParallel_DownCast)
    __swig_destroy__ = _Geom2dGcc.delete_Handle_Geom2dGcc_IsParallel

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Geom2dGcc_IsParallel self, Standard_CString const theMessage) -> Handle_Geom2dGcc_IsParallel

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom2dGcc.Handle_Geom2dGcc_IsParallel

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom2dGcc_IsParallel self) -> char const *

        :rtype: const char *

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2dGcc.Handle_Geom2dGcc_IsParallel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom2dGcc.Handle_Geom2dGcc_IsParallel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Geom2dGcc_IsParallel self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Geom2dGcc_IsParallel self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Geom2dGcc_IsParallel self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Geom2dGcc_IsParallel self)
        Reraise(Handle_Geom2dGcc_IsParallel self, Standard_CString const aMessage)
        Reraise(Handle_Geom2dGcc_IsParallel self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Geom2dGcc_IsParallel self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Geom2dGcc_IsParallel self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom2dGcc_IsParallel self)

        Memory deallocator for transient classes


        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom2dGcc_IsParallel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom2dGcc_IsParallel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom2dGcc_IsParallel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom2dGcc_IsParallel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom2dGcc_IsParallel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom2dGcc_IsParallel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom2dGcc_IsParallel self)

        Increments the reference counter of this object


        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom2dGcc_IsParallel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_DecrementRefCounter(self, *args)

Handle_Geom2dGcc_IsParallel_swigregister = _Geom2dGcc.Handle_Geom2dGcc_IsParallel_swigregister
Handle_Geom2dGcc_IsParallel_swigregister(Handle_Geom2dGcc_IsParallel)

def Handle_Geom2dGcc_IsParallel_DownCast(thing):
    return _Geom2dGcc.Handle_Geom2dGcc_IsParallel_DownCast(thing)
Handle_Geom2dGcc_IsParallel_DownCast = _Geom2dGcc.Handle_Geom2dGcc_IsParallel_DownCast

class Geom2dGcc_Circ2dTanOnRad(object):
    """
    This class implements the algorithms used to
    create a 2d circle tangent to a 2d entity,
    centered on a 2d entity and with a given radius.
    More than one argument must be a curve.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCirc, QualifiedLin, QualifiedCurvPoints).
    - The Center element (circle, line, curve).
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an OutsideCurv Cu1
    centered on a line OnLine with a radius Radius and with
    a tolerance Tolerance.
    If we did not used Tolerance it is impossible to
    find a solution in the the following case : OnLine is
    outside Cu1. There is no intersection point between Cu1
    and OnLine. The distance between the line and the
    circle is greater than Radius.
    With Tolerance we will give a solution if the
    distance between Cu1 and OnLine is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2dTanOnRad self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRad
        __init__(Geom2dGcc_Circ2dTanOnRad self, Handle_Geom2d_Point Point1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRad

        Constructs one or more 2D circles of radius Radius,
        centered on the 2D curve OnCurv and:
        passing through the point Point1.
        OnCurv is an adapted curve, i.e. an object which is an
        interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by the construction algorithm.
        Similarly, the qualified curve Qualified1 is created from
        an adapted curve.
        Adapted curves are created in the following way:
        Handle(Geom2d_Curve) myCurveOn = ... ;
        Geom2dAdaptor_Curve OnCurv ( myCurveOn ) ;
        The algorithm is then constructed with this object:
        Handle(Geom2d_Curve) myCurve1 = ...
        ;
        Geom2dAdaptor_Curve Adapted1 ( myCurve1 ) ;
        Geom2dGcc_QualifiedCurve
        Qualified1 = Geom2dGcc::Outside(Adapted1);
        Standard_Real Radius = ... , Tolerance = ... ;
        Geom2dGcc_Circ2dTanOnRad
        myAlgo ( Qualified1 , OnCurv , Radius , Tolerance ) ;
        if ( myAlgo.IsDone() )
        { Standard_Integer Nbr = myAlgo.NbSolutions() ;
        gp_Circ2d Circ ;
        for ( Standard_Integer i = 1 ;
        i <= nbr ; i++ )
        { Circ = myAlgo.ThisSolution (i) ;
        ...
        }
        }

        :type Point1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type OnCurv: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Radius: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2dTanOnRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Results(self, *args):
        """
        Results(Geom2dGcc_Circ2dTanOnRad self, GccAna_Circ2dTanOnRad Circ)
        Results(Geom2dGcc_Circ2dTanOnRad self, Geom2dGcc_Circ2dTanOnRadGeo Circ)

        :type Circ: OCC.wrapper.Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_Results(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2dTanOnRad self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm which has reached
        its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2dTanOnRad self) -> Standard_Integer

        Returns the number of circles, representing solutions
        computed by this algorithm.
        Exceptions: StdFail_NotDone if the construction fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2dTanOnRad self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the context
        of the algorithm-object.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2dTanOnRad self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        outside with respect to the arguments, or
        -   that computed during construction (i.e. enclosed,
        enclosing or outside) when the solutions are defined
        as unqualified with respect to the arguments, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2dTanOnRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the solution curv.
        ParArg is the intrinsic parameter of the point on the argument curv.
        PntSol is the tangency point on the solution curv.
        PntArg is the tangency point on the argument curv.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_Tangency1(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(Geom2dGcc_Circ2dTanOnRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns the center PntSol on the second argument (i.e.
        line or circle) of the solution of index Index computed by
        this algorithm.
        ParArg is the intrinsic parameter of the point on the argument curv.
        PntSol is the center point of the solution curv.
        PntArg is the projection of PntSol on the argument curv.
        Exceptions:
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2dTanOnRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and the first
        argument of this algorithm are the same (i.e. there are 2
        identical circles).
        If Rarg is the radius of the first argument, Rsol is the
        radius of the solution and dist is the distance between
        the two centers, we consider the two circles to be
        identical if |Rarg - Rsol| and dist are less than
        or equal to the tolerance criterion given at the time of
        construction of this algorithm.
        OutOfRange is raised if Index is greater than the number of solutions.
        notDone is raised if the construction algorithm did not succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_IsTheSame1(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2dTanOnRad
Geom2dGcc_Circ2dTanOnRad_swigregister = _Geom2dGcc.Geom2dGcc_Circ2dTanOnRad_swigregister
Geom2dGcc_Circ2dTanOnRad_swigregister(Geom2dGcc_Circ2dTanOnRad)

class Geom2dGcc_Circ2dTanCen(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to a curve and
    centered on a point.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCurv).
    -The center point Pcenter.
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an EnclosedCurv C1
    with a tolerance Tolerance.
    If we did not used Tolerance it is impossible to
    find a solution in the the following case : Pcenter is
    outside C1.
    With Tolerance we will give a solution if the distance
    between C1 and Pcenter is lower than or equal Tolerance/2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2dTanCen self, Geom2dGcc_QualifiedCurve Qualified1, Handle_Geom2d_Point Pcenter, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanCen

        Constructs one or more 2D circles tangential to the
        curve Qualified1 and centered on the point Pcenter.
        Tolerance is a tolerance criterion used by the algorithm
        to find a solution when, mathematically, the problem
        posed does not have a solution, but where there is
        numeric uncertainty attached to the arguments.
        Tolerance is only used in these algorithms in very
        specific cases where the center of the solution is very
        close to the circle to which it is tangential, and where the
        solution is thus a very small circle.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosing for a line).

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve
        :type Pcenter: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2dTanCen(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2dTanCen self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached
        its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2dTanCen self) -> Standard_Integer

        Returns the number of circles, representing solutions
        computed by this algorithm.
        Exceptions
        StdFail_NotDone if the construction fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2dTanCen self, Standard_Integer const Index) -> gp_Circ2d

        Returns a circle, representing the solution of index
        Index computed by this algorithm.
        Warning
        This indexing simply provides a means of consulting the
        solutions. The index values are not associated with
        these solutions outside the context of the algorithm object.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2dTanCen self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        outside with respect to the argument, or
        -   that computed during construction (i.e. enclosed,
        enclosing or outside) when the solutions are defined
        as unqualified with respect to the argument.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2dTanCen self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_Tangency1(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2dTanCen self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and the first
        argument of this algorithm are the same (i.e. there are 2
        identical circles).
        If Rarg is the radius of the first argument, Rsol is the
        radius of the solution and dist is the distance between
        the two centers, we consider the two circles to be
        identical if |Rarg - Rsol| and dist are less than
        or equal to the tolerance criterion given at the time of
        construction of this algorithm.
        NotDone is raised if the construction algorithm didn't succeed.
        OutOfRange is raised if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCen_IsTheSame1(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2dTanCen
Geom2dGcc_Circ2dTanCen_swigregister = _Geom2dGcc.Geom2dGcc_Circ2dTanCen_swigregister
Geom2dGcc_Circ2dTanCen_swigregister(Geom2dGcc_Circ2dTanCen)

class Geom2dGcc_Circ2d3Tan(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to 3 points/lines/circles/
    curves with one curve or more.
    The arguments of all construction methods are :
    - The three qualifiied elements for the
    tangency constrains (QualifiedCirc, QualifiedLine,
    Qualifiedcurv, Points).
    - A parameter for each QualifiedCurv.
    Describes functions for building a 2D circle:
    -   tangential to 3 curves, or
    -   tangential to 2 curves and passing through a point, or
    -   tangential to a curve and passing through 2 points, or
    -   passing through 3 points.
    A Circ2d3Tan object provides a framework for:
    -   defining the construction of 2D circles(s),
    -   implementing the construction algorithm, and
    -   consulting the result(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d3Tan self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Geom2dGcc_QualifiedCurve Qualified3, Standard_Real const Tolerance, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3) -> Geom2dGcc_Circ2d3Tan
        __init__(Geom2dGcc_Circ2d3Tan self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Handle_Geom2d_Point Point, Standard_Real const Tolerance, Standard_Real const Param1, Standard_Real const Param2) -> Geom2dGcc_Circ2d3Tan
        __init__(Geom2dGcc_Circ2d3Tan self, Geom2dGcc_QualifiedCurve Qualified1, Handle_Geom2d_Point Point1, Handle_Geom2d_Point Point2, Standard_Real const Tolerance, Standard_Real const Param1) -> Geom2dGcc_Circ2d3Tan
        __init__(Geom2dGcc_Circ2d3Tan self, Handle_Geom2d_Point Point1, Handle_Geom2d_Point Point2, Handle_Geom2d_Point Point3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3Tan

        Constructs one or more 2D circles passing through three points Point1, Point2 and Point3.
        Tolerance is a tolerance criterion used by the algorithm
        to find a solution when, mathematically, the problem
        posed does not have a solution, but where there is
        numeric uncertainty attached to the arguments.
        For example, take:
        -   two circles C1 and C2, such that C2 is inside C1,
        and almost tangential to C1; there is in fact no point
        of intersection between C1 and C2; and
        -   a circle C3 outside C1.
        You now want to find a circle which is tangential to C1,
        C2 and C3: a pure mathematical resolution will not find
        a solution. This is where the tolerance criterion is used:
        the algorithm considers that C1 and C2 are tangential if
        the shortest distance between these two circles is less
        than or equal to Tolerance. Thus, the algorithm finds a solution.
        Warning
        An iterative algorithm is used if Qualified1, Qualified2 or
        Qualified3 is more complex than a line or a circle. In
        such cases, the algorithm constructs only one solution.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosing for a line).

        :type Point1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Point2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Point3: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d3Tan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Results(self, *args):
        """
        Results(Geom2dGcc_Circ2d3Tan self, GccAna_Circ2d3Tan Circ, Standard_Integer const Rank1, Standard_Integer const Rank2, Standard_Integer const Rank3)

        :type Circ: OCC.wrapper.GccAna.GccAna_Circ2d3Tan
        :type Rank1: int
        :type Rank2: int
        :type Rank3: int

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_Results(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d3Tan self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2d3Tan self) -> Standard_Integer

        This method returns the number of solutions.
        NotDone is raised if the algorithm failed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the context
        of the algorithm-object.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index)

        It returns the informations about the qualifiers of the tangency
        arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif3: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_Tangency2(self, *args)


    def Tangency3(self, *args):
        """
        Tangency3(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the third argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_Tangency3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution is equal to the first argument.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution is equal to the second argument.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_IsTheSame2(self, *args)


    def IsTheSame3(self, *args):
        """
        IsTheSame3(Geom2dGcc_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution is equal to the third argument.
        If Rarg is the radius of the first, second or third
        argument, Rsol is the radius of the solution and dist
        is the distance between the two centers, we consider
        the two circles to be identical if |Rarg - Rsol| and
        dist are less than or equal to the tolerance criterion
        given at the time of construction of this algorithm.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3Tan_IsTheSame3(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d3Tan
Geom2dGcc_Circ2d3Tan_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d3Tan_swigregister
Geom2dGcc_Circ2d3Tan_swigregister(Geom2dGcc_Circ2d3Tan)

class Geom2dGcc_QCurve(object):
    """Creates a qualified 2d line."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_QCurve self, Geom2dAdaptor_Curve Curve, GccEnt_Position const Qualifier) -> Geom2dGcc_QCurve

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Qualifier: OCC.wrapper.GccEnt.GccEnt_Position

        """
        this = _Geom2dGcc.new_Geom2dGcc_QCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Qualified(self, *args):
        """
        Qualified(Geom2dGcc_QCurve self) -> Geom2dAdaptor_Curve

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_Qualified(self, *args)


    def Qualifier(self, *args):
        """
        Qualifier(Geom2dGcc_QCurve self) -> GccEnt_Position

        :rtype: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_Qualifier(self, *args)


    def IsUnqualified(self, *args):
        """
        IsUnqualified(Geom2dGcc_QCurve self) -> Standard_Boolean

        Returns true if the solution is unqualified and false in the
        other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_IsUnqualified(self, *args)


    def IsEnclosing(self, *args):
        """
        IsEnclosing(Geom2dGcc_QCurve self) -> Standard_Boolean

        Returns true if the solution is Enclosing the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_IsEnclosing(self, *args)


    def IsEnclosed(self, *args):
        """
        IsEnclosed(Geom2dGcc_QCurve self) -> Standard_Boolean

        Returns true if the solution is Enclosed in the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_IsEnclosed(self, *args)


    def IsOutside(self, *args):
        """
        IsOutside(Geom2dGcc_QCurve self) -> Standard_Boolean

        Returns true if the solution is Outside the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QCurve_IsOutside(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_QCurve
Geom2dGcc_QCurve_swigregister = _Geom2dGcc.Geom2dGcc_QCurve_swigregister
Geom2dGcc_QCurve_swigregister(Geom2dGcc_QCurve)

class Geom2dGcc_FunctionTanCuCuOnCu(math.math_FunctionSetWithDerivatives):
    """
    This abstract class describes a set on N Functions of
    M independant variables.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, Geom2dAdaptor_Curve C2, gp_Circ2d OnCi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Circ2d C1, Geom2dAdaptor_Curve C2, gp_Circ2d OnCi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Lin2d L1, Geom2dAdaptor_Curve C2, gp_Circ2d OnCi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, gp_Pnt2d P2, gp_Circ2d OnCi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, Geom2dAdaptor_Curve C2, gp_Lin2d OnLi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Circ2d C1, Geom2dAdaptor_Curve C2, gp_Lin2d OnLi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Lin2d L1, Geom2dAdaptor_Curve C2, gp_Lin2d OnLi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, gp_Pnt2d P2, gp_Lin2d OnLi, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve OnCu, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Circ2d C1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve OnCu, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, gp_Lin2d L1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve OnCu, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu
        __init__(Geom2dGcc_FunctionTanCuCuOnCu self, Geom2dAdaptor_Curve C1, gp_Pnt2d P1, Geom2dAdaptor_Curve OnCu, Standard_Real const Rad) -> Geom2dGcc_FunctionTanCuCuOnCu

        :type C1: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type OnCu: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Rad: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanCuCuOnCu(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitDerivative(self, *args):
        """
        InitDerivative(Geom2dGcc_FunctionTanCuCuOnCu self, math_Vector X, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Pnt2d Point3, gp_Vec2d Tan1, gp_Vec2d Tan2, gp_Vec2d Tan3, gp_Vec2d D21, gp_Vec2d D22, gp_Vec2d D23)

        :type X: OCC.wrapper.math.math_Vector
        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Point3: OCC.wrapper.gp.gp_Pnt2d
        :type Tan1: OCC.wrapper.gp.gp_Vec2d
        :type Tan2: OCC.wrapper.gp.gp_Vec2d
        :type Tan3: OCC.wrapper.gp.gp_Vec2d
        :type D21: OCC.wrapper.gp.gp_Vec2d
        :type D22: OCC.wrapper.gp.gp_Vec2d
        :type D23: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_InitDerivative(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Geom2dGcc_FunctionTanCuCuOnCu self) -> Standard_Integer

        Returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Geom2dGcc_FunctionTanCuCuOnCu self) -> Standard_Integer

        Returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanCuCuOnCu self, math_Vector X, math_Vector F) -> Standard_Boolean

        Computes the values of the Functions for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Geom2dGcc_FunctionTanCuCuOnCu self, math_Vector X, math_Matrix D) -> Standard_Boolean

        Returns the values of the derivatives for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanCuCuOnCu self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        Returns the values of the functions and the derivatives
        for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanCuCuOnCu
Geom2dGcc_FunctionTanCuCuOnCu_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanCuCuOnCu_swigregister
Geom2dGcc_FunctionTanCuCuOnCu_swigregister(Geom2dGcc_FunctionTanCuCuOnCu)

class Geom2dGcc_Circ2dTanCenGeo(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to a curve and
    centered on a point.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCurv).
    -The center point Pcenter.
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an EnclosedCurv C1
    with a tolerance Tolerance.
    If we did not use Tolerance it is impossible to
    find a solution in the following case : Pcenter is
    outside C1.
    With Tolerance we will give a solution if the distance
    between C1 and Pcenter is lower than or equal Tolerance/2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2dTanCenGeo self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Pcenter, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanCenGeo

        This method implements the algorithms used to
        create 2d circles tangent to a circle and
        centered on a point.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Pcenter: OCC.wrapper.gp.gp_Pnt2d
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2dTanCenGeo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2dTanCenGeo self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2dTanCenGeo self) -> Standard_Integer

        Returns the number of solutions and raises NotDone
        exception if the algorithm didn't succeed.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2dTanCenGeo self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions or less than zero.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2dTanCenGeo self, Standard_Integer const Index)

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2dTanCenGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntArg
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions or less than zero.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_Tangency1(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2dTanCenGeo
Geom2dGcc_Circ2dTanCenGeo_swigregister = _Geom2dGcc.Geom2dGcc_Circ2dTanCenGeo_swigregister
Geom2dGcc_Circ2dTanCenGeo_swigregister(Geom2dGcc_Circ2dTanCenGeo)

class Geom2dGcc_Circ2d2TanOn(object):
    """
    This class implements the algorithms used to
    create 2d circles TANgent to 2 entities and
    having the center ON a curve.
    The order of the tangency argument is always
    QualifiedCirc, QualifiedLin, QualifiedCurv, Pnt2d.
    the arguments are :
    - The two tangency arguments.
    - The center line.
    - The parameter for each tangency argument which
    is a curve.
    - The tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d2TanOn self, Geom2dGcc_QualifiedCurve Qualified1, Geom2dGcc_QualifiedCurve Qualified2, Geom2dAdaptor_Curve OnCurve, Standard_Real const Tolerance, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const ParamOn) -> Geom2dGcc_Circ2d2TanOn
        __init__(Geom2dGcc_Circ2d2TanOn self, Geom2dGcc_QualifiedCurve Qualified1, Handle_Geom2d_Point Point, Geom2dAdaptor_Curve OnCurve, Standard_Real const Tolerance, Standard_Real const Param1, Standard_Real const ParamOn) -> Geom2dGcc_Circ2d2TanOn
        __init__(Geom2dGcc_Circ2d2TanOn self, Handle_Geom2d_Point Point1, Handle_Geom2d_Point Point2, Geom2dAdaptor_Curve OnCurve, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOn

        This method implements the algorithms used to
        create 2d circles TANgent to two points and
        having the center ON a 2d curve.
        Tolerance is used for the limit cases.

        :type Point1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Point2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type OnCurve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d2TanOn(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Results(self, *args):
        """
        Results(Geom2dGcc_Circ2d2TanOn self, GccAna_Circ2d2TanOn Circ)
        Results(Geom2dGcc_Circ2d2TanOn self, Geom2dGcc_Circ2d2TanOnGeo Circ)

        :type Circ: OCC.wrapper.Geom2dGcc.Geom2dGcc_Circ2d2TanOnGeo

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_Results(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d2TanOn self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has
        reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2d2TanOn self) -> Standard_Integer

        This method returns the number of solutions.
        NotDone is raised if the algorithm failed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the context
        of the algorithm-object.
        Exceptions
        Standard_OutOfRange if Index is less than or equal
        to zero or greater than the number of solutions
        computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index)

        It returns the informations about the qualifiers of
        the tangency
        arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_Tangency2(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns the center PntSol of the solution of index Index
        computed by this algorithm.
        ParArg is the parameter of the point PntSol on the third argument.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and,
        respectively, the first or second argument of this
        algorithm are the same (i.e. there are 2 identical circles).
        If Rarg is the radius of the first or second argument,
        Rsol is the radius of the solution and dist is the
        distance between the two centers, we consider the two
        circles to be identical if |Rarg - Rsol| and dist
        are less than or equal to the tolerance criterion given at
        the time of construction of this algorithm.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d2TanOn self, Standard_Integer const Index) -> Standard_Boolean

        Returns true if the solution of index Index and,
        respectively, the first or second argument of this
        algorithm are the same (i.e. there are 2 identical circles).
        If Rarg is the radius of the first or second argument,
        Rsol is the radius of the solution and dist is the
        distance between the two centers, we consider the two
        circles to be identical if |Rarg - Rsol| and dist
        are less than or equal to the tolerance criterion given at
        the time of construction of this algorithm.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_IsTheSame2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d2TanOn
Geom2dGcc_Circ2d2TanOn_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d2TanOn_swigregister
Geom2dGcc_Circ2d2TanOn_swigregister(Geom2dGcc_Circ2d2TanOn)

class Geom2dGcc_Lin2d2TanIter(object):
    """
    This class implements the algorithms used to
    create 2d lines tangent to 2 other elements which
    can be circles, curves or points.
    More than one argument must be a curve.

    Note: Some constructors may check the type of the qualified argument
    and raise BadQualifier Error in case of incorrect couple (qualifier,
    curv).
    For example: "EnclosedCirc".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Lin2d2TanIter self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d ThePoint, Standard_Real const Param1, Standard_Real const Tolang) -> Geom2dGcc_Lin2d2TanIter
        __init__(Geom2dGcc_Lin2d2TanIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, Standard_Real const Param2, Standard_Real const Tolang) -> Geom2dGcc_Lin2d2TanIter
        __init__(Geom2dGcc_Lin2d2TanIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolang) -> Geom2dGcc_Lin2d2TanIter

        This class implements the algorithms used to create 2d
        line tangent to two curves.
        Tolang is used to determine the tolerance for the
        tangency points.
        Param1 is used for the initial guess on the first curve.
        Param2 is used for the initial guess on the second curve.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Qualified2: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Param1: float
        :type Param2: float
        :type Tolang: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Lin2d2TanIter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Lin2d2TanIter self) -> Standard_Boolean

        This methode returns true when there is a solution
        and false in the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_IsDone(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Lin2d2TanIter self) -> gp_Lin2d

        Returns the solution.

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Lin2d2TanIter self)

        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Lin2d2TanIter self, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on
        the argument curv.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Lin2d2TanIter self, gp_Pnt2d PntSol)

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_Tangency2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Lin2d2TanIter
Geom2dGcc_Lin2d2TanIter_swigregister = _Geom2dGcc.Geom2dGcc_Lin2d2TanIter_swigregister
Geom2dGcc_Lin2d2TanIter_swigregister(Geom2dGcc_Lin2d2TanIter)

class Geom2dGcc_Circ2d2TanOnIter(object):
    """
    This class implements the algorithms used to
    create 2d circles TANgent to 2 entities and
    having the center ON a curv.
    The order of the tangency argument is always
    QualifiedCirc, QualifiedLin, QualifiedCurv, Pnt2d.
    the arguments are :
    - The two tangency arguments.
    - The center line.
    - The parameter for each tangency argument which
    is a curve.
    - The tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, gp_Lin2d OnLine, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, gp_Lin2d OnLine, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, gp_Lin2d OnLine, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Point2, gp_Lin2d OnLine, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, gp_Circ2d OnCirc, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, gp_Circ2d OnCirc, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, gp_Circ2d OnCirc, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Point2, gp_Circ2d OnCirc, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dAdaptor_Curve OnCurv, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const ParamOn, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dAdaptor_Curve OnCurve, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const ParamOn, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Point2, Geom2dAdaptor_Curve OnCurve, Standard_Real const Param1, Standard_Real const ParamOn, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter
        __init__(Geom2dGcc_Circ2d2TanOnIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dAdaptor_Curve OnCurve, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const ParamOn, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanOnIter

        This method implements the algorithms used to
        create 2d circles TANgent to two curves and
        having the center ON a 2d curve.
        Param1 is the initial guess on the first curve QualifiedCurv.
        Param1 is the initial guess on the second curve QualifiedCurv.
        ParamOn is the initial guess on the center curve OnCurv.
        Tolerance is used for the limit cases.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Qualified2: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type OnCurve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Param1: float
        :type Param2: float
        :type ParamOn: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d2TanOnIter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d2TanOnIter self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_IsDone(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d2TanOnIter self) -> gp_Circ2d

        Returns the solution.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d2TanOnIter self)

        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d2TanOnIter self, gp_Pnt2d PntSol)

        Returns information about the tangency point between
        the result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d2TanOnIter self, gp_Pnt2d PntSol)

        Returns information about the tangency point between
        the result and the second argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_Tangency2(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(Geom2dGcc_Circ2d2TanOnIter self, gp_Pnt2d PntSol)

        Returns information about the center (on the curv) of the
        result and the third argument.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d2TanOnIter self) -> Standard_Boolean

        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d2TanOnIter self) -> Standard_Boolean

        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_IsTheSame2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d2TanOnIter
Geom2dGcc_Circ2d2TanOnIter_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d2TanOnIter_swigregister
Geom2dGcc_Circ2d2TanOnIter_swigregister(Geom2dGcc_Circ2d2TanOnIter)

class Geom2dGcc_Lin2dTanOblIter(object):
    """
    This class implements the algorithms used to
    create 2d line tangent to a curve QualifiedCurv and
    doing an angle Angle with a line TheLin.
    The angle must be in Radian.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Lin2dTanOblIter self, Geom2dGcc_QCurve Qualified1, gp_Lin2d TheLin, Standard_Real const Param1, Standard_Real const TolAng, Standard_Real const Angle=0) -> Geom2dGcc_Lin2dTanOblIter

        This class implements the algorithm used to
        create 2d line tangent to a curve and doing an
        angle Angle with the line TheLin.
        Angle must be in Radian.
        Param2 is the initial guess on the curve QualifiedCurv.
        Tolang is the angular tolerance.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type TheLin: OCC.wrapper.gp.gp_Lin2d
        :type Param1: float
        :type TolAng: float
        :type Angle: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Lin2dTanOblIter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Lin2dTanOblIter self) -> Standard_Boolean

        This method returns true when there is a solution
        and false in the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_IsDone(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Lin2dTanOblIter self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Lin2dTanOblIter self)

        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Lin2dTanOblIter self, gp_Pnt2d PntSol)

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_Tangency1(self, *args)


    def Intersection2(self, *args):
        """
        Intersection2(Geom2dGcc_Lin2dTanOblIter self, gp_Pnt2d PntSol)

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_Intersection2(self, *args)


    def IsParallel2(self, *args):
        """
        IsParallel2(Geom2dGcc_Lin2dTanOblIter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_IsParallel2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Lin2dTanOblIter
Geom2dGcc_Lin2dTanOblIter_swigregister = _Geom2dGcc.Geom2dGcc_Lin2dTanOblIter_swigregister
Geom2dGcc_Lin2dTanOblIter_swigregister(Geom2dGcc_Lin2dTanOblIter)

class Geom2dGcc_(object):
    """
    The Geom2dGcc package describes qualified 2D
    curves used in the construction of constrained geometric
    objects by an algorithm provided by the Geom2dGcc package.
    A qualified 2D curve is a curve with a qualifier which
    specifies whether the solution of a construction
    algorithm using the qualified curve (as an argument):
    -   encloses the curve, or
    -   is enclosed by the curve, or
    -   is built so that both the curve and this solution are external to one another, or
    -   is undefined (all solutions apply).
    These package methods provide simpler functions to construct a qualified curve.
    Note: the interior of a curve is defined as the left-hand
    side of the curve in relation to its orientation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Unqualified(*args):
        """
        Unqualified(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

        Constructs such a qualified curve that the relative
        position of the solution computed by a construction
        algorithm using the qualified curve to the circle or line is
        not qualified, i.e. all solutions apply.
        Warning
        Obj is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom2d_Curve) mycurve = ...
        ;
        Geom2dAdaptor_Curve Obj ( mycurve )
        ;
        The qualified curve is then constructed with this object:
        Geom2dGcc_QualifiedCurve
        myQCurve = Geom2dGcc::Unqualified(Obj);

        :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

        """
        return _Geom2dGcc.Geom2dGcc__Unqualified(*args)

    Unqualified = staticmethod(Unqualified)

    def Enclosing(*args):
        """
        Enclosing(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

        Constructs such a qualified curve that the solution
        computed by a construction algorithm using the qualified
        curve encloses the curve.
        Warning
        Obj is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom2d_Curve) mycurve = ...
        ;
        Geom2dAdaptor_Curve Obj ( mycurve )
        ;
        The qualified curve is then constructed with this object:
        Geom2dGcc_QualifiedCurve
        myQCurve = Geom2dGcc::Enclosing(Obj);

        :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

        """
        return _Geom2dGcc.Geom2dGcc__Enclosing(*args)

    Enclosing = staticmethod(Enclosing)

    def Enclosed(*args):
        """
        Enclosed(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

        Constructs such a qualified curve that the solution
        computed by a construction algorithm using the qualified
        curve is enclosed by the curve.
        Warning
        Obj is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom2d_Curve) mycurve = ...
        ;
        Geom2dAdaptor_Curve Obj ( mycurve )
        ;
        The qualified curve is then constructed with this object:
        Geom2dGcc_QualifiedCurve
        myQCurve = Geom2dGcc::Enclosed(Obj);

        :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

        """
        return _Geom2dGcc.Geom2dGcc__Enclosed(*args)

    Enclosed = staticmethod(Enclosed)

    def Outside(*args):
        """
        Outside(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

        Constructs such a qualified curve that the solution
        computed by a construction algorithm using the qualified
        curve and the curve are external to one another.
        Warning
        Obj is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom2d_Curve) mycurve = ...
        ;
        Geom2dAdaptor_Curve Obj ( mycurve )
        ;
        The qualified curve is then constructed with this object:
        Geom2dGcc_QualifiedCurve
        myQCurve = Geom2dGcc::Outside(Obj);

        :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

        """
        return _Geom2dGcc.Geom2dGcc__Outside(*args)

    Outside = staticmethod(Outside)

    def __init__(self):
        """
        The Geom2dGcc package describes qualified 2D
        curves used in the construction of constrained geometric
        objects by an algorithm provided by the Geom2dGcc package.
        A qualified 2D curve is a curve with a qualifier which
        specifies whether the solution of a construction
        algorithm using the qualified curve (as an argument):
        -   encloses the curve, or
        -   is enclosed by the curve, or
        -   is built so that both the curve and this solution are external to one another, or
        -   is undefined (all solutions apply).
        These package methods provide simpler functions to construct a qualified curve.
        Note: the interior of a curve is defined as the left-hand
        side of the curve in relation to its orientation.
        """
        this = _Geom2dGcc.new_Geom2dGcc_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_
Geom2dGcc__swigregister = _Geom2dGcc.Geom2dGcc__swigregister
Geom2dGcc__swigregister(Geom2dGcc_)

def Geom2dGcc__Unqualified(*args):
    """
    Geom2dGcc__Unqualified(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

    Constructs such a qualified curve that the relative
    position of the solution computed by a construction
    algorithm using the qualified curve to the circle or line is
    not qualified, i.e. all solutions apply.
    Warning
    Obj is an adapted curve, i.e. an object which is an interface between:
    -   the services provided by a 2D curve from the package Geom2d,
    -   and those required on the curve by a computation algorithm.
    The adapted curve is created in the following way:
    Handle(Geom2d_Curve) mycurve = ...
    ;
    Geom2dAdaptor_Curve Obj ( mycurve )
    ;
    The qualified curve is then constructed with this object:
    Geom2dGcc_QualifiedCurve
    myQCurve = Geom2dGcc::Unqualified(Obj);

    :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

    """
    return _Geom2dGcc.Geom2dGcc__Unqualified(*args)

def Geom2dGcc__Enclosing(*args):
    """
    Geom2dGcc__Enclosing(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

    Constructs such a qualified curve that the solution
    computed by a construction algorithm using the qualified
    curve encloses the curve.
    Warning
    Obj is an adapted curve, i.e. an object which is an interface between:
    -   the services provided by a 2D curve from the package Geom2d,
    -   and those required on the curve by a computation algorithm.
    The adapted curve is created in the following way:
    Handle(Geom2d_Curve) mycurve = ...
    ;
    Geom2dAdaptor_Curve Obj ( mycurve )
    ;
    The qualified curve is then constructed with this object:
    Geom2dGcc_QualifiedCurve
    myQCurve = Geom2dGcc::Enclosing(Obj);

    :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

    """
    return _Geom2dGcc.Geom2dGcc__Enclosing(*args)

def Geom2dGcc__Enclosed(*args):
    """
    Geom2dGcc__Enclosed(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

    Constructs such a qualified curve that the solution
    computed by a construction algorithm using the qualified
    curve is enclosed by the curve.
    Warning
    Obj is an adapted curve, i.e. an object which is an interface between:
    -   the services provided by a 2D curve from the package Geom2d,
    -   and those required on the curve by a computation algorithm.
    The adapted curve is created in the following way:
    Handle(Geom2d_Curve) mycurve = ...
    ;
    Geom2dAdaptor_Curve Obj ( mycurve )
    ;
    The qualified curve is then constructed with this object:
    Geom2dGcc_QualifiedCurve
    myQCurve = Geom2dGcc::Enclosed(Obj);

    :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

    """
    return _Geom2dGcc.Geom2dGcc__Enclosed(*args)

def Geom2dGcc__Outside(*args):
    """
    Geom2dGcc__Outside(Geom2dAdaptor_Curve Obj) -> Geom2dGcc_QualifiedCurve

    Constructs such a qualified curve that the solution
    computed by a construction algorithm using the qualified
    curve and the curve are external to one another.
    Warning
    Obj is an adapted curve, i.e. an object which is an interface between:
    -   the services provided by a 2D curve from the package Geom2d,
    -   and those required on the curve by a computation algorithm.
    The adapted curve is created in the following way:
    Handle(Geom2d_Curve) mycurve = ...
    ;
    Geom2dAdaptor_Curve Obj ( mycurve )
    ;
    The qualified curve is then constructed with this object:
    Geom2dGcc_QualifiedCurve
    myQCurve = Geom2dGcc::Outside(Obj);

    :type Obj: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve

    """
    return _Geom2dGcc.Geom2dGcc__Outside(*args)

class Geom2dGcc_Circ2d3TanIter(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to 3 points/lines/circles/
    curves with one curve or more.
    The arguments of all construction methods are :
    - The three qualifiied elements for the
    tangency constrains (QualifiedCirc, QualifiedLine,
    Qualifiedcurv, Points).
    - A parameter for each QualifiedCurv.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, gp_Pnt2d Point3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, gp_Pnt2d Point3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Point1, gp_Pnt2d Point2, Standard_Real const Param1, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, gp_Pnt2d Point2, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter
        __init__(Geom2dGcc_Circ2d3TanIter self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, Geom2dGcc_QCurve Qualified3, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const Param3, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d3TanIter

        This method implements the algorithms used to
        create 2d circles tangent to 3 curves.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Qualified2: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Qualified3: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Param1: float
        :type Param2: float
        :type Param3: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d3TanIter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d3TanIter self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_IsDone(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d3TanIter self) -> gp_Circ2d

        Returns the solution.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d3TanIter self)

        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif3: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d3TanIter self, gp_Pnt2d PntSol)

        Returns informations about the tangency point between
        the result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d3TanIter self, gp_Pnt2d PntSol)

        Returns informations about the tangency point between
        the result and the second argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_Tangency2(self, *args)


    def Tangency3(self, *args):
        """
        Tangency3(Geom2dGcc_Circ2d3TanIter self, gp_Pnt2d PntSol)

        Returns informations about the tangency point between
        the result and the third argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntSol
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_Tangency3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d3TanIter self) -> Standard_Boolean

        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d3TanIter self) -> Standard_Boolean

        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_IsTheSame2(self, *args)


    def IsTheSame3(self, *args):
        """
        IsTheSame3(Geom2dGcc_Circ2d3TanIter self) -> Standard_Boolean

        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_IsTheSame3(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d3TanIter
Geom2dGcc_Circ2d3TanIter_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d3TanIter_swigregister
Geom2dGcc_Circ2d3TanIter_swigregister(Geom2dGcc_Circ2d3TanIter)

class Geom2dGcc_FunctionTanCuCu(math.math_FunctionSetWithDerivatives):
    """
    This abstract class describes a Function of 1 Variable
    used to find a line tangent to two curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanCuCu self, Geom2dAdaptor_Curve Curv1, Geom2dAdaptor_Curve Curv2) -> Geom2dGcc_FunctionTanCuCu
        __init__(Geom2dGcc_FunctionTanCuCu self, gp_Circ2d Circ1, Geom2dAdaptor_Curve Curv2) -> Geom2dGcc_FunctionTanCuCu

        :type Circ1: OCC.wrapper.gp.gp_Circ2d
        :type Curv2: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanCuCu(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitDerivative(self, *args):
        """
        InitDerivative(Geom2dGcc_FunctionTanCuCu self, math_Vector X, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Vec2d Tan1, gp_Vec2d Tan2, gp_Vec2d D21, gp_Vec2d D22)

        :type X: OCC.wrapper.math.math_Vector
        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Tan1: OCC.wrapper.gp.gp_Vec2d
        :type Tan2: OCC.wrapper.gp.gp_Vec2d
        :type D21: OCC.wrapper.gp.gp_Vec2d
        :type D22: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_InitDerivative(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Geom2dGcc_FunctionTanCuCu self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Geom2dGcc_FunctionTanCuCu self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanCuCu self, math_Vector X, math_Vector F) -> Standard_Boolean

        Computes the value of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Geom2dGcc_FunctionTanCuCu self, math_Vector X, math_Matrix Deriv) -> Standard_Boolean

        Computes the derivative of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type Deriv: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanCuCu self, math_Vector X, math_Vector F, math_Matrix Deriv) -> Standard_Boolean

        Computes the value and the derivative of the function F
        for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type Deriv: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanCuCu
Geom2dGcc_FunctionTanCuCu_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanCuCu_swigregister
Geom2dGcc_FunctionTanCuCu_swigregister(Geom2dGcc_FunctionTanCuCu)

class Geom2dGcc_Lin2dTanObl(object):
    """
    This class implements the algorithms used to
    create 2d line tangent to a curve QualifiedCurv and
    doing an angle Angle with a line TheLin.
    The angle must be in Radian.
    Describes functions for building a 2D line making a given
    angle with a line and tangential to a curve.
    A Lin2dTanObl object provides a framework for:
    -   defining the construction of 2D line(s),
    -   implementing the construction algorithm, and
    -   consulting the result(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Lin2dTanObl self, Geom2dGcc_QualifiedCurve Qualified1, gp_Lin2d TheLin, Standard_Real const TolAng, Standard_Real const Angle) -> Geom2dGcc_Lin2dTanObl
        __init__(Geom2dGcc_Lin2dTanObl self, Geom2dGcc_QualifiedCurve Qualified1, gp_Lin2d TheLin, Standard_Real const TolAng, Standard_Real const Param1, Standard_Real const Angle) -> Geom2dGcc_Lin2dTanObl

        This class implements the algorithm used to
        create 2d line tangent to a curve and doing an
        angle Angle with the line TheLin.
        Angle must be in Radian.
        Param2 is the initial guess on the curve QualifiedCurv.
        Tolang is the angular tolerance.
        Warning
        An iterative algorithm is used if Qualified1 is more
        complex than a line or a circle. In such cases, the
        algorithm constructs only one solution.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosed for a circle).

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QualifiedCurve
        :type TheLin: OCC.wrapper.gp.gp_Lin2d
        :type TolAng: float
        :type Param1: float
        :type Angle: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Lin2dTanObl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Lin2dTanObl self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Lin2dTanObl self) -> Standard_Integer

        Returns the number of lines, representing solutions computed by this algorithm.
        Exceptions
        StdFail_NotDone if the construction fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Lin2dTanObl self, Standard_Integer const Index) -> gp_Lin2d

        Returns a line, representing the solution of index Index
        computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Lin2dTanObl self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosing or outside with
        respect to the argument, or
        -   that computed during construction (i.e. enclosing or
        outside) when the solutions are defined as unqualified
        with respect to the argument, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Lin2dTanObl self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on
        the argument curv.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_Tangency1(self, *args)


    def Intersection2(self, *args):
        """
        Intersection2(Geom2dGcc_Lin2dTanObl self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns the point of intersection PntSol between the
        solution of index Index and the second argument (the line) of this algorithm.
        ParSol is the parameter of the point PntSol on the
        solution. ParArg is the parameter of the point PntSol on the second argument (the line).
        Exceptions
        StdFail_NotDone if the construction fails.
        Geom2dGcc_IsParallel if the solution and the second
        argument (the line) are parallel.
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Lin2dTanObl_Intersection2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Lin2dTanObl
Geom2dGcc_Lin2dTanObl_swigregister = _Geom2dGcc.Geom2dGcc_Lin2dTanObl_swigregister
Geom2dGcc_Lin2dTanObl_swigregister(Geom2dGcc_Lin2dTanObl)

class Geom2dGcc_Circ2dTanOnRadGeo(object):
    """
    This class implements the algorithms used to
    create a 2d circle tangent to a 2d entity,
    centered on a 2d entity and with a given radius.
    More than one argument must be a curve.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCirc, QualifiedLin, QualifiedCurvPoints).
    - The Center element (circle, line, curve).
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an OutsideCurv Cu1
    centered on a line OnLine with a radius Radius and with
    a tolerance Tolerance.
    If we did not use Tolerance it is impossible to
    find a solution in the following case : OnLine is
    outside Cu1. There is no intersection point between Cu1
    and OnLine. The distance between the line and the
    circle is greater than Radius.
    With Tolerance we will give a solution if the
    distance between Cu1 and OnLine is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, Geom2dGcc_QCurve Qualified1, gp_Lin2d OnLine, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, Geom2dGcc_QCurve Qualified1, gp_Circ2d OnCirc, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, GccEnt_QualifiedCirc Qualified1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, GccEnt_QualifiedLin Qualified1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, Geom2dGcc_QCurve Qualified1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo
        __init__(Geom2dGcc_Circ2dTanOnRadGeo self, gp_Pnt2d Point1, Geom2dAdaptor_Curve OnCurv, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2dTanOnRadGeo

        This methods implements the algorithms used to create
        2d Circles passing through a 2d point and centered on a
        2d curve with a given radius.
        Tolerance is used to find solution in every limit cases.
        raises NegativeValue in case of NegativeRadius.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type OnCurv: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Radius: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2dTanOnRadGeo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2dTanOnRadGeo self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2dTanOnRadGeo self) -> Standard_Integer

        This method returns the number of solutions.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2dTanOnRadGeo self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2dTanOnRadGeo self, Standard_Integer const Index)

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2dTanOnRadGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        PntSol is the tangency point on the solution curv.
        PntArg is the tangency point on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_Tangency1(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(Geom2dGcc_Circ2dTanOnRadGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the center (on the curv)
        of the result.
        ParArg is the intrinsic parameter of the point on
        the argument curv.
        PntSol is the center point of the solution curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2dTanOnRadGeo self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument and False in the other cases.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_IsTheSame1(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2dTanOnRadGeo
Geom2dGcc_Circ2dTanOnRadGeo_swigregister = _Geom2dGcc.Geom2dGcc_Circ2dTanOnRadGeo_swigregister
Geom2dGcc_Circ2dTanOnRadGeo_swigregister(Geom2dGcc_Circ2dTanOnRadGeo)

class Geom2dGcc_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Geom2dAdaptor_Curve C) -> Standard_Real

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Geom2dAdaptor_Curve C) -> Standard_Real

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def EpsX(*args):
        """
        EpsX(Geom2dAdaptor_Curve C, Standard_Real const Tol) -> Standard_Real

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def NbSamples(*args):
        """
        NbSamples(Geom2dAdaptor_Curve C) -> Standard_Integer

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Value(*args):
        """
        Value(Geom2dAdaptor_Curve C, Standard_Real const X) -> gp_Pnt2d

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type X: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N, gp_Vec2d dN)

        :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d
        :type dN: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def __init__(self):
        this = _Geom2dGcc.new_Geom2dGcc_CurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_CurveTool
Geom2dGcc_CurveTool_swigregister = _Geom2dGcc.Geom2dGcc_CurveTool_swigregister
Geom2dGcc_CurveTool_swigregister(Geom2dGcc_CurveTool)

def Geom2dGcc_CurveTool_FirstParameter(*args):
    """
    Geom2dGcc_CurveTool_FirstParameter(Geom2dAdaptor_Curve C) -> Standard_Real

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_FirstParameter(*args)

def Geom2dGcc_CurveTool_LastParameter(*args):
    """
    Geom2dGcc_CurveTool_LastParameter(Geom2dAdaptor_Curve C) -> Standard_Real

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_LastParameter(*args)

def Geom2dGcc_CurveTool_EpsX(*args):
    """
    Geom2dGcc_CurveTool_EpsX(Geom2dAdaptor_Curve C, Standard_Real const Tol) -> Standard_Real

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_EpsX(*args)

def Geom2dGcc_CurveTool_NbSamples(*args):
    """
    Geom2dGcc_CurveTool_NbSamples(Geom2dAdaptor_Curve C) -> Standard_Integer

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_NbSamples(*args)

def Geom2dGcc_CurveTool_Value(*args):
    """
    Geom2dGcc_CurveTool_Value(Geom2dAdaptor_Curve C, Standard_Real const X) -> gp_Pnt2d

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :type X: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_Value(*args)

def Geom2dGcc_CurveTool_D1(*args):
    """
    Geom2dGcc_CurveTool_D1(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_D1(*args)

def Geom2dGcc_CurveTool_D2(*args):
    """
    Geom2dGcc_CurveTool_D2(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d
    :type N: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_D2(*args)

def Geom2dGcc_CurveTool_D3(*args):
    """
    Geom2dGcc_CurveTool_D3(Geom2dAdaptor_Curve C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N, gp_Vec2d dN)

    :type C: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d
    :type N: OCC.wrapper.gp.gp_Vec2d
    :type dN: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dGcc.Geom2dGcc_CurveTool_D3(*args)

class Geom2dGcc_QualifiedCurve(object):
    """
    Describes functions for building a qualified 2D curve.
    A qualified 2D curve is a curve with a qualifier which
    specifies whether the solution of a construction
    algorithm using the qualified curve (as an argument):
    -   encloses the curve, or
    -   is enclosed by the curve, or
    -   is built so that both the curve and it are external to one another, or
    -   is undefined (all solutions apply).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_QualifiedCurve self, Geom2dAdaptor_Curve Curve, GccEnt_Position const Qualifier) -> Geom2dGcc_QualifiedCurve

        Constructs a qualified curve by assigning the qualifier
        Qualifier to the curve Curve. Qualifier may be:
        -   GccEnt_enclosing if the solution of a construction
        algorithm using the qualified curve encloses the curve, or
        -   GccEnt_enclosed if the solution is enclosed by the curve, or
        -   GccEnt_outside if both the solution and the curve
        are external to one another, or
        -   GccEnt_unqualified if all solutions apply.
        Note: The interior of a curve is defined as the left-hand
        side of the curve in relation to its orientation.
        Warning
        Curve is an adapted curve, i.e. an object which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom2d_Curve) mycurve = ... ;
        Geom2dAdaptor_Curve Curve ( mycurve ) ;
        The qualified curve is then constructed with this object:
        GccEnt_Position myQualif = GccEnt_outside ;
        Geom2dGcc_QualifiedCurve myQCurve ( Curve, myQualif );
        is private;

        :type Curve: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type Qualifier: OCC.wrapper.GccEnt.GccEnt_Position

        """
        this = _Geom2dGcc.new_Geom2dGcc_QualifiedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Qualified(self, *args):
        """
        Qualified(Geom2dGcc_QualifiedCurve self) -> Geom2dAdaptor_Curve

        Returns a 2D curve to which the qualifier is assigned.
        Warning
        The returned curve is an adapted curve, i.e. an object
        which is an interface between:
        -   the services provided by a 2D curve from the package Geom2d,
        -   and those required on the curve by a computation algorithm.
        The Geom2d curve on which the adapted curve is
        based can be obtained in the following way:
        myQualifiedCurve = ... ;
        Geom2dAdaptor_Curve myAdaptedCurve = myQualifiedCurve.Qualified();
        Handle(Geom2d_Curve) = myAdaptedCurve.Curve();

        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_Qualified(self, *args)


    def Qualifier(self, *args):
        """
        Qualifier(Geom2dGcc_QualifiedCurve self) -> GccEnt_Position

        Returns
        - the qualifier of this qualified curve if it is enclosing,
        enclosed or outside, or
        -   GccEnt_noqualifier if it is unqualified.

        :rtype: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_Qualifier(self, *args)


    def IsUnqualified(self, *args):
        """
        IsUnqualified(Geom2dGcc_QualifiedCurve self) -> Standard_Boolean

        Returns true if the solution is unqualified and false in the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_IsUnqualified(self, *args)


    def IsEnclosing(self, *args):
        """
        IsEnclosing(Geom2dGcc_QualifiedCurve self) -> Standard_Boolean

        It returns true if the solution is Enclosing the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_IsEnclosing(self, *args)


    def IsEnclosed(self, *args):
        """
        IsEnclosed(Geom2dGcc_QualifiedCurve self) -> Standard_Boolean

        It returns true if the solution is Enclosed in the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_IsEnclosed(self, *args)


    def IsOutside(self, *args):
        """
        IsOutside(Geom2dGcc_QualifiedCurve self) -> Standard_Boolean

        It returns true if the solution is Outside the Curv and false in
        the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_QualifiedCurve_IsOutside(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_QualifiedCurve
Geom2dGcc_QualifiedCurve_swigregister = _Geom2dGcc.Geom2dGcc_QualifiedCurve_swigregister
Geom2dGcc_QualifiedCurve_swigregister(Geom2dGcc_QualifiedCurve)

class Geom2dGcc_Circ2d2TanRadGeo(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to one curve and a
    point/line/circle/curv and with a given radius.
    For each construction methods arguments are:
    - Two Qualified elements for tangency constrains.
    (for example EnclosedCirc if we want the
    solution inside the argument EnclosedCirc).
    - Two Reals. One (Radius) for the radius and the
    other (Tolerance) for the tolerance.
    Tolerance is only used for the limit cases.
    For example :
    We want to create a circle inside a circle C1 and
    inside a curve Cu2 with a radius Radius and a
    tolerance Tolerance.
    If we did not used Tolerance it is impossible to
    find a solution in the following case : Cu2 is
    inside C1 and there is no intersection point
    between the two elements.
    With Tolerance we will get a solution if the
    lowest distance between C1 and Cu2 is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_Circ2d2TanRadGeo self, GccEnt_QualifiedCirc Qualified1, Geom2dGcc_QCurve Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRadGeo
        __init__(Geom2dGcc_Circ2d2TanRadGeo self, GccEnt_QualifiedLin Qualified1, Geom2dGcc_QCurve Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRadGeo
        __init__(Geom2dGcc_Circ2d2TanRadGeo self, Geom2dGcc_QCurve Qualified1, Geom2dGcc_QCurve Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRadGeo
        __init__(Geom2dGcc_Circ2d2TanRadGeo self, Geom2dGcc_QCurve Qualified1, gp_Pnt2d Point2, Standard_Real const Radius, Standard_Real const Tolerance) -> Geom2dGcc_Circ2d2TanRadGeo

        This method implements the algorithms used to
        create 2d circles TANgent to a curve and a point
        with a radius of Radius.
        It raises NegativeValue if Radius is lower than zero.

        :type Qualified1: OCC.wrapper.Geom2dGcc.Geom2dGcc_QCurve
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Radius: float
        :type Tolerance: float

        """
        this = _Geom2dGcc.new_Geom2dGcc_Circ2d2TanRadGeo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(Geom2dGcc_Circ2d2TanRadGeo self) -> Standard_Boolean

        This method returns True if the algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(Geom2dGcc_Circ2d2TanRadGeo self) -> Standard_Integer

        This method returns the number of solutions.
        It raises NotDone if the algorithm failed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the context
        of the algorithm-object.
        It raises OutOfRange exception if Index is greater
        than the number of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index)

        It returns the information about the qualifiers of
        the tangency arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns information about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution.
        ParArg is the intrinsic parameter of the point PntSol on the first
        argument.
        It raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns information about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution.
        ParArg is the intrinsic parameter of the point PntArg on
        the second argument.
        It raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_Tangency2(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument.
        It raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(Geom2dGcc_Circ2d2TanRadGeo self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the second argument.
        It raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_IsTheSame2(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_Circ2d2TanRadGeo
Geom2dGcc_Circ2d2TanRadGeo_swigregister = _Geom2dGcc.Geom2dGcc_Circ2d2TanRadGeo_swigregister
Geom2dGcc_Circ2d2TanRadGeo_swigregister(Geom2dGcc_Circ2d2TanRadGeo)

class Geom2dGcc_FunctionTanCirCu(math.math_FunctionWithDerivative):
    """
    This abstract class describes a Function of 1 Variable
    used to find a line tangent to a curve and a circle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanCirCu self, gp_Circ2d Circ, Geom2dAdaptor_Curve Curv) -> Geom2dGcc_FunctionTanCirCu

        :type Circ: OCC.wrapper.gp.gp_Circ2d
        :type Curv: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanCirCu(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanCirCu self, Standard_Real const X) -> Standard_Boolean

        Computes the value of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCirCu_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Geom2dGcc_FunctionTanCirCu self, Standard_Real const X) -> Standard_Boolean

        Computes the derivative of the function F for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCirCu_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanCirCu self, Standard_Real const X) -> Standard_Boolean

        Computes the value and the derivative of the function F
        for the variable X.
        It returns True if the computation is successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type Deriv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCirCu_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanCirCu
Geom2dGcc_FunctionTanCirCu_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanCirCu_swigregister
Geom2dGcc_FunctionTanCirCu_swigregister(Geom2dGcc_FunctionTanCirCu)

class Geom2dGcc_FunctionTanCuCuCu(math.math_FunctionSetWithDerivatives):
    """
    This abstract class describes a set on N Functions of
    M independant variables.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dGcc_FunctionTanCuCuCu self, Geom2dAdaptor_Curve C1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu
        __init__(Geom2dGcc_FunctionTanCuCuCu self, gp_Circ2d C1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu
        __init__(Geom2dGcc_FunctionTanCuCuCu self, gp_Circ2d C1, gp_Circ2d C2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu
        __init__(Geom2dGcc_FunctionTanCuCuCu self, gp_Circ2d C1, gp_Lin2d L2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu
        __init__(Geom2dGcc_FunctionTanCuCuCu self, gp_Lin2d L1, gp_Lin2d L2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu
        __init__(Geom2dGcc_FunctionTanCuCuCu self, gp_Lin2d L1, Geom2dAdaptor_Curve C2, Geom2dAdaptor_Curve C3) -> Geom2dGcc_FunctionTanCuCuCu

        :type L1: OCC.wrapper.gp.gp_Lin2d
        :type C2: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve
        :type C3: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        this = _Geom2dGcc.new_Geom2dGcc_FunctionTanCuCuCu(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitDerivative(self, *args):
        """
        InitDerivative(Geom2dGcc_FunctionTanCuCuCu self, math_Vector X, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Pnt2d Point3, gp_Vec2d Tan1, gp_Vec2d Tan2, gp_Vec2d Tan3, gp_Vec2d D21, gp_Vec2d D22, gp_Vec2d D23)

        :type X: OCC.wrapper.math.math_Vector
        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Point3: OCC.wrapper.gp.gp_Pnt2d
        :type Tan1: OCC.wrapper.gp.gp_Vec2d
        :type Tan2: OCC.wrapper.gp.gp_Vec2d
        :type Tan3: OCC.wrapper.gp.gp_Vec2d
        :type D21: OCC.wrapper.gp.gp_Vec2d
        :type D22: OCC.wrapper.gp.gp_Vec2d
        :type D23: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_InitDerivative(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Geom2dGcc_FunctionTanCuCuCu self) -> Standard_Integer

        Returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Geom2dGcc_FunctionTanCuCuCu self) -> Standard_Integer

        Returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Geom2dGcc_FunctionTanCuCuCu self, math_Vector X, math_Vector F) -> Standard_Boolean

        Computes the values of the Functions for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Geom2dGcc_FunctionTanCuCuCu self, math_Vector X, math_Matrix D) -> Standard_Boolean

        Returns the values of the derivatives for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dGcc_FunctionTanCuCuCu self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        Returns the values of the functions and the derivatives
        for the variable <X>.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_Values(self, *args)

    __swig_destroy__ = _Geom2dGcc.delete_Geom2dGcc_FunctionTanCuCuCu
Geom2dGcc_FunctionTanCuCuCu_swigregister = _Geom2dGcc.Geom2dGcc_FunctionTanCuCuCu_swigregister
Geom2dGcc_FunctionTanCuCuCu_swigregister(Geom2dGcc_FunctionTanCuCuCu)




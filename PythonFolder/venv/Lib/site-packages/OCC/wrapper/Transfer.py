# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Transfer')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Transfer')
    _Transfer = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Transfer', [dirname(__file__)])
        except ImportError:
            import _Transfer
            return _Transfer
        try:
            _mod = imp.load_module('_Transfer', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Transfer = swig_import_helper()
    del swig_import_helper
else:
    import _Transfer
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Transfer.delete_SwigPyIterator

    def value(self):
        return _Transfer.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Transfer.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Transfer.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Transfer.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Transfer.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Transfer.SwigPyIterator_copy(self)

    def next(self):
        return _Transfer.SwigPyIterator_next(self)

    def __next__(self):
        return _Transfer.SwigPyIterator___next__(self)

    def previous(self):
        return _Transfer.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Transfer.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Transfer.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Transfer.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Transfer.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Transfer.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Transfer.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Transfer.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Transfer.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Transfer.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Transfer.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Transfer.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Transfer.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Transfer.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Transfer.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Transfer.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Transfer.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Transfer.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Transfer.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Transfer.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Transfer.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Transfer.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Transfer.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Transfer.ptr_to_number(item)
ptr_to_number = _Transfer.ptr_to_number

def HashCode(*args):
    return _Transfer.HashCode(*args)
HashCode = _Transfer.HashCode

def ptr_equal(a, b):
    return _Transfer.ptr_equal(a, b)
ptr_equal = _Transfer.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
Transfer_StatusVoid = _Transfer.Transfer_StatusVoid
Transfer_StatusDefined = _Transfer.Transfer_StatusDefined
Transfer_StatusUsed = _Transfer.Transfer_StatusUsed
Transfer_StatusInitial = _Transfer.Transfer_StatusInitial
Transfer_StatusRun = _Transfer.Transfer_StatusRun
Transfer_StatusDone = _Transfer.Transfer_StatusDone
Transfer_StatusError = _Transfer.Transfer_StatusError
Transfer_StatusLoop = _Transfer.Transfer_StatusLoop
Transfer_UndefIgnore = _Transfer.Transfer_UndefIgnore
Transfer_UndefFailure = _Transfer.Transfer_UndefFailure
Transfer_UndefContent = _Transfer.Transfer_UndefContent
Transfer_UndefUser = _Transfer.Transfer_UndefUser
class Transfer_ActorOfProcessForTransient(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ActorOfProcessForTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ActorOfProcessForTransient(self) 
            return h


    def __init__(self, *args):
        """__init__(Transfer_ActorOfProcessForTransient self) -> Transfer_ActorOfProcessForTransient"""
        this = _Transfer.new_Transfer_ActorOfProcessForTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Recognize(self, *args):
        """
        Recognize(Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        Specific action of Transfer. The Result is stored in
        the returned Binder, or a Null Handle for "No result"
        (Default defined as doing nothing; should be deffered)
        "mutable" allows the Actor to record intermediate
        information, in addition to those of TransferProcess

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Transferring(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Transfer_ActorOfProcessForTransient self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Transfer_ActorOfProcessForTransient self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Transfer_ActorOfProcessForTransient self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Transfer_ActorOfProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Transfer_ActorOfProcessForTransient self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_Next(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ActorOfProcessForTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ActorOfProcessForTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfProcessForTransient
Transfer_ActorOfProcessForTransient_swigregister = _Transfer.Transfer_ActorOfProcessForTransient_swigregister
Transfer_ActorOfProcessForTransient_swigregister(Transfer_ActorOfProcessForTransient)

def Transfer_ActorOfProcessForTransient_get_type_name(*args):
    """
    Transfer_ActorOfProcessForTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ActorOfProcessForTransient_get_type_name(*args)

def Transfer_ActorOfProcessForTransient_get_type_descriptor(*args):
    """
    Transfer_ActorOfProcessForTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ActorOfProcessForTransient_get_type_descriptor(*args)

class Transfer_Binder(Standard.Standard_Transient):
    """
    A Binder is an auxiliary object to Map the Result of the
    Transfer of a given Object : it records the Result of the
    Unitary Transfer (Resulting Object), status of progress and
    error (if any) of the Process

    The class Binder itself makes no definition for the Result :
    it is defined by sub-classes : it can be either Simple (and
    has to be typed : see generic class SimpleBinder) or Multiple
    (see class MultipleBinder).

    In principle, for a Transfer in progress, Result cannot be
    accessed : this would cause an exception raising.
    This is controlled by the value if StatusResult : if it is
    "Used", the Result cannot be changed. This status is normally
    controlled by TransferProcess but can be directly (see method
    SetAlreadyUsed)

    Checks can be completed by a record of cases, as string which
    can be used as codes, but not to be printed

    In addition to the Result, a Binder can bring a list of
    Attributes, which are additional data, each of them has a name
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_Binder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_Binder(self) 
            return h


    def Merge(self, *args):
        """
        Merge(Transfer_Binder self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_Binder_Merge(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(Transfer_Binder self) -> Standard_Boolean

        Returns True if a Binder has several results, either by itself
        or because it has next results
        Can be defined by sub-classes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Binder_IsMultiple(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Transfer_Binder self) -> Handle_Standard_Type

        Returns the Type which characterizes the Result (if known)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_Binder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Transfer_Binder self) -> Standard_CString

        Returns the Name of the Type which characterizes the Result
        Can be returned even if ResultType itself is unknown

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Binder_ResultTypeName(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Transfer_Binder self,  next)

        Adds a next result (at the end of the list)
        Remark : this information is not processed by Merge

        :type next: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_Binder_AddResult(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Transfer_Binder self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_Binder_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Transfer_Binder self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Binder_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Transfer_Binder self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Transfer_Binder_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Transfer_Binder self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Transfer_Binder_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Transfer_Binder self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Transfer_Binder_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Transfer_Binder self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Transfer_Binder_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Transfer_Binder self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Binder_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Transfer_Binder self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Binder_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Transfer_Binder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_Binder_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Transfer_Binder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_Binder_CCheck(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_Binder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_Binder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_Binder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_Binder
Transfer_Binder_swigregister = _Transfer.Transfer_Binder_swigregister
Transfer_Binder_swigregister(Transfer_Binder)

def Transfer_Binder_get_type_name(*args):
    """
    Transfer_Binder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_Binder_get_type_name(*args)

def Transfer_Binder_get_type_descriptor(*args):
    """
    Transfer_Binder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_Binder_get_type_descriptor(*args)

class Transfer_ActorOfTransientProcess(Transfer_ActorOfProcessForTransient):
    """The original class was renamed. Compatibility only"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ActorOfTransientProcess
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ActorOfTransientProcess(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ActorOfTransientProcess self) -> Transfer_ActorOfTransientProcess

        The original class was renamed. Compatibility only
        """
        this = _Transfer.new_Transfer_ActorOfTransientProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Transferring(self, *args):
        """
        Transferring(Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfTransientProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfTransientProcess_Transfer(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ActorOfTransientProcess_TransferTransient(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ActorOfTransientProcess_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ActorOfTransientProcess_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ActorOfTransientProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfTransientProcess
Transfer_ActorOfTransientProcess_swigregister = _Transfer.Transfer_ActorOfTransientProcess_swigregister
Transfer_ActorOfTransientProcess_swigregister(Transfer_ActorOfTransientProcess)

def Transfer_ActorOfTransientProcess_get_type_name(*args):
    """
    Transfer_ActorOfTransientProcess_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ActorOfTransientProcess_get_type_name(*args)

def Transfer_ActorOfTransientProcess_get_type_descriptor(*args):
    """
    Transfer_ActorOfTransientProcess_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ActorOfTransientProcess_get_type_descriptor(*args)

class Transfer_ActorOfProcessForFinder(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ActorOfProcessForFinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ActorOfProcessForFinder(self) 
            return h


    def __init__(self, *args):
        """__init__(Transfer_ActorOfProcessForFinder self) -> Transfer_ActorOfProcessForFinder"""
        this = _Transfer.new_Transfer_ActorOfProcessForFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Recognize(self, *args):
        """
        Recognize(Transfer_ActorOfProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Transfer_ActorOfProcessForFinder self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        Specific action of Transfer. The Result is stored in
        the returned Binder, or a Null Handle for "No result"
        (Default defined as doing nothing; should be deffered)
        "mutable" allows the Actor to record intermediate
        information, in addition to those of TransferProcess

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Transferring(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Transfer_ActorOfProcessForFinder self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Transfer_ActorOfProcessForFinder self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Transfer_ActorOfProcessForFinder self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Transfer_ActorOfProcessForFinder self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Transfer_ActorOfProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Transfer_ActorOfProcessForFinder self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_Next(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ActorOfProcessForFinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ActorOfProcessForFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfProcessForFinder
Transfer_ActorOfProcessForFinder_swigregister = _Transfer.Transfer_ActorOfProcessForFinder_swigregister
Transfer_ActorOfProcessForFinder_swigregister(Transfer_ActorOfProcessForFinder)

def Transfer_ActorOfProcessForFinder_get_type_name(*args):
    """
    Transfer_ActorOfProcessForFinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ActorOfProcessForFinder_get_type_name(*args)

def Transfer_ActorOfProcessForFinder_get_type_descriptor(*args):
    """
    Transfer_ActorOfProcessForFinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ActorOfProcessForFinder_get_type_descriptor(*args)

class Transfer_DispatchControl(Interface.Interface_CopyControl):
    """
    This is an auxiliary class for TransferDispatch, which allows
    to record simple copies, as CopyControl from Interface, but
    based on a TransientProcess. Hence, it allows in addition
    more actions (such as recording results of adaptations)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_DispatchControl
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_DispatchControl(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_DispatchControl self, Handle_Interface_InterfaceModel model, Handle_Transfer_TransientProcess TP) -> Transfer_DispatchControl

        Creates the DispatchControl, ready for use

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        this = _Transfer.new_Transfer_DispatchControl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def TransientProcess(self, *args):
        """
        Returns the content of the DispatchControl : it can be used
        for a direct call, if the basic methods do not suffice

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        res = _Transfer.Transfer_DispatchControl_TransientProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartingModel(self, *args):
        """
        Returns the Model from which the transfer is to be done

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _Transfer.Transfer_DispatchControl_StartingModel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Transfer_DispatchControl self)

        Clears the List of Copied Results


        """
        return _Transfer.Transfer_DispatchControl_Clear(self, *args)


    def Bind(self, *args):
        """
        Bind(Transfer_DispatchControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Binds a (Transient) Result to a (Transient) Starting Entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_DispatchControl_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Transfer_DispatchControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Searches for the Result bound to a Starting Entity
        If Found, returns True and fills <res>
        Else, returns False and nullifies <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_DispatchControl_Search(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_DispatchControl_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_DispatchControl_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_DispatchControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_DispatchControl
Transfer_DispatchControl_swigregister = _Transfer.Transfer_DispatchControl_swigregister
Transfer_DispatchControl_swigregister(Transfer_DispatchControl)

def Transfer_DispatchControl_get_type_name(*args):
    """
    Transfer_DispatchControl_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_DispatchControl_get_type_name(*args)

def Transfer_DispatchControl_get_type_descriptor(*args):
    """
    Transfer_DispatchControl_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_DispatchControl_get_type_descriptor(*args)

class Transfer_HSequenceOfBinder(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_HSequenceOfBinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_HSequenceOfBinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_HSequenceOfBinder self) -> Transfer_HSequenceOfBinder
        __init__(Transfer_HSequenceOfBinder self, NCollection_Sequence_Handle_Transfer_Binder theOther) -> Transfer_HSequenceOfBinder

        :type theOther: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        this = _Transfer.new_Transfer_HSequenceOfBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        res = _Transfer.Transfer_HSequenceOfBinder_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Transfer_HSequenceOfBinder self,  theItem)
        Append(Transfer_HSequenceOfBinder self, NCollection_Sequence_Handle_Transfer_Binder theSequence)

        :type theSequence: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        return _Transfer.Transfer_HSequenceOfBinder_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Transfer_HSequenceOfBinder self) -> NCollection_Sequence_Handle_Transfer_Binder

        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        return _Transfer.Transfer_HSequenceOfBinder_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_HSequenceOfBinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_HSequenceOfBinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_HSequenceOfBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_HSequenceOfBinder
Transfer_HSequenceOfBinder_swigregister = _Transfer.Transfer_HSequenceOfBinder_swigregister
Transfer_HSequenceOfBinder_swigregister(Transfer_HSequenceOfBinder)

def Transfer_HSequenceOfBinder_get_type_name(*args):
    """
    Transfer_HSequenceOfBinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_HSequenceOfBinder_get_type_name(*args)

def Transfer_HSequenceOfBinder_get_type_descriptor(*args):
    """
    Transfer_HSequenceOfBinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_HSequenceOfBinder_get_type_descriptor(*args)

class Transfer_MultipleBinder(Transfer_Binder):
    """
    Allows direct binding between a starting Object and the Result
    of its transfer, when it can be made of several Transient
    Objects. Compared to a Transcriptor, it has no Transfer Action

    Result is a list of Transient Results. Unique Result is not
    available : SetResult is redefined to start the list on the
    first call, and refuse the other times.

    rr

    Remark : MultipleBinder itself is intended to be created and
    filled by TransferProcess itself (method Bind). In particular,
    conflicts between Unique (Standard) result and Multiple result
    are avoided through management made by TransferProcess.

    Also, a Transcriptor (with an effective Transfer Method) which
    can produce a Multiple Result, may be defined as a sub-class
    of MultipleBinder by redefining method Transfer.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_MultipleBinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_MultipleBinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_MultipleBinder self) -> Transfer_MultipleBinder

        normal standard constructor, creates an empty MultipleBinder


        """
        this = _Transfer.new_Transfer_MultipleBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsMultiple(self, *args):
        """
        IsMultiple(Transfer_MultipleBinder self) -> Standard_Boolean

        Returns True if a starting object is bound with SEVERAL
        results : Here, returns allways True

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_MultipleBinder_IsMultiple(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Transfer_MultipleBinder self) -> Handle_Standard_Type

        Returns the Type permitted for Results, i.e. here Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_MultipleBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Transfer_MultipleBinder self) -> Standard_CString

        Returns the Name of the Type which characterizes the Result
        Here, returns "(list)"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_MultipleBinder_ResultTypeName(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Transfer_MultipleBinder self, Handle_Standard_Transient res)

        Adds a new Item to the Multiple Result

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_MultipleBinder_AddResult(self, *args)


    def NbResults(self, *args):
        """
        NbResults(Transfer_MultipleBinder self) -> Standard_Integer

        Returns the actual count of recorded (Transient) results

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_MultipleBinder_NbResults(self, *args)


    def ResultValue(self, *args):
        """
        ResultValue(Transfer_MultipleBinder self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns the value of the recorded result n0 <num>

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_MultipleBinder_ResultValue(self, *args)


    def MultipleResult(self, *args):
        """
        MultipleResult(Transfer_MultipleBinder self) -> Handle_TColStd_HSequenceOfTransient

        Returns the Multiple Result, if it is defined (at least one
        Item). Else, returns a Null Handle

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_MultipleBinder_MultipleResult(self, *args)


    def SetMultipleResult(self, *args):
        """
        SetMultipleResult(Transfer_MultipleBinder self, Handle_TColStd_HSequenceOfTransient mulres)

        Defines a Binding with a Multiple Result, given as a Sequence
        Error if a Unique Result has yet been defined

        :type mulres: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_MultipleBinder_SetMultipleResult(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_MultipleBinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_MultipleBinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_MultipleBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_MultipleBinder
Transfer_MultipleBinder_swigregister = _Transfer.Transfer_MultipleBinder_swigregister
Transfer_MultipleBinder_swigregister(Transfer_MultipleBinder)

def Transfer_MultipleBinder_get_type_name(*args):
    """
    Transfer_MultipleBinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_MultipleBinder_get_type_name(*args)

def Transfer_MultipleBinder_get_type_descriptor(*args):
    """
    Transfer_MultipleBinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_MultipleBinder_get_type_descriptor(*args)

class Transfer_Finder(Standard.Standard_Transient):
    """
    a Finder allows to map any kind of object as a Key for a Map.
    This works by defining, for a Hash Code, that of the real Key,
    not of the Finder which acts only as an intermediate.
    When a Map asks for the HashCode of a Finder, this one returns
    the code it has determined at creation time
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_Finder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_Finder(self) 
            return h


    def GetHashCode(self, *args):
        """
        GetHashCode(Transfer_Finder self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_Finder_GetHashCode(self, *args)


    def Equates(self, *args):
        """
        Equates(Transfer_Finder self, Handle_Transfer_Finder other) -> Standard_Boolean

        Specific testof equallity : to be defined by each sub-class,
        must be False if Finders have not the same true Type, else
        their contents must be compared

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Transfer_Finder self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_Finder_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Transfer_Finder self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Finder_ValueTypeName(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(Transfer_Finder self, Standard_CString const name, Handle_Standard_Transient val)

        Adds an attribute with a given name (replaces the former one
        with the same name if already exists)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_Finder_SetAttribute(self, *args)


    def RemoveAttribute(self, *args):
        """
        RemoveAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Removes an attribute
        Returns True when done, False if this attribute did not exist

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_RemoveAttribute(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(Transfer_Finder self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns an attribute from its name, filtered by a type
        If no attribute has this name, or if it is not kind of this
        type, <val> is Null and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_GetAttribute(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Transfer_Finder self, Standard_CString const name) -> Handle_Standard_Transient

        Returns an attribute from its name. Null Handle if not recorded
        (whatever Transient, Integer, Real ...)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_Finder_Attribute(self, *args)


    def AttributeType(self, *args):
        """
        AttributeType(Transfer_Finder self, Standard_CString const name) -> Interface_ParamType

        Returns the type of an attribute :
        ParamInt , ParamReal , ParamText (String) , ParamIdent (any)
        or ParamVoid (not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Transfer.Transfer_Finder_AttributeType(self, *args)


    def SetIntegerAttribute(self, *args):
        """
        SetIntegerAttribute(Transfer_Finder self, Standard_CString const name, Standard_Integer const val)

        Adds an integer value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int

        """
        return _Transfer.Transfer_Finder_SetIntegerAttribute(self, *args)


    def GetIntegerAttribute(self, *args):
        """
        GetIntegerAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as integer
        If no attribute has this name, or not an integer,
        <val> is 0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_GetIntegerAttribute(self, *args)


    def IntegerAttribute(self, *args):
        """
        IntegerAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_Integer

        Returns an integer attribute from its name. 0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_Finder_IntegerAttribute(self, *args)


    def SetRealAttribute(self, *args):
        """
        SetRealAttribute(Transfer_Finder self, Standard_CString const name, Standard_Real const val)

        Adds a real value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float

        """
        return _Transfer.Transfer_Finder_SetRealAttribute(self, *args)


    def GetRealAttribute(self, *args):
        """
        GetRealAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as real
        If no attribute has this name, or not a real
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_GetRealAttribute(self, *args)


    def RealAttribute(self, *args):
        """
        RealAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_Real

        Returns a real attribute from its name. 0.0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Transfer.Transfer_Finder_RealAttribute(self, *args)


    def SetStringAttribute(self, *args):
        """
        SetStringAttribute(Transfer_Finder self, Standard_CString const name, Standard_CString const val)

        Adds a String value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Finder_SetStringAttribute(self, *args)


    def GetStringAttribute(self, *args):
        """
        GetStringAttribute(Transfer_Finder self, Standard_CString const name, Standard_CString & val) -> Standard_Boolean

        Returns an attribute from its name, as String
        If no attribute has this name, or not a String
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_Finder_GetStringAttribute(self, *args)


    def StringAttribute(self, *args):
        """
        StringAttribute(Transfer_Finder self, Standard_CString const name) -> Standard_CString

        Returns a String attribute from its name. "" if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_Finder_StringAttribute(self, *args)


    def AttrList(self, *args):
        """
        AttrList(Transfer_Finder self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns the exhaustive list of attributes

        :rtype: OCC.wrapper.Transfer.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _Transfer.Transfer_Finder_AttrList(self, *args)


    def SameAttributes(self, *args):
        """
        SameAttributes(Transfer_Finder self, Handle_Transfer_Finder other)

        Gets the list of attributes from <other>, as such, i.e.
        not copied : attributes are shared, any attribute edited,
        added, or removed in <other> is also in <me> and vice versa
        The former list of attributes of <me> is dropped

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Transfer_Finder_SameAttributes(self, *args)


    def GetAttributes(self, *args):
        """
        GetAttributes(Transfer_Finder self, Handle_Transfer_Finder other, Standard_CString const fromname, Standard_Boolean const copied)

        Gets the list of attributes from <other>, by copying it
        By default, considers all the attributes from <other>
        If <fromname> is given, considers only the attributes with
        name beginning by <fromname>

        For each attribute, if <copied> is True (D), its value is also
        copied if it is a basic type (Integer,Real,String), else it
        remains shared between <other> and <me>

        These new attributes are added to the existing ones in <me>,
        in case of same name, they replace the existing ones

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type fromname: OCC.wrapper.Standard.Standard_CString
        :type copied: bool

        """
        return _Transfer.Transfer_Finder_GetAttributes(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_Finder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_Finder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_Finder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_Finder
Transfer_Finder_swigregister = _Transfer.Transfer_Finder_swigregister
Transfer_Finder_swigregister(Transfer_Finder)

def Transfer_Finder_get_type_name(*args):
    """
    Transfer_Finder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_Finder_get_type_name(*args)

def Transfer_Finder_get_type_descriptor(*args):
    """
    Transfer_Finder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_Finder_get_type_descriptor(*args)

class Transfer_TransferFailure(Interface.Interface_InterfaceError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_TransferFailure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_TransferFailure(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_TransferFailure self) -> Transfer_TransferFailure
        __init__(Transfer_TransferFailure self, Standard_CString const theMessage) -> Transfer_TransferFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Transfer.new_Transfer_TransferFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Transfer_TransferFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferFailure

        """
        return _Transfer.Transfer_TransferFailure_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_TransferFailure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransferFailure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_TransferFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_TransferFailure
Transfer_TransferFailure_swigregister = _Transfer.Transfer_TransferFailure_swigregister
Transfer_TransferFailure_swigregister(Transfer_TransferFailure)

def Transfer_TransferFailure_NewInstance(*args):
    """
    Transfer_TransferFailure_NewInstance(Standard_CString const theMessage) -> Handle_Transfer_TransferFailure

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferFailure

    """
    return _Transfer.Transfer_TransferFailure_NewInstance(*args)

def Transfer_TransferFailure_get_type_name(*args):
    """
    Transfer_TransferFailure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_TransferFailure_get_type_name(*args)

def Transfer_TransferFailure_get_type_descriptor(*args):
    """
    Transfer_TransferFailure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_TransferFailure_get_type_descriptor(*args)

class Transfer_ResultFromTransient(Standard.Standard_Transient):
    """
    This class, in conjunction with ResultFromModel, allows to
    record the result of a transfer initially stored in a
    TransientProcess.

    A ResultFromTransient records a couple (Transient,Binder for
    the result and checks) plus a list of "sub-results", which
    have been recorded in the TrabsientProcess, under scope
    attached to the starting transient.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ResultFromTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ResultFromTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ResultFromTransient self) -> Transfer_ResultFromTransient

        Creates a ResultFromTransient, empty


        """
        this = _Transfer.new_Transfer_ResultFromTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetStart(self, *args):
        """
        SetStart(Transfer_ResultFromTransient self, Handle_Standard_Transient start)

        Sets starting entity

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ResultFromTransient_SetStart(self, *args)


    def SetBinder(self, *args):
        """
        SetBinder(Transfer_ResultFromTransient self,  binder)

        Sets Binder (for result plus individual check)

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ResultFromTransient_SetBinder(self, *args)


    def Start(self, *args):
        """
        Start(Transfer_ResultFromTransient self) -> Handle_Standard_Transient

        Returns the starting entity

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ResultFromTransient_Start(self, *args)


    def Binder(self, *args):
        """
        Binder(Transfer_ResultFromTransient self)

        Returns the binder

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ResultFromTransient_Binder(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Transfer_ResultFromTransient self) -> Standard_Boolean

        Returns True if a result is recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ResultFromTransient_HasResult(self, *args)


    def Check(self, *args):
        """
        Check(Transfer_ResultFromTransient self) -> Handle_Interface_Check

        Returns the check (or an empty one if no binder)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_ResultFromTransient_Check(self, *args)


    def CheckStatus(self, *args):
        """
        CheckStatus(Transfer_ResultFromTransient self) -> Interface_CheckStatus

        Returns the check status

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Transfer_ResultFromTransient_CheckStatus(self, *args)


    def ClearSubs(self, *args):
        """
        ClearSubs(Transfer_ResultFromTransient self)

        Clears the list of (immediate) sub-results


        """
        return _Transfer.Transfer_ResultFromTransient_ClearSubs(self, *args)


    def AddSubResult(self, *args):
        """
        AddSubResult(Transfer_ResultFromTransient self, Handle_Transfer_ResultFromTransient sub)

        Adds a sub-result

        :type sub: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromTransient_AddSubResult(self, *args)


    def NbSubResults(self, *args):
        """
        NbSubResults(Transfer_ResultFromTransient self) -> Standard_Integer

        Returns the count of recorded sub-results

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ResultFromTransient_NbSubResults(self, *args)


    def SubResult(self, *args):
        """
        SubResult(Transfer_ResultFromTransient self, Standard_Integer const num) -> Handle_Transfer_ResultFromTransient

        Returns a sub-result, given its rank

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromTransient_SubResult(self, *args)


    def ResultFromKey(self, *args):
        """
        ResultFromKey(Transfer_ResultFromTransient self, Handle_Standard_Transient key) -> Handle_Transfer_ResultFromTransient

        Returns the ResultFromTransient attached to a given starting
        entity (the key). Returns a null handle if not found

        :type key: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromTransient_ResultFromKey(self, *args)


    def FillMap(self, *args):
        """
        FillMap(Transfer_ResultFromTransient self, NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher map)

        This method is used by ResultFromModel to collate the list of
        ResultFromTransient, avoiding duplications with a map
        Remark : <me> is already in the map and has not to be bound

        :type map: OCC.wrapper.TColStd.TColStd_IndexedMapOfTransient

        """
        return _Transfer.Transfer_ResultFromTransient_FillMap(self, *args)


    def Fill(self, *args):
        """
        Fill(Transfer_ResultFromTransient self, Handle_Transfer_TransientProcess TP)

        Fills from a TransientProcess, with the starting entity which
        must have been set before. It works with scopes, calls Fill
        on each of its sub-results

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Transfer_ResultFromTransient_Fill(self, *args)


    def Strip(self, *args):
        """
        Strip(Transfer_ResultFromTransient self)

        Clears some data attached to binders used by TransientProcess,
        which become useless once the transfer has been done :
        the list of sub-scoped binders, which is now recorded as
        sub-results


        """
        return _Transfer.Transfer_ResultFromTransient_Strip(self, *args)


    def FillBack(self, *args):
        """
        FillBack(Transfer_ResultFromTransient self, Handle_Transfer_TransientProcess TP)

        Fills back a TransientProcess with definition of a
        ResultFromTransient, respectfully to its structuration in
        scopes

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Transfer_ResultFromTransient_FillBack(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ResultFromTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ResultFromTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ResultFromTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ResultFromTransient
Transfer_ResultFromTransient_swigregister = _Transfer.Transfer_ResultFromTransient_swigregister
Transfer_ResultFromTransient_swigregister(Transfer_ResultFromTransient)

def Transfer_ResultFromTransient_get_type_name(*args):
    """
    Transfer_ResultFromTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ResultFromTransient_get_type_name(*args)

def Transfer_ResultFromTransient_get_type_descriptor(*args):
    """
    Transfer_ResultFromTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ResultFromTransient_get_type_descriptor(*args)

class Transfer_ActorOfFinderProcess(Transfer_ActorOfProcessForFinder):
    """
    The original class was renamed. Compatibility only

    ModeTrans : a simple way of transmitting a transfer mode from
    a user. To be interpreted for each norm
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ActorOfFinderProcess
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ActorOfFinderProcess(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ActorOfFinderProcess self) -> Transfer_ActorOfFinderProcess

        The original class was renamed. Compatibility only

        ModeTrans : a simple way of transmitting a transfer mode from
        a user. To be interpreted for each norm
        """
        this = _Transfer.new_Transfer_ActorOfFinderProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ModeTrans(self, *args):
        """
        ModeTrans(Transfer_ActorOfFinderProcess self) -> Standard_Integer &

        Returns the Transfer Mode, modifiable

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ActorOfFinderProcess_ModeTrans(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Transfer_ActorOfFinderProcess self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfFinderProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_ActorOfFinderProcess self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorOfFinderProcess_Transfer(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Transfer_ActorOfFinderProcess self, Handle_Standard_Transient start, Handle_Transfer_FinderProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ActorOfFinderProcess_TransferTransient(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ActorOfFinderProcess_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ActorOfFinderProcess_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ActorOfFinderProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ActorOfFinderProcess
Transfer_ActorOfFinderProcess_swigregister = _Transfer.Transfer_ActorOfFinderProcess_swigregister
Transfer_ActorOfFinderProcess_swigregister(Transfer_ActorOfFinderProcess)

def Transfer_ActorOfFinderProcess_get_type_name(*args):
    """
    Transfer_ActorOfFinderProcess_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ActorOfFinderProcess_get_type_name(*args)

def Transfer_ActorOfFinderProcess_get_type_descriptor(*args):
    """
    Transfer_ActorOfFinderProcess_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ActorOfFinderProcess_get_type_descriptor(*args)

class Transfer_ProcessForTransient(Standard.Standard_Transient):
    """
    Manages Transfer of Transient Objects. Produces also
    ActorOfTransientProcess       (deferred class),
    IteratorOfTransientProcess    (for Results),
    TransferMapOfTransientProcess (internally used)
    Normally uses as TransientProcess, which adds some specifics
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ProcessForTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ProcessForTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ProcessForTransient self, Standard_Integer const nb=10000) -> Transfer_ProcessForTransient
        __init__(Transfer_ProcessForTransient self, Handle_Message_Messenger printer, Standard_Integer const nb=10000) -> Transfer_ProcessForTransient

        Sets TransferProcess at initial state. Gives an Initial size
        (indicative) for the Map when known (default is 10000).
        Sets a specified printer.

        :type printer: OCC.wrapper.Message.Handle_Message_Messenger
        :type nb: int

        """
        this = _Transfer.new_Transfer_ProcessForTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(Transfer_ProcessForTransient self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Transfer_ProcessForTransient_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Transfer_ProcessForTransient self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Transfer_ProcessForTransient_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Transfer_ProcessForTransient self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Transfer_ProcessForTransient_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Transfer_ProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Transfer_ProcessForTransient self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Transfer_ProcessForTransient self, Handle_Standard_Transient start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Transfer_ProcessForTransient self, Handle_Standard_Transient start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Transfer_ProcessForTransient self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForTransient_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Transfer_ProcessForTransient self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForTransient_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Transfer_ProcessForTransient self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Transfer_ProcessForTransient_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Transfer_ProcessForTransient self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForTransient_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForTransient_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForTransient_SendMsg(self, *args)


    def AddError(self, *args):
        """
        AddError(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ProcessForTransient_AddError(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForTransient_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForTransient_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const pref)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ProcessForTransient_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_ProcessForTransient_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForTransient_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_ProcessForTransient_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForTransient_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForTransient_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Transfer_ProcessForTransient self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Transfer_ProcessForTransient self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_ProcessForTransient_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Transfer_ProcessForTransient self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForTransient_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Transfer_ProcessForTransient self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Transfer_ProcessForTransient_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Transfer_ProcessForTransient self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_ProcessForTransient_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Transfer_ProcessForTransient self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Transfer_ProcessForTransient self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Transfer_ProcessForTransient self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Transfer_ProcessForTransient_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForTransient_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Transfer_ProcessForTransient self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Transfer_ProcessForTransient_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Transfer_ProcessForTransient self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Transfer_ProcessForTransient self,  binder, Handle_Standard_Transient start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type mode: int

        """
        return _Transfer.Transfer_ProcessForTransient_StartTrace(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Message_Messenger S)

        Prints a short information on a starting object. By default
        prints its Dynamic Type. Can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForTransient_PrintTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Transfer_ProcessForTransient self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Transfer_ProcessForTransient self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Transfer_ProcessForTransient self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Transfer_ProcessForTransient self) -> Transfer_IteratorOfProcessForTransient

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Transfer_ProcessForTransient self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Transfer_ProcessForTransient_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Transfer_ProcessForTransient_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Transfer_ProcessForTransient_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForTransient_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type compute: bool

        """
        return _Transfer.Transfer_ProcessForTransient_RemoveResult(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Computes a number to be associated to a starting object in
        a check or a check-list
        By default, returns 0; can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForTransient_CheckNum(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Transfer_ProcessForTransient self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Transfer_ProcessForTransient_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Transfer_ProcessForTransient self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Transfer_ProcessForTransient_GetProgress(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ProcessForTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ProcessForTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ProcessForTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ProcessForTransient
Transfer_ProcessForTransient_swigregister = _Transfer.Transfer_ProcessForTransient_swigregister
Transfer_ProcessForTransient_swigregister(Transfer_ProcessForTransient)

def Transfer_ProcessForTransient_get_type_name(*args):
    """
    Transfer_ProcessForTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ProcessForTransient_get_type_name(*args)

def Transfer_ProcessForTransient_get_type_descriptor(*args):
    """
    Transfer_ProcessForTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ProcessForTransient_get_type_descriptor(*args)

class Transfer_MapContainer(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_MapContainer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_MapContainer(self) 
            return h


    def __init__(self, *args):
        """__init__(Transfer_MapContainer self) -> Transfer_MapContainer"""
        this = _Transfer.new_Transfer_MapContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMapObjects(self, *args):
        """
        SetMapObjects(Transfer_MapContainer self, NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theMapObjects)

        Set map already translated geometry objects.

        :type theMapObjects: OCC.wrapper.TColStd.TColStd_DataMapOfTransientTransient

        """
        return _Transfer.Transfer_MapContainer_SetMapObjects(self, *args)


    def GetMapObjects(self, *args):
        """
        GetMapObjects(Transfer_MapContainer self) -> NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Get map already translated geometry objects.

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfTransientTransient

        """
        return _Transfer.Transfer_MapContainer_GetMapObjects(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_MapContainer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_MapContainer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_MapContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_MapContainer
Transfer_MapContainer_swigregister = _Transfer.Transfer_MapContainer_swigregister
Transfer_MapContainer_swigregister(Transfer_MapContainer)

def Transfer_MapContainer_get_type_name(*args):
    """
    Transfer_MapContainer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_MapContainer_get_type_name(*args)

def Transfer_MapContainer_get_type_descriptor(*args):
    """
    Transfer_MapContainer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_MapContainer_get_type_descriptor(*args)

class Transfer_ActorDispatch(Transfer_ActorOfTransientProcess):
    """
    This class allows to work with a TransferDispatch, i.e. to
    transfer entities from a data set to another one defined by
    the same interface norm, with the following features :
    - ActorDispatch itself acts as a default actor, i.e. it copies
    entities with the general service Copy, as CopyTool does
    - it allows to add other actors for specific ways of transfer,
    which may include data modifications, conversions ...
    - and other features from TransferDispatch (such as mapping
    other than one-one)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ActorDispatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ActorDispatch(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ActorDispatch self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib) -> Transfer_ActorDispatch
        __init__(Transfer_ActorDispatch self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol) -> Transfer_ActorDispatch
        __init__(Transfer_ActorDispatch self, Handle_Interface_InterfaceModel amodel) -> Transfer_ActorDispatch

        Same as above, but works with the Active Protocol

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _Transfer.new_Transfer_ActorDispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddActor(self, *args):
        """
        AddActor(Transfer_ActorDispatch self, Handle_Transfer_ActorOfTransientProcess actor)

        Utility which adds an actor to the default <me> (it calls
        SetActor from the TransientProcess)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _Transfer.Transfer_ActorDispatch_AddActor(self, *args)


    def TransferDispatch(self, *args):
        """
        TransferDispatch(Transfer_ActorDispatch self) -> Transfer_TransferDispatch

        Returns the TransferDispatch, which does the work, records
        the intermediate data, etc...
        See TransferDispatch & CopyTool, to see the available methods

        :rtype: OCC.wrapper.Transfer.Transfer_TransferDispatch

        """
        return _Transfer.Transfer_ActorDispatch_TransferDispatch(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_ActorDispatch self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        Specific action : it calls the method Transfer from CopyTool
        i.e. the general service Copy, then returns the Binder
        produced by the TransientProcess

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ActorDispatch_Transfer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ActorDispatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ActorDispatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ActorDispatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ActorDispatch
Transfer_ActorDispatch_swigregister = _Transfer.Transfer_ActorDispatch_swigregister
Transfer_ActorDispatch_swigregister(Transfer_ActorDispatch)

def Transfer_ActorDispatch_get_type_name(*args):
    """
    Transfer_ActorDispatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ActorDispatch_get_type_name(*args)

def Transfer_ActorDispatch_get_type_descriptor(*args):
    """
    Transfer_ActorDispatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ActorDispatch_get_type_descriptor(*args)

class Transfer_TransferIterator(object):
    """
    Defines an Iterator on the result of a Transfer
    Available for Normal Results or not (Erroneous Transfer)
    It gives several kinds of Informations, and allows to consider
    various criteria (criteria are cumulative)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_TransferIterator self) -> Transfer_TransferIterator

        Creates an empty Iterator


        """
        this = _Transfer.new_Transfer_TransferIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddItem(self, *args):
        """
        AddItem(Transfer_TransferIterator self,  atr)

        Adds a Binder to the iteration list (construction)

        :type atr: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_TransferIterator_AddItem(self, *args)


    def SelectBinder(self, *args):
        """
        SelectBinder(Transfer_TransferIterator self, Handle_Standard_Type atype, Standard_Boolean const keep)

        Selects Items on the Type of Binder : keep only
        Binders which are of a given Type (if keep is True) or
        reject only them (if keep is False)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type keep: bool

        """
        return _Transfer.Transfer_TransferIterator_SelectBinder(self, *args)


    def SelectResult(self, *args):
        """
        SelectResult(Transfer_TransferIterator self, Handle_Standard_Type atype, Standard_Boolean const keep)

        Selects Items on the Type of Result. Considers only Unique
        Results. Considers Dynamic Type for Transient Result,
        Static Type (the one given to define the Binder) else.

        Results which are of a given Type (if keep is True) or reject
        only them (if keep is False)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type keep: bool

        """
        return _Transfer.Transfer_TransferIterator_SelectResult(self, *args)


    def SelectUnique(self, *args):
        """
        SelectUnique(Transfer_TransferIterator self, Standard_Boolean const keep)

        Select Items according Unicity : keep only Unique Results (if
        keep is True) or keep only Multiple Results (if keep is False)

        :type keep: bool

        """
        return _Transfer.Transfer_TransferIterator_SelectUnique(self, *args)


    def SelectItem(self, *args):
        """
        SelectItem(Transfer_TransferIterator self, Standard_Integer const num, Standard_Boolean const keep)

        Selects/Unselect (according to <keep> an item designated by
        its rank <num> in the list
        Used by sub-classes which have specific criteria

        :type num: int
        :type keep: bool

        """
        return _Transfer.Transfer_TransferIterator_SelectItem(self, *args)


    def Number(self, *args):
        """
        Number(Transfer_TransferIterator self) -> Standard_Integer

        Returns count of Binders to be iterated

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_TransferIterator_Number(self, *args)


    def Start(self, *args):
        """
        Start(Transfer_TransferIterator self)

        Clears Iteration in progress, to allow it to be restarted


        """
        return _Transfer.Transfer_TransferIterator_Start(self, *args)


    def More(self, *args):
        """
        More(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if there are other Items to iterate

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Transfer_TransferIterator self)

        Sets Iteration to the next Item


        """
        return _Transfer.Transfer_TransferIterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns the current Binder

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        res = _Transfer.Transfer_TransferIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasResult(self, *args):
        """
        HasResult(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if current Item brings a Result, Transient
        (Handle) or not or Multiple. That is to say, if it corresponds
        to a normally acheived Transfer, Transient Result is read by
        specific TransientResult below.
        Other kind of Result must be read specifically from its Binder

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_HasResult(self, *args)


    def HasUniqueResult(self, *args):
        """
        HasUniqueResult(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if Current Item has a Unique Result

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_HasUniqueResult(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Transfer_TransferIterator self) -> Handle_Standard_Type

        Returns the Type of the Result of the current Item, if Unique.
        If No Unique Result (Error Transfert or Multiple Result),
        returns a Null Handle
        The Type is : the Dynamic Type for a Transient Result,
        the Type defined by the Binder Class else

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransferIterator_ResultType(self, *args)


    def HasTransientResult(self, *args):
        """
        HasTransientResult(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if the current Item has a Transient Unique
        Result (if yes, use TransientResult to get it)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_HasTransientResult(self, *args)


    def TransientResult(self, *args):
        """
        Returns the Transient Result of the current Item if there is
        (else, returns a null Handle)
        Supposes that Binding is done by a SimpleBinderOfTransient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_TransferIterator_TransientResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Transfer_TransferIterator self) -> Transfer_StatusExec

        Returns Execution Status of current Binder
        Normal transfer corresponds to StatusDone

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Transfer_TransferIterator_Status(self, *args)


    def HasFails(self, *args):
        """
        HasFails(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if Fail Messages are recorded with the current
        Binder. They can then be read through Check (see below)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_HasFails(self, *args)


    def HasWarnings(self, *args):
        """
        HasWarnings(Transfer_TransferIterator self) -> Standard_Boolean

        Returns True if Warning Messages are recorded with the current
        Binder. They can then be read through Check (see below)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferIterator_HasWarnings(self, *args)


    def Check(self, *args):
        """
        Check(Transfer_TransferIterator self) -> Handle_Interface_Check

        Returns Check associated to current Binder
        (in case of error, it brings Fail messages)
        (in case of warnings, it brings Warning messages)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_TransferIterator_Check(self, *args)

    __swig_destroy__ = _Transfer.delete_Transfer_TransferIterator
Transfer_TransferIterator_swigregister = _Transfer.Transfer_TransferIterator_swigregister
Transfer_TransferIterator_swigregister(Transfer_TransferIterator)

class Transfer_SimpleBinderOfTransient(Transfer_Binder):
    """
    An adapted instantiation of SimpleBinder for Transient Result,
    i.e. ResultType can be computed from the Result itself,
    instead of being static
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_SimpleBinderOfTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_SimpleBinderOfTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_SimpleBinderOfTransient self) -> Transfer_SimpleBinderOfTransient

        Creates an empty SimpleBinderOfTransient
        Returns True if a starting object is bound with SEVERAL
        results : Here, returns allways False
        See Binder itself


        """
        this = _Transfer.new_Transfer_SimpleBinderOfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ResultType(self, *args):
        """
        ResultType(Transfer_SimpleBinderOfTransient self) -> Handle_Standard_Type

        Returns the Effective (Dynamic) Type of the Result
        (Standard_Transient if no Result is defined)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Transfer_SimpleBinderOfTransient self) -> Standard_CString

        Returns the Effective Name of (Dynamic) Type of the Result
        (void) if no result is defined

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_ResultTypeName(self, *args)


    def SetResult(self, *args):
        """
        SetResult(Transfer_SimpleBinderOfTransient self, Handle_Standard_Transient res)

        Defines the Result

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_SetResult(self, *args)


    def Result(self, *args):
        """
        Returns the defined Result, if there is one

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_SimpleBinderOfTransient_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTypedResult(*args):
        """
        GetTypedResult( bnd, Handle_Standard_Type atype, Handle_Standard_Transient res) -> Standard_Boolean

        Returns a transient result according to its type (IsKind)
        i.e. the result itself if IsKind(atype), else searches in
        NextResult, until first found, then returns True
        If not found, returns False (res is NOT touched)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <res> and can be
        immediately used, well initialised

        :type bnd: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_GetTypedResult(*args)

    GetTypedResult = staticmethod(GetTypedResult)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_SimpleBinderOfTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_SimpleBinderOfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_SimpleBinderOfTransient
Transfer_SimpleBinderOfTransient_swigregister = _Transfer.Transfer_SimpleBinderOfTransient_swigregister
Transfer_SimpleBinderOfTransient_swigregister(Transfer_SimpleBinderOfTransient)

def Transfer_SimpleBinderOfTransient_GetTypedResult(*args):
    """
    Transfer_SimpleBinderOfTransient_GetTypedResult( bnd, Handle_Standard_Type atype, Handle_Standard_Transient res) -> Standard_Boolean

    Returns a transient result according to its type (IsKind)
    i.e. the result itself if IsKind(atype), else searches in
    NextResult, until first found, then returns True
    If not found, returns False (res is NOT touched)

    This syntactic form avoids to do DownCast : if a result is
    found with the good type, it is loaded in <res> and can be
    immediately used, well initialised

    :type bnd: OCC.wrapper.Transfer.Handle_Transfer_Binder
    :type atype: OCC.wrapper.Standard.Handle_Standard_Type
    :type res: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Transfer.Transfer_SimpleBinderOfTransient_GetTypedResult(*args)

def Transfer_SimpleBinderOfTransient_get_type_name(*args):
    """
    Transfer_SimpleBinderOfTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_SimpleBinderOfTransient_get_type_name(*args)

def Transfer_SimpleBinderOfTransient_get_type_descriptor(*args):
    """
    Transfer_SimpleBinderOfTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_SimpleBinderOfTransient_get_type_descriptor(*args)

class Transfer_HSequenceOfFinder(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_HSequenceOfFinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_HSequenceOfFinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_HSequenceOfFinder self) -> Transfer_HSequenceOfFinder
        __init__(Transfer_HSequenceOfFinder self, NCollection_Sequence_Handle_Transfer_Finder theOther) -> Transfer_HSequenceOfFinder

        :type theOther: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        this = _Transfer.new_Transfer_HSequenceOfFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        res = _Transfer.Transfer_HSequenceOfFinder_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Transfer_HSequenceOfFinder self, Handle_Transfer_Finder theItem)
        Append(Transfer_HSequenceOfFinder self, NCollection_Sequence_Handle_Transfer_Finder theSequence)

        :type theSequence: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        return _Transfer.Transfer_HSequenceOfFinder_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Transfer_HSequenceOfFinder self) -> NCollection_Sequence_Handle_Transfer_Finder

        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        return _Transfer.Transfer_HSequenceOfFinder_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_HSequenceOfFinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_HSequenceOfFinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_HSequenceOfFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_HSequenceOfFinder
Transfer_HSequenceOfFinder_swigregister = _Transfer.Transfer_HSequenceOfFinder_swigregister
Transfer_HSequenceOfFinder_swigregister(Transfer_HSequenceOfFinder)

def Transfer_HSequenceOfFinder_get_type_name(*args):
    """
    Transfer_HSequenceOfFinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_HSequenceOfFinder_get_type_name(*args)

def Transfer_HSequenceOfFinder_get_type_descriptor(*args):
    """
    Transfer_HSequenceOfFinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_HSequenceOfFinder_get_type_descriptor(*args)

class NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,handle< Transfer_Binder >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,handle< Transfer_Binder >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,handle< Transfer_Binder >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,handle< Transfer_Binder >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Transfer.new_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1,  theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_Standard_Transient theKey1,  theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1)

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1)

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1)

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _Transfer.delete_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_swigregister = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Transfer.new_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper_swigregister = _Transfer.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher_IteratorHelper)


try:
	Transfer_TransferMapOfProcessForTransient = NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Transfer_Binder_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class Transfer_ProcessForFinder(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ProcessForFinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ProcessForFinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ProcessForFinder self, Standard_Integer const nb=10000) -> Transfer_ProcessForFinder
        __init__(Transfer_ProcessForFinder self, Handle_Message_Messenger printer, Standard_Integer const nb=10000) -> Transfer_ProcessForFinder

        Sets TransferProcess at initial state. Gives an Initial size
        (indicative) for the Map when known (default is 10000).
        Sets a specified printer.

        :type printer: OCC.wrapper.Message.Handle_Message_Messenger
        :type nb: int

        """
        this = _Transfer.new_Transfer_ProcessForFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(Transfer_ProcessForFinder self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Transfer_ProcessForFinder_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Transfer_ProcessForFinder self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Transfer_ProcessForFinder_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Transfer_ProcessForFinder self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Transfer_ProcessForFinder_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Transfer_ProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Transfer_ProcessForFinder self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Transfer_ProcessForFinder self, Handle_Transfer_Finder start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Transfer_ProcessForFinder self, Handle_Transfer_Finder start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Transfer_ProcessForFinder self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForFinder_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Transfer_ProcessForFinder self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForFinder_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Transfer_ProcessForFinder self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Transfer_ProcessForFinder_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Transfer_ProcessForFinder self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForFinder_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForFinder_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForFinder_SendMsg(self, *args)


    def AddError(self, *args):
        """
        AddError(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ProcessForFinder_AddError(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForFinder_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Transfer_ProcessForFinder_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const pref)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ProcessForFinder_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Transfer_ProcessForFinder_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForFinder_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_ProcessForFinder_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Transfer_ProcessForFinder_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_ProcessForFinder_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Transfer_ProcessForFinder self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Transfer_ProcessForFinder self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Transfer_ProcessForFinder_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Transfer_ProcessForFinder self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Transfer_ProcessForFinder_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Transfer_ProcessForFinder self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Transfer_ProcessForFinder_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Transfer_ProcessForFinder self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Transfer_ProcessForFinder_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Transfer_ProcessForFinder self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Transfer_ProcessForFinder self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Transfer_ProcessForFinder self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Transfer_ProcessForFinder_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Transfer_ProcessForFinder_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Transfer_ProcessForFinder self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Transfer_ProcessForFinder_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Transfer_ProcessForFinder self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Transfer_ProcessForFinder self,  binder, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type mode: int

        """
        return _Transfer.Transfer_ProcessForFinder_StartTrace(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Message_Messenger S)

        Prints a short information on a starting object. By default
        prints its Dynamic Type. Can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_ProcessForFinder_PrintTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Transfer_ProcessForFinder self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Transfer_ProcessForFinder self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Transfer_ProcessForFinder self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Transfer_ProcessForFinder self) -> Transfer_IteratorOfProcessForFinder

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Transfer_ProcessForFinder self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Transfer_ProcessForFinder_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Transfer_ProcessForFinder_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Transfer_ProcessForFinder_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ProcessForFinder_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type compute: bool

        """
        return _Transfer.Transfer_ProcessForFinder_RemoveResult(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Computes a number to be associated to a starting object in
        a check or a check-list
        By default, returns 0; can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ProcessForFinder_CheckNum(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Transfer_ProcessForFinder self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Transfer_ProcessForFinder_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Transfer_ProcessForFinder self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Transfer_ProcessForFinder_GetProgress(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ProcessForFinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ProcessForFinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ProcessForFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ProcessForFinder
Transfer_ProcessForFinder_swigregister = _Transfer.Transfer_ProcessForFinder_swigregister
Transfer_ProcessForFinder_swigregister(Transfer_ProcessForFinder)

def Transfer_ProcessForFinder_get_type_name(*args):
    """
    Transfer_ProcessForFinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ProcessForFinder_get_type_name(*args)

def Transfer_ProcessForFinder_get_type_descriptor(*args):
    """
    Transfer_ProcessForFinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ProcessForFinder_get_type_descriptor(*args)

class Handle_Transfer_HSequenceOfBinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_HSequenceOfBinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_HSequenceOfBinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_HSequenceOfBinder self, Transfer_HSequenceOfBinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_HSequenceOfBinder self, Handle_Transfer_HSequenceOfBinder theHandle) -> Handle_Transfer_HSequenceOfBinder
        assign(Handle_Transfer_HSequenceOfBinder self, Transfer_HSequenceOfBinder thePtr) -> Handle_Transfer_HSequenceOfBinder
        assign(Handle_Transfer_HSequenceOfBinder self, Handle_Transfer_HSequenceOfBinder theHandle) -> Handle_Transfer_HSequenceOfBinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_HSequenceOfBinder self) -> Transfer_HSequenceOfBinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_HSequenceOfBinder self) -> Transfer_HSequenceOfBinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_HSequenceOfBinder self) -> Transfer_HSequenceOfBinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_HSequenceOfBinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_HSequenceOfBinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_HSequenceOfBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_HSequenceOfBinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_HSequenceOfBinder

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        res = _Transfer.Handle_Transfer_HSequenceOfBinder_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Transfer_HSequenceOfBinder self,  theItem)
        Append(Handle_Transfer_HSequenceOfBinder self, NCollection_Sequence_Handle_Transfer_Binder theSequence)

        :type theSequence: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Transfer_HSequenceOfBinder self) -> NCollection_Sequence_Handle_Transfer_Binder

        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfBinder

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_HSequenceOfBinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_HSequenceOfBinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_HSequenceOfBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_HSequenceOfBinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_HSequenceOfBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_HSequenceOfBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_HSequenceOfBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_HSequenceOfBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_HSequenceOfBinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_HSequenceOfBinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_HSequenceOfBinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_HSequenceOfBinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_HSequenceOfBinder_DecrementRefCounter(self, *args)

Handle_Transfer_HSequenceOfBinder_swigregister = _Transfer.Handle_Transfer_HSequenceOfBinder_swigregister
Handle_Transfer_HSequenceOfBinder_swigregister(Handle_Transfer_HSequenceOfBinder)

def Handle_Transfer_HSequenceOfBinder_DownCast(thing):
    return _Transfer.Handle_Transfer_HSequenceOfBinder_DownCast(thing)
Handle_Transfer_HSequenceOfBinder_DownCast = _Transfer.Handle_Transfer_HSequenceOfBinder_DownCast

class Handle_Transfer_ProcessForTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ProcessForTransient self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ProcessForTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ProcessForTransient self, Transfer_ProcessForTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ProcessForTransient self, Handle_Transfer_ProcessForTransient theHandle) -> Handle_Transfer_ProcessForTransient
        assign(Handle_Transfer_ProcessForTransient self, Transfer_ProcessForTransient thePtr) -> Handle_Transfer_ProcessForTransient
        assign(Handle_Transfer_ProcessForTransient self, Handle_Transfer_ProcessForTransient theHandle) -> Handle_Transfer_ProcessForTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ProcessForTransient self) -> Transfer_ProcessForTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ProcessForTransient self) -> Transfer_ProcessForTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ProcessForTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ProcessForTransient self) -> Transfer_ProcessForTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ProcessForTransient___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ProcessForTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ProcessForTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ProcessForTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ProcessForTransient_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ProcessForTransient

    def Clear(self, *args):
        """
        Clear(Handle_Transfer_ProcessForTransient self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Handle_Transfer_ProcessForTransient self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_Transfer_ProcessForTransient self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_Transfer_ProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_Transfer_ProcessForTransient self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_Transfer_ProcessForTransient self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_Transfer_ProcessForTransient self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Transfer_ProcessForTransient self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SendMsg(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_AddFail(self, *args)


    def AddError(self, *args):
        """
        AddError(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_AddError(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_CString const pref)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_ProcessForTransient_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Handle_Transfer_ProcessForTransient self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_ProcessForTransient_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Handle_Transfer_ProcessForTransient self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Handle_Transfer_ProcessForTransient self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_ProcessForTransient_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Handle_Transfer_ProcessForTransient self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Handle_Transfer_ProcessForTransient self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_Transfer_ProcessForTransient self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_Transfer_ProcessForTransient self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Handle_Transfer_ProcessForTransient self,  binder, Handle_Standard_Transient start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type mode: int

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_StartTrace(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Handle_Message_Messenger S)

        Prints a short information on a starting object. By default
        prints its Dynamic Type. Can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_PrintTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Handle_Transfer_ProcessForTransient self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_Transfer_ProcessForTransient self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_Transfer_ProcessForTransient self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Handle_Transfer_ProcessForTransient self) -> Transfer_IteratorOfProcessForTransient

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_Transfer_ProcessForTransient self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type compute: bool

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_RemoveResult(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Handle_Transfer_ProcessForTransient self, Handle_Standard_Transient start) -> Standard_Integer

        Computes a number to be associated to a starting object in
        a check or a check-list
        By default, returns 0; can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_CheckNum(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Handle_Transfer_ProcessForTransient self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Handle_Transfer_ProcessForTransient self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_GetProgress(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ProcessForTransient self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ProcessForTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ProcessForTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ProcessForTransient self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ProcessForTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ProcessForTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ProcessForTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ProcessForTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ProcessForTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ProcessForTransient self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ProcessForTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ProcessForTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForTransient_DecrementRefCounter(self, *args)

Handle_Transfer_ProcessForTransient_swigregister = _Transfer.Handle_Transfer_ProcessForTransient_swigregister
Handle_Transfer_ProcessForTransient_swigregister(Handle_Transfer_ProcessForTransient)

def Handle_Transfer_ProcessForTransient_DownCast(thing):
    return _Transfer.Handle_Transfer_ProcessForTransient_DownCast(thing)
Handle_Transfer_ProcessForTransient_DownCast = _Transfer.Handle_Transfer_ProcessForTransient_DownCast

class Transfer_TransientListBinder(Transfer_Binder):
    """
    This binder binds several (a list of) Transients with a starting
    entity, when this entity itself corresponds to a simple list
    of Transients. Each part is not seen as a sub-result of an
    independant componant, but as an item of a built-in list
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_TransientListBinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_TransientListBinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_TransientListBinder self) -> Transfer_TransientListBinder
        __init__(Transfer_TransientListBinder self, Handle_TColStd_HSequenceOfTransient list) -> Transfer_TransientListBinder

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        this = _Transfer.new_Transfer_TransientListBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsMultiple(self, *args):
        """
        IsMultiple(Transfer_TransientListBinder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientListBinder_IsMultiple(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Transfer_TransientListBinder self) -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransientListBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Transfer_TransientListBinder self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_TransientListBinder_ResultTypeName(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Transfer_TransientListBinder self, Handle_Standard_Transient res)

        Adds an item to the result list

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_TransientListBinder_AddResult(self, *args)


    def Result(self, *args):
        """
        Result(Transfer_TransientListBinder self) -> Handle_TColStd_HSequenceOfTransient

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_TransientListBinder_Result(self, *args)


    def SetResult(self, *args):
        """
        SetResult(Transfer_TransientListBinder self, Standard_Integer const num, Handle_Standard_Transient res)

        Changes an already defined sub-result

        :type num: int
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_TransientListBinder_SetResult(self, *args)


    def NbTransients(self, *args):
        """
        NbTransients(Transfer_TransientListBinder self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_TransientListBinder_NbTransients(self, *args)


    def Transient(self, *args):
        """
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_TransientListBinder_Transient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_TransientListBinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransientListBinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_TransientListBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_TransientListBinder
Transfer_TransientListBinder_swigregister = _Transfer.Transfer_TransientListBinder_swigregister
Transfer_TransientListBinder_swigregister(Transfer_TransientListBinder)

def Transfer_TransientListBinder_get_type_name(*args):
    """
    Transfer_TransientListBinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_TransientListBinder_get_type_name(*args)

def Transfer_TransientListBinder_get_type_descriptor(*args):
    """
    Transfer_TransientListBinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_TransientListBinder_get_type_descriptor(*args)

class Transfer_VoidBinder(Transfer_Binder):
    """
    a VoidBinder is used to bind a starting item with a status,
    error or warning messages, but no result
    It is interpreted by TransferProcess, which admits a
    VoidBinder to be over-written, and copies its check to the
    new Binder
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_VoidBinder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_VoidBinder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_VoidBinder self) -> Transfer_VoidBinder

        a VoidBinder is not Multiple (Remark : it is not Simple too)
        But it can bring next results ...


        """
        this = _Transfer.new_Transfer_VoidBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ResultType(self, *args):
        """
        ResultType(Transfer_VoidBinder self) -> Handle_Standard_Type

        while a VoidBinder admits no Result, its ResultType returns
        the type of <me>

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_VoidBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Transfer_VoidBinder self) -> Standard_CString

        Returns "(void)"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_VoidBinder_ResultTypeName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_VoidBinder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_VoidBinder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_VoidBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_VoidBinder
Transfer_VoidBinder_swigregister = _Transfer.Transfer_VoidBinder_swigregister
Transfer_VoidBinder_swigregister(Transfer_VoidBinder)

def Transfer_VoidBinder_get_type_name(*args):
    """
    Transfer_VoidBinder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_VoidBinder_get_type_name(*args)

def Transfer_VoidBinder_get_type_descriptor(*args):
    """
    Transfer_VoidBinder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_VoidBinder_get_type_descriptor(*args)

class Transfer_TransferDeadLoop(Transfer_TransferFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_TransferDeadLoop
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_TransferDeadLoop(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_TransferDeadLoop self) -> Transfer_TransferDeadLoop
        __init__(Transfer_TransferDeadLoop self, Standard_CString const theMessage) -> Transfer_TransferDeadLoop

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Transfer.new_Transfer_TransferDeadLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Transfer_TransferDeadLoop

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferDeadLoop

        """
        return _Transfer.Transfer_TransferDeadLoop_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_TransferDeadLoop_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransferDeadLoop_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_TransferDeadLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_TransferDeadLoop
Transfer_TransferDeadLoop_swigregister = _Transfer.Transfer_TransferDeadLoop_swigregister
Transfer_TransferDeadLoop_swigregister(Transfer_TransferDeadLoop)

def Transfer_TransferDeadLoop_NewInstance(*args):
    """
    Transfer_TransferDeadLoop_NewInstance(Standard_CString const theMessage) -> Handle_Transfer_TransferDeadLoop

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferDeadLoop

    """
    return _Transfer.Transfer_TransferDeadLoop_NewInstance(*args)

def Transfer_TransferDeadLoop_get_type_name(*args):
    """
    Transfer_TransferDeadLoop_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_TransferDeadLoop_get_type_name(*args)

def Transfer_TransferDeadLoop_get_type_descriptor(*args):
    """
    Transfer_TransferDeadLoop_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_TransferDeadLoop_get_type_descriptor(*args)

class Transfer_TransientMapper(Transfer_Finder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_TransientMapper
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_TransientMapper(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_TransientMapper self, Handle_Standard_Transient akey) -> Transfer_TransientMapper

        Creates a Mapper with a Value. This Value can then not be
        changed. It is used by the Hasher to compute the HashCode,
        which will then be stored for an immediate reading.

        :type akey: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _Transfer.new_Transfer_TransientMapper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Returns the contained value

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_TransientMapper_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Equates(self, *args):
        """
        Equates(Transfer_TransientMapper self, Handle_Transfer_Finder other) -> Standard_Boolean

        Specific testof equallity : defined as False if <other> has
        not the same true Type, else contents are compared (by
        C++ operator ==)

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientMapper_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Transfer_TransientMapper self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransientMapper_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Transfer_TransientMapper self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_TransientMapper_ValueTypeName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_TransientMapper_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransientMapper_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_TransientMapper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_TransientMapper
Transfer_TransientMapper_swigregister = _Transfer.Transfer_TransientMapper_swigregister
Transfer_TransientMapper_swigregister(Transfer_TransientMapper)

def Transfer_TransientMapper_get_type_name(*args):
    """
    Transfer_TransientMapper_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_TransientMapper_get_type_name(*args)

def Transfer_TransientMapper_get_type_descriptor(*args):
    """
    Transfer_TransientMapper_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_TransientMapper_get_type_descriptor(*args)

class Handle_Transfer_DispatchControl(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_DispatchControl self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_DispatchControl_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_DispatchControl self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_DispatchControl_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_DispatchControl self, Transfer_DispatchControl thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_DispatchControl_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_DispatchControl self, Handle_Transfer_DispatchControl theHandle) -> Handle_Transfer_DispatchControl
        assign(Handle_Transfer_DispatchControl self, Transfer_DispatchControl thePtr) -> Handle_Transfer_DispatchControl
        assign(Handle_Transfer_DispatchControl self, Handle_Transfer_DispatchControl theHandle) -> Handle_Transfer_DispatchControl

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_DispatchControl_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_DispatchControl self) -> Transfer_DispatchControl

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_DispatchControl_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_DispatchControl self) -> Transfer_DispatchControl

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_DispatchControl___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_DispatchControl self) -> Transfer_DispatchControl

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_DispatchControl___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_DispatchControl___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_DispatchControl___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_DispatchControl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_DispatchControl_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_DispatchControl

    def TransientProcess(self, *args):
        """
        Returns the content of the DispatchControl : it can be used
        for a direct call, if the basic methods do not suffice

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        res = _Transfer.Handle_Transfer_DispatchControl_TransientProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartingModel(self, *args):
        """
        Returns the Model from which the transfer is to be done

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        res = _Transfer.Handle_Transfer_DispatchControl_StartingModel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_Transfer_DispatchControl self)

        Clears the List of Copied Results


        """
        return _Transfer.Handle_Transfer_DispatchControl_Clear(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Transfer_DispatchControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res)

        Binds a (Transient) Result to a (Transient) Starting Entity

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_DispatchControl_Bind(self, *args)


    def Search(self, *args):
        """
        Search(Handle_Transfer_DispatchControl self, Handle_Standard_Transient ent, Handle_Standard_Transient res) -> Standard_Boolean

        Searches for the Result bound to a Starting Entity
        If Found, returns True and fills <res>
        Else, returns False and nullifies <res>

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_DispatchControl_Search(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_DispatchControl self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_DispatchControl_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_DispatchControl_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_DispatchControl_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_DispatchControl self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_DispatchControl_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_DispatchControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_DispatchControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_DispatchControl_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_DispatchControl self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_DispatchControl self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_DispatchControl_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_DispatchControl self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_DispatchControl_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_DispatchControl self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_DispatchControl_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_DispatchControl self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_DispatchControl_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_DispatchControl self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_DispatchControl_DecrementRefCounter(self, *args)

Handle_Transfer_DispatchControl_swigregister = _Transfer.Handle_Transfer_DispatchControl_swigregister
Handle_Transfer_DispatchControl_swigregister(Handle_Transfer_DispatchControl)

def Handle_Transfer_DispatchControl_DownCast(thing):
    return _Transfer.Handle_Transfer_DispatchControl_DownCast(thing)
Handle_Transfer_DispatchControl_DownCast = _Transfer.Handle_Transfer_DispatchControl_DownCast

class Handle_Transfer_TransferFailure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_TransferFailure self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_TransferFailure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_TransferFailure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_TransferFailure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_TransferFailure self, Transfer_TransferFailure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_TransferFailure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_TransferFailure self, Handle_Transfer_TransferFailure theHandle) -> Handle_Transfer_TransferFailure
        assign(Handle_Transfer_TransferFailure self, Transfer_TransferFailure thePtr) -> Handle_Transfer_TransferFailure
        assign(Handle_Transfer_TransferFailure self, Handle_Transfer_TransferFailure theHandle) -> Handle_Transfer_TransferFailure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_TransferFailure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_TransferFailure self) -> Transfer_TransferFailure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransferFailure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_TransferFailure self) -> Transfer_TransferFailure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransferFailure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_TransferFailure self) -> Transfer_TransferFailure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_TransferFailure___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_TransferFailure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_TransferFailure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_TransferFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_TransferFailure_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_TransferFailure

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Transfer_TransferFailure self, Standard_CString const theMessage) -> Handle_Transfer_TransferFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferFailure

        """
        return _Transfer.Handle_Transfer_TransferFailure_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_TransferFailure self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_TransferFailure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransferFailure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransferFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Transfer_TransferFailure self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Transfer.Handle_Transfer_TransferFailure_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Transfer_TransferFailure self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransferFailure_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Transfer_TransferFailure self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransferFailure_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Transfer_TransferFailure self)
        Reraise(Handle_Transfer_TransferFailure self, Standard_CString const aMessage)
        Reraise(Handle_Transfer_TransferFailure self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Transfer.Handle_Transfer_TransferFailure_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Transfer_TransferFailure self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Transfer.Handle_Transfer_TransferFailure_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Transfer_TransferFailure self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Transfer.Handle_Transfer_TransferFailure_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_TransferFailure self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_TransferFailure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_TransferFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_TransferFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransferFailure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_TransferFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_TransferFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransferFailure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_TransferFailure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransferFailure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_TransferFailure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransferFailure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_TransferFailure self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_TransferFailure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_TransferFailure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransferFailure_DecrementRefCounter(self, *args)

Handle_Transfer_TransferFailure_swigregister = _Transfer.Handle_Transfer_TransferFailure_swigregister
Handle_Transfer_TransferFailure_swigregister(Handle_Transfer_TransferFailure)

def Handle_Transfer_TransferFailure_DownCast(thing):
    return _Transfer.Handle_Transfer_TransferFailure_DownCast(thing)
Handle_Transfer_TransferFailure_DownCast = _Transfer.Handle_Transfer_TransferFailure_DownCast

class Transfer_FindHasher(object):
    """
    FindHasher defines HashCode for Finder, which is : ask a
    Finder its HashCode !  Because this is the Finder itself which
    brings the HashCode for its Key

    This class complies to the template given in TCollection by
    MapHasher itself
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_Transfer_Finder K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HashCode in the range <0,Upper> for a Finder :
        asks the Finder its HashCode then transforms it to be in the
        required range

        :type K: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_FindHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_Transfer_Finder K1, Handle_Transfer_Finder K2) -> Standard_Boolean

        Returns True if two keys are the same.
        The test does not work on the Finders themselves but by
        calling their methods Equates

        :type K1: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type K2: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_FindHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        FindHasher defines HashCode for Finder, which is : ask a
        Finder its HashCode !  Because this is the Finder itself which
        brings the HashCode for its Key

        This class complies to the template given in TCollection by
        MapHasher itself
        """
        this = _Transfer.new_Transfer_FindHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_Transfer_FindHasher
Transfer_FindHasher_swigregister = _Transfer.Transfer_FindHasher_swigregister
Transfer_FindHasher_swigregister(Transfer_FindHasher)

def Transfer_FindHasher_HashCode(*args):
    """
    Transfer_FindHasher_HashCode(Handle_Transfer_Finder K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HashCode in the range <0,Upper> for a Finder :
    asks the Finder its HashCode then transforms it to be in the
    required range

    :type K: OCC.wrapper.Transfer.Handle_Transfer_Finder
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Transfer.Transfer_FindHasher_HashCode(*args)

def Transfer_FindHasher_IsEqual(*args):
    """
    Transfer_FindHasher_IsEqual(Handle_Transfer_Finder K1, Handle_Transfer_Finder K2) -> Standard_Boolean

    Returns True if two keys are the same.
    The test does not work on the Finders themselves but by
    calling their methods Equates

    :type K1: OCC.wrapper.Transfer.Handle_Transfer_Finder
    :type K2: OCC.wrapper.Transfer.Handle_Transfer_Finder
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Transfer.Transfer_FindHasher_IsEqual(*args)

class Handle_Transfer_MultipleBinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_MultipleBinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_MultipleBinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_MultipleBinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_MultipleBinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_MultipleBinder self, Transfer_MultipleBinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_MultipleBinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_MultipleBinder self, Handle_Transfer_MultipleBinder theHandle) -> Handle_Transfer_MultipleBinder
        assign(Handle_Transfer_MultipleBinder self, Transfer_MultipleBinder thePtr) -> Handle_Transfer_MultipleBinder
        assign(Handle_Transfer_MultipleBinder self, Handle_Transfer_MultipleBinder theHandle) -> Handle_Transfer_MultipleBinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_MultipleBinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_MultipleBinder self) -> Transfer_MultipleBinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_MultipleBinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_MultipleBinder self) -> Transfer_MultipleBinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_MultipleBinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_MultipleBinder self) -> Transfer_MultipleBinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_MultipleBinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_MultipleBinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_MultipleBinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_MultipleBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_MultipleBinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_MultipleBinder

    def IsMultiple(self, *args):
        """
        IsMultiple(Handle_Transfer_MultipleBinder self) -> Standard_Boolean

        Returns True if a starting object is bound with SEVERAL
        results : Here, returns allways True

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MultipleBinder_IsMultiple(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Handle_Transfer_MultipleBinder self) -> Handle_Standard_Type

        Returns the Type permitted for Results, i.e. here Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_MultipleBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Handle_Transfer_MultipleBinder self) -> Standard_CString

        Returns the Name of the Type which characterizes the Result
        Here, returns "(list)"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_MultipleBinder_ResultTypeName(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Handle_Transfer_MultipleBinder self, Handle_Standard_Transient res)

        Adds a new Item to the Multiple Result

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_MultipleBinder_AddResult(self, *args)


    def NbResults(self, *args):
        """
        NbResults(Handle_Transfer_MultipleBinder self) -> Standard_Integer

        Returns the actual count of recorded (Transient) results

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_MultipleBinder_NbResults(self, *args)


    def ResultValue(self, *args):
        """
        ResultValue(Handle_Transfer_MultipleBinder self, Standard_Integer const num) -> Handle_Standard_Transient

        Returns the value of the recorded result n0 <num>

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_MultipleBinder_ResultValue(self, *args)


    def MultipleResult(self, *args):
        """
        MultipleResult(Handle_Transfer_MultipleBinder self) -> Handle_TColStd_HSequenceOfTransient

        Returns the Multiple Result, if it is defined (at least one
        Item). Else, returns a Null Handle

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_MultipleBinder_MultipleResult(self, *args)


    def SetMultipleResult(self, *args):
        """
        SetMultipleResult(Handle_Transfer_MultipleBinder self, Handle_TColStd_HSequenceOfTransient mulres)

        Defines a Binding with a Multiple Result, given as a Sequence
        Error if a Unique Result has yet been defined

        :type mulres: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_MultipleBinder_SetMultipleResult(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_MultipleBinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_MultipleBinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_MultipleBinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_MultipleBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Merge(self, *args):
        """
        Merge(Handle_Transfer_MultipleBinder self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_MultipleBinder_Merge(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Handle_Transfer_MultipleBinder self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_MultipleBinder_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_MultipleBinder self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MultipleBinder_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Handle_Transfer_MultipleBinder self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Handle_Transfer_MultipleBinder_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Transfer_MultipleBinder self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Handle_Transfer_MultipleBinder_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Handle_Transfer_MultipleBinder self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_MultipleBinder_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Handle_Transfer_MultipleBinder self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_MultipleBinder_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_MultipleBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_MultipleBinder_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_MultipleBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_MultipleBinder_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_MultipleBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_MultipleBinder_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Handle_Transfer_MultipleBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_MultipleBinder_CCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_MultipleBinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_MultipleBinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_MultipleBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_MultipleBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MultipleBinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_MultipleBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_MultipleBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MultipleBinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_MultipleBinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_MultipleBinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_MultipleBinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_MultipleBinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_MultipleBinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_MultipleBinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_MultipleBinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_MultipleBinder_DecrementRefCounter(self, *args)

Handle_Transfer_MultipleBinder_swigregister = _Transfer.Handle_Transfer_MultipleBinder_swigregister
Handle_Transfer_MultipleBinder_swigregister(Handle_Transfer_MultipleBinder)

def Handle_Transfer_MultipleBinder_DownCast(thing):
    return _Transfer.Handle_Transfer_MultipleBinder_DownCast(thing)
Handle_Transfer_MultipleBinder_DownCast = _Transfer.Handle_Transfer_MultipleBinder_DownCast

class Transfer_TransientProcess(Transfer_ProcessForTransient):
    """
    Adds specific features to the generic definition :
    TransientProcess is intended to work from an InterfaceModel
    to a set of application objects.

    Hence, some informations about starting entities can be gotten
    from the model : for Trace, CheckList, Integrity Status
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_TransientProcess
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_TransientProcess(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_TransientProcess self, Standard_Integer const nb=10000) -> Transfer_TransientProcess

        Sets TransientProcess at initial state, with an initial size

        :type nb: int

        """
        this = _Transfer.new_Transfer_TransientProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetModel(self, *args):
        """
        SetModel(Transfer_TransientProcess self, Handle_Interface_InterfaceModel model)

        Sets an InterfaceModel, used by StartTrace, CheckList, queries
        on Integrity, to give informations significant for each norm.

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_TransientProcess_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Transfer_TransientProcess self) -> Handle_Interface_InterfaceModel

        Returns the Model used for StartTrace

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_TransientProcess_Model(self, *args)


    def SetGraph(self, *args):
        """
        SetGraph(Transfer_TransientProcess self, Handle_Interface_HGraph HG)

        Sets a Graph : superseedes SetModel if already done

        :type HG: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _Transfer.Transfer_TransientProcess_SetGraph(self, *args)


    def HasGraph(self, *args):
        """
        HasGraph(Transfer_TransientProcess self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientProcess_HasGraph(self, *args)


    def HGraph(self, *args):
        """
        HGraph(Transfer_TransientProcess self) -> Handle_Interface_HGraph

        :rtype: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _Transfer.Transfer_TransientProcess_HGraph(self, *args)


    def Graph(self, *args):
        """
        Graph(Transfer_TransientProcess self) -> Interface_Graph

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        return _Transfer.Transfer_TransientProcess_Graph(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Transfer_TransientProcess self, Standard_CString const name, Handle_Standard_Transient ctx)

        Sets a Context : according to receiving appli, to be
        interpreted by the Actor

        :type name: OCC.wrapper.Standard.Standard_CString
        :type ctx: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_TransientProcess_SetContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Transfer_TransientProcess self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient ctx) -> Standard_Boolean

        Returns the Context attached to a name, if set and if it is
        Kind of the type, else a Null Handle
        Returns True if OK, False if no Context

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type ctx: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientProcess_GetContext(self, *args)


    def Context(self, *args):
        """
        Context(Transfer_TransientProcess self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns (modifiable) the whole definition of Context
        Rather for internal use (ex.: preparing and setting in once)

        :rtype: OCC.wrapper.Transfer.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _Transfer.Transfer_TransientProcess_Context(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Message_Messenger S)

        Specific printing to trace an entity : prints label and type
        (if model is set)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_TransientProcess_PrintTrace(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Integer

        Specific number of a starting object for check-list : Number
        in model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_TransientProcess_CheckNum(self, *args)


    def TypedSharings(self, *args):
        """
        TypedSharings(Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Standard_Type type) -> Interface_EntityIterator

        Returns the list of sharings entities, AT ANY LEVEL, which are
        kind of a given type. Calls TypedSharings from Graph
        Returns an empty list if the Graph has not been aknowledged

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Transfer.Transfer_TransientProcess_TypedSharings(self, *args)


    def IsDataLoaded(self, *args):
        """
        IsDataLoaded(Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Boolean

        Tells if an entity is well loaded from file (even if its data
        fail on checking, they are present). Mostly often, answers
        True. Else, there was a syntactic error in the file.
        A non-loaded entity MAY NOT BE transferred, unless its Report
        (in the model) is interpreted

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientProcess_IsDataLoaded(self, *args)


    def IsDataFail(self, *args):
        """
        IsDataFail(Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Boolean

        Tells if an entity fails on data checking (load time,
        syntactic, or semantic check). Normally, should answer False.
        It is not prudent to try transferring an entity which fails on
        data checking

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransientProcess_IsDataFail(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Transfer_TransientProcess self, Standard_Integer const mode, Handle_Message_Messenger S)

        Prints statistics on a given output, according mode

        :type mode: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_TransientProcess_PrintStats(self, *args)


    def RootsForTransfer(self, *args):
        """
        RootsForTransfer(Transfer_TransientProcess self) -> Handle_TColStd_HSequenceOfTransient

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_TransientProcess_RootsForTransfer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_TransientProcess_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_TransientProcess_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_TransientProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_TransientProcess
Transfer_TransientProcess_swigregister = _Transfer.Transfer_TransientProcess_swigregister
Transfer_TransientProcess_swigregister(Transfer_TransientProcess)

def Transfer_TransientProcess_get_type_name(*args):
    """
    Transfer_TransientProcess_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_TransientProcess_get_type_name(*args)

def Transfer_TransientProcess_get_type_descriptor(*args):
    """
    Transfer_TransientProcess_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_TransientProcess_get_type_descriptor(*args)

class Transfer_FinderProcess(Transfer_ProcessForFinder):
    """
    Adds specific features to the generic definition :
    PrintTrace is adapted
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_FinderProcess
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_FinderProcess(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_FinderProcess self, Standard_Integer const nb=10000) -> Transfer_FinderProcess

        Sets FinderProcess at initial state, with an initial size

        :type nb: int

        """
        this = _Transfer.new_Transfer_FinderProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetModel(self, *args):
        """
        SetModel(Transfer_FinderProcess self, Handle_Interface_InterfaceModel model)

        Sets an InterfaceModel, which can be used during transfer
        for instance if a context must be managed, it is in the Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_FinderProcess_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Transfer_FinderProcess self) -> Handle_Interface_InterfaceModel

        Returns the Model which can be used for context

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_FinderProcess_Model(self, *args)


    def NextMappedWithAttribute(self, *args):
        """
        NextMappedWithAttribute(Transfer_FinderProcess self, Standard_CString const name, Standard_Integer const num0) -> Standard_Integer

        In the list of mapped items (between 1 and NbMapped),
        searches for the first mapped item which follows <num0>
        (not included) and which has an attribute named <name>
        The considered Attributes are those brought by Finders,i.e.
        by Input data.
        While NextItemWithAttribute works on Result data (Binders)

        Hence, allows such an iteration

        for (num = FP->NextMappedWithAttribute(name,0);
        num > 0;
        num = FP->NextMappedWithAttribute(name,num) {
        .. process mapped item <num>
        }

        :type name: OCC.wrapper.Standard.Standard_CString
        :type num0: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_FinderProcess_NextMappedWithAttribute(self, *args)


    def TransientMapper(self, *args):
        """
        TransientMapper(Transfer_FinderProcess self, Handle_Standard_Transient obj) -> Handle_Transfer_TransientMapper

        Returns a TransientMapper for a given Transient Object
        Either <obj> is already mapped, then its Mapper is returned
        Or it is not, then a new one is created then returned, BUT
        it is not mapped here (use Bind or FindElseBind to do this)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientMapper

        """
        return _Transfer.Transfer_FinderProcess_TransientMapper(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Transfer_FinderProcess self, Handle_Transfer_Finder start, Handle_Message_Messenger S)

        Specific printing to trace a Finder (by its method ValueType)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_FinderProcess_PrintTrace(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Transfer_FinderProcess self, Standard_Integer const mode, Handle_Message_Messenger S)

        Prints statistics on a given output, according mode

        :type mode: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Transfer_FinderProcess_PrintStats(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_FinderProcess_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_FinderProcess_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_FinderProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_FinderProcess
Transfer_FinderProcess_swigregister = _Transfer.Transfer_FinderProcess_swigregister
Transfer_FinderProcess_swigregister(Transfer_FinderProcess)

def Transfer_FinderProcess_get_type_name(*args):
    """
    Transfer_FinderProcess_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_FinderProcess_get_type_name(*args)

def Transfer_FinderProcess_get_type_descriptor(*args):
    """
    Transfer_FinderProcess_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_FinderProcess_get_type_descriptor(*args)

class Transfer_ResultFromModel(Standard.Standard_Transient):
    """
    ResultFromModel is used to store a final result stored in a
    TransientProcess, respectfully to its structuration in scopes
    by using a set of ResultFromTransient
    Hence, it can be regarded as a passive equivalent of the
    stored data in the TransientProcess, while an Iterator gives
    a flat view of it.

    A ResultFromModel is intended to be attached to the transfer
    of one entity (typically root entity but it is not mandatory)

    It is then possible to :
    - Create and fill a ResultFromModel from a TransientProcess,
    by designating a starting entity
    - Fill back the TransientProcess from a ResultFromModel, as it
    were filled by the operation which filled it the first time
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_ResultFromModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_ResultFromModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_ResultFromModel self) -> Transfer_ResultFromModel

        Creates a ResultFromModel, empty


        """
        this = _Transfer.new_Transfer_ResultFromModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetModel(self, *args):
        """
        SetModel(Transfer_ResultFromModel self, Handle_Interface_InterfaceModel model)

        Sets starting Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_ResultFromModel_SetModel(self, *args)


    def SetFileName(self, *args):
        """
        SetFileName(Transfer_ResultFromModel self, Standard_CString const filename)

        Sets starting File Name

        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ResultFromModel_SetFileName(self, *args)


    def Model(self, *args):
        """
        Model(Transfer_ResultFromModel self) -> Handle_Interface_InterfaceModel

        Returns starting Model (null if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_ResultFromModel_Model(self, *args)


    def FileName(self, *args):
        """
        FileName(Transfer_ResultFromModel self) -> Standard_CString

        Returns starting File Name (empty if not set)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ResultFromModel_FileName(self, *args)


    def Fill(self, *args):
        """
        Fill(Transfer_ResultFromModel self, Handle_Transfer_TransientProcess TP, Handle_Standard_Transient ent) -> Standard_Boolean

        Fills from a TransientProcess, with the result attached to
        a starting entity. Considers its Model if it is set.
        This action produces a structured set of ResultFromTransient,
        considering scopes, starting by that of <ent>.
        If <ent> has no recorded result, it remains empty
        Returns True if a result is recorded, False else

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ResultFromModel_Fill(self, *args)


    def Strip(self, *args):
        """
        Strip(Transfer_ResultFromModel self, Standard_Integer const mode)

        Clears some data attached to binders used by TransientProcess,
        which become useless once the transfer has been done,
        by calling Strip on its ResultFromTransient

        mode = 0 : minimum, clears data remaining from TransferProcess
        mode = 10 : just keeps file name, label, check status ...,
        and MainResult but only the result (Binder)
        mode = 11 : also clears MainResult (status and names remain)

        :type mode: int

        """
        return _Transfer.Transfer_ResultFromModel_Strip(self, *args)


    def FillBack(self, *args):
        """
        FillBack(Transfer_ResultFromModel self, Handle_Transfer_TransientProcess TP)

        Fills back a TransientProcess from the structured set of
        binders. Also sets the Model.

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Transfer_ResultFromModel_FillBack(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Transfer_ResultFromModel self) -> Standard_Boolean

        Returns True if a Result is recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_ResultFromModel_HasResult(self, *args)


    def MainResult(self, *args):
        """
        MainResult(Transfer_ResultFromModel self) -> Handle_Transfer_ResultFromTransient

        Returns the main recorded ResultFromTransient, or a null

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromModel_MainResult(self, *args)


    def SetMainResult(self, *args):
        """
        SetMainResult(Transfer_ResultFromModel self, Handle_Transfer_ResultFromTransient amain)

        Sets a new value for the main recorded ResultFromTransient

        :type amain: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromModel_SetMainResult(self, *args)


    def MainLabel(self, *args):
        """
        MainLabel(Transfer_ResultFromModel self) -> Standard_CString

        Returns the label in starting model attached to main entity
        (updated by Fill or SetMainResult, if Model is known)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_ResultFromModel_MainLabel(self, *args)


    def MainNumber(self, *args):
        """
        MainNumber(Transfer_ResultFromModel self) -> Standard_Integer

        Returns the label in starting model attached to main entity

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_ResultFromModel_MainNumber(self, *args)


    def ResultFromKey(self, *args):
        """
        ResultFromKey(Transfer_ResultFromModel self, Handle_Standard_Transient start) -> Handle_Transfer_ResultFromTransient

        Searches for a key (starting entity) and returns its result
        Returns a null handle if not found

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Transfer_ResultFromModel_ResultFromKey(self, *args)


    def Results(self, *args):
        """
        Results(Transfer_ResultFromModel self, Standard_Integer const level) -> Handle_TColStd_HSequenceOfTransient

        Internal method which returns the list of ResultFromTransient,
        according level (2:complete; 1:sub-level 1; 0:main only)

        :type level: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_ResultFromModel_Results(self, *args)


    def TransferredList(self, *args):
        """
        TransferredList(Transfer_ResultFromModel self, Standard_Integer const level=2) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of recorded starting entities, ending by the
        root. Entities with check but no transfer result are ignored
        <level> = 2 (D), considers the complete list
        <level> = 1      considers the main result plus immediate subs
        <level> = 0      just the main result

        :type level: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_ResultFromModel_TransferredList(self, *args)


    def CheckedList(self, *args):
        """
        CheckedList(Transfer_ResultFromModel self, Interface_CheckStatus const check, Standard_Boolean const result) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of starting entities to which a check status
        is attached.
        <check> = -2 , all entities whatever the check (see result)
        <check> = -1 , entities with no fail (warning allowed)
        <check> =  0 , entities with no check at all
        <check> =  1 , entities with warning but no fail
        <check> =  2 , entities with fail
        <result> : if True, only entities with an attached result
        Remark : result True and check=0 will give an empty list

        :type check: OCC.wrapper.Interface.Interface_CheckStatus
        :type result: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Transfer_ResultFromModel_CheckedList(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Transfer_ResultFromModel self, Standard_Boolean const erronly, Standard_Integer const level=2) -> Interface_CheckIterator

        Returns the check-list of this set of results
        <erronly> true : only fails are considered
        <level> = 0 : considers only main binder
        <level> = 1 : considers main binder plus immediate subs
        <level> = 2 (D) : considers all checks

        :type erronly: bool
        :type level: int
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Transfer_ResultFromModel_CheckList(self, *args)


    def CheckStatus(self, *args):
        """
        CheckStatus(Transfer_ResultFromModel self) -> Interface_CheckStatus

        Returns the check status with corresponds to the content
        of this ResultFromModel; considers all levels of transfer
        (worst status). Returns CheckAny if not yet computed
        Reads it from recorded status if already computed, else
        recomputes one

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Transfer_ResultFromModel_CheckStatus(self, *args)


    def ComputeCheckStatus(self, *args):
        """
        ComputeCheckStatus(Transfer_ResultFromModel self, Standard_Boolean const enforce) -> Interface_CheckStatus

        Computes and records check status (see CheckStatus)
        Does not computes it if already done and <enforce> False

        :type enforce: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Transfer_ResultFromModel_ComputeCheckStatus(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_ResultFromModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_ResultFromModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_ResultFromModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_ResultFromModel
Transfer_ResultFromModel_swigregister = _Transfer.Transfer_ResultFromModel_swigregister
Transfer_ResultFromModel_swigregister(Transfer_ResultFromModel)

def Transfer_ResultFromModel_get_type_name(*args):
    """
    Transfer_ResultFromModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_ResultFromModel_get_type_name(*args)

def Transfer_ResultFromModel_get_type_descriptor(*args):
    """
    Transfer_ResultFromModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_ResultFromModel_get_type_descriptor(*args)

class Handle_Transfer_ResultFromTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ResultFromTransient self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ResultFromTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ResultFromTransient self, Transfer_ResultFromTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ResultFromTransient self, Handle_Transfer_ResultFromTransient theHandle) -> Handle_Transfer_ResultFromTransient
        assign(Handle_Transfer_ResultFromTransient self, Transfer_ResultFromTransient thePtr) -> Handle_Transfer_ResultFromTransient
        assign(Handle_Transfer_ResultFromTransient self, Handle_Transfer_ResultFromTransient theHandle) -> Handle_Transfer_ResultFromTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ResultFromTransient self) -> Transfer_ResultFromTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ResultFromTransient self) -> Transfer_ResultFromTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ResultFromTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ResultFromTransient self) -> Transfer_ResultFromTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ResultFromTransient___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ResultFromTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ResultFromTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ResultFromTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ResultFromTransient_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ResultFromTransient

    def SetStart(self, *args):
        """
        SetStart(Handle_Transfer_ResultFromTransient self, Handle_Standard_Transient start)

        Sets starting entity

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_SetStart(self, *args)


    def SetBinder(self, *args):
        """
        SetBinder(Handle_Transfer_ResultFromTransient self,  binder)

        Sets Binder (for result plus individual check)

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_SetBinder(self, *args)


    def Start(self, *args):
        """
        Start(Handle_Transfer_ResultFromTransient self) -> Handle_Standard_Transient

        Returns the starting entity

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Start(self, *args)


    def Binder(self, *args):
        """
        Binder(Handle_Transfer_ResultFromTransient self)

        Returns the binder

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Binder(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_ResultFromTransient self) -> Standard_Boolean

        Returns True if a result is recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_HasResult(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_ResultFromTransient self) -> Handle_Interface_Check

        Returns the check (or an empty one if no binder)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Check(self, *args)


    def CheckStatus(self, *args):
        """
        CheckStatus(Handle_Transfer_ResultFromTransient self) -> Interface_CheckStatus

        Returns the check status

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_CheckStatus(self, *args)


    def ClearSubs(self, *args):
        """
        ClearSubs(Handle_Transfer_ResultFromTransient self)

        Clears the list of (immediate) sub-results


        """
        return _Transfer.Handle_Transfer_ResultFromTransient_ClearSubs(self, *args)


    def AddSubResult(self, *args):
        """
        AddSubResult(Handle_Transfer_ResultFromTransient self, Handle_Transfer_ResultFromTransient sub)

        Adds a sub-result

        :type sub: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_AddSubResult(self, *args)


    def NbSubResults(self, *args):
        """
        NbSubResults(Handle_Transfer_ResultFromTransient self) -> Standard_Integer

        Returns the count of recorded sub-results

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_NbSubResults(self, *args)


    def SubResult(self, *args):
        """
        SubResult(Handle_Transfer_ResultFromTransient self, Standard_Integer const num) -> Handle_Transfer_ResultFromTransient

        Returns a sub-result, given its rank

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_SubResult(self, *args)


    def ResultFromKey(self, *args):
        """
        ResultFromKey(Handle_Transfer_ResultFromTransient self, Handle_Standard_Transient key) -> Handle_Transfer_ResultFromTransient

        Returns the ResultFromTransient attached to a given starting
        entity (the key). Returns a null handle if not found

        :type key: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_ResultFromKey(self, *args)


    def FillMap(self, *args):
        """
        FillMap(Handle_Transfer_ResultFromTransient self, NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher map)

        This method is used by ResultFromModel to collate the list of
        ResultFromTransient, avoiding duplications with a map
        Remark : <me> is already in the map and has not to be bound

        :type map: OCC.wrapper.TColStd.TColStd_IndexedMapOfTransient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_FillMap(self, *args)


    def Fill(self, *args):
        """
        Fill(Handle_Transfer_ResultFromTransient self, Handle_Transfer_TransientProcess TP)

        Fills from a TransientProcess, with the starting entity which
        must have been set before. It works with scopes, calls Fill
        on each of its sub-results

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Fill(self, *args)


    def Strip(self, *args):
        """
        Strip(Handle_Transfer_ResultFromTransient self)

        Clears some data attached to binders used by TransientProcess,
        which become useless once the transfer has been done :
        the list of sub-scoped binders, which is now recorded as
        sub-results


        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Strip(self, *args)


    def FillBack(self, *args):
        """
        FillBack(Handle_Transfer_ResultFromTransient self, Handle_Transfer_TransientProcess TP)

        Fills back a TransientProcess with definition of a
        ResultFromTransient, respectfully to its structuration in
        scopes

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_FillBack(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ResultFromTransient self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ResultFromTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ResultFromTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ResultFromTransient self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ResultFromTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ResultFromTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ResultFromTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ResultFromTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ResultFromTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ResultFromTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ResultFromTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ResultFromTransient self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ResultFromTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ResultFromTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromTransient_DecrementRefCounter(self, *args)

Handle_Transfer_ResultFromTransient_swigregister = _Transfer.Handle_Transfer_ResultFromTransient_swigregister
Handle_Transfer_ResultFromTransient_swigregister(Handle_Transfer_ResultFromTransient)

def Handle_Transfer_ResultFromTransient_DownCast(thing):
    return _Transfer.Handle_Transfer_ResultFromTransient_DownCast(thing)
Handle_Transfer_ResultFromTransient_DownCast = _Transfer.Handle_Transfer_ResultFromTransient_DownCast

class Transfer_IteratorOfProcessForTransient(Transfer_TransferIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_IteratorOfProcessForTransient self, Standard_Boolean const withstarts) -> Transfer_IteratorOfProcessForTransient

        Creates an empty Iterator
        if withstarts is True, each Binder to be iterated will
        be associated to its corresponding Starting Object

        :type withstarts: bool

        """
        this = _Transfer.new_Transfer_IteratorOfProcessForTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(Transfer_IteratorOfProcessForTransient self,  binder)
        Add(Transfer_IteratorOfProcessForTransient self,  binder, Handle_Standard_Transient start)

        Adds a Binder to the iteration list, associated with
        its corresponding Starting Object "start"
        Starting Object is ignored if not required at
        Creation time

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_Add(self, *args)


    def Filter(self, *args):
        """
        Filter(Transfer_IteratorOfProcessForTransient self, Handle_TColStd_HSequenceOfTransient list, Standard_Boolean const keep)

        After having added all items, keeps or rejects items
        which are attached to starting data given by <only>
        <keep> = True (D) : keeps. <keep> = False : rejects
        Does nothing if <withstarts> was False

        :type list: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :type keep: bool

        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_Filter(self, *args)


    def HasStarting(self, *args):
        """
        HasStarting(Transfer_IteratorOfProcessForTransient self) -> Standard_Boolean

        Returns True if Starting Object is available
        (defined at Creation Time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_IteratorOfProcessForTransient_HasStarting(self, *args)


    def Starting(self, *args):
        """
        Returns corresponding Starting Object

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Transfer_IteratorOfProcessForTransient_Starting(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_IteratorOfProcessForTransient
Transfer_IteratorOfProcessForTransient_swigregister = _Transfer.Transfer_IteratorOfProcessForTransient_swigregister
Transfer_IteratorOfProcessForTransient_swigregister(Transfer_IteratorOfProcessForTransient)

class Handle_Transfer_TransientListBinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_TransientListBinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_TransientListBinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_TransientListBinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_TransientListBinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_TransientListBinder self, Transfer_TransientListBinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_TransientListBinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_TransientListBinder self, Handle_Transfer_TransientListBinder theHandle) -> Handle_Transfer_TransientListBinder
        assign(Handle_Transfer_TransientListBinder self, Transfer_TransientListBinder thePtr) -> Handle_Transfer_TransientListBinder
        assign(Handle_Transfer_TransientListBinder self, Handle_Transfer_TransientListBinder theHandle) -> Handle_Transfer_TransientListBinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_TransientListBinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_TransientListBinder self) -> Transfer_TransientListBinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientListBinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_TransientListBinder self) -> Transfer_TransientListBinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientListBinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_TransientListBinder self) -> Transfer_TransientListBinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_TransientListBinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_TransientListBinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_TransientListBinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_TransientListBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_TransientListBinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_TransientListBinder

    def IsMultiple(self, *args):
        """
        IsMultiple(Handle_Transfer_TransientListBinder self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientListBinder_IsMultiple(self, *args)


    def ResultType(self, *args):
        """
        ResultType(Handle_Transfer_TransientListBinder self) -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_TransientListBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Handle_Transfer_TransientListBinder self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientListBinder_ResultTypeName(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Handle_Transfer_TransientListBinder self, Handle_Standard_Transient res)

        Adds an item to the result list

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientListBinder_AddResult(self, *args)


    def Result(self, *args):
        """
        Result(Handle_Transfer_TransientListBinder self) -> Handle_TColStd_HSequenceOfTransient

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_TransientListBinder_Result(self, *args)


    def SetResult(self, *args):
        """
        SetResult(Handle_Transfer_TransientListBinder self, Standard_Integer const num, Handle_Standard_Transient res)

        Changes an already defined sub-result

        :type num: int
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientListBinder_SetResult(self, *args)


    def NbTransients(self, *args):
        """
        NbTransients(Handle_Transfer_TransientListBinder self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientListBinder_NbTransients(self, *args)


    def Transient(self, *args):
        """
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_TransientListBinder_Transient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_TransientListBinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_TransientListBinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientListBinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientListBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Merge(self, *args):
        """
        Merge(Handle_Transfer_TransientListBinder self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientListBinder_Merge(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Handle_Transfer_TransientListBinder self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientListBinder_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_TransientListBinder self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientListBinder_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Handle_Transfer_TransientListBinder self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Handle_Transfer_TransientListBinder_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Transfer_TransientListBinder self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Handle_Transfer_TransientListBinder_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Handle_Transfer_TransientListBinder self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_TransientListBinder_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Handle_Transfer_TransientListBinder self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_TransientListBinder_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_TransientListBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientListBinder_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_TransientListBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientListBinder_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_TransientListBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_TransientListBinder_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Handle_Transfer_TransientListBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_TransientListBinder_CCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_TransientListBinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_TransientListBinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_TransientListBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_TransientListBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientListBinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_TransientListBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_TransientListBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientListBinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_TransientListBinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientListBinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_TransientListBinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientListBinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_TransientListBinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_TransientListBinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_TransientListBinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientListBinder_DecrementRefCounter(self, *args)

Handle_Transfer_TransientListBinder_swigregister = _Transfer.Handle_Transfer_TransientListBinder_swigregister
Handle_Transfer_TransientListBinder_swigregister(Handle_Transfer_TransientListBinder)

def Handle_Transfer_TransientListBinder_DownCast(thing):
    return _Transfer.Handle_Transfer_TransientListBinder_DownCast(thing)
Handle_Transfer_TransientListBinder_DownCast = _Transfer.Handle_Transfer_TransientListBinder_DownCast

class Handle_Transfer_ActorOfProcessForFinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ActorOfProcessForFinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ActorOfProcessForFinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ActorOfProcessForFinder self, Transfer_ActorOfProcessForFinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ActorOfProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder theHandle) -> Handle_Transfer_ActorOfProcessForFinder
        assign(Handle_Transfer_ActorOfProcessForFinder self, Transfer_ActorOfProcessForFinder thePtr) -> Handle_Transfer_ActorOfProcessForFinder
        assign(Handle_Transfer_ActorOfProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder theHandle) -> Handle_Transfer_ActorOfProcessForFinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ActorOfProcessForFinder self) -> Transfer_ActorOfProcessForFinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ActorOfProcessForFinder self) -> Transfer_ActorOfProcessForFinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ActorOfProcessForFinder self) -> Transfer_ActorOfProcessForFinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ActorOfProcessForFinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ActorOfProcessForFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ActorOfProcessForFinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ActorOfProcessForFinder

    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ActorOfProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ActorOfProcessForFinder self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        Specific action of Transfer. The Result is stored in
        the returned Binder, or a Null Handle for "No result"
        (Default defined as doing nothing; should be deffered)
        "mutable" allows the Actor to record intermediate
        information, in addition to those of TransferProcess

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Transferring(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_Transfer_ActorOfProcessForFinder self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_Transfer_ActorOfProcessForFinder self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_Transfer_ActorOfProcessForFinder self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_Transfer_ActorOfProcessForFinder self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_Transfer_ActorOfProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_Transfer_ActorOfProcessForFinder self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Next(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ActorOfProcessForFinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfProcessForFinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfProcessForFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ActorOfProcessForFinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ActorOfProcessForFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ActorOfProcessForFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ActorOfProcessForFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ActorOfProcessForFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ActorOfProcessForFinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ActorOfProcessForFinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ActorOfProcessForFinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ActorOfProcessForFinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForFinder_DecrementRefCounter(self, *args)

Handle_Transfer_ActorOfProcessForFinder_swigregister = _Transfer.Handle_Transfer_ActorOfProcessForFinder_swigregister
Handle_Transfer_ActorOfProcessForFinder_swigregister(Handle_Transfer_ActorOfProcessForFinder)

def Handle_Transfer_ActorOfProcessForFinder_DownCast(thing):
    return _Transfer.Handle_Transfer_ActorOfProcessForFinder_DownCast(thing)
Handle_Transfer_ActorOfProcessForFinder_DownCast = _Transfer.Handle_Transfer_ActorOfProcessForFinder_DownCast

class Handle_Transfer_TransientProcess(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_TransientProcess self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_TransientProcess_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_TransientProcess self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_TransientProcess self, Transfer_TransientProcess thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_TransientProcess_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_TransientProcess self, Handle_Transfer_TransientProcess theHandle) -> Handle_Transfer_TransientProcess
        assign(Handle_Transfer_TransientProcess self, Transfer_TransientProcess thePtr) -> Handle_Transfer_TransientProcess
        assign(Handle_Transfer_TransientProcess self, Handle_Transfer_TransientProcess theHandle) -> Handle_Transfer_TransientProcess

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_TransientProcess_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_TransientProcess self) -> Transfer_TransientProcess

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientProcess_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_TransientProcess self) -> Transfer_TransientProcess

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientProcess___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_TransientProcess self) -> Transfer_TransientProcess

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_TransientProcess___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_TransientProcess___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_TransientProcess___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_TransientProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_TransientProcess_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_TransientProcess

    def SetModel(self, *args):
        """
        SetModel(Handle_Transfer_TransientProcess self, Handle_Interface_InterfaceModel model)

        Sets an InterfaceModel, used by StartTrace, CheckList, queries
        on Integrity, to give informations significant for each norm.

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Handle_Transfer_TransientProcess self) -> Handle_Interface_InterfaceModel

        Returns the Model used for StartTrace

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_TransientProcess_Model(self, *args)


    def SetGraph(self, *args):
        """
        SetGraph(Handle_Transfer_TransientProcess self, Handle_Interface_HGraph HG)

        Sets a Graph : superseedes SetModel if already done

        :type HG: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetGraph(self, *args)


    def HasGraph(self, *args):
        """
        HasGraph(Handle_Transfer_TransientProcess self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_HasGraph(self, *args)


    def HGraph(self, *args):
        """
        HGraph(Handle_Transfer_TransientProcess self) -> Handle_Interface_HGraph

        :rtype: OCC.wrapper.Interface.Handle_Interface_HGraph

        """
        return _Transfer.Handle_Transfer_TransientProcess_HGraph(self, *args)


    def Graph(self, *args):
        """
        Graph(Handle_Transfer_TransientProcess self) -> Interface_Graph

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        return _Transfer.Handle_Transfer_TransientProcess_Graph(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_Transfer_TransientProcess self, Standard_CString const name, Handle_Standard_Transient ctx)

        Sets a Context : according to receiving appli, to be
        interpreted by the Actor

        :type name: OCC.wrapper.Standard.Standard_CString
        :type ctx: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_Transfer_TransientProcess self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient ctx) -> Standard_Boolean

        Returns the Context attached to a name, if set and if it is
        Kind of the type, else a Null Handle
        Returns True if OK, False if no Context

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type ctx: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_GetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_Transfer_TransientProcess self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns (modifiable) the whole definition of Context
        Rather for internal use (ex.: preparing and setting in once)

        :rtype: OCC.wrapper.Transfer.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_Context(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Message_Messenger S)

        Specific printing to trace an entity : prints label and type
        (if model is set)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_TransientProcess_PrintTrace(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Handle_Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Integer

        Specific number of a starting object for check-list : Number
        in model

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_CheckNum(self, *args)


    def TypedSharings(self, *args):
        """
        TypedSharings(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Standard_Type type) -> Interface_EntityIterator

        Returns the list of sharings entities, AT ANY LEVEL, which are
        kind of a given type. Calls TypedSharings from Graph
        Returns an empty list if the Graph has not been aknowledged

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Transfer.Handle_Transfer_TransientProcess_TypedSharings(self, *args)


    def IsDataLoaded(self, *args):
        """
        IsDataLoaded(Handle_Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Boolean

        Tells if an entity is well loaded from file (even if its data
        fail on checking, they are present). Mostly often, answers
        True. Else, there was a syntactic error in the file.
        A non-loaded entity MAY NOT BE transferred, unless its Report
        (in the model) is interpreted

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsDataLoaded(self, *args)


    def IsDataFail(self, *args):
        """
        IsDataFail(Handle_Transfer_TransientProcess self, Handle_Standard_Transient ent) -> Standard_Boolean

        Tells if an entity fails on data checking (load time,
        syntactic, or semantic check). Normally, should answer False.
        It is not prudent to try transferring an entity which fails on
        data checking

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsDataFail(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Handle_Transfer_TransientProcess self, Standard_Integer const mode, Handle_Message_Messenger S)

        Prints statistics on a given output, according mode

        :type mode: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_TransientProcess_PrintStats(self, *args)


    def RootsForTransfer(self, *args):
        """
        RootsForTransfer(Handle_Transfer_TransientProcess self) -> Handle_TColStd_HSequenceOfTransient

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_RootsForTransfer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_TransientProcess self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_TransientProcess_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientProcess_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_Transfer_TransientProcess self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Handle_Transfer_TransientProcess_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Handle_Transfer_TransientProcess self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Handle_Transfer_TransientProcess_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_Transfer_TransientProcess self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Handle_Transfer_TransientProcess_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_Transfer_TransientProcess self, Handle_Transfer_ActorOfProcessForTransient actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_Transfer_TransientProcess self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_Transfer_TransientProcess self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_Transfer_TransientProcess self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_TransientProcess_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Transfer_TransientProcess self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_TransientProcess_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_TransientProcess_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_TransientProcess_SendMsg(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_TransientProcess_AddFail(self, *args)


    def AddError(self, *args):
        """
        AddError(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientProcess_AddError(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_TransientProcess_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_CString const pref)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientProcess_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_TransientProcess_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_TransientProcess_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Handle_Transfer_TransientProcess self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_TransientProcess_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Handle_Transfer_TransientProcess self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Handle_Transfer_TransientProcess self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_TransientProcess_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Handle_Transfer_TransientProcess self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Handle_Transfer_TransientProcess self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Handle_Transfer_TransientProcess_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_TransientProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_Transfer_TransientProcess self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_Transfer_TransientProcess self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Handle_Transfer_TransientProcess self,  binder, Handle_Standard_Transient start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type mode: int

        """
        return _Transfer.Handle_Transfer_TransientProcess_StartTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Handle_Transfer_TransientProcess self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_Transfer_TransientProcess self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_Transfer_TransientProcess self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Handle_Transfer_TransientProcess self) -> Transfer_IteratorOfProcessForTransient

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_Transfer_TransientProcess self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_TransientProcess_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForTransient

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_TransientProcess_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_TransientProcess_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Handle_Transfer_TransientProcess self, Handle_Standard_Transient start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type level: int
        :type compute: bool

        """
        return _Transfer.Handle_Transfer_TransientProcess_RemoveResult(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Handle_Transfer_TransientProcess self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_TransientProcess_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Handle_Transfer_TransientProcess self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_TransientProcess_GetProgress(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_TransientProcess self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_TransientProcess_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_TransientProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_TransientProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_TransientProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_TransientProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientProcess_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_TransientProcess self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientProcess_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_TransientProcess self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_TransientProcess_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_TransientProcess self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientProcess_DecrementRefCounter(self, *args)

Handle_Transfer_TransientProcess_swigregister = _Transfer.Handle_Transfer_TransientProcess_swigregister
Handle_Transfer_TransientProcess_swigregister(Handle_Transfer_TransientProcess)

def Handle_Transfer_TransientProcess_DownCast(thing):
    return _Transfer.Handle_Transfer_TransientProcess_DownCast(thing)
Handle_Transfer_TransientProcess_DownCast = _Transfer.Handle_Transfer_TransientProcess_DownCast

class Handle_Transfer_Finder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_Finder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_Finder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_Finder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_Finder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_Finder self, Transfer_Finder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_Finder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_Finder self, Handle_Transfer_Finder theHandle) -> Handle_Transfer_Finder
        assign(Handle_Transfer_Finder self, Transfer_Finder thePtr) -> Handle_Transfer_Finder
        assign(Handle_Transfer_Finder self, Handle_Transfer_Finder theHandle) -> Handle_Transfer_Finder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_Finder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_Finder self) -> Transfer_Finder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_Finder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_Finder self) -> Transfer_Finder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_Finder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_Finder self) -> Transfer_Finder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_Finder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_Finder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_Finder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_Finder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_Finder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_Finder

    def GetHashCode(self, *args):
        """
        GetHashCode(Handle_Transfer_Finder self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_Finder_GetHashCode(self, *args)


    def Equates(self, *args):
        """
        Equates(Handle_Transfer_Finder self, Handle_Transfer_Finder other) -> Standard_Boolean

        Specific testof equallity : to be defined by each sub-class,
        must be False if Finders have not the same true Type, else
        their contents must be compared

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_Transfer_Finder self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_Finder_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Handle_Transfer_Finder self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_Finder_ValueTypeName(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(Handle_Transfer_Finder self, Standard_CString const name, Handle_Standard_Transient val)

        Adds an attribute with a given name (replaces the former one
        with the same name if already exists)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_Finder_SetAttribute(self, *args)


    def RemoveAttribute(self, *args):
        """
        RemoveAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Removes an attribute
        Returns True when done, False if this attribute did not exist

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_RemoveAttribute(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(Handle_Transfer_Finder self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns an attribute from its name, filtered by a type
        If no attribute has this name, or if it is not kind of this
        type, <val> is Null and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_GetAttribute(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_Transfer_Finder self, Standard_CString const name) -> Handle_Standard_Transient

        Returns an attribute from its name. Null Handle if not recorded
        (whatever Transient, Integer, Real ...)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_Finder_Attribute(self, *args)


    def AttributeType(self, *args):
        """
        AttributeType(Handle_Transfer_Finder self, Standard_CString const name) -> Interface_ParamType

        Returns the type of an attribute :
        ParamInt , ParamReal , ParamText (String) , ParamIdent (any)
        or ParamVoid (not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Transfer.Handle_Transfer_Finder_AttributeType(self, *args)


    def SetIntegerAttribute(self, *args):
        """
        SetIntegerAttribute(Handle_Transfer_Finder self, Standard_CString const name, Standard_Integer const val)

        Adds an integer value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int

        """
        return _Transfer.Handle_Transfer_Finder_SetIntegerAttribute(self, *args)


    def GetIntegerAttribute(self, *args):
        """
        GetIntegerAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as integer
        If no attribute has this name, or not an integer,
        <val> is 0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_GetIntegerAttribute(self, *args)


    def IntegerAttribute(self, *args):
        """
        IntegerAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_Integer

        Returns an integer attribute from its name. 0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_Finder_IntegerAttribute(self, *args)


    def SetRealAttribute(self, *args):
        """
        SetRealAttribute(Handle_Transfer_Finder self, Standard_CString const name, Standard_Real const val)

        Adds a real value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float

        """
        return _Transfer.Handle_Transfer_Finder_SetRealAttribute(self, *args)


    def GetRealAttribute(self, *args):
        """
        GetRealAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as real
        If no attribute has this name, or not a real
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_GetRealAttribute(self, *args)


    def RealAttribute(self, *args):
        """
        RealAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_Real

        Returns a real attribute from its name. 0.0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Transfer.Handle_Transfer_Finder_RealAttribute(self, *args)


    def SetStringAttribute(self, *args):
        """
        SetStringAttribute(Handle_Transfer_Finder self, Standard_CString const name, Standard_CString const val)

        Adds a String value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_Finder_SetStringAttribute(self, *args)


    def GetStringAttribute(self, *args):
        """
        GetStringAttribute(Handle_Transfer_Finder self, Standard_CString const name, Standard_CString & val) -> Standard_Boolean

        Returns an attribute from its name, as String
        If no attribute has this name, or not a String
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_GetStringAttribute(self, *args)


    def StringAttribute(self, *args):
        """
        StringAttribute(Handle_Transfer_Finder self, Standard_CString const name) -> Standard_CString

        Returns a String attribute from its name. "" if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_Finder_StringAttribute(self, *args)


    def AttrList(self, *args):
        """
        AttrList(Handle_Transfer_Finder self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns the exhaustive list of attributes

        :rtype: OCC.wrapper.Transfer.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_Finder_AttrList(self, *args)


    def SameAttributes(self, *args):
        """
        SameAttributes(Handle_Transfer_Finder self, Handle_Transfer_Finder other)

        Gets the list of attributes from <other>, as such, i.e.
        not copied : attributes are shared, any attribute edited,
        added, or removed in <other> is also in <me> and vice versa
        The former list of attributes of <me> is dropped

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_Finder_SameAttributes(self, *args)


    def GetAttributes(self, *args):
        """
        GetAttributes(Handle_Transfer_Finder self, Handle_Transfer_Finder other, Standard_CString const fromname, Standard_Boolean const copied)

        Gets the list of attributes from <other>, by copying it
        By default, considers all the attributes from <other>
        If <fromname> is given, considers only the attributes with
        name beginning by <fromname>

        For each attribute, if <copied> is True (D), its value is also
        copied if it is a basic type (Integer,Real,String), else it
        remains shared between <other> and <me>

        These new attributes are added to the existing ones in <me>,
        in case of same name, they replace the existing ones

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type fromname: OCC.wrapper.Standard.Standard_CString
        :type copied: bool

        """
        return _Transfer.Handle_Transfer_Finder_GetAttributes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_Finder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_Finder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_Finder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_Finder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_Finder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_Finder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_Finder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_Finder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_Finder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_Finder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_Finder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_Finder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_Finder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_Finder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_Finder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_Finder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_Finder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_Finder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_Finder_DecrementRefCounter(self, *args)

Handle_Transfer_Finder_swigregister = _Transfer.Handle_Transfer_Finder_swigregister
Handle_Transfer_Finder_swigregister(Handle_Transfer_Finder)

def Handle_Transfer_Finder_DownCast(thing):
    return _Transfer.Handle_Transfer_Finder_DownCast(thing)
Handle_Transfer_Finder_DownCast = _Transfer.Handle_Transfer_Finder_DownCast

class Transfer_TransferInput(object):
    """
    A TransferInput is a Tool which fills an InterfaceModel with
    the result of the Transfer of CasCade Objects, once determined
    The Result comes from a TransferProcess, either from
    Transient (the Complete Result is considered, it must contain
    only Transient Objects)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_TransferInput self) -> Transfer_TransferInput

        Creates a TransferInput ready to use


        """
        this = _Transfer.new_Transfer_TransferInput(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Entities(self, *args):
        """
        Entities(Transfer_TransferInput self, Transfer_TransferIterator list) -> Interface_EntityIterator

        Takes the transient items stored in a TransferIterator

        :type list: OCC.wrapper.Transfer.Transfer_TransferIterator
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Transfer.Transfer_TransferInput_Entities(self, *args)


    def FillModel(self, *args):
        """
        FillModel(Transfer_TransferInput self, Handle_Transfer_TransientProcess proc, Handle_Interface_InterfaceModel amodel)
        FillModel(Transfer_TransferInput self, Handle_Transfer_TransientProcess proc, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol proto, Standard_Boolean const roots)
        FillModel(Transfer_TransferInput self, Handle_Transfer_FinderProcess proc, Handle_Interface_InterfaceModel amodel)
        FillModel(Transfer_TransferInput self, Handle_Transfer_FinderProcess proc, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol proto, Standard_Boolean const roots)

        Fills an InterfaceModel with results of the Transfer recorded
        in a TransientProcess (Starting Objects are Transient) :
        Root Result if <roots> is True (Default), Complete Result else
        The entities added to the model are determined from the result
        by by adding the referenced entities

        :type proc: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type roots: bool

        """
        return _Transfer.Transfer_TransferInput_FillModel(self, *args)

    __swig_destroy__ = _Transfer.delete_Transfer_TransferInput
Transfer_TransferInput_swigregister = _Transfer.Transfer_TransferInput_swigregister
Transfer_TransferInput_swigregister(Transfer_TransferInput)

class Handle_Transfer_ActorOfProcessForTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ActorOfProcessForTransient self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ActorOfProcessForTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ActorOfProcessForTransient self, Transfer_ActorOfProcessForTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ActorOfProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient theHandle) -> Handle_Transfer_ActorOfProcessForTransient
        assign(Handle_Transfer_ActorOfProcessForTransient self, Transfer_ActorOfProcessForTransient thePtr) -> Handle_Transfer_ActorOfProcessForTransient
        assign(Handle_Transfer_ActorOfProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient theHandle) -> Handle_Transfer_ActorOfProcessForTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ActorOfProcessForTransient self) -> Transfer_ActorOfProcessForTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ActorOfProcessForTransient self) -> Transfer_ActorOfProcessForTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ActorOfProcessForTransient self) -> Transfer_ActorOfProcessForTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ActorOfProcessForTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ActorOfProcessForTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ActorOfProcessForTransient_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ActorOfProcessForTransient

    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        Specific action of Transfer. The Result is stored in
        the returned Binder, or a Null Handle for "No result"
        (Default defined as doing nothing; should be deffered)
        "mutable" allows the Actor to record intermediate
        information, in addition to those of TransferProcess

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Transferring(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_Transfer_ActorOfProcessForTransient self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_Transfer_ActorOfProcessForTransient self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_Transfer_ActorOfProcessForTransient self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_Transfer_ActorOfProcessForTransient self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_Transfer_ActorOfProcessForTransient self, Handle_Transfer_ActorOfProcessForTransient next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_Transfer_ActorOfProcessForTransient self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Next(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ActorOfProcessForTransient self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfProcessForTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfProcessForTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ActorOfProcessForTransient self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ActorOfProcessForTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ActorOfProcessForTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ActorOfProcessForTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ActorOfProcessForTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ActorOfProcessForTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ActorOfProcessForTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ActorOfProcessForTransient self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ActorOfProcessForTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfProcessForTransient_DecrementRefCounter(self, *args)

Handle_Transfer_ActorOfProcessForTransient_swigregister = _Transfer.Handle_Transfer_ActorOfProcessForTransient_swigregister
Handle_Transfer_ActorOfProcessForTransient_swigregister(Handle_Transfer_ActorOfProcessForTransient)

def Handle_Transfer_ActorOfProcessForTransient_DownCast(thing):
    return _Transfer.Handle_Transfer_ActorOfProcessForTransient_DownCast(thing)
Handle_Transfer_ActorOfProcessForTransient_DownCast = _Transfer.Handle_Transfer_ActorOfProcessForTransient_DownCast

class Handle_Transfer_TransientMapper(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_TransientMapper self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_TransientMapper_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_TransientMapper self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_TransientMapper_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_TransientMapper self, Transfer_TransientMapper thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_TransientMapper_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_TransientMapper self, Handle_Transfer_TransientMapper theHandle) -> Handle_Transfer_TransientMapper
        assign(Handle_Transfer_TransientMapper self, Transfer_TransientMapper thePtr) -> Handle_Transfer_TransientMapper
        assign(Handle_Transfer_TransientMapper self, Handle_Transfer_TransientMapper theHandle) -> Handle_Transfer_TransientMapper

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_TransientMapper_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_TransientMapper self) -> Transfer_TransientMapper

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientMapper_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_TransientMapper self) -> Transfer_TransientMapper

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransientMapper___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_TransientMapper self) -> Transfer_TransientMapper

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_TransientMapper___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_TransientMapper___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_TransientMapper___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_TransientMapper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_TransientMapper_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_TransientMapper

    def Value(self, *args):
        """
        Returns the contained value

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_TransientMapper_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Equates(self, *args):
        """
        Equates(Handle_Transfer_TransientMapper self, Handle_Transfer_Finder other) -> Standard_Boolean

        Specific testof equallity : defined as False if <other> has
        not the same true Type, else contents are compared (by
        C++ operator ==)

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_Transfer_TransientMapper self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_TransientMapper_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Handle_Transfer_TransientMapper self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientMapper_ValueTypeName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_TransientMapper self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_TransientMapper_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientMapper_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransientMapper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetHashCode(self, *args):
        """
        GetHashCode(Handle_Transfer_TransientMapper self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetHashCode(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Handle_Standard_Transient val)

        Adds an attribute with a given name (replaces the former one
        with the same name if already exists)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientMapper_SetAttribute(self, *args)


    def RemoveAttribute(self, *args):
        """
        RemoveAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_Boolean

        Removes an attribute
        Returns True when done, False if this attribute did not exist

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_RemoveAttribute(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns an attribute from its name, filtered by a type
        If no attribute has this name, or if it is not kind of this
        type, <val> is Null and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetAttribute(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Handle_Standard_Transient

        Returns an attribute from its name. Null Handle if not recorded
        (whatever Transient, Integer, Real ...)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientMapper_Attribute(self, *args)


    def AttributeType(self, *args):
        """
        AttributeType(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Interface_ParamType

        Returns the type of an attribute :
        ParamInt , ParamReal , ParamText (String) , ParamIdent (any)
        or ParamVoid (not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _Transfer.Handle_Transfer_TransientMapper_AttributeType(self, *args)


    def SetIntegerAttribute(self, *args):
        """
        SetIntegerAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Standard_Integer const val)

        Adds an integer value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int

        """
        return _Transfer.Handle_Transfer_TransientMapper_SetIntegerAttribute(self, *args)


    def GetIntegerAttribute(self, *args):
        """
        GetIntegerAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as integer
        If no attribute has this name, or not an integer,
        <val> is 0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetIntegerAttribute(self, *args)


    def IntegerAttribute(self, *args):
        """
        IntegerAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_Integer

        Returns an integer attribute from its name. 0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientMapper_IntegerAttribute(self, *args)


    def SetRealAttribute(self, *args):
        """
        SetRealAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Standard_Real const val)

        Adds a real value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float

        """
        return _Transfer.Handle_Transfer_TransientMapper_SetRealAttribute(self, *args)


    def GetRealAttribute(self, *args):
        """
        GetRealAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as real
        If no attribute has this name, or not a real
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetRealAttribute(self, *args)


    def RealAttribute(self, *args):
        """
        RealAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_Real

        Returns a real attribute from its name. 0.0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Transfer.Handle_Transfer_TransientMapper_RealAttribute(self, *args)


    def SetStringAttribute(self, *args):
        """
        SetStringAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Standard_CString const val)

        Adds a String value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientMapper_SetStringAttribute(self, *args)


    def GetStringAttribute(self, *args):
        """
        GetStringAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name, Standard_CString & val) -> Standard_Boolean

        Returns an attribute from its name, as String
        If no attribute has this name, or not a String
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetStringAttribute(self, *args)


    def StringAttribute(self, *args):
        """
        StringAttribute(Handle_Transfer_TransientMapper self, Standard_CString const name) -> Standard_CString

        Returns a String attribute from its name. "" if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransientMapper_StringAttribute(self, *args)


    def AttrList(self, *args):
        """
        AttrList(Handle_Transfer_TransientMapper self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > &

        Returns the exhaustive list of attributes

        :rtype: OCC.wrapper.Transfer.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientMapper_AttrList(self, *args)


    def SameAttributes(self, *args):
        """
        SameAttributes(Handle_Transfer_TransientMapper self, Handle_Transfer_Finder other)

        Gets the list of attributes from <other>, as such, i.e.
        not copied : attributes are shared, any attribute edited,
        added, or removed in <other> is also in <me> and vice versa
        The former list of attributes of <me> is dropped

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_TransientMapper_SameAttributes(self, *args)


    def GetAttributes(self, *args):
        """
        GetAttributes(Handle_Transfer_TransientMapper self, Handle_Transfer_Finder other, Standard_CString const fromname, Standard_Boolean const copied)

        Gets the list of attributes from <other>, by copying it
        By default, considers all the attributes from <other>
        If <fromname> is given, considers only the attributes with
        name beginning by <fromname>

        For each attribute, if <copied> is True (D), its value is also
        copied if it is a basic type (Integer,Real,String), else it
        remains shared between <other> and <me>

        These new attributes are added to the existing ones in <me>,
        in case of same name, they replace the existing ones

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type fromname: OCC.wrapper.Standard.Standard_CString
        :type copied: bool

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_TransientMapper self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_TransientMapper_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_TransientMapper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_TransientMapper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_TransientMapper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_TransientMapper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransientMapper_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_TransientMapper self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransientMapper_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_TransientMapper self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientMapper_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_TransientMapper self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_TransientMapper_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_TransientMapper self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransientMapper_DecrementRefCounter(self, *args)

Handle_Transfer_TransientMapper_swigregister = _Transfer.Handle_Transfer_TransientMapper_swigregister
Handle_Transfer_TransientMapper_swigregister(Handle_Transfer_TransientMapper)

def Handle_Transfer_TransientMapper_DownCast(thing):
    return _Transfer.Handle_Transfer_TransientMapper_DownCast(thing)
Handle_Transfer_TransientMapper_DownCast = _Transfer.Handle_Transfer_TransientMapper_DownCast

class Transfer_BinderOfTransientInteger(Transfer_SimpleBinderOfTransient):
    """
    This type of Binder allows to attach as result, besides a
    Transient Object, an Integer Value, which can be an Index
    in the Object if it defines a List, for instance

    This Binder is otherwise a kind of SimpleBinderOfTransient,
    i.e. its basic result (for iterators, etc) is the Transient
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Transfer_BinderOfTransientInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Transfer_BinderOfTransientInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Transfer_BinderOfTransientInteger self) -> Transfer_BinderOfTransientInteger

        Creates an empty BinderOfTransientInteger; Default value for
        the integer part is zero


        """
        this = _Transfer.new_Transfer_BinderOfTransientInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetInteger(self, *args):
        """
        SetInteger(Transfer_BinderOfTransientInteger self, Standard_Integer const value)

        Sets a value for the integer part

        :type value: int

        """
        return _Transfer.Transfer_BinderOfTransientInteger_SetInteger(self, *args)


    def Integer(self, *args):
        """
        Integer(Transfer_BinderOfTransientInteger self) -> Standard_Integer

        Returns the value set for the integer part

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Transfer_BinderOfTransientInteger_Integer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Transfer.Transfer_BinderOfTransientInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_BinderOfTransientInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Transfer_BinderOfTransientInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_BinderOfTransientInteger
Transfer_BinderOfTransientInteger_swigregister = _Transfer.Transfer_BinderOfTransientInteger_swigregister
Transfer_BinderOfTransientInteger_swigregister(Transfer_BinderOfTransientInteger)

def Transfer_BinderOfTransientInteger_get_type_name(*args):
    """
    Transfer_BinderOfTransientInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Transfer.Transfer_BinderOfTransientInteger_get_type_name(*args)

def Transfer_BinderOfTransientInteger_get_type_descriptor(*args):
    """
    Transfer_BinderOfTransientInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_BinderOfTransientInteger_get_type_descriptor(*args)

class Handle_Transfer_ActorOfTransientProcess(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ActorOfTransientProcess self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ActorOfTransientProcess self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ActorOfTransientProcess self, Transfer_ActorOfTransientProcess thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ActorOfTransientProcess self, Handle_Transfer_ActorOfTransientProcess theHandle) -> Handle_Transfer_ActorOfTransientProcess
        assign(Handle_Transfer_ActorOfTransientProcess self, Transfer_ActorOfTransientProcess thePtr) -> Handle_Transfer_ActorOfTransientProcess
        assign(Handle_Transfer_ActorOfTransientProcess self, Handle_Transfer_ActorOfTransientProcess theHandle) -> Handle_Transfer_ActorOfTransientProcess

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ActorOfTransientProcess self) -> Transfer_ActorOfTransientProcess

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ActorOfTransientProcess self) -> Transfer_ActorOfTransientProcess

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ActorOfTransientProcess self) -> Transfer_ActorOfTransientProcess

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ActorOfTransientProcess___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ActorOfTransientProcess___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ActorOfTransientProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ActorOfTransientProcess_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ActorOfTransientProcess

    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Transfer(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_TransferTransient(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ActorOfTransientProcess self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfTransientProcess_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfTransientProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Transient start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Recognize(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_Transfer_ActorOfTransientProcess self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_Transfer_ActorOfTransientProcess self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_Transfer_ActorOfTransientProcess self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_Transfer_ActorOfTransientProcess self, Handle_Transfer_ActorOfProcessForTransient next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_Transfer_ActorOfTransientProcess self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ActorOfTransientProcess self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ActorOfTransientProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ActorOfTransientProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ActorOfTransientProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ActorOfTransientProcess self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ActorOfTransientProcess self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ActorOfTransientProcess self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ActorOfTransientProcess self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfTransientProcess_DecrementRefCounter(self, *args)

Handle_Transfer_ActorOfTransientProcess_swigregister = _Transfer.Handle_Transfer_ActorOfTransientProcess_swigregister
Handle_Transfer_ActorOfTransientProcess_swigregister(Handle_Transfer_ActorOfTransientProcess)

def Handle_Transfer_ActorOfTransientProcess_DownCast(thing):
    return _Transfer.Handle_Transfer_ActorOfTransientProcess_DownCast(thing)
Handle_Transfer_ActorOfTransientProcess_DownCast = _Transfer.Handle_Transfer_ActorOfTransientProcess_DownCast

class Transfer_TransferDispatch(Interface.Interface_CopyTool):
    """
    A TransferDispatch is aimed to dispatch Entities between two
    Interface Models, by default by copying them, as CopyTool, but
    with more capabilities of adapting : Copy is redefined to
    firstly pass the hand to a TransferProcess. If this gives no
    result, standard Copy is called.

    This allow, for instance, to modify the copied Entity (such as
    changing a Name for a VDA Entity), or to do a deeper work
    (such as Substituting a kind of Entity to another one).

    For these reasons, TransferDispatch is basically a CopyTool,
    but uses a more sophiscated control, which is TransferProcess,
    and its method Copy is redefined
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_TransferDispatch self, Handle_Interface_InterfaceModel amodel, Interface_GeneralLib lib) -> Transfer_TransferDispatch
        __init__(Transfer_TransferDispatch self, Handle_Interface_InterfaceModel amodel, Handle_Interface_Protocol protocol) -> Transfer_TransferDispatch
        __init__(Transfer_TransferDispatch self, Handle_Interface_InterfaceModel amodel) -> Transfer_TransferDispatch

        Same as above, but works with the Active Protocol

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _Transfer.new_Transfer_TransferDispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def TransientProcess(self, *args):
        """
        TransientProcess(Transfer_TransferDispatch self) -> Handle_Transfer_TransientProcess

        Returns the content of Control Object, as a TransientProcess

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Transfer_TransferDispatch_TransientProcess(self, *args)


    def Copy(self, *args):
        """
        Copy(Transfer_TransferDispatch self, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Standard_Boolean const mapped, Standard_Boolean const errstat) -> Standard_Boolean

        Copies an Entity by calling the method Transferring from the
        TransferProcess. If this called produces a Null Binder, then
        the standard, inherited Copy is called

        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type mapped: bool
        :type errstat: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_TransferDispatch_Copy(self, *args)

    __swig_destroy__ = _Transfer.delete_Transfer_TransferDispatch
Transfer_TransferDispatch_swigregister = _Transfer.Transfer_TransferDispatch_swigregister
Transfer_TransferDispatch_swigregister(Transfer_TransferDispatch)

class Handle_Transfer_ActorDispatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ActorDispatch self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ActorDispatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ActorDispatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ActorDispatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ActorDispatch self, Transfer_ActorDispatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ActorDispatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ActorDispatch self, Handle_Transfer_ActorDispatch theHandle) -> Handle_Transfer_ActorDispatch
        assign(Handle_Transfer_ActorDispatch self, Transfer_ActorDispatch thePtr) -> Handle_Transfer_ActorDispatch
        assign(Handle_Transfer_ActorDispatch self, Handle_Transfer_ActorDispatch theHandle) -> Handle_Transfer_ActorDispatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ActorDispatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ActorDispatch self) -> Transfer_ActorDispatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorDispatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ActorDispatch self) -> Transfer_ActorDispatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorDispatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ActorDispatch self) -> Transfer_ActorDispatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ActorDispatch___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ActorDispatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ActorDispatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ActorDispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ActorDispatch_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ActorDispatch

    def AddActor(self, *args):
        """
        AddActor(Handle_Transfer_ActorDispatch self, Handle_Transfer_ActorOfTransientProcess actor)

        Utility which adds an actor to the default <me> (it calls
        SetActor from the TransientProcess)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _Transfer.Handle_Transfer_ActorDispatch_AddActor(self, *args)


    def TransferDispatch(self, *args):
        """
        TransferDispatch(Handle_Transfer_ActorDispatch self) -> Transfer_TransferDispatch

        Returns the TransferDispatch, which does the work, records
        the intermediate data, etc...
        See TransferDispatch & CopyTool, to see the available methods

        :rtype: OCC.wrapper.Transfer.Transfer_TransferDispatch

        """
        return _Transfer.Handle_Transfer_ActorDispatch_TransferDispatch(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_ActorDispatch self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        Specific action : it calls the method Transfer from CopyTool
        i.e. the general service Copy, then returns the Binder
        produced by the TransientProcess

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorDispatch_Transfer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ActorDispatch self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ActorDispatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorDispatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorDispatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ActorDispatch self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorDispatch_Transferring(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_Transfer_ActorDispatch self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorDispatch_TransferTransient(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ActorDispatch self, Handle_Standard_Transient start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorDispatch_Recognize(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_Transfer_ActorDispatch self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Handle_Transfer_ActorDispatch_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_Transfer_ActorDispatch self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorDispatch_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_Transfer_ActorDispatch self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Handle_Transfer_ActorDispatch_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_Transfer_ActorDispatch self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorDispatch_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_Transfer_ActorDispatch self, Handle_Transfer_ActorOfProcessForTransient next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorDispatch_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_Transfer_ActorDispatch self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _Transfer.Handle_Transfer_ActorDispatch_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ActorDispatch self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ActorDispatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ActorDispatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ActorDispatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorDispatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ActorDispatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ActorDispatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorDispatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ActorDispatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorDispatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ActorDispatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorDispatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ActorDispatch self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ActorDispatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ActorDispatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorDispatch_DecrementRefCounter(self, *args)

Handle_Transfer_ActorDispatch_swigregister = _Transfer.Handle_Transfer_ActorDispatch_swigregister
Handle_Transfer_ActorDispatch_swigregister(Handle_Transfer_ActorDispatch)

def Handle_Transfer_ActorDispatch_DownCast(thing):
    return _Transfer.Handle_Transfer_ActorDispatch_DownCast(thing)
Handle_Transfer_ActorDispatch_DownCast = _Transfer.Handle_Transfer_ActorDispatch_DownCast

class Handle_Transfer_FinderProcess(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_FinderProcess self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_FinderProcess_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_FinderProcess self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_FinderProcess self, Transfer_FinderProcess thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_FinderProcess_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_FinderProcess self, Handle_Transfer_FinderProcess theHandle) -> Handle_Transfer_FinderProcess
        assign(Handle_Transfer_FinderProcess self, Transfer_FinderProcess thePtr) -> Handle_Transfer_FinderProcess
        assign(Handle_Transfer_FinderProcess self, Handle_Transfer_FinderProcess theHandle) -> Handle_Transfer_FinderProcess

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_FinderProcess_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_FinderProcess self) -> Transfer_FinderProcess

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_FinderProcess_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_FinderProcess self) -> Transfer_FinderProcess

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_FinderProcess___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_FinderProcess self) -> Transfer_FinderProcess

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_FinderProcess___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_FinderProcess___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_FinderProcess___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_FinderProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_FinderProcess_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_FinderProcess

    def SetModel(self, *args):
        """
        SetModel(Handle_Transfer_FinderProcess self, Handle_Interface_InterfaceModel model)

        Sets an InterfaceModel, which can be used during transfer
        for instance if a context must be managed, it is in the Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetModel(self, *args)


    def Model(self, *args):
        """
        Model(Handle_Transfer_FinderProcess self) -> Handle_Interface_InterfaceModel

        Returns the Model which can be used for context

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_FinderProcess_Model(self, *args)


    def NextMappedWithAttribute(self, *args):
        """
        NextMappedWithAttribute(Handle_Transfer_FinderProcess self, Standard_CString const name, Standard_Integer const num0) -> Standard_Integer

        In the list of mapped items (between 1 and NbMapped),
        searches for the first mapped item which follows <num0>
        (not included) and which has an attribute named <name>
        The considered Attributes are those brought by Finders,i.e.
        by Input data.
        While NextItemWithAttribute works on Result data (Binders)

        Hence, allows such an iteration

        for (num = FP->NextMappedWithAttribute(name,0);
        num > 0;
        num = FP->NextMappedWithAttribute(name,num) {
        .. process mapped item <num>
        }

        :type name: OCC.wrapper.Standard.Standard_CString
        :type num0: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_NextMappedWithAttribute(self, *args)


    def TransientMapper(self, *args):
        """
        TransientMapper(Handle_Transfer_FinderProcess self, Handle_Standard_Transient obj) -> Handle_Transfer_TransientMapper

        Returns a TransientMapper for a given Transient Object
        Either <obj> is already mapped, then its Mapper is returned
        Or it is not, then a new one is created then returned, BUT
        it is not mapped here (use Bind or FindElseBind to do this)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientMapper

        """
        return _Transfer.Handle_Transfer_FinderProcess_TransientMapper(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Handle_Message_Messenger S)

        Specific printing to trace a Finder (by its method ValueType)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_FinderProcess_PrintTrace(self, *args)


    def PrintStats(self, *args):
        """
        PrintStats(Handle_Transfer_FinderProcess self, Standard_Integer const mode, Handle_Message_Messenger S)

        Prints statistics on a given output, according mode

        :type mode: int
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_FinderProcess_PrintStats(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_FinderProcess self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_FinderProcess_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_FinderProcess_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_FinderProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_Transfer_FinderProcess self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Handle_Transfer_FinderProcess_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Handle_Transfer_FinderProcess self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Handle_Transfer_FinderProcess_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_Transfer_FinderProcess self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Handle_Transfer_FinderProcess_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_Transfer_FinderProcess self, Handle_Transfer_ActorOfProcessForFinder actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_Transfer_FinderProcess self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_Transfer_FinderProcess self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_Transfer_FinderProcess self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_FinderProcess_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Transfer_FinderProcess self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_FinderProcess_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_FinderProcess_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_FinderProcess_SendMsg(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_FinderProcess_AddFail(self, *args)


    def AddError(self, *args):
        """
        AddError(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_FinderProcess_AddError(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_FinderProcess_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_CString const pref)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_FinderProcess_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_FinderProcess_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_FinderProcess_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_FinderProcess_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_FinderProcess_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_FinderProcess_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Handle_Transfer_FinderProcess self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Handle_Transfer_FinderProcess_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Handle_Transfer_FinderProcess self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Handle_Transfer_FinderProcess self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Handle_Transfer_FinderProcess_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Handle_Transfer_FinderProcess self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Handle_Transfer_FinderProcess self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Handle_Transfer_FinderProcess_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_FinderProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_Transfer_FinderProcess self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_Transfer_FinderProcess self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Handle_Transfer_FinderProcess self,  binder, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type mode: int

        """
        return _Transfer.Handle_Transfer_FinderProcess_StartTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Handle_Transfer_FinderProcess self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_Transfer_FinderProcess self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_Transfer_FinderProcess self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Handle_Transfer_FinderProcess self) -> Transfer_IteratorOfProcessForFinder

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_Transfer_FinderProcess self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_FinderProcess_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_FinderProcess_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_FinderProcess_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type compute: bool

        """
        return _Transfer.Handle_Transfer_FinderProcess_RemoveResult(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Handle_Transfer_FinderProcess self, Handle_Transfer_Finder start) -> Standard_Integer

        Computes a number to be associated to a starting object in
        a check or a check-list
        By default, returns 0; can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_CheckNum(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Handle_Transfer_FinderProcess self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_FinderProcess_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Handle_Transfer_FinderProcess self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_FinderProcess_GetProgress(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_FinderProcess self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_FinderProcess_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_FinderProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_FinderProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_FinderProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_FinderProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_FinderProcess_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_FinderProcess self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_FinderProcess_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_FinderProcess self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_FinderProcess_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_FinderProcess self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_FinderProcess_DecrementRefCounter(self, *args)

Handle_Transfer_FinderProcess_swigregister = _Transfer.Handle_Transfer_FinderProcess_swigregister
Handle_Transfer_FinderProcess_swigregister(Handle_Transfer_FinderProcess)

def Handle_Transfer_FinderProcess_DownCast(thing):
    return _Transfer.Handle_Transfer_FinderProcess_DownCast(thing)
Handle_Transfer_FinderProcess_DownCast = _Transfer.Handle_Transfer_FinderProcess_DownCast

class Handle_Transfer_BinderOfTransientInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_BinderOfTransientInteger self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_BinderOfTransientInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_BinderOfTransientInteger self, Transfer_BinderOfTransientInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_BinderOfTransientInteger self, Handle_Transfer_BinderOfTransientInteger theHandle) -> Handle_Transfer_BinderOfTransientInteger
        assign(Handle_Transfer_BinderOfTransientInteger self, Transfer_BinderOfTransientInteger thePtr) -> Handle_Transfer_BinderOfTransientInteger
        assign(Handle_Transfer_BinderOfTransientInteger self, Handle_Transfer_BinderOfTransientInteger theHandle) -> Handle_Transfer_BinderOfTransientInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_BinderOfTransientInteger self) -> Transfer_BinderOfTransientInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_BinderOfTransientInteger self) -> Transfer_BinderOfTransientInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_BinderOfTransientInteger self) -> Transfer_BinderOfTransientInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_BinderOfTransientInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_BinderOfTransientInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_BinderOfTransientInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_BinderOfTransientInteger_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_BinderOfTransientInteger

    def SetInteger(self, *args):
        """
        SetInteger(Handle_Transfer_BinderOfTransientInteger self, Standard_Integer const value)

        Sets a value for the integer part

        :type value: int

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_SetInteger(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Integer

        Returns the value set for the integer part

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Integer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_BinderOfTransientInteger self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_BinderOfTransientInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_BinderOfTransientInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResultType(self, *args):
        """
        ResultType(Handle_Transfer_BinderOfTransientInteger self) -> Handle_Standard_Type

        Returns the Effective (Dynamic) Type of the Result
        (Standard_Transient if no Result is defined)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Handle_Transfer_BinderOfTransientInteger self) -> Standard_CString

        Returns the Effective Name of (Dynamic) Type of the Result
        (void) if no result is defined

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_ResultTypeName(self, *args)


    def SetResult(self, *args):
        """
        SetResult(Handle_Transfer_BinderOfTransientInteger self, Handle_Standard_Transient res)

        Defines the Result

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_SetResult(self, *args)


    def Result(self, *args):
        """
        Returns the defined Result, if there is one

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_BinderOfTransientInteger_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTypedResult(self, *args):
        """
        GetTypedResult(Handle_Transfer_BinderOfTransientInteger self,  bnd, Handle_Standard_Type atype, Handle_Standard_Transient res) -> Standard_Boolean

        Returns a transient result according to its type (IsKind)
        i.e. the result itself if IsKind(atype), else searches in
        NextResult, until first found, then returns True
        If not found, returns False (res is NOT touched)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <res> and can be
        immediately used, well initialised

        :type bnd: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_GetTypedResult(self, *args)


    def Merge(self, *args):
        """
        Merge(Handle_Transfer_BinderOfTransientInteger self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Merge(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Boolean

        Returns True if a Binder has several results, either by itself
        or because it has next results
        Can be defined by sub-classes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_IsMultiple(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Handle_Transfer_BinderOfTransientInteger self,  next)

        Adds a next result (at the end of the list)
        Remark : this information is not processed by Merge

        :type next: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_AddResult(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Handle_Transfer_BinderOfTransientInteger self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Handle_Transfer_BinderOfTransientInteger self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Transfer_BinderOfTransientInteger self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Handle_Transfer_BinderOfTransientInteger self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Handle_Transfer_BinderOfTransientInteger self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_BinderOfTransientInteger self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_BinderOfTransientInteger self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_BinderOfTransientInteger self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Handle_Transfer_BinderOfTransientInteger self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_CCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_BinderOfTransientInteger self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_BinderOfTransientInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_BinderOfTransientInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_BinderOfTransientInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_BinderOfTransientInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_BinderOfTransientInteger self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_BinderOfTransientInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_BinderOfTransientInteger_DecrementRefCounter(self, *args)

Handle_Transfer_BinderOfTransientInteger_swigregister = _Transfer.Handle_Transfer_BinderOfTransientInteger_swigregister
Handle_Transfer_BinderOfTransientInteger_swigregister(Handle_Transfer_BinderOfTransientInteger)

def Handle_Transfer_BinderOfTransientInteger_DownCast(thing):
    return _Transfer.Handle_Transfer_BinderOfTransientInteger_DownCast(thing)
Handle_Transfer_BinderOfTransientInteger_DownCast = _Transfer.Handle_Transfer_BinderOfTransientInteger_DownCast

class NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Transfer_Finder >,handle< Transfer_Binder >,Transfer_FindHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Transfer_Finder >,handle< Transfer_Binder >,Transfer_FindHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Transfer_Finder >,handle< Transfer_Binder >,Transfer_FindHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Transfer_Finder >,handle< Transfer_Binder >,Transfer_FindHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Transfer.new_NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher theOther) -> NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher theOther) -> NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1,  theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Integer const theIndex, Handle_Transfer_Finder theKey1,  theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self)

        RemoveLast


        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Integer const theIndex)

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1)

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1)

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_Transfer_Finder theKey1)

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_Size(self, *args)


    def __iter__(self):
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher___iter__(self)
    __swig_destroy__ = _Transfer.delete_NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher
NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_swigregister = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_swigregister
NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_swigregister(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher)

class NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Transfer.new_NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper

    def __next__(self):
        return _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper_swigregister = _Transfer.NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher_IteratorHelper)


try:
	Transfer_TransferMapOfProcessForFinder = NCollection_IndexedDataMap_Handle_Transfer_Finder_Handle_Transfer_Binder_Transfer_FindHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_Transfer_ActorOfFinderProcess(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ActorOfFinderProcess self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ActorOfFinderProcess self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ActorOfFinderProcess self, Transfer_ActorOfFinderProcess thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_ActorOfFinderProcess theHandle) -> Handle_Transfer_ActorOfFinderProcess
        assign(Handle_Transfer_ActorOfFinderProcess self, Transfer_ActorOfFinderProcess thePtr) -> Handle_Transfer_ActorOfFinderProcess
        assign(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_ActorOfFinderProcess theHandle) -> Handle_Transfer_ActorOfFinderProcess

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ActorOfFinderProcess self) -> Transfer_ActorOfFinderProcess

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ActorOfFinderProcess self) -> Transfer_ActorOfFinderProcess

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ActorOfFinderProcess self) -> Transfer_ActorOfFinderProcess

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ActorOfFinderProcess___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ActorOfFinderProcess___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ActorOfFinderProcess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ActorOfFinderProcess_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ActorOfFinderProcess

    def ModeTrans(self, *args):
        """
        ModeTrans(Handle_Transfer_ActorOfFinderProcess self) -> Standard_Integer &

        Returns the Transfer Mode, modifiable

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_ModeTrans(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Transfer(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_Transfer_ActorOfFinderProcess self, Handle_Standard_Transient start, Handle_Transfer_FinderProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_TransferTransient(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ActorOfFinderProcess self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfFinderProcess_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ActorOfFinderProcess_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_Finder start) -> Standard_Boolean

        Prerequesite for Transfer : the method Transfer is
        called on a starting object only if Recognize has
        returned True on it
        This allows to define a list of Actors, each one
        processing a definite kind of data
        TransferProcess calls Recognize on each one before
        calling Transfer. But even if Recognize has returned
        True, Transfer can reject by returning a Null Binder
        (afterwards rejection), the next actor is then invoked

        The provided default returns True, can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Recognize(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_Transfer_ActorOfFinderProcess self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_Transfer_ActorOfFinderProcess self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_Transfer_ActorOfFinderProcess self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_Transfer_ActorOfFinderProcess self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_Transfer_ActorOfFinderProcess self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_Transfer_ActorOfFinderProcess self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ActorOfFinderProcess self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ActorOfFinderProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ActorOfFinderProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ActorOfFinderProcess self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ActorOfFinderProcess self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ActorOfFinderProcess self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ActorOfFinderProcess self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ActorOfFinderProcess self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ActorOfFinderProcess self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ActorOfFinderProcess_DecrementRefCounter(self, *args)

Handle_Transfer_ActorOfFinderProcess_swigregister = _Transfer.Handle_Transfer_ActorOfFinderProcess_swigregister
Handle_Transfer_ActorOfFinderProcess_swigregister(Handle_Transfer_ActorOfFinderProcess)

def Handle_Transfer_ActorOfFinderProcess_DownCast(thing):
    return _Transfer.Handle_Transfer_ActorOfFinderProcess_DownCast(thing)
Handle_Transfer_ActorOfFinderProcess_DownCast = _Transfer.Handle_Transfer_ActorOfFinderProcess_DownCast

class Transfer_DataInfo(object):
    """
    Gives informations on an object
    Used as template to instantiate Mapper and SimpleBinder
    This class is for Transient
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Type(*args):
        """
        Type(Handle_Standard_Transient ent) -> Handle_Standard_Type

        Returns the Type attached to an object
        Here, the Dynamic Type of a Transient. Null Type if unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Transfer_DataInfo_Type(*args)

    Type = staticmethod(Type)

    def TypeName(*args):
        """
        TypeName(Handle_Standard_Transient ent) -> Standard_CString

        Returns Type Name (string)
        Allows to name type of non-handled objects

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Transfer_DataInfo_TypeName(*args)

    TypeName = staticmethod(TypeName)

    def __init__(self):
        """
        Gives informations on an object
        Used as template to instantiate Mapper and SimpleBinder
        This class is for Transient
        """
        this = _Transfer.new_Transfer_DataInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_Transfer_DataInfo
Transfer_DataInfo_swigregister = _Transfer.Transfer_DataInfo_swigregister
Transfer_DataInfo_swigregister(Transfer_DataInfo)

def Transfer_DataInfo_Type(*args):
    """
    Transfer_DataInfo_Type(Handle_Standard_Transient ent) -> Handle_Standard_Type

    Returns the Type attached to an object
    Here, the Dynamic Type of a Transient. Null Type if unknown

    :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Transfer.Transfer_DataInfo_Type(*args)

def Transfer_DataInfo_TypeName(*args):
    """
    Transfer_DataInfo_TypeName(Handle_Standard_Transient ent) -> Standard_CString

    Returns Type Name (string)
    Allows to name type of non-handled objects

    :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Transfer.Transfer_DataInfo_TypeName(*args)

class Transfer_TransferOutput(object):
    """
    A TransferOutput is a Tool which manages the transfer of
    entities created by an Interface, stored in an InterfaceModel,
    into a set of Objects suitable for an Application
    Objects to be transferred are given, by method Transfer
    (which calls Transfer from TransientProcess)
    A default action is available to get all roots of the Model
    Result is given as a TransferIterator (see TransferProcess)
    Also, it is possible to pilot directly the TransientProcess
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_TransferOutput self, Handle_Transfer_ActorOfTransientProcess actor, Handle_Interface_InterfaceModel amodel) -> Transfer_TransferOutput
        __init__(Transfer_TransferOutput self, Handle_Transfer_TransientProcess proc, Handle_Interface_InterfaceModel amodel) -> Transfer_TransferOutput

        Creates a TransferOutput from an already existing
        TransientProcess, and a Model
        Returns (by Reference, hence can be changed) the Mode for
        Scope Management. False (D) means Scope is ignored.
        True means that each individual Transfer (direct or through
        TransferRoots) is regarded as one Scope

        :type proc: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        this = _Transfer.new_Transfer_TransferOutput(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args):
        """
        Model(Transfer_TransferOutput self) -> Handle_Interface_InterfaceModel

        Returns the Starting Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_TransferOutput_Model(self, *args)


    def TransientProcess(self, *args):
        """
        TransientProcess(Transfer_TransferOutput self) -> Handle_Transfer_TransientProcess

        Returns the TransientProcess used to work

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Transfer_TransferOutput_TransientProcess(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Transfer_TransferOutput self, Handle_Standard_Transient obj)

        Transfer checks that all taken Entities come from the same
        Model, then calls Transfer from TransientProcess

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Transfer_TransferOutput_Transfer(self, *args)


    def TransferRoots(self, *args):
        """
        TransferRoots(Transfer_TransferOutput self, Handle_Interface_Protocol protocol)
        TransferRoots(Transfer_TransferOutput self, Interface_Graph G)
        TransferRoots(Transfer_TransferOutput self)

        Runs transfer on the roots of the Interface Model
        Remark : the Roots are computed with a ShareFlags created
        from the Active Protocol


        """
        return _Transfer.Transfer_TransferOutput_TransferRoots(self, *args)


    def ListForStatus(self, *args):
        """
        ListForStatus(Transfer_TransferOutput self, Standard_Boolean const normal, Standard_Boolean const roots) -> Interface_EntityIterator

        Returns the list of Starting Entities with these criteria :
        - <normal> False, gives the entities bound with ABNORMAL STATUS
        (e.g. : Fail recorded, Exception raised during Transfer)
        - <normal> True, gives Entities with or without a Result, but
        with no Fail, no Exception (Warnings are not counted)
        - <roots> False, considers all entities recorded (either for
        Result, or for at least one Fail or Warning message)
        - <roots> True (Default), considers only roots of Transfer
        (the Entities recorded at highest level)
        This method is based on AbnormalResult from TransferProcess

        :type normal: bool
        :type roots: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _Transfer.Transfer_TransferOutput_ListForStatus(self, *args)


    def ModelForStatus(self, *args):
        """
        ModelForStatus(Transfer_TransferOutput self, Handle_Interface_Protocol protocol, Standard_Boolean const normal, Standard_Boolean const roots) -> Handle_Interface_InterfaceModel

        Fills a Model with the list determined by ListForStatus
        This model starts from scratch (made by NewEmptyModel from the
        current Model), then is filled by AddWithRefs

        Useful to get separately from a transfer, the entities which
        have caused problem, in order to furtherly analyse them (with
        normal = False), or the "good" entities, to obtain a data set
        "which works well" (with normal = True)

        :type protocol: OCC.wrapper.Interface.Handle_Interface_Protocol
        :type normal: bool
        :type roots: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Transfer_TransferOutput_ModelForStatus(self, *args)

    __swig_destroy__ = _Transfer.delete_Transfer_TransferOutput
Transfer_TransferOutput_swigregister = _Transfer.Transfer_TransferOutput_swigregister
Transfer_TransferOutput_swigregister(Transfer_TransferOutput)

class Handle_Transfer_HSequenceOfFinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_HSequenceOfFinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_HSequenceOfFinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_HSequenceOfFinder self, Transfer_HSequenceOfFinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_HSequenceOfFinder self, Handle_Transfer_HSequenceOfFinder theHandle) -> Handle_Transfer_HSequenceOfFinder
        assign(Handle_Transfer_HSequenceOfFinder self, Transfer_HSequenceOfFinder thePtr) -> Handle_Transfer_HSequenceOfFinder
        assign(Handle_Transfer_HSequenceOfFinder self, Handle_Transfer_HSequenceOfFinder theHandle) -> Handle_Transfer_HSequenceOfFinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_HSequenceOfFinder self) -> Transfer_HSequenceOfFinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_HSequenceOfFinder self) -> Transfer_HSequenceOfFinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_HSequenceOfFinder self) -> Transfer_HSequenceOfFinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_HSequenceOfFinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_HSequenceOfFinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_HSequenceOfFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_HSequenceOfFinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_HSequenceOfFinder

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        res = _Transfer.Handle_Transfer_HSequenceOfFinder_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Transfer_HSequenceOfFinder self, Handle_Transfer_Finder theItem)
        Append(Handle_Transfer_HSequenceOfFinder self, NCollection_Sequence_Handle_Transfer_Finder theSequence)

        :type theSequence: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Transfer_HSequenceOfFinder self) -> NCollection_Sequence_Handle_Transfer_Finder

        :rtype: OCC.wrapper.Transfer.Transfer_SequenceOfFinder

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_HSequenceOfFinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_HSequenceOfFinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_HSequenceOfFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_HSequenceOfFinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_HSequenceOfFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_HSequenceOfFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_HSequenceOfFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_HSequenceOfFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_HSequenceOfFinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_HSequenceOfFinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_HSequenceOfFinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_HSequenceOfFinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_HSequenceOfFinder_DecrementRefCounter(self, *args)

Handle_Transfer_HSequenceOfFinder_swigregister = _Transfer.Handle_Transfer_HSequenceOfFinder_swigregister
Handle_Transfer_HSequenceOfFinder_swigregister(Handle_Transfer_HSequenceOfFinder)

def Handle_Transfer_HSequenceOfFinder_DownCast(thing):
    return _Transfer.Handle_Transfer_HSequenceOfFinder_DownCast(thing)
Handle_Transfer_HSequenceOfFinder_DownCast = _Transfer.Handle_Transfer_HSequenceOfFinder_DownCast

class Handle_Transfer_VoidBinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_VoidBinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_VoidBinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_VoidBinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_VoidBinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_VoidBinder self, Transfer_VoidBinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_VoidBinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_VoidBinder self, Handle_Transfer_VoidBinder theHandle) -> Handle_Transfer_VoidBinder
        assign(Handle_Transfer_VoidBinder self, Transfer_VoidBinder thePtr) -> Handle_Transfer_VoidBinder
        assign(Handle_Transfer_VoidBinder self, Handle_Transfer_VoidBinder theHandle) -> Handle_Transfer_VoidBinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_VoidBinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_VoidBinder self) -> Transfer_VoidBinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_VoidBinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_VoidBinder self) -> Transfer_VoidBinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_VoidBinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_VoidBinder self) -> Transfer_VoidBinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_VoidBinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_VoidBinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_VoidBinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_VoidBinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_VoidBinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_VoidBinder

    def ResultType(self, *args):
        """
        ResultType(Handle_Transfer_VoidBinder self) -> Handle_Standard_Type

        while a VoidBinder admits no Result, its ResultType returns
        the type of <me>

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_VoidBinder_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Handle_Transfer_VoidBinder self) -> Standard_CString

        Returns "(void)"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_VoidBinder_ResultTypeName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_VoidBinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_VoidBinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_VoidBinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_VoidBinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Merge(self, *args):
        """
        Merge(Handle_Transfer_VoidBinder self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_VoidBinder_Merge(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(Handle_Transfer_VoidBinder self) -> Standard_Boolean

        Returns True if a Binder has several results, either by itself
        or because it has next results
        Can be defined by sub-classes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_VoidBinder_IsMultiple(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Handle_Transfer_VoidBinder self,  next)

        Adds a next result (at the end of the list)
        Remark : this information is not processed by Merge

        :type next: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_VoidBinder_AddResult(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Handle_Transfer_VoidBinder self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_VoidBinder_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_VoidBinder self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_VoidBinder_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Handle_Transfer_VoidBinder self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Handle_Transfer_VoidBinder_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Transfer_VoidBinder self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Handle_Transfer_VoidBinder_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Handle_Transfer_VoidBinder self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_VoidBinder_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Handle_Transfer_VoidBinder self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_VoidBinder_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_VoidBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_VoidBinder_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_VoidBinder self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_VoidBinder_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_VoidBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_VoidBinder_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Handle_Transfer_VoidBinder self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_VoidBinder_CCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_VoidBinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_VoidBinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_VoidBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_VoidBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_VoidBinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_VoidBinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_VoidBinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_VoidBinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_VoidBinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_VoidBinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_VoidBinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_VoidBinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_VoidBinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_VoidBinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_VoidBinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_VoidBinder_DecrementRefCounter(self, *args)

Handle_Transfer_VoidBinder_swigregister = _Transfer.Handle_Transfer_VoidBinder_swigregister
Handle_Transfer_VoidBinder_swigregister(Handle_Transfer_VoidBinder)

def Handle_Transfer_VoidBinder_DownCast(thing):
    return _Transfer.Handle_Transfer_VoidBinder_DownCast(thing)
Handle_Transfer_VoidBinder_DownCast = _Transfer.Handle_Transfer_VoidBinder_DownCast

class Handle_Transfer_ResultFromModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ResultFromModel self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ResultFromModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ResultFromModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ResultFromModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ResultFromModel self, Transfer_ResultFromModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ResultFromModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ResultFromModel self, Handle_Transfer_ResultFromModel theHandle) -> Handle_Transfer_ResultFromModel
        assign(Handle_Transfer_ResultFromModel self, Transfer_ResultFromModel thePtr) -> Handle_Transfer_ResultFromModel
        assign(Handle_Transfer_ResultFromModel self, Handle_Transfer_ResultFromModel theHandle) -> Handle_Transfer_ResultFromModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ResultFromModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ResultFromModel self) -> Transfer_ResultFromModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ResultFromModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ResultFromModel self) -> Transfer_ResultFromModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ResultFromModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ResultFromModel self) -> Transfer_ResultFromModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ResultFromModel___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ResultFromModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ResultFromModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ResultFromModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ResultFromModel_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ResultFromModel

    def SetModel(self, *args):
        """
        SetModel(Handle_Transfer_ResultFromModel self, Handle_Interface_InterfaceModel model)

        Sets starting Model

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_ResultFromModel_SetModel(self, *args)


    def SetFileName(self, *args):
        """
        SetFileName(Handle_Transfer_ResultFromModel self, Standard_CString const filename)

        Sets starting File Name

        :type filename: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ResultFromModel_SetFileName(self, *args)


    def Model(self, *args):
        """
        Model(Handle_Transfer_ResultFromModel self) -> Handle_Interface_InterfaceModel

        Returns starting Model (null if not set)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _Transfer.Handle_Transfer_ResultFromModel_Model(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_Transfer_ResultFromModel self) -> Standard_CString

        Returns starting File Name (empty if not set)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ResultFromModel_FileName(self, *args)


    def Fill(self, *args):
        """
        Fill(Handle_Transfer_ResultFromModel self, Handle_Transfer_TransientProcess TP, Handle_Standard_Transient ent) -> Standard_Boolean

        Fills from a TransientProcess, with the result attached to
        a starting entity. Considers its Model if it is set.
        This action produces a structured set of ResultFromTransient,
        considering scopes, starting by that of <ent>.
        If <ent> has no recorded result, it remains empty
        Returns True if a result is recorded, False else

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromModel_Fill(self, *args)


    def Strip(self, *args):
        """
        Strip(Handle_Transfer_ResultFromModel self, Standard_Integer const mode)

        Clears some data attached to binders used by TransientProcess,
        which become useless once the transfer has been done,
        by calling Strip on its ResultFromTransient

        mode = 0 : minimum, clears data remaining from TransferProcess
        mode = 10 : just keeps file name, label, check status ...,
        and MainResult but only the result (Binder)
        mode = 11 : also clears MainResult (status and names remain)

        :type mode: int

        """
        return _Transfer.Handle_Transfer_ResultFromModel_Strip(self, *args)


    def FillBack(self, *args):
        """
        FillBack(Handle_Transfer_ResultFromModel self, Handle_Transfer_TransientProcess TP)

        Fills back a TransientProcess from the structured set of
        binders. Also sets the Model.

        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _Transfer.Handle_Transfer_ResultFromModel_FillBack(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_ResultFromModel self) -> Standard_Boolean

        Returns True if a Result is recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromModel_HasResult(self, *args)


    def MainResult(self, *args):
        """
        MainResult(Handle_Transfer_ResultFromModel self) -> Handle_Transfer_ResultFromTransient

        Returns the main recorded ResultFromTransient, or a null

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_MainResult(self, *args)


    def SetMainResult(self, *args):
        """
        SetMainResult(Handle_Transfer_ResultFromModel self, Handle_Transfer_ResultFromTransient amain)

        Sets a new value for the main recorded ResultFromTransient

        :type amain: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_SetMainResult(self, *args)


    def MainLabel(self, *args):
        """
        MainLabel(Handle_Transfer_ResultFromModel self) -> Standard_CString

        Returns the label in starting model attached to main entity
        (updated by Fill or SetMainResult, if Model is known)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ResultFromModel_MainLabel(self, *args)


    def MainNumber(self, *args):
        """
        MainNumber(Handle_Transfer_ResultFromModel self) -> Standard_Integer

        Returns the label in starting model attached to main entity

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromModel_MainNumber(self, *args)


    def ResultFromKey(self, *args):
        """
        ResultFromKey(Handle_Transfer_ResultFromModel self, Handle_Standard_Transient start) -> Handle_Transfer_ResultFromTransient

        Searches for a key (starting entity) and returns its result
        Returns a null handle if not found

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ResultFromTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_ResultFromKey(self, *args)


    def Results(self, *args):
        """
        Results(Handle_Transfer_ResultFromModel self, Standard_Integer const level) -> Handle_TColStd_HSequenceOfTransient

        Internal method which returns the list of ResultFromTransient,
        according level (2:complete; 1:sub-level 1; 0:main only)

        :type level: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_Results(self, *args)


    def TransferredList(self, *args):
        """
        TransferredList(Handle_Transfer_ResultFromModel self, Standard_Integer const level=2) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of recorded starting entities, ending by the
        root. Entities with check but no transfer result are ignored
        <level> = 2 (D), considers the complete list
        <level> = 1      considers the main result plus immediate subs
        <level> = 0      just the main result

        :type level: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_TransferredList(self, *args)


    def CheckedList(self, *args):
        """
        CheckedList(Handle_Transfer_ResultFromModel self, Interface_CheckStatus const check, Standard_Boolean const result) -> Handle_TColStd_HSequenceOfTransient

        Returns the list of starting entities to which a check status
        is attached.
        <check> = -2 , all entities whatever the check (see result)
        <check> = -1 , entities with no fail (warning allowed)
        <check> =  0 , entities with no check at all
        <check> =  1 , entities with warning but no fail
        <check> =  2 , entities with fail
        <result> : if True, only entities with an attached result
        Remark : result True and check=0 will give an empty list

        :type check: OCC.wrapper.Interface.Interface_CheckStatus
        :type result: bool
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_CheckedList(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_Transfer_ResultFromModel self, Standard_Boolean const erronly, Standard_Integer const level=2) -> Interface_CheckIterator

        Returns the check-list of this set of results
        <erronly> true : only fails are considered
        <level> = 0 : considers only main binder
        <level> = 1 : considers main binder plus immediate subs
        <level> = 2 (D) : considers all checks

        :type erronly: bool
        :type level: int
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_ResultFromModel_CheckList(self, *args)


    def CheckStatus(self, *args):
        """
        CheckStatus(Handle_Transfer_ResultFromModel self) -> Interface_CheckStatus

        Returns the check status with corresponds to the content
        of this ResultFromModel; considers all levels of transfer
        (worst status). Returns CheckAny if not yet computed
        Reads it from recorded status if already computed, else
        recomputes one

        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Handle_Transfer_ResultFromModel_CheckStatus(self, *args)


    def ComputeCheckStatus(self, *args):
        """
        ComputeCheckStatus(Handle_Transfer_ResultFromModel self, Standard_Boolean const enforce) -> Interface_CheckStatus

        Computes and records check status (see CheckStatus)
        Does not computes it if already done and <enforce> False

        :type enforce: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckStatus

        """
        return _Transfer.Handle_Transfer_ResultFromModel_ComputeCheckStatus(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ResultFromModel self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ResultFromModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ResultFromModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ResultFromModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ResultFromModel self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ResultFromModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ResultFromModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ResultFromModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ResultFromModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ResultFromModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ResultFromModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ResultFromModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ResultFromModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ResultFromModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ResultFromModel self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ResultFromModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ResultFromModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ResultFromModel_DecrementRefCounter(self, *args)

Handle_Transfer_ResultFromModel_swigregister = _Transfer.Handle_Transfer_ResultFromModel_swigregister
Handle_Transfer_ResultFromModel_swigregister(Handle_Transfer_ResultFromModel)

def Handle_Transfer_ResultFromModel_DownCast(thing):
    return _Transfer.Handle_Transfer_ResultFromModel_DownCast(thing)
Handle_Transfer_ResultFromModel_DownCast = _Transfer.Handle_Transfer_ResultFromModel_DownCast

class Transfer_IteratorOfProcessForFinder(Transfer_TransferIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Transfer_IteratorOfProcessForFinder self, Standard_Boolean const withstarts) -> Transfer_IteratorOfProcessForFinder

        Creates an empty Iterator
        if withstarts is True, each Binder to be iterated will
        be associated to its corresponding Starting Object

        :type withstarts: bool

        """
        this = _Transfer.new_Transfer_IteratorOfProcessForFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(Transfer_IteratorOfProcessForFinder self,  binder)
        Add(Transfer_IteratorOfProcessForFinder self,  binder, Handle_Transfer_Finder start)

        Adds a Binder to the iteration list, associated with
        its corresponding Starting Object "start"
        Starting Object is ignored if not required at
        Creation time

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_Add(self, *args)


    def Filter(self, *args):
        """
        Filter(Transfer_IteratorOfProcessForFinder self, Handle_Transfer_HSequenceOfFinder list, Standard_Boolean const keep)

        After having added all items, keeps or rejects items
        which are attached to starting data given by <only>
        <keep> = True (D) : keeps. <keep> = False : rejects
        Does nothing if <withstarts> was False

        :type list: OCC.wrapper.Transfer.Handle_Transfer_HSequenceOfFinder
        :type keep: bool

        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_Filter(self, *args)


    def HasStarting(self, *args):
        """
        HasStarting(Transfer_IteratorOfProcessForFinder self) -> Standard_Boolean

        Returns True if Starting Object is available
        (defined at Creation Time)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Transfer_IteratorOfProcessForFinder_HasStarting(self, *args)


    def Starting(self, *args):
        """
        Returns corresponding Starting Object

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Transfer_IteratorOfProcessForFinder_Starting(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Transfer.delete_Transfer_IteratorOfProcessForFinder
Transfer_IteratorOfProcessForFinder_swigregister = _Transfer.Transfer_IteratorOfProcessForFinder_swigregister
Transfer_IteratorOfProcessForFinder_swigregister(Transfer_IteratorOfProcessForFinder)

class Handle_Transfer_MapContainer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_MapContainer self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_MapContainer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_MapContainer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_MapContainer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_MapContainer self, Transfer_MapContainer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_MapContainer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_MapContainer self, Handle_Transfer_MapContainer theHandle) -> Handle_Transfer_MapContainer
        assign(Handle_Transfer_MapContainer self, Transfer_MapContainer thePtr) -> Handle_Transfer_MapContainer
        assign(Handle_Transfer_MapContainer self, Handle_Transfer_MapContainer theHandle) -> Handle_Transfer_MapContainer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_MapContainer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_MapContainer self) -> Transfer_MapContainer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_MapContainer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_MapContainer self) -> Transfer_MapContainer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_MapContainer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_MapContainer self) -> Transfer_MapContainer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_MapContainer___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_MapContainer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_MapContainer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_MapContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_MapContainer_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_MapContainer

    def SetMapObjects(self, *args):
        """
        SetMapObjects(Handle_Transfer_MapContainer self, NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theMapObjects)

        Set map already translated geometry objects.

        :type theMapObjects: OCC.wrapper.TColStd.TColStd_DataMapOfTransientTransient

        """
        return _Transfer.Handle_Transfer_MapContainer_SetMapObjects(self, *args)


    def GetMapObjects(self, *args):
        """
        GetMapObjects(Handle_Transfer_MapContainer self) -> NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Get map already translated geometry objects.

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfTransientTransient

        """
        return _Transfer.Handle_Transfer_MapContainer_GetMapObjects(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_MapContainer self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_MapContainer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_MapContainer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_MapContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_MapContainer self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_MapContainer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_MapContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_MapContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MapContainer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_MapContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_MapContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_MapContainer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_MapContainer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_MapContainer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_MapContainer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_MapContainer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_MapContainer self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_MapContainer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_MapContainer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_MapContainer_DecrementRefCounter(self, *args)

Handle_Transfer_MapContainer_swigregister = _Transfer.Handle_Transfer_MapContainer_swigregister
Handle_Transfer_MapContainer_swigregister(Handle_Transfer_MapContainer)

def Handle_Transfer_MapContainer_DownCast(thing):
    return _Transfer.Handle_Transfer_MapContainer_DownCast(thing)
Handle_Transfer_MapContainer_DownCast = _Transfer.Handle_Transfer_MapContainer_DownCast

class Handle_Transfer_SimpleBinderOfTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_SimpleBinderOfTransient self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_SimpleBinderOfTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_SimpleBinderOfTransient self, Transfer_SimpleBinderOfTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_SimpleBinderOfTransient self, Handle_Transfer_SimpleBinderOfTransient theHandle) -> Handle_Transfer_SimpleBinderOfTransient
        assign(Handle_Transfer_SimpleBinderOfTransient self, Transfer_SimpleBinderOfTransient thePtr) -> Handle_Transfer_SimpleBinderOfTransient
        assign(Handle_Transfer_SimpleBinderOfTransient self, Handle_Transfer_SimpleBinderOfTransient theHandle) -> Handle_Transfer_SimpleBinderOfTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_SimpleBinderOfTransient self) -> Transfer_SimpleBinderOfTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_SimpleBinderOfTransient self) -> Transfer_SimpleBinderOfTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_SimpleBinderOfTransient self) -> Transfer_SimpleBinderOfTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_SimpleBinderOfTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_SimpleBinderOfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_SimpleBinderOfTransient_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_SimpleBinderOfTransient

    def ResultType(self, *args):
        """
        ResultType(Handle_Transfer_SimpleBinderOfTransient self) -> Handle_Standard_Type

        Returns the Effective (Dynamic) Type of the Result
        (Standard_Transient if no Result is defined)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_ResultType(self, *args)


    def ResultTypeName(self, *args):
        """
        ResultTypeName(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_CString

        Returns the Effective Name of (Dynamic) Type of the Result
        (void) if no result is defined

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_ResultTypeName(self, *args)


    def SetResult(self, *args):
        """
        SetResult(Handle_Transfer_SimpleBinderOfTransient self, Handle_Standard_Transient res)

        Defines the Result

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_SetResult(self, *args)


    def Result(self, *args):
        """
        Returns the defined Result, if there is one

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_SimpleBinderOfTransient_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTypedResult(self, *args):
        """
        GetTypedResult(Handle_Transfer_SimpleBinderOfTransient self,  bnd, Handle_Standard_Type atype, Handle_Standard_Transient res) -> Standard_Boolean

        Returns a transient result according to its type (IsKind)
        i.e. the result itself if IsKind(atype), else searches in
        NextResult, until first found, then returns True
        If not found, returns False (res is NOT touched)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <res> and can be
        immediately used, well initialised

        :type bnd: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_GetTypedResult(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_SimpleBinderOfTransient self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_SimpleBinderOfTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_SimpleBinderOfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Merge(self, *args):
        """
        Merge(Handle_Transfer_SimpleBinderOfTransient self,  other)

        Merges basic data (Check, ExecStatus) from another Binder but
        keeps its result. Used when a binder is replaced by another
        one, this allows to keep messages

        :type other: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Merge(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_Boolean

        Returns True if a Binder has several results, either by itself
        or because it has next results
        Can be defined by sub-classes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsMultiple(self, *args)


    def AddResult(self, *args):
        """
        AddResult(Handle_Transfer_SimpleBinderOfTransient self,  next)

        Adds a next result (at the end of the list)
        Remark : this information is not processed by Merge

        :type next: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_AddResult(self, *args)


    def NextResult(self, *args):
        """
        NextResult(Handle_Transfer_SimpleBinderOfTransient self)

        Returns the next result, Null if none

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_NextResult(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_Boolean

        Returns True if a Result is available (StatusResult = Defined)
        A Unique Result will be gotten by Result (which must be
        defined in each sub-class according to result type)
        For a Multiple Result, see class MultipleBinder
        For other case, specific access has to be forecast

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_HasResult(self, *args)


    def SetAlreadyUsed(self, *args):
        """
        SetAlreadyUsed(Handle_Transfer_SimpleBinderOfTransient self)

        Declares that result is now used by another one, it means that
        it cannot be modified (by Rebind)


        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_SetAlreadyUsed(self, *args)


    def Status(self, *args):
        """
        Status(Handle_Transfer_SimpleBinderOfTransient self) -> Transfer_StatusResult

        Returns status, which can be Initial (not yet done), Made (a
        result is recorded, not yet shared), Used (it is shared and
        cannot be modified)

        :rtype: OCC.wrapper.Transfer.Transfer_StatusResult

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Status(self, *args)


    def StatusExec(self, *args):
        """
        StatusExec(Handle_Transfer_SimpleBinderOfTransient self) -> Transfer_StatusExec

        Returns execution status

        :rtype: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_StatusExec(self, *args)


    def SetStatusExec(self, *args):
        """
        SetStatusExec(Handle_Transfer_SimpleBinderOfTransient self, Transfer_StatusExec const stat)

        Modifies execution status; called by TransferProcess only
        (for StatusError, rather use SetError, below)

        :type stat: OCC.wrapper.Transfer.Transfer_StatusExec

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_SetStatusExec(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_SimpleBinderOfTransient self, Standard_CString const mess, Standard_CString const orig)

        Used to declare an individual transfer as beeing erroneous
        (Status is set to Void, StatusExec is set to Error, <errmess>
        is added to Check's list of Fails)
        It is possible to record several messages of error

        It has same effect for TransferProcess as raising an exception
        during the operation of Transfer, except the Transfer tries to
        continue (as if ErrorHandle had been set)

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_AddFail(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_SimpleBinderOfTransient self, Standard_CString const mess, Standard_CString const orig)

        Used to attach a Warning Message to an individual Transfer
        It has no effect on the Status

        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_AddWarning(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_SimpleBinderOfTransient self) -> Handle_Interface_Check

        Returns Check which stores Fail messages
        Note that no Entity is associated in this Check

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Check(self, *args)


    def CCheck(self, *args):
        """
        CCheck(Handle_Transfer_SimpleBinderOfTransient self) -> Handle_Interface_Check

        Returns Check which stores Fail messages, in order to modify
        it (adding messages, or replacing it)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_CCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_SimpleBinderOfTransient self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_SimpleBinderOfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_SimpleBinderOfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_SimpleBinderOfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_SimpleBinderOfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_SimpleBinderOfTransient self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_SimpleBinderOfTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_SimpleBinderOfTransient_DecrementRefCounter(self, *args)

Handle_Transfer_SimpleBinderOfTransient_swigregister = _Transfer.Handle_Transfer_SimpleBinderOfTransient_swigregister
Handle_Transfer_SimpleBinderOfTransient_swigregister(Handle_Transfer_SimpleBinderOfTransient)

def Handle_Transfer_SimpleBinderOfTransient_DownCast(thing):
    return _Transfer.Handle_Transfer_SimpleBinderOfTransient_DownCast(thing)
Handle_Transfer_SimpleBinderOfTransient_DownCast = _Transfer.Handle_Transfer_SimpleBinderOfTransient_DownCast

class NCollection_Sequence_Handle_Transfer_Finder(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Transfer_Finder self) -> NCollection_Sequence< opencascade::handle< Transfer_Finder > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Transfer_Finder self) -> NCollection_Sequence< opencascade::handle< Transfer_Finder > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Transfer_Finder self) -> NCollection_Sequence< opencascade::handle< Transfer_Finder > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Transfer_Finder self) -> NCollection_Sequence< opencascade::handle< Transfer_Finder > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Transfer.new_NCollection_Sequence_Handle_Transfer_Finder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Transfer_Finder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Transfer_Finder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Transfer_Finder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Transfer_Finder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Transfer_Finder self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Transfer_Finder self)

        Reverse sequence


        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Transfer_Finder self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence_Handle_Transfer_Finder theOther) -> NCollection_Sequence_Handle_Transfer_Finder

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence_Handle_Transfer_Finder theOther) -> NCollection_Sequence_Handle_Transfer_Finder

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence< opencascade::handle< Transfer_Finder > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Transfer_Finder self, Handle_Transfer_Finder theItem)
        Append(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence_Handle_Transfer_Finder theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Transfer_Finder self, Handle_Transfer_Finder theItem)
        Prepend(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence_Handle_Transfer_Finder theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, Handle_Transfer_Finder theItem)
        InsertBefore(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Finder theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Transfer_Finder self, NCollection_Sequence< opencascade::handle< Transfer_Finder > >::Iterator & thePosition, Handle_Transfer_Finder theItem)
        InsertAfter(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Finder theSeq)
        InsertAfter(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, Handle_Transfer_Finder theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Finder theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Finder_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Transfer_Finder self) -> Handle_Transfer_Finder

        First item access

        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Transfer_Finder self) -> Handle_Transfer_Finder

        Last item access

        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Finder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex) -> Handle_Transfer_Finder

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Finder___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Transfer_Finder self, Standard_Integer const theIndex, Handle_Transfer_Finder theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_SetValue(self, *args)


    def __iter__(self):
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder___iter__(self)
    __swig_destroy__ = _Transfer.delete_NCollection_Sequence_Handle_Transfer_Finder
NCollection_Sequence_Handle_Transfer_Finder_swigregister = _Transfer.NCollection_Sequence_Handle_Transfer_Finder_swigregister
NCollection_Sequence_Handle_Transfer_Finder_swigregister(NCollection_Sequence_Handle_Transfer_Finder)

def NCollection_Sequence_Handle_Transfer_Finder_delNode(*args):
    """
    NCollection_Sequence_Handle_Transfer_Finder_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_delNode(*args)

class NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Transfer.new_NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper

    def __next__(self):
        return _Transfer.NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper_swigregister = _Transfer.NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper_swigregister
NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper_swigregister(NCollection_Sequence_Handle_Transfer_Finder_IteratorHelper)


try:
	Transfer_SequenceOfFinder = NCollection_Sequence_Handle_Transfer_Finder
except NameError:
	pass # does not exist, probably ignored

class Handle_Transfer_TransferDeadLoop(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_TransferDeadLoop self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_TransferDeadLoop self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_TransferDeadLoop self, Transfer_TransferDeadLoop thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_TransferDeadLoop self, Handle_Transfer_TransferDeadLoop theHandle) -> Handle_Transfer_TransferDeadLoop
        assign(Handle_Transfer_TransferDeadLoop self, Transfer_TransferDeadLoop thePtr) -> Handle_Transfer_TransferDeadLoop
        assign(Handle_Transfer_TransferDeadLoop self, Handle_Transfer_TransferDeadLoop theHandle) -> Handle_Transfer_TransferDeadLoop

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_TransferDeadLoop self) -> Transfer_TransferDeadLoop

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_TransferDeadLoop self) -> Transfer_TransferDeadLoop

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_TransferDeadLoop self) -> Transfer_TransferDeadLoop

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_TransferDeadLoop___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_TransferDeadLoop___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_TransferDeadLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_TransferDeadLoop_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_TransferDeadLoop

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Transfer_TransferDeadLoop self, Standard_CString const theMessage) -> Handle_Transfer_TransferDeadLoop

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransferDeadLoop

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_TransferDeadLoop self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransferDeadLoop_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_TransferDeadLoop_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Transfer_TransferDeadLoop self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Transfer_TransferDeadLoop self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Transfer_TransferDeadLoop self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Transfer_TransferDeadLoop self)
        Reraise(Handle_Transfer_TransferDeadLoop self, Standard_CString const aMessage)
        Reraise(Handle_Transfer_TransferDeadLoop self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Transfer_TransferDeadLoop self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Transfer_TransferDeadLoop self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Transfer_TransferDeadLoop self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_TransferDeadLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_TransferDeadLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_TransferDeadLoop self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_TransferDeadLoop self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_TransferDeadLoop self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_TransferDeadLoop self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_TransferDeadLoop self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_TransferDeadLoop self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_TransferDeadLoop_DecrementRefCounter(self, *args)

Handle_Transfer_TransferDeadLoop_swigregister = _Transfer.Handle_Transfer_TransferDeadLoop_swigregister
Handle_Transfer_TransferDeadLoop_swigregister(Handle_Transfer_TransferDeadLoop)

def Handle_Transfer_TransferDeadLoop_DownCast(thing):
    return _Transfer.Handle_Transfer_TransferDeadLoop_DownCast(thing)
Handle_Transfer_TransferDeadLoop_DownCast = _Transfer.Handle_Transfer_TransferDeadLoop_DownCast

class NCollection_Sequence_Handle_Transfer_Binder(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Transfer_Binder self) -> NCollection_Sequence< handle< Transfer_Binder > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Transfer_Binder self) -> NCollection_Sequence< handle< Transfer_Binder > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Transfer_Binder self) -> NCollection_Sequence< handle< Transfer_Binder > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Transfer_Binder self) -> NCollection_Sequence< handle< Transfer_Binder > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Transfer.new_NCollection_Sequence_Handle_Transfer_Binder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Transfer_Binder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Transfer_Binder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Transfer_Binder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Transfer_Binder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Transfer_Binder self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Transfer_Binder self)

        Reverse sequence


        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Transfer_Binder self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence_Handle_Transfer_Binder theOther) -> NCollection_Sequence_Handle_Transfer_Binder

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence_Handle_Transfer_Binder theOther) -> NCollection_Sequence_Handle_Transfer_Binder

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence< handle< Transfer_Binder > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Transfer_Binder self,  theItem)
        Append(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence_Handle_Transfer_Binder theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Transfer_Binder self,  theItem)
        Prepend(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence_Handle_Transfer_Binder theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex,  theItem)
        InsertBefore(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Binder theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Transfer_Binder self, NCollection_Sequence< handle< Transfer_Binder > >::Iterator & thePosition,  theItem)
        InsertAfter(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Binder theSeq)
        InsertAfter(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex,  theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Transfer_Binder theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Binder_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Transfer_Binder self)

        First item access

        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Transfer_Binder self)

        Last item access

        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Binder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex)

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Transfer.NCollection_Sequence_Handle_Transfer_Binder___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Transfer_Binder self, Standard_Integer const theIndex,  theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_SetValue(self, *args)


    def __iter__(self):
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder___iter__(self)
    __swig_destroy__ = _Transfer.delete_NCollection_Sequence_Handle_Transfer_Binder
NCollection_Sequence_Handle_Transfer_Binder_swigregister = _Transfer.NCollection_Sequence_Handle_Transfer_Binder_swigregister
NCollection_Sequence_Handle_Transfer_Binder_swigregister(NCollection_Sequence_Handle_Transfer_Binder)

def NCollection_Sequence_Handle_Transfer_Binder_delNode(*args):
    """
    NCollection_Sequence_Handle_Transfer_Binder_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_delNode(*args)

class NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Transfer.new_NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Transfer.delete_NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper

    def __next__(self):
        return _Transfer.NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper_swigregister = _Transfer.NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper_swigregister
NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper_swigregister(NCollection_Sequence_Handle_Transfer_Binder_IteratorHelper)


try:
	Transfer_SequenceOfBinder = NCollection_Sequence_Handle_Transfer_Binder
except NameError:
	pass # does not exist, probably ignored

class Handle_Transfer_ProcessForFinder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Transfer_ProcessForFinder self)

        Nullify the handle


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Transfer_ProcessForFinder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Transfer_ProcessForFinder self, Transfer_ProcessForFinder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Transfer_ProcessForFinder self, Handle_Transfer_ProcessForFinder theHandle) -> Handle_Transfer_ProcessForFinder
        assign(Handle_Transfer_ProcessForFinder self, Transfer_ProcessForFinder thePtr) -> Handle_Transfer_ProcessForFinder
        assign(Handle_Transfer_ProcessForFinder self, Handle_Transfer_ProcessForFinder theHandle) -> Handle_Transfer_ProcessForFinder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Transfer_ProcessForFinder self) -> Transfer_ProcessForFinder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Transfer_ProcessForFinder self) -> Transfer_ProcessForFinder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Transfer.Handle_Transfer_ProcessForFinder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Transfer_ProcessForFinder self) -> Transfer_ProcessForFinder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Transfer.Handle_Transfer_ProcessForFinder___ref__(self, *args)


    def __hash__(self):
        return _Transfer.Handle_Transfer_ProcessForFinder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Transfer.Handle_Transfer_ProcessForFinder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Transfer.new_Handle_Transfer_ProcessForFinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Transfer.Handle_Transfer_ProcessForFinder_DownCast)
    __swig_destroy__ = _Transfer.delete_Handle_Transfer_ProcessForFinder

    def Clear(self, *args):
        """
        Clear(Handle_Transfer_ProcessForFinder self)

        Resets a TransferProcess as ready for a completely new work.
        Clears general data (roots) and the Map


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Clear(self, *args)


    def Clean(self, *args):
        """
        Clean(Handle_Transfer_ProcessForFinder self)

        Rebuilds the Map and the roots to really remove Unbound items
        Because Unbind keeps the entity in place, even if not bound
        Hence, working by checking new items is meaningless if a
        formerly unbound item is rebound


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Clean(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_Transfer_ProcessForFinder self, Standard_Integer const nb)

        Resizes the Map as required (if a new reliable value has been
        determined). Acts only if <nb> is greater than actual NbMapped

        :type nb: int

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Resize(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_Transfer_ProcessForFinder self, Handle_Transfer_ActorOfProcessForFinder actor)

        Defines an Actor, which is used for automatic Transfer
        If already defined, the new Actor is cumulated
        (see SetNext from Actor)

        :type actor: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_Transfer_ProcessForFinder self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the defined Actor. Returns a Null Handle if
        not set.

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Actor(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Returns the Binder which is linked with a starting Object
        It can either bring a Result (Transfer done) or none (for a
        pre-binding).
        If no Binder is linked with <start>, returns a Null Handle
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Find(self, *args)


    def IsBound(self, *args):
        """
        IsBound(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if a Result (whatever its form) is Bound with
        a starting Object. I.e., if a Binder with a Result set,
        is linked with it
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsBound(self, *args)


    def IsAlreadyUsed(self, *args):
        """
        IsAlreadyUsed(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Returns True if the result of the transfer of an object is
        already used in other ones. If it is, Rebind cannot change it.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsAlreadyUsed(self, *args)


    def Bind(self, *args):
        """
        Bind(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start,  binder)

        Creates a Link a starting Object with a Binder. This Binder
        can either bring a Result (effective Binding) or none (it can
        be set later : pre-binding).
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Bind(self, *args)


    def Rebind(self, *args):
        """
        Rebind(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start,  binder)

        Changes the Binder linked with a starting Object for its
        unitary transfer. This it can be useful when the exact form
        of the result is known once the transfer is widely engaged.
        This can be done only on first transfer.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Rebind(self, *args)


    def Unbind(self, *args):
        """
        Unbind(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Removes the Binder linked with a starting object
        If this Binder brings a non-empty Check, it is replaced by
        a VoidBinder. Also removes from the list of Roots as required.
        Returns True if done, False if <start> was not bound
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Unbind(self, *args)


    def FindElseBind(self, *args):
        """
        FindElseBind(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Returns a Binder for a starting entity, as follows :
        Tries to Find the already bound one
        If none found, creates a VoidBinder and Binds it

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_FindElseBind(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_Transfer_ProcessForFinder self, Handle_Message_Messenger messenger)

        Sets Messenger used for outputting messages.

        :type messenger: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_Transfer_ProcessForFinder self) -> Handle_Message_Messenger

        Returns Messenger used for outputting messages.
        The returned object is guaranteed to be non-null;
        default is Message::Messenger().

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Messenger(self, *args)


    def SetTraceLevel(self, *args):
        """
        SetTraceLevel(Handle_Transfer_ProcessForFinder self, Standard_Integer const tracelev)

        Sets trace level used for outputting messages:
        <trace> = 0 : no trace at all
        <trace> = 1 : handled exceptions and calls to AddError
        <trace> = 2 : also calls to AddWarning
        <trace> = 3 : also traces new Roots
        (uses method ErrorTrace).
        Default is 1 : Errors traced

        :type tracelev: int

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetTraceLevel(self, *args)


    def TraceLevel(self, *args):
        """
        TraceLevel(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Returns trace level used for outputting messages.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_TraceLevel(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddFail (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SendFail(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        New name for AddWarning (Msg)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SendWarning(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an information message
        Trace is filled if trace level is at least 3

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SendMsg(self, *args)


    def AddFail(self, *args):
        """
        AddFail(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddFail(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds an Error Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_AddFail(self, *args)


    def AddError(self, *args):
        """
        AddError(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)

        (other name of AddFail, maintained for compatibility)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type orig: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_AddError(self, *args)


    def AddWarning(self, *args):
        """
        AddWarning(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const mess, Standard_CString const orig)
        AddWarning(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Message_Msg amsg)

        Adds a Warning Message to a starting entity from the definition
        of a Msg (Original+Value)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type amsg: OCC.wrapper.Message.Message_Msg

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_AddWarning(self, *args)


    def Mend(self, *args):
        """
        Mend(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_CString const pref)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type pref: OCC.wrapper.Standard.Standard_CString

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Mend(self, *args)


    def Check(self, *args):
        """
        Check(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Handle_Interface_Check

        Returns the Check attached to a starting entity. If <start>
        is unknown, returns an empty Check
        Adds a case name to a starting entity
        Adds a case value to a starting entity
        Returns the complete case list for an entity. Null Handle if empty
        In the list of mapped items (between 1 and NbMapped),
        searches for the first item which follows <num0>(not included)
        and which has an attribute named <name>
        Attributes are brought by Binders
        Hence, allows such an iteration

        for (num = TP->NextItemWithAttribute(name,0);
        num > 0;
        num = TP->NextItemWithAttribute(name,num) {
        .. process mapped item <num>
        }
        Returns the type of an Attribute attached to binders
        If this name gives no Attribute, returns ParamVoid
        If this name gives several different types, returns ParamMisc
        Else, returns the effective type (ParamInteger, ParamReal,
        ParamIdent, or ParamText)
        Returns the list of recorded Attribute Names, as a Dictionary
        of Integer : each value gives the count of items which bring
        this attribute name
        By default, considers all the attribute names
        If <rootname> is given, considers only the attribute names
        which begin by <rootname>

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Check(self, *args)


    def BindTransient(self, *args):
        """
        BindTransient(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Binds a starting object with a Transient Result.
        Uses a SimpleBinderOfTransient to work. If there is already
        one but with no Result set, sets its Result.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_BindTransient(self, *args)


    def FindTransient(self, *args):
        """
        Returns the Result of the Transfer of an object <start> as a
        Transient Result.
        Returns a Null Handle if there is no Transient Result
        Considers a category number, by default 0
        Warning : Supposes that Binding is done with a SimpleBinderOfTransient

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _Transfer.Handle_Transfer_ProcessForFinder_FindTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindMultiple(self, *args):
        """
        BindMultiple(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Prepares an object <start> to be bound with several results.
        If no Binder is yet attached to <obj>, a MultipleBinder
        is created, empty. If a Binder is already set, it must
        accept Multiple Binding.
        Considers a category number, by default 0

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_BindMultiple(self, *args)


    def AddMultiple(self, *args):
        """
        AddMultiple(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Transient res)

        Adds an item to a list of results bound to a starting object.
        Considers a category number, by default 0, for all results

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_AddMultiple(self, *args)


    def FindTypedTransient(self, *args):
        """
        FindTypedTransient(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result attached to a starting object,
        according to its type, by criterium IsKind(atype)

        In case of multiple result, explores the list and gives in
        <val> the first transient result IsKind(atype)
        Returns True and fills <val> if found
        Else, returns False (<val> is not touched, not even nullified)

        This syntactic form avoids to do DownCast : if a result is
        found with the good type, it is loaded in <val> and can be
        immediately used, well initialised

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_FindTypedTransient(self, *args)


    def GetTypedTransient(self, *args):
        """
        GetTypedTransient(Handle_Transfer_ProcessForFinder self,  binder, Handle_Standard_Type atype, Handle_Standard_Transient val) -> Standard_Boolean

        Searches for a transient result recorded in a Binder, whatever
        this Binder is recorded or not in <me>

        This is strictly equivalent to the class method GetTypedResult
        from class SimpleBinderOfTransient, but is just lighter to call

        Apart from this, works as FindTypedTransient

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_GetTypedTransient(self, *args)


    def NbMapped(self, *args):
        """
        NbMapped(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Returns the maximum possible value for Map Index
        (no result can be bound with a value greater than it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_NbMapped(self, *args)


    def Mapped(self, *args):
        """
        Returns the Starting Object bound to an Index,

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Handle_Transfer_ProcessForFinder_Mapped(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapIndex(self, *args):
        """
        MapIndex(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the Index value bound to a Starting Object, 0 if none

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_MapIndex(self, *args)


    def MapItem(self, *args):
        """
        MapItem(Handle_Transfer_ProcessForFinder self, Standard_Integer const num)

        Returns the Binder bound to an Index
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_MapItem(self, *args)


    def SetRoot(self, *args):
        """
        SetRoot(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Declares <obj> (and its Result) as Root. This status will be
        later exploited by RootResult, see below (Result can be
        produced at any time)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetRoot(self, *args)


    def SetRootManagement(self, *args):
        """
        SetRootManagement(Handle_Transfer_ProcessForFinder self, Standard_Boolean const stat)

        Enable (if <stat> True) or Disables (if <stat> False) Root
        Management. If it is set, Transfers are considered as stacked
        (a first Transfer commands other Transfers, and so on) and
        the Transfers commanded by an external caller are "Root".
        Remark : SetRoot can be called whatever this status, on every
        object.
        Default is set to True.

        :type stat: bool

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetRootManagement(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Returns the count of recorded Roots

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_NbRoots(self, *args)


    def Root(self, *args):
        """
        Returns a Root Entity given its number in the list (1-NbRoots)

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Finder

        """
        res = _Transfer.Handle_Transfer_ProcessForFinder_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RootItem(self, *args):
        """
        RootItem(Handle_Transfer_ProcessForFinder self, Standard_Integer const num)

        Returns the Binder bound with a Root Entity given its number
        Considers a category number, by default 0

        :type num: int
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_RootItem(self, *args)


    def RootIndex(self, *args):
        """
        RootIndex(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Returns the index in the list of roots for a starting item,
        or 0 if it is not recorded as a root

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_RootIndex(self, *args)


    def NestingLevel(self, *args):
        """
        NestingLevel(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Returns Nesting Level of Transfers (managed by methods
        TranscriptWith & Co). Starts to zero. If no automatic Transfer
        is used, it remains to zero. Zero means Root Level.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_NestingLevel(self, *args)


    def ResetNestingLevel(self, *args):
        """
        ResetNestingLevel(Handle_Transfer_ProcessForFinder self)

        Resets Nesting Level of Transfers to Zero (Root Level),
        whatever its current value.


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_ResetNestingLevel(self, *args)


    def Recognize(self, *args):
        """
        Recognize(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Tells if <start> has been recognized as good candidate for
        Transfer. i.e. queries the Actor and its Nexts

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Recognize(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start)

        Performs the Transfer of a Starting Object, by calling
        the method TransferProduct (see below).
        Mapping and Roots are managed : nothing is done if a Result is
        already Bound, an exception is raised in case of error.

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Transferring(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Boolean

        Same as Transferring but does not return the Binder.
        Simply returns True in case of success (for user call)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Transfer(self, *args)


    def SetErrorHandle(self, *args):
        """
        SetErrorHandle(Handle_Transfer_ProcessForFinder self, Standard_Boolean const err)

        Allows controls if exceptions will be handled
        Transfer Operations
        <err> False : they are not handled with try {} catch {}
        <err> True  : they are
        Default is False: no handling performed

        :type err: bool

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetErrorHandle(self, *args)


    def ErrorHandle(self, *args):
        """
        ErrorHandle(Handle_Transfer_ProcessForFinder self) -> Standard_Boolean

        Returns error handling flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_ErrorHandle(self, *args)


    def StartTrace(self, *args):
        """
        StartTrace(Handle_Transfer_ProcessForFinder self,  binder, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Integer const mode)

        Method called when trace is asked
        Calls PrintTrace to display information relevant for starting
        objects (which can be redefined)
        <level> is Nesting Level of Transfer (0 = root)
        <mode> controls the way the trace is done :
        0 neutral, 1 for Error, 2 for Warning message, 3 for new Root

        :type binder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type mode: int

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_StartTrace(self, *args)


    def PrintTrace(self, *args):
        """
        PrintTrace(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Handle_Message_Messenger S)

        Prints a short information on a starting object. By default
        prints its Dynamic Type. Can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_PrintTrace(self, *args)


    def IsLooping(self, *args):
        """
        IsLooping(Handle_Transfer_ProcessForFinder self, Standard_Integer const alevel) -> Standard_Boolean

        Returns True if we are surely in a DeadLoop. Evaluation is not
        exact, it is a "majorant" which must be computed fast.
        This "majorant" is : <alevel> greater than NbMapped.

        :type alevel: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsLooping(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_Transfer_ProcessForFinder self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an iterator, the log of root transfer, i.e. the
        created objects and Binders bound to starting roots
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_RootResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_Transfer_ProcessForFinder self, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the entire log of transfer (list of
        created objects and Binders which can bring errors)
        If withstart is given True, Starting Objets are also returned

        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_CompleteResult(self, *args)


    def AbnormalResult(self, *args):
        """
        AbnormalResult(Handle_Transfer_ProcessForFinder self) -> Transfer_IteratorOfProcessForFinder

        Returns Binders which are neither "Done" nor "Initial",
        that is Error,Loop or Run (abnormal states at end of Transfer)
        Starting Objects are given in correspondance in the iterator

        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_AbnormalResult(self, *args)


    def CheckList(self, *args):
        """
        CheckList(Handle_Transfer_ProcessForFinder self, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList as a list of Check : each one is for a
        starting entity which have either check (warning or fail)
        messages are attached, or are in abnormal state : that case
        gives a specific message
        If <erronly> is True, checks with Warnings only are ignored

        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_CheckList(self, *args)


    def ResultOne(self, *args):
        """
        ResultOne(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const withstart) -> Transfer_IteratorOfProcessForFinder

        Returns, as an Iterator, the log of transfer for one object
        <level> = 0 : this object only
        and if <start> is a scope owner (else, <level> is ignored) :
        <level> = 1 : object plus its immediate scoped ones
        <level> = 2 : object plus all its scoped ones

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type withstart: bool
        :rtype: OCC.wrapper.Transfer.Transfer_IteratorOfProcessForFinder

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_ResultOne(self, *args)


    def CheckListOne(self, *args):
        """
        CheckListOne(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Interface_CheckIterator

        Returns a CheckList for one starting object
        <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_CheckListOne(self, *args)


    def IsCheckListEmpty(self, *args):
        """
        IsCheckListEmpty(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const erronly) -> Standard_Boolean

        Returns True if no check message is attached to a starting
        object. <level> interpreted as by ResultOne
        If <erronly> is True, checks with Warnings only are ignored

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type erronly: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsCheckListEmpty(self, *args)


    def RemoveResult(self, *args):
        """
        RemoveResult(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start, Standard_Integer const level, Standard_Boolean const compute)

        Removes Results attached to (== Unbinds) a given object and,
        according <level> :
        <level> = 0 : only it
        <level> = 1 : it plus its immediately owned sub-results(scope)
        <level> = 2 : it plus all its owned sub-results(scope)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type level: int
        :type compute: bool

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_RemoveResult(self, *args)


    def CheckNum(self, *args):
        """
        CheckNum(Handle_Transfer_ProcessForFinder self, Handle_Transfer_Finder start) -> Standard_Integer

        Computes a number to be associated to a starting object in
        a check or a check-list
        By default, returns 0; can be redefined

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_CheckNum(self, *args)


    def SetProgress(self, *args):
        """
        SetProgress(Handle_Transfer_ProcessForFinder self, Handle_Message_ProgressIndicator theProgress)

        Sets Progress indicator

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_SetProgress(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(Handle_Transfer_ProcessForFinder self) -> Handle_Message_ProgressIndicator

        Gets Progress indicator

        :rtype: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_GetProgress(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Transfer_ProcessForFinder self) -> char const *

        :rtype: const char *

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ProcessForFinder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Transfer.Handle_Transfer_ProcessForFinder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Transfer_ProcessForFinder self)

        Memory deallocator for transient classes


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Transfer_ProcessForFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Transfer_ProcessForFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Transfer_ProcessForFinder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Transfer_ProcessForFinder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Transfer_ProcessForFinder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Transfer_ProcessForFinder self)

        Increments the reference counter of this object


        """
        return _Transfer.Handle_Transfer_ProcessForFinder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Transfer_ProcessForFinder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Transfer.Handle_Transfer_ProcessForFinder_DecrementRefCounter(self, *args)

Handle_Transfer_ProcessForFinder_swigregister = _Transfer.Handle_Transfer_ProcessForFinder_swigregister
Handle_Transfer_ProcessForFinder_swigregister(Handle_Transfer_ProcessForFinder)

def Handle_Transfer_ProcessForFinder_DownCast(thing):
    return _Transfer.Handle_Transfer_ProcessForFinder_DownCast(thing)
Handle_Transfer_ProcessForFinder_DownCast = _Transfer.Handle_Transfer_ProcessForFinder_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeExtend')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeExtend')
    _ShapeExtend = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeExtend', [dirname(__file__)])
        except ImportError:
            import _ShapeExtend
            return _ShapeExtend
        try:
            _mod = imp.load_module('_ShapeExtend', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeExtend = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeExtend
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeExtend.delete_SwigPyIterator

    def value(self):
        return _ShapeExtend.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeExtend.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeExtend.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeExtend.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeExtend.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeExtend.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeExtend.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeExtend.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeExtend.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeExtend.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeExtend.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeExtend.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeExtend.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeExtend.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeExtend.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeExtend.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeExtend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeExtend.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeExtend.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeExtend.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeExtend.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeExtend.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeExtend.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeExtend.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeExtend.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeExtend.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeExtend.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeExtend.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeExtend.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeExtend.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeExtend.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeExtend.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeExtend.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeExtend.ptr_to_number(item)
ptr_to_number = _ShapeExtend.ptr_to_number

def HashCode(*args):
    return _ShapeExtend.HashCode(*args)
HashCode = _ShapeExtend.HashCode

def ptr_equal(a, b):
    return _ShapeExtend.ptr_equal(a, b)
ptr_equal = _ShapeExtend.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
ShapeExtend_OK = _ShapeExtend.ShapeExtend_OK
ShapeExtend_DONE1 = _ShapeExtend.ShapeExtend_DONE1
ShapeExtend_DONE2 = _ShapeExtend.ShapeExtend_DONE2
ShapeExtend_DONE3 = _ShapeExtend.ShapeExtend_DONE3
ShapeExtend_DONE4 = _ShapeExtend.ShapeExtend_DONE4
ShapeExtend_DONE5 = _ShapeExtend.ShapeExtend_DONE5
ShapeExtend_DONE6 = _ShapeExtend.ShapeExtend_DONE6
ShapeExtend_DONE7 = _ShapeExtend.ShapeExtend_DONE7
ShapeExtend_DONE8 = _ShapeExtend.ShapeExtend_DONE8
ShapeExtend_DONE = _ShapeExtend.ShapeExtend_DONE
ShapeExtend_FAIL1 = _ShapeExtend.ShapeExtend_FAIL1
ShapeExtend_FAIL2 = _ShapeExtend.ShapeExtend_FAIL2
ShapeExtend_FAIL3 = _ShapeExtend.ShapeExtend_FAIL3
ShapeExtend_FAIL4 = _ShapeExtend.ShapeExtend_FAIL4
ShapeExtend_FAIL5 = _ShapeExtend.ShapeExtend_FAIL5
ShapeExtend_FAIL6 = _ShapeExtend.ShapeExtend_FAIL6
ShapeExtend_FAIL7 = _ShapeExtend.ShapeExtend_FAIL7
ShapeExtend_FAIL8 = _ShapeExtend.ShapeExtend_FAIL8
ShapeExtend_FAIL = _ShapeExtend.ShapeExtend_FAIL
ShapeExtend_Natural = _ShapeExtend.ShapeExtend_Natural
ShapeExtend_Uniform = _ShapeExtend.ShapeExtend_Uniform
ShapeExtend_Unitary = _ShapeExtend.ShapeExtend_Unitary
class ShapeExtend_BasicMsgRegistrator(Standard.Standard_Transient):
    """
    Abstract class that can be used for attaching messages
    to the objects (e.g. shapes).
    It is used by ShapeHealing algorithms to attach a message
    describing encountered case (e.g. removing small edge from
    a wire).

    The methods of this class are empty and redefined, for instance,
    in the classes for Data Exchange processors for attaching
    messages to interface file entities or CAS.CADE shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeExtend_BasicMsgRegistrator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeExtend_BasicMsgRegistrator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeExtend_BasicMsgRegistrator self) -> ShapeExtend_BasicMsgRegistrator

        Empty constructor.


        """
        this = _ShapeExtend.new_ShapeExtend_BasicMsgRegistrator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Send(self, *args):
        """
        Send(ShapeExtend_BasicMsgRegistrator self, Handle_Standard_Transient object, Message_Msg message, Message_Gravity const gravity)
        Send(ShapeExtend_BasicMsgRegistrator self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity)
        Send(ShapeExtend_BasicMsgRegistrator self, Message_Msg message, Message_Gravity const gravity)

        Calls Send method with Null Transient.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeExtend.ShapeExtend_BasicMsgRegistrator_Send(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.ShapeExtend_BasicMsgRegistrator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeExtend.ShapeExtend_BasicMsgRegistrator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.ShapeExtend_BasicMsgRegistrator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_BasicMsgRegistrator
ShapeExtend_BasicMsgRegistrator_swigregister = _ShapeExtend.ShapeExtend_BasicMsgRegistrator_swigregister
ShapeExtend_BasicMsgRegistrator_swigregister(ShapeExtend_BasicMsgRegistrator)

def ShapeExtend_BasicMsgRegistrator_get_type_name(*args):
    """
    ShapeExtend_BasicMsgRegistrator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeExtend.ShapeExtend_BasicMsgRegistrator_get_type_name(*args)

def ShapeExtend_BasicMsgRegistrator_get_type_descriptor(*args):
    """
    ShapeExtend_BasicMsgRegistrator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeExtend.ShapeExtend_BasicMsgRegistrator_get_type_descriptor(*args)

class ShapeExtend_WireData(Standard.Standard_Transient):
    """
    This class provides a data structure necessary for work with the wire as with
    ordered list of edges, what is required for many algorithms. The advantage of
    this class is that it allows to work with wires which are not correct.
    The object of the class ShapeExtend_WireData can be initialized by
    TopoDS_Wire, and converted back to TopoDS_Wire.
    An edge in the wire is defined by its rank number. Operations of accessing,
    adding and removing edge at the given rank number are provided. On the whole
    wire, operations of circular permutation and reversing (both orientations of
    all edges and order of edges) are provided as well.
    This class also provides a method to check if the edge in the wire is a seam
    (if the wire lies on a face).
    This class is handled by reference. Such an approach gives the following advantages:
    1.    Sharing the object of this class strongly optimizes the processes of
    analysis and fixing performed in parallel on the wire stored in the form
    of this class. Fixing tool (e.g. ShapeFix_Wire) fixes problems one by
    one using analyzing tool (e.g. ShapeAnalysis_Wire). Sharing allows not
    to reinitialize each time the analyzing tool with modified
    ShapeExtend_WireData what consumes certain time.
    2.    No copying of contents. The object of ShapeExtend_WireData class has
    quite big size, returning it as a result of the function would cause
    additional copying of contents if this class were one handled by value.
    Moreover, this class is stored as a field in other classes which are
    they returned as results of functions, storing only a handle to
    ShapeExtend_WireData saves time and memory.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeExtend_WireData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeExtend_WireData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeExtend_WireData self) -> ShapeExtend_WireData
        __init__(ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Boolean const chained, Standard_Boolean const theManifoldMode) -> ShapeExtend_WireData

        Constructor initializing the data from TopoDS_Wire. Calls Init(wire,chained).

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type chained: bool
        :type theManifoldMode: bool

        """
        this = _ShapeExtend.new_ShapeExtend_WireData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeExtend_WireData self, Handle_ShapeExtend_WireData other)
        Init(ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Boolean const chained, Standard_Boolean const theManifoldMode) -> Standard_Boolean

        Loads an already existing wire
        If <chained> is True (default), edges are added in the
        sequence as they are explored by TopoDS_Iterator
        Else, if <chained> is False, wire is explored by
        BRepTools_WireExplorer and it is guaranteed that edges will
        be sequencially connected.
        Remark : In the latter case it can happen that not all edges
        will be found (because of limitations of
        BRepTools_WireExplorer for disconnected wires and wires
        with seam edges).

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type chained: bool
        :type theManifoldMode: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_WireData_Init(self, *args)


    def Clear(self, *args):
        """
        Clear(ShapeExtend_WireData self)

        Clears data about Wire.


        """
        return _ShapeExtend.ShapeExtend_WireData_Clear(self, *args)


    def ComputeSeams(self, *args):
        """
        ComputeSeams(ShapeExtend_WireData self, Standard_Boolean const enforce)

        Computes the list of seam edges
        By default (direct call), computing is enforced
        For indirect call (from IsSeam) it is redone only if not yet
        already done or if the list of edges has changed
        Remark : A Seam Edge is an Edge present twice in the list, once as
        FORWARD and once as REVERSED
        Each sense has its own PCurve, the one for FORWARD
        must be set in first

        :type enforce: bool

        """
        return _ShapeExtend.ShapeExtend_WireData_ComputeSeams(self, *args)


    def SetLast(self, *args):
        """
        SetLast(ShapeExtend_WireData self, Standard_Integer const num)

        Does a circular permutation in order to set <num>th edge last

        :type num: int

        """
        return _ShapeExtend.ShapeExtend_WireData_SetLast(self, *args)


    def SetDegeneratedLast(self, *args):
        """
        SetDegeneratedLast(ShapeExtend_WireData self)

        When the wire contains at least one degenerated edge, sets it
        as last one
        Note   : It is useful to process pcurves, for instance, while the pcurve
        of a DGNR may not be computed from its 3D part (there is none)
        it is computed after the other edges have been computed and
        chained.


        """
        return _ShapeExtend.ShapeExtend_WireData_SetDegeneratedLast(self, *args)


    def Add(self, *args):
        """
        Add(ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const atnum=0)
        Add(ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Integer const atnum=0)
        Add(ShapeExtend_WireData self, Handle_ShapeExtend_WireData wire, Standard_Integer const atnum=0)
        Add(ShapeExtend_WireData self, TopoDS_Shape shape, Standard_Integer const atnum=0)

        Adds an edge or a wire invoking corresponding method Add

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type atnum: int

        """
        return _ShapeExtend.ShapeExtend_WireData_Add(self, *args)


    def AddOriented(self, *args):
        """
        AddOriented(ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const mode)
        AddOriented(ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Integer const mode)
        AddOriented(ShapeExtend_WireData self, TopoDS_Shape shape, Standard_Integer const mode)

        Adds an edge or a wire invoking corresponding method
        AddOriented

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mode: int

        """
        return _ShapeExtend.ShapeExtend_WireData_AddOriented(self, *args)


    def Remove(self, *args):
        """
        Remove(ShapeExtend_WireData self, Standard_Integer const num=0)

        Removes an Edge, given its rank. By default removes the last edge.

        :type num: int

        """
        return _ShapeExtend.ShapeExtend_WireData_Remove(self, *args)


    def Set(self, *args):
        """
        Set(ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const num=0)

        Replaces an edge at the given
        rank number <num> with new one. Default is last edge (<num> = 0).

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type num: int

        """
        return _ShapeExtend.ShapeExtend_WireData_Set(self, *args)


    def Reverse(self, *args):
        """
        Reverse(ShapeExtend_WireData self)
        Reverse(ShapeExtend_WireData self, TopoDS_Face face)

        Reverses the sense of the list and the orientation of each Edge
        The face is necessary for swapping pcurves for seam edges
        (first pcurve corresponds to orientation FORWARD, and second to
        REVERSED; when edge is reversed, pcurves must be swapped)
        If face is NULL, no swapping is performed

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeExtend.ShapeExtend_WireData_Reverse(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeExtend_WireData self) -> Standard_Integer

        Returns the count of currently recorded edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_WireData_NbEdges(self, *args)


    def NbNonManifoldEdges(self, *args):
        """
        NbNonManifoldEdges(ShapeExtend_WireData self) -> Standard_Integer

        Returns the count of currently recorded non-manifold edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_WireData_NbNonManifoldEdges(self, *args)


    def NonmanifoldEdge(self, *args):
        """
        NonmanifoldEdge(ShapeExtend_WireData self, Standard_Integer const num) -> TopoDS_Edge

        Returns <num>th nonmanifold Edge

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeExtend.ShapeExtend_WireData_NonmanifoldEdge(self, *args)


    def NonmanifoldEdges(self, *args):
        """
        NonmanifoldEdges(ShapeExtend_WireData self) -> Handle_TopTools_HSequenceOfShape

        Returns sequence of non-manifold edges
        This sequence can be not empty if wire data set in manifold mode but
        initial wire has INTERNAL orientation or contains INTERNAL edges

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeExtend.ShapeExtend_WireData_NonmanifoldEdges(self, *args)


    def ManifoldMode(self, *args):
        """
        ManifoldMode(ShapeExtend_WireData self) -> Standard_Boolean &

        Returns mode defining manifold wire data or not.
        If manifold that nonmanifold edges will not be not
        consider during operations(previous behaviour)
        and they will be added only in result wire
        else non-manifold edges will consider during operations

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_WireData_ManifoldMode(self, *args)


    def Edge(self, *args):
        """
        Edge(ShapeExtend_WireData self, Standard_Integer const num) -> TopoDS_Edge

        Returns <num>th Edge

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeExtend.ShapeExtend_WireData_Edge(self, *args)


    def Index(self, *args):
        """
        Index(ShapeExtend_WireData self, TopoDS_Edge edge) -> Standard_Integer

        Returns the index of the edge
        If the edge is a seam the orientation is also checked
        Returns 0 if the edge is not found in the list

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_WireData_Index(self, *args)


    def IsSeam(self, *args):
        """
        IsSeam(ShapeExtend_WireData self, Standard_Integer const num) -> Standard_Boolean

        Tells if an Edge is seam (see ComputeSeams)
        An edge is considered as seam if it presents twice in
        the edge list, once as FORWARD and once as REVERSED.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_WireData_IsSeam(self, *args)


    def Wire(self, *args):
        """
        Wire(ShapeExtend_WireData self) -> TopoDS_Wire

        Makes TopoDS_Wire using
        BRep_Builder (just creates the TopoDS_Wire object and adds
        all edges into it). This method should be called when
        the wire is correct (for example, after successful
        fixes by ShapeFix_Wire) and adjacent edges share common
        vertices. In case if adjacent edges do not share the same
        vertices the resulting TopoDS_Wire will be invalid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeExtend.ShapeExtend_WireData_Wire(self, *args)


    def WireAPIMake(self, *args):
        """
        WireAPIMake(ShapeExtend_WireData self) -> TopoDS_Wire

        Makes TopoDS_Wire using
        BRepAPI_MakeWire. Class BRepAPI_MakeWire merges
        geometrically coincided vertices and can disturb
        correct order of edges in the wire. If this class fails,
        null shape is returned.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeExtend.ShapeExtend_WireData_WireAPIMake(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.ShapeExtend_WireData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeExtend.ShapeExtend_WireData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.ShapeExtend_WireData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_WireData
ShapeExtend_WireData_swigregister = _ShapeExtend.ShapeExtend_WireData_swigregister
ShapeExtend_WireData_swigregister(ShapeExtend_WireData)

def ShapeExtend_WireData_get_type_name(*args):
    """
    ShapeExtend_WireData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeExtend.ShapeExtend_WireData_get_type_name(*args)

def ShapeExtend_WireData_get_type_descriptor(*args):
    """
    ShapeExtend_WireData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeExtend.ShapeExtend_WireData_get_type_descriptor(*args)

class ShapeExtend_CompositeSurface(Geom.Geom_Surface):
    """
    Composite surface is represented by a grid of surfaces
    (patches) connected geometrically. Patches may have different
    parametrisation ranges, but they should be parametrised in
    the same manner so that parameter of each patch (u,v) can be converted
    to global parameter on the whole surface (U,V) with help of linear
    transformation:

    for any i,j-th patch
    U = Ui + ( u - uijmin ) * ( Ui+1 - Ui ) / ( uijmax - uijmin )
    V = Vj + ( v - vijmin ) * ( Vj+1 - Vj ) / ( vijmax - vijmin )

    where

    [uijmin, uijmax] * [ vijmin, vijmax] - parametric range of i,j-th patch,

    Ui (i=1,..,Nu+1), Vi (j=1,..,Nv+1) - values defining global
    parametrisation by U and V (correspond to points between patches and
    bounds, (Ui,Uj) corresponds to (uijmin,vijmin) on i,j-th patch) and to
    (u(i-1)(j-1)max,v(i-1)(j-1)max) on (i-1),(j-1)-th patch.

    Geometrical connectivity is expressed via global parameters:
    S[i,j](Ui+1,V) = S[i+1,j](Ui+1,V) for any i, j, V
    S[i,j](U,Vj+1) = S[i,j+1](U,Vj+1) for any i, j, U
    It is checked with Precision::Confusion() by default.

    NOTE 1: This class is inherited from Geom_Surface in order to
    make it more easy to store and deal with it. However, it should
    not be passed to standard methods dealing with geometry since
    this type is not known to them.
    NOTE 2: Not all the inherited methods are implemented, and some are
    implemented not in the full form.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeExtend_CompositeSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeExtend_CompositeSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeExtend_CompositeSurface self) -> ShapeExtend_CompositeSurface
        __init__(ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, ShapeExtend_Parametrisation const param=ShapeExtend_Natural) -> ShapeExtend_CompositeSurface
        __init__(ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, NCollection_Array1_Standard_Real UJoints, NCollection_Array1_Standard_Real VJoints) -> ShapeExtend_CompositeSurface

        Initializes by a grid of surfaces (calls Init()).

        :type GridSurf: OCC.wrapper.TColGeom.Handle_TColGeom_HArray2OfSurface
        :type UJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _ShapeExtend.new_ShapeExtend_CompositeSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, ShapeExtend_Parametrisation const param=ShapeExtend_Natural) -> Standard_Boolean
        Init(ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, NCollection_Array1_Standard_Real UJoints, NCollection_Array1_Standard_Real VJoints) -> Standard_Boolean

        Initializes by a grid of surfaces with given global
        parametrisation defined by UJoints and VJoints arrays,
        each having langth equal to number of patches in corresponding
        direction + 1. Global joint values should be sorted in
        increasing order.
        All the Surfaces of the grid must have geometrical
        connectivity as stated above.
        If geometrical connectivity is not satisfied, method
        returns False.
        However, class is initialized even in that case.

        :type GridSurf: OCC.wrapper.TColGeom.Handle_TColGeom_HArray2OfSurface
        :type UJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Init(self, *args)


    def NbUPatches(self, *args):
        """
        NbUPatches(ShapeExtend_CompositeSurface self) -> Standard_Integer

        Returns number of patches in U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_NbUPatches(self, *args)


    def NbVPatches(self, *args):
        """
        NbVPatches(ShapeExtend_CompositeSurface self) -> Standard_Integer

        Returns number of patches in V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_NbVPatches(self, *args)


    def Patches(self, *args):
        """
        Returns grid of surfaces

        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray2OfSurface

        """
        res = _ShapeExtend.ShapeExtend_CompositeSurface_Patches(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UJointValues(self, *args):
        """
        UJointValues(ShapeExtend_CompositeSurface self) -> Handle_TColStd_HArray1OfReal

        Returns the array of U values corresponding to joint
        points between patches as well as to start and end points,
        which define global parametrisation of the surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UJointValues(self, *args)


    def VJointValues(self, *args):
        """
        VJointValues(ShapeExtend_CompositeSurface self) -> Handle_TColStd_HArray1OfReal

        Returns the array of V values corresponding to joint
        points between patches as well as to start and end points,
        which define global parametrisation of the surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VJointValues(self, *args)


    def UJointValue(self, *args):
        """
        UJointValue(ShapeExtend_CompositeSurface self, Standard_Integer const i) -> Standard_Real

        Returns i-th joint value in U direction
        (1-st is global Umin, (NbUPatches()+1)-th is global Umax
        on the composite surface)

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UJointValue(self, *args)


    def VJointValue(self, *args):
        """
        VJointValue(ShapeExtend_CompositeSurface self, Standard_Integer const j) -> Standard_Real

        Returns j-th joint value in V direction
        (1-st is global Vmin, (NbVPatches()+1)-th is global Vmax
        on the composite surface)

        :type j: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VJointValue(self, *args)


    def SetUJointValues(self, *args):
        """
        SetUJointValues(ShapeExtend_CompositeSurface self, NCollection_Array1_Standard_Real UJoints) -> Standard_Boolean

        Sets the array of U values corresponding to joint
        points, which define global parametrisation of the surface.
        Number of values in array should be equal to NbUPatches()+1.
        All the values should be sorted in increasing order.
        If this is not satisfied, does nothing and returns False.

        :type UJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_SetUJointValues(self, *args)


    def SetVJointValues(self, *args):
        """
        SetVJointValues(ShapeExtend_CompositeSurface self, NCollection_Array1_Standard_Real VJoints) -> Standard_Boolean

        Sets the array of V values corresponding to joint
        points, which define global parametrisation of the surface
        Number of values in array should be equal to NbVPatches()+1.
        All the values should be sorted in increasing order.
        If this is not satisfied, does nothing and returns False.

        :type VJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_SetVJointValues(self, *args)


    def SetUFirstValue(self, *args):
        """
        SetUFirstValue(ShapeExtend_CompositeSurface self, Standard_Real const UFirst)

        Changes starting value for global U parametrisation (all
        other joint values are shifted accordingly)

        :type UFirst: float

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_SetUFirstValue(self, *args)


    def SetVFirstValue(self, *args):
        """
        SetVFirstValue(ShapeExtend_CompositeSurface self, Standard_Real const VFirst)

        Changes starting value for global V parametrisation (all
        other joint values are shifted accordingly)

        :type VFirst: float

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_SetVFirstValue(self, *args)


    def LocateUParameter(self, *args):
        """
        LocateUParameter(ShapeExtend_CompositeSurface self, Standard_Real const U) -> Standard_Integer

        Returns number of col that contains given (global) parameter

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_LocateUParameter(self, *args)


    def LocateVParameter(self, *args):
        """
        LocateVParameter(ShapeExtend_CompositeSurface self, Standard_Real const V) -> Standard_Integer

        Returns number of row that contains given (global) parameter

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_LocateVParameter(self, *args)


    def LocateUVPoint(self, *args):
        """
        LocateUVPoint(ShapeExtend_CompositeSurface self, gp_Pnt2d pnt)

        Returns number of row and col of surface that contains
        given point

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :type i: int
        :type j: int

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_LocateUVPoint(self, *args)


    def Patch(self, *args):
        """
        Returns one surface patch that contains given point

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _ShapeExtend.ShapeExtend_CompositeSurface_Patch(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ULocalToGlobal(self, *args):
        """
        ULocalToGlobal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const u) -> Standard_Real

        Converts local parameter u on patch i,j to global parameter U

        :type i: int
        :type j: int
        :type u: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_ULocalToGlobal(self, *args)


    def VLocalToGlobal(self, *args):
        """
        VLocalToGlobal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const v) -> Standard_Real

        Converts local parameter v on patch i,j to global parameter V

        :type i: int
        :type j: int
        :type v: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VLocalToGlobal(self, *args)


    def LocalToGlobal(self, *args):
        """
        LocalToGlobal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Pnt2d uv) -> gp_Pnt2d

        Converts local parameters uv on patch i,j to global parameters UV

        :type i: int
        :type j: int
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_LocalToGlobal(self, *args)


    def UGlobalToLocal(self, *args):
        """
        UGlobalToLocal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const U) -> Standard_Real

        Converts global parameter U to local parameter u on patch i,j

        :type i: int
        :type j: int
        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UGlobalToLocal(self, *args)


    def VGlobalToLocal(self, *args):
        """
        VGlobalToLocal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const V) -> Standard_Real

        Converts global parameter V to local parameter v on patch i,j

        :type i: int
        :type j: int
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VGlobalToLocal(self, *args)


    def GlobalToLocal(self, *args):
        """
        GlobalToLocal(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Pnt2d UV) -> gp_Pnt2d

        Converts global parameters UV to local parameters uv on patch i,j

        :type i: int
        :type j: int
        :type UV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_GlobalToLocal(self, *args)


    def GlobalToLocalTransformation(self, *args):
        """
        GlobalToLocalTransformation(ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Trsf2d Trsf) -> Standard_Boolean

        Computes transformation operator and uFactor descrinbing affine
        transformation required to convert global parameters on composite
        surface to local parameters on patch (i,j):
        uv = ( uFactor, 1. ) X Trsf * UV;
        NOTE: Thus Trsf contains shift and scale by V, scale by U is stored in uFact.
        Returns True if transformation is not an identity

        :type i: int
        :type j: int
        :type uFact: float
        :type Trsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_GlobalToLocalTransformation(self, *args)


    def Transform(self, *args):
        """
        Transform(ShapeExtend_CompositeSurface self, gp_Trsf T)

        Applies transformation to all the patches

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(ShapeExtend_CompositeSurface self) -> Handle_Geom_Geometry

        Returns a copy of the surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Copy(self, *args)


    def UReverse(self, *args):
        """
        UReverse(ShapeExtend_CompositeSurface self)

        NOT IMPLEMENTED (does nothing)


        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(ShapeExtend_CompositeSurface self, Standard_Real const U) -> Standard_Real

        Returns U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(ShapeExtend_CompositeSurface self)

        NOT IMPLEMENTED (does nothing)


        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(ShapeExtend_CompositeSurface self, Standard_Real const V) -> Standard_Real

        Returns V

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(ShapeExtend_CompositeSurface self)

        Returns the parametric bounds of grid

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns True if grid is closed in U direction
        (i.e. connected with Precision::Confusion)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns True if grid is closed in V direction
        (i.e. connected with Precision::Confusion)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(ShapeExtend_CompositeSurface self, Standard_Real const U) -> Handle_Geom_Curve

        NOT IMPLEMENTED (returns Null curve)

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(ShapeExtend_CompositeSurface self, Standard_Real const V) -> Handle_Geom_Curve

        NOT IMPLEMENTED (returns Null curve)

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_VIso(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeExtend_CompositeSurface self) -> GeomAbs_Shape

        returns C0

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(ShapeExtend_CompositeSurface self, Standard_Integer const N) -> Standard_Boolean

        returns True if N <=0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(ShapeExtend_CompositeSurface self, Standard_Integer const N) -> Standard_Boolean

        returns True if N <=0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the grid.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_DN(self, *args)


    def Value(self, *args):
        """
        Value(ShapeExtend_CompositeSurface self, gp_Pnt2d pnt) -> gp_Pnt

        Computes the point of parameter pnt on the grid.

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_Value(self, *args)


    def ComputeJointValues(self, *args):
        """
        ComputeJointValues(ShapeExtend_CompositeSurface self, ShapeExtend_Parametrisation const param=ShapeExtend_Natural)

        Computes Joint values according to parameter

        :type param: OCC.wrapper.ShapeExtend.ShapeExtend_Parametrisation

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_ComputeJointValues(self, *args)


    def CheckConnectivity(self, *args):
        """
        CheckConnectivity(ShapeExtend_CompositeSurface self, Standard_Real const prec) -> Standard_Boolean

        Checks geometrical connectivity of the patches, including
        closedness (sets fields muUClosed and myVClosed)

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_CheckConnectivity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeExtend.ShapeExtend_CompositeSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.ShapeExtend_CompositeSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_CompositeSurface
ShapeExtend_CompositeSurface_swigregister = _ShapeExtend.ShapeExtend_CompositeSurface_swigregister
ShapeExtend_CompositeSurface_swigregister(ShapeExtend_CompositeSurface)

def ShapeExtend_CompositeSurface_get_type_name(*args):
    """
    ShapeExtend_CompositeSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeExtend.ShapeExtend_CompositeSurface_get_type_name(*args)

def ShapeExtend_CompositeSurface_get_type_descriptor(*args):
    """
    ShapeExtend_CompositeSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeExtend.ShapeExtend_CompositeSurface_get_type_descriptor(*args)

class Handle_ShapeExtend_CompositeSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeExtend_CompositeSurface self)

        Nullify the handle


        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeExtend_CompositeSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeExtend_CompositeSurface self, ShapeExtend_CompositeSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeExtend_CompositeSurface self, Handle_ShapeExtend_CompositeSurface theHandle) -> Handle_ShapeExtend_CompositeSurface
        assign(Handle_ShapeExtend_CompositeSurface self, ShapeExtend_CompositeSurface thePtr) -> Handle_ShapeExtend_CompositeSurface
        assign(Handle_ShapeExtend_CompositeSurface self, Handle_ShapeExtend_CompositeSurface theHandle) -> Handle_ShapeExtend_CompositeSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeExtend_CompositeSurface self) -> ShapeExtend_CompositeSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeExtend_CompositeSurface self) -> ShapeExtend_CompositeSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeExtend_CompositeSurface self) -> ShapeExtend_CompositeSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface___ref__(self, *args)


    def __hash__(self):
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeExtend.Handle_ShapeExtend_CompositeSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeExtend.new_Handle_ShapeExtend_CompositeSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeExtend.Handle_ShapeExtend_CompositeSurface_DownCast)
    __swig_destroy__ = _ShapeExtend.delete_Handle_ShapeExtend_CompositeSurface

    def Init(self, *args):
        """
        Init(Handle_ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, ShapeExtend_Parametrisation const param=ShapeExtend_Natural) -> Standard_Boolean
        Init(Handle_ShapeExtend_CompositeSurface self, Handle_TColGeom_HArray2OfSurface GridSurf, NCollection_Array1_Standard_Real UJoints, NCollection_Array1_Standard_Real VJoints) -> Standard_Boolean

        Initializes by a grid of surfaces with given global
        parametrisation defined by UJoints and VJoints arrays,
        each having langth equal to number of patches in corresponding
        direction + 1. Global joint values should be sorted in
        increasing order.
        All the Surfaces of the grid must have geometrical
        connectivity as stated above.
        If geometrical connectivity is not satisfied, method
        returns False.
        However, class is initialized even in that case.

        :type GridSurf: OCC.wrapper.TColGeom.Handle_TColGeom_HArray2OfSurface
        :type UJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Init(self, *args)


    def NbUPatches(self, *args):
        """
        NbUPatches(Handle_ShapeExtend_CompositeSurface self) -> Standard_Integer

        Returns number of patches in U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_NbUPatches(self, *args)


    def NbVPatches(self, *args):
        """
        NbVPatches(Handle_ShapeExtend_CompositeSurface self) -> Standard_Integer

        Returns number of patches in V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_NbVPatches(self, *args)


    def Patch(self, *args):
        """
        Returns one surface patch that contains given point

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Patch(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Patches(self, *args):
        """
        Returns grid of surfaces

        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray2OfSurface

        """
        res = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Patches(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UJointValues(self, *args):
        """
        UJointValues(Handle_ShapeExtend_CompositeSurface self) -> Handle_TColStd_HArray1OfReal

        Returns the array of U values corresponding to joint
        points between patches as well as to start and end points,
        which define global parametrisation of the surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UJointValues(self, *args)


    def VJointValues(self, *args):
        """
        VJointValues(Handle_ShapeExtend_CompositeSurface self) -> Handle_TColStd_HArray1OfReal

        Returns the array of V values corresponding to joint
        points between patches as well as to start and end points,
        which define global parametrisation of the surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VJointValues(self, *args)


    def UJointValue(self, *args):
        """
        UJointValue(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i) -> Standard_Real

        Returns i-th joint value in U direction
        (1-st is global Umin, (NbUPatches()+1)-th is global Umax
        on the composite surface)

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UJointValue(self, *args)


    def VJointValue(self, *args):
        """
        VJointValue(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const j) -> Standard_Real

        Returns j-th joint value in V direction
        (1-st is global Vmin, (NbVPatches()+1)-th is global Vmax
        on the composite surface)

        :type j: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VJointValue(self, *args)


    def SetUJointValues(self, *args):
        """
        SetUJointValues(Handle_ShapeExtend_CompositeSurface self, NCollection_Array1_Standard_Real UJoints) -> Standard_Boolean

        Sets the array of U values corresponding to joint
        points, which define global parametrisation of the surface.
        Number of values in array should be equal to NbUPatches()+1.
        All the values should be sorted in increasing order.
        If this is not satisfied, does nothing and returns False.

        :type UJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_SetUJointValues(self, *args)


    def SetVJointValues(self, *args):
        """
        SetVJointValues(Handle_ShapeExtend_CompositeSurface self, NCollection_Array1_Standard_Real VJoints) -> Standard_Boolean

        Sets the array of V values corresponding to joint
        points, which define global parametrisation of the surface
        Number of values in array should be equal to NbVPatches()+1.
        All the values should be sorted in increasing order.
        If this is not satisfied, does nothing and returns False.

        :type VJoints: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_SetVJointValues(self, *args)


    def SetUFirstValue(self, *args):
        """
        SetUFirstValue(Handle_ShapeExtend_CompositeSurface self, Standard_Real const UFirst)

        Changes starting value for global U parametrisation (all
        other joint values are shifted accordingly)

        :type UFirst: float

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_SetUFirstValue(self, *args)


    def SetVFirstValue(self, *args):
        """
        SetVFirstValue(Handle_ShapeExtend_CompositeSurface self, Standard_Real const VFirst)

        Changes starting value for global V parametrisation (all
        other joint values are shifted accordingly)

        :type VFirst: float

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_SetVFirstValue(self, *args)


    def LocateUParameter(self, *args):
        """
        LocateUParameter(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U) -> Standard_Integer

        Returns number of col that contains given (global) parameter

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_LocateUParameter(self, *args)


    def LocateVParameter(self, *args):
        """
        LocateVParameter(Handle_ShapeExtend_CompositeSurface self, Standard_Real const V) -> Standard_Integer

        Returns number of row that contains given (global) parameter

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_LocateVParameter(self, *args)


    def LocateUVPoint(self, *args):
        """
        LocateUVPoint(Handle_ShapeExtend_CompositeSurface self, gp_Pnt2d pnt)

        Returns number of row and col of surface that contains
        given point

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :type i: int
        :type j: int

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_LocateUVPoint(self, *args)


    def ULocalToGlobal(self, *args):
        """
        ULocalToGlobal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const u) -> Standard_Real

        Converts local parameter u on patch i,j to global parameter U

        :type i: int
        :type j: int
        :type u: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_ULocalToGlobal(self, *args)


    def VLocalToGlobal(self, *args):
        """
        VLocalToGlobal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const v) -> Standard_Real

        Converts local parameter v on patch i,j to global parameter V

        :type i: int
        :type j: int
        :type v: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VLocalToGlobal(self, *args)


    def LocalToGlobal(self, *args):
        """
        LocalToGlobal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Pnt2d uv) -> gp_Pnt2d

        Converts local parameters uv on patch i,j to global parameters UV

        :type i: int
        :type j: int
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_LocalToGlobal(self, *args)


    def UGlobalToLocal(self, *args):
        """
        UGlobalToLocal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const U) -> Standard_Real

        Converts global parameter U to local parameter u on patch i,j

        :type i: int
        :type j: int
        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UGlobalToLocal(self, *args)


    def VGlobalToLocal(self, *args):
        """
        VGlobalToLocal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, Standard_Real const V) -> Standard_Real

        Converts global parameter V to local parameter v on patch i,j

        :type i: int
        :type j: int
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VGlobalToLocal(self, *args)


    def GlobalToLocal(self, *args):
        """
        GlobalToLocal(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Pnt2d UV) -> gp_Pnt2d

        Converts global parameters UV to local parameters uv on patch i,j

        :type i: int
        :type j: int
        :type UV: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_GlobalToLocal(self, *args)


    def GlobalToLocalTransformation(self, *args):
        """
        GlobalToLocalTransformation(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const i, Standard_Integer const j, gp_Trsf2d Trsf) -> Standard_Boolean

        Computes transformation operator and uFactor descrinbing affine
        transformation required to convert global parameters on composite
        surface to local parameters on patch (i,j):
        uv = ( uFactor, 1. ) X Trsf * UV;
        NOTE: Thus Trsf contains shift and scale by V, scale by U is stored in uFact.
        Returns True if transformation is not an identity

        :type i: int
        :type j: int
        :type uFact: float
        :type Trsf: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_GlobalToLocalTransformation(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_ShapeExtend_CompositeSurface self, gp_Trsf T)

        Applies transformation to all the patches

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_ShapeExtend_CompositeSurface self) -> Handle_Geom_Geometry

        Returns a copy of the surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Copy(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_ShapeExtend_CompositeSurface self)

        NOT IMPLEMENTED (does nothing)


        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U) -> Standard_Real

        Returns U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_ShapeExtend_CompositeSurface self)

        NOT IMPLEMENTED (does nothing)


        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_ShapeExtend_CompositeSurface self, Standard_Real const V) -> Standard_Real

        Returns V

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_ShapeExtend_CompositeSurface self)

        Returns the parametric bounds of grid

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns True if grid is closed in U direction
        (i.e. connected with Precision::Confusion)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns True if grid is closed in V direction
        (i.e. connected with Precision::Confusion)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_ShapeExtend_CompositeSurface self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U) -> Handle_Geom_Curve

        NOT IMPLEMENTED (returns Null curve)

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_ShapeExtend_CompositeSurface self, Standard_Real const V) -> Handle_Geom_Curve

        NOT IMPLEMENTED (returns Null curve)

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VIso(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeExtend_CompositeSurface self) -> GeomAbs_Shape

        returns C0

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const N) -> Standard_Boolean

        returns True if N <=0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_ShapeExtend_CompositeSurface self, Standard_Integer const N) -> Standard_Boolean

        returns True if N <=0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the grid.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_ShapeExtend_CompositeSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ShapeExtend_CompositeSurface self, gp_Pnt2d pnt) -> gp_Pnt

        Computes the point of parameter pnt on the grid.

        :type pnt: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Value(self, *args)


    def ComputeJointValues(self, *args):
        """
        ComputeJointValues(Handle_ShapeExtend_CompositeSurface self, ShapeExtend_Parametrisation const param=ShapeExtend_Natural)

        Computes Joint values according to parameter

        :type param: OCC.wrapper.ShapeExtend.ShapeExtend_Parametrisation

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_ComputeJointValues(self, *args)


    def CheckConnectivity(self, *args):
        """
        CheckConnectivity(Handle_ShapeExtend_CompositeSurface self, Standard_Real const prec) -> Standard_Boolean

        Checks geometrical connectivity of the patches, including
        closedness (sets fields muUClosed and myVClosed)

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_CheckConnectivity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeExtend_CompositeSurface self) -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_ShapeExtend_CompositeSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_ShapeExtend_CompositeSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_ShapeExtend_CompositeSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_ShapeExtend_CompositeSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_ParametricTransformation(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_ShapeExtend_CompositeSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_ShapeExtend_CompositeSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_VPeriod(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P)
        Mirror(Handle_ShapeExtend_CompositeSurface self, gp_Ax1 A1)
        Mirror(Handle_ShapeExtend_CompositeSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_ShapeExtend_CompositeSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_ShapeExtend_CompositeSurface self, gp_Vec V)
        Translate(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_ShapeExtend_CompositeSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_ShapeExtend_CompositeSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_ShapeExtend_CompositeSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_ShapeExtend_CompositeSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_ShapeExtend_CompositeSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_ShapeExtend_CompositeSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeExtend_CompositeSurface self)

        Memory deallocator for transient classes


        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeExtend_CompositeSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeExtend_CompositeSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeExtend_CompositeSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeExtend_CompositeSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeExtend_CompositeSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeExtend_CompositeSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeExtend_CompositeSurface self)

        Increments the reference counter of this object


        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeExtend_CompositeSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_DecrementRefCounter(self, *args)

Handle_ShapeExtend_CompositeSurface_swigregister = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_swigregister
Handle_ShapeExtend_CompositeSurface_swigregister(Handle_ShapeExtend_CompositeSurface)

def Handle_ShapeExtend_CompositeSurface_DownCast(thing):
    return _ShapeExtend.Handle_ShapeExtend_CompositeSurface_DownCast(thing)
Handle_ShapeExtend_CompositeSurface_DownCast = _ShapeExtend.Handle_ShapeExtend_CompositeSurface_DownCast

class NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Message_ListOfMsg,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Message_ListOfMsg,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Message_ListOfMsg,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,Message_ListOfMsg,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _ShapeExtend.new_NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, NCollection_List< Message_Msg > const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, NCollection_List< Message_Msg > const & theItem) -> NCollection_List< Message_Msg > *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> NCollection_List< Message_Msg > const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> NCollection_List< Message_Msg > *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> NCollection_List< Message_Msg > &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _ShapeExtend.delete_NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher
NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_swigregister = _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeExtend.new_NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeExtend.delete_NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper_swigregister = _ShapeExtend.NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher_IteratorHelper)


try:
	ShapeExtend_DataMapOfTransientListOfMsg = NCollection_DataMap_Handle_Standard_Transient_Message_ListOfMsg_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class ShapeExtend_MsgRegistrator(ShapeExtend_BasicMsgRegistrator):
    """
    Attaches messages to the objects (generic Transient or shape).
    The objects of this class are transmitted to the Shape Healing
    algorithms so that they could collect messages occurred during
    processing.

    Messages are added to the Maps (stored as a field) that can be
    used, for instance, by Data Exchange processors to attach those
    messages to initial file entities.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeExtend_MsgRegistrator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeExtend_MsgRegistrator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeExtend_MsgRegistrator self) -> ShapeExtend_MsgRegistrator

        Creates an object.


        """
        this = _ShapeExtend.new_ShapeExtend_MsgRegistrator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Send(self, *args):
        """
        Send(ShapeExtend_MsgRegistrator self, Handle_Standard_Transient object, Message_Msg message, Message_Gravity const gravity)
        Send(ShapeExtend_MsgRegistrator self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity)

        Sends a message to be attached to the shape.
        If the shape is in the map then the message is added to the
        list, otherwise the shape is firstly added to the map.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeExtend.ShapeExtend_MsgRegistrator_Send(self, *args)


    def MapTransient(self, *args):
        """
        Returns a Map of objects and message list

        :rtype: OCC.wrapper.ShapeExtend.ShapeExtend_DataMapOfTransientListOfMsg

        """
        res = _ShapeExtend.ShapeExtend_MsgRegistrator_MapTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapShape(self, *args):
        """
        Returns a Map of shapes and message list

        :rtype: OCC.wrapper.ShapeExtend.ShapeExtend_DataMapOfShapeListOfMsg

        """
        res = _ShapeExtend.ShapeExtend_MsgRegistrator_MapShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.ShapeExtend_MsgRegistrator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeExtend.ShapeExtend_MsgRegistrator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.ShapeExtend_MsgRegistrator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_MsgRegistrator
ShapeExtend_MsgRegistrator_swigregister = _ShapeExtend.ShapeExtend_MsgRegistrator_swigregister
ShapeExtend_MsgRegistrator_swigregister(ShapeExtend_MsgRegistrator)

def ShapeExtend_MsgRegistrator_get_type_name(*args):
    """
    ShapeExtend_MsgRegistrator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeExtend.ShapeExtend_MsgRegistrator_get_type_name(*args)

def ShapeExtend_MsgRegistrator_get_type_descriptor(*args):
    """
    ShapeExtend_MsgRegistrator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeExtend.ShapeExtend_MsgRegistrator_get_type_descriptor(*args)

class ShapeExtend_ComplexCurve(Geom.Geom_Curve):
    """
    Defines a curve which consists of several segments.
    Implements basic interface to it.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeExtend_ComplexCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeExtend_ComplexCurve(self) 
            return h


    def NbCurves(self, *args):
        """
        NbCurves(ShapeExtend_ComplexCurve self) -> Standard_Integer

        Returns number of curves

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_NbCurves(self, *args)


    def Curve(self, *args):
        """
        Returns curve given by its index

        :type index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _ShapeExtend.ShapeExtend_ComplexCurve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocateParameter(self, *args):
        """
        LocateParameter(ShapeExtend_ComplexCurve self, Standard_Real const U) -> Standard_Integer

        Returns number of the curve for the given parameter U
        and local paramete r UOut for the found curve

        :type U: float
        :type UOut: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_LocateParameter(self, *args)


    def LocalToGlobal(self, *args):
        """
        LocalToGlobal(ShapeExtend_ComplexCurve self, Standard_Integer const index, Standard_Real const Ulocal) -> Standard_Real

        Returns global parameter for the whole curve according
        to the segment and local parameter on it

        :type index: int
        :type Ulocal: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_LocalToGlobal(self, *args)


    def Transform(self, *args):
        """
        Transform(ShapeExtend_ComplexCurve self, gp_Trsf T)

        Applies transformation to each curve

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_Transform(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(ShapeExtend_ComplexCurve self, Standard_Real const U) -> Standard_Real

        Returns 1 - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(ShapeExtend_ComplexCurve self) -> Standard_Real

        Returns 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(ShapeExtend_ComplexCurve self) -> Standard_Real

        Returns 1

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(ShapeExtend_ComplexCurve self) -> Standard_Boolean

        Returns True if the curve is closed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(ShapeExtend_ComplexCurve self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeExtend_ComplexCurve self) -> GeomAbs_Shape

        Returns GeomAbs_C0

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(ShapeExtend_ComplexCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns False if N > 0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P)

        Returns point at parameter U.
        Finds appropriate curve and local parameter on it.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(ShapeExtend_ComplexCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_DN(self, *args)


    def GetScaleFactor(self, *args):
        """
        GetScaleFactor(ShapeExtend_ComplexCurve self, Standard_Integer const ind) -> Standard_Real

        Returns scale factor for recomputing of deviatives.

        :type ind: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_GetScaleFactor(self, *args)


    def CheckConnectivity(self, *args):
        """
        CheckConnectivity(ShapeExtend_ComplexCurve self, Standard_Real const Preci) -> Standard_Boolean

        Checks geometrical connectivity of the curves, including
        closure (sets fields myClosed)

        :type Preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_CheckConnectivity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeExtend.ShapeExtend_ComplexCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.ShapeExtend_ComplexCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_ComplexCurve
ShapeExtend_ComplexCurve_swigregister = _ShapeExtend.ShapeExtend_ComplexCurve_swigregister
ShapeExtend_ComplexCurve_swigregister(ShapeExtend_ComplexCurve)

def ShapeExtend_ComplexCurve_get_type_name(*args):
    """
    ShapeExtend_ComplexCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeExtend.ShapeExtend_ComplexCurve_get_type_name(*args)

def ShapeExtend_ComplexCurve_get_type_descriptor(*args):
    """
    ShapeExtend_ComplexCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeExtend.ShapeExtend_ComplexCurve_get_type_descriptor(*args)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class ShapeExtend_(object):
    """
    This package provides general tools and data structures common
    for other packages in SHAPEWORKS and extending CAS.CADE
    structures.
    The following items are provided by this package:
    - enumeration Status used for coding status flags in methods
    inside the SHAPEWORKS
    - enumeration Parametrisation used for setting global parametrisation
    on the composite surface
    - class CompositeSurface representing a composite surface
    made of a grid of surface patches
    - class WireData representing a wire in the form of ordered
    list of edges
    - class MsgRegistrator for attaching messages to the objects
    - tools for exploring the shapes
    -       tools for creating       new shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args):
        """
        Init()

        Inits using of ShapeExtend.
        Currently, loads messages output by ShapeHealing algorithms.


        """
        return _ShapeExtend.ShapeExtend__Init(*args)

    Init = staticmethod(Init)

    def EncodeStatus(*args):
        """
        EncodeStatus(ShapeExtend_Status const status) -> Standard_Integer

        Encodes status (enumeration) to a bit flag

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.ShapeExtend__EncodeStatus(*args)

    EncodeStatus = staticmethod(EncodeStatus)

    def DecodeStatus(*args):
        """
        DecodeStatus(Standard_Integer const flag, ShapeExtend_Status const status) -> Standard_Boolean

        Tells if a bit flag contains bit corresponding to enumerated status

        :type flag: int
        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.ShapeExtend__DecodeStatus(*args)

    DecodeStatus = staticmethod(DecodeStatus)

    def __init__(self):
        """
        This package provides general tools and data structures common
        for other packages in SHAPEWORKS and extending CAS.CADE
        structures.
        The following items are provided by this package:
        - enumeration Status used for coding status flags in methods
        inside the SHAPEWORKS
        - enumeration Parametrisation used for setting global parametrisation
        on the composite surface
        - class CompositeSurface representing a composite surface
        made of a grid of surface patches
        - class WireData representing a wire in the form of ordered
        list of edges
        - class MsgRegistrator for attaching messages to the objects
        - tools for exploring the shapes
        -       tools for creating       new shapes.
        """
        this = _ShapeExtend.new_ShapeExtend_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_
ShapeExtend__swigregister = _ShapeExtend.ShapeExtend__swigregister
ShapeExtend__swigregister(ShapeExtend_)

def ShapeExtend__Init(*args):
    """
    ShapeExtend__Init()

    Inits using of ShapeExtend.
    Currently, loads messages output by ShapeHealing algorithms.


    """
    return _ShapeExtend.ShapeExtend__Init(*args)

def ShapeExtend__EncodeStatus(*args):
    """
    ShapeExtend__EncodeStatus(ShapeExtend_Status const status) -> Standard_Integer

    Encodes status (enumeration) to a bit flag

    :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _ShapeExtend.ShapeExtend__EncodeStatus(*args)

def ShapeExtend__DecodeStatus(*args):
    """
    ShapeExtend__DecodeStatus(Standard_Integer const flag, ShapeExtend_Status const status) -> Standard_Boolean

    Tells if a bit flag contains bit corresponding to enumerated status

    :type flag: int
    :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeExtend.ShapeExtend__DecodeStatus(*args)

class Handle_ShapeExtend_WireData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeExtend_WireData self)

        Nullify the handle


        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeExtend_WireData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeExtend_WireData self, ShapeExtend_WireData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeExtend_WireData self, Handle_ShapeExtend_WireData theHandle) -> Handle_ShapeExtend_WireData
        assign(Handle_ShapeExtend_WireData self, ShapeExtend_WireData thePtr) -> Handle_ShapeExtend_WireData
        assign(Handle_ShapeExtend_WireData self, Handle_ShapeExtend_WireData theHandle) -> Handle_ShapeExtend_WireData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeExtend_WireData self) -> ShapeExtend_WireData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeExtend_WireData self) -> ShapeExtend_WireData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeExtend_WireData self) -> ShapeExtend_WireData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData___ref__(self, *args)


    def __hash__(self):
        return _ShapeExtend.Handle_ShapeExtend_WireData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeExtend.Handle_ShapeExtend_WireData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeExtend.new_Handle_ShapeExtend_WireData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeExtend.Handle_ShapeExtend_WireData_DownCast)
    __swig_destroy__ = _ShapeExtend.delete_Handle_ShapeExtend_WireData

    def Init(self, *args):
        """
        Init(Handle_ShapeExtend_WireData self, Handle_ShapeExtend_WireData other)
        Init(Handle_ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Boolean const chained, Standard_Boolean const theManifoldMode) -> Standard_Boolean

        Loads an already existing wire
        If <chained> is True (default), edges are added in the
        sequence as they are explored by TopoDS_Iterator
        Else, if <chained> is False, wire is explored by
        BRepTools_WireExplorer and it is guaranteed that edges will
        be sequencially connected.
        Remark : In the latter case it can happen that not all edges
        will be found (because of limitations of
        BRepTools_WireExplorer for disconnected wires and wires
        with seam edges).

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type chained: bool
        :type theManifoldMode: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Init(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_ShapeExtend_WireData self)

        Clears data about Wire.


        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Clear(self, *args)


    def ComputeSeams(self, *args):
        """
        ComputeSeams(Handle_ShapeExtend_WireData self, Standard_Boolean const enforce)

        Computes the list of seam edges
        By default (direct call), computing is enforced
        For indirect call (from IsSeam) it is redone only if not yet
        already done or if the list of edges has changed
        Remark : A Seam Edge is an Edge present twice in the list, once as
        FORWARD and once as REVERSED
        Each sense has its own PCurve, the one for FORWARD
        must be set in first

        :type enforce: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_ComputeSeams(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_ShapeExtend_WireData self, Standard_Integer const num)

        Does a circular permutation in order to set <num>th edge last

        :type num: int

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_SetLast(self, *args)


    def SetDegeneratedLast(self, *args):
        """
        SetDegeneratedLast(Handle_ShapeExtend_WireData self)

        When the wire contains at least one degenerated edge, sets it
        as last one
        Note   : It is useful to process pcurves, for instance, while the pcurve
        of a DGNR may not be computed from its 3D part (there is none)
        it is computed after the other edges have been computed and
        chained.


        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_SetDegeneratedLast(self, *args)


    def Add(self, *args):
        """
        Add(Handle_ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const atnum=0)
        Add(Handle_ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Integer const atnum=0)
        Add(Handle_ShapeExtend_WireData self, Handle_ShapeExtend_WireData wire, Standard_Integer const atnum=0)
        Add(Handle_ShapeExtend_WireData self, TopoDS_Shape shape, Standard_Integer const atnum=0)

        Adds an edge or a wire invoking corresponding method Add

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type atnum: int

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Add(self, *args)


    def AddOriented(self, *args):
        """
        AddOriented(Handle_ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const mode)
        AddOriented(Handle_ShapeExtend_WireData self, TopoDS_Wire wire, Standard_Integer const mode)
        AddOriented(Handle_ShapeExtend_WireData self, TopoDS_Shape shape, Standard_Integer const mode)

        Adds an edge or a wire invoking corresponding method
        AddOriented

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mode: int

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_AddOriented(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_ShapeExtend_WireData self, Standard_Integer const num=0)

        Removes an Edge, given its rank. By default removes the last edge.

        :type num: int

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Remove(self, *args)


    def Set(self, *args):
        """
        Set(Handle_ShapeExtend_WireData self, TopoDS_Edge edge, Standard_Integer const num=0)

        Replaces an edge at the given
        rank number <num> with new one. Default is last edge (<num> = 0).

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type num: int

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Set(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_ShapeExtend_WireData self)
        Reverse(Handle_ShapeExtend_WireData self, TopoDS_Face face)

        Reverses the sense of the list and the orientation of each Edge
        The face is necessary for swapping pcurves for seam edges
        (first pcurve corresponds to orientation FORWARD, and second to
        REVERSED; when edge is reversed, pcurves must be swapped)
        If face is NULL, no swapping is performed

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Reverse(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_ShapeExtend_WireData self) -> Standard_Integer

        Returns the count of currently recorded edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_NbEdges(self, *args)


    def NbNonManifoldEdges(self, *args):
        """
        NbNonManifoldEdges(Handle_ShapeExtend_WireData self) -> Standard_Integer

        Returns the count of currently recorded non-manifold edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_NbNonManifoldEdges(self, *args)


    def NonmanifoldEdge(self, *args):
        """
        NonmanifoldEdge(Handle_ShapeExtend_WireData self, Standard_Integer const num) -> TopoDS_Edge

        Returns <num>th nonmanifold Edge

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_NonmanifoldEdge(self, *args)


    def NonmanifoldEdges(self, *args):
        """
        NonmanifoldEdges(Handle_ShapeExtend_WireData self) -> Handle_TopTools_HSequenceOfShape

        Returns sequence of non-manifold edges
        This sequence can be not empty if wire data set in manifold mode but
        initial wire has INTERNAL orientation or contains INTERNAL edges

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_NonmanifoldEdges(self, *args)


    def ManifoldMode(self, *args):
        """
        ManifoldMode(Handle_ShapeExtend_WireData self) -> Standard_Boolean &

        Returns mode defining manifold wire data or not.
        If manifold that nonmanifold edges will not be not
        consider during operations(previous behaviour)
        and they will be added only in result wire
        else non-manifold edges will consider during operations

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_ManifoldMode(self, *args)


    def Edge(self, *args):
        """
        Edge(Handle_ShapeExtend_WireData self, Standard_Integer const num) -> TopoDS_Edge

        Returns <num>th Edge

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Edge(self, *args)


    def Index(self, *args):
        """
        Index(Handle_ShapeExtend_WireData self, TopoDS_Edge edge) -> Standard_Integer

        Returns the index of the edge
        If the edge is a seam the orientation is also checked
        Returns 0 if the edge is not found in the list

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Index(self, *args)


    def IsSeam(self, *args):
        """
        IsSeam(Handle_ShapeExtend_WireData self, Standard_Integer const num) -> Standard_Boolean

        Tells if an Edge is seam (see ComputeSeams)
        An edge is considered as seam if it presents twice in
        the edge list, once as FORWARD and once as REVERSED.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_IsSeam(self, *args)


    def Wire(self, *args):
        """
        Wire(Handle_ShapeExtend_WireData self) -> TopoDS_Wire

        Makes TopoDS_Wire using
        BRep_Builder (just creates the TopoDS_Wire object and adds
        all edges into it). This method should be called when
        the wire is correct (for example, after successful
        fixes by ShapeFix_Wire) and adjacent edges share common
        vertices. In case if adjacent edges do not share the same
        vertices the resulting TopoDS_Wire will be invalid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Wire(self, *args)


    def WireAPIMake(self, *args):
        """
        WireAPIMake(Handle_ShapeExtend_WireData self) -> TopoDS_Wire

        Makes TopoDS_Wire using
        BRepAPI_MakeWire. Class BRepAPI_MakeWire merges
        geometrically coincided vertices and can disturb
        correct order of edges in the wire. If this class fails,
        null shape is returned.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_WireAPIMake(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeExtend_WireData self) -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_WireData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_WireData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeExtend_WireData self)

        Memory deallocator for transient classes


        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeExtend_WireData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeExtend_WireData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeExtend_WireData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeExtend_WireData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeExtend_WireData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeExtend_WireData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeExtend_WireData self)

        Increments the reference counter of this object


        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeExtend_WireData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_WireData_DecrementRefCounter(self, *args)

Handle_ShapeExtend_WireData_swigregister = _ShapeExtend.Handle_ShapeExtend_WireData_swigregister
Handle_ShapeExtend_WireData_swigregister(Handle_ShapeExtend_WireData)

def Handle_ShapeExtend_WireData_DownCast(thing):
    return _ShapeExtend.Handle_ShapeExtend_WireData_DownCast(thing)
Handle_ShapeExtend_WireData_DownCast = _ShapeExtend.Handle_ShapeExtend_WireData_DownCast

class NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Message_ListOfMsg,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Message_ListOfMsg,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Message_ListOfMsg,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Message_ListOfMsg,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _ShapeExtend.new_NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< Message_Msg > const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< Message_Msg > const & theItem) -> NCollection_List< Message_Msg > *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< Message_Msg > const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< Message_Msg > *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< Message_Msg > &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _ShapeExtend.delete_NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_swigregister = _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeExtend.new_NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeExtend.delete_NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _ShapeExtend.NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher_IteratorHelper)


try:
	ShapeExtend_DataMapOfShapeListOfMsg = NCollection_DataMap_TopoDS_Shape_Message_ListOfMsg_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_ShapeExtend_ComplexCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeExtend_ComplexCurve self)

        Nullify the handle


        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeExtend_ComplexCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeExtend_ComplexCurve self, ShapeExtend_ComplexCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeExtend_ComplexCurve self, Handle_ShapeExtend_ComplexCurve theHandle) -> Handle_ShapeExtend_ComplexCurve
        assign(Handle_ShapeExtend_ComplexCurve self, ShapeExtend_ComplexCurve thePtr) -> Handle_ShapeExtend_ComplexCurve
        assign(Handle_ShapeExtend_ComplexCurve self, Handle_ShapeExtend_ComplexCurve theHandle) -> Handle_ShapeExtend_ComplexCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeExtend_ComplexCurve self) -> ShapeExtend_ComplexCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeExtend_ComplexCurve self) -> ShapeExtend_ComplexCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeExtend_ComplexCurve self) -> ShapeExtend_ComplexCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve___ref__(self, *args)


    def __hash__(self):
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeExtend.Handle_ShapeExtend_ComplexCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeExtend.new_Handle_ShapeExtend_ComplexCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeExtend.Handle_ShapeExtend_ComplexCurve_DownCast)
    __swig_destroy__ = _ShapeExtend.delete_Handle_ShapeExtend_ComplexCurve

    def NbCurves(self, *args):
        """
        NbCurves(Handle_ShapeExtend_ComplexCurve self) -> Standard_Integer

        Returns number of curves

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_NbCurves(self, *args)


    def Curve(self, *args):
        """
        Returns curve given by its index

        :type index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocateParameter(self, *args):
        """
        LocateParameter(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U) -> Standard_Integer

        Returns number of the curve for the given parameter U
        and local paramete r UOut for the found curve

        :type U: float
        :type UOut: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_LocateParameter(self, *args)


    def LocalToGlobal(self, *args):
        """
        LocalToGlobal(Handle_ShapeExtend_ComplexCurve self, Standard_Integer const index, Standard_Real const Ulocal) -> Standard_Real

        Returns global parameter for the whole curve according
        to the segment and local parameter on it

        :type index: int
        :type Ulocal: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_LocalToGlobal(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_ShapeExtend_ComplexCurve self, gp_Trsf T)

        Applies transformation to each curve

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Transform(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U) -> Standard_Real

        Returns 1 - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_ShapeExtend_ComplexCurve self) -> Standard_Real

        Returns 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_ShapeExtend_ComplexCurve self) -> Standard_Real

        Returns 1

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_ShapeExtend_ComplexCurve self) -> Standard_Boolean

        Returns True if the curve is closed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_ShapeExtend_ComplexCurve self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeExtend_ComplexCurve self) -> GeomAbs_Shape

        Returns GeomAbs_C0

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_ShapeExtend_ComplexCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns False if N > 0

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P)

        Returns point at parameter U.
        Finds appropriate curve and local parameter on it.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_DN(self, *args)


    def GetScaleFactor(self, *args):
        """
        GetScaleFactor(Handle_ShapeExtend_ComplexCurve self, Standard_Integer const ind) -> Standard_Real

        Returns scale factor for recomputing of deviatives.

        :type ind: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_GetScaleFactor(self, *args)


    def CheckConnectivity(self, *args):
        """
        CheckConnectivity(Handle_ShapeExtend_ComplexCurve self, Standard_Real const Preci) -> Standard_Boolean

        Checks geometrical connectivity of the curves, including
        closure (sets fields myClosed)

        :type Preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_CheckConnectivity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeExtend_ComplexCurve self) -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_ComplexCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_ComplexCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_ShapeExtend_ComplexCurve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Reverse(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_ShapeExtend_ComplexCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_ShapeExtend_ComplexCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_ShapeExtend_ComplexCurve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ShapeExtend_ComplexCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P)
        Mirror(Handle_ShapeExtend_ComplexCurve self, gp_Ax1 A1)
        Mirror(Handle_ShapeExtend_ComplexCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_ShapeExtend_ComplexCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_ShapeExtend_ComplexCurve self, gp_Vec V)
        Translate(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_ShapeExtend_ComplexCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_ShapeExtend_ComplexCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_ShapeExtend_ComplexCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_ShapeExtend_ComplexCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_ShapeExtend_ComplexCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_ShapeExtend_ComplexCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_ShapeExtend_ComplexCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeExtend_ComplexCurve self)

        Memory deallocator for transient classes


        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeExtend_ComplexCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeExtend_ComplexCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeExtend_ComplexCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeExtend_ComplexCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeExtend_ComplexCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeExtend_ComplexCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeExtend_ComplexCurve self)

        Increments the reference counter of this object


        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeExtend_ComplexCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_DecrementRefCounter(self, *args)

Handle_ShapeExtend_ComplexCurve_swigregister = _ShapeExtend.Handle_ShapeExtend_ComplexCurve_swigregister
Handle_ShapeExtend_ComplexCurve_swigregister(Handle_ShapeExtend_ComplexCurve)

def Handle_ShapeExtend_ComplexCurve_DownCast(thing):
    return _ShapeExtend.Handle_ShapeExtend_ComplexCurve_DownCast(thing)
Handle_ShapeExtend_ComplexCurve_DownCast = _ShapeExtend.Handle_ShapeExtend_ComplexCurve_DownCast

class ShapeExtend_Explorer(object):
    """
    This class is intended to
    explore shapes and convert different representations
    (list, sequence, compound) of complex shapes. It provides tools for:
    - obtaining type of the shapes in context of TopoDS_Compound,
    - exploring shapes in context of  TopoDS_Compound,
    - converting different representations of shapes (list, sequence, compound).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeExtend_Explorer self) -> ShapeExtend_Explorer

        Creates an object Explorer


        """
        this = _ShapeExtend.new_ShapeExtend_Explorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CompoundFromSeq(self, *args):
        """
        CompoundFromSeq(ShapeExtend_Explorer self, Handle_TopTools_HSequenceOfShape seqval) -> TopoDS_Shape

        Converts a sequence of Shapes to a Compound

        :type seqval: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeExtend.ShapeExtend_Explorer_CompoundFromSeq(self, *args)


    def SeqFromCompound(self, *args):
        """
        SeqFromCompound(ShapeExtend_Explorer self, TopoDS_Shape comp, Standard_Boolean const expcomp) -> Handle_TopTools_HSequenceOfShape

        Converts a Compound to a list of Shapes
        if <comp> is not a compound, the list contains only <comp>
        if <comp> is Null, the list is empty
        if <comp> is a Compound, its sub-shapes are put into the list
        then if <expcomp> is True, if a sub-shape is a Compound, it
        is not put to the list but its sub-shapes are (recursive)

        :type comp: OCC.wrapper.TopoDS.TopoDS_Shape
        :type expcomp: bool
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeExtend.ShapeExtend_Explorer_SeqFromCompound(self, *args)


    def ListFromSeq(self, *args):
        """
        ListFromSeq(ShapeExtend_Explorer self, Handle_TopTools_HSequenceOfShape seqval, NCollection_List_TopoDS_Shape lisval, Standard_Boolean const clear)

        Converts a Sequence of Shapes to a List of Shapes
        <clear> if True (D), commands the list to start from scratch
        else, the list is cumulated

        :type seqval: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type lisval: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type clear: bool

        """
        return _ShapeExtend.ShapeExtend_Explorer_ListFromSeq(self, *args)


    def SeqFromList(self, *args):
        """
        SeqFromList(ShapeExtend_Explorer self, NCollection_List_TopoDS_Shape lisval) -> Handle_TopTools_HSequenceOfShape

        Converts a List of Shapes to a Sequence of Shapes

        :type lisval: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeExtend.ShapeExtend_Explorer_SeqFromList(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(ShapeExtend_Explorer self, TopoDS_Shape shape, Standard_Boolean const compound) -> TopAbs_ShapeEnum

        Returns the type of a Shape: true type if <compound> is False
        If <compound> is True and <shape> is a Compound, iterates on
        its items. If all are of the same type, returns this type.
        Else, returns COMPOUND. If it is empty, returns SHAPE
        For a Null Shape, returns SHAPE

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type compound: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeExtend.ShapeExtend_Explorer_ShapeType(self, *args)


    def SortedCompound(self, *args):
        """
        SortedCompound(ShapeExtend_Explorer self, TopoDS_Shape shape, TopAbs_ShapeEnum const type, Standard_Boolean const explore, Standard_Boolean const compound) -> TopoDS_Shape

        Builds a COMPOUND from the given shape.
        It explores the shape level by level, according to the
        <explore> argument. If <explore> is False, only COMPOUND
        items are explored, else all items are.
        The following shapes are added to resulting compound:
        - shapes which comply to <type>
        - if <type> is WIRE, considers also free edges (and makes wires)
        - if <type> is SHELL, considers also free faces (and makes shells)
        If <compound> is True, gathers items in compounds which
        correspond to starting COMPOUND,SOLID or SHELL containers, or
        items directly contained in a Compound

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type explore: bool
        :type compound: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeExtend.ShapeExtend_Explorer_SortedCompound(self, *args)


    def DispatchList(self, *args):
        """
        DispatchList(ShapeExtend_Explorer self, Handle_TopTools_HSequenceOfShape list, Handle_TopTools_HSequenceOfShape vertices, Handle_TopTools_HSequenceOfShape edges, Handle_TopTools_HSequenceOfShape wires, Handle_TopTools_HSequenceOfShape faces, Handle_TopTools_HSequenceOfShape shells, Handle_TopTools_HSequenceOfShape solids, Handle_TopTools_HSequenceOfShape compsols, Handle_TopTools_HSequenceOfShape compounds)

        Dispatches starting list of shapes according to their type,
        to the appropriate resulting lists
        For each of these lists, if it is null, it is firstly created
        else, new items are appended to the already existing ones

        :type list: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type vertices: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type edges: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type faces: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type shells: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type solids: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type compsols: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type compounds: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeExtend.ShapeExtend_Explorer_DispatchList(self, *args)

    __swig_destroy__ = _ShapeExtend.delete_ShapeExtend_Explorer
ShapeExtend_Explorer_swigregister = _ShapeExtend.ShapeExtend_Explorer_swigregister
ShapeExtend_Explorer_swigregister(ShapeExtend_Explorer)

class Handle_ShapeExtend_MsgRegistrator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeExtend_MsgRegistrator self)

        Nullify the handle


        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeExtend_MsgRegistrator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeExtend_MsgRegistrator self, ShapeExtend_MsgRegistrator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeExtend_MsgRegistrator self, Handle_ShapeExtend_MsgRegistrator theHandle) -> Handle_ShapeExtend_MsgRegistrator
        assign(Handle_ShapeExtend_MsgRegistrator self, ShapeExtend_MsgRegistrator thePtr) -> Handle_ShapeExtend_MsgRegistrator
        assign(Handle_ShapeExtend_MsgRegistrator self, Handle_ShapeExtend_MsgRegistrator theHandle) -> Handle_ShapeExtend_MsgRegistrator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeExtend_MsgRegistrator self) -> ShapeExtend_MsgRegistrator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeExtend_MsgRegistrator self) -> ShapeExtend_MsgRegistrator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeExtend_MsgRegistrator self) -> ShapeExtend_MsgRegistrator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator___ref__(self, *args)


    def __hash__(self):
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeExtend.new_Handle_ShapeExtend_MsgRegistrator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeExtend.Handle_ShapeExtend_MsgRegistrator_DownCast)
    __swig_destroy__ = _ShapeExtend.delete_Handle_ShapeExtend_MsgRegistrator

    def Send(self, *args):
        """
        Send(Handle_ShapeExtend_MsgRegistrator self, Handle_Standard_Transient object, Message_Msg message, Message_Gravity const gravity)
        Send(Handle_ShapeExtend_MsgRegistrator self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity)

        Sends a message to be attached to the shape.
        If the shape is in the map then the message is added to the
        list, otherwise the shape is firstly added to the map.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_Send(self, *args)


    def MapTransient(self, *args):
        """
        Returns a Map of objects and message list

        :rtype: OCC.wrapper.ShapeExtend.ShapeExtend_DataMapOfTransientListOfMsg

        """
        res = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_MapTransient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapShape(self, *args):
        """
        Returns a Map of shapes and message list

        :rtype: OCC.wrapper.ShapeExtend.ShapeExtend_DataMapOfShapeListOfMsg

        """
        res = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_MapShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeExtend_MsgRegistrator self) -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeExtend_MsgRegistrator self)

        Memory deallocator for transient classes


        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeExtend_MsgRegistrator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeExtend_MsgRegistrator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeExtend_MsgRegistrator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeExtend_MsgRegistrator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeExtend_MsgRegistrator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeExtend_MsgRegistrator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeExtend_MsgRegistrator self)

        Increments the reference counter of this object


        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeExtend_MsgRegistrator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_DecrementRefCounter(self, *args)

Handle_ShapeExtend_MsgRegistrator_swigregister = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_swigregister
Handle_ShapeExtend_MsgRegistrator_swigregister(Handle_ShapeExtend_MsgRegistrator)

def Handle_ShapeExtend_MsgRegistrator_DownCast(thing):
    return _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_DownCast(thing)
Handle_ShapeExtend_MsgRegistrator_DownCast = _ShapeExtend.Handle_ShapeExtend_MsgRegistrator_DownCast

class Handle_ShapeExtend_BasicMsgRegistrator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeExtend_BasicMsgRegistrator self)

        Nullify the handle


        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeExtend_BasicMsgRegistrator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeExtend_BasicMsgRegistrator self, ShapeExtend_BasicMsgRegistrator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeExtend_BasicMsgRegistrator self, Handle_ShapeExtend_BasicMsgRegistrator theHandle) -> Handle_ShapeExtend_BasicMsgRegistrator
        assign(Handle_ShapeExtend_BasicMsgRegistrator self, ShapeExtend_BasicMsgRegistrator thePtr) -> Handle_ShapeExtend_BasicMsgRegistrator
        assign(Handle_ShapeExtend_BasicMsgRegistrator self, Handle_ShapeExtend_BasicMsgRegistrator theHandle) -> Handle_ShapeExtend_BasicMsgRegistrator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeExtend_BasicMsgRegistrator self) -> ShapeExtend_BasicMsgRegistrator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeExtend_BasicMsgRegistrator self) -> ShapeExtend_BasicMsgRegistrator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeExtend_BasicMsgRegistrator self) -> ShapeExtend_BasicMsgRegistrator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator___ref__(self, *args)


    def __hash__(self):
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeExtend.new_Handle_ShapeExtend_BasicMsgRegistrator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_DownCast)
    __swig_destroy__ = _ShapeExtend.delete_Handle_ShapeExtend_BasicMsgRegistrator

    def Send(self, *args):
        """
        Send(Handle_ShapeExtend_BasicMsgRegistrator self, Handle_Standard_Transient object, Message_Msg message, Message_Gravity const gravity)
        Send(Handle_ShapeExtend_BasicMsgRegistrator self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity)
        Send(Handle_ShapeExtend_BasicMsgRegistrator self, Message_Msg message, Message_Gravity const gravity)

        Calls Send method with Null Transient.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_Send(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeExtend_BasicMsgRegistrator self) -> char const *

        :rtype: const char *

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeExtend_BasicMsgRegistrator self)

        Memory deallocator for transient classes


        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeExtend_BasicMsgRegistrator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeExtend_BasicMsgRegistrator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeExtend_BasicMsgRegistrator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeExtend_BasicMsgRegistrator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeExtend_BasicMsgRegistrator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeExtend_BasicMsgRegistrator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeExtend_BasicMsgRegistrator self)

        Increments the reference counter of this object


        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeExtend_BasicMsgRegistrator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_DecrementRefCounter(self, *args)

Handle_ShapeExtend_BasicMsgRegistrator_swigregister = _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_swigregister
Handle_ShapeExtend_BasicMsgRegistrator_swigregister(Handle_ShapeExtend_BasicMsgRegistrator)

def Handle_ShapeExtend_BasicMsgRegistrator_DownCast(thing):
    return _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_DownCast(thing)
Handle_ShapeExtend_BasicMsgRegistrator_DownCast = _ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator_DownCast


try:
	Message_ListOfMsg = Message.NCollection_List_Message_Msg
except AttributeError:
	pass # does not exist, probably ignored




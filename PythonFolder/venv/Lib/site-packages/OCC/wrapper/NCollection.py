# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_NCollection')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_NCollection')
    _NCollection = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_NCollection', [dirname(__file__)])
        except ImportError:
            import _NCollection
            return _NCollection
        try:
            _mod = imp.load_module('_NCollection', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _NCollection = swig_import_helper()
    del swig_import_helper
else:
    import _NCollection
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NCollection.delete_SwigPyIterator

    def value(self):
        return _NCollection.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _NCollection.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _NCollection.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _NCollection.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _NCollection.SwigPyIterator_equal(self, x)

    def copy(self):
        return _NCollection.SwigPyIterator_copy(self)

    def next(self):
        return _NCollection.SwigPyIterator_next(self)

    def __next__(self):
        return _NCollection.SwigPyIterator___next__(self)

    def previous(self):
        return _NCollection.SwigPyIterator_previous(self)

    def advance(self, n):
        return _NCollection.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _NCollection.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _NCollection.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _NCollection.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _NCollection.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _NCollection.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _NCollection.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _NCollection.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _NCollection.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_NCollection.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _NCollection.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _NCollection.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _NCollection.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _NCollection.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _NCollection.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _NCollection.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _NCollection.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_NCollection.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _NCollection.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _NCollection.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _NCollection.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _NCollection.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _NCollection.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _NCollection.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _NCollection.ptr_to_number(item)
ptr_to_number = _NCollection.ptr_to_number

def HashCode(*args):
    return _NCollection.HashCode(*args)
HashCode = _NCollection.HashCode

def ptr_equal(a, b):
    return _NCollection.ptr_equal(a, b)
ptr_equal = _NCollection.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
CellFilter_Keep = _NCollection.CellFilter_Keep
CellFilter_Purge = _NCollection.CellFilter_Purge
class NCollection_BaseMap(object):
    """
    Purpose:     This is a base class for all Maps:
    Map
    DataMap
    DoubleMap
    IndexedMap
    IndexedDataMap
    Provides utilitites for managing the buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbBuckets(self, *args):
        """
        NbBuckets(NCollection_BaseMap self) -> Standard_Integer

        NbBuckets

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_BaseMap_NbBuckets(self, *args)


    def Extent(self, *args):
        """
        Extent(NCollection_BaseMap self) -> Standard_Integer

        Extent

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_BaseMap_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_BaseMap self) -> Standard_Boolean

        IsEmpty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.NCollection_BaseMap_IsEmpty(self, *args)


    def Statistics(self, *args):
        """
        Statistics(NCollection_BaseMap self, Standard_OStream & S)

        Statistics

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _NCollection.NCollection_BaseMap_Statistics(self, *args)


    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.NCollection_BaseMap_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_BaseMap_swigregister = _NCollection.NCollection_BaseMap_swigregister
NCollection_BaseMap_swigregister(NCollection_BaseMap)

class NCollection_BaseAllocator(Standard.Standard_Transient):
    """
    Purpose:     Basic class for memory allocation wizards.
    Defines  the  interface  for devising  different  allocators
    firstly to be used  by collections of NCollection, though it
    it is not  deferred. It allocates/frees  the memory  through
    Standard procedures, thus it is  unnecessary (and  sometimes
    injurious) to have  more than one such  allocator.  To avoid
    creation  of multiple  objects the  constructors  were  maid
    inaccessible.  To  create the  BaseAllocator use  the method
    CommonBaseAllocator.
    Note that this object is managed by Handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_BaseAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_BaseAllocator(self) 
            return h


    def Allocate(self, *args):
        """
        Allocate(NCollection_BaseAllocator self, size_t const size) -> void *

        :type size: size_t
        :rtype: void *

        """
        return _NCollection.NCollection_BaseAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_BaseAllocator self, void * anAddress)

        :type anAddress: void *

        """
        return _NCollection.NCollection_BaseAllocator_Free(self, *args)


    def CommonBaseAllocator(*args):
        """
        CommonBaseAllocator() -> Handle_NCollection_BaseAllocator

        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _NCollection.NCollection_BaseAllocator_CommonBaseAllocator(*args)

    CommonBaseAllocator = staticmethod(CommonBaseAllocator)

    def StandardCallBack(*args):
        """
        StandardCallBack(Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.NCollection_BaseAllocator_StandardCallBack(*args)

    StandardCallBack = staticmethod(StandardCallBack)

    def PrintMemUsageStatistics(*args):
        """
        PrintMemUsageStatistics()

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.NCollection_BaseAllocator_PrintMemUsageStatistics(*args)

    PrintMemUsageStatistics = staticmethod(PrintMemUsageStatistics)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_BaseAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_BaseAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_BaseAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_BaseAllocator
NCollection_BaseAllocator_swigregister = _NCollection.NCollection_BaseAllocator_swigregister
NCollection_BaseAllocator_swigregister(NCollection_BaseAllocator)

def NCollection_BaseAllocator_CommonBaseAllocator(*args):
    """
    NCollection_BaseAllocator_CommonBaseAllocator() -> Handle_NCollection_BaseAllocator

    CommonBaseAllocator
    This method is designed to have the only one BaseAllocator (to avoid
    useless copying of collections). However one can use operator new to
    create more BaseAllocators, but it is injurious.

    :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _NCollection.NCollection_BaseAllocator_CommonBaseAllocator(*args)

def NCollection_BaseAllocator_StandardCallBack(*args):
    """
    NCollection_BaseAllocator_StandardCallBack(Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

    Callback function to register alloc/free calls

    :type theIsAlloc: bool
    :type theStorage: OCC.wrapper.Standard.Standard_Address
    :type theRoundSize: int
    :type theSize: int

    """
    return _NCollection.NCollection_BaseAllocator_StandardCallBack(*args)

def NCollection_BaseAllocator_PrintMemUsageStatistics(*args):
    """
    NCollection_BaseAllocator_PrintMemUsageStatistics()

    Prints memory usage statistics cumulated by StandardCallBack


    """
    return _NCollection.NCollection_BaseAllocator_PrintMemUsageStatistics(*args)

def NCollection_BaseAllocator_get_type_name(*args):
    """
    NCollection_BaseAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_BaseAllocator_get_type_name(*args)

def NCollection_BaseAllocator_get_type_descriptor(*args):
    """
    NCollection_BaseAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_BaseAllocator_get_type_descriptor(*args)

class NCollection_IncAllocator(NCollection_BaseAllocator):
    """
    Class NCollection_IncAllocator - incremental memory  allocator. This class
    allocates  memory  on  request  returning  the  pointer  to  an  allocated
    block. This memory is never returned  to the system until the allocator is
    destroyed.

    By comparison with  the standard new() and malloc()  calls, this method is
    faster and consumes very small additional memory to maintain the heap.

    All pointers  returned by Allocate() are  aligned to the size  of the data
    type "aligned_t". To  modify the size of memory  blocks requested from the
    OS,  use the parameter  of the  constructor (measured  in bytes);  if this
    parameter is  smaller than  25 bytes on  32bit or  49 bytes on  64bit, the
    block size will be the default 24 kbytes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_IncAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_IncAllocator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(NCollection_IncAllocator self, size_t const theBlockSize) -> NCollection_IncAllocator

        Constructor

        :type theBlockSize: size_t

        """
        this = _NCollection.new_NCollection_IncAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Allocate(self, *args):
        """
        Allocate(NCollection_IncAllocator self, size_t const size) -> void *

        Allocate memory with given size. Returns NULL on failure

        :type size: size_t
        :rtype: void *

        """
        return _NCollection.NCollection_IncAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_IncAllocator self, void * anAddress)

        Free a previously allocated memory. Does nothing

        :type anAddress: void *

        """
        return _NCollection.NCollection_IncAllocator_Free(self, *args)


    def GetMemSize(self, *args):
        """
        GetMemSize(NCollection_IncAllocator self) -> size_t

        Diagnostic method, returns the total allocated size

        :rtype: size_t

        """
        return _NCollection.NCollection_IncAllocator_GetMemSize(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(NCollection_IncAllocator self, void * anAddress, size_t const oldSize, size_t const newSize) -> void *

        Reallocation: it is always allowed but is only efficient with the
        last allocated item

        :type anAddress: void *
        :type oldSize: size_t
        :type newSize: size_t
        :rtype: void *

        """
        return _NCollection.NCollection_IncAllocator_Reallocate(self, *args)


    def Reset(self, *args):
        """
        Reset(NCollection_IncAllocator self, Standard_Boolean const doReleaseMem)

        Re-initialize the allocator so that the next Allocate call should
        start allocating in the very begining as though the allocator is just
        constructed. Warning: make sure that all previously allocated data are
        no more used in your code!
        @param doReleaseMem
        True - release all previously allocated memory, False - preserve it
        for future allocations.

        :type doReleaseMem: bool

        """
        return _NCollection.NCollection_IncAllocator_Reset(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_IncAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_IncAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_IncAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_IncAllocator
NCollection_IncAllocator_swigregister = _NCollection.NCollection_IncAllocator_swigregister
NCollection_IncAllocator_swigregister(NCollection_IncAllocator)

def NCollection_IncAllocator_get_type_name(*args):
    """
    NCollection_IncAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_IncAllocator_get_type_name(*args)

def NCollection_IncAllocator_get_type_descriptor(*args):
    """
    NCollection_IncAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_IncAllocator_get_type_descriptor(*args)

class NCollection_AlignedAllocator(NCollection_BaseAllocator):
    """NCollection allocator with managed memory alignment capabilities."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_AlignedAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_AlignedAllocator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(NCollection_AlignedAllocator self, size_t const theAlignment) -> NCollection_AlignedAllocator

        Constructor. The alignment should be specified explicitly:
        16 bytes for SSE instructions
        32 bytes for AVX instructions

        :type theAlignment: size_t

        """
        this = _NCollection.new_NCollection_AlignedAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Allocate(self, *args):
        """
        Allocate(NCollection_AlignedAllocator self, size_t const theSize) -> void *

        Allocate memory with given size. Returns NULL on failure.

        :type theSize: size_t
        :rtype: void *

        """
        return _NCollection.NCollection_AlignedAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_AlignedAllocator self, void * thePtr)

        Free a previously allocated memory.

        :type thePtr: void *

        """
        return _NCollection.NCollection_AlignedAllocator_Free(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_AlignedAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_AlignedAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_AlignedAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_AlignedAllocator
NCollection_AlignedAllocator_swigregister = _NCollection.NCollection_AlignedAllocator_swigregister
NCollection_AlignedAllocator_swigregister(NCollection_AlignedAllocator)

def NCollection_AlignedAllocator_get_type_name(*args):
    """
    NCollection_AlignedAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_AlignedAllocator_get_type_name(*args)

def NCollection_AlignedAllocator_get_type_descriptor(*args):
    """
    NCollection_AlignedAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_AlignedAllocator_get_type_descriptor(*args)

class NCollection_BaseSequence(object):
    """
    Purpose:     This  is  a base  class  for  the  Sequence.  It  deals with
    an indexed bidirectional list of NCollection_SeqNode's.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_BaseSequence self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.NCollection_BaseSequence_IsEmpty(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_BaseSequence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_BaseSequence_Length(self, *args)


    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.NCollection_BaseSequence_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_BaseSequence_swigregister = _NCollection.NCollection_BaseSequence_swigregister
NCollection_BaseSequence_swigregister(NCollection_BaseSequence)

class NCollection_BaseList(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Extent(self, *args):
        """
        Extent(NCollection_BaseList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_BaseList_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_BaseList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.NCollection_BaseList_IsEmpty(self, *args)


    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.NCollection_BaseList_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_BaseList
NCollection_BaseList_swigregister = _NCollection.NCollection_BaseList_swigregister
NCollection_BaseList_swigregister(NCollection_BaseList)

class NCollection_ListNode(object):
    """
    Purpose:     This class is used to  represent a node  in the BaseList and
    BaseMap. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Next(self, *args):
        """
        Next(NCollection_ListNode self) -> NCollection_ListNode
        Next(NCollection_ListNode self) -> NCollection_ListNode

        Next pointer const access

        :rtype: OCC.wrapper.NCollection.NCollection_ListNode

        """
        return _NCollection.NCollection_ListNode_Next(self, *args)

NCollection_ListNode_swigregister = _NCollection.NCollection_ListNode_swigregister
NCollection_ListNode_swigregister(NCollection_ListNode)

class NCollection_WinHeapAllocator(NCollection_BaseAllocator):
    """
    This memory allocator creates dedicated heap for allocations.
    This technics available only on Windows platform
    (no alternative on Unix systems).
    It may be used to take control over memory fragmentation
    because on destruction ALL allocated memory will be released
    to the system.

    This allocator can also be created per each working thread
    hovewer it real multi-threading performance is dubious.

    Notice that this also means that existing pointers will be broken
    and you shoould control that allocator is alive along all objects
    allocated with him.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_WinHeapAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_WinHeapAllocator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(NCollection_WinHeapAllocator self, size_t const theInitSizeBytes=0x80000) -> NCollection_WinHeapAllocator

        Main constructor

        :type theInitSizeBytes: size_t

        """
        this = _NCollection.new_NCollection_WinHeapAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Allocate(self, *args):
        """
        Allocate(NCollection_WinHeapAllocator self, Standard_Size const theSize) -> void *

        Allocate memory

        :type theSize: int
        :rtype: void *

        """
        return _NCollection.NCollection_WinHeapAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_WinHeapAllocator self, void * theAddress)

        Release memory

        :type theAddress: void *

        """
        return _NCollection.NCollection_WinHeapAllocator_Free(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_WinHeapAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_WinHeapAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_WinHeapAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_WinHeapAllocator
NCollection_WinHeapAllocator_swigregister = _NCollection.NCollection_WinHeapAllocator_swigregister
NCollection_WinHeapAllocator_swigregister(NCollection_WinHeapAllocator)

def NCollection_WinHeapAllocator_get_type_name(*args):
    """
    NCollection_WinHeapAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_WinHeapAllocator_get_type_name(*args)

def NCollection_WinHeapAllocator_get_type_descriptor(*args):
    """
    NCollection_WinHeapAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_WinHeapAllocator_get_type_descriptor(*args)

class NCollection_Buffer(Standard.Standard_Transient):
    """Low-level buffer object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_Buffer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_Buffer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(NCollection_Buffer self, Handle_NCollection_BaseAllocator theAlloc, Standard_Size const theSize=0, Standard_Byte * theData=None) -> NCollection_Buffer

        Default constructor.
        When theData is NULL but theSize is not 0 than buffer of specified size will be allocated.
        @param theAlloc memory allocator
        @param theSize  buffer size
        @param theData  buffer data allocated by theAlloc

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :type theSize: int
        :type theData: int

        """
        this = _NCollection.new_NCollection_Buffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Data(self, *args):
        """
        Data(NCollection_Buffer self) -> Standard_Byte const *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _NCollection.NCollection_Buffer_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(NCollection_Buffer self) -> Standard_Byte *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _NCollection.NCollection_Buffer_ChangeData(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Buffer self) -> bool

        @return true if buffer is not allocated

        :rtype: bool

        """
        return _NCollection.NCollection_Buffer_IsEmpty(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Buffer self) -> Standard_Size

        Return buffer length in bytes.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _NCollection.NCollection_Buffer_Size(self, *args)


    def Allocator(self, *args):
        """
        @return buffer allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.NCollection_Buffer_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAllocator(self, *args):
        """
        SetAllocator(NCollection_Buffer self, Handle_NCollection_BaseAllocator theAlloc)

        Assign new buffer allocator with de-allocation of buffer.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _NCollection.NCollection_Buffer_SetAllocator(self, *args)


    def Allocate(self, *args):
        """
        Allocate(NCollection_Buffer self, Standard_Size const theSize) -> bool

        Allocate the buffer.
        @param theSize buffer length in bytes

        :type theSize: int
        :rtype: bool

        """
        return _NCollection.NCollection_Buffer_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_Buffer self)

        De-allocate buffer.


        """
        return _NCollection.NCollection_Buffer_Free(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_Buffer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_Buffer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_Buffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_Buffer
NCollection_Buffer_swigregister = _NCollection.NCollection_Buffer_swigregister
NCollection_Buffer_swigregister(NCollection_Buffer)

def NCollection_Buffer_get_type_name(*args):
    """
    NCollection_Buffer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_Buffer_get_type_name(*args)

def NCollection_Buffer_get_type_descriptor(*args):
    """
    NCollection_Buffer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_Buffer_get_type_descriptor(*args)

class NCollection_HeapAllocator(NCollection_BaseAllocator):
    """Allocator that uses the global dynamic heap (malloc / free). """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_HeapAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_HeapAllocator(self) 
            return h


    def Allocate(self, *args):
        """
        Allocate(NCollection_HeapAllocator self, Standard_Size const theSize) -> void *

        :type theSize: int
        :rtype: void *

        """
        return _NCollection.NCollection_HeapAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_HeapAllocator self, void * anAddress)

        :type anAddress: void *

        """
        return _NCollection.NCollection_HeapAllocator_Free(self, *args)


    def GlobalHeapAllocator(*args):
        """
        GlobalHeapAllocator() -> Handle_NCollection_HeapAllocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_HeapAllocator

        """
        return _NCollection.NCollection_HeapAllocator_GlobalHeapAllocator(*args)

    GlobalHeapAllocator = staticmethod(GlobalHeapAllocator)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_HeapAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_HeapAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_HeapAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_HeapAllocator
NCollection_HeapAllocator_swigregister = _NCollection.NCollection_HeapAllocator_swigregister
NCollection_HeapAllocator_swigregister(NCollection_HeapAllocator)

def NCollection_HeapAllocator_GlobalHeapAllocator(*args):
    """
    NCollection_HeapAllocator_GlobalHeapAllocator() -> Handle_NCollection_HeapAllocator

    :rtype: OCC.wrapper.NCollection.Handle_NCollection_HeapAllocator

    """
    return _NCollection.NCollection_HeapAllocator_GlobalHeapAllocator(*args)

def NCollection_HeapAllocator_get_type_name(*args):
    """
    NCollection_HeapAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_HeapAllocator_get_type_name(*args)

def NCollection_HeapAllocator_get_type_descriptor(*args):
    """
    NCollection_HeapAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_HeapAllocator_get_type_descriptor(*args)

class NCollection_UtfString_Standard_WideChar(object):
    """
    This template class represent constant UTF-* string.
    String stored in memory continuously, always NULL-terminated
    and can be used as standard C-string using ToCString() method.

    Notice that changing the string is not allowed
    and any modifications should produce new string.

    In comments to this class, terms "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Iterator(self, *args):
        """
        Iterator(NCollection_UtfString_Standard_WideChar self) -> NCollection_UtfIterator_Standard_WideChar

        :rtype: OCC.wrapper.NCollection.NCollection_UtfIterator_Type

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_Iterator(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_UtfString_Standard_WideChar self) -> Standard_Integer

        @return the size of the buffer in bytes, excluding NULL-termination symbol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_UtfString_Standard_WideChar self) -> Standard_Integer

        @return the length of the string in Unicode symbols

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_Length(self, *args)


    def GetChar(self, *args):
        """
        GetChar(NCollection_UtfString_Standard_WideChar self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be lesser than Length()
        @return the Unicode symbol value

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_GetChar(self, *args)


    def GetCharBuffer(self, *args):
        """
        GetCharBuffer(NCollection_UtfString_Standard_WideChar self, Standard_Integer const theCharIndex) -> wchar_t const *

        Retrieve string buffer at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be less than Length()
        (first symbol of the string has index 0)
        @return the pointer to the symbol

        :type theCharIndex: int
        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_GetCharBuffer(self, *args)


    def at(self, *args):
        """
        at(NCollection_UtfString_Standard_WideChar self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_at(self, *args)


    def __init__(self, *args):
        """
        This template class represent constant UTF-* string.
        String stored in memory continuously, always NULL-terminated
        and can be used as standard C-string using ToCString() method.

        Notice that changing the string is not allowed
        and any modifications should produce new string.

        In comments to this class, terms "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfString_Standard_WideChar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FromLocale(self, *args):
        """
        FromLocale(NCollection_UtfString_Standard_WideChar self, char const * theString, Standard_Integer const theLength=-1)

        Copy from multibyte string in current system locale.
        @param theString multibyte string
        @param theLength the length limit in Unicode symbols
        The string is copied till NULL symbol or, if theLength >0, 
        till either NULL or theLength-th symbol (which comes first).

        :type theString: const char *
        :type theLength: int

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_FromLocale(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theCompare) -> bool

        Compares this string with another one.

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_IsEqual(self, *args)


    def SubString(self, *args):
        """
        SubString(NCollection_UtfString_Standard_WideChar self, Standard_Integer const theStart, Standard_Integer const theEnd) -> NCollection_UtfString_Standard_WideChar

        Returns the substring.
        @param theStart start index (inclusive) of subString
        @param theEnd   end index   (exclusive) of subString
        @return the substring

        :type theStart: int
        :type theEnd: int
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_SubString(self, *args)


    def ToCString(self, *args):
        """
        ToCString(NCollection_UtfString_Standard_WideChar self) -> wchar_t const *

        Returns NULL-terminated Unicode string.
        Should not be modifed or deleted!
        @return (const Type* ) pointer to string

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToCString(self, *args)


    def ToUtf8(self, *args):
        """
        ToUtf8(NCollection_UtfString_Standard_WideChar self) -> NCollection_UtfString_Standard_Utf8Char

        @return copy in UTF-8 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf8Char

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToUtf8(self, *args)


    def ToUtf16(self, *args):
        """
        ToUtf16(NCollection_UtfString_Standard_WideChar self) -> NCollection_UtfString_Standard_Utf16Char

        @return copy in UTF-16 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToUtf16(self, *args)


    def ToUtf32(self, *args):
        """
        ToUtf32(NCollection_UtfString_Standard_WideChar self) -> NCollection_UtfString_Standard_Utf32Char

        @return copy in UTF-32 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToUtf32(self, *args)


    def ToUtfWide(self, *args):
        """
        ToUtfWide(NCollection_UtfString_Standard_WideChar self) -> NCollection_UtfString_Standard_WideChar

        @return copy in wide format (UTF-16 on Windows and UTF-32 on Linux)

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_WideChar

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToUtfWide(self, *args)


    def ToLocale(self, *args):
        """
        ToLocale(NCollection_UtfString_Standard_WideChar self, char * theBuffer, Standard_Integer const theSizeBytes) -> bool

        Converts the string into string in the current system locale.
        @param theBuffer    output buffer
        @param theSizeBytes buffer size in bytes
        @return true on success

        :type theBuffer: char *
        :type theSizeBytes: int
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_ToLocale(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UtfString_Standard_WideChar self) -> bool

        @return true if string is empty

        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UtfString_Standard_WideChar self)

        Zero string.


        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_Clear(self, *args)


    def Assign(self, *args):
        """
        Copy from another string.

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        res = _NCollection.NCollection_UtfString_Standard_WideChar_Assign(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Swap(self, *args):
        """
        Swap(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theOther)

        Exchange the data of two strings (without reallocating memory).

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_Swap(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theOther) -> NCollection_UtfString_Standard_WideChar
        assign(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theOther) -> NCollection_UtfString_Standard_WideChar
        assign(NCollection_UtfString_Standard_WideChar self, char const * theStringUtf8) -> NCollection_UtfString_Standard_WideChar
        assign(NCollection_UtfString_Standard_WideChar self, Standard_WideChar const * theStringUtfWide) -> NCollection_UtfString_Standard_WideChar

        Copy from wchar_t UTF NULL-terminated string.

        :type theStringUtfWide: OCC.wrapper.Standard.Standard_WideChar
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar_assign(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theAppend) -> NCollection_UtfString_Standard_WideChar

        Join strings.

        :type theAppend: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar___iadd__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theCompare) -> bool

        @name compare operators

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(NCollection_UtfString_Standard_WideChar self, NCollection_UtfString_Standard_WideChar theCompare) -> bool

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_WideChar___ne__(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfString_Standard_WideChar
NCollection_UtfString_Standard_WideChar_swigregister = _NCollection.NCollection_UtfString_Standard_WideChar_swigregister
NCollection_UtfString_Standard_WideChar_swigregister(NCollection_UtfString_Standard_WideChar)


try:
	NCollection_UtfWideString = NCollection_UtfString_Standard_WideChar
except NameError:
	pass # does not exist, probably ignored

class Handle_NCollection_IncAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_IncAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_IncAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_IncAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_IncAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_IncAllocator self, NCollection_IncAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_IncAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_IncAllocator self, Handle_NCollection_IncAllocator theHandle) -> Handle_NCollection_IncAllocator
        assign(Handle_NCollection_IncAllocator self, NCollection_IncAllocator thePtr) -> Handle_NCollection_IncAllocator
        assign(Handle_NCollection_IncAllocator self, Handle_NCollection_IncAllocator theHandle) -> Handle_NCollection_IncAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_IncAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_IncAllocator self) -> NCollection_IncAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_IncAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_IncAllocator self) -> NCollection_IncAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_IncAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_IncAllocator self) -> NCollection_IncAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_IncAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_IncAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_IncAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_IncAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_IncAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_IncAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_IncAllocator self, size_t const size) -> void *

        Allocate memory with given size. Returns NULL on failure

        :type size: size_t
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_IncAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_IncAllocator self, void * anAddress)

        Free a previously allocated memory. Does nothing

        :type anAddress: void *

        """
        return _NCollection.Handle_NCollection_IncAllocator_Free(self, *args)


    def GetMemSize(self, *args):
        """
        GetMemSize(Handle_NCollection_IncAllocator self) -> size_t

        Diagnostic method, returns the total allocated size

        :rtype: size_t

        """
        return _NCollection.Handle_NCollection_IncAllocator_GetMemSize(self, *args)


    def Reallocate(self, *args):
        """
        Reallocate(Handle_NCollection_IncAllocator self, void * anAddress, size_t const oldSize, size_t const newSize) -> void *

        Reallocation: it is always allowed but is only efficient with the
        last allocated item

        :type anAddress: void *
        :type oldSize: size_t
        :type newSize: size_t
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_IncAllocator_Reallocate(self, *args)


    def Reset(self, *args):
        """
        Reset(Handle_NCollection_IncAllocator self, Standard_Boolean const doReleaseMem)

        Re-initialize the allocator so that the next Allocate call should
        start allocating in the very begining as though the allocator is just
        constructed. Warning: make sure that all previously allocated data are
        no more used in your code!
        @param doReleaseMem
        True - release all previously allocated memory, False - preserve it
        for future allocations.

        :type doReleaseMem: bool

        """
        return _NCollection.Handle_NCollection_IncAllocator_Reset(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_IncAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_IncAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_IncAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_IncAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_IncAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_IncAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_IncAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_IncAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_IncAllocator_PrintMemUsageStatistics(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_NCollection_IncAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_IncAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_IncAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_IncAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_IncAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_IncAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_IncAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_IncAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_IncAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_IncAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_IncAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_IncAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_IncAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_IncAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_IncAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_IncAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_IncAllocator_swigregister = _NCollection.Handle_NCollection_IncAllocator_swigregister
Handle_NCollection_IncAllocator_swigregister(Handle_NCollection_IncAllocator)

def Handle_NCollection_IncAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_IncAllocator_DownCast(thing)
Handle_NCollection_IncAllocator_DownCast = _NCollection.Handle_NCollection_IncAllocator_DownCast

class Handle_NCollection_BaseAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_BaseAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_BaseAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_BaseAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_BaseAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_BaseAllocator self, NCollection_BaseAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_BaseAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_BaseAllocator self, Handle_NCollection_BaseAllocator theHandle) -> Handle_NCollection_BaseAllocator
        assign(Handle_NCollection_BaseAllocator self, NCollection_BaseAllocator thePtr) -> Handle_NCollection_BaseAllocator
        assign(Handle_NCollection_BaseAllocator self, Handle_NCollection_BaseAllocator theHandle) -> Handle_NCollection_BaseAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_BaseAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_BaseAllocator self) -> NCollection_BaseAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_BaseAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_BaseAllocator self) -> NCollection_BaseAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_BaseAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_BaseAllocator self) -> NCollection_BaseAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_BaseAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_BaseAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_BaseAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_BaseAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_BaseAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_BaseAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_BaseAllocator self, size_t const size) -> void *

        :type size: size_t
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_BaseAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_BaseAllocator self, void * anAddress)

        :type anAddress: void *

        """
        return _NCollection.Handle_NCollection_BaseAllocator_Free(self, *args)


    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_BaseAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_BaseAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_BaseAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_BaseAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_BaseAllocator_PrintMemUsageStatistics(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_BaseAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_BaseAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_BaseAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_BaseAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_NCollection_BaseAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_BaseAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_BaseAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_BaseAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_BaseAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_BaseAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_BaseAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_BaseAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_BaseAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_BaseAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_BaseAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_BaseAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_BaseAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_BaseAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_BaseAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_BaseAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_BaseAllocator_swigregister = _NCollection.Handle_NCollection_BaseAllocator_swigregister
Handle_NCollection_BaseAllocator_swigregister(Handle_NCollection_BaseAllocator)

def Handle_NCollection_BaseAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_BaseAllocator_DownCast(thing)
Handle_NCollection_BaseAllocator_DownCast = _NCollection.Handle_NCollection_BaseAllocator_DownCast

class Handle_NCollection_WinHeapAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_WinHeapAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_WinHeapAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_WinHeapAllocator self, NCollection_WinHeapAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_WinHeapAllocator self, Handle_NCollection_WinHeapAllocator theHandle) -> Handle_NCollection_WinHeapAllocator
        assign(Handle_NCollection_WinHeapAllocator self, NCollection_WinHeapAllocator thePtr) -> Handle_NCollection_WinHeapAllocator
        assign(Handle_NCollection_WinHeapAllocator self, Handle_NCollection_WinHeapAllocator theHandle) -> Handle_NCollection_WinHeapAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_WinHeapAllocator self) -> NCollection_WinHeapAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_WinHeapAllocator self) -> NCollection_WinHeapAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_WinHeapAllocator self) -> NCollection_WinHeapAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_WinHeapAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_WinHeapAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_WinHeapAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_WinHeapAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_WinHeapAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_WinHeapAllocator self, Standard_Size const theSize) -> void *

        Allocate memory

        :type theSize: int
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_WinHeapAllocator self, void * theAddress)

        Release memory

        :type theAddress: void *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_Free(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_WinHeapAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_WinHeapAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_WinHeapAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_WinHeapAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_WinHeapAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_WinHeapAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_PrintMemUsageStatistics(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_NCollection_WinHeapAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_WinHeapAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_WinHeapAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_WinHeapAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_WinHeapAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_WinHeapAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_WinHeapAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_WinHeapAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_WinHeapAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_WinHeapAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_WinHeapAllocator_swigregister = _NCollection.Handle_NCollection_WinHeapAllocator_swigregister
Handle_NCollection_WinHeapAllocator_swigregister(Handle_NCollection_WinHeapAllocator)

def Handle_NCollection_WinHeapAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_WinHeapAllocator_DownCast(thing)
Handle_NCollection_WinHeapAllocator_DownCast = _NCollection.Handle_NCollection_WinHeapAllocator_DownCast

class NCollection_BaseVector(object):
    """Class NCollection_BaseVector - base for NCollection_Vector template"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self, *args):
        """
        Clear(NCollection_BaseVector self)

        Empty the vector of its objects


        """
        return _NCollection.NCollection_BaseVector_Clear(self, *args)


    def SetIncrement(self, *args):
        """
        SetIncrement(NCollection_BaseVector self, Standard_Integer const aIncrement)

        :type aIncrement: int

        """
        return _NCollection.NCollection_BaseVector_SetIncrement(self, *args)


    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.NCollection_BaseVector_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_BaseVector_swigregister = _NCollection.NCollection_BaseVector_swigregister
NCollection_BaseVector_swigregister(NCollection_BaseVector)

class Handle_NCollection_Buffer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_Buffer self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_Buffer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_Buffer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_Buffer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_Buffer self, NCollection_Buffer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_Buffer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_Buffer self, Handle_NCollection_Buffer theHandle) -> Handle_NCollection_Buffer
        assign(Handle_NCollection_Buffer self, NCollection_Buffer thePtr) -> Handle_NCollection_Buffer
        assign(Handle_NCollection_Buffer self, Handle_NCollection_Buffer theHandle) -> Handle_NCollection_Buffer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_Buffer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_Buffer self) -> NCollection_Buffer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_Buffer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_Buffer self) -> NCollection_Buffer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_Buffer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_Buffer self) -> NCollection_Buffer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_Buffer___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_Buffer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_Buffer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_Buffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_Buffer_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_Buffer

    def Data(self, *args):
        """
        Data(Handle_NCollection_Buffer self) -> Standard_Byte const *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _NCollection.Handle_NCollection_Buffer_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(Handle_NCollection_Buffer self) -> Standard_Byte *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _NCollection.Handle_NCollection_Buffer_ChangeData(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_NCollection_Buffer self) -> bool

        @return true if buffer is not allocated

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_Buffer_IsEmpty(self, *args)


    def Size(self, *args):
        """
        Size(Handle_NCollection_Buffer self) -> Standard_Size

        Return buffer length in bytes.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _NCollection.Handle_NCollection_Buffer_Size(self, *args)


    def Allocator(self, *args):
        """
        @return buffer allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_Buffer_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAllocator(self, *args):
        """
        SetAllocator(Handle_NCollection_Buffer self, Handle_NCollection_BaseAllocator theAlloc)

        Assign new buffer allocator with de-allocation of buffer.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _NCollection.Handle_NCollection_Buffer_SetAllocator(self, *args)


    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_Buffer self, Standard_Size const theSize) -> bool

        Allocate the buffer.
        @param theSize buffer length in bytes

        :type theSize: int
        :rtype: bool

        """
        return _NCollection.Handle_NCollection_Buffer_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_Buffer self)

        De-allocate buffer.


        """
        return _NCollection.Handle_NCollection_Buffer_Free(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_Buffer self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_Buffer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_Buffer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_Buffer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_NCollection_Buffer self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_Buffer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_Buffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_Buffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_Buffer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_Buffer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_Buffer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_Buffer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_Buffer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_Buffer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_Buffer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_Buffer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_Buffer self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_Buffer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_Buffer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_Buffer_DecrementRefCounter(self, *args)

Handle_NCollection_Buffer_swigregister = _NCollection.Handle_NCollection_Buffer_swigregister
Handle_NCollection_Buffer_swigregister(Handle_NCollection_Buffer)

def Handle_NCollection_Buffer_DownCast(thing):
    return _NCollection.Handle_NCollection_Buffer_DownCast(thing)
Handle_NCollection_Buffer_DownCast = _NCollection.Handle_NCollection_Buffer_DownCast

class Handle_NCollection_AlignedAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_AlignedAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_AlignedAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_AlignedAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_AlignedAllocator self, NCollection_AlignedAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_AlignedAllocator self, Handle_NCollection_AlignedAllocator theHandle) -> Handle_NCollection_AlignedAllocator
        assign(Handle_NCollection_AlignedAllocator self, NCollection_AlignedAllocator thePtr) -> Handle_NCollection_AlignedAllocator
        assign(Handle_NCollection_AlignedAllocator self, Handle_NCollection_AlignedAllocator theHandle) -> Handle_NCollection_AlignedAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_AlignedAllocator self) -> NCollection_AlignedAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_AlignedAllocator self) -> NCollection_AlignedAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_AlignedAllocator self) -> NCollection_AlignedAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_AlignedAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_AlignedAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_AlignedAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_AlignedAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_AlignedAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_AlignedAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_AlignedAllocator self, size_t const theSize) -> void *

        Allocate memory with given size. Returns NULL on failure.

        :type theSize: size_t
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_AlignedAllocator self, void * thePtr)

        Free a previously allocated memory.

        :type thePtr: void *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_Free(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_AlignedAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_AlignedAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_AlignedAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_AlignedAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_AlignedAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_AlignedAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_AlignedAllocator_PrintMemUsageStatistics(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_NCollection_AlignedAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_AlignedAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_AlignedAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_AlignedAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_AlignedAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_AlignedAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_AlignedAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_AlignedAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_AlignedAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_AlignedAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_AlignedAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_AlignedAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_AlignedAllocator_swigregister = _NCollection.Handle_NCollection_AlignedAllocator_swigregister
Handle_NCollection_AlignedAllocator_swigregister(Handle_NCollection_AlignedAllocator)

def Handle_NCollection_AlignedAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_AlignedAllocator_DownCast(thing)
Handle_NCollection_AlignedAllocator_DownCast = _NCollection.Handle_NCollection_AlignedAllocator_DownCast

class NCollection_UtfIterator_Standard_WideChar(object):
    """
    Template class for Unicode strings support.

    It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
    and convert it from one to another.
    The current value of iterator is returned as UTF-32 Unicode symbol.

    Here and below term "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, theString):
        """
        Template class for Unicode strings support.

        It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
        and convert it from one to another.
        The current value of iterator is returned as UTF-32 Unicode symbol.

        Here and below term "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfIterator_Standard_WideChar(theString)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_UtfIterator_Standard_WideChar self, wchar_t const * theString)

        Initialize iterator within specified NULL-terminated string.

        :type theString: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_Init(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfIterator_Standard_WideChar self, NCollection_UtfIterator_Standard_WideChar theRight) -> bool

        Equality operator.

        :type theRight: OCC.wrapper.NCollection.NCollection_UtfIterator
        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar___eq__(self, *args)


    def IsValid(self, *args):
        """
        IsValid(NCollection_UtfIterator_Standard_WideChar self) -> bool

        Return true if Unicode symbol is within valid range.

        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_IsValid(self, *args)


    def __ref__(self, *args):
        """
        __ref__(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Utf32Char

        Dereference operator.
        @return the UTF-32 codepoint of the symbol currently pointed by iterator.

        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar___ref__(self, *args)


    def BufferHere(self, *args):
        """
        BufferHere(NCollection_UtfIterator_Standard_WideChar self) -> wchar_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_BufferHere(self, *args)


    def ChangeBufferHere(self, *args):
        """
        ChangeBufferHere(NCollection_UtfIterator_Standard_WideChar self) -> wchar_t *

        Buffer-fetching getter. Dangerous! Iterator should be reinitialized on buffer change.

        :rtype: Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_ChangeBufferHere(self, *args)


    def BufferNext(self, *args):
        """
        BufferNext(NCollection_UtfIterator_Standard_WideChar self) -> wchar_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_BufferNext(self, *args)


    def Index(self, *args):
        """
        Index(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Integer

        @return the index displacement from iterator intialization
        (first symbol has index 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_Index(self, *args)


    def AdvanceBytesUtf8(self, *args):
        """
        AdvanceBytesUtf8(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-8.
        0 means an invalid symbol;
        1-4 bytes are valid range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_AdvanceBytesUtf8(self, *args)


    def AdvanceBytesUtf16(self, *args):
        """
        AdvanceBytesUtf16(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        2 bytes is a general case;
        4 bytes for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_AdvanceBytesUtf16(self, *args)


    def AdvanceCodeUnitsUtf16(self, *args):
        """
        AdvanceCodeUnitsUtf16(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        1 16-bit code unit is a general case;
        2 16-bit code units for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_AdvanceCodeUnitsUtf16(self, *args)


    def AdvanceBytesUtf32(self, *args):
        """
        AdvanceBytesUtf32(NCollection_UtfIterator_Standard_WideChar self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-32.
        Always 4 bytes (method for consistency).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_AdvanceBytesUtf32(self, *args)


    def GetUtf8(self, *args):
        """
        GetUtf8(NCollection_UtfIterator_Standard_WideChar self, Standard_Utf8Char * theBuffer) -> Standard_Utf8Char
        GetUtf8(NCollection_UtfIterator_Standard_WideChar self, Standard_Utf8UChar * theBuffer) -> Standard_Utf8UChar *

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf8UChar
        :rtype: OCC.wrapper.Standard.Standard_Utf8UChar

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_GetUtf8(self, *args)


    def GetUtf16(self, *args):
        """
        GetUtf16(NCollection_UtfIterator_Standard_WideChar self, Standard_Utf16Char * theBuffer) -> Standard_Utf16Char *

        Fill the UTF-16 buffer within current Unicode symbol.
        Use method AdvanceUtf16() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf16Char
        :rtype: OCC.wrapper.Standard.Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_GetUtf16(self, *args)


    def GetUtf32(self, *args):
        """
        GetUtf32(NCollection_UtfIterator_Standard_WideChar self, Standard_Utf32Char * theBuffer) -> Standard_Utf32Char *

        Fill the UTF-32 buffer within current Unicode symbol.
        Use method AdvanceUtf32() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf32Char
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_WideChar_GetUtf32(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfIterator_Standard_WideChar
NCollection_UtfIterator_Standard_WideChar_swigregister = _NCollection.NCollection_UtfIterator_Standard_WideChar_swigregister
NCollection_UtfIterator_Standard_WideChar_swigregister(NCollection_UtfIterator_Standard_WideChar)


try:
	NCollection_UtfWideIter = NCollection_UtfIterator_Standard_WideChar
except NameError:
	pass # does not exist, probably ignored

class NCollection_SparseArrayBase(object):
    """
    Base class for NCollection_SparseArray;  
    provides non-template implementation of general mechanics
    of block allocation, items creation / deletion etc.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Clear(self, *args):
        """
        Clear(NCollection_SparseArrayBase self)

        Clears all the data


        """
        return _NCollection.NCollection_SparseArrayBase_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_SparseArrayBase self) -> Standard_Size

        Returns number of currently contained items

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _NCollection.NCollection_SparseArrayBase_Size(self, *args)


    def HasValue(self, *args):
        """
        HasValue(NCollection_SparseArrayBase self, Standard_Size const theIndex) -> Standard_Boolean

        Check whether the value at given index is set

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.NCollection_SparseArrayBase_HasValue(self, *args)


    def UnsetValue(self, *args):
        """
        UnsetValue(NCollection_SparseArrayBase self, Standard_Size const theIndex) -> Standard_Boolean

        Deletes the item from the array; 
        returns True if that item was defined

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.NCollection_SparseArrayBase_UnsetValue(self, *args)

NCollection_SparseArrayBase_swigregister = _NCollection.NCollection_SparseArrayBase_swigregister
NCollection_SparseArrayBase_swigregister(NCollection_SparseArrayBase)

class NCollection_UtfString_Standard_Utf32Char(object):
    """
    This template class represent constant UTF-* string.
    String stored in memory continuously, always NULL-terminated
    and can be used as standard C-string using ToCString() method.

    Notice that changing the string is not allowed
    and any modifications should produce new string.

    In comments to this class, terms "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Iterator(self, *args):
        """
        Iterator(NCollection_UtfString_Standard_Utf32Char self) -> NCollection_UtfIterator_Standard_Utf32Char

        :rtype: OCC.wrapper.NCollection.NCollection_UtfIterator_Type

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_Iterator(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_UtfString_Standard_Utf32Char self) -> Standard_Integer

        @return the size of the buffer in bytes, excluding NULL-termination symbol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_UtfString_Standard_Utf32Char self) -> Standard_Integer

        @return the length of the string in Unicode symbols

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_Length(self, *args)


    def GetChar(self, *args):
        """
        GetChar(NCollection_UtfString_Standard_Utf32Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be lesser than Length()
        @return the Unicode symbol value

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_GetChar(self, *args)


    def GetCharBuffer(self, *args):
        """
        GetCharBuffer(NCollection_UtfString_Standard_Utf32Char self, Standard_Integer const theCharIndex) -> char32_t const *

        Retrieve string buffer at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be less than Length()
        (first symbol of the string has index 0)
        @return the pointer to the symbol

        :type theCharIndex: int
        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_GetCharBuffer(self, *args)


    def at(self, *args):
        """
        at(NCollection_UtfString_Standard_Utf32Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_at(self, *args)


    def __init__(self, *args):
        """
        This template class represent constant UTF-* string.
        String stored in memory continuously, always NULL-terminated
        and can be used as standard C-string using ToCString() method.

        Notice that changing the string is not allowed
        and any modifications should produce new string.

        In comments to this class, terms "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfString_Standard_Utf32Char(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FromLocale(self, *args):
        """
        FromLocale(NCollection_UtfString_Standard_Utf32Char self, char const * theString, Standard_Integer const theLength=-1)

        Copy from multibyte string in current system locale.
        @param theString multibyte string
        @param theLength the length limit in Unicode symbols
        The string is copied till NULL symbol or, if theLength >0, 
        till either NULL or theLength-th symbol (which comes first).

        :type theString: const char *
        :type theLength: int

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_FromLocale(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theCompare) -> bool

        Compares this string with another one.

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_IsEqual(self, *args)


    def SubString(self, *args):
        """
        SubString(NCollection_UtfString_Standard_Utf32Char self, Standard_Integer const theStart, Standard_Integer const theEnd) -> NCollection_UtfString_Standard_Utf32Char

        Returns the substring.
        @param theStart start index (inclusive) of subString
        @param theEnd   end index   (exclusive) of subString
        @return the substring

        :type theStart: int
        :type theEnd: int
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_SubString(self, *args)


    def ToCString(self, *args):
        """
        ToCString(NCollection_UtfString_Standard_Utf32Char self) -> char32_t const *

        Returns NULL-terminated Unicode string.
        Should not be modifed or deleted!
        @return (const Type* ) pointer to string

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToCString(self, *args)


    def ToUtf8(self, *args):
        """
        ToUtf8(NCollection_UtfString_Standard_Utf32Char self) -> NCollection_UtfString_Standard_Utf8Char

        @return copy in UTF-8 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf8Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToUtf8(self, *args)


    def ToUtf16(self, *args):
        """
        ToUtf16(NCollection_UtfString_Standard_Utf32Char self) -> NCollection_UtfString_Standard_Utf16Char

        @return copy in UTF-16 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToUtf16(self, *args)


    def ToUtf32(self, *args):
        """
        ToUtf32(NCollection_UtfString_Standard_Utf32Char self) -> NCollection_UtfString_Standard_Utf32Char

        @return copy in UTF-32 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToUtf32(self, *args)


    def ToUtfWide(self, *args):
        """
        ToUtfWide(NCollection_UtfString_Standard_Utf32Char self) -> NCollection_UtfString_Standard_WideChar

        @return copy in wide format (UTF-16 on Windows and UTF-32 on Linux)

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_WideChar

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToUtfWide(self, *args)


    def ToLocale(self, *args):
        """
        ToLocale(NCollection_UtfString_Standard_Utf32Char self, char * theBuffer, Standard_Integer const theSizeBytes) -> bool

        Converts the string into string in the current system locale.
        @param theBuffer    output buffer
        @param theSizeBytes buffer size in bytes
        @return true on success

        :type theBuffer: char *
        :type theSizeBytes: int
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_ToLocale(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UtfString_Standard_Utf32Char self) -> bool

        @return true if string is empty

        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UtfString_Standard_Utf32Char self)

        Zero string.


        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_Clear(self, *args)


    def Assign(self, *args):
        """
        Copy from another string.

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        res = _NCollection.NCollection_UtfString_Standard_Utf32Char_Assign(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Swap(self, *args):
        """
        Swap(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theOther)

        Exchange the data of two strings (without reallocating memory).

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_Swap(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theOther) -> NCollection_UtfString_Standard_Utf32Char
        assign(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theOther) -> NCollection_UtfString_Standard_Utf32Char
        assign(NCollection_UtfString_Standard_Utf32Char self, char const * theStringUtf8) -> NCollection_UtfString_Standard_Utf32Char
        assign(NCollection_UtfString_Standard_Utf32Char self, Standard_WideChar const * theStringUtfWide) -> NCollection_UtfString_Standard_Utf32Char

        Copy from wchar_t UTF NULL-terminated string.

        :type theStringUtfWide: OCC.wrapper.Standard.Standard_WideChar
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char_assign(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theAppend) -> NCollection_UtfString_Standard_Utf32Char

        Join strings.

        :type theAppend: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char___iadd__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theCompare) -> bool

        @name compare operators

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(NCollection_UtfString_Standard_Utf32Char self, NCollection_UtfString_Standard_Utf32Char theCompare) -> bool

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf32Char___ne__(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfString_Standard_Utf32Char
NCollection_UtfString_Standard_Utf32Char_swigregister = _NCollection.NCollection_UtfString_Standard_Utf32Char_swigregister
NCollection_UtfString_Standard_Utf32Char_swigregister(NCollection_UtfString_Standard_Utf32Char)


try:
	NCollection_Utf32String = NCollection_UtfString_Standard_Utf32Char
except NameError:
	pass # does not exist, probably ignored

class NCollection_UtfString_Standard_Utf8Char(object):
    """
    This template class represent constant UTF-* string.
    String stored in memory continuously, always NULL-terminated
    and can be used as standard C-string using ToCString() method.

    Notice that changing the string is not allowed
    and any modifications should produce new string.

    In comments to this class, terms "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Iterator(self, *args):
        """
        Iterator(NCollection_UtfString_Standard_Utf8Char self) -> NCollection_UtfIterator_Standard_Utf8Char

        :rtype: OCC.wrapper.NCollection.NCollection_UtfIterator_Type

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_Iterator(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_UtfString_Standard_Utf8Char self) -> Standard_Integer

        @return the size of the buffer in bytes, excluding NULL-termination symbol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_UtfString_Standard_Utf8Char self) -> Standard_Integer

        @return the length of the string in Unicode symbols

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_Length(self, *args)


    def GetChar(self, *args):
        """
        GetChar(NCollection_UtfString_Standard_Utf8Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be lesser than Length()
        @return the Unicode symbol value

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_GetChar(self, *args)


    def GetCharBuffer(self, *args):
        """
        GetCharBuffer(NCollection_UtfString_Standard_Utf8Char self, Standard_Integer const theCharIndex) -> char const *

        Retrieve string buffer at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be less than Length()
        (first symbol of the string has index 0)
        @return the pointer to the symbol

        :type theCharIndex: int
        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_GetCharBuffer(self, *args)


    def at(self, *args):
        """
        at(NCollection_UtfString_Standard_Utf8Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_at(self, *args)


    def __init__(self, *args):
        """
        This template class represent constant UTF-* string.
        String stored in memory continuously, always NULL-terminated
        and can be used as standard C-string using ToCString() method.

        Notice that changing the string is not allowed
        and any modifications should produce new string.

        In comments to this class, terms "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfString_Standard_Utf8Char(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FromLocale(self, *args):
        """
        FromLocale(NCollection_UtfString_Standard_Utf8Char self, char const * theString, Standard_Integer const theLength=-1)

        Copy from multibyte string in current system locale.
        @param theString multibyte string
        @param theLength the length limit in Unicode symbols
        The string is copied till NULL symbol or, if theLength >0, 
        till either NULL or theLength-th symbol (which comes first).

        :type theString: const char *
        :type theLength: int

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_FromLocale(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theCompare) -> bool

        Compares this string with another one.

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_IsEqual(self, *args)


    def SubString(self, *args):
        """
        SubString(NCollection_UtfString_Standard_Utf8Char self, Standard_Integer const theStart, Standard_Integer const theEnd) -> NCollection_UtfString_Standard_Utf8Char

        Returns the substring.
        @param theStart start index (inclusive) of subString
        @param theEnd   end index   (exclusive) of subString
        @return the substring

        :type theStart: int
        :type theEnd: int
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_SubString(self, *args)


    def ToCString(self, *args):
        """
        ToCString(NCollection_UtfString_Standard_Utf8Char self) -> char const *

        Returns NULL-terminated Unicode string.
        Should not be modifed or deleted!
        @return (const Type* ) pointer to string

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToCString(self, *args)


    def ToUtf8(self, *args):
        """
        ToUtf8(NCollection_UtfString_Standard_Utf8Char self) -> NCollection_UtfString_Standard_Utf8Char

        @return copy in UTF-8 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf8Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToUtf8(self, *args)


    def ToUtf16(self, *args):
        """
        ToUtf16(NCollection_UtfString_Standard_Utf8Char self) -> NCollection_UtfString_Standard_Utf16Char

        @return copy in UTF-16 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToUtf16(self, *args)


    def ToUtf32(self, *args):
        """
        ToUtf32(NCollection_UtfString_Standard_Utf8Char self) -> NCollection_UtfString_Standard_Utf32Char

        @return copy in UTF-32 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToUtf32(self, *args)


    def ToUtfWide(self, *args):
        """
        ToUtfWide(NCollection_UtfString_Standard_Utf8Char self) -> NCollection_UtfString_Standard_WideChar

        @return copy in wide format (UTF-16 on Windows and UTF-32 on Linux)

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_WideChar

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToUtfWide(self, *args)


    def ToLocale(self, *args):
        """
        ToLocale(NCollection_UtfString_Standard_Utf8Char self, char * theBuffer, Standard_Integer const theSizeBytes) -> bool

        Converts the string into string in the current system locale.
        @param theBuffer    output buffer
        @param theSizeBytes buffer size in bytes
        @return true on success

        :type theBuffer: char *
        :type theSizeBytes: int
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_ToLocale(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UtfString_Standard_Utf8Char self) -> bool

        @return true if string is empty

        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UtfString_Standard_Utf8Char self)

        Zero string.


        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_Clear(self, *args)


    def Assign(self, *args):
        """
        Copy from another string.

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        res = _NCollection.NCollection_UtfString_Standard_Utf8Char_Assign(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Swap(self, *args):
        """
        Swap(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theOther)

        Exchange the data of two strings (without reallocating memory).

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_Swap(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theOther) -> NCollection_UtfString_Standard_Utf8Char
        assign(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theOther) -> NCollection_UtfString_Standard_Utf8Char
        assign(NCollection_UtfString_Standard_Utf8Char self, char const * theStringUtf8) -> NCollection_UtfString_Standard_Utf8Char
        assign(NCollection_UtfString_Standard_Utf8Char self, Standard_WideChar const * theStringUtfWide) -> NCollection_UtfString_Standard_Utf8Char

        Copy from wchar_t UTF NULL-terminated string.

        :type theStringUtfWide: OCC.wrapper.Standard.Standard_WideChar
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char_assign(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theAppend) -> NCollection_UtfString_Standard_Utf8Char

        Join strings.

        :type theAppend: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char___iadd__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theCompare) -> bool

        @name compare operators

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(NCollection_UtfString_Standard_Utf8Char self, NCollection_UtfString_Standard_Utf8Char theCompare) -> bool

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf8Char___ne__(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfString_Standard_Utf8Char
NCollection_UtfString_Standard_Utf8Char_swigregister = _NCollection.NCollection_UtfString_Standard_Utf8Char_swigregister
NCollection_UtfString_Standard_Utf8Char_swigregister(NCollection_UtfString_Standard_Utf8Char)


try:
	NCollection_Utf8String = NCollection_UtfString_Standard_Utf8Char
except NameError:
	pass # does not exist, probably ignored

class NCollection_AccAllocator(NCollection_BaseAllocator):
    """
    Class  NCollection_AccAllocator  -  accumulating  memory  allocator.  This
    class  allocates  memory on request returning the pointer to the allocated
    space.  The  allocation  units  are  grouped  in blocks requested from the
    system  as  required.  This  memory  is  returned  to  the system when all
    allocations in a block are freed.

    By comparison with  the standard new() and malloc()  calls, this method is
    faster and consumes very small additional memory to maintain the heap.

    By comparison with NCollection_IncAllocator,  this class requires some more
    additional memory  and a little more time for allocation and deallocation.
    Memory overhead for NCollection_IncAllocator is 12 bytes per block;
    average memory overhead for NCollection_AccAllocator is 28 bytes per block.

    All pointers  returned by Allocate() are aligned to 4 byte boundaries.
    To  define  the size  of  memory  blocks  requested  from the OS,  use the
    parameter of the constructor (measured in bytes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_NCollection_AccAllocator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_NCollection_AccAllocator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(NCollection_AccAllocator self, size_t const theBlockSize) -> NCollection_AccAllocator

        Constructor

        :type theBlockSize: size_t

        """
        this = _NCollection.new_NCollection_AccAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Allocate(self, *args):
        """
        Allocate(NCollection_AccAllocator self, size_t const theSize) -> void *

        Allocate memory with given size

        :type theSize: size_t
        :rtype: void *

        """
        return _NCollection.NCollection_AccAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(NCollection_AccAllocator self, void * theAddress)

        Free a previously allocated memory;
        memory is returned to the OS when all allocations in some block are freed

        :type theAddress: void *

        """
        return _NCollection.NCollection_AccAllocator_Free(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _NCollection.NCollection_AccAllocator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _NCollection.NCollection_AccAllocator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.NCollection_AccAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _NCollection.delete_NCollection_AccAllocator
NCollection_AccAllocator_swigregister = _NCollection.NCollection_AccAllocator_swigregister
NCollection_AccAllocator_swigregister(NCollection_AccAllocator)

def NCollection_AccAllocator_get_type_name(*args):
    """
    NCollection_AccAllocator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _NCollection.NCollection_AccAllocator_get_type_name(*args)

def NCollection_AccAllocator_get_type_descriptor(*args):
    """
    NCollection_AccAllocator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _NCollection.NCollection_AccAllocator_get_type_descriptor(*args)

class NCollection_UtfIterator_Standard_Utf8Char(object):
    """
    Template class for Unicode strings support.

    It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
    and convert it from one to another.
    The current value of iterator is returned as UTF-32 Unicode symbol.

    Here and below term "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, theString):
        """
        Template class for Unicode strings support.

        It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
        and convert it from one to another.
        The current value of iterator is returned as UTF-32 Unicode symbol.

        Here and below term "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfIterator_Standard_Utf8Char(theString)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_UtfIterator_Standard_Utf8Char self, char const * theString)

        Initialize iterator within specified NULL-terminated string.

        :type theString: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_Init(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfIterator_Standard_Utf8Char self, NCollection_UtfIterator_Standard_Utf8Char theRight) -> bool

        Equality operator.

        :type theRight: OCC.wrapper.NCollection.NCollection_UtfIterator
        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char___eq__(self, *args)


    def IsValid(self, *args):
        """
        IsValid(NCollection_UtfIterator_Standard_Utf8Char self) -> bool

        Return true if Unicode symbol is within valid range.

        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_IsValid(self, *args)


    def __ref__(self, *args):
        """
        __ref__(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Utf32Char

        Dereference operator.
        @return the UTF-32 codepoint of the symbol currently pointed by iterator.

        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char___ref__(self, *args)


    def BufferHere(self, *args):
        """
        BufferHere(NCollection_UtfIterator_Standard_Utf8Char self) -> char const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_BufferHere(self, *args)


    def ChangeBufferHere(self, *args):
        """
        ChangeBufferHere(NCollection_UtfIterator_Standard_Utf8Char self) -> char *

        Buffer-fetching getter. Dangerous! Iterator should be reinitialized on buffer change.

        :rtype: Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_ChangeBufferHere(self, *args)


    def BufferNext(self, *args):
        """
        BufferNext(NCollection_UtfIterator_Standard_Utf8Char self) -> char const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_BufferNext(self, *args)


    def Index(self, *args):
        """
        Index(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Integer

        @return the index displacement from iterator intialization
        (first symbol has index 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_Index(self, *args)


    def AdvanceBytesUtf8(self, *args):
        """
        AdvanceBytesUtf8(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-8.
        0 means an invalid symbol;
        1-4 bytes are valid range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_AdvanceBytesUtf8(self, *args)


    def AdvanceBytesUtf16(self, *args):
        """
        AdvanceBytesUtf16(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        2 bytes is a general case;
        4 bytes for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_AdvanceBytesUtf16(self, *args)


    def AdvanceCodeUnitsUtf16(self, *args):
        """
        AdvanceCodeUnitsUtf16(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        1 16-bit code unit is a general case;
        2 16-bit code units for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_AdvanceCodeUnitsUtf16(self, *args)


    def AdvanceBytesUtf32(self, *args):
        """
        AdvanceBytesUtf32(NCollection_UtfIterator_Standard_Utf8Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-32.
        Always 4 bytes (method for consistency).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_AdvanceBytesUtf32(self, *args)


    def GetUtf8(self, *args):
        """
        GetUtf8(NCollection_UtfIterator_Standard_Utf8Char self, Standard_Utf8Char * theBuffer) -> Standard_Utf8Char
        GetUtf8(NCollection_UtfIterator_Standard_Utf8Char self, Standard_Utf8UChar * theBuffer) -> Standard_Utf8UChar *

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf8UChar
        :rtype: OCC.wrapper.Standard.Standard_Utf8UChar

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_GetUtf8(self, *args)


    def GetUtf16(self, *args):
        """
        GetUtf16(NCollection_UtfIterator_Standard_Utf8Char self, Standard_Utf16Char * theBuffer) -> Standard_Utf16Char *

        Fill the UTF-16 buffer within current Unicode symbol.
        Use method AdvanceUtf16() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf16Char
        :rtype: OCC.wrapper.Standard.Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_GetUtf16(self, *args)


    def GetUtf32(self, *args):
        """
        GetUtf32(NCollection_UtfIterator_Standard_Utf8Char self, Standard_Utf32Char * theBuffer) -> Standard_Utf32Char *

        Fill the UTF-32 buffer within current Unicode symbol.
        Use method AdvanceUtf32() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf32Char
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf8Char_GetUtf32(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfIterator_Standard_Utf8Char
NCollection_UtfIterator_Standard_Utf8Char_swigregister = _NCollection.NCollection_UtfIterator_Standard_Utf8Char_swigregister
NCollection_UtfIterator_Standard_Utf8Char_swigregister(NCollection_UtfIterator_Standard_Utf8Char)


try:
	NCollection_Utf8Iter = NCollection_UtfIterator_Standard_Utf8Char
except NameError:
	pass # does not exist, probably ignored

class Handle_NCollection_HeapAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_HeapAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_HeapAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_HeapAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_HeapAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_HeapAllocator self, NCollection_HeapAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_HeapAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_HeapAllocator self, Handle_NCollection_HeapAllocator theHandle) -> Handle_NCollection_HeapAllocator
        assign(Handle_NCollection_HeapAllocator self, NCollection_HeapAllocator thePtr) -> Handle_NCollection_HeapAllocator
        assign(Handle_NCollection_HeapAllocator self, Handle_NCollection_HeapAllocator theHandle) -> Handle_NCollection_HeapAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_HeapAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_HeapAllocator self) -> NCollection_HeapAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_HeapAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_HeapAllocator self) -> NCollection_HeapAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_HeapAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_HeapAllocator self) -> NCollection_HeapAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_HeapAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_HeapAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_HeapAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_HeapAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_HeapAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_HeapAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_HeapAllocator self, Standard_Size const theSize) -> void *

        :type theSize: int
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_HeapAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_HeapAllocator self, void * anAddress)

        :type anAddress: void *

        """
        return _NCollection.Handle_NCollection_HeapAllocator_Free(self, *args)


    def GlobalHeapAllocator(self, *args):
        """
        :rtype: OCC.wrapper.NCollection.Handle_NCollection_HeapAllocator

        """
        res = _NCollection.Handle_NCollection_HeapAllocator_GlobalHeapAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_HeapAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_HeapAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_HeapAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_HeapAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_HeapAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_HeapAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_HeapAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_HeapAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_HeapAllocator_PrintMemUsageStatistics(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_NCollection_HeapAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_HeapAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_HeapAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_HeapAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_HeapAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_HeapAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_HeapAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_HeapAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_HeapAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_HeapAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_HeapAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_HeapAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_HeapAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_HeapAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_HeapAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_HeapAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_HeapAllocator_swigregister = _NCollection.Handle_NCollection_HeapAllocator_swigregister
Handle_NCollection_HeapAllocator_swigregister(Handle_NCollection_HeapAllocator)

def Handle_NCollection_HeapAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_HeapAllocator_DownCast(thing)
Handle_NCollection_HeapAllocator_DownCast = _NCollection.Handle_NCollection_HeapAllocator_DownCast

class NCollection_UtfIterator_Standard_Utf16Char(object):
    """
    Template class for Unicode strings support.

    It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
    and convert it from one to another.
    The current value of iterator is returned as UTF-32 Unicode symbol.

    Here and below term "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, theString):
        """
        Template class for Unicode strings support.

        It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
        and convert it from one to another.
        The current value of iterator is returned as UTF-32 Unicode symbol.

        Here and below term "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfIterator_Standard_Utf16Char(theString)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_UtfIterator_Standard_Utf16Char self, char16_t const * theString)

        Initialize iterator within specified NULL-terminated string.

        :type theString: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_Init(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfIterator_Standard_Utf16Char self, NCollection_UtfIterator_Standard_Utf16Char theRight) -> bool

        Equality operator.

        :type theRight: OCC.wrapper.NCollection.NCollection_UtfIterator
        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char___eq__(self, *args)


    def IsValid(self, *args):
        """
        IsValid(NCollection_UtfIterator_Standard_Utf16Char self) -> bool

        Return true if Unicode symbol is within valid range.

        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_IsValid(self, *args)


    def __ref__(self, *args):
        """
        __ref__(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Utf32Char

        Dereference operator.
        @return the UTF-32 codepoint of the symbol currently pointed by iterator.

        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char___ref__(self, *args)


    def BufferHere(self, *args):
        """
        BufferHere(NCollection_UtfIterator_Standard_Utf16Char self) -> char16_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_BufferHere(self, *args)


    def ChangeBufferHere(self, *args):
        """
        ChangeBufferHere(NCollection_UtfIterator_Standard_Utf16Char self) -> char16_t *

        Buffer-fetching getter. Dangerous! Iterator should be reinitialized on buffer change.

        :rtype: Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_ChangeBufferHere(self, *args)


    def BufferNext(self, *args):
        """
        BufferNext(NCollection_UtfIterator_Standard_Utf16Char self) -> char16_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_BufferNext(self, *args)


    def Index(self, *args):
        """
        Index(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Integer

        @return the index displacement from iterator intialization
        (first symbol has index 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_Index(self, *args)


    def AdvanceBytesUtf8(self, *args):
        """
        AdvanceBytesUtf8(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-8.
        0 means an invalid symbol;
        1-4 bytes are valid range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_AdvanceBytesUtf8(self, *args)


    def AdvanceBytesUtf16(self, *args):
        """
        AdvanceBytesUtf16(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        2 bytes is a general case;
        4 bytes for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_AdvanceBytesUtf16(self, *args)


    def AdvanceCodeUnitsUtf16(self, *args):
        """
        AdvanceCodeUnitsUtf16(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        1 16-bit code unit is a general case;
        2 16-bit code units for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_AdvanceCodeUnitsUtf16(self, *args)


    def AdvanceBytesUtf32(self, *args):
        """
        AdvanceBytesUtf32(NCollection_UtfIterator_Standard_Utf16Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-32.
        Always 4 bytes (method for consistency).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_AdvanceBytesUtf32(self, *args)


    def GetUtf8(self, *args):
        """
        GetUtf8(NCollection_UtfIterator_Standard_Utf16Char self, Standard_Utf8Char * theBuffer) -> Standard_Utf8Char
        GetUtf8(NCollection_UtfIterator_Standard_Utf16Char self, Standard_Utf8UChar * theBuffer) -> Standard_Utf8UChar *

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf8UChar
        :rtype: OCC.wrapper.Standard.Standard_Utf8UChar

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_GetUtf8(self, *args)


    def GetUtf16(self, *args):
        """
        GetUtf16(NCollection_UtfIterator_Standard_Utf16Char self, Standard_Utf16Char * theBuffer) -> Standard_Utf16Char *

        Fill the UTF-16 buffer within current Unicode symbol.
        Use method AdvanceUtf16() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf16Char
        :rtype: OCC.wrapper.Standard.Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_GetUtf16(self, *args)


    def GetUtf32(self, *args):
        """
        GetUtf32(NCollection_UtfIterator_Standard_Utf16Char self, Standard_Utf32Char * theBuffer) -> Standard_Utf32Char *

        Fill the UTF-32 buffer within current Unicode symbol.
        Use method AdvanceUtf32() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf32Char
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf16Char_GetUtf32(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfIterator_Standard_Utf16Char
NCollection_UtfIterator_Standard_Utf16Char_swigregister = _NCollection.NCollection_UtfIterator_Standard_Utf16Char_swigregister
NCollection_UtfIterator_Standard_Utf16Char_swigregister(NCollection_UtfIterator_Standard_Utf16Char)


try:
	NCollection_Utf16Iter = NCollection_UtfIterator_Standard_Utf16Char
except NameError:
	pass # does not exist, probably ignored

class NCollection_SeqNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Next(self, *args):
        """
        Next(NCollection_SeqNode self) -> NCollection_SeqNode

        :rtype: OCC.wrapper.NCollection.NCollection_SeqNode

        """
        return _NCollection.NCollection_SeqNode_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(NCollection_SeqNode self) -> NCollection_SeqNode

        :rtype: OCC.wrapper.NCollection.NCollection_SeqNode

        """
        return _NCollection.NCollection_SeqNode_Previous(self, *args)


    def SetNext(self, *args):
        """
        SetNext(NCollection_SeqNode self, NCollection_SeqNode theNext)

        :type theNext: OCC.wrapper.NCollection.NCollection_SeqNode

        """
        return _NCollection.NCollection_SeqNode_SetNext(self, *args)


    def SetPrevious(self, *args):
        """
        SetPrevious(NCollection_SeqNode self, NCollection_SeqNode thePrev)

        :type thePrev: OCC.wrapper.NCollection.NCollection_SeqNode

        """
        return _NCollection.NCollection_SeqNode_SetPrevious(self, *args)

NCollection_SeqNode_swigregister = _NCollection.NCollection_SeqNode_swigregister
NCollection_SeqNode_swigregister(NCollection_SeqNode)

class Handle_NCollection_AccAllocator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_NCollection_AccAllocator self)

        Nullify the handle


        """
        return _NCollection.Handle_NCollection_AccAllocator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_NCollection_AccAllocator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _NCollection.Handle_NCollection_AccAllocator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_NCollection_AccAllocator self, NCollection_AccAllocator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _NCollection.Handle_NCollection_AccAllocator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_NCollection_AccAllocator self, Handle_NCollection_AccAllocator theHandle) -> Handle_NCollection_AccAllocator
        assign(Handle_NCollection_AccAllocator self, NCollection_AccAllocator thePtr) -> Handle_NCollection_AccAllocator
        assign(Handle_NCollection_AccAllocator self, Handle_NCollection_AccAllocator theHandle) -> Handle_NCollection_AccAllocator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _NCollection.Handle_NCollection_AccAllocator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_NCollection_AccAllocator self) -> NCollection_AccAllocator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_AccAllocator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_NCollection_AccAllocator self) -> NCollection_AccAllocator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _NCollection.Handle_NCollection_AccAllocator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_NCollection_AccAllocator self) -> NCollection_AccAllocator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _NCollection.Handle_NCollection_AccAllocator___ref__(self, *args)


    def __hash__(self):
        return _NCollection.Handle_NCollection_AccAllocator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _NCollection.Handle_NCollection_AccAllocator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _NCollection.new_Handle_NCollection_AccAllocator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_NCollection.Handle_NCollection_AccAllocator_DownCast)
    __swig_destroy__ = _NCollection.delete_Handle_NCollection_AccAllocator

    def Allocate(self, *args):
        """
        Allocate(Handle_NCollection_AccAllocator self, size_t const theSize) -> void *

        Allocate memory with given size

        :type theSize: size_t
        :rtype: void *

        """
        return _NCollection.Handle_NCollection_AccAllocator_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_NCollection_AccAllocator self, void * theAddress)

        Free a previously allocated memory;
        memory is returned to the OS when all allocations in some block are freed

        :type theAddress: void *

        """
        return _NCollection.Handle_NCollection_AccAllocator_Free(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_NCollection_AccAllocator self) -> char const *

        :rtype: const char *

        """
        return _NCollection.Handle_NCollection_AccAllocator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_AccAllocator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _NCollection.Handle_NCollection_AccAllocator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CommonBaseAllocator(self, *args):
        """
        CommonBaseAllocator
        This method is designed to have the only one BaseAllocator (to avoid
        useless copying of collections). However one can use operator new to
        create more BaseAllocators, but it is injurious.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _NCollection.Handle_NCollection_AccAllocator_CommonBaseAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StandardCallBack(self, *args):
        """
        StandardCallBack(Handle_NCollection_AccAllocator self, Standard_Boolean const theIsAlloc, Standard_Address const theStorage, Standard_Size const theRoundSize, Standard_Size const theSize)

        Callback function to register alloc/free calls

        :type theIsAlloc: bool
        :type theStorage: OCC.wrapper.Standard.Standard_Address
        :type theRoundSize: int
        :type theSize: int

        """
        return _NCollection.Handle_NCollection_AccAllocator_StandardCallBack(self, *args)


    def PrintMemUsageStatistics(self, *args):
        """
        PrintMemUsageStatistics(Handle_NCollection_AccAllocator self)

        Prints memory usage statistics cumulated by StandardCallBack


        """
        return _NCollection.Handle_NCollection_AccAllocator_PrintMemUsageStatistics(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_NCollection_AccAllocator self)

        Memory deallocator for transient classes


        """
        return _NCollection.Handle_NCollection_AccAllocator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_NCollection_AccAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_NCollection_AccAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_AccAllocator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_NCollection_AccAllocator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_NCollection_AccAllocator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _NCollection.Handle_NCollection_AccAllocator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_NCollection_AccAllocator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _NCollection.Handle_NCollection_AccAllocator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_NCollection_AccAllocator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_AccAllocator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_NCollection_AccAllocator self)

        Increments the reference counter of this object


        """
        return _NCollection.Handle_NCollection_AccAllocator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_NCollection_AccAllocator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.Handle_NCollection_AccAllocator_DecrementRefCounter(self, *args)

Handle_NCollection_AccAllocator_swigregister = _NCollection.Handle_NCollection_AccAllocator_swigregister
Handle_NCollection_AccAllocator_swigregister(Handle_NCollection_AccAllocator)

def Handle_NCollection_AccAllocator_DownCast(thing):
    return _NCollection.Handle_NCollection_AccAllocator_DownCast(thing)
Handle_NCollection_AccAllocator_DownCast = _NCollection.Handle_NCollection_AccAllocator_DownCast

class NCollection_UtfString_Standard_Utf16Char(object):
    """
    This template class represent constant UTF-* string.
    String stored in memory continuously, always NULL-terminated
    and can be used as standard C-string using ToCString() method.

    Notice that changing the string is not allowed
    and any modifications should produce new string.

    In comments to this class, terms "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Iterator(self, *args):
        """
        Iterator(NCollection_UtfString_Standard_Utf16Char self) -> NCollection_UtfIterator_Standard_Utf16Char

        :rtype: OCC.wrapper.NCollection.NCollection_UtfIterator_Type

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_Iterator(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_UtfString_Standard_Utf16Char self) -> Standard_Integer

        @return the size of the buffer in bytes, excluding NULL-termination symbol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_UtfString_Standard_Utf16Char self) -> Standard_Integer

        @return the length of the string in Unicode symbols

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_Length(self, *args)


    def GetChar(self, *args):
        """
        GetChar(NCollection_UtfString_Standard_Utf16Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be lesser than Length()
        @return the Unicode symbol value

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_GetChar(self, *args)


    def GetCharBuffer(self, *args):
        """
        GetCharBuffer(NCollection_UtfString_Standard_Utf16Char self, Standard_Integer const theCharIndex) -> char16_t const *

        Retrieve string buffer at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.
        @param theCharIndex the index of the symbol, should be less than Length()
        (first symbol of the string has index 0)
        @return the pointer to the symbol

        :type theCharIndex: int
        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_GetCharBuffer(self, *args)


    def at(self, *args):
        """
        at(NCollection_UtfString_Standard_Utf16Char self, Standard_Integer const theCharIndex) -> Standard_Utf32Char

        Retrieve Unicode symbol at specified position.
        Warning! This is a slow access. Iterator should be used for consecutive parsing.

        :type theCharIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_at(self, *args)


    def __init__(self, *args):
        """
        This template class represent constant UTF-* string.
        String stored in memory continuously, always NULL-terminated
        and can be used as standard C-string using ToCString() method.

        Notice that changing the string is not allowed
        and any modifications should produce new string.

        In comments to this class, terms "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfString_Standard_Utf16Char(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FromLocale(self, *args):
        """
        FromLocale(NCollection_UtfString_Standard_Utf16Char self, char const * theString, Standard_Integer const theLength=-1)

        Copy from multibyte string in current system locale.
        @param theString multibyte string
        @param theLength the length limit in Unicode symbols
        The string is copied till NULL symbol or, if theLength >0, 
        till either NULL or theLength-th symbol (which comes first).

        :type theString: const char *
        :type theLength: int

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_FromLocale(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theCompare) -> bool

        Compares this string with another one.

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_IsEqual(self, *args)


    def SubString(self, *args):
        """
        SubString(NCollection_UtfString_Standard_Utf16Char self, Standard_Integer const theStart, Standard_Integer const theEnd) -> NCollection_UtfString_Standard_Utf16Char

        Returns the substring.
        @param theStart start index (inclusive) of subString
        @param theEnd   end index   (exclusive) of subString
        @return the substring

        :type theStart: int
        :type theEnd: int
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_SubString(self, *args)


    def ToCString(self, *args):
        """
        ToCString(NCollection_UtfString_Standard_Utf16Char self) -> char16_t const *

        Returns NULL-terminated Unicode string.
        Should not be modifed or deleted!
        @return (const Type* ) pointer to string

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToCString(self, *args)


    def ToUtf8(self, *args):
        """
        ToUtf8(NCollection_UtfString_Standard_Utf16Char self) -> NCollection_UtfString_Standard_Utf8Char

        @return copy in UTF-8 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf8Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToUtf8(self, *args)


    def ToUtf16(self, *args):
        """
        ToUtf16(NCollection_UtfString_Standard_Utf16Char self) -> NCollection_UtfString_Standard_Utf16Char

        @return copy in UTF-16 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToUtf16(self, *args)


    def ToUtf32(self, *args):
        """
        ToUtf32(NCollection_UtfString_Standard_Utf16Char self) -> NCollection_UtfString_Standard_Utf32Char

        @return copy in UTF-32 format

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToUtf32(self, *args)


    def ToUtfWide(self, *args):
        """
        ToUtfWide(NCollection_UtfString_Standard_Utf16Char self) -> NCollection_UtfString_Standard_WideChar

        @return copy in wide format (UTF-16 on Windows and UTF-32 on Linux)

        :rtype: OCC.wrapper.NCollection.NCollection_UtfString_Standard_WideChar

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToUtfWide(self, *args)


    def ToLocale(self, *args):
        """
        ToLocale(NCollection_UtfString_Standard_Utf16Char self, char * theBuffer, Standard_Integer const theSizeBytes) -> bool

        Converts the string into string in the current system locale.
        @param theBuffer    output buffer
        @param theSizeBytes buffer size in bytes
        @return true on success

        :type theBuffer: char *
        :type theSizeBytes: int
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_ToLocale(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UtfString_Standard_Utf16Char self) -> bool

        @return true if string is empty

        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UtfString_Standard_Utf16Char self)

        Zero string.


        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_Clear(self, *args)


    def Assign(self, *args):
        """
        Copy from another string.

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        res = _NCollection.NCollection_UtfString_Standard_Utf16Char_Assign(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Swap(self, *args):
        """
        Swap(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theOther)

        Exchange the data of two strings (without reallocating memory).

        :type theOther: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_Swap(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theOther) -> NCollection_UtfString_Standard_Utf16Char
        assign(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theOther) -> NCollection_UtfString_Standard_Utf16Char
        assign(NCollection_UtfString_Standard_Utf16Char self, char const * theStringUtf8) -> NCollection_UtfString_Standard_Utf16Char
        assign(NCollection_UtfString_Standard_Utf16Char self, Standard_WideChar const * theStringUtfWide) -> NCollection_UtfString_Standard_Utf16Char

        Copy from wchar_t UTF NULL-terminated string.

        :type theStringUtfWide: OCC.wrapper.Standard.Standard_WideChar
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char_assign(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theAppend) -> NCollection_UtfString_Standard_Utf16Char

        Join strings.

        :type theAppend: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: OCC.wrapper.NCollection.NCollection_UtfString

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char___iadd__(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theCompare) -> bool

        @name compare operators

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char___eq__(self, *args)


    def __ne__(self, *args):
        """
        __ne__(NCollection_UtfString_Standard_Utf16Char self, NCollection_UtfString_Standard_Utf16Char theCompare) -> bool

        :type theCompare: OCC.wrapper.NCollection.NCollection_UtfString
        :rtype: bool

        """
        return _NCollection.NCollection_UtfString_Standard_Utf16Char___ne__(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfString_Standard_Utf16Char
NCollection_UtfString_Standard_Utf16Char_swigregister = _NCollection.NCollection_UtfString_Standard_Utf16Char_swigregister
NCollection_UtfString_Standard_Utf16Char_swigregister(NCollection_UtfString_Standard_Utf16Char)


try:
	NCollection_Utf16String = NCollection_UtfString_Standard_Utf16Char
except NameError:
	pass # does not exist, probably ignored

class NCollection_UtfIterator_Standard_Utf32Char(object):
    """
    Template class for Unicode strings support.

    It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
    and convert it from one to another.
    The current value of iterator is returned as UTF-32 Unicode symbol.

    Here and below term "Unicode symbol" is used as 
    synonym of "Unicode code point".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, theString):
        """
        Template class for Unicode strings support.

        It defines an iterator and provide correct way to read multi-byte text (UTF-8 and UTF-16)
        and convert it from one to another.
        The current value of iterator is returned as UTF-32 Unicode symbol.

        Here and below term "Unicode symbol" is used as 
        synonym of "Unicode code point".
        """
        this = _NCollection.new_NCollection_UtfIterator_Standard_Utf32Char(theString)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_UtfIterator_Standard_Utf32Char self, char32_t const * theString)

        Initialize iterator within specified NULL-terminated string.

        :type theString: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_Init(self, *args)


    def __eq__(self, *args):
        """
        __eq__(NCollection_UtfIterator_Standard_Utf32Char self, NCollection_UtfIterator_Standard_Utf32Char theRight) -> bool

        Equality operator.

        :type theRight: OCC.wrapper.NCollection.NCollection_UtfIterator
        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char___eq__(self, *args)


    def IsValid(self, *args):
        """
        IsValid(NCollection_UtfIterator_Standard_Utf32Char self) -> bool

        Return true if Unicode symbol is within valid range.

        :rtype: bool

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_IsValid(self, *args)


    def __ref__(self, *args):
        """
        __ref__(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Utf32Char

        Dereference operator.
        @return the UTF-32 codepoint of the symbol currently pointed by iterator.

        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char___ref__(self, *args)


    def BufferHere(self, *args):
        """
        BufferHere(NCollection_UtfIterator_Standard_Utf32Char self) -> char32_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_BufferHere(self, *args)


    def ChangeBufferHere(self, *args):
        """
        ChangeBufferHere(NCollection_UtfIterator_Standard_Utf32Char self) -> char32_t *

        Buffer-fetching getter. Dangerous! Iterator should be reinitialized on buffer change.

        :rtype: Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_ChangeBufferHere(self, *args)


    def BufferNext(self, *args):
        """
        BufferNext(NCollection_UtfIterator_Standard_Utf32Char self) -> char32_t const *

        Buffer-fetching getter.

        :rtype: const Type *

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_BufferNext(self, *args)


    def Index(self, *args):
        """
        Index(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Integer

        @return the index displacement from iterator intialization
        (first symbol has index 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_Index(self, *args)


    def AdvanceBytesUtf8(self, *args):
        """
        AdvanceBytesUtf8(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-8.
        0 means an invalid symbol;
        1-4 bytes are valid range.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_AdvanceBytesUtf8(self, *args)


    def AdvanceBytesUtf16(self, *args):
        """
        AdvanceBytesUtf16(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        2 bytes is a general case;
        4 bytes for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_AdvanceBytesUtf16(self, *args)


    def AdvanceCodeUnitsUtf16(self, *args):
        """
        AdvanceCodeUnitsUtf16(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-16.
        0 means an invalid symbol;
        1 16-bit code unit is a general case;
        2 16-bit code units for surrogate pair.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_AdvanceCodeUnitsUtf16(self, *args)


    def AdvanceBytesUtf32(self, *args):
        """
        AdvanceBytesUtf32(NCollection_UtfIterator_Standard_Utf32Char self) -> Standard_Integer

        @return the advance in bytes to store current symbol in UTF-32.
        Always 4 bytes (method for consistency).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_AdvanceBytesUtf32(self, *args)


    def GetUtf8(self, *args):
        """
        GetUtf8(NCollection_UtfIterator_Standard_Utf32Char self, Standard_Utf8Char * theBuffer) -> Standard_Utf8Char
        GetUtf8(NCollection_UtfIterator_Standard_Utf32Char self, Standard_Utf8UChar * theBuffer) -> Standard_Utf8UChar *

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf8UChar
        :rtype: OCC.wrapper.Standard.Standard_Utf8UChar

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_GetUtf8(self, *args)


    def GetUtf16(self, *args):
        """
        GetUtf16(NCollection_UtfIterator_Standard_Utf32Char self, Standard_Utf16Char * theBuffer) -> Standard_Utf16Char *

        Fill the UTF-16 buffer within current Unicode symbol.
        Use method AdvanceUtf16() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf16Char
        :rtype: OCC.wrapper.Standard.Standard_Utf16Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_GetUtf16(self, *args)


    def GetUtf32(self, *args):
        """
        GetUtf32(NCollection_UtfIterator_Standard_Utf32Char self, Standard_Utf32Char * theBuffer) -> Standard_Utf32Char *

        Fill the UTF-32 buffer within current Unicode symbol.
        Use method AdvanceUtf32() to allocate buffer with enough size.
        @param theBuffer buffer to fill
        @return new buffer position (for next char)

        :type theBuffer: OCC.wrapper.Standard.Standard_Utf32Char
        :rtype: OCC.wrapper.Standard.Standard_Utf32Char

        """
        return _NCollection.NCollection_UtfIterator_Standard_Utf32Char_GetUtf32(self, *args)

    __swig_destroy__ = _NCollection.delete_NCollection_UtfIterator_Standard_Utf32Char
NCollection_UtfIterator_Standard_Utf32Char_swigregister = _NCollection.NCollection_UtfIterator_Standard_Utf32Char_swigregister
NCollection_UtfIterator_Standard_Utf32Char_swigregister(NCollection_UtfIterator_Standard_Utf32Char)


try:
	NCollection_Utf32Iter = NCollection_UtfIterator_Standard_Utf32Char
except NameError:
	pass # does not exist, probably ignored




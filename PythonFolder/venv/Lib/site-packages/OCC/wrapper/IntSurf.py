# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntSurf')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntSurf')
    _IntSurf = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntSurf', [dirname(__file__)])
        except ImportError:
            import _IntSurf
            return _IntSurf
        try:
            _mod = imp.load_module('_IntSurf', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntSurf = swig_import_helper()
    del swig_import_helper
else:
    import _IntSurf
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntSurf.delete_SwigPyIterator

    def value(self):
        return _IntSurf.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntSurf.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntSurf.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntSurf.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntSurf.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntSurf.SwigPyIterator_copy(self)

    def next(self):
        return _IntSurf.SwigPyIterator_next(self)

    def __next__(self):
        return _IntSurf.SwigPyIterator___next__(self)

    def previous(self):
        return _IntSurf.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntSurf.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntSurf.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntSurf.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntSurf.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntSurf.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntSurf.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntSurf.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntSurf.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntSurf.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntSurf.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntSurf.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntSurf.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntSurf.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntSurf.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntSurf.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntSurf.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntSurf.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntSurf.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntSurf.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntSurf.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntSurf.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntSurf.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntSurf.ptr_to_number(item)
ptr_to_number = _IntSurf.ptr_to_number

def HashCode(*args):
    return _IntSurf.HashCode(*args)
HashCode = _IntSurf.HashCode

def ptr_equal(a, b):
    return _IntSurf.ptr_equal(a, b)
ptr_equal = _IntSurf.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
IntSurf_Inside = _IntSurf.IntSurf_Inside
IntSurf_Outside = _IntSurf.IntSurf_Outside
IntSurf_Unknown = _IntSurf.IntSurf_Unknown
IntSurf_In = _IntSurf.IntSurf_In
IntSurf_Out = _IntSurf.IntSurf_Out
IntSurf_Touch = _IntSurf.IntSurf_Touch
IntSurf_Undecided = _IntSurf.IntSurf_Undecided
class IntSurf_InteriorPoint(object):
    """
    Definition of a point solution of the
    intersection between an implicit an a
    parametrised surface. These points are
    passing points on the intersection lines,
    or starting points for the closed lines
    on the parametrised surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_InteriorPoint self) -> IntSurf_InteriorPoint
        __init__(IntSurf_InteriorPoint self, gp_Pnt P, Standard_Real const U, Standard_Real const V, gp_Vec Direc, gp_Vec2d Direc2d) -> IntSurf_InteriorPoint

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float
        :type Direc: OCC.wrapper.gp.gp_Vec
        :type Direc2d: OCC.wrapper.gp.gp_Vec2d

        """
        this = _IntSurf.new_IntSurf_InteriorPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntSurf_InteriorPoint self, gp_Pnt P, Standard_Real const U, Standard_Real const V, gp_Vec Direc, gp_Vec2d Direc2d)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float
        :type Direc: OCC.wrapper.gp.gp_Vec
        :type Direc2d: OCC.wrapper.gp.gp_Vec2d

        """
        return _IntSurf.IntSurf_InteriorPoint_SetValue(self, *args)


    def Value(self, *args):
        """
        Returns the 3d coordinates of the interior point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntSurf.IntSurf_InteriorPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(IntSurf_InteriorPoint self)

        Returns the parameters of the interior point on the
        parametric surface.

        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_InteriorPoint_Parameters(self, *args)


    def UParameter(self, *args):
        """
        UParameter(IntSurf_InteriorPoint self) -> Standard_Real

        Returns the first parameter of the interior point on the
        parametric surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntSurf.IntSurf_InteriorPoint_UParameter(self, *args)


    def VParameter(self, *args):
        """
        VParameter(IntSurf_InteriorPoint self) -> Standard_Real

        Returns the second parameter of the interior point on the
        parametric surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntSurf.IntSurf_InteriorPoint_VParameter(self, *args)


    def Direction(self, *args):
        """
        Returns the tangent at the intersection in 3d space
        associated to the interior point.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _IntSurf.IntSurf_InteriorPoint_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        Returns the tangent at the intersection in the parametric
        space of the parametric surface.

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        res = _IntSurf.IntSurf_InteriorPoint_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntSurf.delete_IntSurf_InteriorPoint
IntSurf_InteriorPoint_swigregister = _IntSurf.IntSurf_InteriorPoint_swigregister
IntSurf_InteriorPoint_swigregister(IntSurf_InteriorPoint)

class IntSurf_LineOn2S(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_IntSurf_LineOn2S
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_IntSurf_LineOn2S(self) 
            return h


    def __init__(self, *args):
        """
        __init__(IntSurf_LineOn2S self, Handle_NCollection_BaseAllocator theAllocator=0) -> IntSurf_LineOn2S

        :type theAllocator: OCC.wrapper.IntSurf.IntSurf_Allocator

        """
        this = _IntSurf.new_IntSurf_LineOn2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(IntSurf_LineOn2S self, IntSurf_PntOn2S P)

        Adds a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntSurf.IntSurf_LineOn2S_Add(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntSurf_LineOn2S self) -> Standard_Integer

        Returns the number of points in the line.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.IntSurf_LineOn2S_NbPoints(self, *args)


    def Reverse(self, *args):
        """
        Reverse(IntSurf_LineOn2S self)

        Reverses the order of points of the line.


        """
        return _IntSurf.IntSurf_LineOn2S_Reverse(self, *args)


    def Split(self, *args):
        """
        Split(IntSurf_LineOn2S self, Standard_Integer const Index) -> Handle_IntSurf_LineOn2S

        Keeps in <me> the points 1 to Index-1, and returns
        the items Index to the end.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntSurf.IntSurf_LineOn2S_Split(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index in the line.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntSurf.IntSurf_LineOn2S_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetUV(self, *args):
        """
        SetUV(IntSurf_LineOn2S self, Standard_Integer const Index, Standard_Boolean const OnFirst, Standard_Real const U, Standard_Real const V)

        Sets the parametric coordinates on one of the surfaces
        of the point of range Index in the line.

        :type Index: int
        :type OnFirst: bool
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_LineOn2S_SetUV(self, *args)


    def Clear(self, *args):
        """Clear(IntSurf_LineOn2S self)"""
        return _IntSurf.IntSurf_LineOn2S_Clear(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(IntSurf_LineOn2S self, Standard_Integer const I, IntSurf_PntOn2S P)

        :type I: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntSurf.IntSurf_LineOn2S_InsertBefore(self, *args)


    def RemovePoint(self, *args):
        """
        RemovePoint(IntSurf_LineOn2S self, Standard_Integer const I)

        :type I: int

        """
        return _IntSurf.IntSurf_LineOn2S_RemovePoint(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _IntSurf.IntSurf_LineOn2S_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _IntSurf.IntSurf_LineOn2S_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntSurf.IntSurf_LineOn2S_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntSurf.delete_IntSurf_LineOn2S
IntSurf_LineOn2S_swigregister = _IntSurf.IntSurf_LineOn2S_swigregister
IntSurf_LineOn2S_swigregister(IntSurf_LineOn2S)

def IntSurf_LineOn2S_get_type_name(*args):
    """
    IntSurf_LineOn2S_get_type_name() -> char const *

    :rtype: const char *

    """
    return _IntSurf.IntSurf_LineOn2S_get_type_name(*args)

def IntSurf_LineOn2S_get_type_descriptor(*args):
    """
    IntSurf_LineOn2S_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _IntSurf.IntSurf_LineOn2S_get_type_descriptor(*args)

class IntSurf_Couple(object):
    """creation d 'un couple de 2 entiers"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_Couple self) -> IntSurf_Couple
        __init__(IntSurf_Couple self, Standard_Integer const Index1, Standard_Integer const Index2) -> IntSurf_Couple

        :type Index1: int
        :type Index2: int

        """
        this = _IntSurf.new_IntSurf_Couple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def First(self, *args):
        """
        First(IntSurf_Couple self) -> Standard_Integer

        returns the first element

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.IntSurf_Couple_First(self, *args)


    def Second(self, *args):
        """
        Second(IntSurf_Couple self) -> Standard_Integer

        returns the Second element

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.IntSurf_Couple_Second(self, *args)

    __swig_destroy__ = _IntSurf.delete_IntSurf_Couple
IntSurf_Couple_swigregister = _IntSurf.IntSurf_Couple_swigregister
IntSurf_Couple_swigregister(IntSurf_Couple)

class IntSurf_QuadricTool(object):
    """
    This class provides a tool on a quadric that can be
    used to instantiates the Walking algorithmes (see
    package IntWalk) with a Quadric from IntSurf
    as implicit surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> Standard_Real

        Returns the value of the function.

        :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type X: float
        :type Y: float
        :type Z: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntSurf.IntSurf_QuadricTool_Value(*args)

    Value = staticmethod(Value)

    def Gradient(*args):
        """
        Gradient(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, gp_Vec V)

        Returns the gradient of the function.

        :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type X: float
        :type Y: float
        :type Z: float
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_QuadricTool_Gradient(*args)

    Gradient = staticmethod(Gradient)

    def ValueAndGradient(*args):
        """
        ValueAndGradient(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, gp_Vec Grad)

        Returns the value and the gradient.

        :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type X: float
        :type Y: float
        :type Z: float
        :type Val: float
        :type Grad: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_QuadricTool_ValueAndGradient(*args)

    ValueAndGradient = staticmethod(ValueAndGradient)

    def Tolerance(*args):
        """
        Tolerance(IntSurf_Quadric Quad) -> Standard_Real

        returns the tolerance of the zero of the implicit function

        :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntSurf.IntSurf_QuadricTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def __init__(self):
        """
        This class provides a tool on a quadric that can be
        used to instantiates the Walking algorithmes (see
        package IntWalk) with a Quadric from IntSurf
        as implicit surface.
        """
        this = _IntSurf.new_IntSurf_QuadricTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_IntSurf_QuadricTool
IntSurf_QuadricTool_swigregister = _IntSurf.IntSurf_QuadricTool_swigregister
IntSurf_QuadricTool_swigregister(IntSurf_QuadricTool)

def IntSurf_QuadricTool_Value(*args):
    """
    IntSurf_QuadricTool_Value(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> Standard_Real

    Returns the value of the function.

    :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
    :type X: float
    :type Y: float
    :type Z: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntSurf.IntSurf_QuadricTool_Value(*args)

def IntSurf_QuadricTool_Gradient(*args):
    """
    IntSurf_QuadricTool_Gradient(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, gp_Vec V)

    Returns the gradient of the function.

    :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
    :type X: float
    :type Y: float
    :type Z: float
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _IntSurf.IntSurf_QuadricTool_Gradient(*args)

def IntSurf_QuadricTool_ValueAndGradient(*args):
    """
    IntSurf_QuadricTool_ValueAndGradient(IntSurf_Quadric Quad, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, gp_Vec Grad)

    Returns the value and the gradient.

    :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
    :type X: float
    :type Y: float
    :type Z: float
    :type Val: float
    :type Grad: OCC.wrapper.gp.gp_Vec

    """
    return _IntSurf.IntSurf_QuadricTool_ValueAndGradient(*args)

def IntSurf_QuadricTool_Tolerance(*args):
    """
    IntSurf_QuadricTool_Tolerance(IntSurf_Quadric Quad) -> Standard_Real

    returns the tolerance of the zero of the implicit function

    :type Quad: OCC.wrapper.IntSurf.IntSurf_Quadric
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntSurf.IntSurf_QuadricTool_Tolerance(*args)

class IntSurf_PathPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_PathPoint self) -> IntSurf_PathPoint
        __init__(IntSurf_PathPoint self, gp_Pnt P, Standard_Real const U, Standard_Real const V) -> IntSurf_PathPoint

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        this = _IntSurf.new_IntSurf_PathPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntSurf_PathPoint self, gp_Pnt P, Standard_Real const U, Standard_Real const V)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPoint_SetValue(self, *args)


    def AddUV(self, *args):
        """
        AddUV(IntSurf_PathPoint self, Standard_Real const U, Standard_Real const V)

        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPoint_AddUV(self, *args)


    def SetDirections(self, *args):
        """
        SetDirections(IntSurf_PathPoint self, gp_Vec V, gp_Dir2d D)

        :type V: OCC.wrapper.gp.gp_Vec
        :type D: OCC.wrapper.gp.gp_Dir2d

        """
        return _IntSurf.IntSurf_PathPoint_SetDirections(self, *args)


    def SetTangency(self, *args):
        """
        SetTangency(IntSurf_PathPoint self, Standard_Boolean const Tang)

        :type Tang: bool

        """
        return _IntSurf.IntSurf_PathPoint_SetTangency(self, *args)


    def SetPassing(self, *args):
        """
        SetPassing(IntSurf_PathPoint self, Standard_Boolean const Pass)

        :type Pass: bool

        """
        return _IntSurf.IntSurf_PathPoint_SetPassing(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntSurf.IntSurf_PathPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value2d(self, *args):
        """
        Value2d(IntSurf_PathPoint self)

        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPoint_Value2d(self, *args)


    def IsPassingPnt(self, *args):
        """
        IsPassingPnt(IntSurf_PathPoint self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_PathPoint_IsPassingPnt(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(IntSurf_PathPoint self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_PathPoint_IsTangent(self, *args)


    def Direction3d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _IntSurf.IntSurf_PathPoint_Direction3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _IntSurf.IntSurf_PathPoint_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Multiplicity(self, *args):
        """
        Multiplicity(IntSurf_PathPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.IntSurf_PathPoint_Multiplicity(self, *args)


    def Parameters(self, *args):
        """
        Parameters(IntSurf_PathPoint self, Standard_Integer const Index)

        :type Index: int
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPoint_Parameters(self, *args)

    __swig_destroy__ = _IntSurf.delete_IntSurf_PathPoint
IntSurf_PathPoint_swigregister = _IntSurf.IntSurf_PathPoint_swigregister
IntSurf_PathPoint_swigregister(IntSurf_PathPoint)

class NCollection_Sequence_IntSurf_Couple(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntSurf_Couple self) -> NCollection_Sequence< IntSurf_Couple >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntSurf_Couple self) -> NCollection_Sequence< IntSurf_Couple >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntSurf_Couple self) -> NCollection_Sequence< IntSurf_Couple >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntSurf_Couple self) -> NCollection_Sequence< IntSurf_Couple >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntSurf.new_NCollection_Sequence_IntSurf_Couple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntSurf_Couple self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntSurf_Couple self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntSurf_Couple self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntSurf_Couple self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntSurf_Couple self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntSurf_Couple self)

        Reverse sequence


        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntSurf_Couple self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence_IntSurf_Couple theOther) -> NCollection_Sequence_IntSurf_Couple

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence_IntSurf_Couple theOther) -> NCollection_Sequence_IntSurf_Couple

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence< IntSurf_Couple >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntSurf_Couple self, IntSurf_Couple theItem)
        Append(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence_IntSurf_Couple theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntSurf_Couple self, IntSurf_Couple theItem)
        Prepend(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence_IntSurf_Couple theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, IntSurf_Couple theItem)
        InsertBefore(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_Couple theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntSurf_Couple self, NCollection_Sequence< IntSurf_Couple >::Iterator & thePosition, IntSurf_Couple theItem)
        InsertAfter(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_Couple theSeq)
        InsertAfter(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, IntSurf_Couple theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_Couple theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_Couple_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntSurf_Couple self) -> IntSurf_Couple

        First item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_Couple_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntSurf_Couple self) -> IntSurf_Couple

        Last item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_Couple_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex) -> IntSurf_Couple

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_Couple___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntSurf_Couple self, Standard_Integer const theIndex, IntSurf_Couple theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_SetValue(self, *args)


    def __iter__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_Couple___iter__(self)
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_Couple
NCollection_Sequence_IntSurf_Couple_swigregister = _IntSurf.NCollection_Sequence_IntSurf_Couple_swigregister
NCollection_Sequence_IntSurf_Couple_swigregister(NCollection_Sequence_IntSurf_Couple)

def NCollection_Sequence_IntSurf_Couple_delNode(*args):
    """
    NCollection_Sequence_IntSurf_Couple_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntSurf.NCollection_Sequence_IntSurf_Couple_delNode(*args)

class NCollection_Sequence_IntSurf_Couple_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntSurf.new_NCollection_Sequence_IntSurf_Couple_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_Couple_IteratorHelper

    def __next__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_Couple_IteratorHelper___next__(self)
NCollection_Sequence_IntSurf_Couple_IteratorHelper_swigregister = _IntSurf.NCollection_Sequence_IntSurf_Couple_IteratorHelper_swigregister
NCollection_Sequence_IntSurf_Couple_IteratorHelper_swigregister(NCollection_Sequence_IntSurf_Couple_IteratorHelper)


try:
	IntSurf_SequenceOfCouple = NCollection_Sequence_IntSurf_Couple
except NameError:
	pass # does not exist, probably ignored

class IntSurf_InteriorPointTool(object):
    """
    This class provides a tool on the "interior point"
    that can be used to instantiates the Walking
    algorithmes (see package IntWalk).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value3d(*args):
        """
        Value3d(IntSurf_InteriorPoint PStart) -> gp_Pnt

        Returns the 3d coordinates of the starting point.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntSurf.IntSurf_InteriorPointTool_Value3d(*args)

    Value3d = staticmethod(Value3d)

    def Value2d(*args):
        """
        Value2d(IntSurf_InteriorPoint PStart)

        Returns the <U,V> parameters which are associated
        with <P>
        it's the parameters which start the marching algorithm

        :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_InteriorPointTool_Value2d(*args)

    Value2d = staticmethod(Value2d)

    def Direction3d(*args):
        """
        Direction3d(IntSurf_InteriorPoint PStart) -> gp_Vec

        returns the tangent at the intersectin in 3d space
        associated to <P>

        :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_InteriorPointTool_Direction3d(*args)

    Direction3d = staticmethod(Direction3d)

    def Direction2d(*args):
        """
        Direction2d(IntSurf_InteriorPoint PStart) -> gp_Dir2d

        returns the tangent at the intersectin in the
        parametric space of the parametrized surface.This tangent
        is associated to the value2d

        :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _IntSurf.IntSurf_InteriorPointTool_Direction2d(*args)

    Direction2d = staticmethod(Direction2d)

    def __init__(self):
        """
        This class provides a tool on the "interior point"
        that can be used to instantiates the Walking
        algorithmes (see package IntWalk).
        """
        this = _IntSurf.new_IntSurf_InteriorPointTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_IntSurf_InteriorPointTool
IntSurf_InteriorPointTool_swigregister = _IntSurf.IntSurf_InteriorPointTool_swigregister
IntSurf_InteriorPointTool_swigregister(IntSurf_InteriorPointTool)

def IntSurf_InteriorPointTool_Value3d(*args):
    """
    IntSurf_InteriorPointTool_Value3d(IntSurf_InteriorPoint PStart) -> gp_Pnt

    Returns the 3d coordinates of the starting point.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntSurf.IntSurf_InteriorPointTool_Value3d(*args)

def IntSurf_InteriorPointTool_Value2d(*args):
    """
    IntSurf_InteriorPointTool_Value2d(IntSurf_InteriorPoint PStart)

    Returns the <U,V> parameters which are associated
    with <P>
    it's the parameters which start the marching algorithm

    :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
    :type U: float
    :type V: float

    """
    return _IntSurf.IntSurf_InteriorPointTool_Value2d(*args)

def IntSurf_InteriorPointTool_Direction3d(*args):
    """
    IntSurf_InteriorPointTool_Direction3d(IntSurf_InteriorPoint PStart) -> gp_Vec

    returns the tangent at the intersectin in 3d space
    associated to <P>

    :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _IntSurf.IntSurf_InteriorPointTool_Direction3d(*args)

def IntSurf_InteriorPointTool_Direction2d(*args):
    """
    IntSurf_InteriorPointTool_Direction2d(IntSurf_InteriorPoint PStart) -> gp_Dir2d

    returns the tangent at the intersectin in the
    parametric space of the parametrized surface.This tangent
    is associated to the value2d

    :type PStart: OCC.wrapper.IntSurf.IntSurf_InteriorPoint
    :rtype: OCC.wrapper.gp.gp_Dir2d

    """
    return _IntSurf.IntSurf_InteriorPointTool_Direction2d(*args)

class IntSurf_Quadric(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_Quadric self) -> IntSurf_Quadric
        __init__(IntSurf_Quadric self, gp_Pln P) -> IntSurf_Quadric
        __init__(IntSurf_Quadric self, gp_Cylinder C) -> IntSurf_Quadric
        __init__(IntSurf_Quadric self, gp_Sphere S) -> IntSurf_Quadric
        __init__(IntSurf_Quadric self, gp_Cone C) -> IntSurf_Quadric
        __init__(IntSurf_Quadric self, gp_Torus T) -> IntSurf_Quadric

        :type T: OCC.wrapper.gp.gp_Torus

        """
        this = _IntSurf.new_IntSurf_Quadric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntSurf_Quadric self, gp_Pln P)
        SetValue(IntSurf_Quadric self, gp_Cylinder C)
        SetValue(IntSurf_Quadric self, gp_Sphere S)
        SetValue(IntSurf_Quadric self, gp_Cone C)
        SetValue(IntSurf_Quadric self, gp_Torus T)

        :type T: OCC.wrapper.gp.gp_Torus

        """
        return _IntSurf.IntSurf_Quadric_SetValue(self, *args)


    def Distance(self, *args):
        """
        Distance(IntSurf_Quadric self, gp_Pnt P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntSurf.IntSurf_Quadric_Distance(self, *args)


    def Gradient(self, *args):
        """
        Gradient(IntSurf_Quadric self, gp_Pnt P) -> gp_Vec

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_Quadric_Gradient(self, *args)


    def ValAndGrad(self, *args):
        """
        ValAndGrad(IntSurf_Quadric self, gp_Pnt P, gp_Vec Grad)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Dist: float
        :type Grad: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_Quadric_ValAndGrad(self, *args)


    def TypeQuadric(self, *args):
        """
        TypeQuadric(IntSurf_Quadric self) -> GeomAbs_SurfaceType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

        """
        return _IntSurf.IntSurf_Quadric_TypeQuadric(self, *args)


    def Plane(self, *args):
        """
        Plane(IntSurf_Quadric self) -> gp_Pln

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _IntSurf.IntSurf_Quadric_Plane(self, *args)


    def Sphere(self, *args):
        """
        Sphere(IntSurf_Quadric self) -> gp_Sphere

        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _IntSurf.IntSurf_Quadric_Sphere(self, *args)


    def Cylinder(self, *args):
        """
        Cylinder(IntSurf_Quadric self) -> gp_Cylinder

        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _IntSurf.IntSurf_Quadric_Cylinder(self, *args)


    def Cone(self, *args):
        """
        Cone(IntSurf_Quadric self) -> gp_Cone

        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _IntSurf.IntSurf_Quadric_Cone(self, *args)


    def Torus(self, *args):
        """
        Torus(IntSurf_Quadric self) -> gp_Torus

        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _IntSurf.IntSurf_Quadric_Torus(self, *args)


    def Value(self, *args):
        """
        Value(IntSurf_Quadric self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntSurf.IntSurf_Quadric_Value(self, *args)


    def D1(self, *args):
        """
        D1(IntSurf_Quadric self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_Quadric_D1(self, *args)


    def DN(self, *args):
        """
        DN(IntSurf_Quadric self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_Quadric_DN(self, *args)


    def Parameters(self, *args):
        """
        Parameters(IntSurf_Quadric self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_Quadric_Parameters(self, *args)


    def Normale(self, *args):
        """
        Normale(IntSurf_Quadric self, Standard_Real const U, Standard_Real const V) -> gp_Vec
        Normale(IntSurf_Quadric self, gp_Pnt P) -> gp_Vec

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_Quadric_Normale(self, *args)

    __swig_destroy__ = _IntSurf.delete_IntSurf_Quadric
IntSurf_Quadric_swigregister = _IntSurf.IntSurf_Quadric_swigregister
IntSurf_Quadric_swigregister(IntSurf_Quadric)

class IntSurf_Transition(object):
    """
    Definition of the transition at the intersection
    between an intersection line and a restriction curve
    on a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_Transition self) -> IntSurf_Transition
        __init__(IntSurf_Transition self, Standard_Boolean const Tangent, IntSurf_TypeTrans const Type) -> IntSurf_Transition
        __init__(IntSurf_Transition self, Standard_Boolean const Tangent, IntSurf_Situation const Situ, Standard_Boolean const Oppos) -> IntSurf_Transition

        Create a TOUCH transition.

        :type Tangent: bool
        :type Situ: OCC.wrapper.IntSurf.IntSurf_Situation
        :type Oppos: bool

        """
        this = _IntSurf.new_IntSurf_Transition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntSurf_Transition self, Standard_Boolean const Tangent, IntSurf_TypeTrans const Type)
        SetValue(IntSurf_Transition self, Standard_Boolean const Tangent, IntSurf_Situation const Situ, Standard_Boolean const Oppos)
        SetValue(IntSurf_Transition self)

        Set the values of an UNDECIDED transition.


        """
        return _IntSurf.IntSurf_Transition_SetValue(self, *args)


    def TransitionType(self, *args):
        """
        TransitionType(IntSurf_Transition self) -> IntSurf_TypeTrans

        Returns the type of Transition (in/out/touch/undecided)
        for the arc given by value. This the transition of
        the intersection line compared to the Arc of restriction,
        i-e when the function returns INSIDE for example, it
        means that the intersection line goes inside the
        part of plane limited by the arc of restriction.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _IntSurf.IntSurf_Transition_TransitionType(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(IntSurf_Transition self) -> Standard_Boolean

        Returns TRUE if the point is tangent to the arc
        given by Value.
        An exception is raised if TransitionType returns UNDECIDED.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_Transition_IsTangent(self, *args)


    def Situation(self, *args):
        """
        Situation(IntSurf_Transition self) -> IntSurf_Situation

        Returns a significant value if TransitionType returns
        TOUCH. In this case, the function returns :
        INSIDE when the intersection line remains inside the Arc,
        OUTSIDE when it remains outside the Arc,
        UNKNOWN when the calsulus cannot give results.
        If TransitionType returns IN, or OUT, or UNDECIDED, a
        exception is raised.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _IntSurf.IntSurf_Transition_Situation(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(IntSurf_Transition self) -> Standard_Boolean

        returns a significant value if TransitionType returns
        TOUCH.
        In this case, the function returns true when
        the 2 curves locally define two different parts of the
        space.
        If TransitionType returns IN or OUT or UNDECIDED, an
        exception is raised.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_Transition_IsOpposite(self, *args)

    __swig_destroy__ = _IntSurf.delete_IntSurf_Transition
IntSurf_Transition_swigregister = _IntSurf.IntSurf_Transition_swigregister
IntSurf_Transition_swigregister(IntSurf_Transition)


try:
	IntSurf_Allocator = NCollection.Handle_NCollection_BaseAllocator
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_IntSurf_InteriorPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntSurf_InteriorPoint self) -> NCollection_Sequence< IntSurf_InteriorPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntSurf_InteriorPoint self) -> NCollection_Sequence< IntSurf_InteriorPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntSurf_InteriorPoint self) -> NCollection_Sequence< IntSurf_InteriorPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntSurf_InteriorPoint self) -> NCollection_Sequence< IntSurf_InteriorPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntSurf.new_NCollection_Sequence_IntSurf_InteriorPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntSurf_InteriorPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntSurf_InteriorPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntSurf_InteriorPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntSurf_InteriorPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntSurf_InteriorPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntSurf_InteriorPoint self)

        Reverse sequence


        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntSurf_InteriorPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence_IntSurf_InteriorPoint theOther) -> NCollection_Sequence_IntSurf_InteriorPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence_IntSurf_InteriorPoint theOther) -> NCollection_Sequence_IntSurf_InteriorPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence< IntSurf_InteriorPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntSurf_InteriorPoint self, IntSurf_InteriorPoint theItem)
        Append(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence_IntSurf_InteriorPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntSurf_InteriorPoint self, IntSurf_InteriorPoint theItem)
        Prepend(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence_IntSurf_InteriorPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, IntSurf_InteriorPoint theItem)
        InsertBefore(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_InteriorPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntSurf_InteriorPoint self, NCollection_Sequence< IntSurf_InteriorPoint >::Iterator & thePosition, IntSurf_InteriorPoint theItem)
        InsertAfter(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_InteriorPoint theSeq)
        InsertAfter(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, IntSurf_InteriorPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_InteriorPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntSurf_InteriorPoint self) -> IntSurf_InteriorPoint

        First item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntSurf_InteriorPoint self) -> IntSurf_InteriorPoint

        Last item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex) -> IntSurf_InteriorPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntSurf_InteriorPoint self, Standard_Integer const theIndex, IntSurf_InteriorPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_SetValue(self, *args)


    def __iter__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint___iter__(self)
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_InteriorPoint
NCollection_Sequence_IntSurf_InteriorPoint_swigregister = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_swigregister
NCollection_Sequence_IntSurf_InteriorPoint_swigregister(NCollection_Sequence_IntSurf_InteriorPoint)

def NCollection_Sequence_IntSurf_InteriorPoint_delNode(*args):
    """
    NCollection_Sequence_IntSurf_InteriorPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_delNode(*args)

class NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntSurf.new_NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper

    def __next__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper___next__(self)
NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper_swigregister = _IntSurf.NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper_swigregister
NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper_swigregister(NCollection_Sequence_IntSurf_InteriorPoint_IteratorHelper)


try:
	IntSurf_SequenceOfInteriorPoint = NCollection_Sequence_IntSurf_InteriorPoint
except NameError:
	pass # does not exist, probably ignored

class IntSurf_PathPointTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value3d(*args):
        """
        Value3d(IntSurf_PathPoint PStart) -> gp_Pnt

        Returns the 3d coordinates of the starting point.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntSurf.IntSurf_PathPointTool_Value3d(*args)

    Value3d = staticmethod(Value3d)

    def Value2d(*args):
        """
        Value2d(IntSurf_PathPoint PStart)

        Returns the <U, V> parameters which are associated
        with <P>
        it's the parameters which start the marching algorithm

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPointTool_Value2d(*args)

    Value2d = staticmethod(Value2d)

    def IsPassingPnt(*args):
        """
        IsPassingPnt(IntSurf_PathPoint PStart) -> Standard_Boolean

        Returns True if the point is a point on a non-oriented
        arc, which means that the intersection line does not
        stop at such a point but just go through such a point.
        IsPassingPnt is True when IsOnArc is True

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_PathPointTool_IsPassingPnt(*args)

    IsPassingPnt = staticmethod(IsPassingPnt)

    def IsTangent(*args):
        """
        IsTangent(IntSurf_PathPoint PStart) -> Standard_Boolean

        Returns True if the surfaces are tangent at this point.
        IsTangent can be True when IsOnArc is True
        if IsPassingPnt is True and IsTangent is True,this point
        is a stopped point.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_PathPointTool_IsTangent(*args)

    IsTangent = staticmethod(IsTangent)

    def Direction3d(*args):
        """
        Direction3d(IntSurf_PathPoint PStart) -> gp_Vec

        returns the tangent at the intersection in 3d space
        associated to <P>
        an exception is raised if IsTangent is true.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntSurf.IntSurf_PathPointTool_Direction3d(*args)

    Direction3d = staticmethod(Direction3d)

    def Direction2d(*args):
        """
        Direction2d(IntSurf_PathPoint PStart) -> gp_Dir2d

        returns the tangent at the intersection in the
        parametric space of the parametrized surface.This tangent
        is associated to the value2d
        la tangente a un sens signifiant (indique le sens de chemin
        ement)
        an exception is raised if IsTangent is true.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _IntSurf.IntSurf_PathPointTool_Direction2d(*args)

    Direction2d = staticmethod(Direction2d)

    def Multiplicity(*args):
        """
        Multiplicity(IntSurf_PathPoint PStart) -> Standard_Integer

        Returns the multiplicity of the point i-e
        the number of auxillar parameters associated to the
        point which the principal parameters are given by Value2d

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.IntSurf_PathPointTool_Multiplicity(*args)

    Multiplicity = staticmethod(Multiplicity)

    def Parameters(*args):
        """
        Parameters(IntSurf_PathPoint PStart, Standard_Integer const Mult)

        Parametric coordinates associated to the multiplicity.
        An exception is raised if Mult<=0 or Mult>multiplicity.

        :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
        :type Mult: int
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PathPointTool_Parameters(*args)

    Parameters = staticmethod(Parameters)

    def __init__(self):
        this = _IntSurf.new_IntSurf_PathPointTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_IntSurf_PathPointTool
IntSurf_PathPointTool_swigregister = _IntSurf.IntSurf_PathPointTool_swigregister
IntSurf_PathPointTool_swigregister(IntSurf_PathPointTool)

def IntSurf_PathPointTool_Value3d(*args):
    """
    IntSurf_PathPointTool_Value3d(IntSurf_PathPoint PStart) -> gp_Pnt

    Returns the 3d coordinates of the starting point.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntSurf.IntSurf_PathPointTool_Value3d(*args)

def IntSurf_PathPointTool_Value2d(*args):
    """
    IntSurf_PathPointTool_Value2d(IntSurf_PathPoint PStart)

    Returns the <U, V> parameters which are associated
    with <P>
    it's the parameters which start the marching algorithm

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :type U: float
    :type V: float

    """
    return _IntSurf.IntSurf_PathPointTool_Value2d(*args)

def IntSurf_PathPointTool_IsPassingPnt(*args):
    """
    IntSurf_PathPointTool_IsPassingPnt(IntSurf_PathPoint PStart) -> Standard_Boolean

    Returns True if the point is a point on a non-oriented
    arc, which means that the intersection line does not
    stop at such a point but just go through such a point.
    IsPassingPnt is True when IsOnArc is True

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntSurf.IntSurf_PathPointTool_IsPassingPnt(*args)

def IntSurf_PathPointTool_IsTangent(*args):
    """
    IntSurf_PathPointTool_IsTangent(IntSurf_PathPoint PStart) -> Standard_Boolean

    Returns True if the surfaces are tangent at this point.
    IsTangent can be True when IsOnArc is True
    if IsPassingPnt is True and IsTangent is True,this point
    is a stopped point.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntSurf.IntSurf_PathPointTool_IsTangent(*args)

def IntSurf_PathPointTool_Direction3d(*args):
    """
    IntSurf_PathPointTool_Direction3d(IntSurf_PathPoint PStart) -> gp_Vec

    returns the tangent at the intersection in 3d space
    associated to <P>
    an exception is raised if IsTangent is true.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _IntSurf.IntSurf_PathPointTool_Direction3d(*args)

def IntSurf_PathPointTool_Direction2d(*args):
    """
    IntSurf_PathPointTool_Direction2d(IntSurf_PathPoint PStart) -> gp_Dir2d

    returns the tangent at the intersection in the
    parametric space of the parametrized surface.This tangent
    is associated to the value2d
    la tangente a un sens signifiant (indique le sens de chemin
    ement)
    an exception is raised if IsTangent is true.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.gp.gp_Dir2d

    """
    return _IntSurf.IntSurf_PathPointTool_Direction2d(*args)

def IntSurf_PathPointTool_Multiplicity(*args):
    """
    IntSurf_PathPointTool_Multiplicity(IntSurf_PathPoint PStart) -> Standard_Integer

    Returns the multiplicity of the point i-e
    the number of auxillar parameters associated to the
    point which the principal parameters are given by Value2d

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntSurf.IntSurf_PathPointTool_Multiplicity(*args)

def IntSurf_PathPointTool_Parameters(*args):
    """
    IntSurf_PathPointTool_Parameters(IntSurf_PathPoint PStart, Standard_Integer const Mult)

    Parametric coordinates associated to the multiplicity.
    An exception is raised if Mult<=0 or Mult>multiplicity.

    :type PStart: OCC.wrapper.IntSurf.IntSurf_PathPoint
    :type Mult: int
    :type U: float
    :type V: float

    """
    return _IntSurf.IntSurf_PathPointTool_Parameters(*args)

class Handle_IntSurf_LineOn2S(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_IntSurf_LineOn2S self)

        Nullify the handle


        """
        return _IntSurf.Handle_IntSurf_LineOn2S_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_IntSurf_LineOn2S self) -> bool

        Check for being null

        :rtype: bool

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_IntSurf_LineOn2S self, IntSurf_LineOn2S thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_IntSurf_LineOn2S self, Handle_IntSurf_LineOn2S theHandle) -> Handle_IntSurf_LineOn2S
        assign(Handle_IntSurf_LineOn2S self, IntSurf_LineOn2S thePtr) -> Handle_IntSurf_LineOn2S
        assign(Handle_IntSurf_LineOn2S self, Handle_IntSurf_LineOn2S theHandle) -> Handle_IntSurf_LineOn2S

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_IntSurf_LineOn2S self) -> IntSurf_LineOn2S

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_IntSurf_LineOn2S self) -> IntSurf_LineOn2S

        Member access operator (note non-const)

        :rtype: T *

        """
        return _IntSurf.Handle_IntSurf_LineOn2S___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_IntSurf_LineOn2S self) -> IntSurf_LineOn2S

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _IntSurf.Handle_IntSurf_LineOn2S___ref__(self, *args)


    def __hash__(self):
        return _IntSurf.Handle_IntSurf_LineOn2S___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _IntSurf.Handle_IntSurf_LineOn2S___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _IntSurf.new_Handle_IntSurf_LineOn2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_IntSurf.Handle_IntSurf_LineOn2S_DownCast)
    __swig_destroy__ = _IntSurf.delete_Handle_IntSurf_LineOn2S

    def Add(self, *args):
        """
        Add(Handle_IntSurf_LineOn2S self, IntSurf_PntOn2S P)

        Adds a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_Add(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_IntSurf_LineOn2S self) -> Standard_Integer

        Returns the number of points in the line.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index in the line.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntSurf.Handle_IntSurf_LineOn2S_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_IntSurf_LineOn2S self)

        Reverses the order of points of the line.


        """
        return _IntSurf.Handle_IntSurf_LineOn2S_Reverse(self, *args)


    def Split(self, *args):
        """
        Split(Handle_IntSurf_LineOn2S self, Standard_Integer const Index) -> Handle_IntSurf_LineOn2S

        Keeps in <me> the points 1 to Index-1, and returns
        the items Index to the end.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_Split(self, *args)


    def SetUV(self, *args):
        """
        SetUV(Handle_IntSurf_LineOn2S self, Standard_Integer const Index, Standard_Boolean const OnFirst, Standard_Real const U, Standard_Real const V)

        Sets the parametric coordinates on one of the surfaces
        of the point of range Index in the line.

        :type Index: int
        :type OnFirst: bool
        :type U: float
        :type V: float

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_SetUV(self, *args)


    def Clear(self, *args):
        """Clear(Handle_IntSurf_LineOn2S self)"""
        return _IntSurf.Handle_IntSurf_LineOn2S_Clear(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_IntSurf_LineOn2S self, Standard_Integer const I, IntSurf_PntOn2S P)

        :type I: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_InsertBefore(self, *args)


    def RemovePoint(self, *args):
        """
        RemovePoint(Handle_IntSurf_LineOn2S self, Standard_Integer const I)

        :type I: int

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_RemovePoint(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_IntSurf_LineOn2S self) -> char const *

        :rtype: const char *

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntSurf.Handle_IntSurf_LineOn2S_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _IntSurf.Handle_IntSurf_LineOn2S_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_IntSurf_LineOn2S self)

        Memory deallocator for transient classes


        """
        return _IntSurf.Handle_IntSurf_LineOn2S_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_IntSurf_LineOn2S self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_IntSurf_LineOn2S self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_IntSurf_LineOn2S self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_IntSurf_LineOn2S self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_IntSurf_LineOn2S self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_IntSurf_LineOn2S self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_IntSurf_LineOn2S self)

        Increments the reference counter of this object


        """
        return _IntSurf.Handle_IntSurf_LineOn2S_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_IntSurf_LineOn2S self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.Handle_IntSurf_LineOn2S_DecrementRefCounter(self, *args)

Handle_IntSurf_LineOn2S_swigregister = _IntSurf.Handle_IntSurf_LineOn2S_swigregister
Handle_IntSurf_LineOn2S_swigregister(Handle_IntSurf_LineOn2S)

def Handle_IntSurf_LineOn2S_DownCast(thing):
    return _IntSurf.Handle_IntSurf_LineOn2S_DownCast(thing)
Handle_IntSurf_LineOn2S_DownCast = _IntSurf.Handle_IntSurf_LineOn2S_DownCast

class IntSurf_PntOn2S(object):
    """
    This class defines the geometric informations
    for an intersection point between 2 surfaces :
    The coordinates ( Pnt from gp ), and two
    parametric coordinates.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntSurf_PntOn2S self) -> IntSurf_PntOn2S

        Empty constructor.


        """
        this = _IntSurf.new_IntSurf_PntOn2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(IntSurf_PntOn2S self, gp_Pnt Pt)
        SetValue(IntSurf_PntOn2S self, gp_Pnt Pt, Standard_Boolean const OnFirst, Standard_Real const U, Standard_Real const V)
        SetValue(IntSurf_PntOn2S self, gp_Pnt Pt, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2)
        SetValue(IntSurf_PntOn2S self, Standard_Boolean const OnFirst, Standard_Real const U, Standard_Real const V)
        SetValue(IntSurf_PntOn2S self, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2)

        Set the values of the point in the parametric
        space of one of the surface.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _IntSurf.IntSurf_PntOn2S_SetValue(self, *args)


    def Value(self, *args):
        """
        Returns the point in 3d space.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntSurf.IntSurf_PntOn2S_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ValueOnSurface(self, *args):
        """
        ValueOnSurface(IntSurf_PntOn2S self, Standard_Boolean const OnFirst) -> gp_Pnt2d

        Returns the point in 2d space of one of the surfaces.

        :type OnFirst: bool
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _IntSurf.IntSurf_PntOn2S_ValueOnSurface(self, *args)


    def ParametersOnS1(self, *args):
        """
        ParametersOnS1(IntSurf_PntOn2S self)

        Returns the parameters of the point on the first surface.

        :type U1: float
        :type V1: float

        """
        return _IntSurf.IntSurf_PntOn2S_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        ParametersOnS2(IntSurf_PntOn2S self)

        Returns the parameters of the point on the second surface.

        :type U2: float
        :type V2: float

        """
        return _IntSurf.IntSurf_PntOn2S_ParametersOnS2(self, *args)


    def ParametersOnSurface(self, *args):
        """
        ParametersOnSurface(IntSurf_PntOn2S self, Standard_Boolean const OnFirst)

        Returns the parameters of the point in the
        parametric space of one of the surface.

        :type OnFirst: bool
        :type U: float
        :type V: float

        """
        return _IntSurf.IntSurf_PntOn2S_ParametersOnSurface(self, *args)


    def Parameters(self, *args):
        """
        Parameters(IntSurf_PntOn2S self)

        Returns the parameters of the point on both surfaces.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _IntSurf.IntSurf_PntOn2S_Parameters(self, *args)


    def IsSame(self, *args):
        """
        IsSame(IntSurf_PntOn2S self, IntSurf_PntOn2S theOtherPoint, Standard_Real const theTol3D=0.0, Standard_Real const theTol2D=-1.0) -> Standard_Boolean

        Returns TRUE if 2D- and 3D-coordinates of theOterPoint are equal to
        corresponding coordinates of me (with given tolerance).
        If theTol2D < 0.0 we will compare 3D-points only.

        :type theOtherPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :type theTol3D: float
        :type theTol2D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.IntSurf_PntOn2S_IsSame(self, *args)

    __swig_destroy__ = _IntSurf.delete_IntSurf_PntOn2S
IntSurf_PntOn2S_swigregister = _IntSurf.IntSurf_PntOn2S_swigregister
IntSurf_PntOn2S_swigregister(IntSurf_PntOn2S)

class NCollection_List_IntSurf_PntOn2S_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntSurf.new_NCollection_List_IntSurf_PntOn2S_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_List_IntSurf_PntOn2S_IteratorHelper

    def __next__(self):
        return _IntSurf.NCollection_List_IntSurf_PntOn2S_IteratorHelper___next__(self)
NCollection_List_IntSurf_PntOn2S_IteratorHelper_swigregister = _IntSurf.NCollection_List_IntSurf_PntOn2S_IteratorHelper_swigregister
NCollection_List_IntSurf_PntOn2S_IteratorHelper_swigregister(NCollection_List_IntSurf_PntOn2S_IteratorHelper)


try:
	IntSurf_ListOfPntOn2S = NCollection_List_IntSurf_PntOn2S
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_IntSurf_PntOn2S(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntSurf_PntOn2S self) -> NCollection_Sequence< IntSurf_PntOn2S >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntSurf_PntOn2S self) -> NCollection_Sequence< IntSurf_PntOn2S >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntSurf_PntOn2S self) -> NCollection_Sequence< IntSurf_PntOn2S >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntSurf_PntOn2S self) -> NCollection_Sequence< IntSurf_PntOn2S >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntSurf.new_NCollection_Sequence_IntSurf_PntOn2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntSurf_PntOn2S self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntSurf_PntOn2S self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntSurf_PntOn2S self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntSurf_PntOn2S self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntSurf_PntOn2S self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntSurf_PntOn2S self)

        Reverse sequence


        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntSurf_PntOn2S self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence_IntSurf_PntOn2S theOther) -> NCollection_Sequence_IntSurf_PntOn2S

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence_IntSurf_PntOn2S theOther) -> NCollection_Sequence_IntSurf_PntOn2S

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence< IntSurf_PntOn2S >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntSurf_PntOn2S self, IntSurf_PntOn2S theItem)
        Append(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence_IntSurf_PntOn2S theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntSurf_PntOn2S self, IntSurf_PntOn2S theItem)
        Prepend(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence_IntSurf_PntOn2S theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, IntSurf_PntOn2S theItem)
        InsertBefore(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PntOn2S theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntSurf_PntOn2S self, NCollection_Sequence< IntSurf_PntOn2S >::Iterator & thePosition, IntSurf_PntOn2S theItem)
        InsertAfter(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PntOn2S theSeq)
        InsertAfter(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, IntSurf_PntOn2S theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PntOn2S theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntSurf_PntOn2S self) -> IntSurf_PntOn2S

        First item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntSurf_PntOn2S self) -> IntSurf_PntOn2S

        Last item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex) -> IntSurf_PntOn2S

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntSurf_PntOn2S self, Standard_Integer const theIndex, IntSurf_PntOn2S theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_SetValue(self, *args)


    def __iter__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S___iter__(self)
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_PntOn2S
NCollection_Sequence_IntSurf_PntOn2S_swigregister = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_swigregister
NCollection_Sequence_IntSurf_PntOn2S_swigregister(NCollection_Sequence_IntSurf_PntOn2S)

def NCollection_Sequence_IntSurf_PntOn2S_delNode(*args):
    """
    NCollection_Sequence_IntSurf_PntOn2S_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_delNode(*args)

class NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntSurf.new_NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper

    def __next__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper___next__(self)
NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper_swigregister = _IntSurf.NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper_swigregister
NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper_swigregister(NCollection_Sequence_IntSurf_PntOn2S_IteratorHelper)


try:
	IntSurf_SequenceOfPntOn2S = NCollection_Sequence_IntSurf_PntOn2S
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_IntSurf_PathPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntSurf_PathPoint self) -> NCollection_Sequence< IntSurf_PathPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntSurf_PathPoint self) -> NCollection_Sequence< IntSurf_PathPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntSurf_PathPoint self) -> NCollection_Sequence< IntSurf_PathPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntSurf_PathPoint self) -> NCollection_Sequence< IntSurf_PathPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntSurf.new_NCollection_Sequence_IntSurf_PathPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntSurf_PathPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntSurf_PathPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntSurf_PathPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntSurf_PathPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntSurf_PathPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntSurf_PathPoint self)

        Reverse sequence


        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntSurf_PathPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence_IntSurf_PathPoint theOther) -> NCollection_Sequence_IntSurf_PathPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence_IntSurf_PathPoint theOther) -> NCollection_Sequence_IntSurf_PathPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence< IntSurf_PathPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntSurf_PathPoint self, IntSurf_PathPoint theItem)
        Append(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence_IntSurf_PathPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntSurf_PathPoint self, IntSurf_PathPoint theItem)
        Prepend(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence_IntSurf_PathPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, IntSurf_PathPoint theItem)
        InsertBefore(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PathPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntSurf_PathPoint self, NCollection_Sequence< IntSurf_PathPoint >::Iterator & thePosition, IntSurf_PathPoint theItem)
        InsertAfter(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PathPoint theSeq)
        InsertAfter(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, IntSurf_PathPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntSurf_PathPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PathPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntSurf_PathPoint self) -> IntSurf_PathPoint

        First item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntSurf_PathPoint self) -> IntSurf_PathPoint

        Last item access

        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PathPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex) -> IntSurf_PathPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntSurf.NCollection_Sequence_IntSurf_PathPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntSurf_PathPoint self, Standard_Integer const theIndex, IntSurf_PathPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_SetValue(self, *args)


    def __iter__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint___iter__(self)
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_PathPoint
NCollection_Sequence_IntSurf_PathPoint_swigregister = _IntSurf.NCollection_Sequence_IntSurf_PathPoint_swigregister
NCollection_Sequence_IntSurf_PathPoint_swigregister(NCollection_Sequence_IntSurf_PathPoint)

def NCollection_Sequence_IntSurf_PathPoint_delNode(*args):
    """
    NCollection_Sequence_IntSurf_PathPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_delNode(*args)

class NCollection_Sequence_IntSurf_PathPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntSurf.new_NCollection_Sequence_IntSurf_PathPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_NCollection_Sequence_IntSurf_PathPoint_IteratorHelper

    def __next__(self):
        return _IntSurf.NCollection_Sequence_IntSurf_PathPoint_IteratorHelper___next__(self)
NCollection_Sequence_IntSurf_PathPoint_IteratorHelper_swigregister = _IntSurf.NCollection_Sequence_IntSurf_PathPoint_IteratorHelper_swigregister
NCollection_Sequence_IntSurf_PathPoint_IteratorHelper_swigregister(NCollection_Sequence_IntSurf_PathPoint_IteratorHelper)


try:
	IntSurf_SequenceOfPathPoint = NCollection_Sequence_IntSurf_PathPoint
except NameError:
	pass # does not exist, probably ignored

class IntSurf_(object):
    """
    This package provides resources for
    all the packages concerning the intersection
    between surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeTransition(*args):
        """
        MakeTransition(gp_Vec TgFirst, gp_Vec TgSecond, gp_Dir Normal, IntSurf_Transition TFirst, IntSurf_Transition TSecond)

        Computes the transition of the intersection point
        between the two lines.
        TgFirst is the tangent vector of the first line.
        TgSecond is the tangent vector of the second line.
        Normal is the direction used to orientate the cross
        product TgFirst^TgSecond.
        TFirst is the transition of the point on the first line.
        TSecond is the transition of the point on the second line.

        :type TgFirst: OCC.wrapper.gp.gp_Vec
        :type TgSecond: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Dir
        :type TFirst: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TSecond: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _IntSurf.IntSurf__MakeTransition(*args)

    MakeTransition = staticmethod(MakeTransition)

    def SetPeriod(*args):
        """
        SetPeriod(Handle_Adaptor3d_HSurface theFirstSurf, Handle_Adaptor3d_HSurface theSecondSurf, Standard_Real * theArrOfPeriod)

        Fills theArrOfPeriod array by the period values of theFirstSurf and theSecondSurf.
        [0] = U-period of theFirstSurf,
        [1] = V-period of theFirstSurf,
        [2] = U-period of theSecondSurf,
        [3] = V-period of theSecondSurf.

        If surface is not periodic in correspond direction then
        its period is considered to be equal to 0.

        :type theFirstSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theSecondSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theArrOfPeriod: OCC.wrapper.Standard.Standard_Real [4]

        """
        return _IntSurf.IntSurf__SetPeriod(*args)

    SetPeriod = staticmethod(SetPeriod)

    def __init__(self):
        """
        This package provides resources for
        all the packages concerning the intersection
        between surfaces.
        """
        this = _IntSurf.new_IntSurf_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntSurf.delete_IntSurf_
IntSurf__swigregister = _IntSurf.IntSurf__swigregister
IntSurf__swigregister(IntSurf_)

def IntSurf__MakeTransition(*args):
    """
    IntSurf__MakeTransition(gp_Vec TgFirst, gp_Vec TgSecond, gp_Dir Normal, IntSurf_Transition TFirst, IntSurf_Transition TSecond)

    Computes the transition of the intersection point
    between the two lines.
    TgFirst is the tangent vector of the first line.
    TgSecond is the tangent vector of the second line.
    Normal is the direction used to orientate the cross
    product TgFirst^TgSecond.
    TFirst is the transition of the point on the first line.
    TSecond is the transition of the point on the second line.

    :type TgFirst: OCC.wrapper.gp.gp_Vec
    :type TgSecond: OCC.wrapper.gp.gp_Vec
    :type Normal: OCC.wrapper.gp.gp_Dir
    :type TFirst: OCC.wrapper.IntSurf.IntSurf_Transition
    :type TSecond: OCC.wrapper.IntSurf.IntSurf_Transition

    """
    return _IntSurf.IntSurf__MakeTransition(*args)

def IntSurf__SetPeriod(*args):
    """
    IntSurf__SetPeriod(Handle_Adaptor3d_HSurface theFirstSurf, Handle_Adaptor3d_HSurface theSecondSurf, Standard_Real * theArrOfPeriod)

    Fills theArrOfPeriod array by the period values of theFirstSurf and theSecondSurf.
    [0] = U-period of theFirstSurf,
    [1] = V-period of theFirstSurf,
    [2] = U-period of theSecondSurf,
    [3] = V-period of theSecondSurf.

    If surface is not periodic in correspond direction then
    its period is considered to be equal to 0.

    :type theFirstSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theSecondSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theArrOfPeriod: OCC.wrapper.Standard.Standard_Real [4]

    """
    return _IntSurf.IntSurf__SetPeriod(*args)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Expr')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Expr')
    _Expr = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Expr', [dirname(__file__)])
        except ImportError:
            import _Expr
            return _Expr
        try:
            _mod = imp.load_module('_Expr', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Expr = swig_import_helper()
    del swig_import_helper
else:
    import _Expr
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Expr.delete_SwigPyIterator

    def value(self):
        return _Expr.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Expr.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Expr.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Expr.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Expr.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Expr.SwigPyIterator_copy(self)

    def next(self):
        return _Expr.SwigPyIterator_next(self)

    def __next__(self):
        return _Expr.SwigPyIterator___next__(self)

    def previous(self):
        return _Expr.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Expr.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Expr.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Expr.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Expr.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Expr.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Expr.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Expr.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Expr.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Expr.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Expr.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Expr.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Expr.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Expr.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Expr.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Expr.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Expr.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Expr.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Expr.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Expr.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Expr.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Expr.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Expr.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Expr.ptr_to_number(item)
ptr_to_number = _Expr.ptr_to_number

def HashCode(*args):
    return _Expr.HashCode(*args)
HashCode = _Expr.HashCode

def ptr_equal(a, b):
    return _Expr.ptr_equal(a, b)
ptr_equal = _Expr.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class Expr_GeneralRelation(Standard.Standard_Transient):
    """
    Defines the general purposes of any relation between
    expressions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_GeneralRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_GeneralRelation(self) 
            return h


    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_GeneralRelation self) -> Standard_Boolean

        Returns the current status of the relation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralRelation_IsSatisfied(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_GeneralRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralRelation_IsLinear(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GeneralRelation_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_GeneralRelation self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_GeneralRelation_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GeneralRelation_Copy(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Expr_GeneralRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_GeneralRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Expr_GeneralRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_GeneralRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Expr_GeneralRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if <index> is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GeneralRelation_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_GeneralRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> contains <var>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_GeneralRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralRelation_Replace(self, *args)


    def String(self, *args):
        """
        String(Expr_GeneralRelation self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_GeneralRelation_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_GeneralRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_GeneralRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_GeneralRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_GeneralRelation
Expr_GeneralRelation_swigregister = _Expr.Expr_GeneralRelation_swigregister
Expr_GeneralRelation_swigregister(Expr_GeneralRelation)

def Expr_GeneralRelation_get_type_name(*args):
    """
    Expr_GeneralRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_GeneralRelation_get_type_name(*args)

def Expr_GeneralRelation_get_type_descriptor(*args):
    """
    Expr_GeneralRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_GeneralRelation_get_type_descriptor(*args)

class Expr_SingleRelation(Expr_GeneralRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_SingleRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_SingleRelation(self) 
            return h


    def SetFirstMember(self, *args):
        """
        SetFirstMember(Expr_SingleRelation self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SingleRelation_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Expr_SingleRelation self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SingleRelation_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Expr_SingleRelation self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SingleRelation_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Expr_SingleRelation self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SingleRelation_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_SingleRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SingleRelation_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Expr_SingleRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_SingleRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Expr_SingleRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_SingleRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Expr_SingleRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SingleRelation_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_SingleRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SingleRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_SingleRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SingleRelation_Replace(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_SingleRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_SingleRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_SingleRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_SingleRelation
Expr_SingleRelation_swigregister = _Expr.Expr_SingleRelation_swigregister
Expr_SingleRelation_swigregister(Expr_SingleRelation)

def Expr_SingleRelation_get_type_name(*args):
    """
    Expr_SingleRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_SingleRelation_get_type_name(*args)

def Expr_SingleRelation_get_type_descriptor(*args):
    """
    Expr_SingleRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_SingleRelation_get_type_descriptor(*args)

class Expr_GeneralExpression(Standard.Standard_Transient):
    """Defines the general purposes of any expression."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_GeneralExpression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_GeneralExpression(self) 
            return h


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_GeneralExpression self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_GeneralExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_GeneralExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> contains NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_GeneralExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralExpression_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralExpression_IsLinear(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_GeneralExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        Warning: This method does not include any simplification before
        testing. It could also be very slow; to be used
        carefully.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralExpression_IsIdentical(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_GeneralExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_GeneralExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_GeneralExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with copies of <with>
        in <me>. Copies of <with> are made with the Copy() method.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_GeneralExpression_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_GeneralExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Expr_GeneralExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_GeneralExpression_EvaluateNumeric(self, *args)


    def String(self, *args):
        """
        String(Expr_GeneralExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_GeneralExpression_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_GeneralExpression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_GeneralExpression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_GeneralExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_GeneralExpression
Expr_GeneralExpression_swigregister = _Expr.Expr_GeneralExpression_swigregister
Expr_GeneralExpression_swigregister(Expr_GeneralExpression)

def Expr_GeneralExpression_get_type_name(*args):
    """
    Expr_GeneralExpression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_GeneralExpression_get_type_name(*args)

def Expr_GeneralExpression_get_type_descriptor(*args):
    """
    Expr_GeneralExpression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_GeneralExpression_get_type_descriptor(*args)

class Expr_UnaryExpression(Expr_GeneralExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_UnaryExpression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_UnaryExpression(self) 
            return h


    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_UnaryExpression_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Expr_UnaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryExpression_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_UnaryExpression self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_UnaryExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_UnaryExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_UnaryExpression self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_UnaryExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_UnaryExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_UnaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryExpression_Simplified(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_UnaryExpression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_UnaryExpression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_UnaryExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_UnaryExpression
Expr_UnaryExpression_swigregister = _Expr.Expr_UnaryExpression_swigregister
Expr_UnaryExpression_swigregister(Expr_UnaryExpression)

def Expr_UnaryExpression_get_type_name(*args):
    """
    Expr_UnaryExpression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_UnaryExpression_get_type_name(*args)

def Expr_UnaryExpression_get_type_descriptor(*args):
    """
    Expr_UnaryExpression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_UnaryExpression_get_type_descriptor(*args)

class Expr_GreaterThan(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_GreaterThan
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_GreaterThan(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_GreaterThan self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_GreaterThan

        Creates the relation <exp1> > <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_GreaterThan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_GreaterThan self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GreaterThan_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_GreaterThan self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GreaterThan_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_GreaterThan self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_GreaterThan_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_GreaterThan self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GreaterThan_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_GreaterThan self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_GreaterThan_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_GreaterThan_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_GreaterThan_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_GreaterThan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_GreaterThan
Expr_GreaterThan_swigregister = _Expr.Expr_GreaterThan_swigregister
Expr_GreaterThan_swigregister(Expr_GreaterThan)

def Expr_GreaterThan_get_type_name(*args):
    """
    Expr_GreaterThan_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_GreaterThan_get_type_name(*args)

def Expr_GreaterThan_get_type_descriptor(*args):
    """
    Expr_GreaterThan_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_GreaterThan_get_type_descriptor(*args)

class Expr_LessThan(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_LessThan
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_LessThan(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_LessThan self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_LessThan

        Creates the relation <exp1> < <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_LessThan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_LessThan self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LessThan_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_LessThan self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_LessThan_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_LessThan self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_LessThan_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_LessThan self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_LessThan_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_LessThan self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_LessThan_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_LessThan_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_LessThan_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_LessThan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_LessThan
Expr_LessThan_swigregister = _Expr.Expr_LessThan_swigregister
Expr_LessThan_swigregister(Expr_LessThan)

def Expr_LessThan_get_type_name(*args):
    """
    Expr_LessThan_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_LessThan_get_type_name(*args)

def Expr_LessThan_get_type_descriptor(*args):
    """
    Expr_LessThan_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_LessThan_get_type_descriptor(*args)

class Expr_PolyExpression(Expr_GeneralExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_PolyExpression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_PolyExpression(self) 
            return h


    def NbOperands(self, *args):
        """
        NbOperands(Expr_PolyExpression self) -> Standard_Integer

        returns the number of operands contained in <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_PolyExpression_NbOperands(self, *args)


    def Operand(self, *args):
        """
        Returns the <index>-th operand used in <me>.
        An exception is raised if index is out of range

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_PolyExpression_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Expr_PolyExpression self, Handle_Expr_GeneralExpression exp, Standard_Integer const index)

        Sets the <index>-th operand used in <me>.
        An exception is raised if <index> is out of range
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type index: int

        """
        return _Expr.Expr_PolyExpression_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_PolyExpression self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 2)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_PolyExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the sub-expression denoted by <I> in <me>
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_PolyExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_PolyExpression self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_PolyExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_PolyExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_PolyExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_PolyExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_PolyExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_PolyExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_PolyExpression_Simplified(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_PolyExpression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_PolyExpression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_PolyExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_PolyExpression
Expr_PolyExpression_swigregister = _Expr.Expr_PolyExpression_swigregister
Expr_PolyExpression_swigregister(Expr_PolyExpression)

def Expr_PolyExpression_get_type_name(*args):
    """
    Expr_PolyExpression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_PolyExpression_get_type_name(*args)

def Expr_PolyExpression_get_type_descriptor(*args):
    """
    Expr_PolyExpression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_PolyExpression_get_type_descriptor(*args)

class Expr_ExprFailure(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ExprFailure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ExprFailure(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ExprFailure self) -> Expr_ExprFailure
        __init__(Expr_ExprFailure self, Standard_CString const theMessage) -> Expr_ExprFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_ExprFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_ExprFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_ExprFailure

        """
        return _Expr.Expr_ExprFailure_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ExprFailure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ExprFailure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ExprFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ExprFailure
Expr_ExprFailure_swigregister = _Expr.Expr_ExprFailure_swigregister
Expr_ExprFailure_swigregister(Expr_ExprFailure)

def Expr_ExprFailure_NewInstance(*args):
    """
    Expr_ExprFailure_NewInstance(Standard_CString const theMessage) -> Handle_Expr_ExprFailure

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_ExprFailure

    """
    return _Expr.Expr_ExprFailure_NewInstance(*args)

def Expr_ExprFailure_get_type_name(*args):
    """
    Expr_ExprFailure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ExprFailure_get_type_name(*args)

def Expr_ExprFailure_get_type_descriptor(*args):
    """
    Expr_ExprFailure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ExprFailure_get_type_descriptor(*args)

class Expr_NotAssigned(Expr_ExprFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NotAssigned
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NotAssigned(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NotAssigned self) -> Expr_NotAssigned
        __init__(Expr_NotAssigned self, Standard_CString const theMessage) -> Expr_NotAssigned

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_NotAssigned(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_NotAssigned

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NotAssigned

        """
        return _Expr.Expr_NotAssigned_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NotAssigned_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NotAssigned_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NotAssigned_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NotAssigned
Expr_NotAssigned_swigregister = _Expr.Expr_NotAssigned_swigregister
Expr_NotAssigned_swigregister(Expr_NotAssigned)

def Expr_NotAssigned_NewInstance(*args):
    """
    Expr_NotAssigned_NewInstance(Standard_CString const theMessage) -> Handle_Expr_NotAssigned

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_NotAssigned

    """
    return _Expr.Expr_NotAssigned_NewInstance(*args)

def Expr_NotAssigned_get_type_name(*args):
    """
    Expr_NotAssigned_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NotAssigned_get_type_name(*args)

def Expr_NotAssigned_get_type_descriptor(*args):
    """
    Expr_NotAssigned_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NotAssigned_get_type_descriptor(*args)

class Expr_BinaryExpression(Expr_GeneralExpression):
    """
    Defines all binary expressions. The order of the two
    operands is significant.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_BinaryExpression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_BinaryExpression(self) 
            return h


    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_BinaryExpression_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_BinaryExpression_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryExpression_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryExpression_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_BinaryExpression self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_BinaryExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_BinaryExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_BinaryExpression self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_BinaryExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_BinaryExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_BinaryExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_BinaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryExpression_Simplified(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_BinaryExpression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_BinaryExpression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_BinaryExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_BinaryExpression
Expr_BinaryExpression_swigregister = _Expr.Expr_BinaryExpression_swigregister
Expr_BinaryExpression_swigregister(Expr_BinaryExpression)

def Expr_BinaryExpression_get_type_name(*args):
    """
    Expr_BinaryExpression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_BinaryExpression_get_type_name(*args)

def Expr_BinaryExpression_get_type_descriptor(*args):
    """
    Expr_BinaryExpression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_BinaryExpression_get_type_descriptor(*args)

class Expr_Product(Expr_PolyExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Product
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Product(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Product self, NCollection_Sequence_Handle_Expr_GeneralExpression exps) -> Expr_Product
        __init__(Expr_Product self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Product

        Creates the product of <exp1> and <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Product(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Product self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Product_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Product self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Product_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Product self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Product_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Product self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Product_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Product self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Product_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Product self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Product_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Product self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Product_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Product_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Product_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Product_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Product
Expr_Product_swigregister = _Expr.Expr_Product_swigregister
Expr_Product_swigregister(Expr_Product)

def Expr_Product_get_type_name(*args):
    """
    Expr_Product_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Product_get_type_name(*args)

def Expr_Product_get_type_descriptor(*args):
    """
    Expr_Product_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Product_get_type_descriptor(*args)

class Expr_InvalidOperand(Expr_ExprFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_InvalidOperand
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_InvalidOperand(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_InvalidOperand self) -> Expr_InvalidOperand
        __init__(Expr_InvalidOperand self, Standard_CString const theMessage) -> Expr_InvalidOperand

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_InvalidOperand(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidOperand

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidOperand

        """
        return _Expr.Expr_InvalidOperand_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_InvalidOperand_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_InvalidOperand_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_InvalidOperand_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_InvalidOperand
Expr_InvalidOperand_swigregister = _Expr.Expr_InvalidOperand_swigregister
Expr_InvalidOperand_swigregister(Expr_InvalidOperand)

def Expr_InvalidOperand_NewInstance(*args):
    """
    Expr_InvalidOperand_NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidOperand

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidOperand

    """
    return _Expr.Expr_InvalidOperand_NewInstance(*args)

def Expr_InvalidOperand_get_type_name(*args):
    """
    Expr_InvalidOperand_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_InvalidOperand_get_type_name(*args)

def Expr_InvalidOperand_get_type_descriptor(*args):
    """
    Expr_InvalidOperand_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_InvalidOperand_get_type_descriptor(*args)

class Expr_Tangent(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Tangent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Tangent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Tangent self, Handle_Expr_GeneralExpression exp) -> Expr_Tangent

        Creates the tangent of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Tangent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Tangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tangent_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Tangent self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tangent_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Tangent self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Tangent_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Tangent self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Tangent_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Tangent self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tangent_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Tangent self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Tangent_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Tangent self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Tangent_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Tangent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Tangent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Tangent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Tangent
Expr_Tangent_swigregister = _Expr.Expr_Tangent_swigregister
Expr_Tangent_swigregister(Expr_Tangent)

def Expr_Tangent_get_type_name(*args):
    """
    Expr_Tangent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Tangent_get_type_name(*args)

def Expr_Tangent_get_type_descriptor(*args):
    """
    Expr_Tangent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Tangent_get_type_descriptor(*args)

class Expr_SystemRelation(Expr_GeneralRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_SystemRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_SystemRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_SystemRelation self, Handle_Expr_GeneralRelation relation) -> Expr_SystemRelation

        Creates a system with one relation

        :type relation: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        this = _Expr.new_Expr_SystemRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(Expr_SystemRelation self, Handle_Expr_GeneralRelation relation)

        Appends <relation> in the list of components of <me>.

        :type relation: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SystemRelation_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Expr_SystemRelation self, Handle_Expr_GeneralRelation relation)

        :type relation: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SystemRelation_Remove(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_SystemRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SystemRelation_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Expr_SystemRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_SystemRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Expr_SystemRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_SystemRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Expr_SystemRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if <index> is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SystemRelation_SubRelation(self, *args)


    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_SystemRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SystemRelation_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_SystemRelation self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SystemRelation_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_SystemRelation self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_SystemRelation_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_SystemRelation self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_SystemRelation_Copy(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_SystemRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SystemRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_SystemRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SystemRelation_Replace(self, *args)


    def String(self, *args):
        """
        String(Expr_SystemRelation self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_SystemRelation_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_SystemRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_SystemRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_SystemRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_SystemRelation
Expr_SystemRelation_swigregister = _Expr.Expr_SystemRelation_swigregister
Expr_SystemRelation_swigregister(Expr_SystemRelation)

def Expr_SystemRelation_get_type_name(*args):
    """
    Expr_SystemRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_SystemRelation_get_type_name(*args)

def Expr_SystemRelation_get_type_descriptor(*args):
    """
    Expr_SystemRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_SystemRelation_get_type_descriptor(*args)

class Expr_ArgTanh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArgTanh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArgTanh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArgTanh self, Handle_Expr_GeneralExpression exp) -> Expr_ArgTanh

        Creates the Argtanh of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArgTanh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArgTanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgTanh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArgTanh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgTanh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArgTanh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgTanh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArgTanh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgTanh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArgTanh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgTanh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArgTanh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArgTanh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArgTanh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArgTanh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArgTanh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArgTanh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArgTanh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArgTanh
Expr_ArgTanh_swigregister = _Expr.Expr_ArgTanh_swigregister
Expr_ArgTanh_swigregister(Expr_ArgTanh)

def Expr_ArgTanh_get_type_name(*args):
    """
    Expr_ArgTanh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArgTanh_get_type_name(*args)

def Expr_ArgTanh_get_type_descriptor(*args):
    """
    Expr_ArgTanh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArgTanh_get_type_descriptor(*args)

class Expr_Division(Expr_BinaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Division
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Division(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Division self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Division

        Creates the division <exp1>/<exp2>

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Division(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Division self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Division_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Division self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Division_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Division self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Division_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Division self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Division_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Division self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Division_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Division self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Division_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Division self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Division_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Division_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Division_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Division_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Division
Expr_Division_swigregister = _Expr.Expr_Division_swigregister
Expr_Division_swigregister(Expr_Division)

def Expr_Division_get_type_name(*args):
    """
    Expr_Division_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Division_get_type_name(*args)

def Expr_Division_get_type_descriptor(*args):
    """
    Expr_Division_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Division_get_type_descriptor(*args)

class Expr_Sign(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Sign
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Sign(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Sign self, Handle_Expr_GeneralExpression exp) -> Expr_Sign

        Creates the sign of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Sign(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Sign self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sign_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Sign self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sign_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Sign self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sign_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Sign self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sign_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Sign self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sign_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Sign self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Sign_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Sign self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Sign_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Sign_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Sign_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Sign_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Sign
Expr_Sign_swigregister = _Expr.Expr_Sign_swigregister
Expr_Sign_swigregister(Expr_Sign)

def Expr_Sign_get_type_name(*args):
    """
    Expr_Sign_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Sign_get_type_name(*args)

def Expr_Sign_get_type_descriptor(*args):
    """
    Expr_Sign_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Sign_get_type_descriptor(*args)

class Expr_Difference(Expr_BinaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Difference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Difference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Difference self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Difference

        Creates the difference <exp1> - <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Difference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Difference self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Difference_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Difference self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Difference_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Difference self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Difference_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Difference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Difference_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Difference self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Difference_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_Difference self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Difference_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Difference self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Difference_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Difference self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Difference_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Difference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Difference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Difference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Difference
Expr_Difference_swigregister = _Expr.Expr_Difference_swigregister
Expr_Difference_swigregister(Expr_Difference)

def Expr_Difference_get_type_name(*args):
    """
    Expr_Difference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Difference_get_type_name(*args)

def Expr_Difference_get_type_descriptor(*args):
    """
    Expr_Difference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Difference_get_type_descriptor(*args)

class Expr_GeneralFunction(Standard.Standard_Transient):
    """Defines the general purposes of any function."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_GeneralFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_GeneralFunction(self) 
            return h


    def NbOfVariables(self, *args):
        """
        NbOfVariables(Expr_GeneralFunction self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_GeneralFunction_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Expr_GeneralFunction self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if index > NbOfVariables.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_GeneralFunction_Variable(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_GeneralFunction self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_GeneralFunction_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_GeneralFunction self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Expr_GeneralFunction self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_GeneralFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_GeneralFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises NotEvaluable if <vars> does not match all variables
        of <me>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_GeneralFunction_Evaluate(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_GeneralFunction self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralFunction_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Expr_GeneralFunction self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GeneralFunction_IsLinearOnVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Expr_GeneralFunction self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_GeneralFunction_GetStringName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_GeneralFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_GeneralFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_GeneralFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_GeneralFunction
Expr_GeneralFunction_swigregister = _Expr.Expr_GeneralFunction_swigregister
Expr_GeneralFunction_swigregister(Expr_GeneralFunction)

def Expr_GeneralFunction_get_type_name(*args):
    """
    Expr_GeneralFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_GeneralFunction_get_type_name(*args)

def Expr_GeneralFunction_get_type_descriptor(*args):
    """
    Expr_GeneralFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_GeneralFunction_get_type_descriptor(*args)

class Expr_ArcSine(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArcSine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArcSine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArcSine self, Handle_Expr_GeneralExpression exp) -> Expr_ArcSine

        Creates the Arcsin of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArcSine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArcSine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcSine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArcSine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcSine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArcSine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcSine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArcSine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcSine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArcSine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcSine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArcSine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArcSine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArcSine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArcSine_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArcSine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArcSine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArcSine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArcSine
Expr_ArcSine_swigregister = _Expr.Expr_ArcSine_swigregister
Expr_ArcSine_swigregister(Expr_ArcSine)

def Expr_ArcSine_get_type_name(*args):
    """
    Expr_ArcSine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArcSine_get_type_name(*args)

def Expr_ArcSine_get_type_descriptor(*args):
    """
    Expr_ArcSine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArcSine_get_type_descriptor(*args)

class Expr_RUIterator(object):
    """Iterates on NamedUnknowns in a GeneralRelation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Expr_RUIterator self, Handle_Expr_GeneralRelation rel) -> Expr_RUIterator

        Creates an iterator on every NamedUnknown contained in
        <rel>.

        :type rel: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        this = _Expr.new_Expr_RUIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(Expr_RUIterator self) -> Standard_Boolean

        Returns False if on other unknown remains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_RUIterator_More(self, *args)


    def Next(self, *args):
        """Next(Expr_RUIterator self)"""
        return _Expr.Expr_RUIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Expr_RUIterator self) -> Handle_Expr_NamedUnknown

        Returns current NamedUnknown.
        Raises exception if no more unknowns remain.

        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_RUIterator_Value(self, *args)

    __swig_destroy__ = _Expr.delete_Expr_RUIterator
Expr_RUIterator_swigregister = _Expr.Expr_RUIterator_swigregister
Expr_RUIterator_swigregister(Expr_RUIterator)

class Handle_Expr_LessThan(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_LessThan self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_LessThan_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_LessThan self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_LessThan_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_LessThan self, Expr_LessThan thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_LessThan_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_LessThan self, Handle_Expr_LessThan theHandle) -> Handle_Expr_LessThan
        assign(Handle_Expr_LessThan self, Expr_LessThan thePtr) -> Handle_Expr_LessThan
        assign(Handle_Expr_LessThan self, Handle_Expr_LessThan theHandle) -> Handle_Expr_LessThan

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_LessThan_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_LessThan self) -> Expr_LessThan

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_LessThan_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_LessThan self) -> Expr_LessThan

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_LessThan___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_LessThan self) -> Expr_LessThan

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_LessThan___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_LessThan___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_LessThan___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_LessThan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_LessThan_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_LessThan

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_LessThan self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThan_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_LessThan self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThan_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_LessThan self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_LessThan_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_LessThan self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThan_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_LessThan self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_LessThan_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_LessThan self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_LessThan_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LessThan_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LessThan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_LessThan self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThan_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_LessThan self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThan_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_LessThan self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThan_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_LessThan self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThan_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_LessThan self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThan_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_LessThan self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThan_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_LessThan self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThan_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_LessThan self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThan_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_LessThan self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThan_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_LessThan self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThan_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_LessThan self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_LessThan_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_LessThan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_LessThan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThan_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_LessThan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_LessThan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThan_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_LessThan self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_LessThan_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_LessThan self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThan_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_LessThan self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_LessThan_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_LessThan self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThan_DecrementRefCounter(self, *args)

Handle_Expr_LessThan_swigregister = _Expr.Handle_Expr_LessThan_swigregister
Handle_Expr_LessThan_swigregister(Handle_Expr_LessThan)

def Handle_Expr_LessThan_DownCast(thing):
    return _Expr.Handle_Expr_LessThan_DownCast(thing)
Handle_Expr_LessThan_DownCast = _Expr.Handle_Expr_LessThan_DownCast

class Expr_NamedFunction(Expr_GeneralFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NamedFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NamedFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NamedFunction self, TCollection_AsciiString name, Handle_Expr_GeneralExpression exp, NCollection_Array1_Handle_Expr_NamedUnknown vars) -> Expr_NamedFunction

        Creates a function of given variables <vars> with name
        <name> defined by the expression <exp>.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown

        """
        this = _Expr.new_Expr_NamedFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetName(self, *args):
        """
        SetName(Expr_NamedFunction self, TCollection_AsciiString newname)

        Sets the name <newname> to <me>.

        :type newname: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NamedFunction_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(Expr_NamedFunction self) -> TCollection_AsciiString

        Returns the name assigned to <me>

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NamedFunction_GetName(self, *args)


    def NbOfVariables(self, *args):
        """
        NbOfVariables(Expr_NamedFunction self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_NamedFunction_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Expr_NamedFunction self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if <index> is greater than
        NbOfVariables of <me>, or less than or equal to zero.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_NamedFunction_Variable(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_NamedFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real values) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises DimensionMismatch if Length(vars) is different from
        Length(values).

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type values: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NamedFunction_Evaluate(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_NamedFunction self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_NamedFunction_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_NamedFunction self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Expr_NamedFunction self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_NamedFunction_Derivative(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_NamedFunction self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedFunction_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Expr_NamedFunction self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedFunction_IsLinearOnVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Expr_NamedFunction self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NamedFunction_GetStringName(self, *args)


    def Expression(self, *args):
        """
        Expression(Expr_NamedFunction self) -> Handle_Expr_GeneralExpression

        Returns equivalent expression of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedFunction_Expression(self, *args)


    def SetExpression(self, *args):
        """
        SetExpression(Expr_NamedFunction self, Handle_Expr_GeneralExpression exp)

        Modifies expression of <me>.
        Warning: Beware of derivatives. See FunctionDerivative

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedFunction_SetExpression(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NamedFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NamedFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NamedFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NamedFunction
Expr_NamedFunction_swigregister = _Expr.Expr_NamedFunction_swigregister
Expr_NamedFunction_swigregister(Expr_NamedFunction)

def Expr_NamedFunction_get_type_name(*args):
    """
    Expr_NamedFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NamedFunction_get_type_name(*args)

def Expr_NamedFunction_get_type_descriptor(*args):
    """
    Expr_NamedFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NamedFunction_get_type_descriptor(*args)

class Handle_Expr_Tangent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Tangent self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Tangent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Tangent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Tangent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Tangent self, Expr_Tangent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Tangent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Tangent self, Handle_Expr_Tangent theHandle) -> Handle_Expr_Tangent
        assign(Handle_Expr_Tangent self, Expr_Tangent thePtr) -> Handle_Expr_Tangent
        assign(Handle_Expr_Tangent self, Handle_Expr_Tangent theHandle) -> Handle_Expr_Tangent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Tangent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Tangent self) -> Expr_Tangent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Tangent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Tangent self) -> Expr_Tangent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Tangent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Tangent self) -> Expr_Tangent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Tangent___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Tangent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Tangent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Tangent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Tangent_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Tangent

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Tangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Tangent self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Tangent self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Tangent self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Tangent self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Tangent self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Tangent_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Tangent self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Tangent_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Tangent self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Tangent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Tangent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Tangent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Tangent_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Tangent self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Tangent self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tangent_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Tangent_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Tangent self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Tangent self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Tangent self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Tangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Tangent self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Tangent self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tangent_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Tangent self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Tangent_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Tangent self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Tangent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Tangent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Tangent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Tangent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Tangent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tangent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Tangent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Tangent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Tangent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tangent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Tangent self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Tangent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Tangent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tangent_DecrementRefCounter(self, *args)

Handle_Expr_Tangent_swigregister = _Expr.Handle_Expr_Tangent_swigregister
Handle_Expr_Tangent_swigregister(Handle_Expr_Tangent)

def Handle_Expr_Tangent_DownCast(thing):
    return _Expr.Handle_Expr_Tangent_DownCast(thing)
Handle_Expr_Tangent_DownCast = _Expr.Handle_Expr_Tangent_DownCast

class Handle_Expr_GreaterThan(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_GreaterThan self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_GreaterThan_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_GreaterThan self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_GreaterThan_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_GreaterThan self, Expr_GreaterThan thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_GreaterThan_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_GreaterThan self, Handle_Expr_GreaterThan theHandle) -> Handle_Expr_GreaterThan
        assign(Handle_Expr_GreaterThan self, Expr_GreaterThan thePtr) -> Handle_Expr_GreaterThan
        assign(Handle_Expr_GreaterThan self, Handle_Expr_GreaterThan theHandle) -> Handle_Expr_GreaterThan

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_GreaterThan_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_GreaterThan self) -> Expr_GreaterThan

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_GreaterThan_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_GreaterThan self) -> Expr_GreaterThan

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_GreaterThan___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_GreaterThan self) -> Expr_GreaterThan

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_GreaterThan___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_GreaterThan___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_GreaterThan___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_GreaterThan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_GreaterThan_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_GreaterThan

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_GreaterThan self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThan_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_GreaterThan self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThan_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_GreaterThan self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_GreaterThan_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_GreaterThan self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThan_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_GreaterThan self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_GreaterThan_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_GreaterThan self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_GreaterThan_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GreaterThan_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GreaterThan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_GreaterThan self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThan_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_GreaterThan self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThan_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_GreaterThan self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThan_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_GreaterThan self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThan_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_GreaterThan self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThan_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_GreaterThan self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThan_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_GreaterThan self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThan_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_GreaterThan self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThan_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_GreaterThan self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThan_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_GreaterThan self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThan_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_GreaterThan self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_GreaterThan_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_GreaterThan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_GreaterThan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThan_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_GreaterThan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_GreaterThan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThan_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_GreaterThan self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_GreaterThan_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_GreaterThan self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThan_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_GreaterThan self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_GreaterThan_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_GreaterThan self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThan_DecrementRefCounter(self, *args)

Handle_Expr_GreaterThan_swigregister = _Expr.Handle_Expr_GreaterThan_swigregister
Handle_Expr_GreaterThan_swigregister(Handle_Expr_GreaterThan)

def Handle_Expr_GreaterThan_DownCast(thing):
    return _Expr.Handle_Expr_GreaterThan_DownCast(thing)
Handle_Expr_GreaterThan_DownCast = _Expr.Handle_Expr_GreaterThan_DownCast

class Expr_SquareRoot(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_SquareRoot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_SquareRoot(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_SquareRoot self, Handle_Expr_GeneralExpression exp) -> Expr_SquareRoot

        Creates the square root of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_SquareRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_SquareRoot self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SquareRoot_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_SquareRoot self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SquareRoot_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_SquareRoot self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SquareRoot_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_SquareRoot self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_SquareRoot_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_SquareRoot self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_SquareRoot_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_SquareRoot self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_SquareRoot_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_SquareRoot self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_SquareRoot_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_SquareRoot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_SquareRoot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_SquareRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_SquareRoot
Expr_SquareRoot_swigregister = _Expr.Expr_SquareRoot_swigregister
Expr_SquareRoot_swigregister(Expr_SquareRoot)

def Expr_SquareRoot_get_type_name(*args):
    """
    Expr_SquareRoot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_SquareRoot_get_type_name(*args)

def Expr_SquareRoot_get_type_descriptor(*args):
    """
    Expr_SquareRoot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_SquareRoot_get_type_descriptor(*args)

class Handle_Expr_Difference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Difference self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Difference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Difference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Difference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Difference self, Expr_Difference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Difference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Difference self, Handle_Expr_Difference theHandle) -> Handle_Expr_Difference
        assign(Handle_Expr_Difference self, Expr_Difference thePtr) -> Handle_Expr_Difference
        assign(Handle_Expr_Difference self, Handle_Expr_Difference theHandle) -> Handle_Expr_Difference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Difference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Difference self) -> Expr_Difference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Difference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Difference self) -> Expr_Difference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Difference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Difference self) -> Expr_Difference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Difference___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Difference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Difference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Difference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Difference_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Difference

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Difference self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Difference self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Difference self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Difference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Difference self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Difference self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Difference self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Difference_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Difference self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Difference_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Difference self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Difference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Difference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Difference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Difference_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Difference_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_Expr_Difference self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_Expr_Difference self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Difference self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Difference_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Difference_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Difference self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Difference self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Difference self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Difference self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Difference_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Difference self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_IsShareable(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Difference self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Difference_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Difference self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Difference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Difference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Difference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Difference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Difference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Difference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Difference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Difference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Difference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Difference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Difference self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Difference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Difference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Difference_DecrementRefCounter(self, *args)

Handle_Expr_Difference_swigregister = _Expr.Handle_Expr_Difference_swigregister
Handle_Expr_Difference_swigregister(Handle_Expr_Difference)

def Handle_Expr_Difference_DownCast(thing):
    return _Expr.Handle_Expr_Difference_DownCast(thing)
Handle_Expr_Difference_DownCast = _Expr.Handle_Expr_Difference_DownCast

class Expr_ArcTangent(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArcTangent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArcTangent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArcTangent self, Handle_Expr_GeneralExpression exp) -> Expr_ArcTangent

        Creates the Arctan of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArcTangent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArcTangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcTangent_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArcTangent self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcTangent_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArcTangent self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcTangent_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArcTangent self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcTangent_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArcTangent self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcTangent_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArcTangent self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArcTangent_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArcTangent self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArcTangent_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArcTangent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArcTangent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArcTangent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArcTangent
Expr_ArcTangent_swigregister = _Expr.Expr_ArcTangent_swigregister
Expr_ArcTangent_swigregister(Expr_ArcTangent)

def Expr_ArcTangent_get_type_name(*args):
    """
    Expr_ArcTangent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArcTangent_get_type_name(*args)

def Expr_ArcTangent_get_type_descriptor(*args):
    """
    Expr_ArcTangent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArcTangent_get_type_descriptor(*args)

class Handle_Expr_Sign(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Sign self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Sign_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Sign self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Sign_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Sign self, Expr_Sign thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Sign_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Sign self, Handle_Expr_Sign theHandle) -> Handle_Expr_Sign
        assign(Handle_Expr_Sign self, Expr_Sign thePtr) -> Handle_Expr_Sign
        assign(Handle_Expr_Sign self, Handle_Expr_Sign theHandle) -> Handle_Expr_Sign

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Sign_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Sign self) -> Expr_Sign

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sign_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Sign self) -> Expr_Sign

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sign___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Sign self) -> Expr_Sign

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Sign___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Sign___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Sign___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Sign(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Sign_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Sign

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Sign self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Sign self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Sign self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Sign self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Sign self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Sign self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sign_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Sign self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Sign_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Sign self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Sign_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sign_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sign_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sign_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Sign self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Sign self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sign_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sign_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Sign self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Sign self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Sign self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Sign self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Sign self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Sign self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sign_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Sign self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sign_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Sign self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Sign_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Sign self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Sign self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Sign self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Sign self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sign_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Sign self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Sign_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Sign self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sign_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Sign self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Sign_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Sign self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sign_DecrementRefCounter(self, *args)

Handle_Expr_Sign_swigregister = _Expr.Handle_Expr_Sign_swigregister
Handle_Expr_Sign_swigregister(Handle_Expr_Sign)

def Handle_Expr_Sign_DownCast(thing):
    return _Expr.Handle_Expr_Sign_DownCast(thing)
Handle_Expr_Sign_DownCast = _Expr.Handle_Expr_Sign_DownCast

class Handle_Expr_NotAssigned(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NotAssigned self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NotAssigned_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NotAssigned self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NotAssigned_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NotAssigned self, Expr_NotAssigned thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NotAssigned_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NotAssigned self, Handle_Expr_NotAssigned theHandle) -> Handle_Expr_NotAssigned
        assign(Handle_Expr_NotAssigned self, Expr_NotAssigned thePtr) -> Handle_Expr_NotAssigned
        assign(Handle_Expr_NotAssigned self, Handle_Expr_NotAssigned theHandle) -> Handle_Expr_NotAssigned

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NotAssigned_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NotAssigned self) -> Expr_NotAssigned

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NotAssigned_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NotAssigned self) -> Expr_NotAssigned

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NotAssigned___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NotAssigned self) -> Expr_NotAssigned

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NotAssigned___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NotAssigned___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NotAssigned___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NotAssigned(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NotAssigned_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NotAssigned

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_NotAssigned self, Standard_CString const theMessage) -> Handle_Expr_NotAssigned

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NotAssigned

        """
        return _Expr.Handle_Expr_NotAssigned_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NotAssigned self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NotAssigned_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NotAssigned_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NotAssigned_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_NotAssigned self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_NotAssigned_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_NotAssigned self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_NotAssigned_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_NotAssigned self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_NotAssigned_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_NotAssigned self)
        Reraise(Handle_Expr_NotAssigned self, Standard_CString const aMessage)
        Reraise(Handle_Expr_NotAssigned self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_NotAssigned_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_NotAssigned self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_NotAssigned_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_NotAssigned self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_NotAssigned_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NotAssigned self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NotAssigned_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NotAssigned self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NotAssigned self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NotAssigned_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NotAssigned self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NotAssigned self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NotAssigned_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NotAssigned self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NotAssigned_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NotAssigned self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NotAssigned_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NotAssigned self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NotAssigned_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NotAssigned self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NotAssigned_DecrementRefCounter(self, *args)

Handle_Expr_NotAssigned_swigregister = _Expr.Handle_Expr_NotAssigned_swigregister
Handle_Expr_NotAssigned_swigregister(Handle_Expr_NotAssigned)

def Handle_Expr_NotAssigned_DownCast(thing):
    return _Expr.Handle_Expr_NotAssigned_DownCast(thing)
Handle_Expr_NotAssigned_DownCast = _Expr.Handle_Expr_NotAssigned_DownCast

class Handle_Expr_Product(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Product self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Product_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Product self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Product_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Product self, Expr_Product thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Product_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Product self, Handle_Expr_Product theHandle) -> Handle_Expr_Product
        assign(Handle_Expr_Product self, Expr_Product thePtr) -> Handle_Expr_Product
        assign(Handle_Expr_Product self, Handle_Expr_Product theHandle) -> Handle_Expr_Product

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Product_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Product self) -> Expr_Product

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Product_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Product self) -> Expr_Product

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Product___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Product self) -> Expr_Product

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Product___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Product___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Product___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Product(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Product_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Product

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Product self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Product self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Product self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Product self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Product self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Product self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Product_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Product self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Product_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Product self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Product_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Product_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Product_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbOperands(self, *args):
        """
        NbOperands(Handle_Expr_Product self) -> Standard_Integer

        returns the number of operands contained in <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Product_NbOperands(self, *args)


    def Operand(self, *args):
        """
        Returns the <index>-th operand used in <me>.
        An exception is raised if index is out of range

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Product_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Product self, Handle_Expr_GeneralExpression exp, Standard_Integer const index)

        Sets the <index>-th operand used in <me>.
        An exception is raised if <index> is out of range
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type index: int

        """
        return _Expr.Handle_Expr_Product_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Product self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 2)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Product_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the sub-expression denoted by <I> in <me>
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Product_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Product self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Product self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Product self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Product self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Product self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Product self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Product_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Product self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Product_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Product self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Product_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Product self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Product self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Product self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Product self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Product_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Product self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Product_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Product self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Product_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Product self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Product_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Product self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Product_DecrementRefCounter(self, *args)

Handle_Expr_Product_swigregister = _Expr.Handle_Expr_Product_swigregister
Handle_Expr_Product_swigregister(Handle_Expr_Product)

def Handle_Expr_Product_DownCast(thing):
    return _Expr.Handle_Expr_Product_DownCast(thing)
Handle_Expr_Product_DownCast = _Expr.Handle_Expr_Product_DownCast

class Expr_UnaryMinus(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_UnaryMinus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_UnaryMinus(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_UnaryMinus self, Handle_Expr_GeneralExpression exp) -> Expr_UnaryMinus

        Create the unary minus of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_UnaryMinus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_UnaryMinus self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryMinus_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_UnaryMinus self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryMinus_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_UnaryMinus self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryMinus_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_UnaryMinus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryMinus_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_UnaryMinus self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryMinus_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_UnaryMinus self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryMinus_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_UnaryMinus self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_UnaryMinus_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_UnaryMinus self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_UnaryMinus_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_UnaryMinus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_UnaryMinus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_UnaryMinus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_UnaryMinus
Expr_UnaryMinus_swigregister = _Expr.Expr_UnaryMinus_swigregister
Expr_UnaryMinus_swigregister(Expr_UnaryMinus)

def Expr_UnaryMinus_get_type_name(*args):
    """
    Expr_UnaryMinus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_UnaryMinus_get_type_name(*args)

def Expr_UnaryMinus_get_type_descriptor(*args):
    """
    Expr_UnaryMinus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_UnaryMinus_get_type_descriptor(*args)

class NCollection_Array1_Handle_Expr_SingleRelation(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Expr_SingleRelation self) -> NCollection_Array1< opencascade::handle< Expr_SingleRelation > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Expr_SingleRelation self) -> NCollection_Array1< opencascade::handle< Expr_SingleRelation > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Expr_SingleRelation self) -> NCollection_Array1< opencascade::handle< Expr_SingleRelation > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Expr_SingleRelation self) -> NCollection_Array1< opencascade::handle< Expr_SingleRelation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Expr.new_NCollection_Array1_Handle_Expr_SingleRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Expr_SingleRelation self, Handle_Expr_SingleRelation theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Expr_SingleRelation self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Expr_SingleRelation self, NCollection_Array1_Handle_Expr_SingleRelation theOther) -> NCollection_Array1_Handle_Expr_SingleRelation

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Expr_SingleRelation self, NCollection_Array1_Handle_Expr_SingleRelation theOther) -> NCollection_Array1_Handle_Expr_SingleRelation

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Expr_SingleRelation self, NCollection_Array1_Handle_Expr_SingleRelation theOther) -> NCollection_Array1_Handle_Expr_SingleRelation
        assign(NCollection_Array1_Handle_Expr_SingleRelation self, NCollection_Array1_Handle_Expr_SingleRelation theOther) -> NCollection_Array1_Handle_Expr_SingleRelation

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_SingleRelation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Expr_SingleRelation self) -> Handle_Expr_SingleRelation

        @return first element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Expr_SingleRelation self) -> Handle_Expr_SingleRelation

        @return last element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Expr_SingleRelation self, Standard_Integer const theIndex) -> Handle_Expr_SingleRelation

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_SingleRelation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_SingleRelation_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Expr_SingleRelation self, Standard_Integer const theIndex, Handle_Expr_SingleRelation theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Expr_SingleRelation self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Expr.NCollection_Array1_Handle_Expr_SingleRelation_Resize(self, *args)

    __swig_destroy__ = _Expr.delete_NCollection_Array1_Handle_Expr_SingleRelation
NCollection_Array1_Handle_Expr_SingleRelation_swigregister = _Expr.NCollection_Array1_Handle_Expr_SingleRelation_swigregister
NCollection_Array1_Handle_Expr_SingleRelation_swigregister(NCollection_Array1_Handle_Expr_SingleRelation)


try:
	Expr_Array1OfSingleRelation = NCollection_Array1_Handle_Expr_SingleRelation
except NameError:
	pass # does not exist, probably ignored

class Expr_Exponential(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Exponential
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Exponential(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Exponential self, Handle_Expr_GeneralExpression exp) -> Expr_Exponential

        Creates the exponential of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Exponential(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Exponential self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponential_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Exponential self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponential_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Exponential self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Exponential_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Exponential self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Exponential_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Exponential self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponential_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Exponential self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Exponential_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Exponential self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Exponential_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Exponential_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Exponential_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Exponential_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Exponential
Expr_Exponential_swigregister = _Expr.Expr_Exponential_swigregister
Expr_Exponential_swigregister(Expr_Exponential)

def Expr_Exponential_get_type_name(*args):
    """
    Expr_Exponential_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Exponential_get_type_name(*args)

def Expr_Exponential_get_type_descriptor(*args):
    """
    Expr_Exponential_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Exponential_get_type_descriptor(*args)

class Expr_NamedExpression(Expr_GeneralExpression):
    """
    Describe an expression used  by its name (as constants
    or variables). A single reference is made to a
    NamedExpression in every Expression (i.e. a
    NamedExpression is shared).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NamedExpression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NamedExpression(self) 
            return h


    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _Expr.Expr_NamedExpression_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Expr_NamedExpression self, TCollection_AsciiString name)

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NamedExpression_SetName(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Expr_NamedExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method redefines to a True
        value the GeneralExpression method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_NamedExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedExpression_IsIdentical(self, *args)


    def String(self, *args):
        """
        String(Expr_NamedExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NamedExpression_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NamedExpression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NamedExpression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NamedExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NamedExpression
Expr_NamedExpression_swigregister = _Expr.Expr_NamedExpression_swigregister
Expr_NamedExpression_swigregister(Expr_NamedExpression)

def Expr_NamedExpression_get_type_name(*args):
    """
    Expr_NamedExpression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NamedExpression_get_type_name(*args)

def Expr_NamedExpression_get_type_descriptor(*args):
    """
    Expr_NamedExpression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NamedExpression_get_type_descriptor(*args)

class Expr_ArgSinh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArgSinh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArgSinh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArgSinh self, Handle_Expr_GeneralExpression exp) -> Expr_ArgSinh

        Creates the ArgSinh of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArgSinh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArgSinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgSinh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArgSinh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgSinh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArgSinh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgSinh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArgSinh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgSinh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArgSinh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgSinh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArgSinh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArgSinh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArgSinh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArgSinh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArgSinh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArgSinh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArgSinh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArgSinh
Expr_ArgSinh_swigregister = _Expr.Expr_ArgSinh_swigregister
Expr_ArgSinh_swigregister(Expr_ArgSinh)

def Expr_ArgSinh_get_type_name(*args):
    """
    Expr_ArgSinh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArgSinh_get_type_name(*args)

def Expr_ArgSinh_get_type_descriptor(*args):
    """
    Expr_ArgSinh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArgSinh_get_type_descriptor(*args)

class Expr_Different(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Different
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Different(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Different self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Different

        Creates the relation <exp1> # <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Different(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_Different self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Different_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_Different self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_Different_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_Different self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_Different_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Different self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_Different_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_Different self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Different_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Different_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Different_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Different_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Different
Expr_Different_swigregister = _Expr.Expr_Different_swigregister
Expr_Different_swigregister(Expr_Different)

def Expr_Different_get_type_name(*args):
    """
    Expr_Different_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Different_get_type_name(*args)

def Expr_Different_get_type_descriptor(*args):
    """
    Expr_Different_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Different_get_type_descriptor(*args)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class Handle_Expr_UnaryExpression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_UnaryExpression self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_UnaryExpression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_UnaryExpression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_UnaryExpression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_UnaryExpression self, Expr_UnaryExpression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_UnaryExpression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_UnaryExpression self, Handle_Expr_UnaryExpression theHandle) -> Handle_Expr_UnaryExpression
        assign(Handle_Expr_UnaryExpression self, Expr_UnaryExpression thePtr) -> Handle_Expr_UnaryExpression
        assign(Handle_Expr_UnaryExpression self, Handle_Expr_UnaryExpression theHandle) -> Handle_Expr_UnaryExpression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_UnaryExpression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_UnaryExpression self) -> Expr_UnaryExpression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryExpression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_UnaryExpression self) -> Expr_UnaryExpression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryExpression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_UnaryExpression self) -> Expr_UnaryExpression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_UnaryExpression___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_UnaryExpression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_UnaryExpression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_UnaryExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_UnaryExpression_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_UnaryExpression

    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryExpression_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_UnaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_UnaryExpression self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_UnaryExpression self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_UnaryExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_UnaryExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_UnaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_Simplified(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_UnaryExpression self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_UnaryExpression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryExpression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_UnaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_UnaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_Copy(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_UnaryExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_IsLinear(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_UnaryExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_UnaryExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        Warning: This method does not include any simplification before
        testing. It could also be very slow; to be used
        carefully.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_IsIdentical(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_UnaryExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_UnaryExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryExpression_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_UnaryExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_UnaryExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryExpression_EvaluateNumeric(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_UnaryExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_UnaryExpression_String(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_UnaryExpression self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_UnaryExpression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_UnaryExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_UnaryExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_UnaryExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_UnaryExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryExpression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_UnaryExpression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_UnaryExpression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_UnaryExpression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryExpression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_UnaryExpression self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_UnaryExpression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_UnaryExpression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryExpression_DecrementRefCounter(self, *args)

Handle_Expr_UnaryExpression_swigregister = _Expr.Handle_Expr_UnaryExpression_swigregister
Handle_Expr_UnaryExpression_swigregister(Handle_Expr_UnaryExpression)

def Handle_Expr_UnaryExpression_DownCast(thing):
    return _Expr.Handle_Expr_UnaryExpression_DownCast(thing)
Handle_Expr_UnaryExpression_DownCast = _Expr.Handle_Expr_UnaryExpression_DownCast

class Expr_NamedUnknown(Expr_NamedExpression):
    """
    This class describes any variable of an expression.
    Assignment is treated directly in this class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NamedUnknown
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NamedUnknown(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NamedUnknown self, TCollection_AsciiString name) -> Expr_NamedUnknown

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _Expr.new_Expr_NamedUnknown(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsAssigned(self, *args):
        """
        IsAssigned(Expr_NamedUnknown self) -> Standard_Boolean

        Tests if an expression is assigned to <me>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedUnknown_IsAssigned(self, *args)


    def AssignedExpression(self, *args):
        """
        If exists, returns the assigned expression.
        An exception is raised if the expression does not exist.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_NamedUnknown_AssignedExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Assign(self, *args):
        """
        Assign(Expr_NamedUnknown self, Handle_Expr_GeneralExpression exp)

        Assigns <me> to <exp> expression.
        Raises exception if <exp> refers to <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_Assign(self, *args)


    def Deassign(self, *args):
        """
        Deassign(Expr_NamedUnknown self)

        Supresses the assigned expression


        """
        return _Expr.Expr_NamedUnknown_Deassign(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_NamedUnknown self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_NamedUnknown_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_NamedUnknown_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_NamedUnknown self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedUnknown_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_NamedUnknown self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedUnknown_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_NamedUnknown self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedUnknown_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_NamedUnknown self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_Derivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_NamedUnknown self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedUnknown_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NamedUnknown_Evaluate(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NamedUnknown_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NamedUnknown_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NamedUnknown_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NamedUnknown
Expr_NamedUnknown_swigregister = _Expr.Expr_NamedUnknown_swigregister
Expr_NamedUnknown_swigregister(Expr_NamedUnknown)

def Expr_NamedUnknown_get_type_name(*args):
    """
    Expr_NamedUnknown_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NamedUnknown_get_type_name(*args)

def Expr_NamedUnknown_get_type_descriptor(*args):
    """
    Expr_NamedUnknown_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NamedUnknown_get_type_descriptor(*args)

class Expr_PolyFunction(Expr_PolyExpression):
    """
    Defines the use of an n-ary function in an expression
    with given arguments.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_PolyFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_PolyFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_PolyFunction self, Handle_Expr_GeneralFunction func, NCollection_Array1_Handle_Expr_GeneralExpression exps) -> Expr_PolyFunction

        Creates <me> as <func>(<exps_1>,<exps_2>,...,<exps_n>)

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :type exps: OCC.wrapper.Expr.Expr_Array1OfGeneralExpression

        """
        this = _Expr.new_Expr_PolyFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Function(self, *args):
        """
        Function(Expr_PolyFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_PolyFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_PolyFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_PolyFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_PolyFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_PolyFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_PolyFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_PolyFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_PolyFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_PolyFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_PolyFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_PolyFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_PolyFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_PolyFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_PolyFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_PolyFunction_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_PolyFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_PolyFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_PolyFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_PolyFunction
Expr_PolyFunction_swigregister = _Expr.Expr_PolyFunction_swigregister
Expr_PolyFunction_swigregister(Expr_PolyFunction)

def Expr_PolyFunction_get_type_name(*args):
    """
    Expr_PolyFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_PolyFunction_get_type_name(*args)

def Expr_PolyFunction_get_type_descriptor(*args):
    """
    Expr_PolyFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_PolyFunction_get_type_descriptor(*args)

class Expr_NotEvaluable(Expr_ExprFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NotEvaluable
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NotEvaluable(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NotEvaluable self) -> Expr_NotEvaluable
        __init__(Expr_NotEvaluable self, Standard_CString const theMessage) -> Expr_NotEvaluable

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_NotEvaluable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_NotEvaluable

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NotEvaluable

        """
        return _Expr.Expr_NotEvaluable_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NotEvaluable_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NotEvaluable_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NotEvaluable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NotEvaluable
Expr_NotEvaluable_swigregister = _Expr.Expr_NotEvaluable_swigregister
Expr_NotEvaluable_swigregister(Expr_NotEvaluable)

def Expr_NotEvaluable_NewInstance(*args):
    """
    Expr_NotEvaluable_NewInstance(Standard_CString const theMessage) -> Handle_Expr_NotEvaluable

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_NotEvaluable

    """
    return _Expr.Expr_NotEvaluable_NewInstance(*args)

def Expr_NotEvaluable_get_type_name(*args):
    """
    Expr_NotEvaluable_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NotEvaluable_get_type_name(*args)

def Expr_NotEvaluable_get_type_descriptor(*args):
    """
    Expr_NotEvaluable_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NotEvaluable_get_type_descriptor(*args)

class Handle_Expr_Exponential(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Exponential self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Exponential_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Exponential self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Exponential_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Exponential self, Expr_Exponential thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Exponential_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Exponential self, Handle_Expr_Exponential theHandle) -> Handle_Expr_Exponential
        assign(Handle_Expr_Exponential self, Expr_Exponential thePtr) -> Handle_Expr_Exponential
        assign(Handle_Expr_Exponential self, Handle_Expr_Exponential theHandle) -> Handle_Expr_Exponential

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Exponential_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Exponential self) -> Expr_Exponential

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Exponential_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Exponential self) -> Expr_Exponential

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Exponential___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Exponential self) -> Expr_Exponential

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Exponential___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Exponential___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Exponential___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Exponential(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Exponential_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Exponential

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Exponential self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Exponential self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Exponential self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Exponential self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Exponential self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Exponential self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Exponential_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Exponential self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Exponential_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Exponential self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Exponential_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Exponential_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Exponential_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Exponential_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Exponential self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Exponential self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponential_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Exponential_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Exponential self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Exponential self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Exponential self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Exponential self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Exponential self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Exponential self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponential_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Exponential self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Exponential_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Exponential self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Exponential_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Exponential self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Exponential self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Exponential self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Exponential self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponential_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Exponential self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Exponential_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Exponential self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponential_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Exponential self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Exponential_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Exponential self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponential_DecrementRefCounter(self, *args)

Handle_Expr_Exponential_swigregister = _Expr.Handle_Expr_Exponential_swigregister
Handle_Expr_Exponential_swigregister(Handle_Expr_Exponential)

def Handle_Expr_Exponential_DownCast(thing):
    return _Expr.Handle_Expr_Exponential_DownCast(thing)
Handle_Expr_Exponential_DownCast = _Expr.Handle_Expr_Exponential_DownCast

class Expr_NumericValue(Expr_GeneralExpression):
    """
    This class describes any reel value defined in an
    expression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NumericValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NumericValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NumericValue self, Standard_Real const val) -> Expr_NumericValue

        :type val: float

        """
        this = _Expr.new_Expr_NumericValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetValue(self, *args):
        """
        GetValue(Expr_NumericValue self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NumericValue_GetValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Expr_NumericValue self, Standard_Real const val)

        :type val: float

        """
        return _Expr.Expr_NumericValue_SetValue(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_NumericValue self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_NumericValue_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_NumericValue_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_NumericValue self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NumericValue_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_NumericValue self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NumericValue_Contains(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_NumericValue self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NumericValue_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_NumericValue self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NumericValue_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_NumericValue self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_NumericValue self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_NumericValue self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NumericValue_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_NumericValue self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NumericValue_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_NumericValue self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_NumericValue_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NumericValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NumericValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NumericValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NumericValue
Expr_NumericValue_swigregister = _Expr.Expr_NumericValue_swigregister
Expr_NumericValue_swigregister(Expr_NumericValue)

def Expr_NumericValue_get_type_name(*args):
    """
    Expr_NumericValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NumericValue_get_type_name(*args)

def Expr_NumericValue_get_type_descriptor(*args):
    """
    Expr_NumericValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NumericValue_get_type_descriptor(*args)

class Expr_NamedConstant(Expr_NamedExpression):
    """
    Describes any numeric constant known by a special name
    (as PI, e,...).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_NamedConstant
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_NamedConstant(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_NamedConstant self, TCollection_AsciiString name, Standard_Real const value) -> Expr_NamedConstant

        Creates a constant value of name <name> and value <value>.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :type value: float

        """
        this = _Expr.new_Expr_NamedConstant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetValue(self, *args):
        """
        GetValue(Expr_NamedConstant self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NamedConstant_GetValue(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Expr_NamedConstant self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> (always returns zero)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_NamedConstant_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Expr_NamedConstant_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Expr_NamedConstant self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.
        (returns always False)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedConstant_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Expr_NamedConstant self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedConstant_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_NamedConstant self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_NamedConstant_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_NamedConstant self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_NamedConstant self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Expr_NamedConstant self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_NamedConstant_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_NamedConstant self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_NamedConstant_Evaluate(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_NamedConstant_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_NamedConstant_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_NamedConstant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_NamedConstant
Expr_NamedConstant_swigregister = _Expr.Expr_NamedConstant_swigregister
Expr_NamedConstant_swigregister(Expr_NamedConstant)

def Expr_NamedConstant_get_type_name(*args):
    """
    Expr_NamedConstant_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_NamedConstant_get_type_name(*args)

def Expr_NamedConstant_get_type_descriptor(*args):
    """
    Expr_NamedConstant_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_NamedConstant_get_type_descriptor(*args)

class Expr_Equal(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Equal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Equal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Equal self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Equal

        Creates the relation <exp1> = <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Equal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_Equal self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Equal_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_Equal self) -> Handle_Expr_GeneralRelation

        returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_Equal_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_Equal self)

        Replaces NamedUnknowns by an associated expressions
        and computes values in <me>.


        """
        return _Expr.Expr_Equal_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Equal self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_Equal_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_Equal self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Equal_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Equal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Equal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Equal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Equal
Expr_Equal_swigregister = _Expr.Expr_Equal_swigregister
Expr_Equal_swigregister(Expr_Equal)

def Expr_Equal_get_type_name(*args):
    """
    Expr_Equal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Equal_get_type_name(*args)

def Expr_Equal_get_type_descriptor(*args):
    """
    Expr_Equal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Equal_get_type_descriptor(*args)

class Expr_ArgCosh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArgCosh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArgCosh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArgCosh self, Handle_Expr_GeneralExpression exp) -> Expr_ArgCosh

        Creates the ArgCosh of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArgCosh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArgCosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgCosh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArgCosh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgCosh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArgCosh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgCosh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArgCosh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArgCosh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArgCosh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArgCosh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArgCosh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArgCosh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArgCosh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArgCosh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArgCosh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArgCosh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArgCosh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArgCosh
Expr_ArgCosh_swigregister = _Expr.Expr_ArgCosh_swigregister
Expr_ArgCosh_swigregister(Expr_ArgCosh)

def Expr_ArgCosh_get_type_name(*args):
    """
    Expr_ArgCosh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArgCosh_get_type_name(*args)

def Expr_ArgCosh_get_type_descriptor(*args):
    """
    Expr_ArgCosh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArgCosh_get_type_descriptor(*args)

class Expr_Sine(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Sine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Sine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Sine self, Handle_Expr_GeneralExpression exp) -> Expr_Sine

        Creates the sine of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Sine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Sine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Sine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Sine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Sine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Sine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Sine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Sine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Sine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Sine_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Sine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Sine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Sine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Sine
Expr_Sine_swigregister = _Expr.Expr_Sine_swigregister
Expr_Sine_swigregister(Expr_Sine)

def Expr_Sine_get_type_name(*args):
    """
    Expr_Sine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Sine_get_type_name(*args)

def Expr_Sine_get_type_descriptor(*args):
    """
    Expr_Sine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Sine_get_type_descriptor(*args)

class Handle_Expr_SystemRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_SystemRelation self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_SystemRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_SystemRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_SystemRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_SystemRelation self, Expr_SystemRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_SystemRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_SystemRelation self, Handle_Expr_SystemRelation theHandle) -> Handle_Expr_SystemRelation
        assign(Handle_Expr_SystemRelation self, Expr_SystemRelation thePtr) -> Handle_Expr_SystemRelation
        assign(Handle_Expr_SystemRelation self, Handle_Expr_SystemRelation theHandle) -> Handle_Expr_SystemRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_SystemRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_SystemRelation self) -> Expr_SystemRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_SystemRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_SystemRelation self) -> Expr_SystemRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_SystemRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_SystemRelation self) -> Expr_SystemRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_SystemRelation___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_SystemRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_SystemRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_SystemRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_SystemRelation_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_SystemRelation

    def Add(self, *args):
        """
        Add(Handle_Expr_SystemRelation self, Handle_Expr_GeneralRelation relation)

        Appends <relation> in the list of components of <me>.

        :type relation: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SystemRelation_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_Expr_SystemRelation self, Handle_Expr_GeneralRelation relation)

        :type relation: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SystemRelation_Remove(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_SystemRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SystemRelation_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_SystemRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SystemRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_SystemRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SystemRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_SystemRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if <index> is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SystemRelation_SubRelation(self, *args)


    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_SystemRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SystemRelation_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_SystemRelation self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SystemRelation_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_SystemRelation self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_SystemRelation_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_SystemRelation self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SystemRelation_Copy(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_SystemRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SystemRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_SystemRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SystemRelation_Replace(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_SystemRelation self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_SystemRelation_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_SystemRelation self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_SystemRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SystemRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SystemRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_SystemRelation self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_SystemRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_SystemRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_SystemRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SystemRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_SystemRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_SystemRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SystemRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_SystemRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_SystemRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_SystemRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SystemRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_SystemRelation self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_SystemRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_SystemRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SystemRelation_DecrementRefCounter(self, *args)

Handle_Expr_SystemRelation_swigregister = _Expr.Handle_Expr_SystemRelation_swigregister
Handle_Expr_SystemRelation_swigregister(Handle_Expr_SystemRelation)

def Handle_Expr_SystemRelation_DownCast(thing):
    return _Expr.Handle_Expr_SystemRelation_DownCast(thing)
Handle_Expr_SystemRelation_DownCast = _Expr.Handle_Expr_SystemRelation_DownCast

class Expr_BinaryFunction(Expr_BinaryExpression):
    """
    Defines the use of a binary function in an expression
    with given arguments.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_BinaryFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_BinaryFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_BinaryFunction self, Handle_Expr_GeneralFunction func, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_BinaryFunction

        Creates <me> as <func> (<exp1>,<exp2>).
        Raises exception if <func> is not binary.

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_BinaryFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Function(self, *args):
        """
        Function(Expr_BinaryFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_BinaryFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_BinaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_BinaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_BinaryFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_BinaryFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_BinaryFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_BinaryFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_BinaryFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_BinaryFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_BinaryFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_BinaryFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_BinaryFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_BinaryFunction_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_BinaryFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_BinaryFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_BinaryFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_BinaryFunction
Expr_BinaryFunction_swigregister = _Expr.Expr_BinaryFunction_swigregister
Expr_BinaryFunction_swigregister(Expr_BinaryFunction)

def Expr_BinaryFunction_get_type_name(*args):
    """
    Expr_BinaryFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_BinaryFunction_get_type_name(*args)

def Expr_BinaryFunction_get_type_descriptor(*args):
    """
    Expr_BinaryFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_BinaryFunction_get_type_descriptor(*args)

class Expr_Sinh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Sinh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Sinh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Sinh self, Handle_Expr_GeneralExpression exp) -> Expr_Sinh

        Creates the sinh of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Sinh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Sinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sinh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Sinh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sinh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Sinh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sinh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Sinh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sinh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Sinh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sinh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Sinh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Sinh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Sinh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Sinh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Sinh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Sinh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Sinh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Sinh
Expr_Sinh_swigregister = _Expr.Expr_Sinh_swigregister
Expr_Sinh_swigregister(Expr_Sinh)

def Expr_Sinh_get_type_name(*args):
    """
    Expr_Sinh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Sinh_get_type_name(*args)

def Expr_Sinh_get_type_descriptor(*args):
    """
    Expr_Sinh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Sinh_get_type_descriptor(*args)

class Expr_Exponentiate(Expr_BinaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Exponentiate
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Exponentiate(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Exponentiate self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Exponentiate

        Creates the exponential <exp1> ^ <exp2>

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Exponentiate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Exponentiate self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponentiate_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Exponentiate self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponentiate_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Exponentiate self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Exponentiate_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Exponentiate self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Exponentiate_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Exponentiate self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Exponentiate_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Exponentiate self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Exponentiate_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Exponentiate self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Exponentiate_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Exponentiate_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Exponentiate_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Exponentiate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Exponentiate
Expr_Exponentiate_swigregister = _Expr.Expr_Exponentiate_swigregister
Expr_Exponentiate_swigregister(Expr_Exponentiate)

def Expr_Exponentiate_get_type_name(*args):
    """
    Expr_Exponentiate_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Exponentiate_get_type_name(*args)

def Expr_Exponentiate_get_type_descriptor(*args):
    """
    Expr_Exponentiate_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Exponentiate_get_type_descriptor(*args)

class Expr_InvalidFunction(Expr_ExprFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_InvalidFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_InvalidFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_InvalidFunction self) -> Expr_InvalidFunction
        __init__(Expr_InvalidFunction self, Standard_CString const theMessage) -> Expr_InvalidFunction

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_InvalidFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidFunction

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidFunction

        """
        return _Expr.Expr_InvalidFunction_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_InvalidFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_InvalidFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_InvalidFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_InvalidFunction
Expr_InvalidFunction_swigregister = _Expr.Expr_InvalidFunction_swigregister
Expr_InvalidFunction_swigregister(Expr_InvalidFunction)

def Expr_InvalidFunction_NewInstance(*args):
    """
    Expr_InvalidFunction_NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidFunction

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidFunction

    """
    return _Expr.Expr_InvalidFunction_NewInstance(*args)

def Expr_InvalidFunction_get_type_name(*args):
    """
    Expr_InvalidFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_InvalidFunction_get_type_name(*args)

def Expr_InvalidFunction_get_type_descriptor(*args):
    """
    Expr_InvalidFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_InvalidFunction_get_type_descriptor(*args)

class Expr_Sum(Expr_PolyExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Sum
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Sum(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Sum self, NCollection_Sequence_Handle_Expr_GeneralExpression exps) -> Expr_Sum
        __init__(Expr_Sum self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_Sum

        Creates the sum of <exp1> and <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Sum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Sum self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sum_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Sum self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sum_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Sum self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sum_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Sum self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Sum_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Sum self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sum_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Expr_Sum self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Sum_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Sum self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Sum_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Sum self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Sum_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Sum_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Sum_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Sum_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Sum
Expr_Sum_swigregister = _Expr.Expr_Sum_swigregister
Expr_Sum_swigregister(Expr_Sum)

def Expr_Sum_get_type_name(*args):
    """
    Expr_Sum_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Sum_get_type_name(*args)

def Expr_Sum_get_type_descriptor(*args):
    """
    Expr_Sum_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Sum_get_type_descriptor(*args)

class Handle_Expr_NamedUnknown(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NamedUnknown self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NamedUnknown_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NamedUnknown self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NamedUnknown_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NamedUnknown self, Expr_NamedUnknown thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NamedUnknown_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown theHandle) -> Handle_Expr_NamedUnknown
        assign(Handle_Expr_NamedUnknown self, Expr_NamedUnknown thePtr) -> Handle_Expr_NamedUnknown
        assign(Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown theHandle) -> Handle_Expr_NamedUnknown

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NamedUnknown_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NamedUnknown self) -> Expr_NamedUnknown

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedUnknown_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NamedUnknown self) -> Expr_NamedUnknown

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedUnknown___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NamedUnknown self) -> Expr_NamedUnknown

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NamedUnknown___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NamedUnknown___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NamedUnknown___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NamedUnknown(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NamedUnknown_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NamedUnknown

    def IsAssigned(self, *args):
        """
        IsAssigned(Handle_Expr_NamedUnknown self) -> Standard_Boolean

        Tests if an expression is assigned to <me>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsAssigned(self, *args)


    def AssignedExpression(self, *args):
        """
        If exists, returns the assigned expression.
        An exception is raised if the expression does not exist.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_NamedUnknown_AssignedExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Assign(self, *args):
        """
        Assign(Handle_Expr_NamedUnknown self, Handle_Expr_GeneralExpression exp)

        Assigns <me> to <exp> expression.
        Raises exception if <exp> refers to <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_Assign(self, *args)


    def Deassign(self, *args):
        """
        Deassign(Handle_Expr_NamedUnknown self)

        Supresses the assigned expression


        """
        return _Expr.Handle_Expr_NamedUnknown_Deassign(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_NamedUnknown self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedUnknown_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_NamedUnknown_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_NamedUnknown self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_NamedUnknown self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_NamedUnknown self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_NamedUnknown self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_Derivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedUnknown_Evaluate(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NamedUnknown self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NamedUnknown_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedUnknown_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedUnknown_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _Expr.Handle_Expr_NamedUnknown_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_Expr_NamedUnknown self, TCollection_AsciiString name)

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedUnknown_SetName(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_NamedUnknown self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method redefines to a True
        value the GeneralExpression method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_NamedUnknown self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsIdentical(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_NamedUnknown self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedUnknown_String(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedUnknown_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_NamedUnknown self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedUnknown_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NamedUnknown self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NamedUnknown_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NamedUnknown self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NamedUnknown self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NamedUnknown self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NamedUnknown self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedUnknown_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NamedUnknown self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NamedUnknown_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NamedUnknown self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedUnknown_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NamedUnknown self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NamedUnknown_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NamedUnknown self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedUnknown_DecrementRefCounter(self, *args)

Handle_Expr_NamedUnknown_swigregister = _Expr.Handle_Expr_NamedUnknown_swigregister
Handle_Expr_NamedUnknown_swigregister(Handle_Expr_NamedUnknown)

def Handle_Expr_NamedUnknown_DownCast(thing):
    return _Expr.Handle_Expr_NamedUnknown_DownCast(thing)
Handle_Expr_NamedUnknown_DownCast = _Expr.Handle_Expr_NamedUnknown_DownCast

class Handle_Expr_PolyFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_PolyFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_PolyFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_PolyFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_PolyFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_PolyFunction self, Expr_PolyFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_PolyFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_PolyFunction self, Handle_Expr_PolyFunction theHandle) -> Handle_Expr_PolyFunction
        assign(Handle_Expr_PolyFunction self, Expr_PolyFunction thePtr) -> Handle_Expr_PolyFunction
        assign(Handle_Expr_PolyFunction self, Handle_Expr_PolyFunction theHandle) -> Handle_Expr_PolyFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_PolyFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_PolyFunction self) -> Expr_PolyFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_PolyFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_PolyFunction self) -> Expr_PolyFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_PolyFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_PolyFunction self) -> Expr_PolyFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_PolyFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_PolyFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_PolyFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_PolyFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_PolyFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_PolyFunction

    def Function(self, *args):
        """
        Function(Handle_Expr_PolyFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_PolyFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_PolyFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_PolyFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_PolyFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_PolyFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_PolyFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_PolyFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_PolyFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_PolyFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_PolyFunction_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_PolyFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_PolyFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_PolyFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_PolyFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbOperands(self, *args):
        """
        NbOperands(Handle_Expr_PolyFunction self) -> Standard_Integer

        returns the number of operands contained in <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyFunction_NbOperands(self, *args)


    def Operand(self, *args):
        """
        Returns the <index>-th operand used in <me>.
        An exception is raised if index is out of range

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_PolyFunction_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_PolyFunction self, Handle_Expr_GeneralExpression exp, Standard_Integer const index)

        Sets the <index>-th operand used in <me>.
        An exception is raised if <index> is out of range
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type index: int

        """
        return _Expr.Handle_Expr_PolyFunction_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_PolyFunction self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 2)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyFunction_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the sub-expression denoted by <I> in <me>
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_PolyFunction_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_PolyFunction self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_PolyFunction self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_PolyFunction self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_PolyFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_PolyFunction self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_PolyFunction self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyFunction_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_PolyFunction self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_PolyFunction_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_PolyFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_PolyFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_PolyFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_PolyFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_PolyFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_PolyFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_PolyFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_PolyFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_PolyFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_PolyFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_PolyFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_PolyFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyFunction_DecrementRefCounter(self, *args)

Handle_Expr_PolyFunction_swigregister = _Expr.Handle_Expr_PolyFunction_swigregister
Handle_Expr_PolyFunction_swigregister(Handle_Expr_PolyFunction)

def Handle_Expr_PolyFunction_DownCast(thing):
    return _Expr.Handle_Expr_PolyFunction_DownCast(thing)
Handle_Expr_PolyFunction_DownCast = _Expr.Handle_Expr_PolyFunction_DownCast

class Handle_Expr_ArcSine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArcSine self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArcSine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArcSine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArcSine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArcSine self, Expr_ArcSine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArcSine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArcSine self, Handle_Expr_ArcSine theHandle) -> Handle_Expr_ArcSine
        assign(Handle_Expr_ArcSine self, Expr_ArcSine thePtr) -> Handle_Expr_ArcSine
        assign(Handle_Expr_ArcSine self, Handle_Expr_ArcSine theHandle) -> Handle_Expr_ArcSine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArcSine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArcSine self) -> Expr_ArcSine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcSine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArcSine self) -> Expr_ArcSine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcSine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArcSine self) -> Expr_ArcSine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArcSine___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArcSine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArcSine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArcSine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArcSine_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArcSine

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArcSine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArcSine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArcSine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArcSine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArcSine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArcSine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcSine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArcSine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArcSine_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArcSine self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArcSine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcSine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcSine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcSine_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArcSine self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArcSine self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcSine_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcSine_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArcSine self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArcSine self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArcSine self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArcSine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArcSine self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArcSine self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcSine_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArcSine self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcSine_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArcSine self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArcSine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArcSine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArcSine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArcSine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArcSine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcSine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArcSine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArcSine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArcSine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcSine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArcSine self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArcSine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArcSine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcSine_DecrementRefCounter(self, *args)

Handle_Expr_ArcSine_swigregister = _Expr.Handle_Expr_ArcSine_swigregister
Handle_Expr_ArcSine_swigregister(Handle_Expr_ArcSine)

def Handle_Expr_ArcSine_DownCast(thing):
    return _Expr.Handle_Expr_ArcSine_DownCast(thing)
Handle_Expr_ArcSine_DownCast = _Expr.Handle_Expr_ArcSine_DownCast

class Expr_Square(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Square
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Square(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Square self, Handle_Expr_GeneralExpression exp) -> Expr_Square

        Creates the square of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Square(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Square self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Square_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Square self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Square_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Square self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Square_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Square self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Square_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Square self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Square_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Square self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Square_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Square self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Square_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Square_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Square_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Square_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Square
Expr_Square_swigregister = _Expr.Expr_Square_swigregister
Expr_Square_swigregister(Expr_Square)

def Expr_Square_get_type_name(*args):
    """
    Expr_Square_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Square_get_type_name(*args)

def Expr_Square_get_type_descriptor(*args):
    """
    Expr_Square_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Square_get_type_descriptor(*args)

class Handle_Expr_InvalidOperand(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_InvalidOperand self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_InvalidOperand_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_InvalidOperand self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_InvalidOperand_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_InvalidOperand self, Expr_InvalidOperand thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_InvalidOperand_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_InvalidOperand self, Handle_Expr_InvalidOperand theHandle) -> Handle_Expr_InvalidOperand
        assign(Handle_Expr_InvalidOperand self, Expr_InvalidOperand thePtr) -> Handle_Expr_InvalidOperand
        assign(Handle_Expr_InvalidOperand self, Handle_Expr_InvalidOperand theHandle) -> Handle_Expr_InvalidOperand

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_InvalidOperand_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_InvalidOperand self) -> Expr_InvalidOperand

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidOperand_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_InvalidOperand self) -> Expr_InvalidOperand

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidOperand___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_InvalidOperand self) -> Expr_InvalidOperand

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_InvalidOperand___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_InvalidOperand___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_InvalidOperand___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_InvalidOperand(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_InvalidOperand_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_InvalidOperand

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_InvalidOperand self, Standard_CString const theMessage) -> Handle_Expr_InvalidOperand

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidOperand

        """
        return _Expr.Handle_Expr_InvalidOperand_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_InvalidOperand self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_InvalidOperand_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidOperand_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidOperand_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_InvalidOperand self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_InvalidOperand_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_InvalidOperand self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidOperand_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_InvalidOperand self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidOperand_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_InvalidOperand self)
        Reraise(Handle_Expr_InvalidOperand self, Standard_CString const aMessage)
        Reraise(Handle_Expr_InvalidOperand self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_InvalidOperand_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_InvalidOperand self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_InvalidOperand_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_InvalidOperand self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_InvalidOperand_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_InvalidOperand self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_InvalidOperand_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_InvalidOperand self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_InvalidOperand self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidOperand_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_InvalidOperand self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_InvalidOperand self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidOperand_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_InvalidOperand self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_InvalidOperand_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_InvalidOperand self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidOperand_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_InvalidOperand self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_InvalidOperand_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_InvalidOperand self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidOperand_DecrementRefCounter(self, *args)

Handle_Expr_InvalidOperand_swigregister = _Expr.Handle_Expr_InvalidOperand_swigregister
Handle_Expr_InvalidOperand_swigregister(Handle_Expr_InvalidOperand)

def Handle_Expr_InvalidOperand_DownCast(thing):
    return _Expr.Handle_Expr_InvalidOperand_DownCast(thing)
Handle_Expr_InvalidOperand_DownCast = _Expr.Handle_Expr_InvalidOperand_DownCast

class Handle_Expr_Exponentiate(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Exponentiate self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Exponentiate_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Exponentiate self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Exponentiate_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Exponentiate self, Expr_Exponentiate thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Exponentiate_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Exponentiate self, Handle_Expr_Exponentiate theHandle) -> Handle_Expr_Exponentiate
        assign(Handle_Expr_Exponentiate self, Expr_Exponentiate thePtr) -> Handle_Expr_Exponentiate
        assign(Handle_Expr_Exponentiate self, Handle_Expr_Exponentiate theHandle) -> Handle_Expr_Exponentiate

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Exponentiate_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Exponentiate self) -> Expr_Exponentiate

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Exponentiate_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Exponentiate self) -> Expr_Exponentiate

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Exponentiate___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Exponentiate self) -> Expr_Exponentiate

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Exponentiate___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Exponentiate___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Exponentiate___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Exponentiate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Exponentiate_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Exponentiate

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Exponentiate self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Exponentiate self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Exponentiate self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Exponentiate self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Exponentiate self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Exponentiate self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Exponentiate_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Exponentiate self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Exponentiate_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Exponentiate self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Exponentiate_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Exponentiate_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Exponentiate_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Exponentiate_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Exponentiate_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_Expr_Exponentiate self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_Expr_Exponentiate self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Exponentiate self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponentiate_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Exponentiate_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Exponentiate self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Exponentiate self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Exponentiate self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Exponentiate self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Exponentiate self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Exponentiate self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Exponentiate_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Exponentiate self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Exponentiate_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Exponentiate self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Exponentiate_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Exponentiate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Exponentiate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Exponentiate self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Exponentiate self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Exponentiate_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Exponentiate self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Exponentiate_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Exponentiate self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponentiate_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Exponentiate self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Exponentiate_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Exponentiate self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Exponentiate_DecrementRefCounter(self, *args)

Handle_Expr_Exponentiate_swigregister = _Expr.Handle_Expr_Exponentiate_swigregister
Handle_Expr_Exponentiate_swigregister(Handle_Expr_Exponentiate)

def Handle_Expr_Exponentiate_DownCast(thing):
    return _Expr.Handle_Expr_Exponentiate_DownCast(thing)
Handle_Expr_Exponentiate_DownCast = _Expr.Handle_Expr_Exponentiate_DownCast

class Expr_LogOf10(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_LogOf10
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_LogOf10(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_LogOf10 self, Handle_Expr_GeneralExpression exp) -> Expr_LogOf10

        Creates the base 10 logarithm of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_LogOf10(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_LogOf10 self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOf10_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_LogOf10 self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOf10_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_LogOf10 self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LogOf10_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_LogOf10 self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LogOf10_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_LogOf10 self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOf10_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_LogOf10 self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_LogOf10_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_LogOf10 self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_LogOf10_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_LogOf10_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_LogOf10_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_LogOf10_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_LogOf10
Expr_LogOf10_swigregister = _Expr.Expr_LogOf10_swigregister
Expr_LogOf10_swigregister(Expr_LogOf10)

def Expr_LogOf10_get_type_name(*args):
    """
    Expr_LogOf10_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_LogOf10_get_type_name(*args)

def Expr_LogOf10_get_type_descriptor(*args):
    """
    Expr_LogOf10_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_LogOf10_get_type_descriptor(*args)

class Expr_GreaterThanOrEqual(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_GreaterThanOrEqual
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_GreaterThanOrEqual(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_GreaterThanOrEqual self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_GreaterThanOrEqual

        Creates the relation <exp1> >= <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_GreaterThanOrEqual(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_GreaterThanOrEqual self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_GreaterThanOrEqual_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GreaterThanOrEqual_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_GreaterThanOrEqual self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_GreaterThanOrEqual_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_GreaterThanOrEqual_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_GreaterThanOrEqual self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_GreaterThanOrEqual_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_GreaterThanOrEqual_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_GreaterThanOrEqual_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_GreaterThanOrEqual_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_GreaterThanOrEqual
Expr_GreaterThanOrEqual_swigregister = _Expr.Expr_GreaterThanOrEqual_swigregister
Expr_GreaterThanOrEqual_swigregister(Expr_GreaterThanOrEqual)

def Expr_GreaterThanOrEqual_get_type_name(*args):
    """
    Expr_GreaterThanOrEqual_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_GreaterThanOrEqual_get_type_name(*args)

def Expr_GreaterThanOrEqual_get_type_descriptor(*args):
    """
    Expr_GreaterThanOrEqual_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_GreaterThanOrEqual_get_type_descriptor(*args)

class Handle_Expr_BinaryFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_BinaryFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_BinaryFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_BinaryFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_BinaryFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_BinaryFunction self, Expr_BinaryFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_BinaryFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_BinaryFunction self, Handle_Expr_BinaryFunction theHandle) -> Handle_Expr_BinaryFunction
        assign(Handle_Expr_BinaryFunction self, Expr_BinaryFunction thePtr) -> Handle_Expr_BinaryFunction
        assign(Handle_Expr_BinaryFunction self, Handle_Expr_BinaryFunction theHandle) -> Handle_Expr_BinaryFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_BinaryFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_BinaryFunction self) -> Expr_BinaryFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_BinaryFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_BinaryFunction self) -> Expr_BinaryFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_BinaryFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_BinaryFunction self) -> Expr_BinaryFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_BinaryFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_BinaryFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_BinaryFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_BinaryFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_BinaryFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_BinaryFunction

    def Function(self, *args):
        """
        Function(Handle_Expr_BinaryFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_BinaryFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_BinaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_BinaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_BinaryFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_BinaryFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_BinaryFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_BinaryFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_BinaryFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_BinaryFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_BinaryFunction_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_BinaryFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_BinaryFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_BinaryFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_BinaryFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryFunction_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryFunction_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_Expr_BinaryFunction self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_Expr_BinaryFunction self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_BinaryFunction self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryFunction_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryFunction_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_BinaryFunction self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_BinaryFunction self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_BinaryFunction self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_BinaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_BinaryFunction self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_BinaryFunction self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryFunction_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_BinaryFunction self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_BinaryFunction_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_BinaryFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_BinaryFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_BinaryFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_BinaryFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_BinaryFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_BinaryFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_BinaryFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_BinaryFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_BinaryFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_BinaryFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_BinaryFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_BinaryFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryFunction_DecrementRefCounter(self, *args)

Handle_Expr_BinaryFunction_swigregister = _Expr.Handle_Expr_BinaryFunction_swigregister
Handle_Expr_BinaryFunction_swigregister(Handle_Expr_BinaryFunction)

def Handle_Expr_BinaryFunction_DownCast(thing):
    return _Expr.Handle_Expr_BinaryFunction_DownCast(thing)
Handle_Expr_BinaryFunction_DownCast = _Expr.Handle_Expr_BinaryFunction_DownCast

class Handle_Expr_NotEvaluable(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NotEvaluable self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NotEvaluable_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NotEvaluable self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NotEvaluable_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NotEvaluable self, Expr_NotEvaluable thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NotEvaluable_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NotEvaluable self, Handle_Expr_NotEvaluable theHandle) -> Handle_Expr_NotEvaluable
        assign(Handle_Expr_NotEvaluable self, Expr_NotEvaluable thePtr) -> Handle_Expr_NotEvaluable
        assign(Handle_Expr_NotEvaluable self, Handle_Expr_NotEvaluable theHandle) -> Handle_Expr_NotEvaluable

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NotEvaluable_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NotEvaluable self) -> Expr_NotEvaluable

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NotEvaluable_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NotEvaluable self) -> Expr_NotEvaluable

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NotEvaluable___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NotEvaluable self) -> Expr_NotEvaluable

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NotEvaluable___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NotEvaluable___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NotEvaluable___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NotEvaluable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NotEvaluable_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NotEvaluable

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_NotEvaluable self, Standard_CString const theMessage) -> Handle_Expr_NotEvaluable

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NotEvaluable

        """
        return _Expr.Handle_Expr_NotEvaluable_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NotEvaluable self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NotEvaluable_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NotEvaluable_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NotEvaluable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_NotEvaluable self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_NotEvaluable_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_NotEvaluable self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_NotEvaluable_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_NotEvaluable self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_NotEvaluable_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_NotEvaluable self)
        Reraise(Handle_Expr_NotEvaluable self, Standard_CString const aMessage)
        Reraise(Handle_Expr_NotEvaluable self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_NotEvaluable_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_NotEvaluable self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_NotEvaluable_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_NotEvaluable self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_NotEvaluable_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NotEvaluable self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NotEvaluable_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NotEvaluable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NotEvaluable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NotEvaluable_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NotEvaluable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NotEvaluable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NotEvaluable_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NotEvaluable self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NotEvaluable_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NotEvaluable self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NotEvaluable_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NotEvaluable self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NotEvaluable_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NotEvaluable self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NotEvaluable_DecrementRefCounter(self, *args)

Handle_Expr_NotEvaluable_swigregister = _Expr.Handle_Expr_NotEvaluable_swigregister
Handle_Expr_NotEvaluable_swigregister(Handle_Expr_NotEvaluable)

def Handle_Expr_NotEvaluable_DownCast(thing):
    return _Expr.Handle_Expr_NotEvaluable_DownCast(thing)
Handle_Expr_NotEvaluable_DownCast = _Expr.Handle_Expr_NotEvaluable_DownCast

class Handle_Expr_GeneralExpression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_GeneralExpression self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_GeneralExpression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_GeneralExpression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_GeneralExpression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_GeneralExpression self, Expr_GeneralExpression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_GeneralExpression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theHandle) -> Handle_Expr_GeneralExpression
        assign(Handle_Expr_GeneralExpression self, Expr_GeneralExpression thePtr) -> Handle_Expr_GeneralExpression
        assign(Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theHandle) -> Handle_Expr_GeneralExpression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_GeneralExpression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_GeneralExpression self) -> Expr_GeneralExpression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralExpression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_GeneralExpression self) -> Expr_GeneralExpression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralExpression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_GeneralExpression self) -> Expr_GeneralExpression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_GeneralExpression___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_GeneralExpression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_GeneralExpression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_GeneralExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_GeneralExpression_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_GeneralExpression

    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_GeneralExpression self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_GeneralExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> contains NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_IsLinear(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_GeneralExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        Warning: This method does not include any simplification before
        testing. It could also be very slow; to be used
        carefully.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_IsIdentical(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_GeneralExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_GeneralExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_GeneralExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with copies of <with>
        in <me>. Copies of <with> are made with the Copy() method.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralExpression_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_GeneralExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_GeneralExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_GeneralExpression_EvaluateNumeric(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_GeneralExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_GeneralExpression_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_GeneralExpression self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_GeneralExpression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralExpression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_GeneralExpression self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_GeneralExpression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_GeneralExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_GeneralExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_GeneralExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_GeneralExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralExpression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_GeneralExpression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_GeneralExpression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_GeneralExpression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralExpression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_GeneralExpression self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_GeneralExpression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_GeneralExpression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralExpression_DecrementRefCounter(self, *args)

Handle_Expr_GeneralExpression_swigregister = _Expr.Handle_Expr_GeneralExpression_swigregister
Handle_Expr_GeneralExpression_swigregister(Handle_Expr_GeneralExpression)

def Handle_Expr_GeneralExpression_DownCast(thing):
    return _Expr.Handle_Expr_GeneralExpression_DownCast(thing)
Handle_Expr_GeneralExpression_DownCast = _Expr.Handle_Expr_GeneralExpression_DownCast

class Handle_Expr_Division(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Division self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Division_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Division self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Division_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Division self, Expr_Division thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Division_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Division self, Handle_Expr_Division theHandle) -> Handle_Expr_Division
        assign(Handle_Expr_Division self, Expr_Division thePtr) -> Handle_Expr_Division
        assign(Handle_Expr_Division self, Handle_Expr_Division theHandle) -> Handle_Expr_Division

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Division_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Division self) -> Expr_Division

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Division_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Division self) -> Expr_Division

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Division___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Division self) -> Expr_Division

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Division___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Division___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Division___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Division(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Division_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Division

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Division self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Division self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Division self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Division self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Division self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Division self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Division_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Division self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Division_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Division self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Division_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Division_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Division_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Division_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Division_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_Expr_Division self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_Expr_Division self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Division self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Division_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Division_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Division self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Division self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Division self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Division self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Division self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Division self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Division_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Division self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Division_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Division self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Division_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Division self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Division self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Division self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Division self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Division_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Division self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Division_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Division self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Division_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Division self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Division_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Division self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Division_DecrementRefCounter(self, *args)

Handle_Expr_Division_swigregister = _Expr.Handle_Expr_Division_swigregister
Handle_Expr_Division_swigregister(Handle_Expr_Division)

def Handle_Expr_Division_DownCast(thing):
    return _Expr.Handle_Expr_Division_DownCast(thing)
Handle_Expr_Division_DownCast = _Expr.Handle_Expr_Division_DownCast

class Handle_Expr_LogOf10(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_LogOf10 self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_LogOf10_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_LogOf10 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_LogOf10_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_LogOf10 self, Expr_LogOf10 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_LogOf10_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_LogOf10 self, Handle_Expr_LogOf10 theHandle) -> Handle_Expr_LogOf10
        assign(Handle_Expr_LogOf10 self, Expr_LogOf10 thePtr) -> Handle_Expr_LogOf10
        assign(Handle_Expr_LogOf10 self, Handle_Expr_LogOf10 theHandle) -> Handle_Expr_LogOf10

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_LogOf10_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_LogOf10 self) -> Expr_LogOf10

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_LogOf10_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_LogOf10 self) -> Expr_LogOf10

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_LogOf10___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_LogOf10 self) -> Expr_LogOf10

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_LogOf10___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_LogOf10___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_LogOf10___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_LogOf10(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_LogOf10_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_LogOf10

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_LogOf10 self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_LogOf10 self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_LogOf10 self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_LogOf10 self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_LogOf10 self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_LogOf10 self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_LogOf10_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_LogOf10 self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_LogOf10_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_LogOf10 self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_LogOf10_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LogOf10_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LogOf10_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_LogOf10_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_LogOf10 self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_LogOf10 self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOf10_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_LogOf10_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_LogOf10 self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_LogOf10 self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_LogOf10 self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_LogOf10 self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_LogOf10 self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_LogOf10 self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOf10_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_LogOf10 self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_LogOf10_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_LogOf10 self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_LogOf10_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_LogOf10 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_LogOf10 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_LogOf10 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_LogOf10 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOf10_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_LogOf10 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_LogOf10_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_LogOf10 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOf10_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_LogOf10 self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_LogOf10_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_LogOf10 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOf10_DecrementRefCounter(self, *args)

Handle_Expr_LogOf10_swigregister = _Expr.Handle_Expr_LogOf10_swigregister
Handle_Expr_LogOf10_swigregister(Handle_Expr_LogOf10)

def Handle_Expr_LogOf10_DownCast(thing):
    return _Expr.Handle_Expr_LogOf10_DownCast(thing)
Handle_Expr_LogOf10_DownCast = _Expr.Handle_Expr_LogOf10_DownCast

class Handle_Expr_SingleRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_SingleRelation self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_SingleRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_SingleRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_SingleRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_SingleRelation self, Expr_SingleRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_SingleRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_SingleRelation self, Handle_Expr_SingleRelation theHandle) -> Handle_Expr_SingleRelation
        assign(Handle_Expr_SingleRelation self, Expr_SingleRelation thePtr) -> Handle_Expr_SingleRelation
        assign(Handle_Expr_SingleRelation self, Handle_Expr_SingleRelation theHandle) -> Handle_Expr_SingleRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_SingleRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_SingleRelation self) -> Expr_SingleRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_SingleRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_SingleRelation self) -> Expr_SingleRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_SingleRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_SingleRelation self) -> Expr_SingleRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_SingleRelation___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_SingleRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_SingleRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_SingleRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_SingleRelation_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_SingleRelation

    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_SingleRelation self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SingleRelation_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_SingleRelation self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SingleRelation_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_SingleRelation self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SingleRelation_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_SingleRelation self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SingleRelation_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_SingleRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SingleRelation_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_SingleRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SingleRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_SingleRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SingleRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_SingleRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SingleRelation_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_SingleRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SingleRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_SingleRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SingleRelation_Replace(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_SingleRelation self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_SingleRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SingleRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SingleRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_SingleRelation self) -> Standard_Boolean

        Returns the current status of the relation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SingleRelation_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_SingleRelation self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SingleRelation_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_SingleRelation self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_SingleRelation_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_SingleRelation self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_SingleRelation_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_SingleRelation self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_SingleRelation_String(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_SingleRelation self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_SingleRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_SingleRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_SingleRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SingleRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_SingleRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_SingleRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SingleRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_SingleRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_SingleRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_SingleRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SingleRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_SingleRelation self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_SingleRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_SingleRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SingleRelation_DecrementRefCounter(self, *args)

Handle_Expr_SingleRelation_swigregister = _Expr.Handle_Expr_SingleRelation_swigregister
Handle_Expr_SingleRelation_swigregister(Handle_Expr_SingleRelation)

def Handle_Expr_SingleRelation_DownCast(thing):
    return _Expr.Handle_Expr_SingleRelation_DownCast(thing)
Handle_Expr_SingleRelation_DownCast = _Expr.Handle_Expr_SingleRelation_DownCast

class Handle_Expr_ArgTanh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArgTanh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArgTanh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArgTanh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArgTanh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArgTanh self, Expr_ArgTanh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArgTanh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArgTanh self, Handle_Expr_ArgTanh theHandle) -> Handle_Expr_ArgTanh
        assign(Handle_Expr_ArgTanh self, Expr_ArgTanh thePtr) -> Handle_Expr_ArgTanh
        assign(Handle_Expr_ArgTanh self, Handle_Expr_ArgTanh theHandle) -> Handle_Expr_ArgTanh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArgTanh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArgTanh self) -> Expr_ArgTanh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgTanh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArgTanh self) -> Expr_ArgTanh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgTanh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArgTanh self) -> Expr_ArgTanh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArgTanh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArgTanh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArgTanh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArgTanh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArgTanh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArgTanh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArgTanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArgTanh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArgTanh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArgTanh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArgTanh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArgTanh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgTanh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArgTanh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArgTanh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArgTanh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArgTanh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgTanh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgTanh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgTanh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArgTanh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArgTanh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgTanh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgTanh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArgTanh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArgTanh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArgTanh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArgTanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArgTanh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArgTanh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgTanh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArgTanh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgTanh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArgTanh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArgTanh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArgTanh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArgTanh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArgTanh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArgTanh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgTanh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArgTanh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArgTanh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArgTanh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgTanh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArgTanh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArgTanh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArgTanh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgTanh_DecrementRefCounter(self, *args)

Handle_Expr_ArgTanh_swigregister = _Expr.Handle_Expr_ArgTanh_swigregister
Handle_Expr_ArgTanh_swigregister(Handle_Expr_ArgTanh)

def Handle_Expr_ArgTanh_DownCast(thing):
    return _Expr.Handle_Expr_ArgTanh_DownCast(thing)
Handle_Expr_ArgTanh_DownCast = _Expr.Handle_Expr_ArgTanh_DownCast

class Expr_ArcCosine(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_ArcCosine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_ArcCosine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_ArcCosine self, Handle_Expr_GeneralExpression exp) -> Expr_ArcCosine

        Creates the Arccos of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_ArcCosine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_ArcCosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcCosine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_ArcCosine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcCosine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_ArcCosine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcCosine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_ArcCosine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_ArcCosine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_ArcCosine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_ArcCosine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_ArcCosine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_ArcCosine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_ArcCosine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_ArcCosine_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_ArcCosine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_ArcCosine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_ArcCosine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_ArcCosine
Expr_ArcCosine_swigregister = _Expr.Expr_ArcCosine_swigregister
Expr_ArcCosine_swigregister(Expr_ArcCosine)

def Expr_ArcCosine_get_type_name(*args):
    """
    Expr_ArcCosine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_ArcCosine_get_type_name(*args)

def Expr_ArcCosine_get_type_descriptor(*args):
    """
    Expr_ArcCosine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_ArcCosine_get_type_descriptor(*args)

class Expr_FunctionDerivative(Expr_GeneralFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_FunctionDerivative
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_FunctionDerivative(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_FunctionDerivative self, Handle_Expr_GeneralFunction func, Handle_Expr_NamedUnknown withX, Standard_Integer const deg) -> Expr_FunctionDerivative

        Creates a FunctionDerivative of degree <deg> relative
        to the <withX> variable.
        Raises OutOfRange if <deg> lower or equal to zero.

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :type withX: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int

        """
        this = _Expr.new_Expr_FunctionDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbOfVariables(self, *args):
        """
        NbOfVariables(Expr_FunctionDerivative self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_FunctionDerivative_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Expr_FunctionDerivative self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if <index> greater than
        NbOfVariables of <me>.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_FunctionDerivative_Variable(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_FunctionDerivative self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real values) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises DimensionMismatch if Length(vars) is different from
        Length(values).

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type values: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_FunctionDerivative_Evaluate(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_FunctionDerivative self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_FunctionDerivative_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_FunctionDerivative self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Expr_FunctionDerivative self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_FunctionDerivative_Derivative(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_FunctionDerivative self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_FunctionDerivative_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Expr_FunctionDerivative self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_FunctionDerivative_IsLinearOnVariable(self, *args)


    def Function(self, *args):
        """
        Function(Expr_FunctionDerivative self) -> Handle_Expr_GeneralFunction

        Returns the function of which <me> is the derivative.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_FunctionDerivative_Function(self, *args)


    def Degree(self, *args):
        """
        Degree(Expr_FunctionDerivative self) -> Standard_Integer

        Returns the degree of derivation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr_FunctionDerivative_Degree(self, *args)


    def DerivVariable(self, *args):
        """
        DerivVariable(Expr_FunctionDerivative self) -> Handle_Expr_NamedUnknown

        Returns the derivation variable of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_FunctionDerivative_DerivVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Expr_FunctionDerivative self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_FunctionDerivative_GetStringName(self, *args)


    def Expression(self, *args):
        """
        Expression(Expr_FunctionDerivative self) -> Handle_Expr_GeneralExpression

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_FunctionDerivative_Expression(self, *args)


    def UpdateExpression(self, *args):
        """UpdateExpression(Expr_FunctionDerivative self)"""
        return _Expr.Expr_FunctionDerivative_UpdateExpression(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_FunctionDerivative_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_FunctionDerivative_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_FunctionDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_FunctionDerivative
Expr_FunctionDerivative_swigregister = _Expr.Expr_FunctionDerivative_swigregister
Expr_FunctionDerivative_swigregister(Expr_FunctionDerivative)

def Expr_FunctionDerivative_get_type_name(*args):
    """
    Expr_FunctionDerivative_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_FunctionDerivative_get_type_name(*args)

def Expr_FunctionDerivative_get_type_descriptor(*args):
    """
    Expr_FunctionDerivative_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_FunctionDerivative_get_type_descriptor(*args)

class Handle_Expr_FunctionDerivative(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_FunctionDerivative self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_FunctionDerivative_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_FunctionDerivative self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_FunctionDerivative_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_FunctionDerivative self, Expr_FunctionDerivative thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_FunctionDerivative_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_FunctionDerivative self, Handle_Expr_FunctionDerivative theHandle) -> Handle_Expr_FunctionDerivative
        assign(Handle_Expr_FunctionDerivative self, Expr_FunctionDerivative thePtr) -> Handle_Expr_FunctionDerivative
        assign(Handle_Expr_FunctionDerivative self, Handle_Expr_FunctionDerivative theHandle) -> Handle_Expr_FunctionDerivative

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_FunctionDerivative_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_FunctionDerivative self) -> Expr_FunctionDerivative

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_FunctionDerivative_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_FunctionDerivative self) -> Expr_FunctionDerivative

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_FunctionDerivative___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_FunctionDerivative self) -> Expr_FunctionDerivative

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_FunctionDerivative___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_FunctionDerivative___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_FunctionDerivative___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_FunctionDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_FunctionDerivative_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_FunctionDerivative

    def NbOfVariables(self, *args):
        """
        NbOfVariables(Handle_Expr_FunctionDerivative self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_FunctionDerivative_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Handle_Expr_FunctionDerivative self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if <index> greater than
        NbOfVariables of <me>.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Handle_Expr_FunctionDerivative_Variable(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_FunctionDerivative self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real values) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises DimensionMismatch if Length(vars) is different from
        Length(values).

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type values: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_FunctionDerivative_Evaluate(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_FunctionDerivative self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_FunctionDerivative_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_FunctionDerivative self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Handle_Expr_FunctionDerivative self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_FunctionDerivative_Derivative(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_FunctionDerivative self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_FunctionDerivative_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Handle_Expr_FunctionDerivative self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_FunctionDerivative_IsLinearOnVariable(self, *args)


    def Function(self, *args):
        """
        Function(Handle_Expr_FunctionDerivative self) -> Handle_Expr_GeneralFunction

        Returns the function of which <me> is the derivative.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_FunctionDerivative_Function(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Expr_FunctionDerivative self) -> Standard_Integer

        Returns the degree of derivation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_FunctionDerivative_Degree(self, *args)


    def DerivVariable(self, *args):
        """
        DerivVariable(Handle_Expr_FunctionDerivative self) -> Handle_Expr_NamedUnknown

        Returns the derivation variable of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Handle_Expr_FunctionDerivative_DerivVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Handle_Expr_FunctionDerivative self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_FunctionDerivative_GetStringName(self, *args)


    def Expression(self, *args):
        """
        Expression(Handle_Expr_FunctionDerivative self) -> Handle_Expr_GeneralExpression

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_FunctionDerivative_Expression(self, *args)


    def UpdateExpression(self, *args):
        """UpdateExpression(Handle_Expr_FunctionDerivative self)"""
        return _Expr.Handle_Expr_FunctionDerivative_UpdateExpression(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_FunctionDerivative self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_FunctionDerivative_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_FunctionDerivative_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_FunctionDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_FunctionDerivative self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_FunctionDerivative_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_FunctionDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_FunctionDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_FunctionDerivative_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_FunctionDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_FunctionDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_FunctionDerivative_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_FunctionDerivative self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_FunctionDerivative_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_FunctionDerivative self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_FunctionDerivative_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_FunctionDerivative self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_FunctionDerivative_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_FunctionDerivative self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_FunctionDerivative_DecrementRefCounter(self, *args)

Handle_Expr_FunctionDerivative_swigregister = _Expr.Handle_Expr_FunctionDerivative_swigregister
Handle_Expr_FunctionDerivative_swigregister(Handle_Expr_FunctionDerivative)

def Handle_Expr_FunctionDerivative_DownCast(thing):
    return _Expr.Handle_Expr_FunctionDerivative_DownCast(thing)
Handle_Expr_FunctionDerivative_DownCast = _Expr.Handle_Expr_FunctionDerivative_DownCast

class Handle_Expr_InvalidFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_InvalidFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_InvalidFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_InvalidFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_InvalidFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_InvalidFunction self, Expr_InvalidFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_InvalidFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_InvalidFunction self, Handle_Expr_InvalidFunction theHandle) -> Handle_Expr_InvalidFunction
        assign(Handle_Expr_InvalidFunction self, Expr_InvalidFunction thePtr) -> Handle_Expr_InvalidFunction
        assign(Handle_Expr_InvalidFunction self, Handle_Expr_InvalidFunction theHandle) -> Handle_Expr_InvalidFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_InvalidFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_InvalidFunction self) -> Expr_InvalidFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_InvalidFunction self) -> Expr_InvalidFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_InvalidFunction self) -> Expr_InvalidFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_InvalidFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_InvalidFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_InvalidFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_InvalidFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_InvalidFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_InvalidFunction

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_InvalidFunction self, Standard_CString const theMessage) -> Handle_Expr_InvalidFunction

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidFunction

        """
        return _Expr.Handle_Expr_InvalidFunction_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_InvalidFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_InvalidFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_InvalidFunction self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_InvalidFunction_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_InvalidFunction self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidFunction_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_InvalidFunction self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidFunction_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_InvalidFunction self)
        Reraise(Handle_Expr_InvalidFunction self, Standard_CString const aMessage)
        Reraise(Handle_Expr_InvalidFunction self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_InvalidFunction_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_InvalidFunction self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_InvalidFunction_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_InvalidFunction self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_InvalidFunction_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_InvalidFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_InvalidFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_InvalidFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_InvalidFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_InvalidFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_InvalidFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_InvalidFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_InvalidFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_InvalidFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_InvalidFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_InvalidFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_InvalidFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidFunction_DecrementRefCounter(self, *args)

Handle_Expr_InvalidFunction_swigregister = _Expr.Handle_Expr_InvalidFunction_swigregister
Handle_Expr_InvalidFunction_swigregister(Handle_Expr_InvalidFunction)

def Handle_Expr_InvalidFunction_DownCast(thing):
    return _Expr.Handle_Expr_InvalidFunction_DownCast(thing)
Handle_Expr_InvalidFunction_DownCast = _Expr.Handle_Expr_InvalidFunction_DownCast

class Handle_Expr_ArgCosh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArgCosh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArgCosh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArgCosh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArgCosh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArgCosh self, Expr_ArgCosh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArgCosh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArgCosh self, Handle_Expr_ArgCosh theHandle) -> Handle_Expr_ArgCosh
        assign(Handle_Expr_ArgCosh self, Expr_ArgCosh thePtr) -> Handle_Expr_ArgCosh
        assign(Handle_Expr_ArgCosh self, Handle_Expr_ArgCosh theHandle) -> Handle_Expr_ArgCosh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArgCosh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArgCosh self) -> Expr_ArgCosh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgCosh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArgCosh self) -> Expr_ArgCosh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgCosh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArgCosh self) -> Expr_ArgCosh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArgCosh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArgCosh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArgCosh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArgCosh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArgCosh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArgCosh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArgCosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArgCosh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArgCosh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArgCosh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArgCosh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArgCosh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgCosh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArgCosh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArgCosh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArgCosh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArgCosh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgCosh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgCosh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgCosh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArgCosh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArgCosh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgCosh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgCosh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArgCosh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArgCosh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArgCosh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArgCosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArgCosh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArgCosh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgCosh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArgCosh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgCosh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArgCosh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArgCosh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArgCosh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArgCosh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArgCosh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArgCosh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgCosh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArgCosh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArgCosh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArgCosh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgCosh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArgCosh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArgCosh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArgCosh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgCosh_DecrementRefCounter(self, *args)

Handle_Expr_ArgCosh_swigregister = _Expr.Handle_Expr_ArgCosh_swigregister
Handle_Expr_ArgCosh_swigregister(Handle_Expr_ArgCosh)

def Handle_Expr_ArgCosh_DownCast(thing):
    return _Expr.Handle_Expr_ArgCosh_DownCast(thing)
Handle_Expr_ArgCosh_DownCast = _Expr.Handle_Expr_ArgCosh_DownCast

class Handle_Expr_Sinh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Sinh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Sinh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Sinh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Sinh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Sinh self, Expr_Sinh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Sinh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Sinh self, Handle_Expr_Sinh theHandle) -> Handle_Expr_Sinh
        assign(Handle_Expr_Sinh self, Expr_Sinh thePtr) -> Handle_Expr_Sinh
        assign(Handle_Expr_Sinh self, Handle_Expr_Sinh theHandle) -> Handle_Expr_Sinh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Sinh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Sinh self) -> Expr_Sinh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sinh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Sinh self) -> Expr_Sinh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sinh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Sinh self) -> Expr_Sinh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Sinh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Sinh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Sinh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Sinh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Sinh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Sinh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Sinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Sinh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Sinh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Sinh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Sinh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Sinh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sinh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Sinh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Sinh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Sinh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Sinh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sinh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sinh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sinh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Sinh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Sinh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sinh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sinh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Sinh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Sinh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Sinh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Sinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Sinh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Sinh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sinh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Sinh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sinh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Sinh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Sinh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Sinh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Sinh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Sinh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Sinh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sinh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Sinh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Sinh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Sinh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sinh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Sinh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Sinh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Sinh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sinh_DecrementRefCounter(self, *args)

Handle_Expr_Sinh_swigregister = _Expr.Handle_Expr_Sinh_swigregister
Handle_Expr_Sinh_swigregister(Handle_Expr_Sinh)

def Handle_Expr_Sinh_DownCast(thing):
    return _Expr.Handle_Expr_Sinh_DownCast(thing)
Handle_Expr_Sinh_DownCast = _Expr.Handle_Expr_Sinh_DownCast

class NCollection_Array1_Handle_Expr_GeneralExpression(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Expr_GeneralExpression self) -> NCollection_Array1< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Expr_GeneralExpression self) -> NCollection_Array1< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Expr_GeneralExpression self) -> NCollection_Array1< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Expr_GeneralExpression self) -> NCollection_Array1< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Expr.new_NCollection_Array1_Handle_Expr_GeneralExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_GeneralExpression theOther) -> NCollection_Array1_Handle_Expr_GeneralExpression

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_GeneralExpression theOther) -> NCollection_Array1_Handle_Expr_GeneralExpression

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_GeneralExpression theOther) -> NCollection_Array1_Handle_Expr_GeneralExpression
        assign(NCollection_Array1_Handle_Expr_GeneralExpression self, NCollection_Array1_Handle_Expr_GeneralExpression theOther) -> NCollection_Array1_Handle_Expr_GeneralExpression

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        @return first element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        @return last element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex) -> Handle_Expr_GeneralExpression

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, Handle_Expr_GeneralExpression theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Expr_GeneralExpression self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_Resize(self, *args)

    __swig_destroy__ = _Expr.delete_NCollection_Array1_Handle_Expr_GeneralExpression
NCollection_Array1_Handle_Expr_GeneralExpression_swigregister = _Expr.NCollection_Array1_Handle_Expr_GeneralExpression_swigregister
NCollection_Array1_Handle_Expr_GeneralExpression_swigregister(NCollection_Array1_Handle_Expr_GeneralExpression)


try:
	Expr_Array1OfGeneralExpression = NCollection_Array1_Handle_Expr_GeneralExpression
except NameError:
	pass # does not exist, probably ignored

class Handle_Expr_Equal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Equal self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Equal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Equal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Equal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Equal self, Expr_Equal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Equal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Equal self, Handle_Expr_Equal theHandle) -> Handle_Expr_Equal
        assign(Handle_Expr_Equal self, Expr_Equal thePtr) -> Handle_Expr_Equal
        assign(Handle_Expr_Equal self, Handle_Expr_Equal theHandle) -> Handle_Expr_Equal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Equal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Equal self) -> Expr_Equal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Equal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Equal self) -> Expr_Equal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Equal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Equal self) -> Expr_Equal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Equal___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Equal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Equal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Equal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Equal_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Equal

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_Equal self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Equal_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Equal self) -> Handle_Expr_GeneralRelation

        returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Equal_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_Equal self)

        Replaces NamedUnknowns by an associated expressions
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_Equal_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Equal self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Equal_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Equal self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Equal_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Equal self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Equal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Equal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Equal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_Equal self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Equal_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_Equal self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Equal_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_Equal self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Equal_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_Equal self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Equal_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Equal self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Equal_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_Equal self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Equal_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_Equal self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Equal_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_Equal self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Equal_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Equal self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Equal_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Equal self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Equal_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Equal self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Equal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Equal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Equal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Equal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Equal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Equal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Equal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Equal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Equal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Equal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Equal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Equal self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Equal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Equal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Equal_DecrementRefCounter(self, *args)

Handle_Expr_Equal_swigregister = _Expr.Handle_Expr_Equal_swigregister
Handle_Expr_Equal_swigregister(Handle_Expr_Equal)

def Handle_Expr_Equal_DownCast(thing):
    return _Expr.Handle_Expr_Equal_DownCast(thing)
Handle_Expr_Equal_DownCast = _Expr.Handle_Expr_Equal_DownCast

class Handle_Expr_GreaterThanOrEqual(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_GreaterThanOrEqual self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_GreaterThanOrEqual self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_GreaterThanOrEqual self, Expr_GreaterThanOrEqual thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_GreaterThanOrEqual theHandle) -> Handle_Expr_GreaterThanOrEqual
        assign(Handle_Expr_GreaterThanOrEqual self, Expr_GreaterThanOrEqual thePtr) -> Handle_Expr_GreaterThanOrEqual
        assign(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_GreaterThanOrEqual theHandle) -> Handle_Expr_GreaterThanOrEqual

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_GreaterThanOrEqual self) -> Expr_GreaterThanOrEqual

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_GreaterThanOrEqual self) -> Expr_GreaterThanOrEqual

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_GreaterThanOrEqual self) -> Expr_GreaterThanOrEqual

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_GreaterThanOrEqual___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_GreaterThanOrEqual___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_GreaterThanOrEqual(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_GreaterThanOrEqual_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_GreaterThanOrEqual

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_GreaterThanOrEqual self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_GreaterThanOrEqual self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_GreaterThanOrEqual self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_GreaterThanOrEqual self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GreaterThanOrEqual_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GreaterThanOrEqual_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_GreaterThanOrEqual self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_GreaterThanOrEqual self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_GreaterThanOrEqual self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_GreaterThanOrEqual self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_GreaterThanOrEqual self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_GreaterThanOrEqual self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_GreaterThanOrEqual self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_GreaterThanOrEqual self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_GreaterThanOrEqual self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_GreaterThanOrEqual self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_GreaterThanOrEqual self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_GreaterThanOrEqual self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_GreaterThanOrEqual self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_GreaterThanOrEqual self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_GreaterThanOrEqual self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GreaterThanOrEqual_DecrementRefCounter(self, *args)

Handle_Expr_GreaterThanOrEqual_swigregister = _Expr.Handle_Expr_GreaterThanOrEqual_swigregister
Handle_Expr_GreaterThanOrEqual_swigregister(Handle_Expr_GreaterThanOrEqual)

def Handle_Expr_GreaterThanOrEqual_DownCast(thing):
    return _Expr.Handle_Expr_GreaterThanOrEqual_DownCast(thing)
Handle_Expr_GreaterThanOrEqual_DownCast = _Expr.Handle_Expr_GreaterThanOrEqual_DownCast

class Expr_UnaryFunction(Expr_UnaryExpression):
    """
    Defines the use of an unary function in an expression
    with a given argument.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_UnaryFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_UnaryFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_UnaryFunction self, Handle_Expr_GeneralFunction func, Handle_Expr_GeneralExpression exp) -> Expr_UnaryFunction

        Creates me as <func>(<exp>).
        Raises exception if <func> is not unary.

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_UnaryFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Function(self, *args):
        """
        Function(Expr_UnaryFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Expr_UnaryFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_UnaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_UnaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_UnaryFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_UnaryFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnaryFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_UnaryFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_UnaryFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_UnaryFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_UnaryFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_UnaryFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_UnaryFunction_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_UnaryFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_UnaryFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_UnaryFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_UnaryFunction
Expr_UnaryFunction_swigregister = _Expr.Expr_UnaryFunction_swigregister
Expr_UnaryFunction_swigregister(Expr_UnaryFunction)

def Expr_UnaryFunction_get_type_name(*args):
    """
    Expr_UnaryFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_UnaryFunction_get_type_name(*args)

def Expr_UnaryFunction_get_type_descriptor(*args):
    """
    Expr_UnaryFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_UnaryFunction_get_type_descriptor(*args)

class Handle_Expr_NamedFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NamedFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NamedFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NamedFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NamedFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NamedFunction self, Expr_NamedFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NamedFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NamedFunction self, Handle_Expr_NamedFunction theHandle) -> Handle_Expr_NamedFunction
        assign(Handle_Expr_NamedFunction self, Expr_NamedFunction thePtr) -> Handle_Expr_NamedFunction
        assign(Handle_Expr_NamedFunction self, Handle_Expr_NamedFunction theHandle) -> Handle_Expr_NamedFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NamedFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NamedFunction self) -> Expr_NamedFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NamedFunction self) -> Expr_NamedFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NamedFunction self) -> Expr_NamedFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NamedFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NamedFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NamedFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NamedFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NamedFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NamedFunction

    def SetName(self, *args):
        """
        SetName(Handle_Expr_NamedFunction self, TCollection_AsciiString newname)

        Sets the name <newname> to <me>.

        :type newname: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedFunction_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_Expr_NamedFunction self) -> TCollection_AsciiString

        Returns the name assigned to <me>

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedFunction_GetName(self, *args)


    def NbOfVariables(self, *args):
        """
        NbOfVariables(Handle_Expr_NamedFunction self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedFunction_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Handle_Expr_NamedFunction self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if <index> is greater than
        NbOfVariables of <me>, or less than or equal to zero.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Handle_Expr_NamedFunction_Variable(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_NamedFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real values) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises DimensionMismatch if Length(vars) is different from
        Length(values).

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type values: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedFunction_Evaluate(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_NamedFunction self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_NamedFunction_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_NamedFunction self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Handle_Expr_NamedFunction self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_NamedFunction_Derivative(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_NamedFunction self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedFunction_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Handle_Expr_NamedFunction self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedFunction_IsLinearOnVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Handle_Expr_NamedFunction self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedFunction_GetStringName(self, *args)


    def Expression(self, *args):
        """
        Expression(Handle_Expr_NamedFunction self) -> Handle_Expr_GeneralExpression

        Returns equivalent expression of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedFunction_Expression(self, *args)


    def SetExpression(self, *args):
        """
        SetExpression(Handle_Expr_NamedFunction self, Handle_Expr_GeneralExpression exp)

        Modifies expression of <me>.
        Warning: Beware of derivatives. See FunctionDerivative

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedFunction_SetExpression(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NamedFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NamedFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_NamedFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NamedFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NamedFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NamedFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NamedFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NamedFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NamedFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NamedFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NamedFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NamedFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NamedFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NamedFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedFunction_DecrementRefCounter(self, *args)

Handle_Expr_NamedFunction_swigregister = _Expr.Handle_Expr_NamedFunction_swigregister
Handle_Expr_NamedFunction_swigregister(Handle_Expr_NamedFunction)

def Handle_Expr_NamedFunction_DownCast(thing):
    return _Expr.Handle_Expr_NamedFunction_DownCast(thing)
Handle_Expr_NamedFunction_DownCast = _Expr.Handle_Expr_NamedFunction_DownCast

class Expr_InvalidAssignment(Expr_ExprFailure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_InvalidAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_InvalidAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_InvalidAssignment self) -> Expr_InvalidAssignment
        __init__(Expr_InvalidAssignment self, Standard_CString const theMessage) -> Expr_InvalidAssignment

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Expr.new_Expr_InvalidAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidAssignment

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidAssignment

        """
        return _Expr.Expr_InvalidAssignment_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_InvalidAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_InvalidAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_InvalidAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_InvalidAssignment
Expr_InvalidAssignment_swigregister = _Expr.Expr_InvalidAssignment_swigregister
Expr_InvalidAssignment_swigregister(Expr_InvalidAssignment)

def Expr_InvalidAssignment_NewInstance(*args):
    """
    Expr_InvalidAssignment_NewInstance(Standard_CString const theMessage) -> Handle_Expr_InvalidAssignment

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidAssignment

    """
    return _Expr.Expr_InvalidAssignment_NewInstance(*args)

def Expr_InvalidAssignment_get_type_name(*args):
    """
    Expr_InvalidAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_InvalidAssignment_get_type_name(*args)

def Expr_InvalidAssignment_get_type_descriptor(*args):
    """
    Expr_InvalidAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_InvalidAssignment_get_type_descriptor(*args)

class Handle_Expr_InvalidAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_InvalidAssignment self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_InvalidAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_InvalidAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_InvalidAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_InvalidAssignment self, Expr_InvalidAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_InvalidAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_InvalidAssignment self, Handle_Expr_InvalidAssignment theHandle) -> Handle_Expr_InvalidAssignment
        assign(Handle_Expr_InvalidAssignment self, Expr_InvalidAssignment thePtr) -> Handle_Expr_InvalidAssignment
        assign(Handle_Expr_InvalidAssignment self, Handle_Expr_InvalidAssignment theHandle) -> Handle_Expr_InvalidAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_InvalidAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_InvalidAssignment self) -> Expr_InvalidAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_InvalidAssignment self) -> Expr_InvalidAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_InvalidAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_InvalidAssignment self) -> Expr_InvalidAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_InvalidAssignment___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_InvalidAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_InvalidAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_InvalidAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_InvalidAssignment_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_InvalidAssignment

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_InvalidAssignment self, Standard_CString const theMessage) -> Handle_Expr_InvalidAssignment

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_InvalidAssignment

        """
        return _Expr.Handle_Expr_InvalidAssignment_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_InvalidAssignment self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_InvalidAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_InvalidAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_InvalidAssignment self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_InvalidAssignment_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_InvalidAssignment self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidAssignment_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_InvalidAssignment self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_InvalidAssignment_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_InvalidAssignment self)
        Reraise(Handle_Expr_InvalidAssignment self, Standard_CString const aMessage)
        Reraise(Handle_Expr_InvalidAssignment self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_InvalidAssignment_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_InvalidAssignment self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_InvalidAssignment_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_InvalidAssignment self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_InvalidAssignment_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_InvalidAssignment self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_InvalidAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_InvalidAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_InvalidAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_InvalidAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_InvalidAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_InvalidAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_InvalidAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_InvalidAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_InvalidAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_InvalidAssignment self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_InvalidAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_InvalidAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_InvalidAssignment_DecrementRefCounter(self, *args)

Handle_Expr_InvalidAssignment_swigregister = _Expr.Handle_Expr_InvalidAssignment_swigregister
Handle_Expr_InvalidAssignment_swigregister(Handle_Expr_InvalidAssignment)

def Handle_Expr_InvalidAssignment_DownCast(thing):
    return _Expr.Handle_Expr_InvalidAssignment_DownCast(thing)
Handle_Expr_InvalidAssignment_DownCast = _Expr.Handle_Expr_InvalidAssignment_DownCast

class Handle_Expr_NamedConstant(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NamedConstant self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NamedConstant_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NamedConstant self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NamedConstant_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NamedConstant self, Expr_NamedConstant thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NamedConstant_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NamedConstant self, Handle_Expr_NamedConstant theHandle) -> Handle_Expr_NamedConstant
        assign(Handle_Expr_NamedConstant self, Expr_NamedConstant thePtr) -> Handle_Expr_NamedConstant
        assign(Handle_Expr_NamedConstant self, Handle_Expr_NamedConstant theHandle) -> Handle_Expr_NamedConstant

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NamedConstant_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NamedConstant self) -> Expr_NamedConstant

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedConstant_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NamedConstant self) -> Expr_NamedConstant

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedConstant___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NamedConstant self) -> Expr_NamedConstant

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NamedConstant___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NamedConstant___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NamedConstant___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NamedConstant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NamedConstant_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NamedConstant

    def GetValue(self, *args):
        """
        GetValue(Handle_Expr_NamedConstant self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedConstant_GetValue(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_NamedConstant self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> (always returns zero)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedConstant_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_NamedConstant_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_NamedConstant self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_NamedConstant self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.
        (returns always False)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_NamedConstant self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_NamedConstant self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_NamedConstant self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_NamedConstant self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_NamedConstant self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedConstant_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_NamedConstant self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedConstant_Evaluate(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NamedConstant self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NamedConstant_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedConstant_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedConstant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _Expr.Handle_Expr_NamedConstant_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_Expr_NamedConstant self, TCollection_AsciiString name)

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedConstant_SetName(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_NamedConstant self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method redefines to a True
        value the GeneralExpression method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_NamedConstant self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_IsIdentical(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_NamedConstant self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedConstant_String(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_NamedConstant self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedConstant_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NamedConstant self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NamedConstant_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NamedConstant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NamedConstant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NamedConstant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NamedConstant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedConstant_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NamedConstant self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NamedConstant_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NamedConstant self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedConstant_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NamedConstant self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NamedConstant_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NamedConstant self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedConstant_DecrementRefCounter(self, *args)

Handle_Expr_NamedConstant_swigregister = _Expr.Handle_Expr_NamedConstant_swigregister
Handle_Expr_NamedConstant_swigregister(Handle_Expr_NamedConstant)

def Handle_Expr_NamedConstant_DownCast(thing):
    return _Expr.Handle_Expr_NamedConstant_DownCast(thing)
Handle_Expr_NamedConstant_DownCast = _Expr.Handle_Expr_NamedConstant_DownCast

class Handle_Expr_ArcTangent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArcTangent self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArcTangent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArcTangent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArcTangent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArcTangent self, Expr_ArcTangent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArcTangent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArcTangent self, Handle_Expr_ArcTangent theHandle) -> Handle_Expr_ArcTangent
        assign(Handle_Expr_ArcTangent self, Expr_ArcTangent thePtr) -> Handle_Expr_ArcTangent
        assign(Handle_Expr_ArcTangent self, Handle_Expr_ArcTangent theHandle) -> Handle_Expr_ArcTangent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArcTangent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArcTangent self) -> Expr_ArcTangent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcTangent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArcTangent self) -> Expr_ArcTangent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcTangent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArcTangent self) -> Expr_ArcTangent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArcTangent___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArcTangent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArcTangent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArcTangent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArcTangent_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArcTangent

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArcTangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArcTangent self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArcTangent self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArcTangent self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArcTangent self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArcTangent self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcTangent_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArcTangent self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArcTangent_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArcTangent self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArcTangent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcTangent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcTangent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcTangent_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArcTangent self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArcTangent self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcTangent_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcTangent_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArcTangent self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArcTangent self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArcTangent self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArcTangent self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArcTangent self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArcTangent self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcTangent_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArcTangent self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcTangent_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArcTangent self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArcTangent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArcTangent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArcTangent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArcTangent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArcTangent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcTangent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArcTangent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArcTangent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArcTangent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcTangent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArcTangent self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArcTangent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArcTangent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcTangent_DecrementRefCounter(self, *args)

Handle_Expr_ArcTangent_swigregister = _Expr.Handle_Expr_ArcTangent_swigregister
Handle_Expr_ArcTangent_swigregister(Handle_Expr_ArcTangent)

def Handle_Expr_ArcTangent_DownCast(thing):
    return _Expr.Handle_Expr_ArcTangent_DownCast(thing)
Handle_Expr_ArcTangent_DownCast = _Expr.Handle_Expr_ArcTangent_DownCast

class NCollection_Sequence_Handle_Expr_GeneralExpression(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Expr.new_NCollection_Sequence_Handle_Expr_GeneralExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Expr_GeneralExpression self)

        Reverse sequence


        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Expr_GeneralExpression self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence_Handle_Expr_GeneralExpression theOther) -> NCollection_Sequence_Handle_Expr_GeneralExpression

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence_Handle_Expr_GeneralExpression theOther) -> NCollection_Sequence_Handle_Expr_GeneralExpression

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem)
        Append(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence_Handle_Expr_GeneralExpression theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem)
        Prepend(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence_Handle_Expr_GeneralExpression theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, Handle_Expr_GeneralExpression theItem)
        InsertBefore(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralExpression theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralExpression self, NCollection_Sequence< opencascade::handle< Expr_GeneralExpression > >::Iterator & thePosition, Handle_Expr_GeneralExpression theItem)
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralExpression theSeq)
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, Handle_Expr_GeneralExpression theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralExpression theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        First item access

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Expr_GeneralExpression self) -> Handle_Expr_GeneralExpression

        Last item access

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex) -> Handle_Expr_GeneralExpression

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Expr_GeneralExpression self, Standard_Integer const theIndex, Handle_Expr_GeneralExpression theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_SetValue(self, *args)


    def __iter__(self):
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression___iter__(self)
    __swig_destroy__ = _Expr.delete_NCollection_Sequence_Handle_Expr_GeneralExpression
NCollection_Sequence_Handle_Expr_GeneralExpression_swigregister = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_swigregister
NCollection_Sequence_Handle_Expr_GeneralExpression_swigregister(NCollection_Sequence_Handle_Expr_GeneralExpression)

def NCollection_Sequence_Handle_Expr_GeneralExpression_delNode(*args):
    """
    NCollection_Sequence_Handle_Expr_GeneralExpression_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_delNode(*args)

class NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Expr.new_NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper

    def __next__(self):
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper_swigregister = _Expr.NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper_swigregister
NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper_swigregister(NCollection_Sequence_Handle_Expr_GeneralExpression_IteratorHelper)


try:
	Expr_SequenceOfGeneralExpression = NCollection_Sequence_Handle_Expr_GeneralExpression
except NameError:
	pass # does not exist, probably ignored

class Handle_Expr_Sum(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Sum self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Sum_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Sum self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Sum_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Sum self, Expr_Sum thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Sum_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Sum self, Handle_Expr_Sum theHandle) -> Handle_Expr_Sum
        assign(Handle_Expr_Sum self, Expr_Sum thePtr) -> Handle_Expr_Sum
        assign(Handle_Expr_Sum self, Handle_Expr_Sum theHandle) -> Handle_Expr_Sum

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Sum_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Sum self) -> Expr_Sum

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sum_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Sum self) -> Expr_Sum

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sum___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Sum self) -> Expr_Sum

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Sum___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Sum___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Sum___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Sum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Sum_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Sum

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Sum self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Sum self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Sum self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Sum self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Sum self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Sum self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Sum self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sum_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Sum self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Sum_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Sum self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Sum_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sum_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sum_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbOperands(self, *args):
        """
        NbOperands(Handle_Expr_Sum self) -> Standard_Integer

        returns the number of operands contained in <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sum_NbOperands(self, *args)


    def Operand(self, *args):
        """
        Returns the <index>-th operand used in <me>.
        An exception is raised if index is out of range

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sum_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Sum self, Handle_Expr_GeneralExpression exp, Standard_Integer const index)

        Sets the <index>-th operand used in <me>.
        An exception is raised if <index> is out of range
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type index: int

        """
        return _Expr.Handle_Expr_Sum_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Sum self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 2)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sum_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the sub-expression denoted by <I> in <me>
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sum_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Sum self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Sum self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Sum self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Sum self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sum_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Sum self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_IsShareable(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Sum self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sum_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Sum self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Sum_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Sum self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Sum self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Sum self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Sum self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sum_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Sum self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Sum_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Sum self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sum_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Sum self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Sum_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Sum self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sum_DecrementRefCounter(self, *args)

Handle_Expr_Sum_swigregister = _Expr.Handle_Expr_Sum_swigregister
Handle_Expr_Sum_swigregister(Handle_Expr_Sum)

def Handle_Expr_Sum_DownCast(thing):
    return _Expr.Handle_Expr_Sum_DownCast(thing)
Handle_Expr_Sum_DownCast = _Expr.Handle_Expr_Sum_DownCast

class Handle_Expr_BinaryExpression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_BinaryExpression self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_BinaryExpression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_BinaryExpression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_BinaryExpression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_BinaryExpression self, Expr_BinaryExpression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_BinaryExpression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_BinaryExpression self, Handle_Expr_BinaryExpression theHandle) -> Handle_Expr_BinaryExpression
        assign(Handle_Expr_BinaryExpression self, Expr_BinaryExpression thePtr) -> Handle_Expr_BinaryExpression
        assign(Handle_Expr_BinaryExpression self, Handle_Expr_BinaryExpression theHandle) -> Handle_Expr_BinaryExpression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_BinaryExpression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_BinaryExpression self) -> Expr_BinaryExpression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_BinaryExpression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_BinaryExpression self) -> Expr_BinaryExpression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_BinaryExpression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_BinaryExpression self) -> Expr_BinaryExpression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_BinaryExpression___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_BinaryExpression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_BinaryExpression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_BinaryExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_BinaryExpression_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_BinaryExpression

    def FirstOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryExpression_FirstOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondOperand(self, *args):
        """
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryExpression_SecondOperand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstOperand(self, *args):
        """
        SetFirstOperand(Handle_Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets first operand of <me>
        Raises InvalidOperand if exp = me

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_SetFirstOperand(self, *args)


    def SetSecondOperand(self, *args):
        """
        SetSecondOperand(Handle_Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp)

        Sets second operand of <me>
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_SetSecondOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_BinaryExpression self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_BinaryExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_BinaryExpression self) -> Standard_Boolean

        Does <me> contain NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_BinaryExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_BinaryExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_BinaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_Simplified(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_BinaryExpression self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_BinaryExpression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_BinaryExpression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_BinaryExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_BinaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_BinaryExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_Copy(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_BinaryExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_IsLinear(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_BinaryExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_BinaryExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        Warning: This method does not include any simplification before
        testing. It could also be very slow; to be used
        carefully.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_IsIdentical(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_BinaryExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_BinaryExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_BinaryExpression_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_BinaryExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_BinaryExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_BinaryExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_BinaryExpression_EvaluateNumeric(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_BinaryExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_BinaryExpression_String(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_BinaryExpression self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_BinaryExpression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_BinaryExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_BinaryExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_BinaryExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_BinaryExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_BinaryExpression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_BinaryExpression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_BinaryExpression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_BinaryExpression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryExpression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_BinaryExpression self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_BinaryExpression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_BinaryExpression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_BinaryExpression_DecrementRefCounter(self, *args)

Handle_Expr_BinaryExpression_swigregister = _Expr.Handle_Expr_BinaryExpression_swigregister
Handle_Expr_BinaryExpression_swigregister(Handle_Expr_BinaryExpression)

def Handle_Expr_BinaryExpression_DownCast(thing):
    return _Expr.Handle_Expr_BinaryExpression_DownCast(thing)
Handle_Expr_BinaryExpression_DownCast = _Expr.Handle_Expr_BinaryExpression_DownCast

class Handle_Expr_GeneralFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_GeneralFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_GeneralFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_GeneralFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_GeneralFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_GeneralFunction self, Expr_GeneralFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_GeneralFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theHandle) -> Handle_Expr_GeneralFunction
        assign(Handle_Expr_GeneralFunction self, Expr_GeneralFunction thePtr) -> Handle_Expr_GeneralFunction
        assign(Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theHandle) -> Handle_Expr_GeneralFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_GeneralFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_GeneralFunction self) -> Expr_GeneralFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_GeneralFunction self) -> Expr_GeneralFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_GeneralFunction self) -> Expr_GeneralFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_GeneralFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_GeneralFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_GeneralFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_GeneralFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_GeneralFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_GeneralFunction

    def NbOfVariables(self, *args):
        """
        NbOfVariables(Handle_Expr_GeneralFunction self) -> Standard_Integer

        Returns the number of variables of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralFunction_NbOfVariables(self, *args)


    def Variable(self, *args):
        """
        Variable(Handle_Expr_GeneralFunction self, Standard_Integer const index) -> Handle_Expr_NamedUnknown

        Returns the variable denoted by <index> in <me>.
        Raises OutOfRange if index > NbOfVariables.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Handle_Expr_GeneralFunction_Variable(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_GeneralFunction self) -> Handle_Expr_GeneralFunction

        Returns a copy of <me> with the same form.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_GeneralFunction_Copy(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_GeneralFunction self, Handle_Expr_NamedUnknown var) -> Handle_Expr_GeneralFunction
        Derivative(Handle_Expr_GeneralFunction self, Handle_Expr_NamedUnknown var, Standard_Integer const deg) -> Handle_Expr_GeneralFunction

        Returns Derivative of <me> for variable <var> with
        degree <deg>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type deg: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_GeneralFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_GeneralFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Computes the value of <me> with the given variables.
        Raises NotEvaluable if <vars> does not match all variables
        of <me>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_GeneralFunction_Evaluate(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction func) -> Standard_Boolean

        Tests if <me> and <func> are similar functions (same
        name and same used expression).

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralFunction_IsIdentical(self, *args)


    def IsLinearOnVariable(self, *args):
        """
        IsLinearOnVariable(Handle_Expr_GeneralFunction self, Standard_Integer const index) -> Standard_Boolean

        Tests if <me> is linear on variable on range <index>

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralFunction_IsLinearOnVariable(self, *args)


    def GetStringName(self, *args):
        """
        GetStringName(Handle_Expr_GeneralFunction self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_GeneralFunction_GetStringName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_GeneralFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_GeneralFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_GeneralFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_GeneralFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_GeneralFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_GeneralFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_GeneralFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_GeneralFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_GeneralFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_GeneralFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_GeneralFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_GeneralFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_GeneralFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_GeneralFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralFunction_DecrementRefCounter(self, *args)

Handle_Expr_GeneralFunction_swigregister = _Expr.Handle_Expr_GeneralFunction_swigregister
Handle_Expr_GeneralFunction_swigregister(Handle_Expr_GeneralFunction)

def Handle_Expr_GeneralFunction_DownCast(thing):
    return _Expr.Handle_Expr_GeneralFunction_DownCast(thing)
Handle_Expr_GeneralFunction_DownCast = _Expr.Handle_Expr_GeneralFunction_DownCast

class Expr_UnknownIterator(object):
    """
    Describes an iterator on NamedUnknowns contained
    in any GeneralExpression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Expr_UnknownIterator self, Handle_Expr_GeneralExpression exp) -> Expr_UnknownIterator

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_UnknownIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(Expr_UnknownIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_UnknownIterator_More(self, *args)


    def Next(self, *args):
        """Next(Expr_UnknownIterator self)"""
        return _Expr.Expr_UnknownIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Expr_UnknownIterator self) -> Handle_Expr_NamedUnknown

        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedUnknown

        """
        return _Expr.Expr_UnknownIterator_Value(self, *args)

    __swig_destroy__ = _Expr.delete_Expr_UnknownIterator
Expr_UnknownIterator_swigregister = _Expr.Expr_UnknownIterator_swigregister
Expr_UnknownIterator_swigregister(Expr_UnknownIterator)

class Expr_Tanh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Tanh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Tanh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Tanh self, Handle_Expr_GeneralExpression exp) -> Expr_Tanh

        Creates the hyperbolic tangent of <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Tanh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Tanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tanh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Tanh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tanh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Tanh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Tanh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Tanh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Tanh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Tanh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Tanh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Tanh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Tanh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Tanh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Tanh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Tanh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Tanh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Tanh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Tanh
Expr_Tanh_swigregister = _Expr.Expr_Tanh_swigregister
Expr_Tanh_swigregister(Expr_Tanh)

def Expr_Tanh_get_type_name(*args):
    """
    Expr_Tanh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Tanh_get_type_name(*args)

def Expr_Tanh_get_type_descriptor(*args):
    """
    Expr_Tanh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Tanh_get_type_descriptor(*args)

class Expr_LogOfe(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_LogOfe
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_LogOfe(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_LogOfe self, Handle_Expr_GeneralExpression exp) -> Expr_LogOfe

        Creates the natural logarithm of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_LogOfe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_LogOfe self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOfe_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_LogOfe self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOfe_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_LogOfe self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LogOfe_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_LogOfe self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LogOfe_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_LogOfe self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_LogOfe_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_LogOfe self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_LogOfe_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_LogOfe self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_LogOfe_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_LogOfe_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_LogOfe_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_LogOfe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_LogOfe
Expr_LogOfe_swigregister = _Expr.Expr_LogOfe_swigregister
Expr_LogOfe_swigregister(Expr_LogOfe)

def Expr_LogOfe_get_type_name(*args):
    """
    Expr_LogOfe_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_LogOfe_get_type_name(*args)

def Expr_LogOfe_get_type_descriptor(*args):
    """
    Expr_LogOfe_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_LogOfe_get_type_descriptor(*args)

class Handle_Expr_ArcCosine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArcCosine self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArcCosine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArcCosine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArcCosine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArcCosine self, Expr_ArcCosine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArcCosine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArcCosine self, Handle_Expr_ArcCosine theHandle) -> Handle_Expr_ArcCosine
        assign(Handle_Expr_ArcCosine self, Expr_ArcCosine thePtr) -> Handle_Expr_ArcCosine
        assign(Handle_Expr_ArcCosine self, Handle_Expr_ArcCosine theHandle) -> Handle_Expr_ArcCosine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArcCosine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArcCosine self) -> Expr_ArcCosine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcCosine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArcCosine self) -> Expr_ArcCosine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArcCosine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArcCosine self) -> Expr_ArcCosine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArcCosine___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArcCosine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArcCosine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArcCosine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArcCosine_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArcCosine

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArcCosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArcCosine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArcCosine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArcCosine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArcCosine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArcCosine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcCosine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArcCosine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArcCosine_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArcCosine self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArcCosine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcCosine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArcCosine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcCosine_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArcCosine self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArcCosine self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcCosine_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArcCosine_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArcCosine self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArcCosine self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArcCosine self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArcCosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArcCosine self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArcCosine self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArcCosine_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArcCosine self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArcCosine_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArcCosine self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArcCosine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArcCosine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArcCosine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArcCosine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArcCosine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArcCosine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArcCosine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArcCosine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArcCosine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcCosine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArcCosine self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArcCosine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArcCosine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArcCosine_DecrementRefCounter(self, *args)

Handle_Expr_ArcCosine_swigregister = _Expr.Handle_Expr_ArcCosine_swigregister
Handle_Expr_ArcCosine_swigregister(Handle_Expr_ArcCosine)

def Handle_Expr_ArcCosine_DownCast(thing):
    return _Expr.Handle_Expr_ArcCosine_DownCast(thing)
Handle_Expr_ArcCosine_DownCast = _Expr.Handle_Expr_ArcCosine_DownCast

class Handle_Expr_Different(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Different self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Different_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Different self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Different_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Different self, Expr_Different thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Different_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Different self, Handle_Expr_Different theHandle) -> Handle_Expr_Different
        assign(Handle_Expr_Different self, Expr_Different thePtr) -> Handle_Expr_Different
        assign(Handle_Expr_Different self, Handle_Expr_Different theHandle) -> Handle_Expr_Different

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Different_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Different self) -> Expr_Different

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Different_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Different self) -> Expr_Different

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Different___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Different self) -> Expr_Different

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Different___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Different___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Different___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Different(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Different_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Different

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_Different self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Different_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Different self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Different_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_Different self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_Different_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Different self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Different_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Different self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Different_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Different self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Different_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Different_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Different_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_Different self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Different_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_Different self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Different_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_Different self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Different_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_Different self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Different_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Different self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Different_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_Different self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Different_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_Different self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Different_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_Different self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_Different_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Different self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Different_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Different self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Different_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Different self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Different_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Different self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Different self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Different_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Different self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Different self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Different_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Different self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Different_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Different self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Different_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Different self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Different_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Different self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Different_DecrementRefCounter(self, *args)

Handle_Expr_Different_swigregister = _Expr.Handle_Expr_Different_swigregister
Handle_Expr_Different_swigregister(Handle_Expr_Different)

def Handle_Expr_Different_DownCast(thing):
    return _Expr.Handle_Expr_Different_DownCast(thing)
Handle_Expr_Different_DownCast = _Expr.Handle_Expr_Different_DownCast

class Handle_Expr_Sine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Sine self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Sine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Sine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Sine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Sine self, Expr_Sine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Sine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Sine self, Handle_Expr_Sine theHandle) -> Handle_Expr_Sine
        assign(Handle_Expr_Sine self, Expr_Sine thePtr) -> Handle_Expr_Sine
        assign(Handle_Expr_Sine self, Handle_Expr_Sine theHandle) -> Handle_Expr_Sine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Sine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Sine self) -> Expr_Sine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Sine self) -> Expr_Sine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Sine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Sine self) -> Expr_Sine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Sine___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Sine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Sine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Sine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Sine_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Sine

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Sine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Sine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Sine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Sine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Sine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Sine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Sine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Sine_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Sine self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Sine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Sine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sine_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Sine self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Sine self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sine_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Sine_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Sine self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Sine self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Sine self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Sine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Sine self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Sine self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Sine_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Sine self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Sine_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Sine self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Sine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Sine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Sine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Sine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Sine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Sine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Sine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Sine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Sine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Sine self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Sine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Sine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Sine_DecrementRefCounter(self, *args)

Handle_Expr_Sine_swigregister = _Expr.Handle_Expr_Sine_swigregister
Handle_Expr_Sine_swigregister(Handle_Expr_Sine)

def Handle_Expr_Sine_DownCast(thing):
    return _Expr.Handle_Expr_Sine_DownCast(thing)
Handle_Expr_Sine_DownCast = _Expr.Handle_Expr_Sine_DownCast

class Handle_Expr_PolyExpression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_PolyExpression self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_PolyExpression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_PolyExpression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_PolyExpression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_PolyExpression self, Expr_PolyExpression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_PolyExpression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_PolyExpression self, Handle_Expr_PolyExpression theHandle) -> Handle_Expr_PolyExpression
        assign(Handle_Expr_PolyExpression self, Expr_PolyExpression thePtr) -> Handle_Expr_PolyExpression
        assign(Handle_Expr_PolyExpression self, Handle_Expr_PolyExpression theHandle) -> Handle_Expr_PolyExpression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_PolyExpression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_PolyExpression self) -> Expr_PolyExpression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_PolyExpression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_PolyExpression self) -> Expr_PolyExpression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_PolyExpression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_PolyExpression self) -> Expr_PolyExpression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_PolyExpression___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_PolyExpression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_PolyExpression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_PolyExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_PolyExpression_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_PolyExpression

    def NbOperands(self, *args):
        """
        NbOperands(Handle_Expr_PolyExpression self) -> Standard_Integer

        returns the number of operands contained in <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyExpression_NbOperands(self, *args)


    def Operand(self, *args):
        """
        Returns the <index>-th operand used in <me>.
        An exception is raised if index is out of range

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_PolyExpression_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_PolyExpression self, Handle_Expr_GeneralExpression exp, Standard_Integer const index)

        Sets the <index>-th operand used in <me>.
        An exception is raised if <index> is out of range
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type index: int

        """
        return _Expr.Handle_Expr_PolyExpression_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_PolyExpression self) -> Standard_Integer

        returns the number of sub-expressions contained
        in <me> ( >= 2)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the sub-expression denoted by <I> in <me>
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_PolyExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_PolyExpression self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_PolyExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_PolyExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_PolyExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_Simplified(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_PolyExpression self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_PolyExpression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_PolyExpression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_PolyExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_PolyExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_PolyExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_Copy(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_PolyExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_IsLinear(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_PolyExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_PolyExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        Warning: This method does not include any simplification before
        testing. It could also be very slow; to be used
        carefully.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_IsIdentical(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_PolyExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_PolyExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_PolyExpression_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_PolyExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_PolyExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_PolyExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_PolyExpression_EvaluateNumeric(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_PolyExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_PolyExpression_String(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_PolyExpression self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_PolyExpression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_PolyExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_PolyExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_PolyExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_PolyExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_PolyExpression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_PolyExpression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_PolyExpression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_PolyExpression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyExpression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_PolyExpression self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_PolyExpression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_PolyExpression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_PolyExpression_DecrementRefCounter(self, *args)

Handle_Expr_PolyExpression_swigregister = _Expr.Handle_Expr_PolyExpression_swigregister
Handle_Expr_PolyExpression_swigregister(Handle_Expr_PolyExpression)

def Handle_Expr_PolyExpression_DownCast(thing):
    return _Expr.Handle_Expr_PolyExpression_DownCast(thing)
Handle_Expr_PolyExpression_DownCast = _Expr.Handle_Expr_PolyExpression_DownCast

class Expr_Cosh(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Cosh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Cosh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Cosh self, Handle_Expr_GeneralExpression exp) -> Expr_Cosh

        Creates the Cosh of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Cosh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Cosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Cosh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Cosh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Cosh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Cosh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Cosh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Cosh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Cosh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Cosh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Cosh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Cosh_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Cosh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Cosh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Cosh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Cosh
Expr_Cosh_swigregister = _Expr.Expr_Cosh_swigregister
Expr_Cosh_swigregister(Expr_Cosh)

def Expr_Cosh_get_type_name(*args):
    """
    Expr_Cosh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Cosh_get_type_name(*args)

def Expr_Cosh_get_type_descriptor(*args):
    """
    Expr_Cosh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Cosh_get_type_descriptor(*args)

class Expr_Cosine(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Cosine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Cosine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Cosine self, Handle_Expr_GeneralExpression Exp) -> Expr_Cosine

        Creates the cosine of Exp

        :type Exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Cosine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Cosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Cosine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Cosine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Cosine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Cosine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Cosine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Cosine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Cosine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Cosine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Cosine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Cosine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Cosine_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Cosine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Cosine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Cosine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Cosine
Expr_Cosine_swigregister = _Expr.Expr_Cosine_swigregister
Expr_Cosine_swigregister(Expr_Cosine)

def Expr_Cosine_get_type_name(*args):
    """
    Expr_Cosine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Cosine_get_type_name(*args)

def Expr_Cosine_get_type_descriptor(*args):
    """
    Expr_Cosine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Cosine_get_type_descriptor(*args)

class Expr_LessThanOrEqual(Expr_SingleRelation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_LessThanOrEqual
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_LessThanOrEqual(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_LessThanOrEqual self, Handle_Expr_GeneralExpression exp1, Handle_Expr_GeneralExpression exp2) -> Expr_LessThanOrEqual

        Creates the relation <exp1> <= <exp2>.

        :type exp1: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :type exp2: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_LessThanOrEqual(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsSatisfied(self, *args):
        """
        IsSatisfied(Expr_LessThanOrEqual self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_LessThanOrEqual_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Expr_LessThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_LessThanOrEqual_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Expr_LessThanOrEqual self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Expr_LessThanOrEqual_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_LessThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Expr_LessThanOrEqual_Copy(self, *args)


    def String(self, *args):
        """
        String(Expr_LessThanOrEqual self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_LessThanOrEqual_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_LessThanOrEqual_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_LessThanOrEqual_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_LessThanOrEqual_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_LessThanOrEqual
Expr_LessThanOrEqual_swigregister = _Expr.Expr_LessThanOrEqual_swigregister
Expr_LessThanOrEqual_swigregister(Expr_LessThanOrEqual)

def Expr_LessThanOrEqual_get_type_name(*args):
    """
    Expr_LessThanOrEqual_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_LessThanOrEqual_get_type_name(*args)

def Expr_LessThanOrEqual_get_type_descriptor(*args):
    """
    Expr_LessThanOrEqual_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_LessThanOrEqual_get_type_descriptor(*args)

class Expr_RelationIterator(object):
    """
    Iterates on every basic relation contained in
    a GeneralRelation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Expr_RelationIterator self, Handle_Expr_GeneralRelation rel) -> Expr_RelationIterator

        :type rel: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        this = _Expr.new_Expr_RelationIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(Expr_RelationIterator self) -> Standard_Boolean

        Returns False if no other relation remains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_RelationIterator_More(self, *args)


    def Next(self, *args):
        """Next(Expr_RelationIterator self)"""
        return _Expr.Expr_RelationIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Expr_RelationIterator self) -> Handle_Expr_SingleRelation

        Returns current basic relation.
        Exception is raised if no more relation remains.

        :rtype: OCC.wrapper.Expr.Handle_Expr_SingleRelation

        """
        return _Expr.Expr_RelationIterator_Value(self, *args)

    __swig_destroy__ = _Expr.delete_Expr_RelationIterator
Expr_RelationIterator_swigregister = _Expr.Expr_RelationIterator_swigregister
Expr_RelationIterator_swigregister(Expr_RelationIterator)

class Handle_Expr_Cosine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Cosine self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Cosine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Cosine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Cosine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Cosine self, Expr_Cosine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Cosine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Cosine self, Handle_Expr_Cosine theHandle) -> Handle_Expr_Cosine
        assign(Handle_Expr_Cosine self, Expr_Cosine thePtr) -> Handle_Expr_Cosine
        assign(Handle_Expr_Cosine self, Handle_Expr_Cosine theHandle) -> Handle_Expr_Cosine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Cosine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Cosine self) -> Expr_Cosine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Cosine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Cosine self) -> Expr_Cosine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Cosine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Cosine self) -> Expr_Cosine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Cosine___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Cosine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Cosine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Cosine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Cosine_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Cosine

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Cosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Cosine self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Cosine self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Cosine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Cosine self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Cosine self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Cosine_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Cosine self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Cosine_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Cosine self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Cosine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Cosine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Cosine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Cosine_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Cosine self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Cosine self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosine_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Cosine_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Cosine self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Cosine self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Cosine self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Cosine self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Cosine self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Cosine self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosine_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Cosine self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Cosine_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Cosine self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Cosine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Cosine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Cosine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Cosine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Cosine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Cosine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Cosine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Cosine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Cosine self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Cosine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Cosine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosine_DecrementRefCounter(self, *args)

Handle_Expr_Cosine_swigregister = _Expr.Handle_Expr_Cosine_swigregister
Handle_Expr_Cosine_swigregister(Handle_Expr_Cosine)

def Handle_Expr_Cosine_DownCast(thing):
    return _Expr.Handle_Expr_Cosine_DownCast(thing)
Handle_Expr_Cosine_DownCast = _Expr.Handle_Expr_Cosine_DownCast

class Expr_(object):
    """
    This package describes  the data structure  of any
    expression, relation or function used in mathematics.
    It also describes the assignment of variables. Standard
    mathematical functions are implemented such as
    trigonometrics, hyperbolics, and log functions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CopyShare(*args):
        """
        CopyShare(Handle_Expr_GeneralExpression exp) -> Handle_Expr_GeneralExpression

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr__CopyShare(*args)

    CopyShare = staticmethod(CopyShare)

    def NbOfFreeVariables(*args):
        """
        NbOfFreeVariables(Handle_Expr_GeneralExpression exp) -> Standard_Integer
        NbOfFreeVariables(Handle_Expr_GeneralRelation exp) -> Standard_Integer

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralRelation
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Expr__NbOfFreeVariables(*args)

    NbOfFreeVariables = staticmethod(NbOfFreeVariables)

    def Sign(*args):
        """
        Sign(Standard_Real const val) -> Standard_Real

        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr__Sign(*args)

    Sign = staticmethod(Sign)

    def __init__(self):
        """
        This package describes  the data structure  of any
        expression, relation or function used in mathematics.
        It also describes the assignment of variables. Standard
        mathematical functions are implemented such as
        trigonometrics, hyperbolics, and log functions.
        """
        this = _Expr.new_Expr_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_Expr_
Expr__swigregister = _Expr.Expr__swigregister
Expr__swigregister(Expr_)

def Expr__CopyShare(*args):
    """
    Expr__CopyShare(Handle_Expr_GeneralExpression exp) -> Handle_Expr_GeneralExpression

    :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
    :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

    """
    return _Expr.Expr__CopyShare(*args)

def Expr__NbOfFreeVariables(*args):
    """
    NbOfFreeVariables(Handle_Expr_GeneralExpression exp) -> Standard_Integer
    Expr__NbOfFreeVariables(Handle_Expr_GeneralRelation exp) -> Standard_Integer

    :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralRelation
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Expr.Expr__NbOfFreeVariables(*args)

def Expr__Sign(*args):
    """
    Expr__Sign(Standard_Real const val) -> Standard_Real

    :type val: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Expr.Expr__Sign(*args)

class Handle_Expr_UnaryMinus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_UnaryMinus self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_UnaryMinus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_UnaryMinus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_UnaryMinus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_UnaryMinus self, Expr_UnaryMinus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_UnaryMinus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_UnaryMinus self, Handle_Expr_UnaryMinus theHandle) -> Handle_Expr_UnaryMinus
        assign(Handle_Expr_UnaryMinus self, Expr_UnaryMinus thePtr) -> Handle_Expr_UnaryMinus
        assign(Handle_Expr_UnaryMinus self, Handle_Expr_UnaryMinus theHandle) -> Handle_Expr_UnaryMinus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_UnaryMinus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_UnaryMinus self) -> Expr_UnaryMinus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryMinus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_UnaryMinus self) -> Expr_UnaryMinus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryMinus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_UnaryMinus self) -> Expr_UnaryMinus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_UnaryMinus___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_UnaryMinus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_UnaryMinus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_UnaryMinus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_UnaryMinus_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_UnaryMinus

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_UnaryMinus self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_UnaryMinus self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_UnaryMinus self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_UnaryMinus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_UnaryMinus self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_UnaryMinus self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_NDerivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_UnaryMinus self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryMinus_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_UnaryMinus self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_UnaryMinus_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_UnaryMinus self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_UnaryMinus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryMinus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryMinus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryMinus_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_UnaryMinus self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_UnaryMinus self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryMinus_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryMinus_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_UnaryMinus self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_UnaryMinus self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_UnaryMinus self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_UnaryMinus self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryMinus_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_UnaryMinus self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_IsShareable(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_UnaryMinus self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryMinus_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_UnaryMinus self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_UnaryMinus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_UnaryMinus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_UnaryMinus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_UnaryMinus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_UnaryMinus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryMinus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_UnaryMinus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_UnaryMinus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_UnaryMinus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryMinus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_UnaryMinus self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_UnaryMinus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_UnaryMinus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryMinus_DecrementRefCounter(self, *args)

Handle_Expr_UnaryMinus_swigregister = _Expr.Handle_Expr_UnaryMinus_swigregister
Handle_Expr_UnaryMinus_swigregister(Handle_Expr_UnaryMinus)

def Handle_Expr_UnaryMinus_DownCast(thing):
    return _Expr.Handle_Expr_UnaryMinus_DownCast(thing)
Handle_Expr_UnaryMinus_DownCast = _Expr.Handle_Expr_UnaryMinus_DownCast

class Handle_Expr_NumericValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NumericValue self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NumericValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NumericValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NumericValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NumericValue self, Expr_NumericValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NumericValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NumericValue self, Handle_Expr_NumericValue theHandle) -> Handle_Expr_NumericValue
        assign(Handle_Expr_NumericValue self, Expr_NumericValue thePtr) -> Handle_Expr_NumericValue
        assign(Handle_Expr_NumericValue self, Handle_Expr_NumericValue theHandle) -> Handle_Expr_NumericValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NumericValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NumericValue self) -> Expr_NumericValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NumericValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NumericValue self) -> Expr_NumericValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NumericValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NumericValue self) -> Expr_NumericValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NumericValue___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NumericValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NumericValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NumericValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NumericValue_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NumericValue

    def GetValue(self, *args):
        """
        GetValue(Handle_Expr_NumericValue self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NumericValue_GetValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_Expr_NumericValue self, Standard_Real const val)

        :type val: float

        """
        return _Expr.Handle_Expr_NumericValue_SetValue(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_NumericValue self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NumericValue_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_NumericValue_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_NumericValue self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_NumericValue self) -> Standard_Boolean

        Tests if <me> contains NamedUnknown.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_NumericValue self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_Contains(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_NumericValue self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_NumericValue self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_NumericValue self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_NumericValue self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raises OutOfRange if <N> <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_NumericValue self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NumericValue_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_NumericValue self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NumericValue_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_NumericValue self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NumericValue_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NumericValue self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NumericValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NumericValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NumericValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_NumericValue self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_IsShareable(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_NumericValue self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NumericValue_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NumericValue self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NumericValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NumericValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NumericValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NumericValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NumericValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NumericValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NumericValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NumericValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NumericValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NumericValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NumericValue self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NumericValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NumericValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NumericValue_DecrementRefCounter(self, *args)

Handle_Expr_NumericValue_swigregister = _Expr.Handle_Expr_NumericValue_swigregister
Handle_Expr_NumericValue_swigregister(Handle_Expr_NumericValue)

def Handle_Expr_NumericValue_DownCast(thing):
    return _Expr.Handle_Expr_NumericValue_DownCast(thing)
Handle_Expr_NumericValue_DownCast = _Expr.Handle_Expr_NumericValue_DownCast

class Handle_Expr_Cosh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Cosh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Cosh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Cosh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Cosh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Cosh self, Expr_Cosh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Cosh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Cosh self, Handle_Expr_Cosh theHandle) -> Handle_Expr_Cosh
        assign(Handle_Expr_Cosh self, Expr_Cosh thePtr) -> Handle_Expr_Cosh
        assign(Handle_Expr_Cosh self, Handle_Expr_Cosh theHandle) -> Handle_Expr_Cosh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Cosh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Cosh self) -> Expr_Cosh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Cosh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Cosh self) -> Expr_Cosh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Cosh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Cosh self) -> Expr_Cosh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Cosh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Cosh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Cosh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Cosh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Cosh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Cosh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Cosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Cosh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Cosh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Cosh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Cosh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Cosh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Cosh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Cosh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Cosh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Cosh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Cosh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Cosh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Cosh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Cosh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Cosh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Cosh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Cosh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Cosh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Cosh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Cosh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Cosh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Cosh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Cosh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Cosh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Cosh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Cosh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Cosh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Cosh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Cosh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Cosh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Cosh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Cosh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Cosh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Cosh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Cosh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Cosh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Cosh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Cosh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Cosh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Cosh_DecrementRefCounter(self, *args)

Handle_Expr_Cosh_swigregister = _Expr.Handle_Expr_Cosh_swigregister
Handle_Expr_Cosh_swigregister(Handle_Expr_Cosh)

def Handle_Expr_Cosh_DownCast(thing):
    return _Expr.Handle_Expr_Cosh_DownCast(thing)
Handle_Expr_Cosh_DownCast = _Expr.Handle_Expr_Cosh_DownCast

class NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< Expr_NamedUnknown >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< Expr_NamedUnknown >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Expr.new_NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Handle_Expr_NamedUnknown theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Handle_Expr_NamedUnknown theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_Expr_NamedUnknown theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Handle_Expr_NamedUnknown theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Handle_Expr_NamedUnknown theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _Expr.delete_NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher
NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_swigregister = _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_swigregister
NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_swigregister(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher)

class NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Expr.new_NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper_swigregister = _Expr.NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher_IteratorHelper)


try:
	Expr_MapOfNamedUnknown = NCollection_IndexedMap_Handle_Expr_NamedUnknown_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_Expr_GeneralRelation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Expr.new_NCollection_Sequence_Handle_Expr_GeneralRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Expr_GeneralRelation self)

        Reverse sequence


        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Expr_GeneralRelation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence_Handle_Expr_GeneralRelation theOther) -> NCollection_Sequence_Handle_Expr_GeneralRelation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence_Handle_Expr_GeneralRelation theOther) -> NCollection_Sequence_Handle_Expr_GeneralRelation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem)
        Append(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence_Handle_Expr_GeneralRelation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem)
        Prepend(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence_Handle_Expr_GeneralRelation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, Handle_Expr_GeneralRelation theItem)
        InsertBefore(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralRelation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralRelation self, NCollection_Sequence< opencascade::handle< Expr_GeneralRelation > >::Iterator & thePosition, Handle_Expr_GeneralRelation theItem)
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralRelation theSeq)
        InsertAfter(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, Handle_Expr_GeneralRelation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_GeneralRelation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        First item access

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        Last item access

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex) -> Handle_Expr_GeneralRelation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Expr_GeneralRelation self, Standard_Integer const theIndex, Handle_Expr_GeneralRelation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_SetValue(self, *args)


    def __iter__(self):
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation___iter__(self)
    __swig_destroy__ = _Expr.delete_NCollection_Sequence_Handle_Expr_GeneralRelation
NCollection_Sequence_Handle_Expr_GeneralRelation_swigregister = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_swigregister
NCollection_Sequence_Handle_Expr_GeneralRelation_swigregister(NCollection_Sequence_Handle_Expr_GeneralRelation)

def NCollection_Sequence_Handle_Expr_GeneralRelation_delNode(*args):
    """
    NCollection_Sequence_Handle_Expr_GeneralRelation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_delNode(*args)

class NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Expr.new_NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Expr.delete_NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper

    def __next__(self):
        return _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper_swigregister = _Expr.NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper_swigregister
NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper_swigregister(NCollection_Sequence_Handle_Expr_GeneralRelation_IteratorHelper)


try:
	Expr_SequenceOfGeneralRelation = NCollection_Sequence_Handle_Expr_GeneralRelation
except NameError:
	pass # does not exist, probably ignored

class Handle_Expr_GeneralRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_GeneralRelation self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_GeneralRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_GeneralRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_GeneralRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_GeneralRelation self, Expr_GeneralRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_GeneralRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theHandle) -> Handle_Expr_GeneralRelation
        assign(Handle_Expr_GeneralRelation self, Expr_GeneralRelation thePtr) -> Handle_Expr_GeneralRelation
        assign(Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theHandle) -> Handle_Expr_GeneralRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_GeneralRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_GeneralRelation self) -> Expr_GeneralRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_GeneralRelation self) -> Expr_GeneralRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_GeneralRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_GeneralRelation self) -> Expr_GeneralRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_GeneralRelation___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_GeneralRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_GeneralRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_GeneralRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_GeneralRelation_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_GeneralRelation

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_GeneralRelation self) -> Standard_Boolean

        Returns the current status of the relation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralRelation_IsSatisfied(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_GeneralRelation self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralRelation_IsLinear(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GeneralRelation_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_GeneralRelation self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_GeneralRelation_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_GeneralRelation self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GeneralRelation_Copy(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_GeneralRelation self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralRelation_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_GeneralRelation self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralRelation_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_GeneralRelation self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if <index> is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_GeneralRelation_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_GeneralRelation self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> contains <var>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralRelation_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_GeneralRelation self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_GeneralRelation_Replace(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_GeneralRelation self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_GeneralRelation_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_GeneralRelation self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_GeneralRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_GeneralRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Expr_GeneralRelation self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_GeneralRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_GeneralRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_GeneralRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_GeneralRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_GeneralRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_GeneralRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_GeneralRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_GeneralRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_GeneralRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_GeneralRelation self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_GeneralRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_GeneralRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_GeneralRelation_DecrementRefCounter(self, *args)

Handle_Expr_GeneralRelation_swigregister = _Expr.Handle_Expr_GeneralRelation_swigregister
Handle_Expr_GeneralRelation_swigregister(Handle_Expr_GeneralRelation)

def Handle_Expr_GeneralRelation_DownCast(thing):
    return _Expr.Handle_Expr_GeneralRelation_DownCast(thing)
Handle_Expr_GeneralRelation_DownCast = _Expr.Handle_Expr_GeneralRelation_DownCast

class Handle_Expr_LogOfe(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_LogOfe self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_LogOfe_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_LogOfe self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_LogOfe_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_LogOfe self, Expr_LogOfe thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_LogOfe_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_LogOfe self, Handle_Expr_LogOfe theHandle) -> Handle_Expr_LogOfe
        assign(Handle_Expr_LogOfe self, Expr_LogOfe thePtr) -> Handle_Expr_LogOfe
        assign(Handle_Expr_LogOfe self, Handle_Expr_LogOfe theHandle) -> Handle_Expr_LogOfe

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_LogOfe_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_LogOfe self) -> Expr_LogOfe

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_LogOfe_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_LogOfe self) -> Expr_LogOfe

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_LogOfe___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_LogOfe self) -> Expr_LogOfe

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_LogOfe___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_LogOfe___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_LogOfe___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_LogOfe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_LogOfe_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_LogOfe

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_LogOfe self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_LogOfe self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_LogOfe self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_LogOfe self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_LogOfe self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_LogOfe self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_LogOfe_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_LogOfe self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_LogOfe_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_LogOfe self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_LogOfe_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LogOfe_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LogOfe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_LogOfe_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_LogOfe self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_LogOfe self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOfe_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_LogOfe_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_LogOfe self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_LogOfe self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_LogOfe self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_LogOfe self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_LogOfe self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_LogOfe self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LogOfe_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_LogOfe self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_LogOfe_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_LogOfe self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_LogOfe_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_LogOfe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_LogOfe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_LogOfe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_LogOfe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LogOfe_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_LogOfe self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_LogOfe_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_LogOfe self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOfe_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_LogOfe self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_LogOfe_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_LogOfe self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LogOfe_DecrementRefCounter(self, *args)

Handle_Expr_LogOfe_swigregister = _Expr.Handle_Expr_LogOfe_swigregister
Handle_Expr_LogOfe_swigregister(Handle_Expr_LogOfe)

def Handle_Expr_LogOfe_DownCast(thing):
    return _Expr.Handle_Expr_LogOfe_DownCast(thing)
Handle_Expr_LogOfe_DownCast = _Expr.Handle_Expr_LogOfe_DownCast

class Handle_Expr_LessThanOrEqual(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_LessThanOrEqual self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_LessThanOrEqual_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_LessThanOrEqual self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_LessThanOrEqual_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_LessThanOrEqual self, Expr_LessThanOrEqual thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_LessThanOrEqual_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_LessThanOrEqual self, Handle_Expr_LessThanOrEqual theHandle) -> Handle_Expr_LessThanOrEqual
        assign(Handle_Expr_LessThanOrEqual self, Expr_LessThanOrEqual thePtr) -> Handle_Expr_LessThanOrEqual
        assign(Handle_Expr_LessThanOrEqual self, Handle_Expr_LessThanOrEqual theHandle) -> Handle_Expr_LessThanOrEqual

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_LessThanOrEqual_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_LessThanOrEqual self) -> Expr_LessThanOrEqual

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_LessThanOrEqual_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_LessThanOrEqual self) -> Expr_LessThanOrEqual

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_LessThanOrEqual___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_LessThanOrEqual self) -> Expr_LessThanOrEqual

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_LessThanOrEqual___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_LessThanOrEqual___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_LessThanOrEqual___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_LessThanOrEqual(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_LessThanOrEqual_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_LessThanOrEqual

    def IsSatisfied(self, *args):
        """
        IsSatisfied(Handle_Expr_LessThanOrEqual self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThanOrEqual_IsSatisfied(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_LessThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a GeneralRelation after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThanOrEqual_Simplified(self, *args)


    def Simplify(self, *args):
        """
        Simplify(Handle_Expr_LessThanOrEqual self)

        Replaces NamedUnknowns by associated expressions,
        and computes values in <me>.


        """
        return _Expr.Handle_Expr_LessThanOrEqual_Simplify(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_LessThanOrEqual self) -> Handle_Expr_GeneralRelation

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThanOrEqual_Copy(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_LessThanOrEqual self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_LessThanOrEqual_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_LessThanOrEqual self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_LessThanOrEqual_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LessThanOrEqual_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_LessThanOrEqual_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstMember(self, *args):
        """
        SetFirstMember(Handle_Expr_LessThanOrEqual self, Handle_Expr_GeneralExpression exp)

        Defines the first member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThanOrEqual_SetFirstMember(self, *args)


    def SetSecondMember(self, *args):
        """
        SetSecondMember(Handle_Expr_LessThanOrEqual self, Handle_Expr_GeneralExpression exp)

        Defines the second member of the relation

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThanOrEqual_SetSecondMember(self, *args)


    def FirstMember(self, *args):
        """
        FirstMember(Handle_Expr_LessThanOrEqual self) -> Handle_Expr_GeneralExpression

        Returns the first member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThanOrEqual_FirstMember(self, *args)


    def SecondMember(self, *args):
        """
        SecondMember(Handle_Expr_LessThanOrEqual self) -> Handle_Expr_GeneralExpression

        Returns the second member of the relation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThanOrEqual_SecondMember(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_LessThanOrEqual self) -> Standard_Boolean

        Tests if <me> is linear between its NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThanOrEqual_IsLinear(self, *args)


    def NbOfSubRelations(self, *args):
        """
        NbOfSubRelations(Handle_Expr_LessThanOrEqual self) -> Standard_Integer

        Returns the number of relations contained in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThanOrEqual_NbOfSubRelations(self, *args)


    def NbOfSingleRelations(self, *args):
        """
        NbOfSingleRelations(Handle_Expr_LessThanOrEqual self) -> Standard_Integer

        Returns the number of SingleRelations contained in
        <me> (Always 1).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThanOrEqual_NbOfSingleRelations(self, *args)


    def SubRelation(self, *args):
        """
        SubRelation(Handle_Expr_LessThanOrEqual self, Standard_Integer const index) -> Handle_Expr_GeneralRelation

        Returns the relation denoted by <index> in <me>.
        An exception is raised if index is out of range.

        :type index: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _Expr.Handle_Expr_LessThanOrEqual_SubRelation(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_LessThanOrEqual self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <me> contains <exp>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThanOrEqual_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_LessThanOrEqual self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_LessThanOrEqual_Replace(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_LessThanOrEqual self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_LessThanOrEqual_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_LessThanOrEqual self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_LessThanOrEqual self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThanOrEqual_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_LessThanOrEqual self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_LessThanOrEqual self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_LessThanOrEqual_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_LessThanOrEqual self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_LessThanOrEqual_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_LessThanOrEqual self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThanOrEqual_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_LessThanOrEqual self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_LessThanOrEqual_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_LessThanOrEqual self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_LessThanOrEqual_DecrementRefCounter(self, *args)

Handle_Expr_LessThanOrEqual_swigregister = _Expr.Handle_Expr_LessThanOrEqual_swigregister
Handle_Expr_LessThanOrEqual_swigregister(Handle_Expr_LessThanOrEqual)

def Handle_Expr_LessThanOrEqual_DownCast(thing):
    return _Expr.Handle_Expr_LessThanOrEqual_DownCast(thing)
Handle_Expr_LessThanOrEqual_DownCast = _Expr.Handle_Expr_LessThanOrEqual_DownCast

class NCollection_Array1_Handle_Expr_NamedUnknown(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Expr_NamedUnknown self) -> NCollection_Array1< opencascade::handle< Expr_NamedUnknown > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Expr_NamedUnknown self) -> NCollection_Array1< opencascade::handle< Expr_NamedUnknown > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Expr_NamedUnknown self) -> NCollection_Array1< opencascade::handle< Expr_NamedUnknown > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Expr_NamedUnknown self) -> NCollection_Array1< opencascade::handle< Expr_NamedUnknown > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Expr.new_NCollection_Array1_Handle_Expr_NamedUnknown(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Expr_NamedUnknown self, Handle_Expr_NamedUnknown theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown theOther) -> NCollection_Array1_Handle_Expr_NamedUnknown

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown theOther) -> NCollection_Array1_Handle_Expr_NamedUnknown

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown theOther) -> NCollection_Array1_Handle_Expr_NamedUnknown
        assign(NCollection_Array1_Handle_Expr_NamedUnknown self, NCollection_Array1_Handle_Expr_NamedUnknown theOther) -> NCollection_Array1_Handle_Expr_NamedUnknown

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Handle_Expr_NamedUnknown

        @return first element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Expr_NamedUnknown self) -> Handle_Expr_NamedUnknown

        @return last element

        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Expr_NamedUnknown self, Standard_Integer const theIndex) -> Handle_Expr_NamedUnknown

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Expr_NamedUnknown self, Standard_Integer const theIndex, Handle_Expr_NamedUnknown theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Expr_NamedUnknown self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_Resize(self, *args)

    __swig_destroy__ = _Expr.delete_NCollection_Array1_Handle_Expr_NamedUnknown
NCollection_Array1_Handle_Expr_NamedUnknown_swigregister = _Expr.NCollection_Array1_Handle_Expr_NamedUnknown_swigregister
NCollection_Array1_Handle_Expr_NamedUnknown_swigregister(NCollection_Array1_Handle_Expr_NamedUnknown)


try:
	Expr_Array1OfNamedUnknown = NCollection_Array1_Handle_Expr_NamedUnknown
except NameError:
	pass # does not exist, probably ignored

class Handle_Expr_ExprFailure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ExprFailure self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ExprFailure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ExprFailure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ExprFailure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ExprFailure self, Expr_ExprFailure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ExprFailure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ExprFailure self, Handle_Expr_ExprFailure theHandle) -> Handle_Expr_ExprFailure
        assign(Handle_Expr_ExprFailure self, Expr_ExprFailure thePtr) -> Handle_Expr_ExprFailure
        assign(Handle_Expr_ExprFailure self, Handle_Expr_ExprFailure theHandle) -> Handle_Expr_ExprFailure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ExprFailure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ExprFailure self) -> Expr_ExprFailure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ExprFailure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ExprFailure self) -> Expr_ExprFailure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ExprFailure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ExprFailure self) -> Expr_ExprFailure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ExprFailure___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ExprFailure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ExprFailure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ExprFailure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ExprFailure_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ExprFailure

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Expr_ExprFailure self, Standard_CString const theMessage) -> Handle_Expr_ExprFailure

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Expr.Handle_Expr_ExprFailure

        """
        return _Expr.Handle_Expr_ExprFailure_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ExprFailure self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ExprFailure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ExprFailure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ExprFailure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Expr_ExprFailure self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Expr.Handle_Expr_ExprFailure_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Expr_ExprFailure self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_ExprFailure_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Expr_ExprFailure self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Expr.Handle_Expr_ExprFailure_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Expr_ExprFailure self)
        Reraise(Handle_Expr_ExprFailure self, Standard_CString const aMessage)
        Reraise(Handle_Expr_ExprFailure self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Expr.Handle_Expr_ExprFailure_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Expr_ExprFailure self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Expr.Handle_Expr_ExprFailure_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Expr_ExprFailure self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Expr.Handle_Expr_ExprFailure_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ExprFailure self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ExprFailure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ExprFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ExprFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ExprFailure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ExprFailure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ExprFailure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ExprFailure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ExprFailure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ExprFailure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ExprFailure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ExprFailure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ExprFailure self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ExprFailure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ExprFailure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ExprFailure_DecrementRefCounter(self, *args)

Handle_Expr_ExprFailure_swigregister = _Expr.Handle_Expr_ExprFailure_swigregister
Handle_Expr_ExprFailure_swigregister(Handle_Expr_ExprFailure)

def Handle_Expr_ExprFailure_DownCast(thing):
    return _Expr.Handle_Expr_ExprFailure_DownCast(thing)
Handle_Expr_ExprFailure_DownCast = _Expr.Handle_Expr_ExprFailure_DownCast

class Handle_Expr_NamedExpression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_NamedExpression self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_NamedExpression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_NamedExpression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_NamedExpression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_NamedExpression self, Expr_NamedExpression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_NamedExpression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_NamedExpression self, Handle_Expr_NamedExpression theHandle) -> Handle_Expr_NamedExpression
        assign(Handle_Expr_NamedExpression self, Expr_NamedExpression thePtr) -> Handle_Expr_NamedExpression
        assign(Handle_Expr_NamedExpression self, Handle_Expr_NamedExpression theHandle) -> Handle_Expr_NamedExpression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_NamedExpression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_NamedExpression self) -> Expr_NamedExpression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedExpression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_NamedExpression self) -> Expr_NamedExpression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_NamedExpression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_NamedExpression self) -> Expr_NamedExpression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_NamedExpression___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_NamedExpression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_NamedExpression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_NamedExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_NamedExpression_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_NamedExpression

    def GetName(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _Expr.Handle_Expr_NamedExpression_GetName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_Expr_NamedExpression self, TCollection_AsciiString name)

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedExpression_SetName(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_NamedExpression self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method redefines to a True
        value the GeneralExpression method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_IsShareable(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_NamedExpression self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_IsIdentical(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_NamedExpression self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_NamedExpression_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_NamedExpression self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_NamedExpression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedExpression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_NamedExpression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_NamedExpression self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedExpression_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>
        raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_NamedExpression_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_NamedExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_Simplified(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_NamedExpression self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_NamedExpression self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and
        functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_Copy(self, *args)


    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_NamedExpression self) -> Standard_Boolean

        Tests if <me> contains NamedUnknowns.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_NamedExpression self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_Contains(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_NamedExpression self) -> Standard_Boolean

        Tests if <me> is linear on every NamedUnknown it
        contains.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_NamedExpression self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_Derivative(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_NamedExpression self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_NDerivative(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_NamedExpression self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with copies of <with>
        in <me>. Copies of <with> are made with the Copy() method.
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_NamedExpression_Replace(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_NamedExpression self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedExpression_Evaluate(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_NamedExpression self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_NamedExpression_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_NamedExpression self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_NamedExpression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_NamedExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_NamedExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_NamedExpression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_NamedExpression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_NamedExpression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_NamedExpression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_NamedExpression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_NamedExpression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedExpression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_NamedExpression self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_NamedExpression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_NamedExpression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_NamedExpression_DecrementRefCounter(self, *args)

Handle_Expr_NamedExpression_swigregister = _Expr.Handle_Expr_NamedExpression_swigregister
Handle_Expr_NamedExpression_swigregister(Handle_Expr_NamedExpression)

def Handle_Expr_NamedExpression_DownCast(thing):
    return _Expr.Handle_Expr_NamedExpression_DownCast(thing)
Handle_Expr_NamedExpression_DownCast = _Expr.Handle_Expr_NamedExpression_DownCast

class Expr_Absolute(Expr_UnaryExpression):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Expr_Absolute
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Expr_Absolute(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Expr_Absolute self, Handle_Expr_GeneralExpression exp) -> Expr_Absolute

        Creates the Abs of <exp>

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        this = _Expr.new_Expr_Absolute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Expr_Absolute self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Absolute_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Expr_Absolute self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Absolute_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Expr_Absolute self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Absolute_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Expr_Absolute self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Expr_Absolute_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Expr_Absolute self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Expr_Absolute_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Expr_Absolute self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Expr_Absolute_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Expr_Absolute self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Expr_Absolute_String(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Expr.Expr_Absolute_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Expr.Expr_Absolute_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Expr_Absolute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Expr.delete_Expr_Absolute
Expr_Absolute_swigregister = _Expr.Expr_Absolute_swigregister
Expr_Absolute_swigregister(Expr_Absolute)

def Expr_Absolute_get_type_name(*args):
    """
    Expr_Absolute_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Expr.Expr_Absolute_get_type_name(*args)

def Expr_Absolute_get_type_descriptor(*args):
    """
    Expr_Absolute_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Expr.Expr_Absolute_get_type_descriptor(*args)

class Handle_Expr_Square(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Square self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Square_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Square self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Square_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Square self, Expr_Square thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Square_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Square self, Handle_Expr_Square theHandle) -> Handle_Expr_Square
        assign(Handle_Expr_Square self, Expr_Square thePtr) -> Handle_Expr_Square
        assign(Handle_Expr_Square self, Handle_Expr_Square theHandle) -> Handle_Expr_Square

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Square_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Square self) -> Expr_Square

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Square_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Square self) -> Expr_Square

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Square___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Square self) -> Expr_Square

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Square___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Square___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Square___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Square(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Square_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Square

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Square self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Square self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Square self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Square self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Square self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Square self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Square_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Square self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Square_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Square self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Square_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Square_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Square_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Square_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Square self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Square self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Square_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Square_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Square self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Square self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Square self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Square self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Square self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Square self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Square_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Square self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Square_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Square self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Square_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Square self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Square self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Square self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Square self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Square_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Square self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Square_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Square self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Square_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Square self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Square_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Square self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Square_DecrementRefCounter(self, *args)

Handle_Expr_Square_swigregister = _Expr.Handle_Expr_Square_swigregister
Handle_Expr_Square_swigregister(Handle_Expr_Square)

def Handle_Expr_Square_DownCast(thing):
    return _Expr.Handle_Expr_Square_DownCast(thing)
Handle_Expr_Square_DownCast = _Expr.Handle_Expr_Square_DownCast

class Handle_Expr_Tanh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Tanh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Tanh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Tanh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Tanh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Tanh self, Expr_Tanh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Tanh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Tanh self, Handle_Expr_Tanh theHandle) -> Handle_Expr_Tanh
        assign(Handle_Expr_Tanh self, Expr_Tanh thePtr) -> Handle_Expr_Tanh
        assign(Handle_Expr_Tanh self, Handle_Expr_Tanh theHandle) -> Handle_Expr_Tanh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Tanh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Tanh self) -> Expr_Tanh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Tanh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Tanh self) -> Expr_Tanh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Tanh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Tanh self) -> Expr_Tanh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Tanh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Tanh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Tanh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Tanh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Tanh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Tanh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Tanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Tanh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Tanh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Tanh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Tanh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Tanh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Tanh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Tanh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Tanh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Tanh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Tanh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Tanh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Tanh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Tanh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Tanh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Tanh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tanh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Tanh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Tanh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Tanh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Tanh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Tanh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Tanh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Tanh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Tanh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Tanh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Tanh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Tanh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Tanh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Tanh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Tanh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Tanh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Tanh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Tanh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Tanh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Tanh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Tanh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tanh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Tanh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Tanh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Tanh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Tanh_DecrementRefCounter(self, *args)

Handle_Expr_Tanh_swigregister = _Expr.Handle_Expr_Tanh_swigregister
Handle_Expr_Tanh_swigregister(Handle_Expr_Tanh)

def Handle_Expr_Tanh_DownCast(thing):
    return _Expr.Handle_Expr_Tanh_DownCast(thing)
Handle_Expr_Tanh_DownCast = _Expr.Handle_Expr_Tanh_DownCast

class Handle_Expr_Absolute(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_Absolute self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_Absolute_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_Absolute self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_Absolute_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_Absolute self, Expr_Absolute thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_Absolute_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_Absolute self, Handle_Expr_Absolute theHandle) -> Handle_Expr_Absolute
        assign(Handle_Expr_Absolute self, Expr_Absolute thePtr) -> Handle_Expr_Absolute
        assign(Handle_Expr_Absolute self, Handle_Expr_Absolute theHandle) -> Handle_Expr_Absolute

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_Absolute_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_Absolute self) -> Expr_Absolute

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_Absolute_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_Absolute self) -> Expr_Absolute

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_Absolute___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_Absolute self) -> Expr_Absolute

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_Absolute___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_Absolute___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_Absolute___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_Absolute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_Absolute_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_Absolute

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_Absolute self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_Absolute self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_Absolute self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_Absolute self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_Absolute self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_Absolute self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Absolute_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_Absolute self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_Absolute_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_Absolute self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_Absolute_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Absolute_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_Absolute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Absolute_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_Absolute self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_Absolute self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Absolute_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_Absolute_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_Absolute self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_Absolute self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_Absolute self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_Absolute self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_Absolute self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_Absolute self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_Absolute_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_Absolute self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_Absolute_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_Absolute self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_Absolute_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_Absolute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_Absolute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_Absolute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_Absolute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_Absolute_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_Absolute self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_Absolute_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_Absolute self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Absolute_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_Absolute self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_Absolute_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_Absolute self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_Absolute_DecrementRefCounter(self, *args)

Handle_Expr_Absolute_swigregister = _Expr.Handle_Expr_Absolute_swigregister
Handle_Expr_Absolute_swigregister(Handle_Expr_Absolute)

def Handle_Expr_Absolute_DownCast(thing):
    return _Expr.Handle_Expr_Absolute_DownCast(thing)
Handle_Expr_Absolute_DownCast = _Expr.Handle_Expr_Absolute_DownCast

class Handle_Expr_SquareRoot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_SquareRoot self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_SquareRoot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_SquareRoot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_SquareRoot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_SquareRoot self, Expr_SquareRoot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_SquareRoot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_SquareRoot self, Handle_Expr_SquareRoot theHandle) -> Handle_Expr_SquareRoot
        assign(Handle_Expr_SquareRoot self, Expr_SquareRoot thePtr) -> Handle_Expr_SquareRoot
        assign(Handle_Expr_SquareRoot self, Handle_Expr_SquareRoot theHandle) -> Handle_Expr_SquareRoot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_SquareRoot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_SquareRoot self) -> Expr_SquareRoot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_SquareRoot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_SquareRoot self) -> Expr_SquareRoot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_SquareRoot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_SquareRoot self) -> Expr_SquareRoot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_SquareRoot___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_SquareRoot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_SquareRoot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_SquareRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_SquareRoot_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_SquareRoot

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_SquareRoot self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_SquareRoot self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_SquareRoot self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_SquareRoot self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_SquareRoot self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_SquareRoot self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_SquareRoot_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_SquareRoot self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_SquareRoot_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_SquareRoot self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_SquareRoot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SquareRoot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_SquareRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_SquareRoot_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_SquareRoot self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_SquareRoot self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SquareRoot_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_SquareRoot_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_SquareRoot self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_SquareRoot self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_SquareRoot self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_SquareRoot self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_SquareRoot self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_SquareRoot self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_SquareRoot_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_SquareRoot self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_SquareRoot_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_SquareRoot self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_SquareRoot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_SquareRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_SquareRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_SquareRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_SquareRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_SquareRoot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_SquareRoot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_SquareRoot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_SquareRoot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SquareRoot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_SquareRoot self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_SquareRoot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_SquareRoot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_SquareRoot_DecrementRefCounter(self, *args)

Handle_Expr_SquareRoot_swigregister = _Expr.Handle_Expr_SquareRoot_swigregister
Handle_Expr_SquareRoot_swigregister(Handle_Expr_SquareRoot)

def Handle_Expr_SquareRoot_DownCast(thing):
    return _Expr.Handle_Expr_SquareRoot_DownCast(thing)
Handle_Expr_SquareRoot_DownCast = _Expr.Handle_Expr_SquareRoot_DownCast

class Handle_Expr_UnaryFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_UnaryFunction self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_UnaryFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_UnaryFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_UnaryFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_UnaryFunction self, Expr_UnaryFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_UnaryFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_UnaryFunction self, Handle_Expr_UnaryFunction theHandle) -> Handle_Expr_UnaryFunction
        assign(Handle_Expr_UnaryFunction self, Expr_UnaryFunction thePtr) -> Handle_Expr_UnaryFunction
        assign(Handle_Expr_UnaryFunction self, Handle_Expr_UnaryFunction theHandle) -> Handle_Expr_UnaryFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_UnaryFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_UnaryFunction self) -> Expr_UnaryFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_UnaryFunction self) -> Expr_UnaryFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_UnaryFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_UnaryFunction self) -> Expr_UnaryFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_UnaryFunction___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_UnaryFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_UnaryFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_UnaryFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_UnaryFunction_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_UnaryFunction

    def Function(self, *args):
        """
        Function(Handle_Expr_UnaryFunction self) -> Handle_Expr_GeneralFunction

        Returns the function defining <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _Expr.Handle_Expr_UnaryFunction_Function(self, *args)


    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_UnaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_UnaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_UnaryFunction self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_UnaryFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_UnaryFunction self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_UnaryFunction self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryFunction_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_UnaryFunction self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_UnaryFunction_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_UnaryFunction self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_UnaryFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_UnaryFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryFunction_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_UnaryFunction self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_UnaryFunction self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryFunction_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_UnaryFunction_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_UnaryFunction self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_UnaryFunction self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_UnaryFunction self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_UnaryFunction self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_UnaryFunction self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_UnaryFunction self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_UnaryFunction_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_UnaryFunction self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_UnaryFunction_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_UnaryFunction self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_UnaryFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_UnaryFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_UnaryFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_UnaryFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_UnaryFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_UnaryFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_UnaryFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_UnaryFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_UnaryFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_UnaryFunction self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_UnaryFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_UnaryFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_UnaryFunction_DecrementRefCounter(self, *args)

Handle_Expr_UnaryFunction_swigregister = _Expr.Handle_Expr_UnaryFunction_swigregister
Handle_Expr_UnaryFunction_swigregister(Handle_Expr_UnaryFunction)

def Handle_Expr_UnaryFunction_DownCast(thing):
    return _Expr.Handle_Expr_UnaryFunction_DownCast(thing)
Handle_Expr_UnaryFunction_DownCast = _Expr.Handle_Expr_UnaryFunction_DownCast

class Handle_Expr_ArgSinh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Expr_ArgSinh self)

        Nullify the handle


        """
        return _Expr.Handle_Expr_ArgSinh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Expr_ArgSinh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Expr.Handle_Expr_ArgSinh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Expr_ArgSinh self, Expr_ArgSinh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Expr.Handle_Expr_ArgSinh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Expr_ArgSinh self, Handle_Expr_ArgSinh theHandle) -> Handle_Expr_ArgSinh
        assign(Handle_Expr_ArgSinh self, Expr_ArgSinh thePtr) -> Handle_Expr_ArgSinh
        assign(Handle_Expr_ArgSinh self, Handle_Expr_ArgSinh theHandle) -> Handle_Expr_ArgSinh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Expr.Handle_Expr_ArgSinh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Expr_ArgSinh self) -> Expr_ArgSinh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgSinh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Expr_ArgSinh self) -> Expr_ArgSinh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Expr.Handle_Expr_ArgSinh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Expr_ArgSinh self) -> Expr_ArgSinh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Expr.Handle_Expr_ArgSinh___ref__(self, *args)


    def __hash__(self):
        return _Expr.Handle_Expr_ArgSinh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Expr.Handle_Expr_ArgSinh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Expr.new_Handle_Expr_ArgSinh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Expr.Handle_Expr_ArgSinh_DownCast)
    __swig_destroy__ = _Expr.delete_Handle_Expr_ArgSinh

    def ShallowSimplified(self, *args):
        """
        ShallowSimplified(Handle_Expr_ArgSinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after a simplification
        of the arguments of <me>.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_ShallowSimplified(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Expr_ArgSinh self) -> Handle_Expr_GeneralExpression

        Returns a copy of <me> having the same unknowns and functions.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_Copy(self, *args)


    def IsIdentical(self, *args):
        """
        IsIdentical(Handle_Expr_ArgSinh self, Handle_Expr_GeneralExpression Other) -> Standard_Boolean

        Tests if <me> and <Other> define the same expression.
        This method does not include any simplification before
        testing.

        :type Other: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_IsIdentical(self, *args)


    def IsLinear(self, *args):
        """
        IsLinear(Handle_Expr_ArgSinh self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_IsLinear(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Handle_Expr_ArgSinh self, Handle_Expr_NamedUnknown X) -> Handle_Expr_GeneralExpression

        Returns the derivative on <X> unknown of <me>.

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_Derivative(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Handle_Expr_ArgSinh self, NCollection_Array1_Handle_Expr_NamedUnknown vars, NCollection_Array1_Standard_Real vals) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :type vars: OCC.wrapper.Expr.Expr_Array1OfNamedUnknown
        :type vals: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgSinh_Evaluate(self, *args)


    def String(self, *args):
        """
        String(Handle_Expr_ArgSinh self) -> TCollection_AsciiString

        returns a string representing <me> in a readable way.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Expr.Handle_Expr_ArgSinh_String(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Expr_ArgSinh self) -> char const *

        :rtype: const char *

        """
        return _Expr.Handle_Expr_ArgSinh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgSinh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Expr.Handle_Expr_ArgSinh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operand(self, *args):
        """
        Returns the operand used

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgSinh_Operand(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperand(self, *args):
        """
        SetOperand(Handle_Expr_ArgSinh self, Handle_Expr_GeneralExpression exp)

        Sets the operand used
        Raises InvalidOperand if <exp> contains <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_SetOperand(self, *args)


    def NbSubExpressions(self, *args):
        """
        NbSubExpressions(Handle_Expr_ArgSinh self) -> Standard_Integer

        Returns the number of sub-expressions contained
        in <me> ( >= 0)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgSinh_NbSubExpressions(self, *args)


    def SubExpression(self, *args):
        """
        Returns the <I>-th sub-expression of <me>.
        Raises OutOfRange if <I> > NbSubExpressions(me)

        :type I: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        res = _Expr.Handle_Expr_ArgSinh_SubExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContainsUnknowns(self, *args):
        """
        ContainsUnknowns(Handle_Expr_ArgSinh self) -> Standard_Boolean

        Does <me> contains NamedUnknown ?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_ContainsUnknowns(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_Expr_ArgSinh self, Handle_Expr_GeneralExpression exp) -> Standard_Boolean

        Tests if <exp> is contained in <me>.

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_Contains(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_Expr_ArgSinh self, Handle_Expr_NamedUnknown var, Handle_Expr_GeneralExpression arg3)

        Replaces all occurences of <var> with <with> in <me>
        Raises InvalidOperand if <with> contains <me>.

        :type var: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type with: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_Replace(self, *args)


    def Simplified(self, *args):
        """
        Simplified(Handle_Expr_ArgSinh self) -> Handle_Expr_GeneralExpression

        Returns a GeneralExpression after replacement of
        NamedUnknowns by an associated expression, and after
        values computation.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_Simplified(self, *args)


    def IsShareable(self, *args):
        """
        IsShareable(Handle_Expr_ArgSinh self) -> Standard_Boolean

        Tests if <me> can be shared by one or more expressions
        or must be copied. This method returns False as a
        default value. To be redefined ( especially for
        NamedUnknown).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_IsShareable(self, *args)


    def NDerivative(self, *args):
        """
        NDerivative(Handle_Expr_ArgSinh self, Handle_Expr_NamedUnknown X, Standard_Integer const N) -> Handle_Expr_GeneralExpression

        Returns the <N>-th derivative on <X> unknown of <me>.
        Raise OutOfRange if N <= 0

        :type X: OCC.wrapper.Expr.Handle_Expr_NamedUnknown
        :type N: int
        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _Expr.Handle_Expr_ArgSinh_NDerivative(self, *args)


    def EvaluateNumeric(self, *args):
        """
        EvaluateNumeric(Handle_Expr_ArgSinh self) -> Standard_Real

        Returns the value of <me> (as a Real) by
        replacement of <vars> by <vals>.
        Raises NotEvaluable if <me> contains NamedUnknown not
        in <vars> or NumericError if result cannot be computed.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Expr.Handle_Expr_ArgSinh_EvaluateNumeric(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Expr_ArgSinh self)

        Memory deallocator for transient classes


        """
        return _Expr.Handle_Expr_ArgSinh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Expr_ArgSinh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Expr_ArgSinh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Expr_ArgSinh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Expr_ArgSinh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Expr.Handle_Expr_ArgSinh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Expr_ArgSinh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Expr.Handle_Expr_ArgSinh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Expr_ArgSinh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgSinh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Expr_ArgSinh self)

        Increments the reference counter of this object


        """
        return _Expr.Handle_Expr_ArgSinh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Expr_ArgSinh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Expr.Handle_Expr_ArgSinh_DecrementRefCounter(self, *args)

Handle_Expr_ArgSinh_swigregister = _Expr.Handle_Expr_ArgSinh_swigregister
Handle_Expr_ArgSinh_swigregister(Handle_Expr_ArgSinh)

def Handle_Expr_ArgSinh_DownCast(thing):
    return _Expr.Handle_Expr_ArgSinh_DownCast(thing)
Handle_Expr_ArgSinh_DownCast = _Expr.Handle_Expr_ArgSinh_DownCast




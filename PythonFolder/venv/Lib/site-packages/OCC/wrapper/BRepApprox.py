# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepApprox')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepApprox')
    _BRepApprox = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepApprox', [dirname(__file__)])
        except ImportError:
            import _BRepApprox
            return _BRepApprox
        try:
            _mod = imp.load_module('_BRepApprox', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepApprox = swig_import_helper()
    del swig_import_helper
else:
    import _BRepApprox
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepApprox.delete_SwigPyIterator

    def value(self):
        return _BRepApprox.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepApprox.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepApprox.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepApprox.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepApprox.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepApprox.SwigPyIterator_copy(self)

    def next(self):
        return _BRepApprox.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepApprox.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepApprox.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepApprox.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepApprox.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepApprox.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepApprox.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepApprox.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepApprox.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepApprox.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepApprox.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepApprox.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepApprox.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepApprox.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepApprox.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepApprox.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepApprox.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepApprox.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepApprox.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepApprox.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepApprox.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepApprox.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepApprox.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepApprox.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepApprox.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepApprox.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepApprox.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepApprox.ptr_to_number(item)
ptr_to_number = _BRepApprox.ptr_to_number

def HashCode(*args):
    return _BRepApprox.HashCode(*args)
HashCode = _BRepApprox.HashCode

def ptr_equal(a, b):
    return _BRepApprox.ptr_equal(a, b)
ptr_equal = _BRepApprox.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
class BRepApprox_Approx(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BRepApprox_Approx self) -> BRepApprox_Approx"""
        this = _BRepApprox.new_BRepApprox_Approx(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepApprox_Approx self, BRepAdaptor_Surface Surf1, BRepAdaptor_Surface Surf2, Handle_BRepApprox_ApproxLine aLine, Standard_Boolean const ApproxXYZ, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Integer const indicemin=0, Standard_Integer const indicemax=0)
        Perform(BRepApprox_Approx self, Handle_BRepApprox_ApproxLine aLine, Standard_Boolean const ApproxXYZ, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Integer const indicemin=0, Standard_Integer const indicemax=0)

        :type aLine: OCC.wrapper.BRepApprox.Handle_BRepApprox_ApproxLine
        :type ApproxXYZ: bool
        :type ApproxU1V1: bool
        :type ApproxU2V2: bool
        :type indicemin: int
        :type indicemax: int

        """
        return _BRepApprox.BRepApprox_Approx_Perform(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(BRepApprox_Approx self, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const DegMin, Standard_Integer const DegMax, Standard_Integer const NbIterMax, Standard_Integer const NbPntMax=30, Standard_Boolean const ApproxWithTangency, Approx_ParametrizationType const Parametrization=Approx_ChordLength)

        :type Tol3d: float
        :type Tol2d: float
        :type DegMin: int
        :type DegMax: int
        :type NbIterMax: int
        :type NbPntMax: int
        :type ApproxWithTangency: bool
        :type Parametrization: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepApprox.BRepApprox_Approx_SetParameters(self, *args)


    def TolReached3d(self, *args):
        """
        TolReached3d(BRepApprox_Approx self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_Approx_TolReached3d(self, *args)


    def TolReached2d(self, *args):
        """
        TolReached2d(BRepApprox_Approx self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_Approx_TolReached2d(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepApprox_Approx self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_Approx_IsDone(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(BRepApprox_Approx self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_Approx_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_Approx_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Approx
BRepApprox_Approx_swigregister = _BRepApprox.BRepApprox_Approx_swigregister
BRepApprox_Approx_swigregister(BRepApprox_Approx)

class BRepApprox_ApproxLine(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepApprox_ApproxLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepApprox_ApproxLine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepApprox_ApproxLine self, Handle_Geom_BSplineCurve CurveXYZ, Handle_Geom2d_BSplineCurve CurveUV1, Handle_Geom2d_BSplineCurve CurveUV2) -> BRepApprox_ApproxLine
        __init__(BRepApprox_ApproxLine self, Handle_IntSurf_LineOn2S lin, Standard_Boolean const Tang) -> BRepApprox_ApproxLine

        :type lin: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S
        :type Tang: bool

        """
        this = _BRepApprox.new_BRepApprox_ApproxLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbPnts(self, *args):
        """
        NbPnts(BRepApprox_ApproxLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_ApproxLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Point(BRepApprox_ApproxLine self, Standard_Integer const Index) -> IntSurf_PntOn2S

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _BRepApprox.BRepApprox_ApproxLine_Point(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepApprox.BRepApprox_ApproxLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepApprox.BRepApprox_ApproxLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepApprox.BRepApprox_ApproxLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ApproxLine
BRepApprox_ApproxLine_swigregister = _BRepApprox.BRepApprox_ApproxLine_swigregister
BRepApprox_ApproxLine_swigregister(BRepApprox_ApproxLine)

def BRepApprox_ApproxLine_get_type_name(*args):
    """
    BRepApprox_ApproxLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepApprox.BRepApprox_ApproxLine_get_type_name(*args)

def BRepApprox_ApproxLine_get_type_descriptor(*args):
    """
    BRepApprox_ApproxLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepApprox.BRepApprox_ApproxLine_get_type_descriptor(*args)

class BRepApprox_TheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineBezierOfApprox
        __init__(BRepApprox_TheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineBezierOfApprox
        __init__(BRepApprox_TheComputeLineBezierOfApprox self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineBezierOfApprox
        __init__(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineBezierOfApprox

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _BRepApprox.new_BRepApprox_TheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepApprox_TheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(BRepApprox_TheComputeLineBezierOfApprox self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(BRepApprox_TheComputeLineBezierOfApprox self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(BRepApprox_TheComputeLineBezierOfApprox self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(BRepApprox_TheComputeLineBezierOfApprox self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(BRepApprox_TheComputeLineBezierOfApprox self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_ChangeValue(self, *args)


    def SplineValue(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_SplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parametrization(self, *args):
        """
        Parametrization(BRepApprox_TheComputeLineBezierOfApprox self) -> Approx_ParametrizationType

        returns the type  of  parametrization

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parametrization(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the multicurve <Index>.

        :type Index: int
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineBezierOfApprox
BRepApprox_TheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_TheComputeLineBezierOfApprox_swigregister
BRepApprox_TheComputeLineBezierOfApprox_swigregister(BRepApprox_TheComputeLineBezierOfApprox)

class BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self, NCollection_Array1_Standard_Real Param, BRepAdaptor_Surface S1, BRepAdaptor_Surface S2, Standard_Real const TolTangency) -> BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox
        __init__(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self, BRepAdaptor_Surface S1, BRepAdaptor_Surface S2, Standard_Real const TolTangency) -> BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox

        initialize the parameters to compute the solution point
        it 's possible to write to optimize:
        IntImp_Int2S inter(S1,S2,Func,TolTangency);
        math_FunctionSetRoot rsnld(inter.Function());
        while ...{
        Param(1)=...
        Param(2)=...
        param(3)=...
        inter.Perform(Param,rsnld);
        }

        :type S1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type S2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type TolTangency: float

        """
        this = _BRepApprox.new_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld) -> IntImp_ConstIsoparametric
        Perform(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld, IntImp_ConstIsoparametric const ChoixIso) -> IntImp_ConstIsoparametric

        returns the best constant isoparametric to find
        the next intersection's point +stores the solution
        point (the solution point is found with the close point
        to intersect the isoparametric with the other patch;
        the choice of the isoparametic is given by ChoixIso)

        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.IntImp.IntImp_ConstIsoparametric

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Boolean

        Returns TRUE when there is no solution to the problem.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsEmpty(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Boolean

        Returns True if the surfaces are tangent at the
        intersection point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Returns the tangent at the intersection line.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS1(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS2(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Function(self, *args):
        """
        Function(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_Function(self, *args)


    def ChangePoint(self, *args):
        """
        ChangePoint(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> IntSurf_PntOn2S

        return the intersection point which is
        enable for changing.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_ChangePoint(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> BRepApprox_MyGradientOfTheComputeLineBezierOfApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _BRepApprox.new_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_AverageError(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientOfTheComputeLineBezierOfApprox
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_MyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_MyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_MyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> BRepApprox_MyGradientbisOfTheComputeLineOfApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _BRepApprox.new_BRepApprox_MyGradientbisOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(BRepApprox_MyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_AverageError(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyGradientbisOfTheComputeLineOfApprox
BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_MyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_MyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ThePrmPrmSvSurfacesOfApprox(ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, BRepAdaptor_Surface Surf1, BRepAdaptor_Surface Surf2) -> BRepApprox_ThePrmPrmSvSurfacesOfApprox

        :type Surf1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type Surf2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        this = _BRepApprox.new_BRepApprox_ThePrmPrmSvSurfacesOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, gp_Pnt Pt, gp_Vec Tg, gp_Vec2d Tguv1, gp_Vec2d Tguv2) -> Standard_Boolean

        returns True if Tg,Tguv1 Tguv2 can be computed.

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tg: OCC.wrapper.gp.gp_Vec
        :type Tguv1: OCC.wrapper.gp.gp_Vec2d
        :type Tguv2: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_Compute(self, *args)


    def Pnt(self, *args):
        """
        Pnt(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Pnt P)

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_Pnt(self, *args)


    def SeekPoint(self, *args):
        """
        SeekPoint(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, IntSurf_PntOn2S Point) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Point: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_SeekPoint(self, *args)


    def Tangency(self, *args):
        """
        Tangency(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_Tangency(self, *args)


    def TangencyOnSurf1(self, *args):
        """
        TangencyOnSurf1(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_TangencyOnSurf1(self, *args)


    def TangencyOnSurf2(self, *args):
        """
        TangencyOnSurf2(BRepApprox_ThePrmPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_TangencyOnSurf2(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ThePrmPrmSvSurfacesOfApprox
BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_ThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_ThePrmPrmSvSurfacesOfApprox)

class BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox
        __init__(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox
        __init__(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox
        __init__(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _BRepApprox.new_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector Parameters)
        Perform(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_TheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineOfApprox
        __init__(BRepApprox_TheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineOfApprox
        __init__(BRepApprox_TheComputeLineOfApprox self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineOfApprox
        __init__(BRepApprox_TheComputeLineOfApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> BRepApprox_TheComputeLineOfApprox

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _BRepApprox.new_BRepApprox_TheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Interpol(self, *args):
        """
        Interpol(BRepApprox_TheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox Line)

        Constructs an interpolation of the MultiLine <Line>
        The result will be a C2 curve of degree 3.

        :type Line: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Interpol(self, *args)


    def Init(self, *args):
        """
        Init(BRepApprox_TheComputeLineOfApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepApprox_TheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Perform(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(BRepApprox_TheComputeLineOfApprox self, math_Vector ThePar)

        The approximation will begin with the
        set of  parameters <ThePar>.

        :type ThePar: OCC.wrapper.math.math_Vector

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetParameters(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(BRepApprox_TheComputeLineOfApprox self, NCollection_Array1_Standard_Real Knots)

        The approximation will be done with the
        set of knots <Knots>. The multiplicities will be set
        with the degree and the desired continuity.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args):
        """
        SetKnotsAndMultiplicities(BRepApprox_TheComputeLineOfApprox self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        The approximation will be done with the
        set of knots <Knots> and the multiplicities <Mults>.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetKnotsAndMultiplicities(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(BRepApprox_TheComputeLineOfApprox self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(BRepApprox_TheComputeLineOfApprox self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetTolerances(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(BRepApprox_TheComputeLineOfApprox self, Standard_Integer const C)

        sets the continuity of the spline.
        if C = 2, the spline will be C2.

        :type C: int

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetContinuity(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(BRepApprox_TheComputeLineOfApprox self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(BRepApprox_TheComputeLineOfApprox self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(BRepApprox_TheComputeLineOfApprox self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_TheComputeLineOfApprox self)

        returns the tolerances 2d and 3d of the MultiBSpCurve.

        :type tol3d: float
        :type tol2d: float

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_Error(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_TheComputeLineOfApprox_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(BRepApprox_TheComputeLineOfApprox self) -> AppParCurves_MultiBSpCurve

        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _BRepApprox.BRepApprox_TheComputeLineOfApprox_ChangeValue(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the MultiBSpCurve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _BRepApprox.BRepApprox_TheComputeLineOfApprox_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheComputeLineOfApprox
BRepApprox_TheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_TheComputeLineOfApprox_swigregister
BRepApprox_TheComputeLineOfApprox_swigregister(BRepApprox_TheComputeLineOfApprox)

class BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _BRepApprox.new_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ResConstraintOfMyGradientOfTheComputeLineBezierOfApprox)

class Handle_BRepApprox_ApproxLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepApprox_ApproxLine self)

        Nullify the handle


        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepApprox_ApproxLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepApprox_ApproxLine self, BRepApprox_ApproxLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepApprox_ApproxLine self, Handle_BRepApprox_ApproxLine theHandle) -> Handle_BRepApprox_ApproxLine
        assign(Handle_BRepApprox_ApproxLine self, BRepApprox_ApproxLine thePtr) -> Handle_BRepApprox_ApproxLine
        assign(Handle_BRepApprox_ApproxLine self, Handle_BRepApprox_ApproxLine theHandle) -> Handle_BRepApprox_ApproxLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepApprox_ApproxLine self) -> BRepApprox_ApproxLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepApprox_ApproxLine self) -> BRepApprox_ApproxLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepApprox_ApproxLine self) -> BRepApprox_ApproxLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine___ref__(self, *args)


    def __hash__(self):
        return _BRepApprox.Handle_BRepApprox_ApproxLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepApprox.Handle_BRepApprox_ApproxLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepApprox.new_Handle_BRepApprox_ApproxLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepApprox.Handle_BRepApprox_ApproxLine_DownCast)
    __swig_destroy__ = _BRepApprox.delete_Handle_BRepApprox_ApproxLine

    def NbPnts(self, *args):
        """
        NbPnts(Handle_BRepApprox_ApproxLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_NbPnts(self, *args)


    def Point(self, *args):
        """
        Point(Handle_BRepApprox_ApproxLine self, Standard_Integer const Index) -> IntSurf_PntOn2S

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_Point(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepApprox_ApproxLine self) -> char const *

        :rtype: const char *

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepApprox.Handle_BRepApprox_ApproxLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepApprox.Handle_BRepApprox_ApproxLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepApprox_ApproxLine self)

        Memory deallocator for transient classes


        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepApprox_ApproxLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepApprox_ApproxLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepApprox_ApproxLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepApprox_ApproxLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepApprox_ApproxLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepApprox_ApproxLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepApprox_ApproxLine self)

        Increments the reference counter of this object


        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepApprox_ApproxLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.Handle_BRepApprox_ApproxLine_DecrementRefCounter(self, *args)

Handle_BRepApprox_ApproxLine_swigregister = _BRepApprox.Handle_BRepApprox_ApproxLine_swigregister
Handle_BRepApprox_ApproxLine_swigregister(Handle_BRepApprox_ApproxLine)

def Handle_BRepApprox_ApproxLine_DownCast(thing):
    return _BRepApprox.Handle_BRepApprox_ApproxLine_DownCast(thing)
Handle_BRepApprox_ApproxLine_DownCast = _BRepApprox.Handle_BRepApprox_ApproxLine_DownCast

class BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _BRepApprox.new_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector Parameters)
        Perform(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_LastConstraint(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox
        __init__(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _BRepApprox.new_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector Parameters)
        Perform(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_ParLeastSquareOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_TheImpPrmSvSurfacesOfApprox(ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheImpPrmSvSurfacesOfApprox self, BRepAdaptor_Surface Surf1, IntSurf_Quadric Surf2) -> BRepApprox_TheImpPrmSvSurfacesOfApprox
        __init__(BRepApprox_TheImpPrmSvSurfacesOfApprox self, IntSurf_Quadric Surf1, BRepAdaptor_Surface Surf2) -> BRepApprox_TheImpPrmSvSurfacesOfApprox

        :type Surf1: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type Surf2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        this = _BRepApprox.new_BRepApprox_TheImpPrmSvSurfacesOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(BRepApprox_TheImpPrmSvSurfacesOfApprox self, gp_Pnt Pt, gp_Vec Tg, gp_Vec2d Tguv1, gp_Vec2d Tguv2) -> Standard_Boolean

        returns True if Tg,Tguv1 Tguv2 can be computed.

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tg: OCC.wrapper.gp.gp_Vec
        :type Tguv1: OCC.wrapper.gp.gp_Vec2d
        :type Tguv2: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_Compute(self, *args)


    def Pnt(self, *args):
        """
        Pnt(BRepApprox_TheImpPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Pnt P)

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_Pnt(self, *args)


    def SeekPoint(self, *args):
        """
        SeekPoint(BRepApprox_TheImpPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, IntSurf_PntOn2S Point) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Point: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_SeekPoint(self, *args)


    def Tangency(self, *args):
        """
        Tangency(BRepApprox_TheImpPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_Tangency(self, *args)


    def TangencyOnSurf1(self, *args):
        """
        TangencyOnSurf1(BRepApprox_TheImpPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_TangencyOnSurf1(self, *args)


    def TangencyOnSurf2(self, *args):
        """
        TangencyOnSurf2(BRepApprox_TheImpPrmSvSurfacesOfApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_TangencyOnSurf2(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheImpPrmSvSurfacesOfApprox
BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheImpPrmSvSurfacesOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox
BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister
BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfApprox)

class BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const NbPol) -> BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox

        initializes the fields of the function. The approximating
        curve has <NbPol> control points.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbPol: int

        """
        this = _BRepApprox.new_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        CurveValue(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self) -> AppParCurves_MultiBSpCurve

        returns the MultiBSpCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_CurveValue(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_Index(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstConstraint(self, *args):
        """
        FirstConstraint(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_LastConstraint(self, *args)


    def SetFirstLambda(self, *args):
        """
        SetFirstLambda(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, Standard_Real const l1)

        :type l1: float

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args):
        """
        SetLastLambda(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox self, Standard_Real const l2)

        :type l2: float

        """
        return _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_SetLastLambda(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, BRepAdaptor_Surface S1, BRepAdaptor_Surface S2) -> BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox

        :type S1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type S2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        this = _BRepApprox.new_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Values(self, *args)


    def ComputeParameters(self, *args):
        """
        ComputeParameters(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, IntImp_ConstIsoparametric const ChoixIso, NCollection_Array1_Standard_Real Param, math_Vector UVap, math_Vector BornInf, math_Vector BornSup, math_Vector Tolerance)

        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UVap: OCC.wrapper.math.math_Vector
        :type BornInf: OCC.wrapper.math.math_Vector
        :type BornSup: OCC.wrapper.math.math_Vector
        :type Tolerance: OCC.wrapper.math.math_Vector

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_ComputeParameters(self, *args)


    def Root(self, *args):
        """
        Root(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> Standard_Real

        returns somme des fi*fi

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Root(self, *args)


    def Point(self, *args):
        """
        Point(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Point(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self, math_Vector UVap, NCollection_Array1_Standard_Real Param) -> Standard_Boolean

        :type UVap: OCC.wrapper.math.math_Vector
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BestChoix: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Direction(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_Direction(self, *args)


    def DirectionOnS1(self, *args):
        """
        DirectionOnS1(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args):
        """
        DirectionOnS2(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_DirectionOnS2(self, *args)


    def AuxillarSurface1(self, *args):
        """
        AuxillarSurface1(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> BRepAdaptor_Surface

        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface1(self, *args)


    def AuxillarSurface2(self, *args):
        """
        AuxillarSurface2(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox self) -> BRepAdaptor_Surface

        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_AuxillarSurface2(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfApprox)

class BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox
        __init__(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, BRepAdaptor_Surface PS, IntSurf_Quadric IS) -> BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox
        __init__(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, IntSurf_Quadric IS) -> BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        this = _BRepApprox.new_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetImplicitSurface(self, *args):
        """
        SetImplicitSurface(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, IntSurf_Quadric IS)

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_SetImplicitSurface(self, *args)


    def Set(self, *args):
        """
        Set(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, BRepAdaptor_Surface PS)
        Set(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, Standard_Real const Tolerance)

        :type Tolerance: float

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Set(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Values(self, *args)


    def Root(self, *args):
        """
        Root(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Root(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> Standard_Real

        Returns the value Tol so that if Abs(Func.Root())<Tol
        the function is considered null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Tolerance(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_IsTangent(self, *args)


    def Direction3d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PSurface(self, *args):
        """
        PSurface(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> BRepAdaptor_Surface

        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_PSurface(self, *args)


    def ISurface(self, *args):
        """
        ISurface(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox self) -> IntSurf_Quadric

        :rtype: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_ISurface(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister = _BRepApprox.BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister
BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox_swigregister(BRepApprox_TheZerImpFuncOfTheImpPrmSvSurfacesOfApprox)

class BRepApprox_TheMultiLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_TheMultiLineOfApprox self) -> BRepApprox_TheMultiLineOfApprox
        __init__(BRepApprox_TheMultiLineOfApprox self, Handle_BRepApprox_ApproxLine line, Standard_Address const PtrSvSurfaces, Standard_Integer const NbP3d, Standard_Integer const NbP2d, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Real const xo, Standard_Real const yo, Standard_Real const zo, Standard_Real const u1o, Standard_Real const v1o, Standard_Real const u2o, Standard_Real const v2o, Standard_Boolean const P2DOnFirst, Standard_Integer const IndMin=0, Standard_Integer const IndMax=0) -> BRepApprox_TheMultiLineOfApprox
        __init__(BRepApprox_TheMultiLineOfApprox self, Handle_BRepApprox_ApproxLine line, Standard_Integer const NbP3d, Standard_Integer const NbP2d, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Real const xo, Standard_Real const yo, Standard_Real const zo, Standard_Real const u1o, Standard_Real const v1o, Standard_Real const u2o, Standard_Real const v2o, Standard_Boolean const P2DOnFirst, Standard_Integer const IndMin=0, Standard_Integer const IndMax=0) -> BRepApprox_TheMultiLineOfApprox

        No Extra points will be added on the current line

        :type line: OCC.wrapper.BRepApprox.Handle_BRepApprox_ApproxLine
        :type NbP3d: int
        :type NbP2d: int
        :type ApproxU1V1: bool
        :type ApproxU2V2: bool
        :type xo: float
        :type yo: float
        :type zo: float
        :type u1o: float
        :type v1o: float
        :type u2o: float
        :type v2o: float
        :type P2DOnFirst: bool
        :type IndMin: int
        :type IndMax: int

        """
        this = _BRepApprox.new_BRepApprox_TheMultiLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstPoint(self, *args):
        """
        FirstPoint(BRepApprox_TheMultiLineOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_FirstPoint(self, *args)


    def LastPoint(self, *args):
        """
        LastPoint(BRepApprox_TheMultiLineOfApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_LastPoint(self, *args)


    def NbP2d(self, *args):
        """
        NbP2d(BRepApprox_TheMultiLineOfApprox self) -> Standard_Integer

        Returns the number of 2d points of a TheLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP2d(self, *args)


    def NbP3d(self, *args):
        """
        NbP3d(BRepApprox_TheMultiLineOfApprox self) -> Standard_Integer

        Returns the number of 3d points of a TheLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_NbP3d(self, *args)


    def WhatStatus(self, *args):
        """
        WhatStatus(BRepApprox_TheMultiLineOfApprox self) -> Approx_Status

        :rtype: OCC.wrapper.Approx.Approx_Status

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_WhatStatus(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
        Value(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
        Value(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

        Returns the 3d and 2d points of the multipoint <MPointIndex>.

        :type MPointIndex: int
        :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Value(self, *args)


    def Tangency(self, *args):
        """
        Tangency(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Tangency(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Tangency(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        Returns the 3d and 2d points of the multipoint <MPointIndex>.

        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Tangency(self, *args)


    def MakeMLBetween(self, *args):
        """
        MakeMLBetween(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const Low, Standard_Integer const High, Standard_Integer const NbPointsToInsert) -> BRepApprox_TheMultiLineOfApprox

        Tries to make a sub-line between <Low> and <High> points of this line
        by adding <NbPointsToInsert> new points

        :type Low: int
        :type High: int
        :type NbPointsToInsert: int
        :rtype: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLBetween(self, *args)


    def MakeMLOneMorePoint(self, *args):
        """
        MakeMLOneMorePoint(BRepApprox_TheMultiLineOfApprox self, Standard_Integer const Low, Standard_Integer const High, Standard_Integer const indbad, BRepApprox_TheMultiLineOfApprox OtherLine) -> Standard_Boolean

        Tries to make a sub-line between <Low> and <High> points of this line
        by adding one more point between (indbad-1)-th and indbad-th points

        :type Low: int
        :type High: int
        :type indbad: int
        :type OtherLine: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_MakeMLOneMorePoint(self, *args)


    def Dump(self, *args):
        """
        Dump(BRepApprox_TheMultiLineOfApprox self)

        Dump of the current multi-line.


        """
        return _BRepApprox.BRepApprox_TheMultiLineOfApprox_Dump(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineOfApprox
BRepApprox_TheMultiLineOfApprox_swigregister = _BRepApprox.BRepApprox_TheMultiLineOfApprox_swigregister
BRepApprox_TheMultiLineOfApprox_swigregister(BRepApprox_TheMultiLineOfApprox)

class BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=1) -> BRepApprox_MyBSplGradientOfTheComputeLineOfApprox
        __init__(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations, Standard_Real const lambda1, Standard_Real const lambda2) -> BRepApprox_MyBSplGradientOfTheComputeLineOfApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating BSpline curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int
        :type lambda1: float
        :type lambda2: float

        """
        this = _BRepApprox.new_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self) -> AppParCurves_MultiBSpCurve

        returns all the BSpline curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_AverageError(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_MyBSplGradientOfTheComputeLineOfApprox
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister = _BRepApprox.BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister
BRepApprox_MyBSplGradientOfTheComputeLineOfApprox_swigregister(BRepApprox_MyBSplGradientOfTheComputeLineOfApprox)

class BRepApprox_TheMultiLineToolOfApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstPoint(*args):
        """
        FirstPoint(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

        Returns the number of multipoints of the TheMultiLine.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args):
        """
        LastPoint(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

        Returns the number of multipoints of the TheMultiLine.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def NbP2d(*args):
        """
        NbP2d(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

        Returns the number of 2d points of a TheMultiLine.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args):
        """
        NbP3d(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

        Returns the number of 3d points of a TheMultiLine.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Value(*args):
        """
        Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
        Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
        Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type MPointIndex: int
        :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value(*args)

    Value = staticmethod(Value)

    def Tangency(*args):
        """
        Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Curvature(*args):
        """
        Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d curvature of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def MakeMLBetween(*args):
        """
        MakeMLBetween(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> BRepApprox_TheMultiLineOfApprox

        Is called if WhatStatus returned "PointsAdded".

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type I1: int
        :type I2: int
        :type NbPMin: int
        :rtype: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args):
        """
        MakeMLOneMorePoint(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, BRepApprox_TheMultiLineOfApprox OtherLine) -> Standard_Boolean

        Is called when the Bezier curve contains a loop

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type I1: int
        :type I2: int
        :type indbad: int
        :type OtherLine: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def WhatStatus(*args):
        """
        WhatStatus(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type I1: int
        :type I2: int
        :rtype: OCC.wrapper.Approx.Approx_Status

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    def Dump(*args):
        """
        Dump(BRepApprox_TheMultiLineOfApprox ML)

        Dump of the current multi-line.

        :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

        """
        return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _BRepApprox.new_BRepApprox_TheMultiLineToolOfApprox()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepApprox.delete_BRepApprox_TheMultiLineToolOfApprox
BRepApprox_TheMultiLineToolOfApprox_swigregister = _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_swigregister
BRepApprox_TheMultiLineToolOfApprox_swigregister(BRepApprox_TheMultiLineToolOfApprox)

def BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_FirstPoint(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

    Returns the number of multipoints of the TheMultiLine.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_FirstPoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_LastPoint(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

    Returns the number of multipoints of the TheMultiLine.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_LastPoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_NbP2d(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

    Returns the number of 2d points of a TheMultiLine.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP2d(*args)

def BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_NbP3d(BRepApprox_TheMultiLineOfApprox ML) -> Standard_Integer

    Returns the number of 3d points of a TheMultiLine.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_NbP3d(*args)

def BRepApprox_TheMultiLineToolOfApprox_Value(*args):
    """
    Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
    Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
    BRepApprox_TheMultiLineToolOfApprox_Value(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type MPointIndex: int
    :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Value(*args)

def BRepApprox_TheMultiLineToolOfApprox_Tangency(*args):
    """
    Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    BRepApprox_TheMultiLineToolOfApprox_Tangency(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Tangency(*args)

def BRepApprox_TheMultiLineToolOfApprox_Curvature(*args):
    """
    Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    BRepApprox_TheMultiLineToolOfApprox_Curvature(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d curvature of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Curvature(*args)

def BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> BRepApprox_TheMultiLineOfApprox

    Is called if WhatStatus returned "PointsAdded".

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type I1: int
    :type I2: int
    :type NbPMin: int
    :rtype: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLBetween(*args)

def BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, BRepApprox_TheMultiLineOfApprox OtherLine) -> Standard_Boolean

    Is called when the Bezier curve contains a loop

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type I1: int
    :type I2: int
    :type indbad: int
    :type OtherLine: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_MakeMLOneMorePoint(*args)

def BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_WhatStatus(BRepApprox_TheMultiLineOfApprox ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
    :type I1: int
    :type I2: int
    :rtype: OCC.wrapper.Approx.Approx_Status

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_WhatStatus(*args)

def BRepApprox_TheMultiLineToolOfApprox_Dump(*args):
    """
    BRepApprox_TheMultiLineToolOfApprox_Dump(BRepApprox_TheMultiLineOfApprox ML)

    Dump of the current multi-line.

    :type ML: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox

    """
    return _BRepApprox.BRepApprox_TheMultiLineToolOfApprox_Dump(*args)

class BRepApprox_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstUParameter(*args):
        """
        FirstUParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_FirstUParameter(*args)

    FirstUParameter = staticmethod(FirstUParameter)

    def FirstVParameter(*args):
        """
        FirstVParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_FirstVParameter(*args)

    FirstVParameter = staticmethod(FirstVParameter)

    def LastUParameter(*args):
        """
        LastUParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_LastUParameter(*args)

    LastUParameter = staticmethod(LastUParameter)

    def LastVParameter(*args):
        """
        LastVParameter(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_LastVParameter(*args)

    LastVParameter = staticmethod(LastVParameter)

    def NbUIntervals(*args):
        """
        NbUIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_SurfaceTool_NbUIntervals(*args)

    NbUIntervals = staticmethod(NbUIntervals)

    def NbVIntervals(*args):
        """
        NbVIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_SurfaceTool_NbVIntervals(*args)

    NbVIntervals = staticmethod(NbVIntervals)

    def UIntervals(*args):
        """
        UIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepApprox.BRepApprox_SurfaceTool_UIntervals(*args)

    UIntervals = staticmethod(UIntervals)

    def VIntervals(*args):
        """
        VIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepApprox.BRepApprox_SurfaceTool_VIntervals(*args)

    VIntervals = staticmethod(VIntervals)

    def UTrim(*args):
        """
        UTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _BRepApprox.BRepApprox_SurfaceTool_UTrim(*args)

    UTrim = staticmethod(UTrim)

    def VTrim(*args):
        """
        VTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

        If <First> >= <Last>

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _BRepApprox.BRepApprox_SurfaceTool_VTrim(*args)

    VTrim = staticmethod(VTrim)

    def IsUClosed(*args):
        """
        IsUClosed(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_SurfaceTool_IsUClosed(*args)

    IsUClosed = staticmethod(IsUClosed)

    def IsVClosed(*args):
        """
        IsVClosed(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_SurfaceTool_IsVClosed(*args)

    IsVClosed = staticmethod(IsVClosed)

    def IsUPeriodic(*args):
        """
        IsUPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_SurfaceTool_IsUPeriodic(*args)

    IsUPeriodic = staticmethod(IsUPeriodic)

    def UPeriod(*args):
        """
        UPeriod(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_UPeriod(*args)

    UPeriod = staticmethod(UPeriod)

    def IsVPeriodic(*args):
        """
        IsVPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_SurfaceTool_IsVPeriodic(*args)

    IsVPeriodic = staticmethod(IsVPeriodic)

    def VPeriod(*args):
        """
        VPeriod(BRepAdaptor_Surface S) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_VPeriod(*args)

    VPeriod = staticmethod(VPeriod)

    def Value(*args):
        """
        Value(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepApprox.BRepApprox_SurfaceTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1u: OCC.wrapper.gp.gp_Vec
        :type D1v: OCC.wrapper.gp.gp_Vec

        """
        return _BRepApprox.BRepApprox_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _BRepApprox.BRepApprox_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _BRepApprox.BRepApprox_SurfaceTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u: float
        :type v: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _BRepApprox.BRepApprox_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def UResolution(*args):
        """
        UResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_UResolution(*args)

    UResolution = staticmethod(UResolution)

    def VResolution(*args):
        """
        VResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_SurfaceTool_VResolution(*args)

    VResolution = staticmethod(VResolution)

    def GetType(*args):
        """
        GetType(BRepAdaptor_Surface S) -> GeomAbs_SurfaceType

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

        """
        return _BRepApprox.BRepApprox_SurfaceTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Plane(*args):
        """
        Plane(BRepAdaptor_Surface S) -> gp_Pln

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Plane(*args)

    Plane = staticmethod(Plane)

    def Cylinder(*args):
        """
        Cylinder(BRepAdaptor_Surface S) -> gp_Cylinder

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Cylinder(*args)

    Cylinder = staticmethod(Cylinder)

    def Cone(*args):
        """
        Cone(BRepAdaptor_Surface S) -> gp_Cone

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Cone(*args)

    Cone = staticmethod(Cone)

    def Torus(*args):
        """
        Torus(BRepAdaptor_Surface S) -> gp_Torus

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Torus(*args)

    Torus = staticmethod(Torus)

    def Sphere(*args):
        """
        Sphere(BRepAdaptor_Surface S) -> gp_Sphere

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Sphere(*args)

    Sphere = staticmethod(Sphere)

    def Bezier(*args):
        """
        Bezier(BRepAdaptor_Surface S) -> Handle_Geom_BezierSurface

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(BRepAdaptor_Surface S) -> Handle_Geom_BSplineSurface

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _BRepApprox.BRepApprox_SurfaceTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def AxeOfRevolution(*args):
        """
        AxeOfRevolution(BRepAdaptor_Surface S) -> gp_Ax1

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _BRepApprox.BRepApprox_SurfaceTool_AxeOfRevolution(*args)

    AxeOfRevolution = staticmethod(AxeOfRevolution)

    def Direction(*args):
        """
        Direction(BRepAdaptor_Surface S) -> gp_Dir

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _BRepApprox.BRepApprox_SurfaceTool_Direction(*args)

    Direction = staticmethod(Direction)

    def BasisCurve(*args):
        """
        BasisCurve(BRepAdaptor_Surface S) -> Handle_Adaptor3d_HCurve

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _BRepApprox.BRepApprox_SurfaceTool_BasisCurve(*args)

    BasisCurve = staticmethod(BasisCurve)

    def NbSamplesU(*args):
        """
        NbSamplesU(BRepAdaptor_Surface S) -> Standard_Integer
        NbSamplesU(BRepAdaptor_Surface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_SurfaceTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(BRepAdaptor_Surface S) -> Standard_Integer
        NbSamplesV(BRepAdaptor_Surface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_SurfaceTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def __init__(self):
        this = _BRepApprox.new_BRepApprox_SurfaceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepApprox.delete_BRepApprox_SurfaceTool
BRepApprox_SurfaceTool_swigregister = _BRepApprox.BRepApprox_SurfaceTool_swigregister
BRepApprox_SurfaceTool_swigregister(BRepApprox_SurfaceTool)

def BRepApprox_SurfaceTool_FirstUParameter(*args):
    """
    BRepApprox_SurfaceTool_FirstUParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_FirstUParameter(*args)

def BRepApprox_SurfaceTool_FirstVParameter(*args):
    """
    BRepApprox_SurfaceTool_FirstVParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_FirstVParameter(*args)

def BRepApprox_SurfaceTool_LastUParameter(*args):
    """
    BRepApprox_SurfaceTool_LastUParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_LastUParameter(*args)

def BRepApprox_SurfaceTool_LastVParameter(*args):
    """
    BRepApprox_SurfaceTool_LastVParameter(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_LastVParameter(*args)

def BRepApprox_SurfaceTool_NbUIntervals(*args):
    """
    BRepApprox_SurfaceTool_NbUIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_SurfaceTool_NbUIntervals(*args)

def BRepApprox_SurfaceTool_NbVIntervals(*args):
    """
    BRepApprox_SurfaceTool_NbVIntervals(BRepAdaptor_Surface S, GeomAbs_Shape const Sh) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_SurfaceTool_NbVIntervals(*args)

def BRepApprox_SurfaceTool_UIntervals(*args):
    """
    BRepApprox_SurfaceTool_UIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepApprox.BRepApprox_SurfaceTool_UIntervals(*args)

def BRepApprox_SurfaceTool_VIntervals(*args):
    """
    BRepApprox_SurfaceTool_VIntervals(BRepAdaptor_Surface S, NCollection_Array1_Standard_Real T, GeomAbs_Shape const Sh)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Sh: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepApprox.BRepApprox_SurfaceTool_VIntervals(*args)

def BRepApprox_SurfaceTool_UTrim(*args):
    """
    BRepApprox_SurfaceTool_UTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _BRepApprox.BRepApprox_SurfaceTool_UTrim(*args)

def BRepApprox_SurfaceTool_VTrim(*args):
    """
    BRepApprox_SurfaceTool_VTrim(BRepAdaptor_Surface S, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HSurface

    If <First> >= <Last>

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type First: float
    :type Last: float
    :type Tol: float
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

    """
    return _BRepApprox.BRepApprox_SurfaceTool_VTrim(*args)

def BRepApprox_SurfaceTool_IsUClosed(*args):
    """
    BRepApprox_SurfaceTool_IsUClosed(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_SurfaceTool_IsUClosed(*args)

def BRepApprox_SurfaceTool_IsVClosed(*args):
    """
    BRepApprox_SurfaceTool_IsVClosed(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_SurfaceTool_IsVClosed(*args)

def BRepApprox_SurfaceTool_IsUPeriodic(*args):
    """
    BRepApprox_SurfaceTool_IsUPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_SurfaceTool_IsUPeriodic(*args)

def BRepApprox_SurfaceTool_UPeriod(*args):
    """
    BRepApprox_SurfaceTool_UPeriod(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_UPeriod(*args)

def BRepApprox_SurfaceTool_IsVPeriodic(*args):
    """
    BRepApprox_SurfaceTool_IsVPeriodic(BRepAdaptor_Surface S) -> Standard_Boolean

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepApprox.BRepApprox_SurfaceTool_IsVPeriodic(*args)

def BRepApprox_SurfaceTool_VPeriod(*args):
    """
    BRepApprox_SurfaceTool_VPeriod(BRepAdaptor_Surface S) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_VPeriod(*args)

def BRepApprox_SurfaceTool_Value(*args):
    """
    BRepApprox_SurfaceTool_Value(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v) -> gp_Pnt

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Value(*args)

def BRepApprox_SurfaceTool_D0(*args):
    """
    BRepApprox_SurfaceTool_D0(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepApprox.BRepApprox_SurfaceTool_D0(*args)

def BRepApprox_SurfaceTool_D1(*args):
    """
    BRepApprox_SurfaceTool_D1(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1u, gp_Vec D1v)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1u: OCC.wrapper.gp.gp_Vec
    :type D1v: OCC.wrapper.gp.gp_Vec

    """
    return _BRepApprox.BRepApprox_SurfaceTool_D1(*args)

def BRepApprox_SurfaceTool_D2(*args):
    """
    BRepApprox_SurfaceTool_D2(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec

    """
    return _BRepApprox.BRepApprox_SurfaceTool_D2(*args)

def BRepApprox_SurfaceTool_D3(*args):
    """
    BRepApprox_SurfaceTool_D3(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type D2UV: OCC.wrapper.gp.gp_Vec
    :type D3U: OCC.wrapper.gp.gp_Vec
    :type D3V: OCC.wrapper.gp.gp_Vec
    :type D3UUV: OCC.wrapper.gp.gp_Vec
    :type D3UVV: OCC.wrapper.gp.gp_Vec

    """
    return _BRepApprox.BRepApprox_SurfaceTool_D3(*args)

def BRepApprox_SurfaceTool_DN(*args):
    """
    BRepApprox_SurfaceTool_DN(BRepAdaptor_Surface S, Standard_Real const u, Standard_Real const v, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u: float
    :type v: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _BRepApprox.BRepApprox_SurfaceTool_DN(*args)

def BRepApprox_SurfaceTool_UResolution(*args):
    """
    BRepApprox_SurfaceTool_UResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_UResolution(*args)

def BRepApprox_SurfaceTool_VResolution(*args):
    """
    BRepApprox_SurfaceTool_VResolution(BRepAdaptor_Surface S, Standard_Real const R3d) -> Standard_Real

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepApprox.BRepApprox_SurfaceTool_VResolution(*args)

def BRepApprox_SurfaceTool_GetType(*args):
    """
    BRepApprox_SurfaceTool_GetType(BRepAdaptor_Surface S) -> GeomAbs_SurfaceType

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_SurfaceType

    """
    return _BRepApprox.BRepApprox_SurfaceTool_GetType(*args)

def BRepApprox_SurfaceTool_Plane(*args):
    """
    BRepApprox_SurfaceTool_Plane(BRepAdaptor_Surface S) -> gp_Pln

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Pln

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Plane(*args)

def BRepApprox_SurfaceTool_Cylinder(*args):
    """
    BRepApprox_SurfaceTool_Cylinder(BRepAdaptor_Surface S) -> gp_Cylinder

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Cylinder

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Cylinder(*args)

def BRepApprox_SurfaceTool_Cone(*args):
    """
    BRepApprox_SurfaceTool_Cone(BRepAdaptor_Surface S) -> gp_Cone

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Cone

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Cone(*args)

def BRepApprox_SurfaceTool_Torus(*args):
    """
    BRepApprox_SurfaceTool_Torus(BRepAdaptor_Surface S) -> gp_Torus

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Torus

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Torus(*args)

def BRepApprox_SurfaceTool_Sphere(*args):
    """
    BRepApprox_SurfaceTool_Sphere(BRepAdaptor_Surface S) -> gp_Sphere

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Sphere

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Sphere(*args)

def BRepApprox_SurfaceTool_Bezier(*args):
    """
    BRepApprox_SurfaceTool_Bezier(BRepAdaptor_Surface S) -> Handle_Geom_BezierSurface

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Bezier(*args)

def BRepApprox_SurfaceTool_BSpline(*args):
    """
    BRepApprox_SurfaceTool_BSpline(BRepAdaptor_Surface S) -> Handle_Geom_BSplineSurface

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _BRepApprox.BRepApprox_SurfaceTool_BSpline(*args)

def BRepApprox_SurfaceTool_AxeOfRevolution(*args):
    """
    BRepApprox_SurfaceTool_AxeOfRevolution(BRepAdaptor_Surface S) -> gp_Ax1

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _BRepApprox.BRepApprox_SurfaceTool_AxeOfRevolution(*args)

def BRepApprox_SurfaceTool_Direction(*args):
    """
    BRepApprox_SurfaceTool_Direction(BRepAdaptor_Surface S) -> gp_Dir

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _BRepApprox.BRepApprox_SurfaceTool_Direction(*args)

def BRepApprox_SurfaceTool_BasisCurve(*args):
    """
    BRepApprox_SurfaceTool_BasisCurve(BRepAdaptor_Surface S) -> Handle_Adaptor3d_HCurve

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

    """
    return _BRepApprox.BRepApprox_SurfaceTool_BasisCurve(*args)

def BRepApprox_SurfaceTool_NbSamplesU(*args):
    """
    NbSamplesU(BRepAdaptor_Surface S) -> Standard_Integer
    BRepApprox_SurfaceTool_NbSamplesU(BRepAdaptor_Surface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_SurfaceTool_NbSamplesU(*args)

def BRepApprox_SurfaceTool_NbSamplesV(*args):
    """
    NbSamplesV(BRepAdaptor_Surface S) -> Standard_Integer
    BRepApprox_SurfaceTool_NbSamplesV(BRepAdaptor_Surface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepApprox.BRepApprox_SurfaceTool_NbSamplesV(*args)

class BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, BRepApprox_TheMultiLineOfApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.BRepApprox.BRepApprox_TheMultiLineOfApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _BRepApprox.new_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_LastConstraint(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_ParFunctionOfMyGradientOfTheComputeLineBezierOfApprox)

class BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _BRepApprox.new_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _BRepApprox.delete_BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox
BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister = _BRepApprox.BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister
BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox_swigregister(BRepApprox_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfApprox)




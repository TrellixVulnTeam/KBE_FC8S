# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntAna')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntAna')
    _IntAna = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntAna', [dirname(__file__)])
        except ImportError:
            import _IntAna
            return _IntAna
        try:
            _mod = imp.load_module('_IntAna', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntAna = swig_import_helper()
    del swig_import_helper
else:
    import _IntAna
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntAna.delete_SwigPyIterator

    def value(self):
        return _IntAna.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntAna.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntAna.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntAna.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntAna.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntAna.SwigPyIterator_copy(self)

    def next(self):
        return _IntAna.SwigPyIterator_next(self)

    def __next__(self):
        return _IntAna.SwigPyIterator___next__(self)

    def previous(self):
        return _IntAna.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntAna.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntAna.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntAna.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntAna.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntAna.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntAna.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntAna.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntAna.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntAna.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntAna.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntAna.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntAna.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntAna.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntAna.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntAna.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntAna.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntAna.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntAna.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntAna.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntAna.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntAna.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntAna.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntAna.ptr_to_number(item)
ptr_to_number = _IntAna.ptr_to_number

def HashCode(*args):
    return _IntAna.HashCode(*args)
HashCode = _IntAna.HashCode

def ptr_equal(a, b):
    return _IntAna.ptr_equal(a, b)
ptr_equal = _IntAna.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
IntAna_Point = _IntAna.IntAna_Point
IntAna_Line = _IntAna.IntAna_Line
IntAna_Circle = _IntAna.IntAna_Circle
IntAna_PointAndCircle = _IntAna.IntAna_PointAndCircle
IntAna_Ellipse = _IntAna.IntAna_Ellipse
IntAna_Parabola = _IntAna.IntAna_Parabola
IntAna_Hyperbola = _IntAna.IntAna_Hyperbola
IntAna_Empty = _IntAna.IntAna_Empty
IntAna_Same = _IntAna.IntAna_Same
IntAna_NoGeometricSolution = _IntAna.IntAna_NoGeometricSolution
class IntAna_Curve(object):
    """
    Definition of a parametric Curve which is the result
    of the intersection between two quadrics.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_Curve self) -> IntAna_Curve

        Empty Constructor


        """
        this = _IntAna.new_IntAna_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCylinderQuadValues(self, *args):
        """
        SetCylinderQuadValues(IntAna_Curve self, gp_Cylinder Cylinder, Standard_Real const Qxx, Standard_Real const Qyy, Standard_Real const Qzz, Standard_Real const Qxy, Standard_Real const Qxz, Standard_Real const Qyz, Standard_Real const Qx, Standard_Real const Qy, Standard_Real const Qz, Standard_Real const Q1, Standard_Real const Tol, Standard_Real const DomInf, Standard_Real const DomSup, Standard_Boolean const TwoZForATheta, Standard_Boolean const ZIsPositive)

        Sets the parameters used to compute Points and Derivative
        on the curve.

        :type Cylinder: OCC.wrapper.gp.gp_Cylinder
        :type Qxx: float
        :type Qyy: float
        :type Qzz: float
        :type Qxy: float
        :type Qxz: float
        :type Qyz: float
        :type Qx: float
        :type Qy: float
        :type Qz: float
        :type Q1: float
        :type Tol: float
        :type DomInf: float
        :type DomSup: float
        :type TwoZForATheta: bool
        :type ZIsPositive: bool

        """
        return _IntAna.IntAna_Curve_SetCylinderQuadValues(self, *args)


    def SetConeQuadValues(self, *args):
        """
        SetConeQuadValues(IntAna_Curve self, gp_Cone Cone, Standard_Real const Qxx, Standard_Real const Qyy, Standard_Real const Qzz, Standard_Real const Qxy, Standard_Real const Qxz, Standard_Real const Qyz, Standard_Real const Qx, Standard_Real const Qy, Standard_Real const Qz, Standard_Real const Q1, Standard_Real const Tol, Standard_Real const DomInf, Standard_Real const DomSup, Standard_Boolean const TwoZForATheta, Standard_Boolean const ZIsPositive)

        Sets  the parameters used    to compute Points  and
        Derivative on the curve.

        :type Cone: OCC.wrapper.gp.gp_Cone
        :type Qxx: float
        :type Qyy: float
        :type Qzz: float
        :type Qxy: float
        :type Qxz: float
        :type Qyz: float
        :type Qx: float
        :type Qy: float
        :type Qz: float
        :type Q1: float
        :type Tol: float
        :type DomInf: float
        :type DomSup: float
        :type TwoZForATheta: bool
        :type ZIsPositive: bool

        """
        return _IntAna.IntAna_Curve_SetConeQuadValues(self, *args)


    def IsOpen(self, *args):
        """
        IsOpen(IntAna_Curve self) -> Standard_Boolean

        Returns TRUE if the curve is not  infinite  at the
        last parameter or at the first parameter of the domain.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Curve_IsOpen(self, *args)


    def Domain(self, *args):
        """
        Domain(IntAna_Curve self)

        Returns the paramatric domain of the curve.

        :type theFirst: float
        :type theLast: float

        """
        return _IntAna.IntAna_Curve_Domain(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(IntAna_Curve self) -> Standard_Boolean

        Returns TRUE if the function is constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Curve_IsConstant(self, *args)


    def IsFirstOpen(self, *args):
        """
        IsFirstOpen(IntAna_Curve self) -> Standard_Boolean

        Returns TRUE if the domain is open at the beginning.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Curve_IsFirstOpen(self, *args)


    def IsLastOpen(self, *args):
        """
        IsLastOpen(IntAna_Curve self) -> Standard_Boolean

        Returns TRUE if the domain is open at the end.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Curve_IsLastOpen(self, *args)


    def Value(self, *args):
        """
        Value(IntAna_Curve self, Standard_Real const Theta) -> gp_Pnt

        Returns the point at parameter Theta on the curve.

        :type Theta: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntAna.IntAna_Curve_Value(self, *args)


    def D1u(self, *args):
        """
        D1u(IntAna_Curve self, Standard_Real const Theta, gp_Pnt P, gp_Vec V) -> Standard_Boolean

        Returns the point and the first derivative at parameter
        Theta on the curve.

        :type Theta: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Curve_D1u(self, *args)


    def FindParameter(self, *args):
        """
        FindParameter(IntAna_Curve self, gp_Pnt P, NCollection_List_Standard_Real theParams)

        Tries to find the parameter of the point P on the curve.
        If the method returns False, the "projection" is
        impossible.
        If the method returns True at least one parameter has been found.
        theParams is always sorted in ascending order.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type theParams: OCC.wrapper.TColStd.TColStd_ListOfReal

        """
        return _IntAna.IntAna_Curve_FindParameter(self, *args)


    def SetIsFirstOpen(self, *args):
        """
        SetIsFirstOpen(IntAna_Curve self, Standard_Boolean const Flag)

        If flag is True, the Curve is not defined at the
        first parameter of its domain.

        :type Flag: bool

        """
        return _IntAna.IntAna_Curve_SetIsFirstOpen(self, *args)


    def SetIsLastOpen(self, *args):
        """
        SetIsLastOpen(IntAna_Curve self, Standard_Boolean const Flag)

        If flag is True, the Curve is not defined at the
        first parameter of its domain.

        :type Flag: bool

        """
        return _IntAna.IntAna_Curve_SetIsLastOpen(self, *args)


    def SetDomain(self, *args):
        """
        SetDomain(IntAna_Curve self, Standard_Real const theFirst, Standard_Real const theLast)

        Trims this curve

        :type theFirst: float
        :type theLast: float

        """
        return _IntAna.IntAna_Curve_SetDomain(self, *args)

    __swig_destroy__ = _IntAna.delete_IntAna_Curve
IntAna_Curve_swigregister = _IntAna.IntAna_Curve_swigregister
IntAna_Curve_swigregister(IntAna_Curve)

class IntAna_Int3Pln(object):
    """
    Intersection between 3 planes. The algorithm searches
    for an intersection point. If two of the planes are
    parallel or identical, IsEmpty returns TRUE.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_Int3Pln self) -> IntAna_Int3Pln
        __init__(IntAna_Int3Pln self, gp_Pln P1, gp_Pln P2, gp_Pln P3) -> IntAna_Int3Pln

        Determination of the intersection point between
        3 planes.

        :type P1: OCC.wrapper.gp.gp_Pln
        :type P2: OCC.wrapper.gp.gp_Pln
        :type P3: OCC.wrapper.gp.gp_Pln

        """
        this = _IntAna.new_IntAna_Int3Pln(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna_Int3Pln self, gp_Pln P1, gp_Pln P2, gp_Pln P3)

        Determination of the intersection point between
        3 planes.

        :type P1: OCC.wrapper.gp.gp_Pln
        :type P2: OCC.wrapper.gp.gp_Pln
        :type P3: OCC.wrapper.gp.gp_Pln

        """
        return _IntAna.IntAna_Int3Pln_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna_Int3Pln self) -> Standard_Boolean

        Returns True if the computation was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Int3Pln_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntAna_Int3Pln self) -> Standard_Boolean

        Returns TRUE if there is no intersection POINT.
        If 2 planes are identical or parallel, IsEmpty
        will return TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_Int3Pln_IsEmpty(self, *args)


    def Value(self, *args):
        """
        Returns the intersection point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntAna.IntAna_Int3Pln_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntAna.delete_IntAna_Int3Pln
IntAna_Int3Pln_swigregister = _IntAna.IntAna_Int3Pln_swigregister
IntAna_Int3Pln_swigregister(IntAna_Int3Pln)

class IntAna_IntQuadQuad(object):
    """
    This class provides the analytic intersection between a
    cylinder or a cone from gp and another quadric, as defined
    in the class Quadric from IntAna.
    This algorithm is used when the geometric intersection
    (class QuadQuadGeo from IntAna) returns no geometric
    solution.
    The result of the intersection may be
    - Curves as defined in the class Curve from IntAna
    - Points (Pnt from gp)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_IntQuadQuad self) -> IntAna_IntQuadQuad
        __init__(IntAna_IntQuadQuad self, gp_Cylinder C, IntAna_Quadric Q, Standard_Real const Tol) -> IntAna_IntQuadQuad
        __init__(IntAna_IntQuadQuad self, gp_Cone C, IntAna_Quadric Q, Standard_Real const Tol) -> IntAna_IntQuadQuad

        Creates the intersection between a cone and a quadric.
        Tol est a definir plus precisemment.

        :type C: OCC.wrapper.gp.gp_Cone
        :type Q: OCC.wrapper.IntAna.IntAna_Quadric
        :type Tol: float

        """
        this = _IntAna.new_IntAna_IntQuadQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna_IntQuadQuad self, gp_Cylinder C, IntAna_Quadric Q, Standard_Real const Tol)
        Perform(IntAna_IntQuadQuad self, gp_Cone C, IntAna_Quadric Q, Standard_Real const Tol)

        Intersects a cone and a quadric.
        Tol est a definir plus precisemment.

        :type C: OCC.wrapper.gp.gp_Cone
        :type Q: OCC.wrapper.IntAna.IntAna_Quadric
        :type Tol: float

        """
        return _IntAna.IntAna_IntQuadQuad_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna_IntQuadQuad self) -> Standard_Boolean

        Returns True if the computation was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntQuadQuad_IsDone(self, *args)


    def IdenticalElements(self, *args):
        """
        IdenticalElements(IntAna_IntQuadQuad self) -> Standard_Boolean

        Returns TRUE if the cylinder, the cone or the sphere
        is identical to the quadric.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntQuadQuad_IdenticalElements(self, *args)


    def NbCurve(self, *args):
        """
        NbCurve(IntAna_IntQuadQuad self) -> Standard_Integer

        Returns the number of curves solution.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntQuadQuad_NbCurve(self, *args)


    def Curve(self, *args):
        """
        Returns the curve of range N.

        :type N: int
        :rtype: OCC.wrapper.IntAna.IntAna_Curve

        """
        res = _IntAna.IntAna_IntQuadQuad_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbPnt(self, *args):
        """
        NbPnt(IntAna_IntQuadQuad self) -> Standard_Integer

        Returns the number of contact point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntQuadQuad_NbPnt(self, *args)


    def Point(self, *args):
        """
        Returns the point of range N.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntAna.IntAna_IntQuadQuad_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(IntAna_IntQuadQuad self, Standard_Integer const N)

        Returns  the paramaters on the  "explicit quadric"
        (i.e  the cylinder or the  cone, the
        first argument   given to the constructor)  of the
        point of  range  N.

        :type N: int
        :type U1: float
        :type U2: float

        """
        return _IntAna.IntAna_IntQuadQuad_Parameters(self, *args)


    def HasNextCurve(self, *args):
        """
        HasNextCurve(IntAna_IntQuadQuad self, Standard_Integer const I) -> Standard_Boolean

        Returns True if the Curve I  shares its last bound
        with another curve.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntQuadQuad_HasNextCurve(self, *args)


    def NextCurve(self, *args):
        """
        NextCurve(IntAna_IntQuadQuad self, Standard_Integer const I) -> Standard_Integer

        If  HasNextCurve(I)  returns True,  this  function
        returns  the  Index J  of the curve  which   has a
        common bound  with the curve   I.  If  theOpposite ==
        True , then the last parameter of the curve I, and
        the last parameter of  the curve J  give  the same
        point. Else the last  parameter of the curve I and
        the first parameter  of  the curve J are  the same
        point.

        :type I: int
        :type theOpposite: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntQuadQuad_NextCurve(self, *args)


    def HasPreviousCurve(self, *args):
        """
        HasPreviousCurve(IntAna_IntQuadQuad self, Standard_Integer const I) -> Standard_Boolean

        Returns True if the Curve I shares its first bound
        with another curve.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntQuadQuad_HasPreviousCurve(self, *args)


    def PreviousCurve(self, *args):
        """
        PreviousCurve(IntAna_IntQuadQuad self, Standard_Integer const I) -> Standard_Integer

        if HasPreviousCurve(I) returns True, this function
        returns the   Index  J of the   curve  which has a
        common  bound with the  curve  I.  If theOpposite  ==
        True  , then the  first parameter of  the curve I,
        and the first parameter of the curve  J  give  the
        same point. Else the first  parameter of the curve
        I and the last  parameter  of the curve J  are the
        same point.

        :type I: int
        :type theOpposite: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntQuadQuad_PreviousCurve(self, *args)

    __swig_destroy__ = _IntAna.delete_IntAna_IntQuadQuad
IntAna_IntQuadQuad_swigregister = _IntAna.IntAna_IntQuadQuad_swigregister
IntAna_IntQuadQuad_swigregister(IntAna_IntQuadQuad)

class IntAna_Quadric(object):
    """
    This class provides a description of Quadrics by their
    Coefficients in natural coordinate system.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_Quadric self) -> IntAna_Quadric
        __init__(IntAna_Quadric self, gp_Pln P) -> IntAna_Quadric
        __init__(IntAna_Quadric self, gp_Sphere Sph) -> IntAna_Quadric
        __init__(IntAna_Quadric self, gp_Cylinder Cyl) -> IntAna_Quadric
        __init__(IntAna_Quadric self, gp_Cone Cone) -> IntAna_Quadric

        Creates a Quadric from a Cone

        :type Cone: OCC.wrapper.gp.gp_Cone

        """
        this = _IntAna.new_IntAna_Quadric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetQuadric(self, *args):
        """
        SetQuadric(IntAna_Quadric self, gp_Pln P)
        SetQuadric(IntAna_Quadric self, gp_Sphere Sph)
        SetQuadric(IntAna_Quadric self, gp_Cone Con)
        SetQuadric(IntAna_Quadric self, gp_Cylinder Cyl)

        Initializes the quadric with a Cylinder

        :type Cyl: OCC.wrapper.gp.gp_Cylinder

        """
        return _IntAna.IntAna_Quadric_SetQuadric(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(IntAna_Quadric self)

        Returns the coefficients of the polynomial equation
        which define the quadric:
        xCXX x**2 + xCYY y**2 + xCZZ z**2
        + 2 ( xCXY x y  + xCXZ x z  + xCYZ y z  )
        + 2 ( xCX x + xCY y + xCZ z )
        + xCCte

        :type xCXX: float
        :type xCYY: float
        :type xCZZ: float
        :type xCXY: float
        :type xCXZ: float
        :type xCYZ: float
        :type xCX: float
        :type xCY: float
        :type xCZ: float
        :type xCCte: float

        """
        return _IntAna.IntAna_Quadric_Coefficients(self, *args)


    def NewCoefficients(self, *args):
        """
        NewCoefficients(IntAna_Quadric self, gp_Ax3 Axis)

        Returns the coefficients of the polynomial equation
        ( written in the natural coordinates system )
        in the local coordinates system defined by Axis

        :type xCXX: float
        :type xCYY: float
        :type xCZZ: float
        :type xCXY: float
        :type xCXZ: float
        :type xCYZ: float
        :type xCX: float
        :type xCY: float
        :type xCZ: float
        :type xCCte: float
        :type Axis: OCC.wrapper.gp.gp_Ax3

        """
        return _IntAna.IntAna_Quadric_NewCoefficients(self, *args)


    def SpecialPoints(self, *args):
        """
        Returns the list of special points (with singularities)

        :rtype: OCC.wrapper.IntAna.NCollection_List_gp_Pnt

        """
        res = _IntAna.IntAna_Quadric_SpecialPoints(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntAna.delete_IntAna_Quadric
IntAna_Quadric_swigregister = _IntAna.IntAna_Quadric_swigregister
IntAna_Quadric_swigregister(IntAna_Quadric)

class NCollection_List_gp_Pnt_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntAna.new_NCollection_List_gp_Pnt_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna.delete_NCollection_List_gp_Pnt_IteratorHelper

    def __next__(self):
        return _IntAna.NCollection_List_gp_Pnt_IteratorHelper___next__(self)
NCollection_List_gp_Pnt_IteratorHelper_swigregister = _IntAna.NCollection_List_gp_Pnt_IteratorHelper_swigregister
NCollection_List_gp_Pnt_IteratorHelper_swigregister(NCollection_List_gp_Pnt_IteratorHelper)

class NCollection_List_IntAna_Curve_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntAna.new_NCollection_List_IntAna_Curve_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntAna.delete_NCollection_List_IntAna_Curve_IteratorHelper

    def __next__(self):
        return _IntAna.NCollection_List_IntAna_Curve_IteratorHelper___next__(self)
NCollection_List_IntAna_Curve_IteratorHelper_swigregister = _IntAna.NCollection_List_IntAna_Curve_IteratorHelper_swigregister
NCollection_List_IntAna_Curve_IteratorHelper_swigregister(NCollection_List_IntAna_Curve_IteratorHelper)


try:
	IntAna_ListOfCurve = NCollection_List_IntAna_Curve
except NameError:
	pass # does not exist, probably ignored

class IntAna_IntConicQuad(object):
    """
    This class provides the analytic intersection between
    a conic defined as an element of gp (Lin,Circ,Elips,
    Parab,Hypr) and a quadric as defined in the class
    Quadric from IntAna.
    The intersection between a conic and a plane is treated
    as a special case.

    The result of the intersection are points (Pnt from
    gp), associated with the parameter on the conic.

    A call to an Intersection  L:Lin from gp and
    SPH: Sphere from gp can be written either :
    IntAna_IntConicQuad Inter(L,IntAna_Quadric(SPH))
    or :
    IntAna_IntConicQuad Inter(L,SPH) (it is necessary
    to include IntAna_Quadric.hxx in this case)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_IntConicQuad self) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Lin L, IntAna_Quadric Q) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Circ C, IntAna_Quadric Q) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Elips E, IntAna_Quadric Q) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Parab P, IntAna_Quadric Q) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Hypr H, IntAna_Quadric Q) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Lin L, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol=0, Standard_Real const Len=0) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Circ C, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Elips E, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Parab Pb, gp_Pln P, Standard_Real const Tolang) -> IntAna_IntConicQuad
        __init__(IntAna_IntConicQuad self, gp_Hypr H, gp_Pln P, Standard_Real const Tolang) -> IntAna_IntConicQuad

        Intersection between an hyperbola and a plane.
        Tolang is used to determine if the angle between two
        vectors is null.

        :type H: OCC.wrapper.gp.gp_Hypr
        :type P: OCC.wrapper.gp.gp_Pln
        :type Tolang: float

        """
        this = _IntAna.new_IntAna_IntConicQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna_IntConicQuad self, gp_Lin L, IntAna_Quadric Q)
        Perform(IntAna_IntConicQuad self, gp_Circ C, IntAna_Quadric Q)
        Perform(IntAna_IntConicQuad self, gp_Elips E, IntAna_Quadric Q)
        Perform(IntAna_IntConicQuad self, gp_Parab P, IntAna_Quadric Q)
        Perform(IntAna_IntConicQuad self, gp_Hypr H, IntAna_Quadric Q)
        Perform(IntAna_IntConicQuad self, gp_Lin L, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol=0, Standard_Real const Len=0)
        Perform(IntAna_IntConicQuad self, gp_Circ C, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol)
        Perform(IntAna_IntConicQuad self, gp_Elips E, gp_Pln P, Standard_Real const Tolang, Standard_Real const Tol)
        Perform(IntAna_IntConicQuad self, gp_Parab Pb, gp_Pln P, Standard_Real const Tolang)
        Perform(IntAna_IntConicQuad self, gp_Hypr H, gp_Pln P, Standard_Real const Tolang)

        Intersects an hyperbola and a plane.
        Tolang is used to determine if the angle between two
        vectors is null.

        :type H: OCC.wrapper.gp.gp_Hypr
        :type P: OCC.wrapper.gp.gp_Pln
        :type Tolang: float

        """
        return _IntAna.IntAna_IntConicQuad_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna_IntConicQuad self) -> Standard_Boolean

        Returns TRUE if the creation completed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntConicQuad_IsDone(self, *args)


    def IsInQuadric(self, *args):
        """
        IsInQuadric(IntAna_IntConicQuad self) -> Standard_Boolean

        Returns TRUE if the conic is in the quadric.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntConicQuad_IsInQuadric(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(IntAna_IntConicQuad self) -> Standard_Boolean

        Returns TRUE if the line is in a quadric which
        is parallel to the quadric.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntConicQuad_IsParallel(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntAna_IntConicQuad self) -> Standard_Integer

        Returns the number of intersection point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntConicQuad_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the point of range N.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntAna.IntAna_IntConicQuad_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnConic(self, *args):
        """
        ParamOnConic(IntAna_IntConicQuad self, Standard_Integer const N) -> Standard_Real

        Returns the parameter on the line of the intersection
        point of range N.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna.IntAna_IntConicQuad_ParamOnConic(self, *args)

    __swig_destroy__ = _IntAna.delete_IntAna_IntConicQuad
IntAna_IntConicQuad_swigregister = _IntAna.IntAna_IntConicQuad_swigregister
IntAna_IntConicQuad_swigregister(IntAna_IntConicQuad)

class IntAna_QuadQuadGeo(object):
    """
    Geometric intersections between two natural quadrics
    (Sphere , Cylinder , Cone , Pln from gp).
    The possible intersections are :
    - 1 point
    - 1 or 2 line(s)
    - 1 Point and 1 Line
    - 1 circle
    - 1 ellipse
    - 1 parabola
    - 1 or 2 hyperbola(s).
    - Empty : there is no intersection between the two quadrics.
    - Same  : the quadrics are identical
    - NoGeometricSolution : there may be an intersection, but it
    is necessary to use an analytic algorithm to determine
    it. See class IntQuadQuad from IntAna.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_QuadQuadGeo self) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Pln P1, gp_Pln P2, Standard_Real const TolAng, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Pln P, gp_Cylinder C, Standard_Real const Tolang, Standard_Real const Tol, Standard_Real const H=0) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Pln P, gp_Sphere S) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Pln P, gp_Cone C, Standard_Real const Tolang, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cylinder Cyl1, gp_Cylinder Cyl2, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Sphere Sph, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Cone Con, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Sphere Sph1, gp_Sphere Sph2, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Sphere Sph, gp_Cone Con, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cone Con1, gp_Cone Con2, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Pln Pln, gp_Torus Tor, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Torus Tor, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Cone Con, gp_Torus Tor, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Sphere Sph, gp_Torus Tor, Standard_Real const Tol) -> IntAna_QuadQuadGeo
        __init__(IntAna_QuadQuadGeo self, gp_Torus Tor1, gp_Torus Tor2, Standard_Real const Tol) -> IntAna_QuadQuadGeo

        Creates the intersection beween two toruses.

        :type Tor1: OCC.wrapper.gp.gp_Torus
        :type Tor2: OCC.wrapper.gp.gp_Torus
        :type Tol: float

        """
        this = _IntAna.new_IntAna_QuadQuadGeo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna_QuadQuadGeo self, gp_Pln P1, gp_Pln P2, Standard_Real const TolAng, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Pln P, gp_Cylinder C, Standard_Real const Tolang, Standard_Real const Tol, Standard_Real const H=0)
        Perform(IntAna_QuadQuadGeo self, gp_Pln P, gp_Sphere S)
        Perform(IntAna_QuadQuadGeo self, gp_Pln P, gp_Cone C, Standard_Real const Tolang, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cylinder Cyl1, gp_Cylinder Cyl2, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Sphere Sph, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Cone Con, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Sphere Sph1, gp_Sphere Sph2, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Sphere Sph, gp_Cone Con, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cone Con1, gp_Cone Con2, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Pln Pln, gp_Torus Tor, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cylinder Cyl, gp_Torus Tor, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Cone Con, gp_Torus Tor, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Sphere Sph, gp_Torus Tor, Standard_Real const Tol)
        Perform(IntAna_QuadQuadGeo self, gp_Torus Tor1, gp_Torus Tor2, Standard_Real const Tol)

        Intersects two toruses.

        :type Tor1: OCC.wrapper.gp.gp_Torus
        :type Tor2: OCC.wrapper.gp.gp_Torus
        :type Tol: float

        """
        return _IntAna.IntAna_QuadQuadGeo_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna_QuadQuadGeo self) -> Standard_Boolean

        Returns Standard_True if the computation was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_QuadQuadGeo_IsDone(self, *args)


    def TypeInter(self, *args):
        """
        TypeInter(IntAna_QuadQuadGeo self) -> IntAna_ResultType

        Returns the type of intersection.

        :rtype: OCC.wrapper.IntAna.IntAna_ResultType

        """
        return _IntAna.IntAna_QuadQuadGeo_TypeInter(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(IntAna_QuadQuadGeo self) -> Standard_Integer

        Returns the number of interesections.
        The possible intersections are :
        - 1 point
        - 1 or 2 line(s)
        - 1 Point and 1 Line
        - 1 circle
        - 1 ellipse
        - 1 parabola
        - 1 or 2 hyperbola(s).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_QuadQuadGeo_NbSolutions(self, *args)


    def Point(self, *args):
        """
        Point(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Pnt

        Returns the point solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntAna.IntAna_QuadQuadGeo_Point(self, *args)


    def Line(self, *args):
        """
        Line(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Lin

        Returns the line solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _IntAna.IntAna_QuadQuadGeo_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Circ

        Returns the circle solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _IntAna.IntAna_QuadQuadGeo_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Elips

        Returns the ellipse solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _IntAna.IntAna_QuadQuadGeo_Ellipse(self, *args)


    def Parabola(self, *args):
        """
        Parabola(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Parab

        Returns the parabola solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _IntAna.IntAna_QuadQuadGeo_Parabola(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(IntAna_QuadQuadGeo self, Standard_Integer const Num) -> gp_Hypr

        Returns the hyperbola solution of range Num.

        :type Num: int
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _IntAna.IntAna_QuadQuadGeo_Hyperbola(self, *args)


    def HasCommonGen(self, *args):
        """
        HasCommonGen(IntAna_QuadQuadGeo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_QuadQuadGeo_HasCommonGen(self, *args)


    def PChar(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntAna.IntAna_QuadQuadGeo_PChar(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntAna.delete_IntAna_QuadQuadGeo
IntAna_QuadQuadGeo_swigregister = _IntAna.IntAna_QuadQuadGeo_swigregister
IntAna_QuadQuadGeo_swigregister(IntAna_QuadQuadGeo)

class IntAna_IntLinTorus(object):
    """Intersection between a line and a torus."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntAna_IntLinTorus self) -> IntAna_IntLinTorus
        __init__(IntAna_IntLinTorus self, gp_Lin L, gp_Torus T) -> IntAna_IntLinTorus

        Creates the intersection between a line and a torus.

        :type L: OCC.wrapper.gp.gp_Lin
        :type T: OCC.wrapper.gp.gp_Torus

        """
        this = _IntAna.new_IntAna_IntLinTorus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntAna_IntLinTorus self, gp_Lin L, gp_Torus T)

        Intersects a line and a torus.

        :type L: OCC.wrapper.gp.gp_Lin
        :type T: OCC.wrapper.gp.gp_Torus

        """
        return _IntAna.IntAna_IntLinTorus_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntAna_IntLinTorus self) -> Standard_Boolean

        Returns True if the computation was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntAna.IntAna_IntLinTorus_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntAna_IntLinTorus self) -> Standard_Integer

        Returns the number of intersection points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntAna.IntAna_IntLinTorus_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the intersection point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntAna.IntAna_IntLinTorus_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnLine(self, *args):
        """
        ParamOnLine(IntAna_IntLinTorus self, Standard_Integer const Index) -> Standard_Real

        Returns the parameter on the line of the intersection
        point of range Index.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntAna.IntAna_IntLinTorus_ParamOnLine(self, *args)


    def ParamOnTorus(self, *args):
        """
        ParamOnTorus(IntAna_IntLinTorus self, Standard_Integer const Index)

        Returns the parameters on the torus of the intersection
        point of range Index.

        :type Index: int
        :type FI: float
        :type THETA: float

        """
        return _IntAna.IntAna_IntLinTorus_ParamOnTorus(self, *args)

    __swig_destroy__ = _IntAna.delete_IntAna_IntLinTorus
IntAna_IntLinTorus_swigregister = _IntAna.IntAna_IntLinTorus_swigregister
IntAna_IntLinTorus_swigregister(IntAna_IntLinTorus)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GC')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GC')
    _GC = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GC', [dirname(__file__)])
        except ImportError:
            import _GC
            return _GC
        try:
            _mod = imp.load_module('_GC', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GC = swig_import_helper()
    del swig_import_helper
else:
    import _GC
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GC.delete_SwigPyIterator

    def value(self):
        return _GC.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GC.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GC.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GC.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GC.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GC.SwigPyIterator_copy(self)

    def next(self):
        return _GC.SwigPyIterator_next(self)

    def __next__(self):
        return _GC.SwigPyIterator___next__(self)

    def previous(self):
        return _GC.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GC.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GC.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GC.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GC.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GC.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GC.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GC.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GC.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GC.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GC.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GC.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GC.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GC.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GC.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GC.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GC.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GC.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GC.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GC.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GC.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GC.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GC.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GC.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GC.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GC.ptr_to_number(item)
ptr_to_number = _GC.ptr_to_number

def HashCode(*args):
    return _GC.HashCode(*args)
HashCode = _GC.HashCode

def ptr_equal(a, b):
    return _GC.ptr_equal(a, b)
ptr_equal = _GC.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gce
else:
    import gce
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class GC_Root(object):
    """
    This class implements the common services for
    all classes of gce which report error.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(GC_Root self) -> Standard_Boolean

        Returns true if the construction is successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GC.GC_Root_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(GC_Root self) -> gce_ErrorType

        Returns the status of the construction:
        -   gce_Done, if the construction is successful, or
        -   another value of the gce_ErrorType enumeration
        indicating why the construction failed.

        :rtype: OCC.wrapper.gce.gce_ErrorType

        """
        return _GC.GC_Root_Status(self, *args)


    def __init__(self):
        """
        This class implements the common services for
        all classes of gce which report error.
        """
        this = _GC.new_GC_Root()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GC.delete_GC_Root
GC_Root_swigregister = _GC.GC_Root_swigregister
GC_Root_swigregister(GC_Root)

class GC_MakeTranslation(object):
    """
    This class implements elementary construction algorithms for a
    translation in 3D space. The result is a
    Geom_Transformation transformation.
    A MakeTranslation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeTranslation self, gp_Vec Vect) -> GC_MakeTranslation
        __init__(GC_MakeTranslation self, gp_Pnt Point1, gp_Pnt Point2) -> GC_MakeTranslation

        Constructs a translation along the vector (Point1,Point2)
        defined from the point Point1 to the point Point2.

        :type Point1: OCC.wrapper.gp.gp_Pnt
        :type Point2: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeTranslation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _GC.GC_MakeTranslation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeTranslation
GC_MakeTranslation_swigregister = _GC.GC_MakeTranslation_swigregister
GC_MakeTranslation_swigregister(GC_MakeTranslation)

class GC_MakeCylindricalSurface(GC_Root):
    """
    This class implements the following algorithms used
    to create a CylindricalSurface from Geom.
    * Create a CylindricalSurface parallel to another and
    passing through a point.
    * Create a CylindricalSurface parallel to another at a
    distance
    <Dist>.
    * Create a CylindricalSurface passing through 3 points.
    * Create a CylindricalSurface by its axis and radius.
    * Create a cylindricalSurface by its circular base.
    The local coordinate system of the CylindricalSurface is defined
    with an axis placement (see class ElementarySurface).

    The "ZAxis" is the symmetry axis of the CylindricalSurface,
    it gives the direction of increasing parametric value V.

    The parametrization range is :
    U [0, 2*PI],  V ]- infinite, + infinite[

    The "XAxis" and the "YAxis" define the placement plane of the
    surface (Z = 0, and parametric value V = 0)  perpendicular to
    the symmetry axis. The "XAxis" defines the origin of the
    parameter U = 0.  The trigonometric sense gives the positive
    orientation for the parameter U.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeCylindricalSurface self, gp_Ax2 A2, Standard_Real const Radius) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Cylinder C) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Cylinder Cyl, gp_Pnt Point) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Cylinder Cyl, Standard_Real const Dist) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Ax1 Axis, Standard_Real const Radius) -> GC_MakeCylindricalSurface
        __init__(GC_MakeCylindricalSurface self, gp_Circ Circ) -> GC_MakeCylindricalSurface

        Make a CylindricalSurface by its circular base.

        :type Circ: OCC.wrapper.gp.gp_Circ

        """
        this = _GC.new_GC_MakeCylindricalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed cylinder.
        Exceptions StdFail_NotDone if no cylinder is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_CylindricalSurface

        """
        res = _GC.GC_MakeCylindricalSurface_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeCylindricalSurface
GC_MakeCylindricalSurface_swigregister = _GC.GC_MakeCylindricalSurface_swigregister
GC_MakeCylindricalSurface_swigregister(GC_MakeCylindricalSurface)

class GC_MakeArcOfEllipse(GC_Root):
    """
    Implements construction algorithms for an arc
    of ellipse in 3D space. The result is a Geom_TrimmedCurve curve.
    A MakeArcOfEllipse object provides a framework for:
    -   defining the construction of the arc of ellipse,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the
    Value function returns the constructed arc of ellipse.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeArcOfEllipse self, gp_Elips Elips, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GC_MakeArcOfEllipse
        __init__(GC_MakeArcOfEllipse self, gp_Elips Elips, gp_Pnt P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GC_MakeArcOfEllipse
        __init__(GC_MakeArcOfEllipse self, gp_Elips Elips, gp_Pnt P1, gp_Pnt P2, Standard_Boolean const Sense) -> GC_MakeArcOfEllipse

        Constructs an arc of Ellipse (TrimmedCurve from Geom) from
        a Ellipse between two points P1 and P2.
        The orientation of the arc of ellipse is:
        -   the sense of Elips if Sense is true, or
        -   the opposite sense if Sense is false.
        Notes:
        -   Alpha1, Alpha2 and Alpha are angle values, given in radians.
        -   IsDone always returns true.

        :type Elips: OCC.wrapper.gp.gp_Elips
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type Sense: bool

        """
        this = _GC.new_GC_MakeArcOfEllipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of ellipse.

        :rtype: OCC.wrapper.Geom.Handle_Geom_TrimmedCurve

        """
        res = _GC.GC_MakeArcOfEllipse_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeArcOfEllipse
GC_MakeArcOfEllipse_swigregister = _GC.GC_MakeArcOfEllipse_swigregister
GC_MakeArcOfEllipse_swigregister(GC_MakeArcOfEllipse)

class GC_MakeConicalSurface(GC_Root):
    """
    This class implements the following algorithms used
    to create a ConicalSurface from Geom.
    * Create a ConicalSurface parallel to another and passing
    through a point.
    * Create a ConicalSurface parallel to another at a distance
    <Dist>.
    * Create a ConicalSurface by 4 points.
    * Create a ConicalSurface by its axis and 2 points.
    * Create a ConicalSurface by 2 points and 2 radius.
    The local coordinate system of the ConicalSurface is defined
    with an axis placement (see class ElementarySurface).

    The "ZAxis" is the symmetry axis of the ConicalSurface,
    it gives the direction of increasing parametric value V.
    The apex of the surface is on the negative side of this axis.

    The parametrization range is  :
    U [0, 2*PI],  V ]-infinite, + infinite[

    The "XAxis" and the "YAxis" define the placement plane of the
    surface (Z = 0, and parametric value V = 0)  perpendicular to
    the symmetry axis. The "XAxis" defines the origin of the
    parameter U = 0.  The trigonometric sense gives the positive
    orientation for the parameter U.

    When you create a ConicalSurface the U and V directions of
    parametrization are such that at each point of the surface the
    normal is oriented towards the "outside region".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeConicalSurface self, gp_Ax2 A2, Standard_Real const Ang, Standard_Real const Radius) -> GC_MakeConicalSurface
        __init__(GC_MakeConicalSurface self, gp_Cone C) -> GC_MakeConicalSurface
        __init__(GC_MakeConicalSurface self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt P4) -> GC_MakeConicalSurface
        __init__(GC_MakeConicalSurface self, gp_Pnt P1, gp_Pnt P2, Standard_Real const R1, Standard_Real const R2) -> GC_MakeConicalSurface

        Make a ConicalSurface with two points and two radius.
        The axis of the solution is the line passing through
        <P1> and <P2>.
        <R1> is the radius of the section passing through <P1>
        and <R2> the radius of the section passing through <P2>.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type R1: float
        :type R2: float

        """
        this = _GC.new_GC_MakeConicalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed cone.
        Exceptions
        StdFail_NotDone if no cone is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_ConicalSurface

        """
        res = _GC.GC_MakeConicalSurface_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeConicalSurface
GC_MakeConicalSurface_swigregister = _GC.GC_MakeConicalSurface_swigregister
GC_MakeConicalSurface_swigregister(GC_MakeConicalSurface)

class GC_MakeArcOfCircle(GC_Root):
    """
    Implements construction algorithms for an
    arc of circle in 3D space. The result is a Geom_TrimmedCurve curve.
    A MakeArcOfCircle object provides a framework for:
    -   defining the construction of the arc of circle,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the
    Value function returns the constructed arc of circle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeArcOfCircle self, gp_Circ Circ, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GC_MakeArcOfCircle
        __init__(GC_MakeArcOfCircle self, gp_Circ Circ, gp_Pnt P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GC_MakeArcOfCircle
        __init__(GC_MakeArcOfCircle self, gp_Circ Circ, gp_Pnt P1, gp_Pnt P2, Standard_Boolean const Sense) -> GC_MakeArcOfCircle
        __init__(GC_MakeArcOfCircle self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> GC_MakeArcOfCircle
        __init__(GC_MakeArcOfCircle self, gp_Pnt P1, gp_Vec V, gp_Pnt P2) -> GC_MakeArcOfCircle

        Make an arc of circle (TrimmedCurve from Geom) from
        two points P1,P2 and the tangente to the solution at
        the point P1.
        The orientation of the arc is:
        -   the sense determined by the order of the points P1, P3 and P2;
        -   the sense defined by the vector V; or
        -   for other syntaxes:
        -   the sense of Circ if Sense is true, or
        -   the opposite sense if Sense is false.
        Note: Alpha1, Alpha2 and Alpha are angle values, given in radians.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_ConfusedPoints if:
        -   any 2 of the 3 points P1, P2 and P3 are coincident, or
        -   P1 and P2 are coincident; or
        -   gce_IntersectionError if:
        -   P1, P2 and P3 are collinear and not coincident, or
        -   the vector defined by the points P1 and
        P2 is collinear with the vector V.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeArcOfCircle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of circle.
        Exceptions StdFail_NotDone if no arc of circle is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_TrimmedCurve

        """
        res = _GC.GC_MakeArcOfCircle_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeArcOfCircle
GC_MakeArcOfCircle_swigregister = _GC.GC_MakeArcOfCircle_swigregister
GC_MakeArcOfCircle_swigregister(GC_MakeArcOfCircle)

class GC_MakeScale(object):
    """
    This class implements an elementary construction algorithm for
    a scaling transformation in 3D space. The result is a
    Geom_Transformation transformation (a scaling transformation with
    the center point <Point> and the scaling value <Scale>).
    A MakeScale object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeScale self, gp_Pnt Point, Standard_Real const Scale) -> GC_MakeScale

        Constructs a scaling transformation with
        -   Point as the center of the transformation, and
        -   Scale as the scale factor.

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Scale: float

        """
        this = _GC.new_GC_MakeScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _GC.GC_MakeScale_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeScale
GC_MakeScale_swigregister = _GC.GC_MakeScale_swigregister
GC_MakeScale_swigregister(GC_MakeScale)

class GC_MakePlane(GC_Root):
    """
    This class implements the following algorithms used
    to create a Plane from gp.
    * Create a Plane parallel to another and passing
    through a point.
    * Create a Plane passing through 3 points.
    * Create a Plane by its normal
    A MakePlane object provides a framework for:
    -   defining the construction of the plane,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed plane.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakePlane self, gp_Pln Pl) -> GC_MakePlane
        __init__(GC_MakePlane self, gp_Pnt P, gp_Dir V) -> GC_MakePlane
        __init__(GC_MakePlane self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D) -> GC_MakePlane
        __init__(GC_MakePlane self, gp_Pln Pln, gp_Pnt Point) -> GC_MakePlane
        __init__(GC_MakePlane self, gp_Pln Pln, Standard_Real const Dist) -> GC_MakePlane
        __init__(GC_MakePlane self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> GC_MakePlane
        __init__(GC_MakePlane self, gp_Ax1 Axis) -> GC_MakePlane

        Make a Plane  passing through the location of <Axis>and
        normal to the Direction of <Axis>.

        :type Axis: OCC.wrapper.gp.gp_Ax1

        """
        this = _GC.new_GC_MakePlane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed plane.
        Exceptions StdFail_NotDone if no plane is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _GC.GC_MakePlane_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakePlane
GC_MakePlane_swigregister = _GC.GC_MakePlane_swigregister
GC_MakePlane_swigregister(GC_MakePlane)

class GC_MakeTrimmedCone(GC_Root):
    """
    Implements construction algorithms for a trimmed
    cone limited by two planes orthogonal to its axis. The
    result is a Geom_RectangularTrimmedSurface surface.
    A MakeTrimmedCone provides a framework for:
    -   defining the construction of the trimmed cone,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed trimmed cone.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeTrimmedCone self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt P4) -> GC_MakeTrimmedCone
        __init__(GC_MakeTrimmedCone self, gp_Pnt P1, gp_Pnt P2, Standard_Real const R1, Standard_Real const R2) -> GC_MakeTrimmedCone

        Make a RectangularTrimmedSurface from Geom <TheCone>
        from a cone and trimmed by two points P1 and P2 and
        the two radius <R1> and <R2> of the sections passing
        through <P1> an <P2>.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_ConfusedPoints if points P1 and P2, or P3 and P4, are coincident;
        -   gce_NullAngle if:
        -   the lines joining P1 to P2 and P3 to P4 are parallel, or
        -   R1 and R2 are equal (i.e. their difference is less than gp::Resolution());
        -   gce_NullRadius if:
        -   the line joining P1 to P2 is perpendicular to the line joining P3 to P4, or
        -   the points P1, P2, P3 and P4 are collinear;
        -   gce_NegativeRadius if R1 or R2 is negative; or
        -   gce_NullAxis if points P1 and P2 are coincident (2nd syntax only).

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type R1: float
        :type R2: float

        """
        this = _GC.new_GC_MakeTrimmedCone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed trimmed cone.
        StdFail_NotDone if no trimmed cone is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_RectangularTrimmedSurface

        """
        res = _GC.GC_MakeTrimmedCone_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeTrimmedCone
GC_MakeTrimmedCone_swigregister = _GC.GC_MakeTrimmedCone_swigregister
GC_MakeTrimmedCone_swigregister(GC_MakeTrimmedCone)

class GC_MakeArcOfParabola(GC_Root):
    """
    Implements construction algorithms for an arc
    of parabola in 3D space. The result is a Geom_TrimmedCurve curve.
    A MakeArcOfParabola object provides a framework for:
    -   defining the construction of the arc of parabola,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the
    Value function returns the constructed arc of parabola.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeArcOfParabola self, gp_Parab Parab, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GC_MakeArcOfParabola
        __init__(GC_MakeArcOfParabola self, gp_Parab Parab, gp_Pnt P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GC_MakeArcOfParabola
        __init__(GC_MakeArcOfParabola self, gp_Parab Parab, gp_Pnt P1, gp_Pnt P2, Standard_Boolean const Sense) -> GC_MakeArcOfParabola

        Creates an arc of Parabola (TrimmedCurve from Geom) from
        a Parabola between two points P1 and P2.

        :type Parab: OCC.wrapper.gp.gp_Parab
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type Sense: bool

        """
        this = _GC.new_GC_MakeArcOfParabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of parabola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_TrimmedCurve

        """
        res = _GC.GC_MakeArcOfParabola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeArcOfParabola
GC_MakeArcOfParabola_swigregister = _GC.GC_MakeArcOfParabola_swigregister
GC_MakeArcOfParabola_swigregister(GC_MakeArcOfParabola)

class GC_MakeHyperbola(GC_Root):
    """
    This class implements construction algorithms for a hyperbola in
    3D space. The result is a Geom_Hyperbola hyperbola.
    A MakeHyperbola object provides a framework for:
    -   defining the construction of the hyperbola,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed hyperbola.
    To define the main branch of an hyperbola.
    The parameterization range is ]-infinite,+infinite[
    It is possible to get the other branch and the two conjugate
    branches of the main branch.

    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    SecondConjugateBranch
    |

    The major radius is the distance between the Location point
    of the hyperbola C and the apex of the Main Branch (or the
    Other branch). The major axis is the XAxis.
    The minor radius is the distance between the Location point
    of the hyperbola C and the apex of the First (or Second)
    Conjugate branch. The minor axis is the YAxis.
    The major radius can be lower than the minor radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeHyperbola self, gp_Hypr H) -> GC_MakeHyperbola
        __init__(GC_MakeHyperbola self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> GC_MakeHyperbola
        __init__(GC_MakeHyperbola self, gp_Pnt S1, gp_Pnt S2, gp_Pnt Center) -> GC_MakeHyperbola

        Constructs a hyperbola centered on the point Center, where
        -   the plane of the hyperbola is defined by Center, S1 and S2,
        -   its major axis is defined by Center and S1,
        -   its major radius is the distance between Center and S1, and
        -   its minor radius is the distance between S2 and the major axis;

        :type S1: OCC.wrapper.gp.gp_Pnt
        :type S2: OCC.wrapper.gp.gp_Pnt
        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeHyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed hyperbola.
        Exceptions StdFail_NotDone if no hyperbola is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Hyperbola

        """
        res = _GC.GC_MakeHyperbola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeHyperbola
GC_MakeHyperbola_swigregister = _GC.GC_MakeHyperbola_swigregister
GC_MakeHyperbola_swigregister(GC_MakeHyperbola)

class GC_MakeEllipse(GC_Root):
    """
    This class implements construction algorithms for an ellipse in
    3D space. The result is a Geom_Ellipse ellipse.
    A MakeEllipse object provides a framework for:
    -   defining the construction of the ellipse,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed ellipse.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeEllipse self, gp_Elips E) -> GC_MakeEllipse
        __init__(GC_MakeEllipse self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> GC_MakeEllipse
        __init__(GC_MakeEllipse self, gp_Pnt S1, gp_Pnt S2, gp_Pnt Center) -> GC_MakeEllipse

        Constructs an ellipse centered on the point Center, where
        -   the plane of the ellipse is defined by Center, S1 and S2,
        -   its major axis is defined by Center and S1,
        -   its major radius is the distance between Center and S1, and
        -   its minor radius is the distance between S2 and the major axis.

        :type S1: OCC.wrapper.gp.gp_Pnt
        :type S2: OCC.wrapper.gp.gp_Pnt
        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeEllipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed ellipse.
        Exceptions StdFail_NotDone if no ellipse is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Ellipse

        """
        res = _GC.GC_MakeEllipse_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeEllipse
GC_MakeEllipse_swigregister = _GC.GC_MakeEllipse_swigregister
GC_MakeEllipse_swigregister(GC_MakeEllipse)

class GC_MakeCircle(GC_Root):
    """
    This class implements the following algorithms used
    to create Cirlec from Geom.

    * Create a Circle parallel to another and passing
    though a point.
    * Create a Circle parallel to another at the distance
    Dist.
    * Create a Circle passing through 3 points.
    * Create a Circle with its center and the normal of its
    plane and its radius.
    * Create a Circle with its axis and radius.
    The circle's parameter is the angle (Radian).
    The parametrization range is [0,2*PI].
    The circle is a closed and periodic curve.
    The center of the circle is the Location point of its axis
    placement. The XDirection of the axis placement defines the
    origin of the parametrization.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeCircle self, gp_Circ C) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Ax2 A2, Standard_Real const Radius) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Circ Circ, Standard_Real const Dist) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Circ Circ, gp_Pnt Point) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Pnt Center, gp_Dir Norm, Standard_Real const Radius) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Pnt Center, gp_Pnt PtAxis, Standard_Real const Radius) -> GC_MakeCircle
        __init__(GC_MakeCircle self, gp_Ax1 Axis, Standard_Real const Radius) -> GC_MakeCircle

        Make a Circle from Geom <TheCirc> with its center
        <Center> and its radius <Radius>.

        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Radius: float

        """
        this = _GC.new_GC_MakeCircle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed circle.
        Exceptions
        StdFail_NotDone if no circle is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Circle

        """
        res = _GC.GC_MakeCircle_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeCircle
GC_MakeCircle_swigregister = _GC.GC_MakeCircle_swigregister
GC_MakeCircle_swigregister(GC_MakeCircle)

class GC_MakeArcOfHyperbola(GC_Root):
    """
    Implements construction algorithms for an arc
    of hyperbola in 3D space. The result is a Geom_TrimmedCurve curve.
    A MakeArcOfHyperbola object provides a framework for:
    -   defining the construction of the arc of hyperbola,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the
    Value function returns the constructed arc of hyperbola.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeArcOfHyperbola self, gp_Hypr Hypr, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GC_MakeArcOfHyperbola
        __init__(GC_MakeArcOfHyperbola self, gp_Hypr Hypr, gp_Pnt P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GC_MakeArcOfHyperbola
        __init__(GC_MakeArcOfHyperbola self, gp_Hypr Hypr, gp_Pnt P1, gp_Pnt P2, Standard_Boolean const Sense) -> GC_MakeArcOfHyperbola

        Creates an arc of Hyperbola (TrimmedCurve from Geom) from
        a Hyperbola between two points P1 and P2.
        The orientation of the arc of hyperbola is:
        -   the sense of Hypr if Sense is true, or
        -   the opposite sense if Sense is false.

        :type Hypr: OCC.wrapper.gp.gp_Hypr
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type Sense: bool

        """
        this = _GC.new_GC_MakeArcOfHyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of hyperbola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_TrimmedCurve

        """
        res = _GC.GC_MakeArcOfHyperbola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeArcOfHyperbola
GC_MakeArcOfHyperbola_swigregister = _GC.GC_MakeArcOfHyperbola_swigregister
GC_MakeArcOfHyperbola_swigregister(GC_MakeArcOfHyperbola)

class GC_MakeRotation(object):
    """
    This class implements elementary construction algorithms for a
    rotation in 3D space. The result is a
    Geom_Transformation transformation.
    A MakeRotation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeRotation self, gp_Lin Line, Standard_Real const Angle) -> GC_MakeRotation
        __init__(GC_MakeRotation self, gp_Ax1 Axis, Standard_Real const Angle) -> GC_MakeRotation
        __init__(GC_MakeRotation self, gp_Pnt Point, gp_Dir Direc, Standard_Real const Angle) -> GC_MakeRotation

        Constructs a rotation through angle Angle about the axis
        defined by the point Point and the unit vector Direc.

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Direc: OCC.wrapper.gp.gp_Dir
        :type Angle: float

        """
        this = _GC.new_GC_MakeRotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _GC.GC_MakeRotation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeRotation
GC_MakeRotation_swigregister = _GC.GC_MakeRotation_swigregister
GC_MakeRotation_swigregister(GC_MakeRotation)

class GC_MakeMirror(object):
    """
    This class implements elementary construction algorithms for a
    symmetrical transformation in 3D space about a point,
    axis or plane. The result is a Geom_Transformation transformation.
    A MakeMirror object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeMirror self, gp_Pnt Point) -> GC_MakeMirror
        __init__(GC_MakeMirror self, gp_Ax1 Axis) -> GC_MakeMirror
        __init__(GC_MakeMirror self, gp_Lin Line) -> GC_MakeMirror
        __init__(GC_MakeMirror self, gp_Pnt Point, gp_Dir Direc) -> GC_MakeMirror
        __init__(GC_MakeMirror self, gp_Pln Plane) -> GC_MakeMirror
        __init__(GC_MakeMirror self, gp_Ax2 Plane) -> GC_MakeMirror

        Make a symetry transformation of plane <Plane>.

        :type Plane: OCC.wrapper.gp.gp_Ax2

        """
        this = _GC.new_GC_MakeMirror(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _GC.GC_MakeMirror_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeMirror
GC_MakeMirror_swigregister = _GC.GC_MakeMirror_swigregister
GC_MakeMirror_swigregister(GC_MakeMirror)

class GC_MakeSegment(GC_Root):
    """
    Implements construction algorithms for a line
    segment in 3D space.
    Makes a segment of Line from the 2 points <P1> and <P2>.
    The result is a Geom_TrimmedCurve curve.
    A MakeSegment object provides a framework for:
    -   defining the construction of the line segment,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed line segment.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeSegment self, gp_Pnt P1, gp_Pnt P2) -> GC_MakeSegment
        __init__(GC_MakeSegment self, gp_Lin Line, Standard_Real const U1, Standard_Real const U2) -> GC_MakeSegment
        __init__(GC_MakeSegment self, gp_Lin Line, gp_Pnt Point, Standard_Real const Ulast) -> GC_MakeSegment
        __init__(GC_MakeSegment self, gp_Lin Line, gp_Pnt P1, gp_Pnt P2) -> GC_MakeSegment

        Make a segment of Line from the line <Line1>
        between the two points <P1> and <P2>.
        It returns NullObject if <U1> is equal <U2>.

        :type Line: OCC.wrapper.gp.gp_Lin
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed line segment.

        :rtype: OCC.wrapper.Geom.Handle_Geom_TrimmedCurve

        """
        res = _GC.GC_MakeSegment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeSegment
GC_MakeSegment_swigregister = _GC.GC_MakeSegment_swigregister
GC_MakeSegment_swigregister(GC_MakeSegment)

class GC_MakeTrimmedCylinder(GC_Root):
    """
    Implements construction algorithms for a trimmed
    cylinder limited by two planes orthogonal to its axis.
    The result is a Geom_RectangularTrimmedSurface surface.
    A MakeTrimmedCylinder provides a framework for:
    -   defining the construction of the trimmed cylinder,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed trimmed cylinder.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeTrimmedCylinder self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> GC_MakeTrimmedCylinder
        __init__(GC_MakeTrimmedCylinder self, gp_Circ Circ, Standard_Real const Height) -> GC_MakeTrimmedCylinder
        __init__(GC_MakeTrimmedCylinder self, gp_Ax1 A1, Standard_Real const Radius, Standard_Real const Height) -> GC_MakeTrimmedCylinder

        Make a cylindricalSurface <Cyl> from gp by its
        axis <A1> and its radius <Radius>.
        It returns NullObject if <Radius> is lower than zero.
        <Height> can be greater than zero or lower than zero.
        In the first case the V parametric direction of the
        result has the same orientation as <A1>.
        In the other case it has the opposite orientation.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Radius: float
        :type Height: float

        """
        this = _GC.new_GC_MakeTrimmedCylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed trimmed cylinder.
        Exceptions
        StdFail_NotDone if no trimmed cylinder is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_RectangularTrimmedSurface

        """
        res = _GC.GC_MakeTrimmedCylinder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeTrimmedCylinder
GC_MakeTrimmedCylinder_swigregister = _GC.GC_MakeTrimmedCylinder_swigregister
GC_MakeTrimmedCylinder_swigregister(GC_MakeTrimmedCylinder)

class GC_MakeLine(GC_Root):
    """
    This class implements the following algorithms used
    to create a Line from Geom.
    * Create a Line parallel to another and passing
    through a point.
    * Create a Line passing through 2 points.
    A MakeLine object provides a framework for:
    -   defining the construction of the line,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed line.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GC_MakeLine self, gp_Ax1 A1) -> GC_MakeLine
        __init__(GC_MakeLine self, gp_Lin L) -> GC_MakeLine
        __init__(GC_MakeLine self, gp_Pnt P, gp_Dir V) -> GC_MakeLine
        __init__(GC_MakeLine self, gp_Lin Lin, gp_Pnt Point) -> GC_MakeLine
        __init__(GC_MakeLine self, gp_Pnt P1, gp_Pnt P2) -> GC_MakeLine

        Make a Line from Geom <TheLin> passing through 2
        Pnt <P1>,<P2>.
        It returns false if <p1> and <P2> are confused.
        Warning
        If the points P1 and P2 are coincident (that is, when
        IsDone returns false), the Status function returns gce_ConfusedPoints.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _GC.new_GC_MakeLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed line.
        Exceptions StdFail_NotDone if no line is constructed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Line

        """
        res = _GC.GC_MakeLine_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GC.delete_GC_MakeLine
GC_MakeLine_swigregister = _GC.GC_MakeLine_swigregister
GC_MakeLine_swigregister(GC_MakeLine)




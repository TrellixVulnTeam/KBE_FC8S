# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Bisector')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Bisector')
    _Bisector = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Bisector', [dirname(__file__)])
        except ImportError:
            import _Bisector
            return _Bisector
        try:
            _mod = imp.load_module('_Bisector', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Bisector = swig_import_helper()
    del swig_import_helper
else:
    import _Bisector
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Bisector.delete_SwigPyIterator

    def value(self):
        return _Bisector.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Bisector.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Bisector.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Bisector.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Bisector.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Bisector.SwigPyIterator_copy(self)

    def next(self):
        return _Bisector.SwigPyIterator_next(self)

    def __next__(self):
        return _Bisector.SwigPyIterator___next__(self)

    def previous(self):
        return _Bisector.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Bisector.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Bisector.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Bisector.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Bisector.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Bisector.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Bisector.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Bisector.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Bisector.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Bisector.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Bisector.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Bisector.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Bisector.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bisector.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Bisector.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Bisector.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Bisector.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Bisector.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Bisector.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Bisector.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Bisector.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bisector.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Bisector.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Bisector.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Bisector.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Bisector.ptr_to_number(item)
ptr_to_number = _Bisector.ptr_to_number

def HashCode(*args):
    return _Bisector.HashCode(*args)
HashCode = _Bisector.HashCode

def ptr_equal(a, b):
    return _Bisector.ptr_equal(a, b)
ptr_equal = _Bisector.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class Bisector_Curve(Geom2d.Geom2d_Curve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bisector_Curve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bisector_Curve(self) 
            return h


    def Parameter(self, *args):
        """
        Parameter(Bisector_Curve self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_Curve_Parameter(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Bisector_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_Curve_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Bisector_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_Curve_IsExtendAtEnd(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Bisector_Curve self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Bisector_Curve_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Bisector_Curve self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_Curve_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Bisector_Curve self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_Curve_IntervalLast(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bisector.Bisector_Curve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bisector.Bisector_Curve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Bisector_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bisector.delete_Bisector_Curve
Bisector_Curve_swigregister = _Bisector.Bisector_Curve_swigregister
Bisector_Curve_swigregister(Bisector_Curve)

def Bisector_Curve_get_type_name(*args):
    """
    Bisector_Curve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bisector.Bisector_Curve_get_type_name(*args)

def Bisector_Curve_get_type_descriptor(*args):
    """
    Bisector_Curve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bisector.Bisector_Curve_get_type_descriptor(*args)

class Bisector_BisecPC(Bisector_Curve):
    """
    Provides the bisector between a point and a curve.
    the curvature on the curve has to be monoton.
    the point can't be on the curve exept at the extremitys.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bisector_BisecPC
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bisector_BisecPC(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bisector_BisecPC self) -> Bisector_BisecPC
        __init__(Bisector_BisecPC self, Handle_Geom2d_Curve Cu, gp_Pnt2d P, Standard_Real const Side, Standard_Real const DistMax=500) -> Bisector_BisecPC
        __init__(Bisector_BisecPC self, Handle_Geom2d_Curve Cu, gp_Pnt2d P, Standard_Real const Side, Standard_Real const UMin, Standard_Real const UMax) -> Bisector_BisecPC

        Constructs the bisector between the point <P> and
        the curve <Cu> Trimmed by <UMin> and <UMax>
        <Side> = 1. if the bisector curve is on the Left of <Cu>
        else <Side> = -1.
        Warning: the bisector is supposed all over defined between
        <UMin> and <UMax>.

        :type Cu: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Side: float
        :type UMin: float
        :type UMax: float

        """
        this = _Bisector.new_Bisector_BisecPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(Bisector_BisecPC self, Handle_Geom2d_Curve Cu, gp_Pnt2d P, Standard_Real const Side, Standard_Real const DistMax=500)

        Construct the bisector between the point <P> and
        the curve <Cu>.
        <Side> = 1. if the bisector curve is on the Left of <Cu>
        else <Side> = -1.
        <DistMax> is used to trim the bisector.The distance
        between the points of the bisector and <Cu> is smaller
        than <DistMax>.

        :type Cu: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Side: float
        :type DistMax: float

        """
        return _Bisector.Bisector_BisecPC_Perform(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Bisector_BisecPC self) -> Standard_Boolean

        Returns True if the bisector is extended at start.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Bisector_BisecPC self) -> Standard_Boolean

        Returns True if the bisector is extended at end.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsExtendAtEnd(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Bisector_BisecPC self)

        Changes the direction of parametrization of <me>.
        The orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Bisector_BisecPC_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_ReversedParameter(self, *args)


    def Copy(self, *args):
        """
        Copy(Bisector_BisecPC self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Bisector_BisecPC_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Bisector_BisecPC self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Bisector_BisecPC_Transform(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Bisector_BisecPC self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsCN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Bisector_BisecPC self) -> Standard_Real

        Value of the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Bisector_BisecPC self) -> Standard_Real

        Value of the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Bisector_BisecPC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Bisector_BisecPC_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Bisector_BisecPC self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Bisector_BisecPC_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Bisector_BisecPC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Bisector_BisecPC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_IntervalLast(self, *args)


    def IntervalContinuity(self, *args):
        """
        IntervalContinuity(Bisector_BisecPC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Bisector_BisecPC_IntervalContinuity(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Bisector_BisecPC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Bisector_BisecPC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsPeriodic(self, *args)


    def Distance(self, *args):
        """
        Distance(Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns   the   distance   between  the  point  of
        parameter U on <me> and my point or my curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_Distance(self, *args)


    def D0(self, *args):
        """
        D0(Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_BisecPC_D0(self, *args)


    def D1(self, *args):
        """
        D1(Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecPC_D1(self, *args)


    def D2(self, *args):
        """
        D2(Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecPC_D2(self, *args)


    def D3(self, *args):
        """
        D3(Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecPC_D3(self, *args)


    def DN(self, *args):
        """
        DN(Bisector_BisecPC self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecPC_DN(self, *args)


    def Dump(self, *args):
        """
        Dump(Bisector_BisecPC self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Bisector_BisecPC_Dump(self, *args)


    def LinkBisCurve(self, *args):
        """
        LinkBisCurve(Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the parameter on the curve1 of the projection
        of the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_LinkBisCurve(self, *args)


    def LinkCurveBis(self, *args):
        """
        LinkCurveBis(Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the reciproque of LinkBisCurve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_LinkCurveBis(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Bisector_BisecPC self, gp_Pnt2d P) -> Standard_Real

        Returns the parameter on <me> corresponding to <P>.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecPC_Parameter(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Bisector_BisecPC self) -> Standard_Boolean

        Returns <True> if the bisector is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecPC_IsEmpty(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bisector.Bisector_BisecPC_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bisector.Bisector_BisecPC_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Bisector_BisecPC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bisector.delete_Bisector_BisecPC
Bisector_BisecPC_swigregister = _Bisector.Bisector_BisecPC_swigregister
Bisector_BisecPC_swigregister(Bisector_BisecPC)

def Bisector_BisecPC_get_type_name(*args):
    """
    Bisector_BisecPC_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bisector.Bisector_BisecPC_get_type_name(*args)

def Bisector_BisecPC_get_type_descriptor(*args):
    """
    Bisector_BisecPC_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bisector.Bisector_BisecPC_get_type_descriptor(*args)

class Bisector_BisecAna(Bisector_Curve):
    """
    This class provides the bisecting line between two
    geometric elements.The elements are Circles,Lines or
    Points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bisector_BisecAna
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bisector_BisecAna(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bisector_BisecAna self) -> Bisector_BisecAna

        This class provides the bisecting line between two
        geometric elements.The elements are Circles,Lines or
        Points.
        """
        this = _Bisector.new_Bisector_BisecAna(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(Bisector_BisecAna self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, GeomAbs_JoinType const jointype, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_BisecAna self, Handle_Geom2d_Curve Cu, Handle_Geom2d_Point Pnt, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_BisecAna self, Handle_Geom2d_Point Pnt, Handle_Geom2d_Curve Cu, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_BisecAna self, Handle_Geom2d_Point Pnt1, Handle_Geom2d_Point Pnt2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance=0.0, Standard_Boolean const oncurve)

        Performs  the bisecting line  between the two points
        <Pnt1>  and <Pnt2>.

        :type Pnt1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Pnt2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type Sense: float
        :type Tolerance: float
        :type oncurve: bool

        """
        return _Bisector.Bisector_BisecAna_Perform(self, *args)


    def Init(self, *args):
        """
        Init(Bisector_BisecAna self, Handle_Geom2d_TrimmedCurve bisector)

        :type bisector: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        return _Bisector.Bisector_BisecAna_Init(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecAna_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecAna_IsExtendAtEnd(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Bisector_BisecAna self, Handle_Geom2d_Curve Cu)
        SetTrim(Bisector_BisecAna self, Standard_Real const uf, Standard_Real const ul)

        Trim <me> by a domain defined by uf  and  ul

        :type uf: float
        :type ul: float

        """
        return _Bisector.Bisector_BisecAna_SetTrim(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Bisector_BisecAna self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Bisector_BisecAna_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Bisector_BisecAna self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_ReversedParameter(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Bisector_BisecAna self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecAna_IsCN(self, *args)


    def Copy(self, *args):
        """
        Copy(Bisector_BisecAna self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Bisector_BisecAna_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Bisector_BisecAna self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Bisector_BisecAna_Transform(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecAna_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecAna_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Bisector_BisecAna self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Bisector_BisecAna_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_BisecAna_D0(self, *args)


    def D1(self, *args):
        """
        D1(Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecAna_D1(self, *args)


    def D2(self, *args):
        """
        D2(Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecAna_D2(self, *args)


    def D3(self, *args):
        """
        D3(Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecAna_D3(self, *args)


    def DN(self, *args):
        """
        DN(Bisector_BisecAna self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecAna_DN(self, *args)


    def Geom2dCurve(self, *args):
        """
        Geom2dCurve(Bisector_BisecAna self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Bisector_BisecAna_Geom2dCurve(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Bisector_BisecAna self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_Parameter(self, *args)


    def ParameterOfStartPoint(self, *args):
        """
        ParameterOfStartPoint(Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_ParameterOfStartPoint(self, *args)


    def ParameterOfEndPoint(self, *args):
        """
        ParameterOfEndPoint(Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_ParameterOfEndPoint(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Bisector_BisecAna self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Bisector_BisecAna_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Bisector_BisecAna self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Bisector_BisecAna self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecAna_IntervalLast(self, *args)


    def Dump(self, *args):
        """
        Dump(Bisector_BisecAna self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Bisector_BisecAna_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bisector.Bisector_BisecAna_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bisector.Bisector_BisecAna_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Bisector_BisecAna_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bisector.delete_Bisector_BisecAna
Bisector_BisecAna_swigregister = _Bisector.Bisector_BisecAna_swigregister
Bisector_BisecAna_swigregister(Bisector_BisecAna)

def Bisector_BisecAna_get_type_name(*args):
    """
    Bisector_BisecAna_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bisector.Bisector_BisecAna_get_type_name(*args)

def Bisector_BisecAna_get_type_descriptor(*args):
    """
    Bisector_BisecAna_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bisector.Bisector_BisecAna_get_type_descriptor(*args)

class Handle_Bisector_BisecAna(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bisector_BisecAna self)

        Nullify the handle


        """
        return _Bisector.Handle_Bisector_BisecAna_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bisector_BisecAna self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bisector.Handle_Bisector_BisecAna_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bisector_BisecAna self, Bisector_BisecAna thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bisector.Handle_Bisector_BisecAna_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bisector_BisecAna self, Handle_Bisector_BisecAna theHandle) -> Handle_Bisector_BisecAna
        assign(Handle_Bisector_BisecAna self, Bisector_BisecAna thePtr) -> Handle_Bisector_BisecAna
        assign(Handle_Bisector_BisecAna self, Handle_Bisector_BisecAna theHandle) -> Handle_Bisector_BisecAna

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bisector.Handle_Bisector_BisecAna_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bisector_BisecAna self) -> Bisector_BisecAna

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecAna_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bisector_BisecAna self) -> Bisector_BisecAna

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecAna___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bisector_BisecAna self) -> Bisector_BisecAna

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bisector.Handle_Bisector_BisecAna___ref__(self, *args)


    def __hash__(self):
        return _Bisector.Handle_Bisector_BisecAna___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bisector.Handle_Bisector_BisecAna___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bisector.new_Handle_Bisector_BisecAna(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bisector.Handle_Bisector_BisecAna_DownCast)
    __swig_destroy__ = _Bisector.delete_Handle_Bisector_BisecAna

    def Perform(self, *args):
        """
        Perform(Handle_Bisector_BisecAna self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, GeomAbs_JoinType const jointype, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Handle_Bisector_BisecAna self, Handle_Geom2d_Curve Cu, Handle_Geom2d_Point Pnt, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Handle_Bisector_BisecAna self, Handle_Geom2d_Point Pnt, Handle_Geom2d_Curve Cu, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Handle_Bisector_BisecAna self, Handle_Geom2d_Point Pnt1, Handle_Geom2d_Point Pnt2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance=0.0, Standard_Boolean const oncurve)

        Performs  the bisecting line  between the two points
        <Pnt1>  and <Pnt2>.

        :type Pnt1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Pnt2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type Sense: float
        :type Tolerance: float
        :type oncurve: bool

        """
        return _Bisector.Handle_Bisector_BisecAna_Perform(self, *args)


    def Init(self, *args):
        """
        Init(Handle_Bisector_BisecAna self, Handle_Geom2d_TrimmedCurve bisector)

        :type bisector: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        return _Bisector.Handle_Bisector_BisecAna_Init(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Handle_Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Handle_Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsExtendAtEnd(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Handle_Bisector_BisecAna self, Handle_Geom2d_Curve Cu)
        SetTrim(Handle_Bisector_BisecAna self, Standard_Real const uf, Standard_Real const ul)

        Trim <me> by a domain defined by uf  and  ul

        :type uf: float
        :type ul: float

        """
        return _Bisector.Handle_Bisector_BisecAna_SetTrim(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Bisector_BisecAna self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Handle_Bisector_BisecAna_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Bisector_BisecAna self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_ReversedParameter(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Bisector_BisecAna self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsCN(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Bisector_BisecAna self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Bisector_BisecAna self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Handle_Bisector_BisecAna_Transform(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Bisector_BisecAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Bisector_BisecAna self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_BisecAna_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecAna_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecAna_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecAna_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Bisector_BisecAna self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecAna_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Bisector_BisecAna self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecAna_DN(self, *args)


    def Geom2dCurve(self, *args):
        """
        Geom2dCurve(Handle_Bisector_BisecAna self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_BisecAna_Geom2dCurve(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Bisector_BisecAna self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_Parameter(self, *args)


    def ParameterOfStartPoint(self, *args):
        """
        ParameterOfStartPoint(Handle_Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_ParameterOfStartPoint(self, *args)


    def ParameterOfEndPoint(self, *args):
        """
        ParameterOfEndPoint(Handle_Bisector_BisecAna self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_ParameterOfEndPoint(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Bisector_BisecAna self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecAna_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Handle_Bisector_BisecAna self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Handle_Bisector_BisecAna self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_IntervalLast(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Bisector_BisecAna self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Handle_Bisector_BisecAna_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bisector_BisecAna self) -> char const *

        :rtype: const char *

        """
        return _Bisector.Handle_Bisector_BisecAna_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecAna_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecAna_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Bisector_BisecAna self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Bisector_BisecAna self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Bisector_BisecAna self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_BisecAna_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Bisector_BisecAna self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecAna_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Bisector_BisecAna self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecAna_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Bisector_BisecAna self, gp_Pnt2d P)
        Mirror(Handle_Bisector_BisecAna self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Bisector.Handle_Bisector_BisecAna_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Bisector_BisecAna self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Bisector.Handle_Bisector_BisecAna_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Bisector_BisecAna self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Bisector.Handle_Bisector_BisecAna_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Bisector_BisecAna self, gp_Vec2d V)
        Translate(Handle_Bisector_BisecAna self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecAna_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Bisector_BisecAna self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Bisector_BisecAna self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Bisector_BisecAna self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Bisector_BisecAna self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Bisector_BisecAna self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Bisector_BisecAna self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Bisector_BisecAna self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecAna_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Bisector_BisecAna self)

        Memory deallocator for transient classes


        """
        return _Bisector.Handle_Bisector_BisecAna_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bisector_BisecAna self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bisector_BisecAna self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bisector_BisecAna self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bisector_BisecAna self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecAna_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bisector_BisecAna self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bisector.Handle_Bisector_BisecAna_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bisector_BisecAna self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecAna_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bisector_BisecAna self)

        Increments the reference counter of this object


        """
        return _Bisector.Handle_Bisector_BisecAna_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bisector_BisecAna self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecAna_DecrementRefCounter(self, *args)

Handle_Bisector_BisecAna_swigregister = _Bisector.Handle_Bisector_BisecAna_swigregister
Handle_Bisector_BisecAna_swigregister(Handle_Bisector_BisecAna)

def Handle_Bisector_BisecAna_DownCast(thing):
    return _Bisector.Handle_Bisector_BisecAna_DownCast(thing)
Handle_Bisector_BisecAna_DownCast = _Bisector.Handle_Bisector_BisecAna_DownCast

class Bisector_FunctionInter(math.math_FunctionWithDerivative):
    """
    2                      2
    F(u) =  (PC(u) - PBis1(u))   + (PC(u) - PBis2(u))
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_FunctionInter self) -> Bisector_FunctionInter
        __init__(Bisector_FunctionInter self, Handle_Geom2d_Curve C, Handle_Bisector_Curve Bis1, Handle_Bisector_Curve Bis2) -> Bisector_FunctionInter

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Bis1: OCC.wrapper.Bisector.Handle_Bisector_Curve
        :type Bis2: OCC.wrapper.Bisector.Handle_Bisector_Curve

        """
        this = _Bisector.new_Bisector_FunctionInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Bisector_FunctionInter self, Handle_Geom2d_Curve C, Handle_Bisector_Curve Bis1, Handle_Bisector_Curve Bis2)

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Bis1: OCC.wrapper.Bisector.Handle_Bisector_Curve
        :type Bis2: OCC.wrapper.Bisector.Handle_Bisector_Curve

        """
        return _Bisector.Bisector_FunctionInter_Perform(self, *args)


    def Value(self, *args):
        """
        Value(Bisector_FunctionInter self, Standard_Real const X) -> Standard_Boolean

        Computes the values of the Functions for the variable <X>.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Bisector_FunctionInter self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Bisector_FunctionInter self, Standard_Real const X) -> Standard_Boolean

        Returns the values of the functions and the derivatives
        for the variable <X>.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionInter_Values(self, *args)

    __swig_destroy__ = _Bisector.delete_Bisector_FunctionInter
Bisector_FunctionInter_swigregister = _Bisector.Bisector_FunctionInter_swigregister
Bisector_FunctionInter_swigregister(Bisector_FunctionInter)

class Bisector_BisecCC(Bisector_Curve):
    """
    Construct the bisector between two curves.
    The curves can intersect only in their extremities.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Bisector_BisecCC
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Bisector_BisecCC(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Bisector_BisecCC self) -> Bisector_BisecCC
        __init__(Bisector_BisecCC self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, Standard_Real const Side1, Standard_Real const Side2, gp_Pnt2d Origin, Standard_Real const DistMax=500) -> Bisector_BisecCC

        Constructs  the bisector  between the  curves <Cu1>
        and <Cu2>.

        <Side1>  (resp <Side2>) = 1   if the
        bisector curve is on the left of <Cu1> (resp <Cu2>)
        else <Side1> (resp <Side2>) = -1.

        the Bisector is trimmed by the Point <Origin>.
        <DistMax> is used to trim the bisector.The distance
        between the points of the bisector and <Cu> is smaller
        than <DistMax>.

        :type Cu1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Cu2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Side1: float
        :type Side2: float
        :type Origin: OCC.wrapper.gp.gp_Pnt2d
        :type DistMax: float

        """
        this = _Bisector.new_Bisector_BisecCC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(Bisector_BisecCC self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, Standard_Real const Side1, Standard_Real const Side2, gp_Pnt2d Origin, Standard_Real const DistMax=500)

        Computes the bisector  between the  curves <Cu1>
        and <Cu2>.

        <Side1>  (resp <Side2>) = 1   if the
        bisector curve is on the left of <Cu1> (resp <Cu2>)
        else <Side1> (resp <Side2>) = -1.

        the Bisector is trimmed by the Point <Origin>.

        <DistMax> is used to trim the bisector.The distance
        between the points of the bisector and <Cu> is smaller
        than <DistMax>.

        :type Cu1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Cu2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Side1: float
        :type Side2: float
        :type Origin: OCC.wrapper.gp.gp_Pnt2d
        :type DistMax: float

        """
        return _Bisector.Bisector_BisecCC_Perform(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsExtendAtEnd(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Bisector_BisecCC self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Bisector_BisecCC_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_ReversedParameter(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Bisector_BisecCC self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsCN(self, *args)


    def ChangeGuide(self, *args):
        """
        ChangeGuide(Bisector_BisecCC self) -> Handle_Bisector_BisecCC

        The parameter  on <me> is linked to  the parameter
        on the first curve. This method creates the same bisector
        where the curves are inversed.

        :rtype: OCC.wrapper.Bisector.Handle_Bisector_BisecCC

        """
        return _Bisector.Bisector_BisecCC_ChangeGuide(self, *args)


    def Copy(self, *args):
        """
        Copy(Bisector_BisecCC self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Bisector_BisecCC_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Bisector_BisecCC self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Bisector_BisecCC_Transform(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Bisector_BisecCC self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Bisector_BisecCC self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Bisector_BisecCC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Bisector_BisecCC_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Bisector_BisecCC self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Bisector_BisecCC_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Bisector_BisecCC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Bisector_BisecCC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_IntervalLast(self, *args)


    def IntervalContinuity(self, *args):
        """
        IntervalContinuity(Bisector_BisecCC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Bisector_BisecCC_IntervalContinuity(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsPeriodic(self, *args)


    def ValueAndDist(self, *args):
        """
        ValueAndDist(Bisector_BisecCC self, Standard_Real const U) -> gp_Pnt2d

        Returns the point of parameter U.
        Computes the distance between the current point and
        the two curves I separate.
        Computes the parameters on each curve corresponding
        of the projection of the current point.

        :type U: float
        :type U1: float
        :type U2: float
        :type Distance: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_BisecCC_ValueAndDist(self, *args)


    def ValueByInt(self, *args):
        """
        ValueByInt(Bisector_BisecCC self, Standard_Real const U) -> gp_Pnt2d

        Returns the point of parameter U.
        Computes the distance between the current point and
        the two curves I separate.
        Computes the parameters on each curve corresponding
        of the projection of the current point.

        :type U: float
        :type U1: float
        :type U2: float
        :type Distance: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_BisecCC_ValueByInt(self, *args)


    def D0(self, *args):
        """
        D0(Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_BisecCC_D0(self, *args)


    def D1(self, *args):
        """
        D1(Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecCC_D1(self, *args)


    def D2(self, *args):
        """
        D2(Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecCC_D2(self, *args)


    def D3(self, *args):
        """
        D3(Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecCC_D3(self, *args)


    def DN(self, *args):
        """
        DN(Bisector_BisecCC self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Bisector_BisecCC_DN(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_BisecCC_IsEmpty(self, *args)


    def LinkBisCurve(self, *args):
        """
        LinkBisCurve(Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        Returns the parameter on the curve1 of the projection
        of the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_LinkBisCurve(self, *args)


    def LinkCurveBis(self, *args):
        """
        LinkCurveBis(Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        Returns the reciproque of LinkBisCurve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_LinkCurveBis(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Bisector_BisecCC self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_BisecCC_Parameter(self, *args)


    def Curve(self, *args):
        """
        Curve(Bisector_BisecCC self, Standard_Integer const IndCurve) -> Handle_Geom2d_Curve

        :type IndCurve: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Bisector_BisecCC_Curve(self, *args)


    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Bisector.Bisector_PolyBis

        """
        res = _Bisector.Bisector_BisecCC_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(Bisector_BisecCC self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Bisector_BisecCC_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Bisector.Bisector_BisecCC_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Bisector.Bisector_BisecCC_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Bisector_BisecCC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bisector.delete_Bisector_BisecCC
Bisector_BisecCC_swigregister = _Bisector.Bisector_BisecCC_swigregister
Bisector_BisecCC_swigregister(Bisector_BisecCC)

def Bisector_BisecCC_get_type_name(*args):
    """
    Bisector_BisecCC_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Bisector.Bisector_BisecCC_get_type_name(*args)

def Bisector_BisecCC_get_type_descriptor(*args):
    """
    Bisector_BisecCC_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Bisector.Bisector_BisecCC_get_type_descriptor(*args)

class Bisector_(object):
    """
    This package provides the bisecting line between two
    geometric elements.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsConvex(*args):
        """
        IsConvex(Handle_Geom2d_Curve Cu, Standard_Real const Sign) -> Standard_Boolean

        :type Cu: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Sign: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector__IsConvex(*args)

    IsConvex = staticmethod(IsConvex)

    def __init__(self):
        """
        This package provides the bisecting line between two
        geometric elements.
        """
        this = _Bisector.new_Bisector_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Bisector.delete_Bisector_
Bisector__swigregister = _Bisector.Bisector__swigregister
Bisector__swigregister(Bisector_)

def Bisector__IsConvex(*args):
    """
    Bisector__IsConvex(Handle_Geom2d_Curve Cu, Standard_Real const Sign) -> Standard_Boolean

    :type Cu: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type Sign: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Bisector.Bisector__IsConvex(*args)

class Bisector_Bisec(object):
    """
    Bisec  provides the bisecting line between two  elements
    This line is trimed by a point <P> and it's contained in the domain
    defined by the two vectors <V1>, <V2> and <Sense>.

    Definition of  the domain:
    if <Sense>  is  true the bisecting line is contained in the sector
    defined by <-V1> and <-V2> in the sense indirect.
    if <Sense>  is  false the bisecting line is contained in the sector
    defined by <-V1> and <-V2> in the sense direct.

    <Tolerance> is used to define degenerate bisector.
    if the bisector is an hyperbola and one of this radius is smaller
    than <Tolerance>, the bisector is replaced by a line or semi_line
    corresponding to one of hyperbola's axes.
    if the bisector is a parabola on the focal length is smaller than
    <Tolerance>, the bisector is replaced by a semi_line corresponding
    to the axe of symetrie of the parabola.
    if the bisector is an ellipse  and the minor radius is smaller than
    <Tolerance>, the bisector is replaced by a segment corresponding
    to the great axe of the ellipse.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_Bisec self) -> Bisector_Bisec

        Bisec  provides the bisecting line between two  elements
        This line is trimed by a point <P> and it's contained in the domain
        defined by the two vectors <V1>, <V2> and <Sense>.

        Definition of  the domain:
        if <Sense>  is  true the bisecting line is contained in the sector
        defined by <-V1> and <-V2> in the sense indirect.
        if <Sense>  is  false the bisecting line is contained in the sector
        defined by <-V1> and <-V2> in the sense direct.

        <Tolerance> is used to define degenerate bisector.
        if the bisector is an hyperbola and one of this radius is smaller
        than <Tolerance>, the bisector is replaced by a line or semi_line
        corresponding to one of hyperbola's axes.
        if the bisector is a parabola on the focal length is smaller than
        <Tolerance>, the bisector is replaced by a semi_line corresponding
        to the axe of symetrie of the parabola.
        if the bisector is an ellipse  and the minor radius is smaller than
        <Tolerance>, the bisector is replaced by a segment corresponding
        to the great axe of the ellipse.
        """
        this = _Bisector.new_Bisector_Bisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Bisector_Bisec self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, GeomAbs_JoinType const ajointype, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_Bisec self, Handle_Geom2d_Curve Cu, Handle_Geom2d_Point Pnt, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_Bisec self, Handle_Geom2d_Point Pnt, Handle_Geom2d_Curve Cu, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance, Standard_Boolean const oncurve)
        Perform(Bisector_Bisec self, Handle_Geom2d_Point Pnt1, Handle_Geom2d_Point Pnt2, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, Standard_Real const Sense, Standard_Real const Tolerance=0.0, Standard_Boolean const oncurve)

        Performs  the bisecting line  between the two points
        <Pnt1>  and <Pnt2>.

        :type Pnt1: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type Pnt2: OCC.wrapper.Geom2d.Handle_Geom2d_Point
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type Sense: float
        :type Tolerance: float
        :type oncurve: bool

        """
        return _Bisector.Bisector_Bisec_Perform(self, *args)


    def Value(self, *args):
        """
        Returns the Curve of <me>.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _Bisector.Bisector_Bisec_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        Returns the Curve of <me>.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _Bisector.Bisector_Bisec_ChangeValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Bisector.delete_Bisector_Bisec
Bisector_Bisec_swigregister = _Bisector.Bisector_Bisec_swigregister
Bisector_Bisec_swigregister(Bisector_Bisec)

class Handle_Bisector_Curve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bisector_Curve self)

        Nullify the handle


        """
        return _Bisector.Handle_Bisector_Curve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bisector_Curve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bisector.Handle_Bisector_Curve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bisector_Curve self, Bisector_Curve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bisector.Handle_Bisector_Curve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bisector_Curve self, Handle_Bisector_Curve theHandle) -> Handle_Bisector_Curve
        assign(Handle_Bisector_Curve self, Bisector_Curve thePtr) -> Handle_Bisector_Curve
        assign(Handle_Bisector_Curve self, Handle_Bisector_Curve theHandle) -> Handle_Bisector_Curve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bisector.Handle_Bisector_Curve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bisector_Curve self) -> Bisector_Curve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_Curve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bisector_Curve self) -> Bisector_Curve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_Curve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bisector_Curve self) -> Bisector_Curve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bisector.Handle_Bisector_Curve___ref__(self, *args)


    def __hash__(self):
        return _Bisector.Handle_Bisector_Curve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bisector.Handle_Bisector_Curve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bisector.new_Handle_Bisector_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bisector.Handle_Bisector_Curve_DownCast)
    __swig_destroy__ = _Bisector.delete_Handle_Bisector_Curve

    def Parameter(self, *args):
        """
        Parameter(Handle_Bisector_Curve self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_Parameter(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Handle_Bisector_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Handle_Bisector_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsExtendAtEnd(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Bisector_Curve self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_Curve_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Handle_Bisector_Curve self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Handle_Bisector_Curve self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_IntervalLast(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bisector_Curve self) -> char const *

        :rtype: const char *

        """
        return _Bisector.Handle_Bisector_Curve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_Curve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Bisector_Curve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Handle_Bisector_Curve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Bisector_Curve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this curve.
        Note: The point of parameter U on this curve is
        identical to the point of parameter
        ReversedParameter(U) on the reversed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Bisector_Curve self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Bisector_Curve self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Bisector_Curve self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_Curve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Bisector_Curve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Bisector_Curve self) -> Standard_Real

        Value of the last parameter.
        Warnings :
        It can be RealFirst or RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Bisector_Curve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Examples :
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Bisector_Curve self) -> Standard_Boolean

        Returns true if the parameter of the curve is periodic.
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Bisector_Curve self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_Curve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Bisector_Curve self) -> GeomAbs_Shape

        It is the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_Curve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Bisector_Curve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Bisector_Curve self, Standard_Real const U, gp_Pnt2d P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Bisector_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Bisector_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Bisector_Curve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Bisector_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        For the point of parameter U of this curve, computes
        the vector corresponding to the Nth derivative.
        Exceptions
        StdFail_UndefinedDerivative if:
        - the continuity of the curve is not "CN", or
        - the derivative vector cannot be computed easily;
        this is the case with specific types of curve (for
        example, a rational BSpline curve where N is greater than 3).
        Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_Curve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Bisector_Curve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_Curve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Bisector_Curve self, gp_Pnt2d P)
        Mirror(Handle_Bisector_Curve self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Bisector.Handle_Bisector_Curve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Bisector_Curve self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Bisector.Handle_Bisector_Curve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Bisector_Curve self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Bisector.Handle_Bisector_Curve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Bisector_Curve self, gp_Vec2d V)
        Translate(Handle_Bisector_Curve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_Curve_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Bisector_Curve self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom2d).
        The following transformations have the same properties
        as the previous ones but they don't modified the object
        itself. A copy of the object is returned.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Handle_Bisector_Curve_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Bisector_Curve self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Bisector_Curve self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Bisector_Curve self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Bisector_Curve self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Bisector_Curve self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Bisector_Curve self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Bisector_Curve self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Bisector_Curve self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_Curve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Bisector_Curve self)

        Memory deallocator for transient classes


        """
        return _Bisector.Handle_Bisector_Curve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bisector_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bisector_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bisector_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bisector_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_Curve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bisector_Curve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bisector.Handle_Bisector_Curve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bisector_Curve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_Curve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bisector_Curve self)

        Increments the reference counter of this object


        """
        return _Bisector.Handle_Bisector_Curve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bisector_Curve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_Curve_DecrementRefCounter(self, *args)

Handle_Bisector_Curve_swigregister = _Bisector.Handle_Bisector_Curve_swigregister
Handle_Bisector_Curve_swigregister(Handle_Bisector_Curve)

def Handle_Bisector_Curve_DownCast(thing):
    return _Bisector.Handle_Bisector_Curve_DownCast(thing)
Handle_Bisector_Curve_DownCast = _Bisector.Handle_Bisector_Curve_DownCast

class Handle_Bisector_BisecPC(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bisector_BisecPC self)

        Nullify the handle


        """
        return _Bisector.Handle_Bisector_BisecPC_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bisector_BisecPC self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bisector.Handle_Bisector_BisecPC_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bisector_BisecPC self, Bisector_BisecPC thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bisector.Handle_Bisector_BisecPC_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bisector_BisecPC self, Handle_Bisector_BisecPC theHandle) -> Handle_Bisector_BisecPC
        assign(Handle_Bisector_BisecPC self, Bisector_BisecPC thePtr) -> Handle_Bisector_BisecPC
        assign(Handle_Bisector_BisecPC self, Handle_Bisector_BisecPC theHandle) -> Handle_Bisector_BisecPC

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bisector.Handle_Bisector_BisecPC_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bisector_BisecPC self) -> Bisector_BisecPC

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecPC_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bisector_BisecPC self) -> Bisector_BisecPC

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecPC___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bisector_BisecPC self) -> Bisector_BisecPC

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bisector.Handle_Bisector_BisecPC___ref__(self, *args)


    def __hash__(self):
        return _Bisector.Handle_Bisector_BisecPC___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bisector.Handle_Bisector_BisecPC___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bisector.new_Handle_Bisector_BisecPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bisector.Handle_Bisector_BisecPC_DownCast)
    __swig_destroy__ = _Bisector.delete_Handle_Bisector_BisecPC

    def Perform(self, *args):
        """
        Perform(Handle_Bisector_BisecPC self, Handle_Geom2d_Curve Cu, gp_Pnt2d P, Standard_Real const Side, Standard_Real const DistMax=500)

        Construct the bisector between the point <P> and
        the curve <Cu>.
        <Side> = 1. if the bisector curve is on the Left of <Cu>
        else <Side> = -1.
        <DistMax> is used to trim the bisector.The distance
        between the points of the bisector and <Cu> is smaller
        than <DistMax>.

        :type Cu: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Side: float
        :type DistMax: float

        """
        return _Bisector.Handle_Bisector_BisecPC_Perform(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Handle_Bisector_BisecPC self) -> Standard_Boolean

        Returns True if the bisector is extended at start.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Handle_Bisector_BisecPC self) -> Standard_Boolean

        Returns True if the bisector is extended at end.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsExtendAtEnd(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Bisector_BisecPC self)

        Changes the direction of parametrization of <me>.
        The orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Handle_Bisector_BisecPC_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_ReversedParameter(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Bisector_BisecPC self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Bisector_BisecPC self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Handle_Bisector_BisecPC_Transform(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Bisector_BisecPC self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsCN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Bisector_BisecPC self) -> Standard_Real

        Value of the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Bisector_BisecPC self) -> Standard_Real

        Value of the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Bisector_BisecPC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_BisecPC_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Bisector_BisecPC self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecPC_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Handle_Bisector_BisecPC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Handle_Bisector_BisecPC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_IntervalLast(self, *args)


    def IntervalContinuity(self, *args):
        """
        IntervalContinuity(Handle_Bisector_BisecPC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_BisecPC_IntervalContinuity(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Bisector_BisecPC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Bisector_BisecPC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsPeriodic(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns   the   distance   between  the  point  of
        parameter U on <me> and my point or my curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_Distance(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecPC_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecPC_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecPC_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Bisector_BisecPC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecPC_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Bisector_BisecPC self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecPC_DN(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Bisector_BisecPC self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Handle_Bisector_BisecPC_Dump(self, *args)


    def LinkBisCurve(self, *args):
        """
        LinkBisCurve(Handle_Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the parameter on the curve1 of the projection
        of the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_LinkBisCurve(self, *args)


    def LinkCurveBis(self, *args):
        """
        LinkCurveBis(Handle_Bisector_BisecPC self, Standard_Real const U) -> Standard_Real

        Returns the reciproque of LinkBisCurve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_LinkCurveBis(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Bisector_BisecPC self, gp_Pnt2d P) -> Standard_Real

        Returns the parameter on <me> corresponding to <P>.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_Parameter(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Bisector_BisecPC self) -> Standard_Boolean

        Returns <True> if the bisector is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsEmpty(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bisector_BisecPC self) -> char const *

        :rtype: const char *

        """
        return _Bisector.Handle_Bisector_BisecPC_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecPC_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecPC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Bisector_BisecPC self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Bisector_BisecPC self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Bisector_BisecPC self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_BisecPC_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Bisector_BisecPC self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecPC_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Bisector_BisecPC self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecPC_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Bisector_BisecPC self, gp_Pnt2d P)
        Mirror(Handle_Bisector_BisecPC self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Bisector.Handle_Bisector_BisecPC_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Bisector_BisecPC self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Bisector.Handle_Bisector_BisecPC_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Bisector_BisecPC self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Bisector.Handle_Bisector_BisecPC_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Bisector_BisecPC self, gp_Vec2d V)
        Translate(Handle_Bisector_BisecPC self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecPC_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Bisector_BisecPC self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Bisector_BisecPC self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Bisector_BisecPC self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Bisector_BisecPC self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Bisector_BisecPC self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Bisector_BisecPC self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Bisector_BisecPC self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecPC_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Bisector_BisecPC self)

        Memory deallocator for transient classes


        """
        return _Bisector.Handle_Bisector_BisecPC_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bisector_BisecPC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bisector_BisecPC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bisector_BisecPC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bisector_BisecPC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecPC_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bisector_BisecPC self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bisector.Handle_Bisector_BisecPC_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bisector_BisecPC self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecPC_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bisector_BisecPC self)

        Increments the reference counter of this object


        """
        return _Bisector.Handle_Bisector_BisecPC_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bisector_BisecPC self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecPC_DecrementRefCounter(self, *args)

Handle_Bisector_BisecPC_swigregister = _Bisector.Handle_Bisector_BisecPC_swigregister
Handle_Bisector_BisecPC_swigregister(Handle_Bisector_BisecPC)

def Handle_Bisector_BisecPC_DownCast(thing):
    return _Bisector.Handle_Bisector_BisecPC_DownCast(thing)
Handle_Bisector_BisecPC_DownCast = _Bisector.Handle_Bisector_BisecPC_DownCast

class Bisector_Inter(IntRes2d.IntRes2d_Intersection):
    """Intersection between two <Bisec> from Bisector."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_Inter self) -> Bisector_Inter
        __init__(Bisector_Inter self, Bisector_Bisec C1, IntRes2d_Domain D1, Bisector_Bisec C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol, Standard_Boolean const ComunElement) -> Bisector_Inter

        Intersection between 2 curves.
        C1 separates the element A and B.
        C2 separates the elements C et D.
        If B an C have the same geometry. <ComunElement>
        Has to be True.
        It Permits an optimiztion of the computation.

        :type C1: OCC.wrapper.Bisector.Bisector_Bisec
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type C2: OCC.wrapper.Bisector.Bisector_Bisec
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float
        :type ComunElement: bool

        """
        this = _Bisector.new_Bisector_Inter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Bisector_Inter self, Bisector_Bisec C1, IntRes2d_Domain D1, Bisector_Bisec C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol, Standard_Boolean const ComunElement)

        Intersection between 2 curves.
        C1 separates the element A and B.
        C2 separates the elements C et D.
        If B an C have the same geometry. <ComunElement>
        Has to be True.
        It Permits an optimiztion of the computation.

        :type C1: OCC.wrapper.Bisector.Bisector_Bisec
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type C2: OCC.wrapper.Bisector.Bisector_Bisec
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float
        :type ComunElement: bool

        """
        return _Bisector.Bisector_Inter_Perform(self, *args)

    __swig_destroy__ = _Bisector.delete_Bisector_Inter
Bisector_Inter_swigregister = _Bisector.Bisector_Inter_swigregister
Bisector_Inter_swigregister(Bisector_Inter)

class Bisector_FunctionH(math.math_FunctionWithDerivative):
    """
    H(v) = (T1  .P2(v) - P1) * ||T(v)||  -
    2         2
    (T(v).P2(v) - P1) * ||T1||
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_FunctionH self, Handle_Geom2d_Curve C2, gp_Pnt2d P1, gp_Vec2d T1) -> Bisector_FunctionH

        :type C2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type T1: OCC.wrapper.gp.gp_Vec2d

        """
        this = _Bisector.new_Bisector_FunctionH(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(Bisector_FunctionH self, Standard_Real const X) -> Standard_Boolean

        Computes the values of the Functions for the variable <X>.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionH_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Bisector_FunctionH self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionH_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Bisector_FunctionH self, Standard_Real const X) -> Standard_Boolean

        Returns the values of the functions and the derivatives
        for the variable <X>.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_FunctionH_Values(self, *args)

    __swig_destroy__ = _Bisector.delete_Bisector_FunctionH
Bisector_FunctionH_swigregister = _Bisector.Bisector_FunctionH_swigregister
Bisector_FunctionH_swigregister(Bisector_FunctionH)

class Handle_Bisector_BisecCC(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Bisector_BisecCC self)

        Nullify the handle


        """
        return _Bisector.Handle_Bisector_BisecCC_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Bisector_BisecCC self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Bisector.Handle_Bisector_BisecCC_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Bisector_BisecCC self, Bisector_BisecCC thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Bisector.Handle_Bisector_BisecCC_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Bisector_BisecCC self, Handle_Bisector_BisecCC theHandle) -> Handle_Bisector_BisecCC
        assign(Handle_Bisector_BisecCC self, Bisector_BisecCC thePtr) -> Handle_Bisector_BisecCC
        assign(Handle_Bisector_BisecCC self, Handle_Bisector_BisecCC theHandle) -> Handle_Bisector_BisecCC

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Bisector.Handle_Bisector_BisecCC_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Bisector_BisecCC self) -> Bisector_BisecCC

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecCC_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Bisector_BisecCC self) -> Bisector_BisecCC

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Bisector.Handle_Bisector_BisecCC___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Bisector_BisecCC self) -> Bisector_BisecCC

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Bisector.Handle_Bisector_BisecCC___ref__(self, *args)


    def __hash__(self):
        return _Bisector.Handle_Bisector_BisecCC___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Bisector.Handle_Bisector_BisecCC___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Bisector.new_Handle_Bisector_BisecCC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Bisector.Handle_Bisector_BisecCC_DownCast)
    __swig_destroy__ = _Bisector.delete_Handle_Bisector_BisecCC

    def Perform(self, *args):
        """
        Perform(Handle_Bisector_BisecCC self, Handle_Geom2d_Curve Cu1, Handle_Geom2d_Curve Cu2, Standard_Real const Side1, Standard_Real const Side2, gp_Pnt2d Origin, Standard_Real const DistMax=500)

        Computes the bisector  between the  curves <Cu1>
        and <Cu2>.

        <Side1>  (resp <Side2>) = 1   if the
        bisector curve is on the left of <Cu1> (resp <Cu2>)
        else <Side1> (resp <Side2>) = -1.

        the Bisector is trimmed by the Point <Origin>.

        <DistMax> is used to trim the bisector.The distance
        between the points of the bisector and <Cu> is smaller
        than <DistMax>.

        :type Cu1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Cu2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Side1: float
        :type Side2: float
        :type Origin: OCC.wrapper.gp.gp_Pnt2d
        :type DistMax: float

        """
        return _Bisector.Handle_Bisector_BisecCC_Perform(self, *args)


    def IsExtendAtStart(self, *args):
        """
        IsExtendAtStart(Handle_Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsExtendAtStart(self, *args)


    def IsExtendAtEnd(self, *args):
        """
        IsExtendAtEnd(Handle_Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsExtendAtEnd(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Bisector_BisecCC self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Bisector.Handle_Bisector_BisecCC_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_ReversedParameter(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Bisector_BisecCC self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsCN(self, *args)


    def ChangeGuide(self, *args):
        """
        ChangeGuide(Handle_Bisector_BisecCC self) -> Handle_Bisector_BisecCC

        The parameter  on <me> is linked to  the parameter
        on the first curve. This method creates the same bisector
        where the curves are inversed.

        :rtype: OCC.wrapper.Bisector.Handle_Bisector_BisecCC

        """
        return _Bisector.Handle_Bisector_BisecCC_ChangeGuide(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Bisector_BisecCC self) -> Handle_Geom2d_Geometry

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Copy(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Bisector_BisecCC self, gp_Trsf2d T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Handle_Bisector_BisecCC_Transform(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Bisector_BisecCC self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Bisector_BisecCC self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Bisector_BisecCC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_BisecCC_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Bisector_BisecCC self) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <C1>.    And  returns   the number   of
        intervals.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecCC_NbIntervals(self, *args)


    def IntervalFirst(self, *args):
        """
        IntervalFirst(Handle_Bisector_BisecCC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  first  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_IntervalFirst(self, *args)


    def IntervalLast(self, *args):
        """
        IntervalLast(Handle_Bisector_BisecCC self, Standard_Integer const Index) -> Standard_Real

        Returns  the  last  parameter    of  the  current
        interval.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_IntervalLast(self, *args)


    def IntervalContinuity(self, *args):
        """
        IntervalContinuity(Handle_Bisector_BisecCC self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Bisector.Handle_Bisector_BisecCC_IntervalContinuity(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsPeriodic(self, *args)


    def ValueAndDist(self, *args):
        """
        ValueAndDist(Handle_Bisector_BisecCC self, Standard_Real const U) -> gp_Pnt2d

        Returns the point of parameter U.
        Computes the distance between the current point and
        the two curves I separate.
        Computes the parameters on each curve corresponding
        of the projection of the current point.

        :type U: float
        :type U1: float
        :type U2: float
        :type Distance: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecCC_ValueAndDist(self, *args)


    def ValueByInt(self, *args):
        """
        ValueByInt(Handle_Bisector_BisecCC self, Standard_Real const U) -> gp_Pnt2d

        Returns the point of parameter U.
        Computes the distance between the current point and
        the two curves I separate.
        Computes the parameters on each curve corresponding
        of the projection of the current point.

        :type U: float
        :type U1: float
        :type U2: float
        :type Distance: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecCC_ValueByInt(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecCC_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecCC_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecCC_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Bisector_BisecCC self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecCC_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Bisector_BisecCC self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Bisector.Handle_Bisector_BisecCC_DN(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Bisector_BisecCC self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsEmpty(self, *args)


    def LinkBisCurve(self, *args):
        """
        LinkBisCurve(Handle_Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        Returns the parameter on the curve1 of the projection
        of the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_LinkBisCurve(self, *args)


    def LinkCurveBis(self, *args):
        """
        LinkCurveBis(Handle_Bisector_BisecCC self, Standard_Real const U) -> Standard_Real

        Returns the reciproque of LinkBisCurve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_LinkCurveBis(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Bisector_BisecCC self, gp_Pnt2d P) -> Standard_Real

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_Parameter(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_Bisector_BisecCC self, Standard_Integer const IndCurve) -> Handle_Geom2d_Curve

        :type IndCurve: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_BisecCC_Curve(self, *args)


    def Polygon(self, *args):
        """
        :rtype: OCC.wrapper.Bisector.Bisector_PolyBis

        """
        res = _Bisector.Handle_Bisector_BisecCC_Polygon(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(Handle_Bisector_BisecCC self, Standard_Integer const Deep=0, Standard_Integer const Offset=0)

        :type Deep: int
        :type Offset: int

        """
        return _Bisector.Handle_Bisector_BisecCC_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Bisector_BisecCC self) -> char const *

        :rtype: const char *

        """
        return _Bisector.Handle_Bisector_BisecCC_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecCC_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Bisector.Handle_Bisector_BisecCC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Bisector_BisecCC self, Standard_Real const U, gp_Trsf2d T) -> Standard_Real

        Computes the parameter on the curve transformed by
        T for the point of parameter U on this curve.
        Note: this function generally returns U but it can be
        redefined (for example, on a line).

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Bisector_BisecCC self, gp_Trsf2d T) -> Standard_Real

        Returns the coefficient required to compute the
        parametric transformation of this curve when
        transformation T is applied. This coefficient is the
        ratio between the parameter of a point on this curve
        and the parameter of the transformed point on the
        new curve transformed by T.
        Note: this function generally returns 1. but it can be
        redefined (for example, on a line).

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Bisector_BisecCC self) -> Handle_Geom2d_Curve

        Creates a reversed duplicate Changes the orientation of this curve. The first and
        last parameters are not changed, but the parametric
        direction of the curve is reversed.
        If the curve is bounded:
        - the start point of the initial curve becomes the end
        point of the reversed curve, and
        - the end point of the initial curve becomes the start
        point of the reversed curve.
        - Reversed creates a new curve.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Bisector.Handle_Bisector_BisecCC_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Bisector_BisecCC self) -> Standard_Real

        Returns thne period of this curve.
        raises if the curve is not periodic

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Handle_Bisector_BisecCC_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Bisector_BisecCC self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecCC_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Bisector_BisecCC self, gp_Pnt2d P)
        Mirror(Handle_Bisector_BisecCC self, gp_Ax2d A)

        Performs the symmetrical transformation of a Geometry
        with respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _Bisector.Handle_Bisector_BisecCC_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Bisector_BisecCC self, gp_Pnt2d P, Standard_Real const Ang)

        Rotates a Geometry. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _Bisector.Handle_Bisector_BisecCC_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Bisector_BisecCC self, gp_Pnt2d P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _Bisector.Handle_Bisector_BisecCC_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Bisector_BisecCC self, gp_Vec2d V)
        Translate(Handle_Bisector_BisecCC self, gp_Pnt2d P1, gp_Pnt2d P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Handle_Bisector_BisecCC_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Bisector_BisecCC self, gp_Pnt2d P) -> Handle_Geom2d_Geometry
        Mirrored(Handle_Bisector_BisecCC self, gp_Ax2d A) -> Handle_Geom2d_Geometry

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Bisector_BisecCC self, gp_Pnt2d P, Standard_Real const Ang) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Bisector_BisecCC self, gp_Pnt2d P, Standard_Real const S) -> Handle_Geom2d_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Bisector_BisecCC self, gp_Trsf2d T) -> Handle_Geom2d_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Bisector_BisecCC self, gp_Vec2d V) -> Handle_Geom2d_Geometry
        Translated(Handle_Bisector_BisecCC self, gp_Pnt2d P1, gp_Pnt2d P2) -> Handle_Geom2d_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Geometry

        """
        return _Bisector.Handle_Bisector_BisecCC_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Bisector_BisecCC self)

        Memory deallocator for transient classes


        """
        return _Bisector.Handle_Bisector_BisecCC_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Bisector_BisecCC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Bisector_BisecCC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Bisector_BisecCC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Bisector_BisecCC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Handle_Bisector_BisecCC_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Bisector_BisecCC self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Bisector.Handle_Bisector_BisecCC_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Bisector_BisecCC self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecCC_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Bisector_BisecCC self)

        Increments the reference counter of this object


        """
        return _Bisector.Handle_Bisector_BisecCC_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Bisector_BisecCC self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Handle_Bisector_BisecCC_DecrementRefCounter(self, *args)

Handle_Bisector_BisecCC_swigregister = _Bisector.Handle_Bisector_BisecCC_swigregister
Handle_Bisector_BisecCC_swigregister(Handle_Bisector_BisecCC)

def Handle_Bisector_BisecCC_DownCast(thing):
    return _Bisector.Handle_Bisector_BisecCC_DownCast(thing)
Handle_Bisector_BisecCC_DownCast = _Bisector.Handle_Bisector_BisecCC_DownCast

class Bisector_PolyBis(object):
    """Polygon of PointOnBis"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_PolyBis self) -> Bisector_PolyBis

        Polygon of PointOnBis
        """
        this = _Bisector.new_Bisector_PolyBis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(Bisector_PolyBis self, Bisector_PointOnBis Point)

        :type Point: OCC.wrapper.Bisector.Bisector_PointOnBis

        """
        return _Bisector.Bisector_PolyBis_Append(self, *args)


    def Length(self, *args):
        """
        Length(Bisector_PolyBis self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Bisector.Bisector_PolyBis_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Bisector_PolyBis self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_PolyBis_IsEmpty(self, *args)


    def Value(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Bisector.Bisector_PointOnBis

        """
        res = _Bisector.Bisector_PolyBis_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        :rtype: OCC.wrapper.Bisector.Bisector_PointOnBis

        """
        res = _Bisector.Bisector_PolyBis_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        :rtype: OCC.wrapper.Bisector.Bisector_PointOnBis

        """
        res = _Bisector.Bisector_PolyBis_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transform(self, *args):
        """
        Transform(Bisector_PolyBis self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _Bisector.Bisector_PolyBis_Transform(self, *args)

    __swig_destroy__ = _Bisector.delete_Bisector_PolyBis
Bisector_PolyBis_swigregister = _Bisector.Bisector_PolyBis_swigregister
Bisector_PolyBis_swigregister(Bisector_PolyBis)

class Bisector_PointOnBis(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Bisector_PointOnBis self) -> Bisector_PointOnBis
        __init__(Bisector_PointOnBis self, Standard_Real const Param1, Standard_Real const Param2, Standard_Real const ParamBis, Standard_Real const Distance, gp_Pnt2d Point) -> Bisector_PointOnBis

        :type Param1: float
        :type Param2: float
        :type ParamBis: float
        :type Distance: float
        :type Point: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _Bisector.new_Bisector_PointOnBis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ParamOnC1(self, *args):
        """
        ParamOnC1(Bisector_PointOnBis self, Standard_Real const Param)
        ParamOnC1(Bisector_PointOnBis self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_PointOnBis_ParamOnC1(self, *args)


    def ParamOnC2(self, *args):
        """
        ParamOnC2(Bisector_PointOnBis self, Standard_Real const Param)
        ParamOnC2(Bisector_PointOnBis self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_PointOnBis_ParamOnC2(self, *args)


    def ParamOnBis(self, *args):
        """
        ParamOnBis(Bisector_PointOnBis self, Standard_Real const Param)
        ParamOnBis(Bisector_PointOnBis self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_PointOnBis_ParamOnBis(self, *args)


    def Distance(self, *args):
        """
        Distance(Bisector_PointOnBis self, Standard_Real const Distance)
        Distance(Bisector_PointOnBis self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Bisector.Bisector_PointOnBis_Distance(self, *args)


    def Point(self, *args):
        """
        Point(Bisector_PointOnBis self, gp_Pnt2d P)
        Point(Bisector_PointOnBis self) -> gp_Pnt2d

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Bisector.Bisector_PointOnBis_Point(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Bisector_PointOnBis self, Standard_Boolean const Infinite)
        IsInfinite(Bisector_PointOnBis self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Bisector.Bisector_PointOnBis_IsInfinite(self, *args)


    def Dump(self, *args):
        """Dump(Bisector_PointOnBis self)"""
        return _Bisector.Bisector_PointOnBis_Dump(self, *args)

    __swig_destroy__ = _Bisector.delete_Bisector_PointOnBis
Bisector_PointOnBis_swigregister = _Bisector.Bisector_PointOnBis_swigregister
Bisector_PointOnBis_swigregister(Bisector_PointOnBis)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MeshTest')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MeshTest')
    _MeshTest = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MeshTest', [dirname(__file__)])
        except ImportError:
            import _MeshTest
            return _MeshTest
        try:
            _mod = imp.load_module('_MeshTest', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MeshTest = swig_import_helper()
    del swig_import_helper
else:
    import _MeshTest
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MeshTest.delete_SwigPyIterator

    def value(self):
        return _MeshTest.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _MeshTest.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _MeshTest.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _MeshTest.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _MeshTest.SwigPyIterator_equal(self, x)

    def copy(self):
        return _MeshTest.SwigPyIterator_copy(self)

    def next(self):
        return _MeshTest.SwigPyIterator_next(self)

    def __next__(self):
        return _MeshTest.SwigPyIterator___next__(self)

    def previous(self):
        return _MeshTest.SwigPyIterator_previous(self)

    def advance(self, n):
        return _MeshTest.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _MeshTest.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _MeshTest.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _MeshTest.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _MeshTest.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _MeshTest.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _MeshTest.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MeshTest.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MeshTest.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_MeshTest.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _MeshTest.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MeshTest.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshTest.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _MeshTest.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _MeshTest.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _MeshTest.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MeshTest.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_MeshTest.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _MeshTest.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MeshTest.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshTest.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _MeshTest.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _MeshTest.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _MeshTest.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _MeshTest.ptr_to_number(item)
ptr_to_number = _MeshTest.ptr_to_number

def HashCode(*args):
    return _MeshTest.HashCode(*args)
HashCode = _MeshTest.HashCode

def ptr_equal(a, b):
    return _MeshTest.ptr_equal(a, b)
ptr_equal = _MeshTest.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepMesh
else:
    import BRepMesh
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Draw
else:
    import Draw
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
class MeshTest_DrawableMesh(Draw.Draw_Drawable3D):
    """
    A drawable mesh. 
    Provides a mesh object inherited from Drawable3d to draw a triangulation.
    It contains a sequence of highlighted edges and highlighted vertices. <br>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshTest_DrawableMesh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshTest_DrawableMesh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshTest_DrawableMesh self) -> MeshTest_DrawableMesh
        __init__(MeshTest_DrawableMesh self, TopoDS_Shape theShape, Standard_Real const theDeflection) -> MeshTest_DrawableMesh
        __init__(MeshTest_DrawableMesh self, Handle_BRepMesh_IncrementalMesh theMesher) -> MeshTest_DrawableMesh

        :type theMesher: OCC.wrapper.BRepMesh.Handle_BRepMesh_IncrementalMesh

        """
        this = _MeshTest.new_MeshTest_DrawableMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(MeshTest_DrawableMesh self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _MeshTest.MeshTest_DrawableMesh_Add(self, *args)


    def Edges(self, *args):
        """
        Edges(MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.MeshTest_DrawableMesh_Edges(self, *args)


    def Vertices(self, *args):
        """
        Vertices(MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.MeshTest_DrawableMesh_Vertices(self, *args)


    def Triangles(self, *args):
        """
        Triangles(MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.MeshTest_DrawableMesh_Triangles(self, *args)


    def DrawOn(self, *args):
        """
        DrawOn(MeshTest_DrawableMesh self, Draw_Display theDisplay)

        :type theDisplay: OCC.wrapper.Draw.Draw_Display

        """
        return _MeshTest.MeshTest_DrawableMesh_DrawOn(self, *args)


    def Copy(self, *args):
        """
        Copy(MeshTest_DrawableMesh self) -> Handle_Draw_Drawable3D

        :rtype: OCC.wrapper.Draw.Handle_Draw_Drawable3D

        """
        return _MeshTest.MeshTest_DrawableMesh_Copy(self, *args)


    def Dump(self, *args):
        """
        Dump(MeshTest_DrawableMesh self, Standard_OStream & theStream)

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _MeshTest.MeshTest_DrawableMesh_Dump(self, *args)


    def Whatis(self, *args):
        """
        Whatis(MeshTest_DrawableMesh self, Draw_Interpretor theDi)

        :type theDi: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _MeshTest.MeshTest_DrawableMesh_Whatis(self, *args)


    def Mesher(self, *args):
        """
        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_IncrementalMesh

        """
        res = _MeshTest.MeshTest_DrawableMesh_Mesher(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshTest.MeshTest_DrawableMesh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshTest.MeshTest_DrawableMesh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshTest.MeshTest_DrawableMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshTest.delete_MeshTest_DrawableMesh
MeshTest_DrawableMesh_swigregister = _MeshTest.MeshTest_DrawableMesh_swigregister
MeshTest_DrawableMesh_swigregister(MeshTest_DrawableMesh)

def MeshTest_DrawableMesh_get_type_name(*args):
    """
    MeshTest_DrawableMesh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshTest.MeshTest_DrawableMesh_get_type_name(*args)

def MeshTest_DrawableMesh_get_type_descriptor(*args):
    """
    MeshTest_DrawableMesh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshTest.MeshTest_DrawableMesh_get_type_descriptor(*args)

class Handle_MeshTest_DrawableMesh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshTest_DrawableMesh self)

        Nullify the handle


        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshTest_DrawableMesh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshTest_DrawableMesh self, MeshTest_DrawableMesh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshTest_DrawableMesh self, Handle_MeshTest_DrawableMesh theHandle) -> Handle_MeshTest_DrawableMesh
        assign(Handle_MeshTest_DrawableMesh self, MeshTest_DrawableMesh thePtr) -> Handle_MeshTest_DrawableMesh
        assign(Handle_MeshTest_DrawableMesh self, Handle_MeshTest_DrawableMesh theHandle) -> Handle_MeshTest_DrawableMesh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshTest_DrawableMesh self) -> MeshTest_DrawableMesh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshTest_DrawableMesh self) -> MeshTest_DrawableMesh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshTest_DrawableMesh self) -> MeshTest_DrawableMesh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh___ref__(self, *args)


    def __hash__(self):
        return _MeshTest.Handle_MeshTest_DrawableMesh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshTest.Handle_MeshTest_DrawableMesh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshTest.new_Handle_MeshTest_DrawableMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshTest.Handle_MeshTest_DrawableMesh_DownCast)
    __swig_destroy__ = _MeshTest.delete_Handle_MeshTest_DrawableMesh

    def Add(self, *args):
        """
        Add(Handle_MeshTest_DrawableMesh self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Add(self, *args)


    def Edges(self, *args):
        """
        Edges(Handle_MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Edges(self, *args)


    def Vertices(self, *args):
        """
        Vertices(Handle_MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Vertices(self, *args)


    def Triangles(self, *args):
        """
        Triangles(Handle_MeshTest_DrawableMesh self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Triangles(self, *args)


    def DrawOn(self, *args):
        """
        DrawOn(Handle_MeshTest_DrawableMesh self, Draw_Display theDisplay)

        :type theDisplay: OCC.wrapper.Draw.Draw_Display

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_DrawOn(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_MeshTest_DrawableMesh self) -> Handle_Draw_Drawable3D

        :rtype: OCC.wrapper.Draw.Handle_Draw_Drawable3D

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Copy(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MeshTest_DrawableMesh self, Standard_OStream & theStream)

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Dump(self, *args)


    def Whatis(self, *args):
        """
        Whatis(Handle_MeshTest_DrawableMesh self, Draw_Interpretor theDi)

        :type theDi: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Whatis(self, *args)


    def Mesher(self, *args):
        """
        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_IncrementalMesh

        """
        res = _MeshTest.Handle_MeshTest_DrawableMesh_Mesher(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshTest_DrawableMesh self) -> char const *

        :rtype: const char *

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshTest.Handle_MeshTest_DrawableMesh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshTest.Handle_MeshTest_DrawableMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PickReject(self, *args):
        """
        PickReject(Handle_MeshTest_DrawableMesh self, Standard_Real const X, Standard_Real const Y, Standard_Real const Prec) -> Standard_Boolean

        Returs True if the pick is outside the box

        :type X: float
        :type Y: float
        :type Prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_PickReject(self, *args)


    def Is3D(self, *args):
        """
        Is3D(Handle_MeshTest_DrawableMesh self) -> Standard_Boolean

        Is a 3D object. (Default True).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Is3D(self, *args)


    def SetBounds(self, *args):
        """
        SetBounds(Handle_MeshTest_DrawableMesh self, Standard_Real const xmin, Standard_Real const xmax, Standard_Real const ymin, Standard_Real const ymax)

        :type xmin: float
        :type xmax: float
        :type ymin: float
        :type ymax: float

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_SetBounds(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_MeshTest_DrawableMesh self)

        :type xmin: float
        :type xmax: float
        :type ymin: float
        :type ymax: float

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Bounds(self, *args)


    def Visible(self, *args):
        """
        Visible(Handle_MeshTest_DrawableMesh self) -> Standard_Boolean
        Visible(Handle_MeshTest_DrawableMesh self, Standard_Boolean const V)

        :type V: bool

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Visible(self, *args)


    def Protected(self, *args):
        """
        Protected(Handle_MeshTest_DrawableMesh self) -> Standard_Boolean
        Protected(Handle_MeshTest_DrawableMesh self, Standard_Boolean const P)

        :type P: bool

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Protected(self, *args)


    def Name(self, *args):
        """
        Name(Handle_MeshTest_DrawableMesh self) -> Standard_CString
        Name(Handle_MeshTest_DrawableMesh self, Standard_CString const N)

        :type N: OCC.wrapper.Standard.Standard_CString

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshTest_DrawableMesh self)

        Memory deallocator for transient classes


        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshTest_DrawableMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshTest_DrawableMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshTest_DrawableMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshTest_DrawableMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshTest_DrawableMesh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshTest_DrawableMesh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshTest_DrawableMesh self)

        Increments the reference counter of this object


        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshTest_DrawableMesh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.Handle_MeshTest_DrawableMesh_DecrementRefCounter(self, *args)

Handle_MeshTest_DrawableMesh_swigregister = _MeshTest.Handle_MeshTest_DrawableMesh_swigregister
Handle_MeshTest_DrawableMesh_swigregister(Handle_MeshTest_DrawableMesh)

def Handle_MeshTest_DrawableMesh_DownCast(thing):
    return _MeshTest.Handle_MeshTest_DrawableMesh_DownCast(thing)
Handle_MeshTest_DrawableMesh_DownCast = _MeshTest.Handle_MeshTest_DrawableMesh_DownCast

class MeshTest_CheckTopology(object):
    """
    This class checks topology of the mesh presented by
    triangulations of faces.

    The following error are reported:
    - free links. A link is considered free if it has only one
    neighboring triangle and at least one of its nodes belongs to
    interior of the face rather than to its boundary.
    - cross face errors. It is a situation when a point on a common
    boundary between two faces has different 3d coordinates on each
    triangulation. The error is reported if the distance is greater
    than a deflection written in triangulations.
    - asynchronous edges. It is an edge having polygons on two neighboring
    triangulations with different number of points in the polygons.
    - free nodes -- nodes not shared by any triangle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(MeshTest_CheckTopology self, TopoDS_Shape theShape) -> MeshTest_CheckTopology

        constructor

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _MeshTest.new_MeshTest_CheckTopology(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(MeshTest_CheckTopology self, Draw_Interpretor di)

        performs checking

        :type di: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _MeshTest.MeshTest_CheckTopology_Perform(self, *args)


    def NbFacesWithFL(self, *args):
        """
        NbFacesWithFL(MeshTest_CheckTopology self) -> Standard_Integer

        returns the number of faces with free links

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_NbFacesWithFL(self, *args)


    def GetFaceNumWithFL(self, *args):
        """
        GetFaceNumWithFL(MeshTest_CheckTopology self, Standard_Integer const theIndex) -> Standard_Integer

        returns the number (in the shape) of a face with free links
        with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_GetFaceNumWithFL(self, *args)


    def NbFreeLinks(self, *args):
        """
        NbFreeLinks(MeshTest_CheckTopology self, Standard_Integer const theIndex) -> Standard_Integer

        returns the number free links on a face with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_NbFreeLinks(self, *args)


    def GetFreeLink(self, *args):
        """
        GetFreeLink(MeshTest_CheckTopology self, Standard_Integer const theFaceIndex, Standard_Integer const theLinkIndex)

        gets the numbers of nodes of a free link with the given index
        in the face with the given index

        :type theFaceIndex: int
        :type theLinkIndex: int
        :type theNode1: int
        :type theNode2: int

        """
        return _MeshTest.MeshTest_CheckTopology_GetFreeLink(self, *args)


    def NbCrossFaceErrors(self, *args):
        """
        NbCrossFaceErrors(MeshTest_CheckTopology self) -> Standard_Integer

        returns the number of cross face errors

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_NbCrossFaceErrors(self, *args)


    def GetCrossFaceError(self, *args):
        """
        GetCrossFaceError(MeshTest_CheckTopology self, Standard_Integer const theIndex)

        gets the attributes of a cross face error with the given index

        :type theIndex: int
        :type theFace1: int
        :type theNode1: int
        :type theFace2: int
        :type theNode2: int
        :type theValue: float

        """
        return _MeshTest.MeshTest_CheckTopology_GetCrossFaceError(self, *args)


    def NbAsyncEdges(self, *args):
        """
        NbAsyncEdges(MeshTest_CheckTopology self) -> Standard_Integer

        returns the number of async edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_NbAsyncEdges(self, *args)


    def GetAsyncEdgeNum(self, *args):
        """
        GetAsyncEdgeNum(MeshTest_CheckTopology self, Standard_Integer const theIndex) -> Standard_Integer

        returns the number (in the shape) of an async edge with the given index

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_GetAsyncEdgeNum(self, *args)


    def NbFreeNodes(self, *args):
        """
        NbFreeNodes(MeshTest_CheckTopology self) -> Standard_Integer

        returns the number of free nodes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshTest.MeshTest_CheckTopology_NbFreeNodes(self, *args)


    def GetFreeNodeNum(self, *args):
        """
        GetFreeNodeNum(MeshTest_CheckTopology self, Standard_Integer const theIndex)

        returns the number of face containing the Index-th detected free node,
        and number of this node in the triangulation of that face

        :type theIndex: int
        :type theFaceNum: int
        :type theNodeNum: int

        """
        return _MeshTest.MeshTest_CheckTopology_GetFreeNodeNum(self, *args)

    __swig_destroy__ = _MeshTest.delete_MeshTest_CheckTopology
MeshTest_CheckTopology_swigregister = _MeshTest.MeshTest_CheckTopology_swigregister
MeshTest_CheckTopology_swigregister(MeshTest_CheckTopology)

class MeshTest_(object):
    """Provides methods for testing the mesh algorithms."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Commands(*args):
        """
        Commands(Draw_Interpretor DI)

        Defines meshing commands

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _MeshTest.MeshTest__Commands(*args)

    Commands = staticmethod(Commands)

    def PluginCommands(*args):
        """
        PluginCommands(Draw_Interpretor DI)

        Defines plugin commands

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _MeshTest.MeshTest__PluginCommands(*args)

    PluginCommands = staticmethod(PluginCommands)

    def __init__(self):
        """Provides methods for testing the mesh algorithms."""
        this = _MeshTest.new_MeshTest_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshTest.delete_MeshTest_
MeshTest__swigregister = _MeshTest.MeshTest__swigregister
MeshTest__swigregister(MeshTest_)

def MeshTest__Commands(*args):
    """
    MeshTest__Commands(Draw_Interpretor DI)

    Defines meshing commands

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _MeshTest.MeshTest__Commands(*args)

def MeshTest__PluginCommands(*args):
    """
    MeshTest__PluginCommands(Draw_Interpretor DI)

    Defines plugin commands

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _MeshTest.MeshTest__PluginCommands(*args)




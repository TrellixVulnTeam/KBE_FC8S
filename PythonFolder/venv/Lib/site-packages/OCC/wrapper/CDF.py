# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CDF')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CDF')
    _CDF = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CDF', [dirname(__file__)])
        except ImportError:
            import _CDF
            return _CDF
        try:
            _mod = imp.load_module('_CDF', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CDF = swig_import_helper()
    del swig_import_helper
else:
    import _CDF
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CDF.delete_SwigPyIterator

    def value(self):
        return _CDF.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CDF.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CDF.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CDF.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CDF.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CDF.SwigPyIterator_copy(self)

    def next(self):
        return _CDF.SwigPyIterator_next(self)

    def __next__(self):
        return _CDF.SwigPyIterator___next__(self)

    def previous(self):
        return _CDF.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CDF.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CDF.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CDF.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CDF.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CDF.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CDF.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CDF.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _CDF.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CDF.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_CDF.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _CDF.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CDF.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDF.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _CDF.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _CDF.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _CDF.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CDF.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_CDF.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _CDF.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CDF.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDF.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _CDF.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _CDF.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _CDF.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _CDF.ptr_to_number(item)
ptr_to_number = _CDF.ptr_to_number

def HashCode(*args):
    return _CDF.HashCode(*args)
HashCode = _CDF.HashCode

def ptr_equal(a, b):
    return _CDF.ptr_equal(a, b)
ptr_equal = _CDF.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDM
else:
    import CDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Resource
else:
    import Resource
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PCDM
else:
    import PCDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import LDOM
else:
    import LDOM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Storage
else:
    import Storage
del _swig_python_version_info
CDF_TOA_New = _CDF.CDF_TOA_New
CDF_TOA_Modified = _CDF.CDF_TOA_Modified
CDF_TOA_Unchanged = _CDF.CDF_TOA_Unchanged
CDF_TS_OK = _CDF.CDF_TS_OK
CDF_TS_NoCurrentDocument = _CDF.CDF_TS_NoCurrentDocument
CDF_TS_NoDriver = _CDF.CDF_TS_NoDriver
CDF_TS_NoSubComponentDriver = _CDF.CDF_TS_NoSubComponentDriver
CDF_SSNS_OK = _CDF.CDF_SSNS_OK
CDF_SSNS_ReplacingAnExistentDocument = _CDF.CDF_SSNS_ReplacingAnExistentDocument
CDF_SSNS_OpenDocument = _CDF.CDF_SSNS_OpenDocument
CDF_SCS_Consistent = _CDF.CDF_SCS_Consistent
CDF_SCS_Unconsistent = _CDF.CDF_SCS_Unconsistent
CDF_SCS_Stored = _CDF.CDF_SCS_Stored
CDF_SCS_Modified = _CDF.CDF_SCS_Modified
class CDF_StoreList(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_StoreList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_StoreList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(CDF_StoreList self, Handle_CDM_Document aDocument) -> CDF_StoreList

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        this = _CDF.new_CDF_StoreList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsConsistent(self, *args):
        """
        IsConsistent(CDF_StoreList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_StoreList_IsConsistent(self, *args)


    def Store(self, *args):
        """
        Store(CDF_StoreList self, Handle_CDM_MetaData aMetaData, TCollection_ExtendedString aStatusAssociatedText) -> PCDM_StoreStatus

        stores each object of the storelist in the reverse
        order of which they had been added.

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aStatusAssociatedText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _CDF.CDF_StoreList_Store(self, *args)


    def Init(self, *args):
        """Init(CDF_StoreList self)"""
        return _CDF.CDF_StoreList_Init(self, *args)


    def More(self, *args):
        """
        More(CDF_StoreList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_StoreList_More(self, *args)


    def Next(self, *args):
        """Next(CDF_StoreList self)"""
        return _CDF.CDF_StoreList_Next(self, *args)


    def Value(self, *args):
        """
        Value(CDF_StoreList self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_StoreList_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_StoreList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_StoreList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_StoreList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_StoreList
CDF_StoreList_swigregister = _CDF.CDF_StoreList_swigregister
CDF_StoreList_swigregister(CDF_StoreList)

def CDF_StoreList_get_type_name(*args):
    """
    CDF_StoreList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_StoreList_get_type_name(*args)

def CDF_StoreList_get_type_descriptor(*args):
    """
    CDF_StoreList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_StoreList_get_type_descriptor(*args)

class CDF_MetaDataDriverFactory(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_MetaDataDriverFactory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_MetaDataDriverFactory(self) 
            return h


    def Build(self, *args):
        """
        Build(CDF_MetaDataDriverFactory self) -> Handle_CDF_MetaDataDriver

        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriver

        """
        return _CDF.CDF_MetaDataDriverFactory_Build(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_MetaDataDriverFactory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_MetaDataDriverFactory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_MetaDataDriverFactory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriverFactory
CDF_MetaDataDriverFactory_swigregister = _CDF.CDF_MetaDataDriverFactory_swigregister
CDF_MetaDataDriverFactory_swigregister(CDF_MetaDataDriverFactory)

def CDF_MetaDataDriverFactory_get_type_name(*args):
    """
    CDF_MetaDataDriverFactory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_MetaDataDriverFactory_get_type_name(*args)

def CDF_MetaDataDriverFactory_get_type_descriptor(*args):
    """
    CDF_MetaDataDriverFactory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_MetaDataDriverFactory_get_type_descriptor(*args)

class CDF_MetaDataDriver(Standard.Standard_Transient):
    """
    this class list the method that must be available for
    a specific DBMS
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_MetaDataDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_MetaDataDriver(self) 
            return h


    def HasVersionCapability(self, *args):
        """
        HasVersionCapability(CDF_MetaDataDriver self) -> Standard_Boolean

        returns true if the MetaDataDriver can manage different
        versions of a Data.
        By default, returns Standard_False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_MetaDataDriver_HasVersionCapability(self, *args)


    def CreateDependsOn(self, *args):
        """
        CreateDependsOn(CDF_MetaDataDriver self, Handle_CDM_MetaData aFirstData, Handle_CDM_MetaData aSecondData)

        Creates a "Depends On"  relation between two Datas.
        By default does nothing

        :type aFirstData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aSecondData: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.CDF_MetaDataDriver_CreateDependsOn(self, *args)


    def CreateReference(self, *args):
        """
        CreateReference(CDF_MetaDataDriver self, Handle_CDM_MetaData aFrom, Handle_CDM_MetaData aTo, Standard_Integer const aReferenceIdentifier, Standard_Integer const aToDocumentVersion)

        :type aFrom: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aTo: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aReferenceIdentifier: int
        :type aToDocumentVersion: int

        """
        return _CDF.CDF_MetaDataDriver_CreateReference(self, *args)


    def HasVersion(self, *args):
        """
        HasVersion(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Standard_Boolean

        by default return Standard_True.

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_MetaDataDriver_HasVersion(self, *args)


    def BuildFileName(self, *args):
        """
        BuildFileName(CDF_MetaDataDriver self, Handle_CDM_Document aDocument) -> TCollection_ExtendedString

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_BuildFileName(self, *args)


    def SetName(self, *args):
        """
        SetName(CDF_MetaDataDriver self, Handle_CDM_Document aDocument, TCollection_ExtendedString aName) -> TCollection_ExtendedString

        this methods  is usefull if the name  of an  object --
        depends on  the metadatadriver. For  example a Driver
        -- based  on the operating  system can choose to  add
        the extension of file to create to the object.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_SetName(self, *args)


    def HasReadPermission(self, *args):
        """
        HasReadPermission(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_MetaDataDriver_HasReadPermission(self, *args)


    def LastVersion(self, *args):
        """
        LastVersion(CDF_MetaDataDriver self, Handle_CDM_MetaData aMetaData) -> Handle_CDM_MetaData

        by default returns aMetaDATA
        should return the MetaData stored in the DBMS with the meta-data
        corresponding to the path. If the MetaDataDriver has version management capabilities
        the version has to be set in the returned MetaData.
        MetaData is called by GetMetaData
        If the version is not included in the path , MetaData should return
        the last version of the metadata
        is deferred;

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.CDF_MetaDataDriver_LastVersion(self, *args)


    def FindFolder(self, *args):
        """
        FindFolder(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_MetaDataDriver_FindFolder(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(CDF_MetaDataDriver self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_DefaultFolder(self, *args)


    def ReferenceIterator(self, *args):
        """
        ReferenceIterator(CDF_MetaDataDriver self) -> Handle_PCDM_ReferenceIterator

        :rtype: OCC.wrapper.PCDM.Handle_PCDM_ReferenceIterator

        """
        return _CDF.CDF_MetaDataDriver_ReferenceIterator(self, *args)


    def Find(self, *args):
        """
        Find(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean
        Find(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Standard_Boolean

        calls Find with an empty version

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_MetaDataDriver_Find(self, *args)


    def MetaData(self, *args):
        """
        MetaData(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Handle_CDM_MetaData
        MetaData(CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Handle_CDM_MetaData

        calls MetaData with an empty version

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.CDF_MetaDataDriver_MetaData(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_MetaDataDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_MetaDataDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_MetaDataDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriver
CDF_MetaDataDriver_swigregister = _CDF.CDF_MetaDataDriver_swigregister
CDF_MetaDataDriver_swigregister(CDF_MetaDataDriver)

def CDF_MetaDataDriver_get_type_name(*args):
    """
    CDF_MetaDataDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_MetaDataDriver_get_type_name(*args)

def CDF_MetaDataDriver_get_type_descriptor(*args):
    """
    CDF_MetaDataDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_MetaDataDriver_get_type_descriptor(*args)

class CDF_Session(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_Session
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_Session(self) 
            return h


    def __init__(self, *args):
        """__init__(CDF_Session self) -> CDF_Session"""
        this = _CDF.new_CDF_Session(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Exists(*args):
        """
        Exists() -> Standard_Boolean

        returns true if a session has been created.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Session_Exists(*args)

    Exists = staticmethod(Exists)

    def CurrentSession(*args):
        """
        CurrentSession() -> Handle_CDF_Session

        returns the only one instance of Session
        that has been created.

        :rtype: OCC.wrapper.CDF.Handle_CDF_Session

        """
        return _CDF.CDF_Session_CurrentSession(*args)

    CurrentSession = staticmethod(CurrentSession)

    def Directory(self, *args):
        """
        Directory(CDF_Session self) -> Handle_CDF_Directory

        returns the directory of the session;

        :rtype: OCC.wrapper.CDF.Handle_CDF_Directory

        """
        return _CDF.CDF_Session_Directory(self, *args)


    def HasCurrentApplication(self, *args):
        """
        HasCurrentApplication(CDF_Session self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Session_HasCurrentApplication(self, *args)


    def CurrentApplication(self, *args):
        """
        CurrentApplication(CDF_Session self) -> Handle_CDF_Application

        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.CDF_Session_CurrentApplication(self, *args)


    def SetCurrentApplication(self, *args):
        """
        SetCurrentApplication(CDF_Session self, Handle_CDF_Application anApplication)

        :type anApplication: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.CDF_Session_SetCurrentApplication(self, *args)


    def UnsetCurrentApplication(self, *args):
        """UnsetCurrentApplication(CDF_Session self)"""
        return _CDF.CDF_Session_UnsetCurrentApplication(self, *args)


    def MetaDataDriver(self, *args):
        """
        MetaDataDriver(CDF_Session self) -> Handle_CDF_MetaDataDriver

        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriver

        """
        return _CDF.CDF_Session_MetaDataDriver(self, *args)


    def LoadDriver(self, *args):
        """LoadDriver(CDF_Session self)"""
        return _CDF.CDF_Session_LoadDriver(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_Session_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_Session_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_Session_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_Session
CDF_Session_swigregister = _CDF.CDF_Session_swigregister
CDF_Session_swigregister(CDF_Session)

def CDF_Session_Exists(*args):
    """
    CDF_Session_Exists() -> Standard_Boolean

    returns true if a session has been created.

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _CDF.CDF_Session_Exists(*args)

def CDF_Session_CurrentSession(*args):
    """
    CDF_Session_CurrentSession() -> Handle_CDF_Session

    returns the only one instance of Session
    that has been created.

    :rtype: OCC.wrapper.CDF.Handle_CDF_Session

    """
    return _CDF.CDF_Session_CurrentSession(*args)

def CDF_Session_get_type_name(*args):
    """
    CDF_Session_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_Session_get_type_name(*args)

def CDF_Session_get_type_descriptor(*args):
    """
    CDF_Session_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_Session_get_type_descriptor(*args)

class CDF_FWOSDriver(CDF_MetaDataDriver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_FWOSDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_FWOSDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(CDF_FWOSDriver self) -> CDF_FWOSDriver

        initializes the MetaDatadriver with its specific name.


        """
        this = _CDF.new_CDF_FWOSDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Find(self, *args):
        """
        Find(CDF_FWOSDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean

        indicate whether a file exists corresponding to the folder and the name

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_FWOSDriver_Find(self, *args)


    def HasReadPermission(self, *args):
        """
        HasReadPermission(CDF_FWOSDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_FWOSDriver_HasReadPermission(self, *args)


    def FindFolder(self, *args):
        """
        FindFolder(CDF_FWOSDriver self, TCollection_ExtendedString aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_FWOSDriver_FindFolder(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(CDF_FWOSDriver self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_FWOSDriver_DefaultFolder(self, *args)


    def BuildFileName(self, *args):
        """
        BuildFileName(CDF_FWOSDriver self, Handle_CDM_Document aDocument) -> TCollection_ExtendedString

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_FWOSDriver_BuildFileName(self, *args)


    def SetName(self, *args):
        """
        SetName(CDF_FWOSDriver self, Handle_CDM_Document aDocument, TCollection_ExtendedString aName) -> TCollection_ExtendedString

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.CDF_FWOSDriver_SetName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_FWOSDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_FWOSDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_FWOSDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_FWOSDriver
CDF_FWOSDriver_swigregister = _CDF.CDF_FWOSDriver_swigregister
CDF_FWOSDriver_swigregister(CDF_FWOSDriver)

def CDF_FWOSDriver_get_type_name(*args):
    """
    CDF_FWOSDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_FWOSDriver_get_type_name(*args)

def CDF_FWOSDriver_get_type_descriptor(*args):
    """
    CDF_FWOSDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_FWOSDriver_get_type_descriptor(*args)

class Handle_CDF_MetaDataDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_MetaDataDriver self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_MetaDataDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_MetaDataDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_MetaDataDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_MetaDataDriver self, CDF_MetaDataDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_MetaDataDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_MetaDataDriver self, Handle_CDF_MetaDataDriver theHandle) -> Handle_CDF_MetaDataDriver
        assign(Handle_CDF_MetaDataDriver self, CDF_MetaDataDriver thePtr) -> Handle_CDF_MetaDataDriver
        assign(Handle_CDF_MetaDataDriver self, Handle_CDF_MetaDataDriver theHandle) -> Handle_CDF_MetaDataDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_MetaDataDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_MetaDataDriver self) -> CDF_MetaDataDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_MetaDataDriver self) -> CDF_MetaDataDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_MetaDataDriver self) -> CDF_MetaDataDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_MetaDataDriver___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_MetaDataDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_MetaDataDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_MetaDataDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_MetaDataDriver_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_MetaDataDriver

    def HasVersionCapability(self, *args):
        """
        HasVersionCapability(Handle_CDF_MetaDataDriver self) -> Standard_Boolean

        returns true if the MetaDataDriver can manage different
        versions of a Data.
        By default, returns Standard_False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_HasVersionCapability(self, *args)


    def CreateDependsOn(self, *args):
        """
        CreateDependsOn(Handle_CDF_MetaDataDriver self, Handle_CDM_MetaData aFirstData, Handle_CDM_MetaData aSecondData)

        Creates a "Depends On"  relation between two Datas.
        By default does nothing

        :type aFirstData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aSecondData: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.Handle_CDF_MetaDataDriver_CreateDependsOn(self, *args)


    def CreateReference(self, *args):
        """
        CreateReference(Handle_CDF_MetaDataDriver self, Handle_CDM_MetaData aFrom, Handle_CDM_MetaData aTo, Standard_Integer const aReferenceIdentifier, Standard_Integer const aToDocumentVersion)

        :type aFrom: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aTo: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aReferenceIdentifier: int
        :type aToDocumentVersion: int

        """
        return _CDF.Handle_CDF_MetaDataDriver_CreateReference(self, *args)


    def HasVersion(self, *args):
        """
        HasVersion(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Standard_Boolean

        by default return Standard_True.

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_HasVersion(self, *args)


    def BuildFileName(self, *args):
        """
        BuildFileName(Handle_CDF_MetaDataDriver self, Handle_CDM_Document aDocument) -> TCollection_ExtendedString

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.Handle_CDF_MetaDataDriver_BuildFileName(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_CDF_MetaDataDriver self, Handle_CDM_Document aDocument, TCollection_ExtendedString aName) -> TCollection_ExtendedString

        this methods  is usefull if the name  of an  object --
        depends on  the metadatadriver. For  example a Driver
        -- based  on the operating  system can choose to  add
        the extension of file to create to the object.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.Handle_CDF_MetaDataDriver_SetName(self, *args)


    def Find(self, *args):
        """
        Find(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean
        Find(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Standard_Boolean

        calls Find with an empty version

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_Find(self, *args)


    def HasReadPermission(self, *args):
        """
        HasReadPermission(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_HasReadPermission(self, *args)


    def MetaData(self, *args):
        """
        MetaData(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> Handle_CDM_MetaData
        MetaData(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> Handle_CDM_MetaData

        calls MetaData with an empty version

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.Handle_CDF_MetaDataDriver_MetaData(self, *args)


    def LastVersion(self, *args):
        """
        LastVersion(Handle_CDF_MetaDataDriver self, Handle_CDM_MetaData aMetaData) -> Handle_CDM_MetaData

        by default returns aMetaDATA
        should return the MetaData stored in the DBMS with the meta-data
        corresponding to the path. If the MetaDataDriver has version management capabilities
        the version has to be set in the returned MetaData.
        MetaData is called by GetMetaData
        If the version is not included in the path , MetaData should return
        the last version of the metadata
        is deferred;

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDF.Handle_CDF_MetaDataDriver_LastVersion(self, *args)


    def FindFolder(self, *args):
        """
        FindFolder(Handle_CDF_MetaDataDriver self, TCollection_ExtendedString aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_FindFolder(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(Handle_CDF_MetaDataDriver self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.Handle_CDF_MetaDataDriver_DefaultFolder(self, *args)


    def ReferenceIterator(self, *args):
        """
        ReferenceIterator(Handle_CDF_MetaDataDriver self) -> Handle_PCDM_ReferenceIterator

        :rtype: OCC.wrapper.PCDM.Handle_PCDM_ReferenceIterator

        """
        return _CDF.Handle_CDF_MetaDataDriver_ReferenceIterator(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_MetaDataDriver self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_MetaDataDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDF_MetaDataDriver self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_MetaDataDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_MetaDataDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_MetaDataDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_MetaDataDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_MetaDataDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_MetaDataDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_MetaDataDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_MetaDataDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_MetaDataDriver self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_MetaDataDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_MetaDataDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriver_DecrementRefCounter(self, *args)

Handle_CDF_MetaDataDriver_swigregister = _CDF.Handle_CDF_MetaDataDriver_swigregister
Handle_CDF_MetaDataDriver_swigregister(Handle_CDF_MetaDataDriver)

def Handle_CDF_MetaDataDriver_DownCast(thing):
    return _CDF.Handle_CDF_MetaDataDriver_DownCast(thing)
Handle_CDF_MetaDataDriver_DownCast = _CDF.Handle_CDF_MetaDataDriver_DownCast

class CDF_Store(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CDF_Store self, Handle_CDM_Document aDocument) -> CDF_Store

        creates a store list  from the document of the current selection.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        this = _CDF.new_CDF_Store(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Folder(self, *args):
        """
        Folder(CDF_Store self) -> Standard_ExtString

        returns the folder in which the current document will be stored.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Folder(self, *args)


    def Name(self, *args):
        """
        Name(CDF_Store self) -> Standard_ExtString

        returns the name under which the current document will be stored

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Name(self, *args)


    def IsStored(self, *args):
        """
        IsStored(CDF_Store self) -> Standard_Boolean

        returns true if the current document is already stored

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_IsStored(self, *args)


    def IsModified(self, *args):
        """
        IsModified(CDF_Store self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_IsModified(self, *args)


    def CurrentIsConsistent(self, *args):
        """
        CurrentIsConsistent(CDF_Store self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_CurrentIsConsistent(self, *args)


    def IsConsistent(self, *args):
        """
        IsConsistent(CDF_Store self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_IsConsistent(self, *args)


    def HasAPreviousVersion(self, *args):
        """
        HasAPreviousVersion(CDF_Store self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_HasAPreviousVersion(self, *args)


    def PreviousVersion(self, *args):
        """
        PreviousVersion(CDF_Store self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_PreviousVersion(self, *args)


    def IsMainDocument(self, *args):
        """
        IsMainDocument(CDF_Store self) -> Standard_Boolean

        returns true if the currentdocument is the main one, ie the document
        of the current selection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_IsMainDocument(self, *args)


    def SetComment(self, *args):
        """
        SetComment(CDF_Store self, Standard_ExtString const aComment)

        :type aComment: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_SetComment(self, *args)


    def Comment(self, *args):
        """
        Comment(CDF_Store self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Comment(self, *args)


    def RecheckName(self, *args):
        """
        RecheckName(CDF_Store self) -> CDF_StoreSetNameStatus

        defines the name under which the document should be stored.
        uses for example after modification of the folder.

        :rtype: OCC.wrapper.CDF.CDF_StoreSetNameStatus

        """
        return _CDF.CDF_Store_RecheckName(self, *args)


    def SetPreviousVersion(self, *args):
        """
        SetPreviousVersion(CDF_Store self, Standard_ExtString const aPreviousVersion) -> Standard_Boolean

        :type aPreviousVersion: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_SetPreviousVersion(self, *args)


    def Realize(self, *args):
        """Realize(CDF_Store self)"""
        return _CDF.CDF_Store_Realize(self, *args)


    def Path(self, *args):
        """
        Path(CDF_Store self) -> Standard_ExtString

        returns the complete path of the created meta-data.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Path(self, *args)


    def MetaDataPath(self, *args):
        """
        MetaDataPath(CDF_Store self) -> Standard_ExtString

        returns the path of  the previous store is the object
        is already stored, otherwise an empty string;

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_MetaDataPath(self, *args)


    def Description(self, *args):
        """
        Description(CDF_Store self) -> Standard_ExtString

        returns the description of the format of the main object.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Description(self, *args)


    def InitComponent(self, *args):
        """
        InitComponent(CDF_Store self)

        Allows to Start a new Iteration from beginning


        """
        return _CDF.CDF_Store_InitComponent(self, *args)


    def MoreComponent(self, *args):
        """
        MoreComponent(CDF_Store self) -> Standard_Boolean

        Returns True if there are more entries to return

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_MoreComponent(self, *args)


    def NextComponent(self, *args):
        """
        NextComponent(CDF_Store self)

        Go to the next entry
        (if there is not, Value will raise an exception)


        """
        return _CDF.CDF_Store_NextComponent(self, *args)


    def Component(self, *args):
        """
        Component(CDF_Store self) -> Standard_ExtString

        Returns item value of current entry

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_Component(self, *args)


    def HasSubComponents(self, *args):
        """
        HasSubComponents(CDF_Store self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_HasSubComponents(self, *args)


    def SubComponentStatus(self, *args):
        """
        SubComponentStatus(CDF_Store self, Standard_ExtString const aPresentation) -> CDF_SubComponentStatus

        :type aPresentation: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.CDF.CDF_SubComponentStatus

        """
        return _CDF.CDF_Store_SubComponentStatus(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(CDF_Store self)
        SetCurrent(CDF_Store self, Standard_ExtString const aPresentation)

        :type aPresentation: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_SetCurrent(self, *args)


    def SetMain(self, *args):
        """
        SetMain(CDF_Store self)

        the two following methods can
        be used just after Realize  or Import --  method to know if
        thes methods worked correctly, and if not why.


        """
        return _CDF.CDF_Store_SetMain(self, *args)


    def StoreStatus(self, *args):
        """
        StoreStatus(CDF_Store self) -> PCDM_StoreStatus

        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _CDF.CDF_Store_StoreStatus(self, *args)


    def AssociatedStatusText(self, *args):
        """
        AssociatedStatusText(CDF_Store self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Store_AssociatedStatusText(self, *args)


    def SetName(self, *args):
        """
        SetName(CDF_Store self, Standard_ExtString const aName) -> CDF_StoreSetNameStatus
        SetName(CDF_Store self, TCollection_ExtendedString aName) -> CDF_StoreSetNameStatus

        defines the name under which the document should be stored.

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDF.CDF_StoreSetNameStatus

        """
        return _CDF.CDF_Store_SetName(self, *args)


    def SetFolder(self, *args):
        """
        SetFolder(CDF_Store self, TCollection_ExtendedString aFolder) -> Standard_Boolean
        SetFolder(CDF_Store self, Standard_ExtString const aFolder) -> Standard_Boolean

        defines the   folder in which  the document  should be
        stored.  returns  Standard_True if  the Folder exists,
        Standard_False otherwise.

        :type aFolder: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Store_SetFolder(self, *args)

    __swig_destroy__ = _CDF.delete_CDF_Store
CDF_Store_swigregister = _CDF.CDF_Store_swigregister
CDF_Store_swigregister(CDF_Store)

class Handle_CDF_Session(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_Session self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_Session_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_Session self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_Session_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_Session self, CDF_Session thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_Session_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_Session self, Handle_CDF_Session theHandle) -> Handle_CDF_Session
        assign(Handle_CDF_Session self, CDF_Session thePtr) -> Handle_CDF_Session
        assign(Handle_CDF_Session self, Handle_CDF_Session theHandle) -> Handle_CDF_Session

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_Session_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_Session self) -> CDF_Session

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_Session_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_Session self) -> CDF_Session

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_Session___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_Session self) -> CDF_Session

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_Session___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_Session___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_Session___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_Session(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_Session_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_Session

    def Exists(self, *args):
        """
        Exists(Handle_CDF_Session self) -> Standard_Boolean

        returns true if a session has been created.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Session_Exists(self, *args)


    def CurrentSession(self, *args):
        """
        CurrentSession(Handle_CDF_Session self) -> Handle_CDF_Session

        returns the only one instance of Session
        that has been created.

        :rtype: OCC.wrapper.CDF.Handle_CDF_Session

        """
        return _CDF.Handle_CDF_Session_CurrentSession(self, *args)


    def Directory(self, *args):
        """
        Directory(Handle_CDF_Session self) -> Handle_CDF_Directory

        returns the directory of the session;

        :rtype: OCC.wrapper.CDF.Handle_CDF_Directory

        """
        return _CDF.Handle_CDF_Session_Directory(self, *args)


    def HasCurrentApplication(self, *args):
        """
        HasCurrentApplication(Handle_CDF_Session self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Session_HasCurrentApplication(self, *args)


    def CurrentApplication(self, *args):
        """
        CurrentApplication(Handle_CDF_Session self) -> Handle_CDF_Application

        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.Handle_CDF_Session_CurrentApplication(self, *args)


    def SetCurrentApplication(self, *args):
        """
        SetCurrentApplication(Handle_CDF_Session self, Handle_CDF_Application anApplication)

        :type anApplication: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.Handle_CDF_Session_SetCurrentApplication(self, *args)


    def UnsetCurrentApplication(self, *args):
        """UnsetCurrentApplication(Handle_CDF_Session self)"""
        return _CDF.Handle_CDF_Session_UnsetCurrentApplication(self, *args)


    def MetaDataDriver(self, *args):
        """
        MetaDataDriver(Handle_CDF_Session self) -> Handle_CDF_MetaDataDriver

        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriver

        """
        return _CDF.Handle_CDF_Session_MetaDataDriver(self, *args)


    def LoadDriver(self, *args):
        """LoadDriver(Handle_CDF_Session self)"""
        return _CDF.Handle_CDF_Session_LoadDriver(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_Session self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_Session_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Session_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Session_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDF_Session self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_Session_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_Session self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_Session self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Session_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_Session self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_Session self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Session_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_Session self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_Session_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_Session self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Session_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_Session self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_Session_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_Session self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Session_DecrementRefCounter(self, *args)

Handle_CDF_Session_swigregister = _CDF.Handle_CDF_Session_swigregister
Handle_CDF_Session_swigregister(Handle_CDF_Session)

def Handle_CDF_Session_DownCast(thing):
    return _CDF.Handle_CDF_Session_DownCast(thing)
Handle_CDF_Session_DownCast = _CDF.Handle_CDF_Session_DownCast

class Handle_CDF_StoreList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_StoreList self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_StoreList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_StoreList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_StoreList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_StoreList self, CDF_StoreList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_StoreList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_StoreList self, Handle_CDF_StoreList theHandle) -> Handle_CDF_StoreList
        assign(Handle_CDF_StoreList self, CDF_StoreList thePtr) -> Handle_CDF_StoreList
        assign(Handle_CDF_StoreList self, Handle_CDF_StoreList theHandle) -> Handle_CDF_StoreList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_StoreList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_StoreList self) -> CDF_StoreList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_StoreList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_StoreList self) -> CDF_StoreList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_StoreList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_StoreList self) -> CDF_StoreList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_StoreList___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_StoreList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_StoreList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_StoreList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_StoreList_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_StoreList

    def IsConsistent(self, *args):
        """
        IsConsistent(Handle_CDF_StoreList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_StoreList_IsConsistent(self, *args)


    def Store(self, *args):
        """
        Store(Handle_CDF_StoreList self, Handle_CDM_MetaData aMetaData, TCollection_ExtendedString aStatusAssociatedText) -> PCDM_StoreStatus

        stores each object of the storelist in the reverse
        order of which they had been added.

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type aStatusAssociatedText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _CDF.Handle_CDF_StoreList_Store(self, *args)


    def Init(self, *args):
        """Init(Handle_CDF_StoreList self)"""
        return _CDF.Handle_CDF_StoreList_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_CDF_StoreList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_StoreList_More(self, *args)


    def Next(self, *args):
        """Next(Handle_CDF_StoreList self)"""
        return _CDF.Handle_CDF_StoreList_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_CDF_StoreList self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_StoreList_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_StoreList self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_StoreList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_StoreList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_StoreList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDF_StoreList self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_StoreList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_StoreList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_StoreList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_StoreList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_StoreList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_StoreList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_StoreList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_StoreList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_StoreList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_StoreList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_StoreList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_StoreList self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_StoreList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_StoreList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_StoreList_DecrementRefCounter(self, *args)

Handle_CDF_StoreList_swigregister = _CDF.Handle_CDF_StoreList_swigregister
Handle_CDF_StoreList_swigregister(Handle_CDF_StoreList)

def Handle_CDF_StoreList_DownCast(thing):
    return _CDF.Handle_CDF_StoreList_DownCast(thing)
Handle_CDF_StoreList_DownCast = _CDF.Handle_CDF_StoreList_DownCast

class Handle_CDF_MetaDataDriverFactory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_MetaDataDriverFactory self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_MetaDataDriverFactory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_MetaDataDriverFactory self, CDF_MetaDataDriverFactory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_MetaDataDriverFactory self, Handle_CDF_MetaDataDriverFactory theHandle) -> Handle_CDF_MetaDataDriverFactory
        assign(Handle_CDF_MetaDataDriverFactory self, CDF_MetaDataDriverFactory thePtr) -> Handle_CDF_MetaDataDriverFactory
        assign(Handle_CDF_MetaDataDriverFactory self, Handle_CDF_MetaDataDriverFactory theHandle) -> Handle_CDF_MetaDataDriverFactory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_MetaDataDriverFactory self) -> CDF_MetaDataDriverFactory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_MetaDataDriverFactory self) -> CDF_MetaDataDriverFactory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_MetaDataDriverFactory self) -> CDF_MetaDataDriverFactory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_MetaDataDriverFactory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_MetaDataDriverFactory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_MetaDataDriverFactory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_MetaDataDriverFactory_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_MetaDataDriverFactory

    def Build(self, *args):
        """
        Build(Handle_CDF_MetaDataDriverFactory self) -> Handle_CDF_MetaDataDriver

        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriver

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_Build(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_MetaDataDriverFactory self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriverFactory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriverFactory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDF_MetaDataDriverFactory self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_MetaDataDriverFactory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_MetaDataDriverFactory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_MetaDataDriverFactory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_MetaDataDriverFactory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_MetaDataDriverFactory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_MetaDataDriverFactory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_MetaDataDriverFactory self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_MetaDataDriverFactory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriverFactory_DecrementRefCounter(self, *args)

Handle_CDF_MetaDataDriverFactory_swigregister = _CDF.Handle_CDF_MetaDataDriverFactory_swigregister
Handle_CDF_MetaDataDriverFactory_swigregister(Handle_CDF_MetaDataDriverFactory)

def Handle_CDF_MetaDataDriverFactory_DownCast(thing):
    return _CDF.Handle_CDF_MetaDataDriverFactory_DownCast(thing)
Handle_CDF_MetaDataDriverFactory_DownCast = _CDF.Handle_CDF_MetaDataDriverFactory_DownCast

class CDF_Directory(Standard.Standard_Transient):
    """
    A directory is a collection of documents. There is only one instance
    of a given document in a directory.
    put.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_Directory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_Directory(self) 
            return h


    def __init__(self, *args):
        """
        __init__(CDF_Directory self) -> CDF_Directory

        Creates an empty directory.


        """
        this = _CDF.new_CDF_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(CDF_Directory self, Handle_CDM_Document aDocument)

        adds a document into the directory.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Directory_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(CDF_Directory self, Handle_CDM_Document aDocument)

        removes the document.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Directory_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(CDF_Directory self, Handle_CDM_Document aDocument) -> Standard_Boolean

        Returns true if the document aDocument is in the directory

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Directory_Contains(self, *args)


    def Last(self, *args):
        """
        Last(CDF_Directory self) -> Handle_CDM_Document

        returns the last document (if any) which has been added
        in the directory.

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Directory_Last(self, *args)


    def Length(self, *args):
        """
        Length(CDF_Directory self) -> Standard_Integer

        returns the number of documents of the directory.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.CDF_Directory_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(CDF_Directory self) -> Standard_Boolean

        returns true if the directory is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Directory_IsEmpty(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_Directory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_Directory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_Directory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_Directory
CDF_Directory_swigregister = _CDF.CDF_Directory_swigregister
CDF_Directory_swigregister(CDF_Directory)

def CDF_Directory_get_type_name(*args):
    """
    CDF_Directory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_Directory_get_type_name(*args)

def CDF_Directory_get_type_descriptor(*args):
    """
    CDF_Directory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_Directory_get_type_descriptor(*args)

class CDF_MetaDataDriverError(Standard.Standard_Failure):
    """
    This exception is used in the deferred methods.
    Programmer implementing such methods may use this
    exception or any exception inheriting MetaDataDriverError.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_MetaDataDriverError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_MetaDataDriverError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(CDF_MetaDataDriverError self) -> CDF_MetaDataDriverError
        __init__(CDF_MetaDataDriverError self, Standard_CString const theMessage) -> CDF_MetaDataDriverError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _CDF.new_CDF_MetaDataDriverError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_CDF_MetaDataDriverError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriverError

        """
        return _CDF.CDF_MetaDataDriverError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_MetaDataDriverError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_MetaDataDriverError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_MetaDataDriverError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriverError
CDF_MetaDataDriverError_swigregister = _CDF.CDF_MetaDataDriverError_swigregister
CDF_MetaDataDriverError_swigregister(CDF_MetaDataDriverError)

def CDF_MetaDataDriverError_NewInstance(*args):
    """
    CDF_MetaDataDriverError_NewInstance(Standard_CString const theMessage) -> Handle_CDF_MetaDataDriverError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriverError

    """
    return _CDF.CDF_MetaDataDriverError_NewInstance(*args)

def CDF_MetaDataDriverError_get_type_name(*args):
    """
    CDF_MetaDataDriverError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_MetaDataDriverError_get_type_name(*args)

def CDF_MetaDataDriverError_get_type_descriptor(*args):
    """
    CDF_MetaDataDriverError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_MetaDataDriverError_get_type_descriptor(*args)

class CDF_DirectoryIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CDF_DirectoryIterator self) -> CDF_DirectoryIterator
        __init__(CDF_DirectoryIterator self, Handle_CDF_Directory aDirectory) -> CDF_DirectoryIterator

        :type aDirectory: OCC.wrapper.CDF.Handle_CDF_Directory

        """
        this = _CDF.new_CDF_DirectoryIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MoreDocument(self, *args):
        """
        MoreDocument(CDF_DirectoryIterator self) -> Standard_Boolean

        Returns True if there are more entries to return

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_DirectoryIterator_MoreDocument(self, *args)


    def NextDocument(self, *args):
        """
        NextDocument(CDF_DirectoryIterator self)

        Go to the next entry
        (if there is not, Value will raise an exception)


        """
        return _CDF.CDF_DirectoryIterator_NextDocument(self, *args)


    def Document(self, *args):
        """
        Document(CDF_DirectoryIterator self) -> Handle_CDM_Document

        Returns item value of current entry

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_DirectoryIterator_Document(self, *args)

    __swig_destroy__ = _CDF.delete_CDF_DirectoryIterator
CDF_DirectoryIterator_swigregister = _CDF.CDF_DirectoryIterator_swigregister
CDF_DirectoryIterator_swigregister(CDF_DirectoryIterator)

class CDF_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetLicense(*args):
        """
        GetLicense(Standard_Integer const anApplicationIdentifier)

        :type anApplicationIdentifier: int

        """
        return _CDF.CDF__GetLicense(*args)

    GetLicense = staticmethod(GetLicense)

    def IsAvailable(*args):
        """
        IsAvailable(Standard_Integer const anApplicationIdentifier) -> Standard_Boolean

        :type anApplicationIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF__IsAvailable(*args)

    IsAvailable = staticmethod(IsAvailable)

    def __init__(self):
        this = _CDF.new_CDF_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDF.delete_CDF_
CDF__swigregister = _CDF.CDF__swigregister
CDF__swigregister(CDF_)

def CDF__GetLicense(*args):
    """
    CDF__GetLicense(Standard_Integer const anApplicationIdentifier)

    :type anApplicationIdentifier: int

    """
    return _CDF.CDF__GetLicense(*args)

def CDF__IsAvailable(*args):
    """
    CDF__IsAvailable(Standard_Integer const anApplicationIdentifier) -> Standard_Boolean

    :type anApplicationIdentifier: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _CDF.CDF__IsAvailable(*args)

class CDF_Application(CDM.CDM_Application):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDF_Application
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDF_Application(self) 
            return h


    def Load(*args):
        """
        Load(Standard_GUID aGUID) -> Handle_CDF_Application

        plugs an application.

        Open is used
        - for opening a Document that has been created in an application
        - for opening a Document from the database
        - for opening a Document from a file.
        The Open methods always add the document in the session directory and
        calls the virtual Activate method. The document is considered to be
        opened until Close is used. To be storable, a document must be
        opened by an application since the application resources are
        needed to store it.

        :type aGUID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.CDF_Application_Load(*args)

    Load = staticmethod(Load)

    def Open(self, *args):
        """
        Open(CDF_Application self, Handle_CDM_Document aDocument)

        puts the document in the current session directory
        and calls the virtual method Activate on it.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Application_Open(self, *args)


    def CanClose(self, *args):
        """
        CanClose(CDF_Application self, Handle_CDM_Document aDocument) -> CDM_CanCloseStatus

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _CDF.CDF_Application_CanClose(self, *args)


    def Close(self, *args):
        """
        Close(CDF_Application self, Handle_CDM_Document aDocument)

        removes the document of the current session directory
        and closes the document;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Application_Close(self, *args)


    def Retrieve(self, *args):
        """
        Retrieve(CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document
        Retrieve(CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document

        This method retrieves  a  document from the database.
        If the  Document references other documents which have
        been  updated, the  latest version of  these documents
        will    be   used  if   {UseStorageConfiguration}  is
        Standard_True.  --  If the DBMS is  only  based on the
        OS, this syntax  should not be used.

        If the DBMS is EUCLID/Design Manager, {aFolder}, {aName}
        and  {aVersion} have the form they have in
        EUCLID/Design Manager. For example:

        Handle(CDM_Document) theDocument=myApplication->Retrieve("|user|cascade","box","2");
        A link is kept with the database through an instance
        of CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Application_Retrieve(self, *args)


    def CanRetrieve(self, *args):
        """
        CanRetrieve(CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> PCDM_ReaderStatus
        CanRetrieve(CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> PCDM_ReaderStatus

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _CDF.CDF_Application_CanRetrieve(self, *args)


    def GetRetrieveStatus(self, *args):
        """
        GetRetrieveStatus(CDF_Application self) -> PCDM_ReaderStatus

        Checks  status  after  Retrieve

        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _CDF.CDF_Application_GetRetrieveStatus(self, *args)


    def Read(self, *args):
        """
        Read(CDF_Application self, Standard_IStream & theIStream) -> Handle_CDM_Document

        Reads aDoc from standard SEEKABLE stream theIStream,
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.CDF_Application_Read(self, *args)


    def ReaderFromFormat(self, *args):
        """
        ReaderFromFormat(CDF_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_Reader

        Returns instance of read driver for specified format.

        Default implementation uses plugin mechanism to load reader dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].RetrievalPlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if reader is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_Reader

        """
        return _CDF.CDF_Application_ReaderFromFormat(self, *args)


    def WriterFromFormat(self, *args):
        """
        WriterFromFormat(CDF_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_StorageDriver

        Returns instance of storage driver for specified format.

        Default implementation uses plugin mechanism to load driver dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].StoragePlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if driver is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _CDF.CDF_Application_WriterFromFormat(self, *args)


    def Format(self, *args):
        """
        Format(CDF_Application self, TCollection_ExtendedString aFileName, TCollection_ExtendedString theFormat) -> Standard_Boolean

        try to  retrieve a Format  directly in the  file or in
        application   resource  by using   extension. returns
        True if found;

        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Application_Format(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(CDF_Application self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.CDF_Application_DefaultFolder(self, *args)


    def SetDefaultFolder(self, *args):
        """
        SetDefaultFolder(CDF_Application self, Standard_ExtString const aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.CDF_Application_SetDefaultFolder(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDF.CDF_Application_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDF.CDF_Application_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.CDF_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDF.delete_CDF_Application
CDF_Application_swigregister = _CDF.CDF_Application_swigregister
CDF_Application_swigregister(CDF_Application)

def CDF_Application_Load(*args):
    """
    CDF_Application_Load(Standard_GUID aGUID) -> Handle_CDF_Application

    plugs an application.

    Open is used
    - for opening a Document that has been created in an application
    - for opening a Document from the database
    - for opening a Document from a file.
    The Open methods always add the document in the session directory and
    calls the virtual Activate method. The document is considered to be
    opened until Close is used. To be storable, a document must be
    opened by an application since the application resources are
    needed to store it.

    :type aGUID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.CDF.Handle_CDF_Application

    """
    return _CDF.CDF_Application_Load(*args)

def CDF_Application_get_type_name(*args):
    """
    CDF_Application_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDF.CDF_Application_get_type_name(*args)

def CDF_Application_get_type_descriptor(*args):
    """
    CDF_Application_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDF.CDF_Application_get_type_descriptor(*args)

class Handle_CDF_Application(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_Application self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_Application_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_Application self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_Application_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_Application self, CDF_Application thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_Application_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_Application self, Handle_CDF_Application theHandle) -> Handle_CDF_Application
        assign(Handle_CDF_Application self, CDF_Application thePtr) -> Handle_CDF_Application
        assign(Handle_CDF_Application self, Handle_CDF_Application theHandle) -> Handle_CDF_Application

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_Application_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_Application self) -> CDF_Application

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_Application_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_Application self) -> CDF_Application

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_Application___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_Application self) -> CDF_Application

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_Application___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_Application___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_Application___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_Application(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_Application_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_Application

    def Load(self, *args):
        """
        Load(Handle_CDF_Application self, Standard_GUID aGUID) -> Handle_CDF_Application

        plugs an application.

        Open is used
        - for opening a Document that has been created in an application
        - for opening a Document from the database
        - for opening a Document from a file.
        The Open methods always add the document in the session directory and
        calls the virtual Activate method. The document is considered to be
        opened until Close is used. To be storable, a document must be
        opened by an application since the application resources are
        needed to store it.

        :type aGUID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _CDF.Handle_CDF_Application_Load(self, *args)


    def Open(self, *args):
        """
        Open(Handle_CDF_Application self, Handle_CDM_Document aDocument)

        puts the document in the current session directory
        and calls the virtual method Activate on it.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Application_Open(self, *args)


    def CanClose(self, *args):
        """
        CanClose(Handle_CDF_Application self, Handle_CDM_Document aDocument) -> CDM_CanCloseStatus

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _CDF.Handle_CDF_Application_CanClose(self, *args)


    def Close(self, *args):
        """
        Close(Handle_CDF_Application self, Handle_CDM_Document aDocument)

        removes the document of the current session directory
        and closes the document;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Application_Close(self, *args)


    def Retrieve(self, *args):
        """
        Retrieve(Handle_CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document
        Retrieve(Handle_CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document

        This method retrieves  a  document from the database.
        If the  Document references other documents which have
        been  updated, the  latest version of  these documents
        will    be   used  if   {UseStorageConfiguration}  is
        Standard_True.  --  If the DBMS is  only  based on the
        OS, this syntax  should not be used.

        If the DBMS is EUCLID/Design Manager, {aFolder}, {aName}
        and  {aVersion} have the form they have in
        EUCLID/Design Manager. For example:

        Handle(CDM_Document) theDocument=myApplication->Retrieve("|user|cascade","box","2");
        A link is kept with the database through an instance
        of CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Application_Retrieve(self, *args)


    def CanRetrieve(self, *args):
        """
        CanRetrieve(Handle_CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> PCDM_ReaderStatus
        CanRetrieve(Handle_CDF_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> PCDM_ReaderStatus

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _CDF.Handle_CDF_Application_CanRetrieve(self, *args)


    def GetRetrieveStatus(self, *args):
        """
        GetRetrieveStatus(Handle_CDF_Application self) -> PCDM_ReaderStatus

        Checks  status  after  Retrieve

        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _CDF.Handle_CDF_Application_GetRetrieveStatus(self, *args)


    def Read(self, *args):
        """
        Read(Handle_CDF_Application self, Standard_IStream & theIStream) -> Handle_CDM_Document

        Reads aDoc from standard SEEKABLE stream theIStream,
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Application_Read(self, *args)


    def ReaderFromFormat(self, *args):
        """
        ReaderFromFormat(Handle_CDF_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_Reader

        Returns instance of read driver for specified format.

        Default implementation uses plugin mechanism to load reader dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].RetrievalPlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if reader is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_Reader

        """
        return _CDF.Handle_CDF_Application_ReaderFromFormat(self, *args)


    def WriterFromFormat(self, *args):
        """
        WriterFromFormat(Handle_CDF_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_StorageDriver

        Returns instance of storage driver for specified format.

        Default implementation uses plugin mechanism to load driver dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].StoragePlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if driver is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _CDF.Handle_CDF_Application_WriterFromFormat(self, *args)


    def Format(self, *args):
        """
        Format(Handle_CDF_Application self, TCollection_ExtendedString aFileName, TCollection_ExtendedString theFormat) -> Standard_Boolean

        try to  retrieve a Format  directly in the  file or in
        application   resource  by using   extension. returns
        True if found;

        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Application_Format(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(Handle_CDF_Application self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.Handle_CDF_Application_DefaultFolder(self, *args)


    def SetDefaultFolder(self, *args):
        """
        SetDefaultFolder(Handle_CDF_Application self, Standard_ExtString const aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Application_SetDefaultFolder(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_Application self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_Application_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Application_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Resources(self, *args):
        """
        Resources(Handle_CDF_Application self) -> Handle_Resource_Manager

        The manager returned by  this virtual  method will be
        used to search for Format.Retrieval  resource items.

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _CDF.Handle_CDF_Application_Resources(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(Handle_CDF_Application self) -> Handle_Message_Messenger

        Returns default messenger;

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _CDF.Handle_CDF_Application_MessageDriver(self, *args)


    def BeginOfUpdate(self, *args):
        """
        BeginOfUpdate(Handle_CDF_Application self, Handle_CDM_Document aDocument)

        this method is called before the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Application_BeginOfUpdate(self, *args)


    def EndOfUpdate(self, *args):
        """
        EndOfUpdate(Handle_CDF_Application self, Handle_CDM_Document aDocument, Standard_Boolean const theStatus, TCollection_ExtendedString ErrorString)

        this method is called affter the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type theStatus: bool
        :type ErrorString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.Handle_CDF_Application_EndOfUpdate(self, *args)


    def Write(self, *args):
        """
        Write(Handle_CDF_Application self, Standard_ExtString const aString)

        writes the string in the application MessagerDriver.

        :type aString: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDF.Handle_CDF_Application_Write(self, *args)


    def Name(self, *args):
        """
        Name(Handle_CDF_Application self) -> TCollection_ExtendedString

        Returns the application name.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDF.Handle_CDF_Application_Name(self, *args)


    def Version(self, *args):
        """
        Version(Handle_CDF_Application self) -> TCollection_AsciiString

        Returns the application version.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _CDF.Handle_CDF_Application_Version(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_CDF_Application self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_Application_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Application_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Application_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_Application self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_Application_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_Application self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Application_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_Application self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_Application_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_Application self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Application_DecrementRefCounter(self, *args)

Handle_CDF_Application_swigregister = _CDF.Handle_CDF_Application_swigregister
Handle_CDF_Application_swigregister(Handle_CDF_Application)

def Handle_CDF_Application_DownCast(thing):
    return _CDF.Handle_CDF_Application_DownCast(thing)
Handle_CDF_Application_DownCast = _CDF.Handle_CDF_Application_DownCast

class Handle_CDF_Directory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_Directory self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_Directory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_Directory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_Directory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_Directory self, CDF_Directory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_Directory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_Directory self, Handle_CDF_Directory theHandle) -> Handle_CDF_Directory
        assign(Handle_CDF_Directory self, CDF_Directory thePtr) -> Handle_CDF_Directory
        assign(Handle_CDF_Directory self, Handle_CDF_Directory theHandle) -> Handle_CDF_Directory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_Directory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_Directory self) -> CDF_Directory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_Directory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_Directory self) -> CDF_Directory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_Directory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_Directory self) -> CDF_Directory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_Directory___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_Directory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_Directory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_Directory_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_Directory

    def Add(self, *args):
        """
        Add(Handle_CDF_Directory self, Handle_CDM_Document aDocument)

        adds a document into the directory.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Directory_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_CDF_Directory self, Handle_CDM_Document aDocument)

        removes the document.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Directory_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_CDF_Directory self, Handle_CDM_Document aDocument) -> Standard_Boolean

        Returns true if the document aDocument is in the directory

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Directory_Contains(self, *args)


    def Last(self, *args):
        """
        Last(Handle_CDF_Directory self) -> Handle_CDM_Document

        returns the last document (if any) which has been added
        in the directory.

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDF.Handle_CDF_Directory_Last(self, *args)


    def Length(self, *args):
        """
        Length(Handle_CDF_Directory self) -> Standard_Integer

        returns the number of documents of the directory.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Directory_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_CDF_Directory self) -> Standard_Boolean

        returns true if the directory is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Directory_IsEmpty(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_Directory self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_Directory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Directory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_Directory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDF_Directory self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_Directory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_Directory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_Directory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Directory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_Directory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_Directory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_Directory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_Directory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_Directory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_Directory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Directory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_Directory self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_Directory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_Directory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_Directory_DecrementRefCounter(self, *args)

Handle_CDF_Directory_swigregister = _CDF.Handle_CDF_Directory_swigregister
Handle_CDF_Directory_swigregister(Handle_CDF_Directory)

def Handle_CDF_Directory_DownCast(thing):
    return _CDF.Handle_CDF_Directory_DownCast(thing)
Handle_CDF_Directory_DownCast = _CDF.Handle_CDF_Directory_DownCast

class Handle_CDF_MetaDataDriverError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDF_MetaDataDriverError self)

        Nullify the handle


        """
        return _CDF.Handle_CDF_MetaDataDriverError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDF_MetaDataDriverError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDF.Handle_CDF_MetaDataDriverError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDF_MetaDataDriverError self, CDF_MetaDataDriverError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDF_MetaDataDriverError self, Handle_CDF_MetaDataDriverError theHandle) -> Handle_CDF_MetaDataDriverError
        assign(Handle_CDF_MetaDataDriverError self, CDF_MetaDataDriverError thePtr) -> Handle_CDF_MetaDataDriverError
        assign(Handle_CDF_MetaDataDriverError self, Handle_CDF_MetaDataDriverError theHandle) -> Handle_CDF_MetaDataDriverError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDF.Handle_CDF_MetaDataDriverError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDF_MetaDataDriverError self) -> CDF_MetaDataDriverError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDF_MetaDataDriverError self) -> CDF_MetaDataDriverError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDF.Handle_CDF_MetaDataDriverError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDF_MetaDataDriverError self) -> CDF_MetaDataDriverError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDF.Handle_CDF_MetaDataDriverError___ref__(self, *args)


    def __hash__(self):
        return _CDF.Handle_CDF_MetaDataDriverError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDF.Handle_CDF_MetaDataDriverError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDF.new_Handle_CDF_MetaDataDriverError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDF.Handle_CDF_MetaDataDriverError_DownCast)
    __swig_destroy__ = _CDF.delete_Handle_CDF_MetaDataDriverError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_CDF_MetaDataDriverError self, Standard_CString const theMessage) -> Handle_CDF_MetaDataDriverError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.CDF.Handle_CDF_MetaDataDriverError

        """
        return _CDF.Handle_CDF_MetaDataDriverError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDF_MetaDataDriverError self) -> char const *

        :rtype: const char *

        """
        return _CDF.Handle_CDF_MetaDataDriverError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriverError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDF.Handle_CDF_MetaDataDriverError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_CDF_MetaDataDriverError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _CDF.Handle_CDF_MetaDataDriverError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_CDF_MetaDataDriverError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _CDF.Handle_CDF_MetaDataDriverError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_CDF_MetaDataDriverError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _CDF.Handle_CDF_MetaDataDriverError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_CDF_MetaDataDriverError self)
        Reraise(Handle_CDF_MetaDataDriverError self, Standard_CString const aMessage)
        Reraise(Handle_CDF_MetaDataDriverError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _CDF.Handle_CDF_MetaDataDriverError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_CDF_MetaDataDriverError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _CDF.Handle_CDF_MetaDataDriverError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_CDF_MetaDataDriverError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _CDF.Handle_CDF_MetaDataDriverError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_CDF_MetaDataDriverError self)

        Memory deallocator for transient classes


        """
        return _CDF.Handle_CDF_MetaDataDriverError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDF_MetaDataDriverError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDF_MetaDataDriverError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriverError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDF_MetaDataDriverError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDF_MetaDataDriverError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDF.Handle_CDF_MetaDataDriverError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDF_MetaDataDriverError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDF.Handle_CDF_MetaDataDriverError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDF_MetaDataDriverError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriverError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDF_MetaDataDriverError self)

        Increments the reference counter of this object


        """
        return _CDF.Handle_CDF_MetaDataDriverError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDF_MetaDataDriverError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDF.Handle_CDF_MetaDataDriverError_DecrementRefCounter(self, *args)

Handle_CDF_MetaDataDriverError_swigregister = _CDF.Handle_CDF_MetaDataDriverError_swigregister
Handle_CDF_MetaDataDriverError_swigregister(Handle_CDF_MetaDataDriverError)

def Handle_CDF_MetaDataDriverError_DownCast(thing):
    return _CDF.Handle_CDF_MetaDataDriverError_DownCast(thing)
Handle_CDF_MetaDataDriverError_DownCast = _CDF.Handle_CDF_MetaDataDriverError_DownCast




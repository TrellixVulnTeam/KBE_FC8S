# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IFGraph')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IFGraph')
    _IFGraph = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IFGraph', [dirname(__file__)])
        except ImportError:
            import _IFGraph
            return _IFGraph
        try:
            _mod = imp.load_module('_IFGraph', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IFGraph = swig_import_helper()
    del swig_import_helper
else:
    import _IFGraph
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IFGraph.delete_SwigPyIterator

    def value(self):
        return _IFGraph.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IFGraph.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IFGraph.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IFGraph.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IFGraph.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IFGraph.SwigPyIterator_copy(self)

    def next(self):
        return _IFGraph.SwigPyIterator_next(self)

    def __next__(self):
        return _IFGraph.SwigPyIterator___next__(self)

    def previous(self):
        return _IFGraph.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IFGraph.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IFGraph.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IFGraph.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IFGraph.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IFGraph.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IFGraph.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IFGraph.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IFGraph.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IFGraph.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IFGraph.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IFGraph.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IFGraph.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFGraph.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IFGraph.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IFGraph.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IFGraph.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IFGraph.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IFGraph.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IFGraph.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IFGraph.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFGraph.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IFGraph.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IFGraph.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IFGraph.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IFGraph.ptr_to_number(item)
ptr_to_number = _IFGraph.ptr_to_number

def HashCode(*args):
    return _IFGraph.HashCode(*args)
HashCode = _IFGraph.HashCode

def ptr_equal(a, b):
    return _IFGraph.ptr_equal(a, b)
ptr_equal = _IFGraph.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class IFGraph_SubPartsIterator(object):
    """
    defines general form for graph classes of which result is
    not a single iteration on Entities, but a nested one :
    External iteration works on sub-parts, identified by each
    class (according to its algorithm)
    Internal Iteration concerns Entities of a sub-part
    Sub-Parts are assumed to be disjoined; if they are not,
    the first one has priority

    A SubPartsIterator can work in two steps : first, load
    entities which have to be processed
    then, analyse to set those entities into sub-parts
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_SubPartsIterator self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_SubPartsIterator
        __init__(IFGraph_SubPartsIterator self, IFGraph_SubPartsIterator other) -> IFGraph_SubPartsIterator

        Creates a SubPartIterator from another one and gets its Data
        Note that only non-empty sub-parts are taken into account
        PartNum is set to the last one

        :type other: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        this = _IFGraph.new_IFGraph_SubPartsIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetParts(self, *args):
        """
        GetParts(IFGraph_SubPartsIterator self, IFGraph_SubPartsIterator other)

        Gets Parts from another SubPartsIterator (in addition to the
        ones already recorded)
        Error if both SubPartsIterators are not based on the same Model

        :type other: OCC.wrapper.IFGraph.IFGraph_SubPartsIterator

        """
        return _IFGraph.IFGraph_SubPartsIterator_GetParts(self, *args)


    def Model(self, *args):
        """
        Model(IFGraph_SubPartsIterator self) -> Handle_Interface_InterfaceModel

        Returns the Model with which this Iterator was created

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _IFGraph.IFGraph_SubPartsIterator_Model(self, *args)


    def AddPart(self, *args):
        """
        AddPart(IFGraph_SubPartsIterator self)

        Adds an empty part and sets it to receive entities


        """
        return _IFGraph.IFGraph_SubPartsIterator_AddPart(self, *args)


    def NbParts(self, *args):
        """
        NbParts(IFGraph_SubPartsIterator self) -> Standard_Integer

        Returns count of registered parts

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFGraph.IFGraph_SubPartsIterator_NbParts(self, *args)


    def PartNum(self, *args):
        """
        PartNum(IFGraph_SubPartsIterator self) -> Standard_Integer

        Returns numero of part which currently receives entities
        (0 at load time)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFGraph.IFGraph_SubPartsIterator_PartNum(self, *args)


    def SetLoad(self, *args):
        """
        SetLoad(IFGraph_SubPartsIterator self)

        Sets SubPartIterator to get Entities (by GetFromEntity &
        GetFromIter) into load status, to be analysed later


        """
        return _IFGraph.IFGraph_SubPartsIterator_SetLoad(self, *args)


    def SetPartNum(self, *args):
        """
        SetPartNum(IFGraph_SubPartsIterator self, Standard_Integer const num)

        Sets numero of receiving part to a new value
        Error if not in range (1-NbParts)

        :type num: int

        """
        return _IFGraph.IFGraph_SubPartsIterator_SetPartNum(self, *args)


    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_SubPartsIterator self, Handle_Standard_Transient ent, Standard_Boolean const shared)

        Adds an Entity : into load status if in Load mode, to the
        current part if there is one. If shared is True, adds
        also its shared ones (shared at all levels)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shared: bool

        """
        return _IFGraph.IFGraph_SubPartsIterator_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_SubPartsIterator self, Interface_EntityIterator iter)

        Adds a list of Entities (into Load mode or to a Part),
        given as an Iterator

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_SubPartsIterator_GetFromIter(self, *args)


    def Reset(self, *args):
        """
        Reset(IFGraph_SubPartsIterator self)

        Erases data (parts, entities) : "me" becomes empty and in
        load status


        """
        return _IFGraph.IFGraph_SubPartsIterator_Reset(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_SubPartsIterator self)

        Called by Clear, this method allows evaluation just before
        iteration; its default is doing nothing, it is designed to
        be redefined


        """
        return _IFGraph.IFGraph_SubPartsIterator_Evaluate(self, *args)


    def Loaded(self, *args):
        """
        Loaded(IFGraph_SubPartsIterator self) -> Interface_GraphContent

        Returns entities which where loaded (not set into a sub-part)

        :rtype: OCC.wrapper.Interface.Interface_GraphContent

        """
        return _IFGraph.IFGraph_SubPartsIterator_Loaded(self, *args)


    def LoadedGraph(self, *args):
        """
        LoadedGraph(IFGraph_SubPartsIterator self) -> Interface_Graph

        Same as above, but under the form of a Graph

        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        return _IFGraph.IFGraph_SubPartsIterator_LoadedGraph(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(IFGraph_SubPartsIterator self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if an Entity is loaded (either set into a
        sub-part or not)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFGraph.IFGraph_SubPartsIterator_IsLoaded(self, *args)


    def IsInPart(self, *args):
        """
        IsInPart(IFGraph_SubPartsIterator self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if an Entity is Present in a sub-part

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFGraph.IFGraph_SubPartsIterator_IsInPart(self, *args)


    def EntityPartNum(self, *args):
        """
        EntityPartNum(IFGraph_SubPartsIterator self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns number of the sub-part in which an Entity has been set
        if it is not in a sub-part (or not loaded at all), Returns 0

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFGraph.IFGraph_SubPartsIterator_EntityPartNum(self, *args)


    def Start(self, *args):
        """
        Start(IFGraph_SubPartsIterator self)

        Sets iteration to its beginning; calls Evaluate


        """
        return _IFGraph.IFGraph_SubPartsIterator_Start(self, *args)


    def More(self, *args):
        """
        More(IFGraph_SubPartsIterator self) -> Standard_Boolean

        Returns True if there are more sub-parts to iterate on
        Note : an empty sub-part is not taken in account by Iteration

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFGraph.IFGraph_SubPartsIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(IFGraph_SubPartsIterator self)

        Sets iteration to the next sub-part
        if there is not, IsSingle-Entities will raises an exception


        """
        return _IFGraph.IFGraph_SubPartsIterator_Next(self, *args)


    def IsSingle(self, *args):
        """
        IsSingle(IFGraph_SubPartsIterator self) -> Standard_Boolean

        Returns True if current sub-part is single (has only one Entity)
        Error if there is no sub-part to iterate now

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFGraph.IFGraph_SubPartsIterator_IsSingle(self, *args)


    def FirstEntity(self, *args):
        """
        FirstEntity(IFGraph_SubPartsIterator self) -> Handle_Standard_Transient

        Returns the first entity of current sub-part, that is for a
        Single one, the only one it contains
        Error : same as above (end of iteration)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_SubPartsIterator_FirstEntity(self, *args)


    def Entities(self, *args):
        """
        Entities(IFGraph_SubPartsIterator self) -> Interface_EntityIterator

        Returns current sub-part, not as a "Value", but as an Iterator
        on Entities it contains
        Error : same as above (end of iteration)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_SubPartsIterator_Entities(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_SubPartsIterator
IFGraph_SubPartsIterator_swigregister = _IFGraph.IFGraph_SubPartsIterator_swigregister
IFGraph_SubPartsIterator_swigregister(IFGraph_SubPartsIterator)

class IFGraph_StrongComponants(IFGraph_SubPartsIterator):
    """
    determines strong componants of a graph, that is
    isolated entities (single componants) or loops
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_StrongComponants self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_StrongComponants

        creates with a Graph, and will analyse :
        whole True  : all the contents of the Model
        whole False : sub-parts which will be given later

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type whole: bool

        """
        this = _IFGraph.new_IFGraph_StrongComponants(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_StrongComponants self)

        does the computation


        """
        return _IFGraph.IFGraph_StrongComponants_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_StrongComponants
IFGraph_StrongComponants_swigregister = _IFGraph.IFGraph_StrongComponants_swigregister
IFGraph_StrongComponants_swigregister(IFGraph_StrongComponants)

class IFGraph_AllShared(Interface.Interface_GraphContent):
    """
    this class determines all Entities shared by some specific
    ones, at any level (those which will be lead in a Transfer
    for instance)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_AllShared self, Interface_Graph agraph) -> IFGraph_AllShared
        __init__(IFGraph_AllShared self, Interface_Graph agraph, Handle_Standard_Transient ent) -> IFGraph_AllShared

        creates an AllShared which memrizes Entities shared by a given
        one, at any level, including itself

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _IFGraph.new_IFGraph_AllShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_AllShared self, Handle_Standard_Transient ent)

        adds an entity and its shared ones to the list (allows to
        cumulate all Entities shared by some ones)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_AllShared_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_AllShared self, Interface_EntityIterator iter)

        Adds Entities from an EntityIterator and all their shared
        ones at any level

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_AllShared_GetFromIter(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_AllShared self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_AllShared_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_AllShared self)

        does the specific evaluation (shared entities atall levels)


        """
        return _IFGraph.IFGraph_AllShared_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_AllShared
IFGraph_AllShared_swigregister = _IFGraph.IFGraph_AllShared_swigregister
IFGraph_AllShared_swigregister(IFGraph_AllShared)

class IFGraph_Cumulate(Interface.Interface_GraphContent):
    """
    this class evaluates effect of cumulated sub-parts :
    overlapping, forgotten entities
    Results are kept in a Graph, several question can be set
    Basic Iteration gives entities which are part of Cumulation
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_Cumulate self, Interface_Graph agraph) -> IFGraph_Cumulate

        creates empty Cumulate, ready to work

        :type agraph: OCC.wrapper.Interface.Interface_Graph

        """
        this = _IFGraph.new_IFGraph_Cumulate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_Cumulate self, Handle_Standard_Transient ent)

        adds an entity and its shared ones to the list

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_Cumulate_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_Cumulate self, Interface_EntityIterator iter)

        adds a list of entities (as an iterator) as such, that is,
        without their shared entities (use AllShared to have them)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Cumulate_GetFromIter(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_Cumulate self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_Cumulate_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_Cumulate self)

        Evaluates the result of cumulation


        """
        return _IFGraph.IFGraph_Cumulate_Evaluate(self, *args)


    def Overlapped(self, *args):
        """
        Overlapped(IFGraph_Cumulate self) -> Interface_EntityIterator

        returns entities which are taken several times

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Cumulate_Overlapped(self, *args)


    def Forgotten(self, *args):
        """
        Forgotten(IFGraph_Cumulate self) -> Interface_EntityIterator

        returns entities which are not taken

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Cumulate_Forgotten(self, *args)


    def PerCount(self, *args):
        """
        PerCount(IFGraph_Cumulate self, Standard_Integer const count=1) -> Interface_EntityIterator

        Returns entities taken a given count of times
        (0 : same as Forgotten, 1 : same as no Overlap : default)

        :type count: int
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Cumulate_PerCount(self, *args)


    def NbTimes(self, *args):
        """
        NbTimes(IFGraph_Cumulate self, Handle_Standard_Transient ent) -> Standard_Integer

        returns number of times an Entity has been counted
        (0 means forgotten, more than 1 means overlap, 1 is normal)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFGraph.IFGraph_Cumulate_NbTimes(self, *args)


    def HighestNbTimes(self, *args):
        """
        HighestNbTimes(IFGraph_Cumulate self) -> Standard_Integer

        Returns the highest number of times recorded for every Entity
        (0 means empty, 1 means no overlap)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IFGraph.IFGraph_Cumulate_HighestNbTimes(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_Cumulate
IFGraph_Cumulate_swigregister = _IFGraph.IFGraph_Cumulate_swigregister
IFGraph_Cumulate_swigregister(IFGraph_Cumulate)

class IFGraph_SCRoots(IFGraph_StrongComponants):
    """determines strong componants in a graph which are Roots"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_SCRoots self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_SCRoots
        __init__(IFGraph_SCRoots self, IFGraph_StrongComponants subparts) -> IFGraph_SCRoots

        creates from a StrongComponants which was already computed

        :type subparts: OCC.wrapper.IFGraph.IFGraph_StrongComponants

        """
        this = _IFGraph.new_IFGraph_SCRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_SCRoots self)

        does the computation


        """
        return _IFGraph.IFGraph_SCRoots_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_SCRoots
IFGraph_SCRoots_swigregister = _IFGraph.IFGraph_SCRoots_swigregister
IFGraph_SCRoots_swigregister(IFGraph_SCRoots)

class IFGraph_AllConnected(Interface.Interface_GraphContent):
    """
    this class gives content of the CONNECTED COMPONANT(S)
    which include specific Entity(ies)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_AllConnected self, Interface_Graph agraph) -> IFGraph_AllConnected
        __init__(IFGraph_AllConnected self, Interface_Graph agraph, Handle_Standard_Transient ent) -> IFGraph_AllConnected

        creates an AllConnected which memorizes Entities Connected to
        a given one, at any level : that is, itself, all Entities
        Shared by it and Sharing it, and so on.
        In other terms, this is the content of the CONNECTED COMPONANT
        which include a specific Entity

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _IFGraph.new_IFGraph_AllConnected(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_AllConnected self, Handle_Standard_Transient ent)

        adds an entity and its Connected ones to the list (allows to
        cumulate all Entities Connected by some ones)
        Note that if "ent" is in the already computed list,, no entity
        will be added, but if "ent" is not already in the list, a new
        Connected Componant will be cumulated

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_AllConnected_GetFromEntity(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_AllConnected self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_AllConnected_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_AllConnected self)

        does the specific evaluation (Connected entities atall levels)


        """
        return _IFGraph.IFGraph_AllConnected_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_AllConnected
IFGraph_AllConnected_swigregister = _IFGraph.IFGraph_AllConnected_swigregister
IFGraph_AllConnected_swigregister(IFGraph_AllConnected)

class IFGraph_ExternalSources(Interface.Interface_GraphContent):
    """
    this class gives entities which are Source of entities of
    a sub-part, but are not contained by this sub-part
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_ExternalSources self, Interface_Graph agraph) -> IFGraph_ExternalSources

        creates empty ExternalSources, ready to work

        :type agraph: OCC.wrapper.Interface.Interface_Graph

        """
        this = _IFGraph.new_IFGraph_ExternalSources(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_ExternalSources self, Handle_Standard_Transient ent)

        adds an entity and its shared ones to the list

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_ExternalSources_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_ExternalSources self, Interface_EntityIterator iter)

        adds a list of entities (as an iterator) with shared ones

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_ExternalSources_GetFromIter(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_ExternalSources self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_ExternalSources_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_ExternalSources self)

        Evaluates external sources of a set of entities


        """
        return _IFGraph.IFGraph_ExternalSources_Evaluate(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IFGraph_ExternalSources self) -> Standard_Boolean

        Returns True if no External Source are found
        It means that we have a "root" set
        (performs an Evaluation as necessary)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IFGraph.IFGraph_ExternalSources_IsEmpty(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_ExternalSources
IFGraph_ExternalSources_swigregister = _IFGraph.IFGraph_ExternalSources_swigregister
IFGraph_ExternalSources_swigregister(IFGraph_ExternalSources)

class IFGraph_Cycles(IFGraph_SubPartsIterator):
    """determines strong componants in a graph which are Cycles"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_Cycles self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_Cycles
        __init__(IFGraph_Cycles self, IFGraph_StrongComponants subparts) -> IFGraph_Cycles

        creates from a StrongComponants which was already computed

        :type subparts: OCC.wrapper.IFGraph.IFGraph_StrongComponants

        """
        this = _IFGraph.new_IFGraph_Cycles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_Cycles self)

        does the computation. Cycles are StrongComponants which are
        not Single


        """
        return _IFGraph.IFGraph_Cycles_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_Cycles
IFGraph_Cycles_swigregister = _IFGraph.IFGraph_Cycles_swigregister
IFGraph_Cycles_swigregister(IFGraph_Cycles)

class IFGraph_ConnectedComponants(IFGraph_SubPartsIterator):
    """
    determines Connected Componants in a Graph. They define
    disjoined sets of Entities
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_ConnectedComponants self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_ConnectedComponants

        creates with a Graph, and will analyse :
        whole True  : all the contents of the Model
        whole False : sub-parts which will be given later

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type whole: bool

        """
        this = _IFGraph.new_IFGraph_ConnectedComponants(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_ConnectedComponants self)

        does the computation


        """
        return _IFGraph.IFGraph_ConnectedComponants_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_ConnectedComponants
IFGraph_ConnectedComponants_swigregister = _IFGraph.IFGraph_ConnectedComponants_swigregister
IFGraph_ConnectedComponants_swigregister(IFGraph_ConnectedComponants)

class IFGraph_Compare(Interface.Interface_GraphContent):
    """
    this class evaluates effect of two compared sub-parts :
    cumulation (union), common part (intersection-overlapping)
    part specific to first sub-part or to the second one
    Results are kept in a Graph, several question can be set
    Basic Iteration gives Cumulation (union)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_Compare self, Interface_Graph agraph) -> IFGraph_Compare

        creates empty Compare, ready to work

        :type agraph: OCC.wrapper.Interface.Interface_Graph

        """
        this = _IFGraph.new_IFGraph_Compare(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_Compare self, Handle_Standard_Transient ent, Standard_Boolean const first)

        adds an entity and its shared ones to the list :
        first True means adds to the first sub-list, else to the 2nd

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type first: bool

        """
        return _IFGraph.IFGraph_Compare_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_Compare self, Interface_EntityIterator iter, Standard_Boolean const first)

        adds a list of entities (as an iterator) as such, that is,
        their shared entities are not considered (use AllShared to
        have them)
        first True means adds to the first sub-list, else to the 2nd

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type first: bool

        """
        return _IFGraph.IFGraph_Compare_GetFromIter(self, *args)


    def Merge(self, *args):
        """
        Merge(IFGraph_Compare self)

        merges the second list into the first one, hence the second
        list is empty


        """
        return _IFGraph.IFGraph_Compare_Merge(self, *args)


    def RemoveSecond(self, *args):
        """
        RemoveSecond(IFGraph_Compare self)

        Removes the contents of second list


        """
        return _IFGraph.IFGraph_Compare_RemoveSecond(self, *args)


    def KeepCommon(self, *args):
        """
        KeepCommon(IFGraph_Compare self)

        Keeps only Common part, sets it as First list and clears
        second list


        """
        return _IFGraph.IFGraph_Compare_KeepCommon(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_Compare self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_Compare_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_Compare self)

        Recomputes result of comparing to sub-parts


        """
        return _IFGraph.IFGraph_Compare_Evaluate(self, *args)


    def Common(self, *args):
        """
        Common(IFGraph_Compare self) -> Interface_EntityIterator

        returns entities common to the both parts

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Compare_Common(self, *args)


    def FirstOnly(self, *args):
        """
        FirstOnly(IFGraph_Compare self) -> Interface_EntityIterator

        returns entities which are exclusively in the first list

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Compare_FirstOnly(self, *args)


    def SecondOnly(self, *args):
        """
        SecondOnly(IFGraph_Compare self) -> Interface_EntityIterator

        returns entities which are exclusively in the second part

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Compare_SecondOnly(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_Compare
IFGraph_Compare_swigregister = _IFGraph.IFGraph_Compare_swigregister
IFGraph_Compare_swigregister(IFGraph_Compare)

class IFGraph_Articulations(Interface.Interface_GraphContent):
    """
    this class gives entities which are Articulation points
    in a whole Model or in a sub-part
    An Articulation Point divides the graph in two (or more)
    disconnected sub-graphs
    Identifying Articulation Points allows improving
    efficiency of spliting a set of Entities into sub-sets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IFGraph_Articulations self, Interface_Graph agraph, Standard_Boolean const whole) -> IFGraph_Articulations

        creates Articulations to evaluate a Graph
        whole True : works on the whole Model
        whole False : remains empty, ready to work on a sub-part

        :type agraph: OCC.wrapper.Interface.Interface_Graph
        :type whole: bool

        """
        this = _IFGraph.new_IFGraph_Articulations(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFromEntity(self, *args):
        """
        GetFromEntity(IFGraph_Articulations self, Handle_Standard_Transient ent)

        adds an entity and its shared ones to the list

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _IFGraph.IFGraph_Articulations_GetFromEntity(self, *args)


    def GetFromIter(self, *args):
        """
        GetFromIter(IFGraph_Articulations self, Interface_EntityIterator iter)

        adds a list of entities (as an iterator)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _IFGraph.IFGraph_Articulations_GetFromIter(self, *args)


    def ResetData(self, *args):
        """
        ResetData(IFGraph_Articulations self)

        Allows to restart on a new data set


        """
        return _IFGraph.IFGraph_Articulations_ResetData(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(IFGraph_Articulations self)

        Evaluates the list of Articulation points


        """
        return _IFGraph.IFGraph_Articulations_Evaluate(self, *args)

    __swig_destroy__ = _IFGraph.delete_IFGraph_Articulations
IFGraph_Articulations_swigregister = _IFGraph.IFGraph_Articulations_swigregister
IFGraph_Articulations_swigregister(IFGraph_Articulations)




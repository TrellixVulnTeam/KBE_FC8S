# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepExtrema')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepExtrema')
    _BRepExtrema = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepExtrema', [dirname(__file__)])
        except ImportError:
            import _BRepExtrema
            return _BRepExtrema
        try:
            _mod = imp.load_module('_BRepExtrema', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepExtrema = swig_import_helper()
    del swig_import_helper
else:
    import _BRepExtrema
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepExtrema.delete_SwigPyIterator

    def value(self):
        return _BRepExtrema.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepExtrema.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepExtrema.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepExtrema.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepExtrema.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepExtrema.SwigPyIterator_copy(self)

    def next(self):
        return _BRepExtrema.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepExtrema.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepExtrema.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepExtrema.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepExtrema.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepExtrema.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepExtrema.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepExtrema.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepExtrema.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepExtrema.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepExtrema.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepExtrema.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepExtrema.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepExtrema.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepExtrema.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepExtrema.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepExtrema.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepExtrema.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepExtrema.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepExtrema.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepExtrema.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepExtrema.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepExtrema.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepExtrema.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepExtrema.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepExtrema.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepExtrema.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepExtrema.ptr_to_number(item)
ptr_to_number = _BRepExtrema.ptr_to_number

def HashCode(*args):
    return _BRepExtrema.HashCode(*args)
HashCode = _BRepExtrema.HashCode

def ptr_equal(a, b):
    return _BRepExtrema.ptr_equal(a, b)
ptr_equal = _BRepExtrema.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
BRepExtrema_IsVertex = _BRepExtrema.BRepExtrema_IsVertex
BRepExtrema_IsOnEdge = _BRepExtrema.BRepExtrema_IsOnEdge
BRepExtrema_IsInFace = _BRepExtrema.BRepExtrema_IsInFace
class BRepExtrema_SolutionElem(object):
    """This class is used to store information relative to the minimum distance between two shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_SolutionElem self) -> BRepExtrema_SolutionElem
        __init__(BRepExtrema_SolutionElem self, Standard_Real const theDist, gp_Pnt thePoint, BRepExtrema_SupportType const theSolType, TopoDS_Vertex theVertex) -> BRepExtrema_SolutionElem
        __init__(BRepExtrema_SolutionElem self, Standard_Real const theDist, gp_Pnt thePoint, BRepExtrema_SupportType const theSolType, TopoDS_Edge theEdge, Standard_Real const theParam) -> BRepExtrema_SolutionElem
        __init__(BRepExtrema_SolutionElem self, Standard_Real const theDist, gp_Pnt thePoint, BRepExtrema_SupportType const theSolType, TopoDS_Face theFace, Standard_Real const theU, Standard_Real const theV) -> BRepExtrema_SolutionElem

        This constructor is used when the  solution of distance is in a Face.
        The different initialized fields are:
        @param theDist    the distance
        @param thePoint   the solution point
        @param theSolType the type of solution
        @param theFace    the Face
        @param theU       U parameter to locate the solution
        @param theV       V parameter to locate the solution

        :type theDist: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theSolType: OCC.wrapper.BRepExtrema.BRepExtrema_SupportType
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theU: float
        :type theV: float

        """
        this = _BRepExtrema.new_BRepExtrema_SolutionElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dist(self, *args):
        """
        Dist(BRepExtrema_SolutionElem self) -> Standard_Real

        Returns the value of the minimum distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_SolutionElem_Dist(self, *args)


    def Point(self, *args):
        """
        Returns the solution point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepExtrema.BRepExtrema_SolutionElem_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SupportKind(self, *args):
        """
        SupportKind(BRepExtrema_SolutionElem self) -> BRepExtrema_SupportType

        Returns the Support type:
        IsVertex => The solution is a vertex.
        IsOnEdge => The solution belongs to an Edge.
        IsInFace => The solution is inside a Face.

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_SupportType

        """
        return _BRepExtrema.BRepExtrema_SolutionElem_SupportKind(self, *args)


    def Vertex(self, *args):
        """
        Returns the vertex if the solution is a Vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepExtrema.BRepExtrema_SolutionElem_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Returns the vertex if the solution is an Edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepExtrema.BRepExtrema_SolutionElem_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        Returns the vertex if the solution is an Face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepExtrema.BRepExtrema_SolutionElem_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeParameter(self, *args):
        """
        EdgeParameter(BRepExtrema_SolutionElem self)

        Returns the parameter value if the solution is on Edge.

        :type theParam: float

        """
        return _BRepExtrema.BRepExtrema_SolutionElem_EdgeParameter(self, *args)


    def FaceParameter(self, *args):
        """
        FaceParameter(BRepExtrema_SolutionElem self)

        Returns the parameters U and V if the solution is in a Face.

        :type theU: float
        :type theV: float

        """
        return _BRepExtrema.BRepExtrema_SolutionElem_FaceParameter(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_SolutionElem
BRepExtrema_SolutionElem_swigregister = _BRepExtrema.BRepExtrema_SolutionElem_swigregister
BRepExtrema_SolutionElem_swigregister(BRepExtrema_SolutionElem)

class BRepExtrema_UnCompatibleShape(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepExtrema_UnCompatibleShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepExtrema_UnCompatibleShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepExtrema_UnCompatibleShape self) -> BRepExtrema_UnCompatibleShape
        __init__(BRepExtrema_UnCompatibleShape self, Standard_CString const theMessage) -> BRepExtrema_UnCompatibleShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _BRepExtrema.new_BRepExtrema_UnCompatibleShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_BRepExtrema_UnCompatibleShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_UnCompatibleShape

        """
        return _BRepExtrema.BRepExtrema_UnCompatibleShape_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepExtrema.BRepExtrema_UnCompatibleShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepExtrema.BRepExtrema_UnCompatibleShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.BRepExtrema_UnCompatibleShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_UnCompatibleShape
BRepExtrema_UnCompatibleShape_swigregister = _BRepExtrema.BRepExtrema_UnCompatibleShape_swigregister
BRepExtrema_UnCompatibleShape_swigregister(BRepExtrema_UnCompatibleShape)

def BRepExtrema_UnCompatibleShape_NewInstance(*args):
    """
    BRepExtrema_UnCompatibleShape_NewInstance(Standard_CString const theMessage) -> Handle_BRepExtrema_UnCompatibleShape

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_UnCompatibleShape

    """
    return _BRepExtrema.BRepExtrema_UnCompatibleShape_NewInstance(*args)

def BRepExtrema_UnCompatibleShape_get_type_name(*args):
    """
    BRepExtrema_UnCompatibleShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepExtrema.BRepExtrema_UnCompatibleShape_get_type_name(*args)

def BRepExtrema_UnCompatibleShape_get_type_descriptor(*args):
    """
    BRepExtrema_UnCompatibleShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepExtrema.BRepExtrema_UnCompatibleShape_get_type_descriptor(*args)

class NCollection_Vector_TopoDS_Face(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_TopoDS_Face self) -> NCollection_Vector< TopoDS_Face >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_TopoDS_Face self) -> NCollection_Vector< TopoDS_Face >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_TopoDS_Face self) -> NCollection_Vector< TopoDS_Face >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_TopoDS_Face self) -> NCollection_Vector< TopoDS_Face >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BRepExtrema.new_NCollection_Vector_TopoDS_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_TopoDS_Face self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_TopoDS_Face self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_TopoDS_Face self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_TopoDS_Face self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_TopoDS_Face self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_TopoDS_Face self, NCollection_Vector_TopoDS_Face theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_TopoDS_Face self, NCollection_Vector_TopoDS_Face theOther) -> NCollection_Vector_TopoDS_Face

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_TopoDS_Face self, TopoDS_Face theValue) -> TopoDS_Face

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_TopoDS_Face self) -> TopoDS_Face

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Vector_TopoDS_Face_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Vector_TopoDS_Face_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_TopoDS_Face self) -> TopoDS_Face

        @return first element

        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Vector_TopoDS_Face_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_TopoDS_Face self) -> TopoDS_Face

        @return last element

        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Vector_TopoDS_Face___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Vector_TopoDS_Face_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_TopoDS_Face self, Standard_Integer const theIndex) -> TopoDS_Face

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_TopoDS_Face self, Standard_Integer const theIndex, TopoDS_Face theValue) -> TopoDS_Face

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Vector_TopoDS_Face_SetValue(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_NCollection_Vector_TopoDS_Face
NCollection_Vector_TopoDS_Face_swigregister = _BRepExtrema.NCollection_Vector_TopoDS_Face_swigregister
NCollection_Vector_TopoDS_Face_swigregister(NCollection_Vector_TopoDS_Face)


try:
	BRepExtrema_ShapeList = NCollection_Vector_TopoDS_Face
except NameError:
	pass # does not exist, probably ignored

class BRepExtrema_OverlapTool(object):
    """
    Tool class for for detection of overlapping of two BVH primitive sets.
    This tool is not intended to be used independently, and is integrated
    in other classes, implementing algorithms based on shape tessellation
    (BRepExtrema_ShapeProximity and BRepExtrema_SelfIntersection).

    Note that input element sets may correspond to different shapes or to
    the same shape. In first case, tessellations of two given shapes will
    be tested for intersection (or overlapping, if tolerance is not zero).
    In second case, tessellation of single shape will be tested for self-
    intersections. Please note that algorithm results are approximate and
    depend greatly on the quality of input tessellation(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_OverlapTool self) -> Standard_Boolean

        Is overlap test completed?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_OverlapTool_IsDone(self, *args)


    def MarkDirty(self, *args):
        """
        MarkDirty(BRepExtrema_OverlapTool self)

        Marks test results as outdated.


        """
        return _BRepExtrema.BRepExtrema_OverlapTool_MarkDirty(self, *args)


    def OverlapSubShapes1(self, *args):
        """
        Returns set of overlapped sub-shapes of 1st shape (currently only faces are detected).

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_MapOfIntegerPackedMapOfInteger

        """
        res = _BRepExtrema.BRepExtrema_OverlapTool_OverlapSubShapes1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OverlapSubShapes2(self, *args):
        """
        Returns set of overlapped sub-shapes of 2nd shape (currently only faces are detected).

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_MapOfIntegerPackedMapOfInteger

        """
        res = _BRepExtrema.BRepExtrema_OverlapTool_OverlapSubShapes2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetElementFilter(self, *args):
        """
        SetElementFilter(BRepExtrema_OverlapTool self, BRepExtrema_ElementFilter * theFilter)

        Sets filtering tool for preliminary checking pairs of mesh elements.

        :type theFilter: OCC.wrapper.BRepExtrema.BRepExtrema_ElementFilter

        """
        return _BRepExtrema.BRepExtrema_OverlapTool_SetElementFilter(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_OverlapTool
BRepExtrema_OverlapTool_swigregister = _BRepExtrema.BRepExtrema_OverlapTool_swigregister
BRepExtrema_OverlapTool_swigregister(BRepExtrema_OverlapTool)

class BVH_Box_Standard_Real_(object):
    """
    Defines axis aligned bounding box (AABB) based on BVH vectors.
    	param T Numeric data type
    	param N Vector dimension
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Defines axis aligned bounding box (AABB) based on BVH vectors.
        	param T Numeric data type
        	param N Vector dimension
        """
        this = _BRepExtrema.new_BVH_Box_Standard_Real_(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BVH_Box_Standard_Real_ self)

        Clears bounding box.


        """
        return _BRepExtrema.BVH_Box_Standard_Real__Clear(self, *args)


    def IsValid(self, *args):
        """
        IsValid(BVH_Box_Standard_Real_ self) -> Standard_Boolean

        Is bounding box valid?

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BVH_Box_Standard_Real__IsValid(self, *args)


    def Add(self, *args):
        """
        Add(BVH_Box_Standard_Real_ self, BVH_Box< Standard_Real,3 >::BVH_VecNt const & thePoint)

        Appends new point to the bounding box.

        :type thePoint: OCC.wrapper.BVH.BVH_VecNt

        """
        return _BRepExtrema.BVH_Box_Standard_Real__Add(self, *args)


    def Combine(self, *args):
        """
        Combine(BVH_Box_Standard_Real_ self, BVH_Box_Standard_Real_ theBox)

        Combines bounding box with another one.

        :type theBox: OCC.wrapper.BVH.BVH_Box

        """
        return _BRepExtrema.BVH_Box_Standard_Real__Combine(self, *args)


    def CornerMin(self, *args):
        """
        Returns minimum point of bounding box.

        :rtype: OCC.wrapper.BVH.BVH_VecNt

        """
        res = _BRepExtrema.BVH_Box_Standard_Real__CornerMin(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CornerMax(self, *args):
        """
        Returns maximum point of bounding box.

        :rtype: OCC.wrapper.BVH.BVH_VecNt

        """
        res = _BRepExtrema.BVH_Box_Standard_Real__CornerMax(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Area(self, *args):
        """
        Area(BVH_Box_Standard_Real_ self) -> double

        Returns surface area of bounding box.
        If the box is degenerated into line, returns the perimeter instead.

        :rtype: T

        """
        return _BRepExtrema.BVH_Box_Standard_Real__Area(self, *args)


    def Size(self, *args):
        """
        Size(BVH_Box_Standard_Real_ self) -> BVH_Box< Standard_Real,3 >::BVH_VecNt

        Returns diagonal of bounding box.

        :rtype: OCC.wrapper.BVH.BVH_VecNt

        """
        return _BRepExtrema.BVH_Box_Standard_Real__Size(self, *args)


    def Center(self, *args):
        """
        Center(BVH_Box_Standard_Real_ self) -> BVH_Box< Standard_Real,3 >::BVH_VecNt
        Center(BVH_Box_Standard_Real_ self, Standard_Integer const theAxis) -> double

        Returns center of bounding box along the given axis.

        :type theAxis: int
        :rtype: T

        """
        return _BRepExtrema.BVH_Box_Standard_Real__Center(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BVH_Box_Standard_Real_
BVH_Box_Standard_Real__swigregister = _BRepExtrema.BVH_Box_Standard_Real__swigregister
BVH_Box_Standard_Real__swigregister(BVH_Box_Standard_Real_)

class BRepExtrema_Poly(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Distance(*args):
        """
        Distance(TopoDS_Shape S1, TopoDS_Shape S2, gp_Pnt P1, gp_Pnt P2) -> Standard_Boolean

        returns Standard_True if OK.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type dist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_Poly_Distance(*args)

    Distance = staticmethod(Distance)

    def __init__(self):
        this = _BRepExtrema.new_BRepExtrema_Poly()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_Poly
BRepExtrema_Poly_swigregister = _BRepExtrema.BRepExtrema_Poly_swigregister
BRepExtrema_Poly_swigregister(BRepExtrema_Poly)

def BRepExtrema_Poly_Distance(*args):
    """
    BRepExtrema_Poly_Distance(TopoDS_Shape S1, TopoDS_Shape S2, gp_Pnt P1, gp_Pnt P2) -> Standard_Boolean

    returns Standard_True if OK.

    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :type P1: OCC.wrapper.gp.gp_Pnt
    :type P2: OCC.wrapper.gp.gp_Pnt
    :type dist: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepExtrema.BRepExtrema_Poly_Distance(*args)

class NCollection_Sequence_BRepExtrema_SolutionElem(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_BRepExtrema_SolutionElem self) -> NCollection_Sequence< BRepExtrema_SolutionElem >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_BRepExtrema_SolutionElem self) -> NCollection_Sequence< BRepExtrema_SolutionElem >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_BRepExtrema_SolutionElem self) -> NCollection_Sequence< BRepExtrema_SolutionElem >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_BRepExtrema_SolutionElem self) -> NCollection_Sequence< BRepExtrema_SolutionElem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepExtrema.new_NCollection_Sequence_BRepExtrema_SolutionElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_BRepExtrema_SolutionElem self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_BRepExtrema_SolutionElem self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_BRepExtrema_SolutionElem self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_BRepExtrema_SolutionElem self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_BRepExtrema_SolutionElem self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_BRepExtrema_SolutionElem self)

        Reverse sequence


        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_BRepExtrema_SolutionElem self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence_BRepExtrema_SolutionElem theOther) -> NCollection_Sequence_BRepExtrema_SolutionElem

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence_BRepExtrema_SolutionElem theOther) -> NCollection_Sequence_BRepExtrema_SolutionElem

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence< BRepExtrema_SolutionElem >::Iterator & thePosition)
        Remove(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_BRepExtrema_SolutionElem self, BRepExtrema_SolutionElem theItem)
        Append(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence_BRepExtrema_SolutionElem theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_BRepExtrema_SolutionElem self, BRepExtrema_SolutionElem theItem)
        Prepend(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence_BRepExtrema_SolutionElem theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, BRepExtrema_SolutionElem theItem)
        InsertBefore(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, NCollection_Sequence_BRepExtrema_SolutionElem theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_BRepExtrema_SolutionElem self, NCollection_Sequence< BRepExtrema_SolutionElem >::Iterator & thePosition, BRepExtrema_SolutionElem theItem)
        InsertAfter(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, NCollection_Sequence_BRepExtrema_SolutionElem theSeq)
        InsertAfter(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, BRepExtrema_SolutionElem theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, NCollection_Sequence_BRepExtrema_SolutionElem theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_BRepExtrema_SolutionElem self) -> BRepExtrema_SolutionElem

        First item access

        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_BRepExtrema_SolutionElem self) -> BRepExtrema_SolutionElem

        Last item access

        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex) -> BRepExtrema_SolutionElem

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_BRepExtrema_SolutionElem self, Standard_Integer const theIndex, BRepExtrema_SolutionElem theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_SetValue(self, *args)


    def __iter__(self):
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem___iter__(self)
    __swig_destroy__ = _BRepExtrema.delete_NCollection_Sequence_BRepExtrema_SolutionElem
NCollection_Sequence_BRepExtrema_SolutionElem_swigregister = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_swigregister
NCollection_Sequence_BRepExtrema_SolutionElem_swigregister(NCollection_Sequence_BRepExtrema_SolutionElem)

def NCollection_Sequence_BRepExtrema_SolutionElem_delNode(*args):
    """
    NCollection_Sequence_BRepExtrema_SolutionElem_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_delNode(*args)

class NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepExtrema.new_NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepExtrema.delete_NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper

    def __next__(self):
        return _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper___next__(self)
NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper_swigregister = _BRepExtrema.NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper_swigregister
NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper_swigregister(NCollection_Sequence_BRepExtrema_SolutionElem_IteratorHelper)


try:
	BRepExtrema_SeqOfSolution = NCollection_Sequence_BRepExtrema_SolutionElem
except NameError:
	pass # does not exist, probably ignored

class BRepExtrema_ExtCF(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ExtCF self) -> BRepExtrema_ExtCF
        __init__(BRepExtrema_ExtCF self, TopoDS_Edge E, TopoDS_Face F) -> BRepExtrema_ExtCF

        It calculates all the distances. <br>

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepExtrema.new_BRepExtrema_ExtCF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepExtrema_ExtCF self, TopoDS_Edge E, TopoDS_Face F)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepExtrema.BRepExtrema_ExtCF_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ExtCF self, TopoDS_Edge E, TopoDS_Face F)

        An exception is raised if the fields have not been initialized. <br>
        Be careful: this method uses the Face only for classify not for the fields. <br>

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepExtrema.BRepExtrema_ExtCF_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ExtCF self) -> Standard_Boolean

        True if the distances are found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtCF_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(BRepExtrema_ExtCF self) -> Standard_Integer

        Returns the number of extremum distances. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_ExtCF_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(BRepExtrema_ExtCF self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtCF_SquareDistance(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(BRepExtrema_ExtCF self) -> Standard_Boolean

        Returns True if the curve is on a parallel surface. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtCF_IsParallel(self, *args)


    def ParameterOnEdge(self, *args):
        """
        ParameterOnEdge(BRepExtrema_ExtCF self, Standard_Integer const N) -> Standard_Real

        Returns the parameters on the Edge of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtCF_ParameterOnEdge(self, *args)


    def ParameterOnFace(self, *args):
        """
        ParameterOnFace(BRepExtrema_ExtCF self, Standard_Integer const N)

        Returns the parameters on the Face of the <N>th extremum distance. <br>

        :type N: int
        :type U: float
        :type V: float

        """
        return _BRepExtrema.BRepExtrema_ExtCF_ParameterOnFace(self, *args)


    def PointOnEdge(self, *args):
        """
        PointOnEdge(BRepExtrema_ExtCF self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtCF_PointOnEdge(self, *args)


    def PointOnFace(self, *args):
        """
        PointOnFace(BRepExtrema_ExtCF self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtCF_PointOnFace(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ExtCF
BRepExtrema_ExtCF_swigregister = _BRepExtrema.BRepExtrema_ExtCF_swigregister
BRepExtrema_ExtCF_swigregister(BRepExtrema_ExtCF)

class BRepExtrema_TriangleSet(object):
    """Triangle set corresponding to specific face."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_TriangleSet self) -> BRepExtrema_TriangleSet
        __init__(BRepExtrema_TriangleSet self, NCollection_Vector_TopoDS_Face theFaces) -> BRepExtrema_TriangleSet

        Creates triangle set from the given face.

        :type theFaces: OCC.wrapper.BRepExtrema.BRepExtrema_ShapeList

        """
        this = _BRepExtrema.new_BRepExtrema_TriangleSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(BRepExtrema_TriangleSet self) -> Standard_Integer

        Returns total number of triangles.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Size(self, *args)


    def Box(self, *args):
        """
        Box(BRepExtrema_TriangleSet self, Standard_Integer const theIndex) -> BVH_Box_Standard_Real_

        Returns AABB of the given triangle.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepExtrema.BVH_Box_Standard_Real

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Box(self, *args)


    def Center(self, *args):
        """
        Center(BRepExtrema_TriangleSet self, Standard_Integer const theIndex, Standard_Integer const theAxis) -> Standard_Real

        Returns centroid position along specified axis.

        :type theIndex: int
        :type theAxis: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Center(self, *args)


    def Swap(self, *args):
        """
        Swap(BRepExtrema_TriangleSet self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps indices of two specified triangles.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Swap(self, *args)


    def Clear(self, *args):
        """
        Clear(BRepExtrema_TriangleSet self)

        Clears triangle set data.


        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Clear(self, *args)


    def Init(self, *args):
        """
        Init(BRepExtrema_TriangleSet self, NCollection_Vector_TopoDS_Face theFaces) -> Standard_Boolean

        Initializes triangle set.

        :type theFaces: OCC.wrapper.BRepExtrema.BRepExtrema_ShapeList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_Init(self, *args)


    def GetVertices(self, *args):
        """
        GetVertices(BRepExtrema_TriangleSet self, Standard_Integer const theIndex, BVH_Vec3d & theVertex1, BVH_Vec3d & theVertex2, BVH_Vec3d & theVertex3)

        Returns vertices of the given triangle.

        :type theIndex: int
        :type theVertex1: OCC.wrapper.BVH.BVH_Vec3d
        :type theVertex2: OCC.wrapper.BVH.BVH_Vec3d
        :type theVertex3: OCC.wrapper.BVH.BVH_Vec3d

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_GetVertices(self, *args)


    def GetFaceID(self, *args):
        """
        GetFaceID(BRepExtrema_TriangleSet self, Standard_Integer const theIndex) -> Standard_Integer

        Returns face ID of the given triangle.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_GetFaceID(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepExtrema.BRepExtrema_TriangleSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.BRepExtrema_TriangleSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_TriangleSet
BRepExtrema_TriangleSet_swigregister = _BRepExtrema.BRepExtrema_TriangleSet_swigregister
BRepExtrema_TriangleSet_swigregister(BRepExtrema_TriangleSet)

def BRepExtrema_TriangleSet_get_type_name(*args):
    """
    BRepExtrema_TriangleSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepExtrema.BRepExtrema_TriangleSet_get_type_name(*args)

def BRepExtrema_TriangleSet_get_type_descriptor(*args):
    """
    BRepExtrema_TriangleSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepExtrema.BRepExtrema_TriangleSet_get_type_descriptor(*args)

class BRepExtrema_ExtPF(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ExtPF self) -> BRepExtrema_ExtPF
        __init__(BRepExtrema_ExtPF self, TopoDS_Vertex TheVertex, TopoDS_Face TheFace, Extrema_ExtFlag const TheFlag=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const TheAlgo=Extrema_ExtAlgo_Grad) -> BRepExtrema_ExtPF

        It calculates all the distances. <br>

        :type TheVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TheFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type TheFlag: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type TheAlgo: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _BRepExtrema.new_BRepExtrema_ExtPF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepExtrema_ExtPF self, TopoDS_Face TheFace, Extrema_ExtFlag const TheFlag=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const TheAlgo=Extrema_ExtAlgo_Grad)

        :type TheFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type TheFlag: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type TheAlgo: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _BRepExtrema.BRepExtrema_ExtPF_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ExtPF self, TopoDS_Vertex TheVertex, TopoDS_Face TheFace)

        An exception is raised if the fields have not been initialized. <br>
        Be careful: this method uses the Face only for classify not for the fields. <br>

        :type TheVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type TheFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepExtrema.BRepExtrema_ExtPF_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ExtPF self) -> Standard_Boolean

        True if the distances are found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtPF_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(BRepExtrema_ExtPF self) -> Standard_Integer

        Returns the number of extremum distances. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_ExtPF_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(BRepExtrema_ExtPF self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtPF_SquareDistance(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BRepExtrema_ExtPF self, Standard_Integer const N)

        Returns the parameters on the Face of the <N>th extremum distance. <br>

        :type N: int
        :type U: float
        :type V: float

        """
        return _BRepExtrema.BRepExtrema_ExtPF_Parameter(self, *args)


    def Point(self, *args):
        """
        Point(BRepExtrema_ExtPF self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtPF_Point(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(BRepExtrema_ExtPF self, Extrema_ExtFlag const F)

        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _BRepExtrema.BRepExtrema_ExtPF_SetFlag(self, *args)


    def SetAlgo(self, *args):
        """
        SetAlgo(BRepExtrema_ExtPF self, Extrema_ExtAlgo const A)

        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _BRepExtrema.BRepExtrema_ExtPF_SetAlgo(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ExtPF
BRepExtrema_ExtPF_swigregister = _BRepExtrema.BRepExtrema_ExtPF_swigregister
BRepExtrema_ExtPF_swigregister(BRepExtrema_ExtPF)

class BRepExtrema_DistShapeShape(object):
    """
    This class  provides tools to compute minimum distance <br>
    between two Shapes (Compound,CompSolid, Solid, Shell, Face, Wire, Edge, Vertex). <br>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_DistShapeShape self) -> BRepExtrema_DistShapeShape
        __init__(BRepExtrema_DistShapeShape self, TopoDS_Shape Shape1, TopoDS_Shape Shape2, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> BRepExtrema_DistShapeShape
        __init__(BRepExtrema_DistShapeShape self, TopoDS_Shape Shape1, TopoDS_Shape Shape2, Standard_Real const theDeflection, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> BRepExtrema_DistShapeShape

        create tool and load both shapes into it <br>

        :type Shape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Shape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDeflection: float
        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _BRepExtrema.new_BRepExtrema_DistShapeShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDeflection(self, *args):
        """
        SetDeflection(BRepExtrema_DistShapeShape self, Standard_Real const theDeflection)

        :type theDeflection: float

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SetDeflection(self, *args)


    def LoadS1(self, *args):
        """
        LoadS1(BRepExtrema_DistShapeShape self, TopoDS_Shape Shape1)

        load first shape into extrema <br>

        :type Shape1: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_LoadS1(self, *args)


    def LoadS2(self, *args):
        """
        LoadS2(BRepExtrema_DistShapeShape self, TopoDS_Shape Shape1)

        load second shape into extrema <br>

        :type Shape1: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_LoadS2(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_DistShapeShape self) -> Standard_Boolean

        computation of  the minimum  distance  (value  and <br>
        couple  of points). Parameter theDeflection is used <br>
        to specify a maximum deviation of extreme distances <br>
        from the minimum one. <br>
        Returns IsDone status. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_DistShapeShape self) -> Standard_Boolean

        True if the minimum distance is found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_IsDone(self, *args)


    def NbSolution(self, *args):
        """
        NbSolution(BRepExtrema_DistShapeShape self) -> Standard_Integer

        Returns the number of solutions satisfying the minimum distance. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_NbSolution(self, *args)


    def Value(self, *args):
        """
        Value(BRepExtrema_DistShapeShape self) -> Standard_Real

        Returns the value of the minimum distance. <br>

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_Value(self, *args)


    def InnerSolution(self, *args):
        """
        InnerSolution(BRepExtrema_DistShapeShape self) -> Standard_Boolean

        True if one of the shapes is a solid and the other shape <br>
        is completely or partially inside the solid. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_InnerSolution(self, *args)


    def PointOnShape1(self, *args):
        """
        Returns the Point corresponding to the <N>th solution on the first Shape <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepExtrema.BRepExtrema_DistShapeShape_PointOnShape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PointOnShape2(self, *args):
        """
        Returns the Point corresponding to the <N>th solution on the second Shape <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _BRepExtrema.BRepExtrema_DistShapeShape_PointOnShape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SupportTypeShape1(self, *args):
        """
        SupportTypeShape1(BRepExtrema_DistShapeShape self, Standard_Integer const N) -> BRepExtrema_SupportType

        gives the type of the support where the Nth solution on the first shape is situated: <br>
        IsVertex => the Nth solution on the first shape is a Vertex <br>
        IsOnEdge => the Nth soluion on the first shape is on a Edge <br>
        IsInFace => the Nth solution on the first shape is inside a face <br>
        the corresponding support is obtained by the method SupportOnShape1 <br>

        :type N: int
        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_SupportType

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SupportTypeShape1(self, *args)


    def SupportTypeShape2(self, *args):
        """
        SupportTypeShape2(BRepExtrema_DistShapeShape self, Standard_Integer const N) -> BRepExtrema_SupportType

        gives the type of the support where the Nth solution on the second shape is situated: <br>
        IsVertex => the Nth solution on the second shape is a Vertex <br>
        IsOnEdge => the Nth soluion on the secondt shape is on a Edge <br>
        IsInFace => the Nth solution on the second shape is inside a face <br>
        the corresponding support is obtained by the method SupportOnShape2 <br>

        :type N: int
        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_SupportType

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SupportTypeShape2(self, *args)


    def SupportOnShape1(self, *args):
        """
        SupportOnShape1(BRepExtrema_DistShapeShape self, Standard_Integer const N) -> TopoDS_Shape

        gives the support where the Nth solution on the first shape is situated. <br>
        This support can be a Vertex, an Edge or a Face. <br>

        :type N: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SupportOnShape1(self, *args)


    def SupportOnShape2(self, *args):
        """
        SupportOnShape2(BRepExtrema_DistShapeShape self, Standard_Integer const N) -> TopoDS_Shape

        gives the support where the Nth solution on the second shape is situated. <br>
        This support can be a Vertex, an Edge or a Face. <br>

        :type N: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SupportOnShape2(self, *args)


    def ParOnEdgeS1(self, *args):
        """
        ParOnEdgeS1(BRepExtrema_DistShapeShape self, Standard_Integer const N)

        gives the corresponding parameter t if the Nth solution <br>
        is situated on an Egde of the first shape <br>

        :type N: int
        :type t: float

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_ParOnEdgeS1(self, *args)


    def ParOnEdgeS2(self, *args):
        """
        ParOnEdgeS2(BRepExtrema_DistShapeShape self, Standard_Integer const N)

        gives the corresponding parameter t if the Nth solution <br>
        is situated on an Egde of the first shape <br>

        :type N: int
        :type t: float

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_ParOnEdgeS2(self, *args)


    def ParOnFaceS1(self, *args):
        """
        ParOnFaceS1(BRepExtrema_DistShapeShape self, Standard_Integer const N)

        gives the corresponding parameters (U,V) if the Nth solution <br>
        is situated on an face of the first shape <br>

        :type N: int
        :type u: float
        :type v: float

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_ParOnFaceS1(self, *args)


    def ParOnFaceS2(self, *args):
        """
        ParOnFaceS2(BRepExtrema_DistShapeShape self, Standard_Integer const N)

        gives the corresponding parameters (U,V) if the Nth solution <br>
        is situated on an Face of the second shape <br>

        :type N: int
        :type u: float
        :type v: float

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_ParOnFaceS2(self, *args)


    def Dump(self, *args):
        """
        Dump(BRepExtrema_DistShapeShape self, Standard_OStream & o)

        Prints on the stream o information on the current state of the object. <br>

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_Dump(self, *args)


    def SetFlag(self, *args):
        """
        SetFlag(BRepExtrema_DistShapeShape self, Extrema_ExtFlag const F)

        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SetFlag(self, *args)


    def SetAlgo(self, *args):
        """
        SetAlgo(BRepExtrema_DistShapeShape self, Extrema_ExtAlgo const A)

        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _BRepExtrema.BRepExtrema_DistShapeShape_SetAlgo(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_DistShapeShape
BRepExtrema_DistShapeShape_swigregister = _BRepExtrema.BRepExtrema_DistShapeShape_swigregister
BRepExtrema_DistShapeShape_swigregister(BRepExtrema_DistShapeShape)

class BRepExtrema_ShapeProximity(object):
    """
    Tool class for shape proximity detection.
    For two given shapes and given tolerance (offset from the mesh) the algorithm allows
    to determine whether or not they are overlapped. The algorithm input consists of any
    shapes which can be decomposed into individual faces (used as basic shape elements).
    High performance is achieved through the use of existing triangulation of faces. So
    poly triangulation (with the desired deflection) should already be built. Note that
    solution is approximate (and corresponds to the deflection used for triangulation).

    The algorithm can be run in two modes. If tolerance is set to zero, the algorithm
    will detect only intersecting faces (containing triangles with common points). If
    tolerance is set to positive value, the algorithm will also detect faces located
    on distance less than the given tolerance from each other.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ShapeProximity self, Standard_Real const theTolerance=0.0) -> BRepExtrema_ShapeProximity
        __init__(BRepExtrema_ShapeProximity self, TopoDS_Shape theShape1, TopoDS_Shape theShape2, Standard_Real const theTolerance=0.0) -> BRepExtrema_ShapeProximity

        Creates proximity tool for the given two shapes.

        :type theShape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theTolerance: float

        """
        this = _BRepExtrema.new_BRepExtrema_ShapeProximity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Tolerance(self, *args):
        """
        Tolerance(BRepExtrema_ShapeProximity self) -> Standard_Real

        Returns tolerance value for overlap test (distance between shapes).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_Tolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepExtrema_ShapeProximity self, Standard_Real const theTolerance)

        Sets tolerance value for overlap test (distance between shapes).

        :type theTolerance: float

        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_SetTolerance(self, *args)


    def LoadShape1(self, *args):
        """
        LoadShape1(BRepExtrema_ShapeProximity self, TopoDS_Shape theShape1) -> Standard_Boolean

        Loads 1st shape into proximity tool.

        :type theShape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_LoadShape1(self, *args)


    def LoadShape2(self, *args):
        """
        LoadShape2(BRepExtrema_ShapeProximity self, TopoDS_Shape theShape2) -> Standard_Boolean

        Loads 2nd shape into proximity tool.

        :type theShape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_LoadShape2(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ShapeProximity self)

        Performs search of overlapped faces.


        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ShapeProximity self) -> Standard_Boolean

        True if the search is completed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ShapeProximity_IsDone(self, *args)


    def OverlapSubShapes1(self, *args):
        """
        Returns set of IDs of overlapped faces of 1st shape (started from 0).

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_MapOfIntegerPackedMapOfInteger

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_OverlapSubShapes1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OverlapSubShapes2(self, *args):
        """
        Returns set of IDs of overlapped faces of 2nd shape (started from 0).

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_MapOfIntegerPackedMapOfInteger

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_OverlapSubShapes2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSubShape1(self, *args):
        """
        Returns sub-shape from 1st shape with the given index (started from 0).

        :type theID: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_GetSubShape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSubShape2(self, *args):
        """
        Returns sub-shape from 1st shape with the given index (started from 0).

        :type theID: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_GetSubShape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElementSet1(self, *args):
        """
        Returns set of all the face triangles of the 1st shape.

        :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_TriangleSet

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_ElementSet1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElementSet2(self, *args):
        """
        Returns set of all the face triangles of the 2nd shape.

        :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_TriangleSet

        """
        res = _BRepExtrema.BRepExtrema_ShapeProximity_ElementSet2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ShapeProximity
BRepExtrema_ShapeProximity_swigregister = _BRepExtrema.BRepExtrema_ShapeProximity_swigregister
BRepExtrema_ShapeProximity_swigregister(BRepExtrema_ShapeProximity)

class Handle_BRepExtrema_TriangleSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepExtrema_TriangleSet self)

        Nullify the handle


        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepExtrema_TriangleSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepExtrema_TriangleSet self, BRepExtrema_TriangleSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepExtrema_TriangleSet self, Handle_BRepExtrema_TriangleSet theHandle) -> Handle_BRepExtrema_TriangleSet
        assign(Handle_BRepExtrema_TriangleSet self, BRepExtrema_TriangleSet thePtr) -> Handle_BRepExtrema_TriangleSet
        assign(Handle_BRepExtrema_TriangleSet self, Handle_BRepExtrema_TriangleSet theHandle) -> Handle_BRepExtrema_TriangleSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepExtrema_TriangleSet self) -> BRepExtrema_TriangleSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepExtrema_TriangleSet self) -> BRepExtrema_TriangleSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepExtrema_TriangleSet self) -> BRepExtrema_TriangleSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet___ref__(self, *args)


    def __hash__(self):
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepExtrema.Handle_BRepExtrema_TriangleSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepExtrema.new_Handle_BRepExtrema_TriangleSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepExtrema.Handle_BRepExtrema_TriangleSet_DownCast)
    __swig_destroy__ = _BRepExtrema.delete_Handle_BRepExtrema_TriangleSet

    def Size(self, *args):
        """
        Size(Handle_BRepExtrema_TriangleSet self) -> Standard_Integer

        Returns total number of triangles.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Size(self, *args)


    def Box(self, *args):
        """
        Box(Handle_BRepExtrema_TriangleSet self, Standard_Integer const theIndex) -> BVH_Box_Standard_Real_

        Returns AABB of the given triangle.

        :type theIndex: int
        :rtype: OCC.wrapper.BRepExtrema.BVH_Box_Standard_Real

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Box(self, *args)


    def Center(self, *args):
        """
        Center(Handle_BRepExtrema_TriangleSet self, Standard_Integer const theIndex, Standard_Integer const theAxis) -> Standard_Real

        Returns centroid position along specified axis.

        :type theIndex: int
        :type theAxis: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Center(self, *args)


    def Swap(self, *args):
        """
        Swap(Handle_BRepExtrema_TriangleSet self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps indices of two specified triangles.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Swap(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_BRepExtrema_TriangleSet self)

        Clears triangle set data.


        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Clear(self, *args)


    def Init(self, *args):
        """
        Init(Handle_BRepExtrema_TriangleSet self, NCollection_Vector_TopoDS_Face theFaces) -> Standard_Boolean

        Initializes triangle set.

        :type theFaces: OCC.wrapper.BRepExtrema.BRepExtrema_ShapeList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_Init(self, *args)


    def GetVertices(self, *args):
        """
        GetVertices(Handle_BRepExtrema_TriangleSet self, Standard_Integer const theIndex, BVH_Vec3d & theVertex1, BVH_Vec3d & theVertex2, BVH_Vec3d & theVertex3)

        Returns vertices of the given triangle.

        :type theIndex: int
        :type theVertex1: OCC.wrapper.BVH.BVH_Vec3d
        :type theVertex2: OCC.wrapper.BVH.BVH_Vec3d
        :type theVertex3: OCC.wrapper.BVH.BVH_Vec3d

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_GetVertices(self, *args)


    def GetFaceID(self, *args):
        """
        GetFaceID(Handle_BRepExtrema_TriangleSet self, Standard_Integer const theIndex) -> Standard_Integer

        Returns face ID of the given triangle.

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_GetFaceID(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepExtrema_TriangleSet self) -> char const *

        :rtype: const char *

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.Handle_BRepExtrema_TriangleSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.Handle_BRepExtrema_TriangleSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVH(self, *args):
        """
        Returns BVH tree (and builds it if necessary).

        :rtype: OCC.wrapper.BVH.Handle_BVH_Tree_T

        """
        res = _BRepExtrema.Handle_BRepExtrema_TriangleSet_BVH(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Builder(self, *args):
        """
        Returns the method (builder) used to construct BVH.

        :rtype: OCC.wrapper.BVH.Handle_BVH_Builder_T

        """
        res = _BRepExtrema.Handle_BRepExtrema_TriangleSet_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBuilder(self, *args):
        """
        SetBuilder(Handle_BRepExtrema_TriangleSet self, opencascade::handle< BVH_Builder< double,3 > > const & theBuilder)

        Sets the method (builder) used to construct BVH.

        :type theBuilder: OCC.wrapper.BVH.Handle_BVH_Builder_T

        """
        return _BRepExtrema.Handle_BRepExtrema_TriangleSet_SetBuilder(self, *args)

Handle_BRepExtrema_TriangleSet_swigregister = _BRepExtrema.Handle_BRepExtrema_TriangleSet_swigregister
Handle_BRepExtrema_TriangleSet_swigregister(Handle_BRepExtrema_TriangleSet)

def Handle_BRepExtrema_TriangleSet_DownCast(thing):
    return _BRepExtrema.Handle_BRepExtrema_TriangleSet_DownCast(thing)
Handle_BRepExtrema_TriangleSet_DownCast = _BRepExtrema.Handle_BRepExtrema_TriangleSet_DownCast

class Handle_BRepExtrema_UnCompatibleShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepExtrema_UnCompatibleShape self)

        Nullify the handle


        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepExtrema_UnCompatibleShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepExtrema_UnCompatibleShape self, BRepExtrema_UnCompatibleShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepExtrema_UnCompatibleShape self, Handle_BRepExtrema_UnCompatibleShape theHandle) -> Handle_BRepExtrema_UnCompatibleShape
        assign(Handle_BRepExtrema_UnCompatibleShape self, BRepExtrema_UnCompatibleShape thePtr) -> Handle_BRepExtrema_UnCompatibleShape
        assign(Handle_BRepExtrema_UnCompatibleShape self, Handle_BRepExtrema_UnCompatibleShape theHandle) -> Handle_BRepExtrema_UnCompatibleShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepExtrema_UnCompatibleShape self) -> BRepExtrema_UnCompatibleShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepExtrema_UnCompatibleShape self) -> BRepExtrema_UnCompatibleShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepExtrema_UnCompatibleShape self) -> BRepExtrema_UnCompatibleShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape___ref__(self, *args)


    def __hash__(self):
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepExtrema.new_Handle_BRepExtrema_UnCompatibleShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_DownCast)
    __swig_destroy__ = _BRepExtrema.delete_Handle_BRepExtrema_UnCompatibleShape

    def NewInstance(self, *args):
        """
        NewInstance(Handle_BRepExtrema_UnCompatibleShape self, Standard_CString const theMessage) -> Handle_BRepExtrema_UnCompatibleShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_UnCompatibleShape

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepExtrema_UnCompatibleShape self) -> char const *

        :rtype: const char *

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_BRepExtrema_UnCompatibleShape self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_BRepExtrema_UnCompatibleShape self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_BRepExtrema_UnCompatibleShape self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_BRepExtrema_UnCompatibleShape self)
        Reraise(Handle_BRepExtrema_UnCompatibleShape self, Standard_CString const aMessage)
        Reraise(Handle_BRepExtrema_UnCompatibleShape self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_BRepExtrema_UnCompatibleShape self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_BRepExtrema_UnCompatibleShape self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepExtrema_UnCompatibleShape self)

        Memory deallocator for transient classes


        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepExtrema_UnCompatibleShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepExtrema_UnCompatibleShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepExtrema_UnCompatibleShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepExtrema_UnCompatibleShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepExtrema_UnCompatibleShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepExtrema_UnCompatibleShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepExtrema_UnCompatibleShape self)

        Increments the reference counter of this object


        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepExtrema_UnCompatibleShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_DecrementRefCounter(self, *args)

Handle_BRepExtrema_UnCompatibleShape_swigregister = _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_swigregister
Handle_BRepExtrema_UnCompatibleShape_swigregister(Handle_BRepExtrema_UnCompatibleShape)

def Handle_BRepExtrema_UnCompatibleShape_DownCast(thing):
    return _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_DownCast(thing)
Handle_BRepExtrema_UnCompatibleShape_DownCast = _BRepExtrema.Handle_BRepExtrema_UnCompatibleShape_DownCast

class BRepExtrema_ExtPC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ExtPC self) -> BRepExtrema_ExtPC
        __init__(BRepExtrema_ExtPC self, TopoDS_Vertex V, TopoDS_Edge E) -> BRepExtrema_ExtPC

        It calculates all the distances. <br>

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _BRepExtrema.new_BRepExtrema_ExtPC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepExtrema_ExtPC self, TopoDS_Edge E)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepExtrema.BRepExtrema_ExtPC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ExtPC self, TopoDS_Vertex V)

        An exception is raised if the fields have not been initialized. <br>

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepExtrema.BRepExtrema_ExtPC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ExtPC self) -> Standard_Boolean

        True if the distances are found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtPC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(BRepExtrema_ExtPC self) -> Standard_Integer

        Returns the number of extremum distances. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_ExtPC_NbExt(self, *args)


    def IsMin(self, *args):
        """
        IsMin(BRepExtrema_ExtPC self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the <N>th extremum distance is a minimum. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtPC_IsMin(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(BRepExtrema_ExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtPC_SquareDistance(self, *args)


    def Parameter(self, *args):
        """
        Parameter(BRepExtrema_ExtPC self, Standard_Integer const N) -> Standard_Real

        Returns the parameter on the edge of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtPC_Parameter(self, *args)


    def Point(self, *args):
        """
        Point(BRepExtrema_ExtPC self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtPC_Point(self, *args)


    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(BRepExtrema_ExtPC self, gp_Pnt pnt1, gp_Pnt pnt2)

        if the curve is a trimmed curve, <br>
        dist1 is a square distance between <P> and the point <br>
        of parameter FirstParameter <pnt1> and <br>
        dist2 is a square distance between <P> and the point <br>
        of parameter LastParameter <pnt2>. <br>

        :type dist1: float
        :type dist2: float
        :type pnt1: OCC.wrapper.gp.gp_Pnt
        :type pnt2: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtPC_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ExtPC
BRepExtrema_ExtPC_swigregister = _BRepExtrema.BRepExtrema_ExtPC_swigregister
BRepExtrema_ExtPC_swigregister(BRepExtrema_ExtPC)

class BRepExtrema_ExtCC(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ExtCC self) -> BRepExtrema_ExtCC
        __init__(BRepExtrema_ExtCC self, TopoDS_Edge E1, TopoDS_Edge E2) -> BRepExtrema_ExtCC

        It calculates all the distances. <br>

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _BRepExtrema.new_BRepExtrema_ExtCC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepExtrema_ExtCC self, TopoDS_Edge E2)

        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepExtrema.BRepExtrema_ExtCC_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ExtCC self, TopoDS_Edge E1)

        An exception is raised if the fields have not been initialized. <br>

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepExtrema.BRepExtrema_ExtCC_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ExtCC self) -> Standard_Boolean

        True if the distances are found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtCC_IsDone(self, *args)


    def NbExt(self, *args):
        """
        NbExt(BRepExtrema_ExtCC self) -> Standard_Integer

        Returns the number of extremum distances. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_ExtCC_NbExt(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(BRepExtrema_ExtCC self) -> Standard_Boolean

        Returns True if E1 and E2 are parallel. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtCC_IsParallel(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(BRepExtrema_ExtCC self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtCC_SquareDistance(self, *args)


    def ParameterOnE1(self, *args):
        """
        ParameterOnE1(BRepExtrema_ExtCC self, Standard_Integer const N) -> Standard_Real

        Returns the parameter on the first edge of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtCC_ParameterOnE1(self, *args)


    def PointOnE1(self, *args):
        """
        PointOnE1(BRepExtrema_ExtCC self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance on the edge E1. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtCC_PointOnE1(self, *args)


    def ParameterOnE2(self, *args):
        """
        ParameterOnE2(BRepExtrema_ExtCC self, Standard_Integer const N) -> Standard_Real

        Returns the parameter on the second edge of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtCC_ParameterOnE2(self, *args)


    def PointOnE2(self, *args):
        """
        PointOnE2(BRepExtrema_ExtCC self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance on the edge E2. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtCC_PointOnE2(self, *args)


    def TrimmedSquareDistances(self, *args):
        """
        TrimmedSquareDistances(BRepExtrema_ExtCC self, gp_Pnt P11, gp_Pnt P12, gp_Pnt P21, gp_Pnt P22)

        if the edges is a trimmed curve, <br>
        dist11 is a square distance between the point on E1 <br>
        of parameter FirstParameter and the point of <br>
        parameter FirstParameter on E2. <br>

        :type dist11: float
        :type distP12: float
        :type distP21: float
        :type distP22: float
        :type P11: OCC.wrapper.gp.gp_Pnt
        :type P12: OCC.wrapper.gp.gp_Pnt
        :type P21: OCC.wrapper.gp.gp_Pnt
        :type P22: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtCC_TrimmedSquareDistances(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ExtCC
BRepExtrema_ExtCC_swigregister = _BRepExtrema.BRepExtrema_ExtCC_swigregister
BRepExtrema_ExtCC_swigregister(BRepExtrema_ExtCC)

class BRepExtrema_ExtFF(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_ExtFF self) -> BRepExtrema_ExtFF
        __init__(BRepExtrema_ExtFF self, TopoDS_Face F1, TopoDS_Face F2) -> BRepExtrema_ExtFF

        It calculates all the distances. <br>

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepExtrema.new_BRepExtrema_ExtFF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepExtrema_ExtFF self, TopoDS_Face F2)

        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepExtrema.BRepExtrema_ExtFF_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_ExtFF self, TopoDS_Face F1, TopoDS_Face F2)

        An exception is raised if the fields have not been initialized. <br>
        Be careful: this method uses the Face F2 only for classify, not for the fields. <br>

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepExtrema.BRepExtrema_ExtFF_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_ExtFF self) -> Standard_Boolean

        True if the distances are found. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtFF_IsDone(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(BRepExtrema_ExtFF self) -> Standard_Boolean

        Returns True if the surfaces are parallel. <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_ExtFF_IsParallel(self, *args)


    def NbExt(self, *args):
        """
        NbExt(BRepExtrema_ExtFF self) -> Standard_Integer

        Returns the number of extremum distances. <br>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepExtrema.BRepExtrema_ExtFF_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(BRepExtrema_ExtFF self, Standard_Integer const N) -> Standard_Real

        Returns the value of the <N>th extremum square distance. <br>

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_ExtFF_SquareDistance(self, *args)


    def ParameterOnFace1(self, *args):
        """
        ParameterOnFace1(BRepExtrema_ExtFF self, Standard_Integer const N)

        Returns the parameters on the Face F1 of the <N>th extremum distance. <br>

        :type N: int
        :type U: float
        :type V: float

        """
        return _BRepExtrema.BRepExtrema_ExtFF_ParameterOnFace1(self, *args)


    def ParameterOnFace2(self, *args):
        """
        ParameterOnFace2(BRepExtrema_ExtFF self, Standard_Integer const N)

        Returns the parameters on the Face F2 of the <N>th extremum distance. <br>

        :type N: int
        :type U: float
        :type V: float

        """
        return _BRepExtrema.BRepExtrema_ExtFF_ParameterOnFace2(self, *args)


    def PointOnFace1(self, *args):
        """
        PointOnFace1(BRepExtrema_ExtFF self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtFF_PointOnFace1(self, *args)


    def PointOnFace2(self, *args):
        """
        PointOnFace2(BRepExtrema_ExtFF self, Standard_Integer const N) -> gp_Pnt

        Returns the Point of the <N>th extremum distance. <br>

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepExtrema.BRepExtrema_ExtFF_PointOnFace2(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_ExtFF
BRepExtrema_ExtFF_swigregister = _BRepExtrema.BRepExtrema_ExtFF_swigregister
BRepExtrema_ExtFF_swigregister(BRepExtrema_ExtFF)

class BRepExtrema_SelfIntersection(object):
    """
    Tool class for detection of self-sections in the given shape.
    This class is based on BRepExtrema_OverlapTool and thus uses
    shape tessellation to detect incorrect mesh fragments (pairs
    of overlapped triangles belonging to different faces). Thus,
    a result depends critically on the quality of mesh generator
    (e.g., BREP mesh is not always a good choice, because it can
    contain gaps between adjacent face triangulations, which may
    not share vertices on common edge; thus false overlap can be
    detected). As a result, this tool can be used for relatively
    fast approximated test which provides sub-set of potentially
    overlapped faces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_SelfIntersection self, Standard_Real const theTolerance=0.0) -> BRepExtrema_SelfIntersection
        __init__(BRepExtrema_SelfIntersection self, TopoDS_Shape theShape, Standard_Real const theTolerance=0.0) -> BRepExtrema_SelfIntersection

        Creates self-intersection tool for the given shape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theTolerance: float

        """
        this = _BRepExtrema.new_BRepExtrema_SelfIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Tolerance(self, *args):
        """
        Tolerance(BRepExtrema_SelfIntersection self) -> Standard_Real

        Returns tolerance value used for self-intersection test.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_SelfIntersection_Tolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepExtrema_SelfIntersection self, Standard_Real const theTolerance)

        Sets tolerance value used for self-intersection test.

        :type theTolerance: float

        """
        return _BRepExtrema.BRepExtrema_SelfIntersection_SetTolerance(self, *args)


    def LoadShape(self, *args):
        """
        LoadShape(BRepExtrema_SelfIntersection self, TopoDS_Shape theShape) -> Standard_Boolean

        Loads shape for detection of self-intersections.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_SelfIntersection_LoadShape(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepExtrema_SelfIntersection self)

        Performs detection of self-intersections.


        """
        return _BRepExtrema.BRepExtrema_SelfIntersection_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_SelfIntersection self) -> Standard_Boolean

        True if the detection is completed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_SelfIntersection_IsDone(self, *args)


    def OverlapElements(self, *args):
        """
        Returns set of IDs of overlapped sub-shapes (started from 0).

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_MapOfIntegerPackedMapOfInteger

        """
        res = _BRepExtrema.BRepExtrema_SelfIntersection_OverlapElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSubShape(self, *args):
        """
        Returns sub-shape from the shape for the given index (started from 0).

        :type theID: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepExtrema.BRepExtrema_SelfIntersection_GetSubShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElementSet(self, *args):
        """
        Returns set of all the face triangles of the shape.

        :rtype: OCC.wrapper.BRepExtrema.Handle_BRepExtrema_TriangleSet

        """
        res = _BRepExtrema.BRepExtrema_SelfIntersection_ElementSet(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_SelfIntersection
BRepExtrema_SelfIntersection_swigregister = _BRepExtrema.BRepExtrema_SelfIntersection_swigregister
BRepExtrema_SelfIntersection_swigregister(BRepExtrema_SelfIntersection)

class BRepExtrema_DistanceSS(object):
    """
    This class allows to compute minimum distance between two shapes <br>
    (face edge vertex) and is used in DistShapeShape class. <br>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepExtrema_DistanceSS self, TopoDS_Shape S1, TopoDS_Shape S2, Bnd_Box B1, Bnd_Box B2, Standard_Real const DstRef, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> BRepExtrema_DistanceSS
        __init__(BRepExtrema_DistanceSS self, TopoDS_Shape S1, TopoDS_Shape S2, Bnd_Box B1, Bnd_Box B2, Standard_Real const DstRef, Standard_Real const aDeflection, Extrema_ExtFlag const F=Extrema_ExtFlag_MINMAX, Extrema_ExtAlgo const A=Extrema_ExtAlgo_Grad) -> BRepExtrema_DistanceSS

        computes the distance between two Shapes ( face edge vertex). <br>
        Parameter theDeflection is used to specify a maximum deviation <br>
        of extreme distances from the minimum one. <br>
        Default value is Precision::Confusion(). <br>

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B1: OCC.wrapper.Bnd.Bnd_Box
        :type B2: OCC.wrapper.Bnd.Bnd_Box
        :type DstRef: float
        :type aDeflection: float
        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag
        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _BRepExtrema.new_BRepExtrema_DistanceSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(BRepExtrema_DistanceSS self) -> Standard_Boolean

        True if the distance has been computed <br>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepExtrema.BRepExtrema_DistanceSS_IsDone(self, *args)


    def DistValue(self, *args):
        """
        DistValue(BRepExtrema_DistanceSS self) -> Standard_Real

        returns the distance value <br>

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepExtrema.BRepExtrema_DistanceSS_DistValue(self, *args)


    def Seq1Value(self, *args):
        """
        returns the list of solutions on the first shape <br>

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_SeqOfSolution

        """
        res = _BRepExtrema.BRepExtrema_DistanceSS_Seq1Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Seq2Value(self, *args):
        """
        returns the list of solutions on the second shape <br>

        :rtype: OCC.wrapper.BRepExtrema.BRepExtrema_SeqOfSolution

        """
        res = _BRepExtrema.BRepExtrema_DistanceSS_Seq2Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFlag(self, *args):
        """
        SetFlag(BRepExtrema_DistanceSS self, Extrema_ExtFlag const F)

        sets the flag controlling minimum and maximum search

        :type F: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _BRepExtrema.BRepExtrema_DistanceSS_SetFlag(self, *args)


    def SetAlgo(self, *args):
        """
        SetAlgo(BRepExtrema_DistanceSS self, Extrema_ExtAlgo const A)

        sets the flag controlling ...

        :type A: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _BRepExtrema.BRepExtrema_DistanceSS_SetAlgo(self, *args)

    __swig_destroy__ = _BRepExtrema.delete_BRepExtrema_DistanceSS
BRepExtrema_DistanceSS_swigregister = _BRepExtrema.BRepExtrema_DistanceSS_swigregister
BRepExtrema_DistanceSS_swigregister(BRepExtrema_DistanceSS)




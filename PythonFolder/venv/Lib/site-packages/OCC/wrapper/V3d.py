# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_V3d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_V3d')
    _V3d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_V3d', [dirname(__file__)])
        except ImportError:
            import _V3d
            return _V3d
        try:
            _mod = imp.load_module('_V3d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _V3d = swig_import_helper()
    del swig_import_helper
else:
    import _V3d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _V3d.delete_SwigPyIterator

    def value(self):
        return _V3d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _V3d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _V3d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _V3d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _V3d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _V3d.SwigPyIterator_copy(self)

    def next(self):
        return _V3d.SwigPyIterator_next(self)

    def __next__(self):
        return _V3d.SwigPyIterator___next__(self)

    def previous(self):
        return _V3d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _V3d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _V3d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _V3d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _V3d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _V3d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _V3d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _V3d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _V3d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _V3d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_V3d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _V3d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _V3d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _V3d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _V3d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _V3d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _V3d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _V3d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_V3d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _V3d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _V3d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _V3d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _V3d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _V3d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _V3d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _V3d.ptr_to_number(item)
ptr_to_number = _V3d.ptr_to_number

def HashCode(*args):
    return _V3d.HashCode(*args)
HashCode = _V3d.HashCode

def ptr_equal(a, b):
    return _V3d.ptr_equal(a, b)
ptr_equal = _V3d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
V3d_Xpos = _V3d.V3d_Xpos
V3d_Ypos = _V3d.V3d_Ypos
V3d_Zpos = _V3d.V3d_Zpos
V3d_Xneg = _V3d.V3d_Xneg
V3d_Yneg = _V3d.V3d_Yneg
V3d_Zneg = _V3d.V3d_Zneg
V3d_XposYpos = _V3d.V3d_XposYpos
V3d_XposZpos = _V3d.V3d_XposZpos
V3d_YposZpos = _V3d.V3d_YposZpos
V3d_XnegYneg = _V3d.V3d_XnegYneg
V3d_XnegYpos = _V3d.V3d_XnegYpos
V3d_XnegZneg = _V3d.V3d_XnegZneg
V3d_XnegZpos = _V3d.V3d_XnegZpos
V3d_YnegZneg = _V3d.V3d_YnegZneg
V3d_YnegZpos = _V3d.V3d_YnegZpos
V3d_XposYneg = _V3d.V3d_XposYneg
V3d_XposZneg = _V3d.V3d_XposZneg
V3d_YposZneg = _V3d.V3d_YposZneg
V3d_XposYposZpos = _V3d.V3d_XposYposZpos
V3d_XposYnegZpos = _V3d.V3d_XposYnegZpos
V3d_XposYposZneg = _V3d.V3d_XposYposZneg
V3d_XnegYposZpos = _V3d.V3d_XnegYposZpos
V3d_XposYnegZneg = _V3d.V3d_XposYnegZneg
V3d_XnegYposZneg = _V3d.V3d_XnegYposZneg
V3d_XnegYnegZpos = _V3d.V3d_XnegYnegZpos
V3d_XnegYnegZneg = _V3d.V3d_XnegYnegZneg
V3d_POSITIONLIGHT = _V3d.V3d_POSITIONLIGHT
V3d_SPACELIGHT = _V3d.V3d_SPACELIGHT
V3d_RADIUSTEXTLIGHT = _V3d.V3d_RADIUSTEXTLIGHT
V3d_ExtRADIUSLIGHT = _V3d.V3d_ExtRADIUSLIGHT
V3d_IntRADIUSLIGHT = _V3d.V3d_IntRADIUSLIGHT
V3d_NOTHING = _V3d.V3d_NOTHING
V3d_SIMPLE = _V3d.V3d_SIMPLE
V3d_COMPLETE = _V3d.V3d_COMPLETE
V3d_PARTIAL = _V3d.V3d_PARTIAL
V3d_SAMELAST = _V3d.V3d_SAMELAST
V3d_SDO_MONO = _V3d.V3d_SDO_MONO
V3d_SDO_LEFT_EYE = _V3d.V3d_SDO_LEFT_EYE
V3d_SDO_RIGHT_EYE = _V3d.V3d_SDO_RIGHT_EYE
V3d_SDO_BLENDED = _V3d.V3d_SDO_BLENDED
V3d_X = _V3d.V3d_X
V3d_Y = _V3d.V3d_Y
V3d_Z = _V3d.V3d_Z
V3d_TOBM_AUTOMATIC = _V3d.V3d_TOBM_AUTOMATIC
V3d_TOBM_ALWAYS_DISPLAYED = _V3d.V3d_TOBM_ALWAYS_DISPLAYED
V3d_TOBM_NEVER_DISPLAYED = _V3d.V3d_TOBM_NEVER_DISPLAYED
V3d_ORTHOGRAPHIC = _V3d.V3d_ORTHOGRAPHIC
V3d_PERSPECTIVE = _V3d.V3d_PERSPECTIVE
V3d_WIREFRAME = _V3d.V3d_WIREFRAME
V3d_ZBUFFER = _V3d.V3d_ZBUFFER
V3d_POSITIONCAMERA = _V3d.V3d_POSITIONCAMERA
V3d_SPACECAMERA = _V3d.V3d_SPACECAMERA
V3d_RADIUSTEXTCAMERA = _V3d.V3d_RADIUSTEXTCAMERA
V3d_ExtRADIUSCAMERA = _V3d.V3d_ExtRADIUSCAMERA
V3d_IntRADIUSCAMERA = _V3d.V3d_IntRADIUSCAMERA
V3d_NOTHINGCAMERA = _V3d.V3d_NOTHINGCAMERA
class V3d_PositionLight(Graphic3d.Graphic3d_CLight):
    """Base class for Positional, Spot and Directional Light classes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_PositionLight
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_PositionLight(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_PositionLight_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_PositionLight_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_PositionLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _V3d.delete_V3d_PositionLight
V3d_PositionLight_swigregister = _V3d.V3d_PositionLight_swigregister
V3d_PositionLight_swigregister(V3d_PositionLight)

def V3d_PositionLight_get_type_name(*args):
    """
    V3d_PositionLight_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_PositionLight_get_type_name(*args)

def V3d_PositionLight_get_type_descriptor(*args):
    """
    V3d_PositionLight_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_PositionLight_get_type_descriptor(*args)

class V3d_PositionalLight(V3d_PositionLight):
    """
    Creation and modification of an isolated (positional) light source.
    It is also defined by the color and two attenuation factors ConstAttentuation() and LinearAttentuation().
    The resulting attenuation factor determining the illumination of a surface depends on the following formula:
    @code
    F = 1 / (ConstAttenuation() + LinearAttenuation() * Distance)
    @endcode
    Where Distance is the distance of the isolated source from the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_PositionalLight
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_PositionalLight(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_PositionalLight_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_PositionalLight_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_PositionalLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(V3d_PositionalLight self, gp_Pnt thePos, Quantity_Color theColor=Quantity_NOC_WHITE) -> V3d_PositionalLight
        __init__(V3d_PositionalLight self, Handle_V3d_Viewer theViewer, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Real const theConstAttenuation=1.0, Standard_Real const theLinearAttenuation=0.0) -> V3d_PositionalLight

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theX: float
        :type theY: float
        :type theZ: float
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        this = _V3d.new_V3d_PositionalLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _V3d.delete_V3d_PositionalLight
V3d_PositionalLight_swigregister = _V3d.V3d_PositionalLight_swigregister
V3d_PositionalLight_swigregister(V3d_PositionalLight)

def V3d_PositionalLight_get_type_name(*args):
    """
    V3d_PositionalLight_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_PositionalLight_get_type_name(*args)

def V3d_PositionalLight_get_type_descriptor(*args):
    """
    V3d_PositionalLight_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_PositionalLight_get_type_descriptor(*args)

class V3d_BadValue(Standard.Standard_OutOfRange):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_BadValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_BadValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(V3d_BadValue self) -> V3d_BadValue
        __init__(V3d_BadValue self, Standard_CString const theMessage) -> V3d_BadValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _V3d.new_V3d_BadValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_V3d_BadValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.V3d.Handle_V3d_BadValue

        """
        return _V3d.V3d_BadValue_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_BadValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_BadValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_BadValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _V3d.delete_V3d_BadValue
V3d_BadValue_swigregister = _V3d.V3d_BadValue_swigregister
V3d_BadValue_swigregister(V3d_BadValue)

def V3d_BadValue_NewInstance(*args):
    """
    V3d_BadValue_NewInstance(Standard_CString const theMessage) -> Handle_V3d_BadValue

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.V3d.Handle_V3d_BadValue

    """
    return _V3d.V3d_BadValue_NewInstance(*args)

def V3d_BadValue_get_type_name(*args):
    """
    V3d_BadValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_BadValue_get_type_name(*args)

def V3d_BadValue_get_type_descriptor(*args):
    """
    V3d_BadValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_BadValue_get_type_descriptor(*args)

class V3d_View(Standard.Standard_Transient):
    """
    Defines the application object VIEW for the
    VIEWER application.
    The methods of this class allow the editing
    and inquiring the parameters linked to the view.
    Provides a set of services common to all types of view.
    Warning: The default parameters are defined by the class
    Viewer (Example : SetDefaultViewSize()).
    Certain methods are mouse oriented, and it is
    necessary to know the difference between the start and
    the continuation of this gesture in putting the method
    into operation.
    Example : Shifting the eye-view along the screen axes.

    View->Move(10.,20.,0.,True)     (Starting motion)
    View->Move(15.,-5.,0.,False)    (Next motion)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_View
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_View(self) 
            return h


    def __init__(self, *args):
        """
        __init__(V3d_View self, Handle_V3d_Viewer theViewer, V3d_TypeOfView const theType=V3d_ORTHOGRAPHIC) -> V3d_View
        __init__(V3d_View self, Handle_V3d_Viewer theViewer, Handle_V3d_View theView) -> V3d_View

        Initializes the view by copying.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        this = _V3d.new_V3d_View(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetWindow(self, *args):
        """
        SetWindow(V3d_View self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext=None)

        Activates the view in the specified Window
        If <aContext> is not NULL the graphic context is used
        to draw something in this view.
        Otherwise an internal graphic context is created.
        Warning: The view is centered and resized to preserve
        the height/width ratio of the window.

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext

        """
        return _V3d.V3d_View_SetWindow(self, *args)


    def SetMagnify(self, *args):
        """
        SetMagnify(V3d_View self, Handle_Aspect_Window theWindow, Handle_V3d_View thePreviousView, Standard_Integer const theX1, Standard_Integer const theY1, Standard_Integer const theX2, Standard_Integer const theY2)

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type thePreviousView: OCC.wrapper.V3d.Handle_V3d_View
        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int

        """
        return _V3d.V3d_View_SetMagnify(self, *args)


    def Remove(self, *args):
        """
        Remove(V3d_View self)

        Destroys the view.


        """
        return _V3d.V3d_View_Remove(self, *args)


    def Update(self, *args):
        """
        Update(V3d_View self)

        Deprecated, Redraw() should be used instead.


        """
        return _V3d.V3d_View_Update(self, *args)


    def Redraw(self, *args):
        """
        Redraw(V3d_View self)

        Redisplays the view even if there has not
        been any modification.
        Must be called if the view is shown.
        (Ex: DeIconification ) .


        """
        return _V3d.V3d_View_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(V3d_View self)

        Updates layer of immediate presentations.


        """
        return _V3d.V3d_View_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(V3d_View self)

        Invalidates view content but does not redraw it.


        """
        return _V3d.V3d_View_Invalidate(self, *args)


    def IsInvalidated(self, *args):
        """
        IsInvalidated(V3d_View self) -> Standard_Boolean

        Returns true if cached view content has been invalidated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IsInvalidated(self, *args)


    def MustBeResized(self, *args):
        """
        MustBeResized(V3d_View self)

        Must be called when the window supporting the
        view changes size.
        if the view is not mapped on a window.
        Warning: The view is centered and resized to preserve
        the height/width ratio of the window.


        """
        return _V3d.V3d_View_MustBeResized(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(V3d_View self)

        Must be called when the window supporting the
        view is mapped or unmapped.


        """
        return _V3d.V3d_View_DoMapping(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(V3d_View self) -> Standard_Boolean

        Returns the status of the view regarding
        the displayed structures inside
        Returns True is The View is empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IsEmpty(self, *args)


    def UpdateLights(self, *args):
        """
        UpdateLights(V3d_View self)

        Updates the lights of the view.


        """
        return _V3d.V3d_View_UpdateLights(self, *args)


    def SetAutoZFitMode(self, *args):
        """
        SetAutoZFitMode(V3d_View self, Standard_Boolean const theIsOn, Standard_Real const theScaleFactor=1.0)

        Sets the automatic z-fit mode and its parameters.
        The auto z-fit has extra parameters which can controlled from application level
        to ensure that the size of viewing volume will be sufficiently large to cover
        the depth of unmanaged objects, for example, transformation persistent ones.
        @param theScaleFactor [in] the scale factor for Z-range.
        The range between Z-min, Z-max projection volume planes
        evaluated by z fitting method will be scaled using this coefficient.
        Program error exception is thrown if negative or zero value
        is passed.

        :type theIsOn: bool
        :type theScaleFactor: float

        """
        return _V3d.V3d_View_SetAutoZFitMode(self, *args)


    def AutoZFitMode(self, *args):
        """
        AutoZFitMode(V3d_View self) -> Standard_Boolean

        returns TRUE if automatic z-fit mode is turned on.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_AutoZFitMode(self, *args)


    def AutoZFitScaleFactor(self, *args):
        """
        AutoZFitScaleFactor(V3d_View self) -> Standard_Real

        returns scale factor parameter of automatic z-fit mode.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_AutoZFitScaleFactor(self, *args)


    def AutoZFit(self, *args):
        """
        AutoZFit(V3d_View self)

        If automatic z-range fitting is turned on, adjusts Z-min and Z-max
        projection volume planes with call to ZFitAll.


        """
        return _V3d.V3d_View_AutoZFit(self, *args)


    def ZFitAll(self, *args):
        """
        ZFitAll(V3d_View self, Standard_Real const theScaleFactor=1.0)

        Change Z-min and Z-max planes of projection volume to match the
        displayed objects.

        :type theScaleFactor: float

        """
        return _V3d.V3d_View_ZFitAll(self, *args)


    def SetBackgroundColor(self, *args):
        """
        SetBackgroundColor(V3d_View self, Quantity_TypeOfColor const theType, Standard_Real const theV1, Standard_Real const theV2, Standard_Real const theV3)
        SetBackgroundColor(V3d_View self, Quantity_Color theColor)

        Defines the background color of the view.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_View_SetBackgroundColor(self, *args)


    def SetBgGradientColors(self, *args):
        """
        SetBgGradientColors(V3d_View self, Quantity_Color theColor1, Quantity_Color theColor2, Aspect_GradientFillMethod const theFillStyle=Aspect_GFM_HOR, Standard_Boolean const theToUpdate)

        Defines the gradient background colors of the view by supplying the colors
        and the fill method (horizontal by default).

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_GradientFillMethod
        :type theToUpdate: bool

        """
        return _V3d.V3d_View_SetBgGradientColors(self, *args)


    def SetBgGradientStyle(self, *args):
        """
        SetBgGradientStyle(V3d_View self, Aspect_GradientFillMethod const theMethod=Aspect_GFM_HOR, Standard_Boolean const theToUpdate)

        Defines the gradient background fill method of the view.

        :type theMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod
        :type theToUpdate: bool

        """
        return _V3d.V3d_View_SetBgGradientStyle(self, *args)


    def SetBackgroundImage(self, *args):
        """
        SetBackgroundImage(V3d_View self, Standard_CString const theFileName, Aspect_FillMethod const theFillStyle=Aspect_FM_CENTERED, Standard_Boolean const theToUpdate)

        Defines the background texture of the view by supplying the texture image file name
        and fill method (centered by default).

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod
        :type theToUpdate: bool

        """
        return _V3d.V3d_View_SetBackgroundImage(self, *args)


    def SetBgImageStyle(self, *args):
        """
        SetBgImageStyle(V3d_View self, Aspect_FillMethod const theFillStyle, Standard_Boolean const theToUpdate)

        Defines the textured background fill method of the view.

        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod
        :type theToUpdate: bool

        """
        return _V3d.V3d_View_SetBgImageStyle(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)

        Definition of an axis from its origin and
        its orientation .
        This will be the current axis for rotations and movements.
        Warning! raises BadValue from V3d if the vector normal is NULL. .

        :type X: float
        :type Y: float
        :type Z: float
        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.V3d_View_SetAxis(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(V3d_View self, Graphic3d_TypeOfShadingModel const theShadingModel)

        Defines the shading model for the visualization. Various models are available.

        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.V3d_View_SetShadingModel(self, *args)


    def SetTextureEnv(self, *args):
        """
        SetTextureEnv(V3d_View self, Handle_Graphic3d_TextureEnv theTexture)

        Sets the environment texture to use. No environment texture by default.

        :type theTexture: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _V3d.V3d_View_SetTextureEnv(self, *args)


    def SetVisualization(self, *args):
        """
        SetVisualization(V3d_View self, V3d_TypeOfVisualization const theType)

        Defines the visualization type in the view.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.V3d_View_SetVisualization(self, *args)


    def SetLightOn(self, *args):
        """
        SetLightOn(V3d_View self, Handle_Graphic3d_CLight theLight)
        SetLightOn(V3d_View self)

        Activates all the lights defined in this view.


        """
        return _V3d.V3d_View_SetLightOn(self, *args)


    def SetLightOff(self, *args):
        """
        SetLightOff(V3d_View self, Handle_Graphic3d_CLight theLight)
        SetLightOff(V3d_View self)

        Deactivate all the Lights defined in this view.


        """
        return _V3d.V3d_View_SetLightOff(self, *args)


    def IsActiveLight(self, *args):
        """
        IsActiveLight(V3d_View self, Handle_Graphic3d_CLight theLight) -> Standard_Boolean

        Returns TRUE when the light is active in this view.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IsActiveLight(self, *args)


    def SetImmediateUpdate(self, *args):
        """
        SetImmediateUpdate(V3d_View self, Standard_Boolean const theImmediateUpdate) -> Standard_Boolean

        sets the immediate update mode and returns the previous one.

        :type theImmediateUpdate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_SetImmediateUpdate(self, *args)


    def ZBufferTriedronSetup(self, *args):
        """
        ZBufferTriedronSetup(V3d_View self, Quantity_Color theXColor=Quantity_NOC_RED, Quantity_Color theYColor=Quantity_NOC_GREEN, Quantity_Color theZColor=Quantity_NOC_BLUE1, Standard_Real const theSizeRatio=0.8, Standard_Real const theAxisDiametr=0.05, Standard_Integer const theNbFacettes=12)

        Customization of the ZBUFFER Triedron.
        XColor,YColor,ZColor - colors of axis
        SizeRatio - ratio of decreasing of the trihedron size when its physical
        position comes out of the view
        AxisDiametr - diameter relatively to axis length
        NbFacettes - number of facets of cylinders and cones

        :type theXColor: OCC.wrapper.Quantity.Quantity_Color
        :type theYColor: OCC.wrapper.Quantity.Quantity_Color
        :type theZColor: OCC.wrapper.Quantity.Quantity_Color
        :type theSizeRatio: float
        :type theAxisDiametr: float
        :type theNbFacettes: int

        """
        return _V3d.V3d_View_ZBufferTriedronSetup(self, *args)


    def TriedronDisplay(self, *args):
        """
        TriedronDisplay(V3d_View self, Aspect_TypeOfTriedronPosition const thePosition=Aspect_TOTP_CENTER, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Real const theScale=0.02, V3d_TypeOfVisualization const theMode=V3d_WIREFRAME)

        Display of the Triedron.
        Initialize position, color and length of Triedron axes.
        The scale is a percent of the window width.

        :type thePosition: OCC.wrapper.Aspect.Aspect_TypeOfTriedronPosition
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theScale: float
        :type theMode: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.V3d_View_TriedronDisplay(self, *args)


    def TriedronErase(self, *args):
        """
        TriedronErase(V3d_View self)

        Erases the Triedron.


        """
        return _V3d.V3d_View_TriedronErase(self, *args)


    def GetGraduatedTrihedron(self, *args):
        """
        Returns data of a graduated trihedron.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        res = _V3d.V3d_View_GetGraduatedTrihedron(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GraduatedTrihedronDisplay(self, *args):
        """
        GraduatedTrihedronDisplay(V3d_View self, Graphic3d_GraduatedTrihedron theTrihedronData)

        Displays a graduated trihedron.

        :type theTrihedronData: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        return _V3d.V3d_View_GraduatedTrihedronDisplay(self, *args)


    def GraduatedTrihedronErase(self, *args):
        """
        GraduatedTrihedronErase(V3d_View self)

        Erases a graduated trihedron from the view.


        """
        return _V3d.V3d_View_GraduatedTrihedronErase(self, *args)


    def SetFront(self, *args):
        """
        SetFront(V3d_View self)

        modify the Projection of the view perpendicularly to
        the privileged plane of the viewer.


        """
        return _V3d.V3d_View_SetFront(self, *args)


    def Rotate(self, *args):
        """
        Rotate(V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Boolean const Start)
        Rotate(V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Boolean const Start)
        Rotate(V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Boolean const Start)
        Rotate(V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Boolean const Start)
        Rotate(V3d_View self, Standard_Real const Angle, Standard_Boolean const Start)

        Rotates the eye around the current axis a relative
        angular value in RADIANS with respect to the initial
        position expressed by Start = Standard_True

        :type Angle: float
        :type Start: bool

        """
        return _V3d.V3d_View_Rotate(self, *args)


    def Move(self, *args):
        """
        Move(V3d_View self, Standard_Real const Dx, Standard_Real const Dy, Standard_Real const Dz, Standard_Boolean const Start)
        Move(V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Length, Standard_Boolean const Start)
        Move(V3d_View self, Standard_Real const Length, Standard_Boolean const Start)

        Movement of the eye parllel to the current axis
        a distance relative to the initial position
        expressed by Start = Standard_True

        :type Length: float
        :type Start: bool

        """
        return _V3d.V3d_View_Move(self, *args)


    def Translate(self, *args):
        """
        Translate(V3d_View self, Standard_Real const Dx, Standard_Real const Dy, Standard_Real const Dz, Standard_Boolean const Start)
        Translate(V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Length, Standard_Boolean const Start)
        Translate(V3d_View self, Standard_Real const Length, Standard_Boolean const Start)

        Movement of the eye and view point parallel to
        the current axis a distance relative to the initial
        position expressed by Start = Standard_True

        :type Length: float
        :type Start: bool

        """
        return _V3d.V3d_View_Translate(self, *args)


    def Place(self, *args):
        """
        Place(V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp, Standard_Real const theZoomFactor=1)

        places the point of the view corresponding
        at the pixel position x,y at the center of the window
        and updates the view.

        :type theXp: int
        :type theYp: int
        :type theZoomFactor: float

        """
        return _V3d.V3d_View_Place(self, *args)


    def Turn(self, *args):
        """
        Turn(V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Boolean const Start)
        Turn(V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Boolean const Start)
        Turn(V3d_View self, Standard_Real const Angle, Standard_Boolean const Start)

        Rotation of the view point around the current axis an
        angular value in RADIANS relative to the initial
        position expressed by Start = Standard_True

        :type Angle: float
        :type Start: bool

        """
        return _V3d.V3d_View_Turn(self, *args)


    def SetTwist(self, *args):
        """
        SetTwist(V3d_View self, Standard_Real const Angle)

        Defines the angular position of the high point of
        the reference frame of the view with respect to the
        Y screen axis with an absolute angular value in
        RADIANS.

        :type Angle: float

        """
        return _V3d.V3d_View_SetTwist(self, *args)


    def SetEye(self, *args):
        """
        SetEye(V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Defines the position of the eye..

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.V3d_View_SetEye(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(V3d_View self, Standard_Real const Depth)

        Defines the Depth of the eye from the view point
        without update the projection .

        :type Depth: float

        """
        return _V3d.V3d_View_SetDepth(self, *args)


    def SetProj(self, *args):
        """
        SetProj(V3d_View self, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)
        SetProj(V3d_View self, V3d_TypeOfOrientation const Orientation)

        Defines the orientation of the projection .

        :type Orientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_View_SetProj(self, *args)


    def SetAt(self, *args):
        """
        SetAt(V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Defines the position of the view point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.V3d_View_SetAt(self, *args)


    def SetUp(self, *args):
        """
        SetUp(V3d_View self, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)
        SetUp(V3d_View self, V3d_TypeOfOrientation const Orientation)

        Defines the orientation(SO) of the high point.

        :type Orientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_View_SetUp(self, *args)


    def SetViewOrientationDefault(self, *args):
        """
        SetViewOrientationDefault(V3d_View self)

        Saves the current state of the orientation of the view
        which will be the return state at ResetViewOrientation.


        """
        return _V3d.V3d_View_SetViewOrientationDefault(self, *args)


    def ResetViewOrientation(self, *args):
        """
        ResetViewOrientation(V3d_View self)

        Resets the orientation of the view.
        Updates the view


        """
        return _V3d.V3d_View_ResetViewOrientation(self, *args)


    def Panning(self, *args):
        """
        Panning(V3d_View self, Standard_Real const theDXv, Standard_Real const theDYv, Standard_Real const theZoomFactor=1, Standard_Boolean const theToStart)

        Translates the center of the view along "x" and "y" axes of
        view projection. Can be used to perform interactive panning operation.
        In that case the DXv, DXy parameters specify panning relative to the
        point where the operation is started.
        @param theDXv [in] the relative panning on "x" axis of view projection, in view space coordinates.
        @param theDYv [in] the relative panning on "y" axis of view projection, in view space coordinates.
        @param theZoomFactor [in] the zooming factor.
        @param theToStart [in] pass TRUE when starting panning to remember view
        state prior to panning for relative arguments. If panning is started,
        passing {0, 0} for {theDXv, theDYv} will return view to initial state.
        Performs update of view.

        :type theDXv: float
        :type theDYv: float
        :type theZoomFactor: float
        :type theToStart: bool

        """
        return _V3d.V3d_View_Panning(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp)

        Relocates center of screen to the point, determined by
        {Xp, Yp} pixel coordinates relative to the bottom-left corner of
        screen. To calculate pixel coordinates for any point from world
        coordinate space, it can be projected using "Project".
        @param theXp [in] the x coordinate.
        @param theYp [in] the y coordinate.

        :type theXp: int
        :type theYp: int

        """
        return _V3d.V3d_View_SetCenter(self, *args)


    def SetSize(self, *args):
        """
        SetSize(V3d_View self, Standard_Real const theSize)

        Defines the view projection size in its maximum dimension,
        keeping the inital height/width ratio unchanged.

        :type theSize: float

        """
        return _V3d.V3d_View_SetSize(self, *args)


    def SetZSize(self, *args):
        """
        SetZSize(V3d_View self, Standard_Real const SetZSize)

        Defines the Depth size of the view
        Front Plane will be set to Size/2.
        Back  Plane will be set to -Size/2.
        Any Object located Above the Front Plane or
        behind the Back Plane will be Clipped .
        NOTE than the XY Size of the View is NOT modified .

        :type SetZSize: float

        """
        return _V3d.V3d_View_SetZSize(self, *args)


    def SetZoom(self, *args):
        """
        SetZoom(V3d_View self, Standard_Real const Coef, Standard_Boolean const Start)

        Zooms the view by a factor relative to the initial
        value expressed by Start = Standard_True
        Updates the view.

        :type Coef: float
        :type Start: bool

        """
        return _V3d.V3d_View_SetZoom(self, *args)


    def SetScale(self, *args):
        """
        SetScale(V3d_View self, Standard_Real const Coef)

        Zooms the view by a factor relative to the value
        initialised by SetViewMappingDefault().
        Updates the view.

        :type Coef: float

        """
        return _V3d.V3d_View_SetScale(self, *args)


    def SetAxialScale(self, *args):
        """
        SetAxialScale(V3d_View self, Standard_Real const Sx, Standard_Real const Sy, Standard_Real const Sz)

        Sets  anisotropic (axial)  scale  factors  <Sx>, <Sy>, <Sz>  for  view <me>.
        Anisotropic  scaling  operation  is  performed  through  multiplying
        the current view  orientation  matrix  by  a  scaling  matrix:
        || Sx  0   0   0 ||
        || 0   Sy  0   0 ||
        || 0   0   Sz  0 ||
        || 0   0   0   1 ||
        Updates the view.

        :type Sx: float
        :type Sy: float
        :type Sz: float

        """
        return _V3d.V3d_View_SetAxialScale(self, *args)


    def DepthFitAll(self, *args):
        """
        DepthFitAll(V3d_View self, Standard_Real const Aspect=0.01, Standard_Real const Margin=0.01)

        Adjusts the viewing volume so as not to clip the displayed objects by front and back
        and back clipping planes. Also sets depth value automatically depending on the
        calculated Z size and Aspect parameter.
        NOTE than the original XY size of the view is NOT modified .

        :type Aspect: float
        :type Margin: float

        """
        return _V3d.V3d_View_DepthFitAll(self, *args)


    def FitAll(self, *args):
        """
        FitAll(V3d_View self, Standard_Real const theMargin=0.01, Standard_Boolean const theToUpdate)
        FitAll(V3d_View self, Bnd_Box theBox, Standard_Real const theMargin=0.01, Standard_Boolean const theToUpdate)
        FitAll(V3d_View self, Standard_Real const theMinXv, Standard_Real const theMinYv, Standard_Real const theMaxXv, Standard_Real const theMaxYv)

        Centers the defined projection window so that it occupies
        the maximum space while respecting the initial
        height/width ratio.
        NOTE than the original Z size of the view is NOT modified .

        :type theMinXv: float
        :type theMinYv: float
        :type theMaxXv: float
        :type theMaxYv: float

        """
        return _V3d.V3d_View_FitAll(self, *args)


    def WindowFit(self, *args):
        """
        WindowFit(V3d_View self, Standard_Integer const theMinXp, Standard_Integer const theMinYp, Standard_Integer const theMaxXp, Standard_Integer const theMaxYp)

        Centers the defined PIXEL window so that it occupies
        the maximum space while respecting the initial height/width ratio.
        NOTE than the original Z size of the view is NOT modified.
        @param theMinXp [in] pixel coordinates of minimal corner on x screen axis.
        @param theMinYp [in] pixel coordinates of minimal corner on y screen axis.
        @param theMaxXp [in] pixel coordinates of maximal corner on x screen axis.
        @param theMaxYp [in] pixel coordinates of maximal corner on y screen axis.

        :type theMinXp: int
        :type theMinYp: int
        :type theMaxXp: int
        :type theMaxYp: int

        """
        return _V3d.V3d_View_WindowFit(self, *args)


    def SetViewMappingDefault(self, *args):
        """
        SetViewMappingDefault(V3d_View self)

        Saves the current view mapping. This will be the
        state returned from ResetViewmapping.


        """
        return _V3d.V3d_View_SetViewMappingDefault(self, *args)


    def ResetViewMapping(self, *args):
        """
        ResetViewMapping(V3d_View self)

        Resets the centering of the view.
        Updates the view


        """
        return _V3d.V3d_View_ResetViewMapping(self, *args)


    def Reset(self, *args):
        """
        Reset(V3d_View self, Standard_Boolean const theToUpdate)

        Resets the centering and the orientation of the view.

        :type theToUpdate: bool

        """
        return _V3d.V3d_View_Reset(self, *args)


    def ConvertWithProj(self, *args):
        """
        ConvertWithProj(V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)

        Converts the projected point into a point
        in the reference frame of the view corresponding
        to the intersection with the projection plane
        of the eye/view point vector and returns the
        projection ray for further computations.

        :type Xp: int
        :type Yp: int
        :type X: float
        :type Y: float
        :type Z: float
        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.V3d_View_ConvertWithProj(self, *args)


    def ConvertToGrid(self, *args):
        """
        ConvertToGrid(V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        ConvertToGrid(V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Converts the point into the nearest grid point
        and display the grid marker.

        :type X: float
        :type Y: float
        :type Z: float
        :type Xg: float
        :type Yg: float
        :type Zg: float

        """
        return _V3d.V3d_View_ConvertToGrid(self, *args)


    def Convert(self, *args):
        """
        Convert(V3d_View self, Standard_Integer const Vp) -> Standard_Real
        Convert(V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        Convert(V3d_View self, Standard_Real const Vv) -> Standard_Integer
        Convert(V3d_View self, Standard_Real const Xv, Standard_Real const Yv)
        Convert(V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        Convert(V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Projects the point defined in the reference frame of
        the view into the projected point in the associated window.

        :type X: float
        :type Y: float
        :type Z: float
        :type Xp: int
        :type Yp: int

        """
        return _V3d.V3d_View_Convert(self, *args)


    def Project(self, *args):
        """
        Project(V3d_View self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ)
        Project(V3d_View self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ)

        Converts the point defined in the user space of
        the view to the projection plane at the depth
        relative to theZ.

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theXp: float
        :type theYp: float
        :type theZp: float

        """
        return _V3d.V3d_View_Project(self, *args)


    def BackgroundColor(self, *args):
        """
        BackgroundColor(V3d_View self, Quantity_TypeOfColor const Type)
        BackgroundColor(V3d_View self) -> Quantity_Color

        Returns the Background color object of the view.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_View_BackgroundColor(self, *args)


    def GradientBackgroundColors(self, *args):
        """
        GradientBackgroundColors(V3d_View self, Quantity_Color theColor1, Quantity_Color theColor2)

        Returns the gradient background colors of the view.

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_View_GradientBackgroundColors(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(V3d_View self) -> Aspect_GradientBackground

        Returns the gradient background of the view.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _V3d.V3d_View_GradientBackground(self, *args)


    def Scale(self, *args):
        """
        Scale(V3d_View self) -> Standard_Real

        Returns the current value of the zoom expressed with
        respect to SetViewMappingDefault().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_Scale(self, *args)


    def Size(self, *args):
        """
        Size(V3d_View self)

        Returns the height and width of the view.

        :type Width: float
        :type Height: float

        """
        return _V3d.V3d_View_Size(self, *args)


    def ZSize(self, *args):
        """
        ZSize(V3d_View self) -> Standard_Real

        Returns the Depth of the view .

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_ZSize(self, *args)


    def Eye(self, *args):
        """
        Eye(V3d_View self)

        Returns the position of the eye.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.V3d_View_Eye(self, *args)


    def FocalReferencePoint(self, *args):
        """
        FocalReferencePoint(V3d_View self)

        Returns the position of point which emanating the
        projections.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.V3d_View_FocalReferencePoint(self, *args)


    def ProjReferenceAxe(self, *args):
        """
        ProjReferenceAxe(V3d_View self, Standard_Integer const Xpix, Standard_Integer const Ypix)

        Returns the coordinate of the point (Xpix,Ypix)
        in the view (XP,YP,ZP), and the projection vector of the
        view passing by the point (for PerspectiveView).

        :type Xpix: int
        :type Ypix: int
        :type XP: float
        :type YP: float
        :type ZP: float
        :type VX: float
        :type VY: float
        :type VZ: float

        """
        return _V3d.V3d_View_ProjReferenceAxe(self, *args)


    def Depth(self, *args):
        """
        Depth(V3d_View self) -> Standard_Real

        Returns the Distance between the Eye and View Point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_Depth(self, *args)


    def Proj(self, *args):
        """
        Proj(V3d_View self)

        Returns the projection vector.

        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.V3d_View_Proj(self, *args)


    def At(self, *args):
        """
        At(V3d_View self)

        Returns the position of the view point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.V3d_View_At(self, *args)


    def Up(self, *args):
        """
        Up(V3d_View self)

        Returns the vector giving the position of the high point.

        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.V3d_View_Up(self, *args)


    def Twist(self, *args):
        """
        Twist(V3d_View self) -> Standard_Real

        Returns in RADIANS the orientation of the view around
        the visual axis measured from the Y axis of the screen.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_Twist(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(V3d_View self) -> Graphic3d_TypeOfShadingModel

        Returns the current shading model.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.V3d_View_ShadingModel(self, *args)


    def TextureEnv(self, *args):
        """
        TextureEnv(V3d_View self) -> Handle_Graphic3d_TextureEnv

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _V3d.V3d_View_TextureEnv(self, *args)


    def Visualization(self, *args):
        """
        Visualization(V3d_View self) -> V3d_TypeOfVisualization

        Returns the current visualisation mode.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.V3d_View_Visualization(self, *args)


    def IfMoreLights(self, *args):
        """
        IfMoreLights(V3d_View self) -> Standard_Boolean

        Returns True if One light more can be
        activated in this View.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IfMoreLights(self, *args)


    def ActiveLightIterator(self, *args):
        """
        ActiveLightIterator(V3d_View self) -> V3d_ListOfLightIterator

        Return iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.V3d_View_ActiveLightIterator(self, *args)


    def InitActiveLights(self, *args):
        """
        InitActiveLights(V3d_View self)

        initializes an iteration on the active Lights.


        """
        return _V3d.V3d_View_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args):
        """
        MoreActiveLights(V3d_View self) -> Standard_Boolean

        returns true if there are more active Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args):
        """
        NextActiveLights(V3d_View self)

        Go to the next active Light (if there is not, ActiveLight will raise an exception)


        """
        return _V3d.V3d_View_NextActiveLights(self, *args)


    def ActiveLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.V3d_View_ActiveLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LightLimit(self, *args):
        """
        LightLimit(V3d_View self) -> Standard_Integer

        Returns the MAX number of light associated to the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.V3d_View_LightLimit(self, *args)


    def Viewer(self, *args):
        """
        Viewer(V3d_View self) -> Handle_V3d_Viewer

        Returns the viewer in which the view has been created.

        :rtype: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _V3d.V3d_View_Viewer(self, *args)


    def IfWindow(self, *args):
        """
        IfWindow(V3d_View self) -> Standard_Boolean

        Returns True if MyView is associated with a window .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IfWindow(self, *args)


    def Window(self, *args):
        """
        Window(V3d_View self) -> Handle_Aspect_Window

        Returns the Aspect Window associated with the view.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _V3d.V3d_View_Window(self, *args)


    def Type(self, *args):
        """
        Type(V3d_View self) -> V3d_TypeOfView

        Returns the Type of the View

        :rtype: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.V3d_View_Type(self, *args)


    def Pan(self, *args):
        """
        Pan(V3d_View self, Standard_Integer const theDXp, Standard_Integer const theDYp, Standard_Real const theZoomFactor=1, Standard_Boolean const theToStart)

        Translates the center of the view along "x" and "y" axes of
        view projection. Can be used to perform interactive panning operation.
        In that case the DXp, DXp parameters specify panning relative to the
        point where the operation is started.
        @param theDXp [in] the relative panning on "x" axis of view projection, in pixels.
        @param theDYp [in] the relative panning on "y" axis of view projection, in pixels.
        @param theZoomFactor [in] the zooming factor.
        @param theToStart [in] pass TRUE when starting panning to remember view
        state prior to panning for relative arguments. Passing 0 for relative
        panning parameter should return view panning to initial state.
        Performs update of view.

        :type theDXp: int
        :type theDYp: int
        :type theZoomFactor: float
        :type theToStart: bool

        """
        return _V3d.V3d_View_Pan(self, *args)


    def Zoom(self, *args):
        """
        Zoom(V3d_View self, Standard_Integer const theXp1, Standard_Integer const theYp1, Standard_Integer const theXp2, Standard_Integer const theYp2)

        Zoom the view according to a zoom factor computed
        from the distance between the 2 mouse position.
        @param theXp1 [in] the x coordinate of first mouse position, in pixels.
        @param theYp1 [in] the y coordinate of first mouse position, in pixels.
        @param theXp2 [in] the x coordinate of second mouse position, in pixels.
        @param theYp2 [in] the y coordinate of second mouse position, in pixels.

        :type theXp1: int
        :type theYp1: int
        :type theXp2: int
        :type theYp2: int

        """
        return _V3d.V3d_View_Zoom(self, *args)


    def StartZoomAtPoint(self, *args):
        """
        StartZoomAtPoint(V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp)

        Defines starting point for ZoomAtPoint view operation.
        @param theXp [in] the x mouse coordinate, in pixels.
        @param theYp [in] the y mouse coordinate, in pixels.

        :type theXp: int
        :type theYp: int

        """
        return _V3d.V3d_View_StartZoomAtPoint(self, *args)


    def ZoomAtPoint(self, *args):
        """
        ZoomAtPoint(V3d_View self, Standard_Integer const theMouseStartX, Standard_Integer const theMouseStartY, Standard_Integer const theMouseEndX, Standard_Integer const theMouseEndY)

        Zooms the model at a pixel defined by the method StartZoomAtPoint().

        :type theMouseStartX: int
        :type theMouseStartY: int
        :type theMouseEndX: int
        :type theMouseEndY: int

        """
        return _V3d.V3d_View_ZoomAtPoint(self, *args)


    def AxialScale(self, *args):
        """
        AxialScale(V3d_View self)
        AxialScale(V3d_View self, Standard_Integer const Dx, Standard_Integer const Dy, V3d_TypeOfAxe const Axis)

        Performs  anisotropic scaling  of  <me>  view  along  the  given  <Axis>.
        The  scale  factor  is  calculated on a basis of
        the mouse pointer displacement <Dx,Dy>.
        The  calculated  scale  factor  is  then  passed  to  SetAxialScale(Sx,  Sy,  Sz)  method.

        :type Dx: int
        :type Dy: int
        :type Axis: OCC.wrapper.V3d.V3d_TypeOfAxe

        """
        return _V3d.V3d_View_AxialScale(self, *args)


    def StartRotation(self, *args):
        """
        StartRotation(V3d_View self, Standard_Integer const X, Standard_Integer const Y, Standard_Real const zRotationThreshold=0.0)

        Begin the rotation of the view around the screen axis
        according to the mouse position <X,Y>.
        Warning: Enable rotation around the Z screen axis when <zRotationThreshold>
        factor is > 0 soon the distance from the start point and the center
        of the view is > (medium viewSize * <zRotationThreshold> ).
        Generally a value of 0.4 is usable to rotate around XY screen axis
        inside the circular threshold area and to rotate around Z screen axis
        outside this area.

        :type X: int
        :type Y: int
        :type zRotationThreshold: float

        """
        return _V3d.V3d_View_StartRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(V3d_View self, Standard_Integer const X, Standard_Integer const Y)

        Continues the rotation of the view
        with an angle computed from the last and new mouse position <X,Y>.

        :type X: int
        :type Y: int

        """
        return _V3d.V3d_View_Rotation(self, *args)


    def SetFocale(self, *args):
        """
        SetFocale(V3d_View self, Standard_Real const Focale)

        Change View Plane Distance for Perspective Views
        Warning! raises TypeMismatch from Standard if the view
        is not a perspective view.

        :type Focale: float

        """
        return _V3d.V3d_View_SetFocale(self, *args)


    def Focale(self, *args):
        """
        Focale(V3d_View self) -> Standard_Real

        Returns the View Plane Distance for Perspective Views

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_View_Focale(self, *args)


    def View(self, *args):
        """
        View(V3d_View self) -> Handle_Graphic3d_CView

        Returns the associated Graphic3d view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _V3d.V3d_View_View(self, *args)


    def SetComputedMode(self, *args):
        """
        SetComputedMode(V3d_View self, Standard_Boolean const theMode)

        Switches computed HLR mode in the view.

        :type theMode: bool

        """
        return _V3d.V3d_View_SetComputedMode(self, *args)


    def ComputedMode(self, *args):
        """
        ComputedMode(V3d_View self) -> Standard_Boolean

        Returns the computed HLR mode state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_ComputedMode(self, *args)


    def WindowFitAll(self, *args):
        """
        WindowFitAll(V3d_View self, Standard_Integer const Xmin, Standard_Integer const Ymin, Standard_Integer const Xmax, Standard_Integer const Ymax)

        idem than WindowFit

        :type Xmin: int
        :type Ymin: int
        :type Xmax: int
        :type Ymax: int

        """
        return _V3d.V3d_View_WindowFitAll(self, *args)


    def SetGrid(self, *args):
        """
        SetGrid(V3d_View self, gp_Ax3 aPlane, Handle_Aspect_Grid aGrid)

        Defines or Updates the definition of the
        grid in <me>

        :type aPlane: OCC.wrapper.gp.gp_Ax3
        :type aGrid: OCC.wrapper.Aspect.Handle_Aspect_Grid

        """
        return _V3d.V3d_View_SetGrid(self, *args)


    def SetGridActivity(self, *args):
        """
        SetGridActivity(V3d_View self, Standard_Boolean const aFlag)

        Defines or Updates the activity of the
        grid in <me>

        :type aFlag: bool

        """
        return _V3d.V3d_View_SetGridActivity(self, *args)


    def Dump(self, *args):
        """
        Dump(V3d_View self, Standard_CString const theFile, Graphic3d_BufferType const & theBufferType=Graphic3d_BT_RGB) -> Standard_Boolean

        dump the full contents of the view at the same
        scale in the file <theFile>. The file name
        extension must be one of ".png",".bmp",".jpg",".gif".
        Returns FALSE when the dump has failed

        :type theFile: OCC.wrapper.Standard.Standard_CString
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_Dump(self, *args)


    def Export(self, *args):
        """
        Export(V3d_View self, Standard_CString const theFileName, Graphic3d_ExportFormat const theFormat, Graphic3d_SortType const theSortType=Graphic3d_ST_BSP_Tree) -> Standard_Boolean

        Export scene into the one of the Vector graphics formats (SVG, PS, PDF...).
        In contrast to Bitmaps, Vector graphics is scalable (so you may got quality benefits
        on printing to laser printer). Notice however that results may differ a lot and
        do not contain some elements.

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFormat: OCC.wrapper.Graphic3d.Graphic3d_ExportFormat
        :type theSortType: OCC.wrapper.Graphic3d.Graphic3d_SortType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_Export(self, *args)


    def ToPixMap(self, *args):
        """
        ToPixMap(V3d_View self, Image_PixMap theImage, V3d_ImageDumpOptions const & theParams) -> Standard_Boolean
        ToPixMap(V3d_View self, Image_PixMap theImage, Standard_Integer const theWidth, Standard_Integer const theHeight, Graphic3d_BufferType const & theBufferType=Graphic3d_BT_RGB, Standard_Boolean const theToAdjustAspect, V3d_StereoDumpOptions const theStereoOptions=V3d_SDO_MONO) -> Standard_Boolean

        Dumps the full contents of the view to a pixmap.
        @param theImage          target image, will be re-allocated to match theWidth x theHeight
        @param theWidth          target image width
        @param theHeight         target image height
        @param theBufferType     type of the view buffer to dump (color / depth)
        @param theToAdjustAspect when true, active view aspect ratio will be overridden by (theWidth / theHeight)
        @param theStereoOptions  how to dump stereographic camera

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theWidth: int
        :type theHeight: int
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :type theToAdjustAspect: bool
        :type theStereoOptions: OCC.wrapper.V3d.V3d_StereoDumpOptions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_ToPixMap(self, *args)


    def SetBackFacingModel(self, *args):
        """
        SetBackFacingModel(V3d_View self, V3d_TypeOfBackfacingModel const theModel=V3d_TOBM_AUTOMATIC)

        Manages display of the back faces
        When <aModel> is TOBM_AUTOMATIC the object backfaces
        are displayed only for surface objects and
        never displayed for solid objects.
        this was the previous mode.
        <aModel> is TOBM_ALWAYS_DISPLAYED the object backfaces
        are always displayed both for surfaces or solids.
        <aModel> is TOBM_NEVER_DISPLAYED the object backfaces
        are never displayed.

        :type theModel: OCC.wrapper.V3d.V3d_TypeOfBackfacingModel

        """
        return _V3d.V3d_View_SetBackFacingModel(self, *args)


    def BackFacingModel(self, *args):
        """
        BackFacingModel(V3d_View self) -> V3d_TypeOfBackfacingModel

        Returns current state of the back faces display

        :rtype: OCC.wrapper.V3d.V3d_TypeOfBackfacingModel

        """
        return _V3d.V3d_View_BackFacingModel(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(V3d_View self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane to the view. The composition of clip planes truncates the
        rendering space to convex volume. Number of supported clip planes can be consulted
        by PlaneLimit method of associated Graphic3d_GraphicDriver.
        Please be aware that the planes which exceed the limit are ignored during rendering.
        @param thePlane [in] the clip plane to be added to view.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _V3d.V3d_View_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(V3d_View self, Handle_Graphic3d_ClipPlane thePlane)

        Removes clip plane from the view.
        @param thePlane [in] the clip plane to be removed from view.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _V3d.V3d_View_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(V3d_View self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(V3d_View self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _V3d.V3d_View_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return sequence clip planes that have been set for the view

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _V3d.V3d_View_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PlaneLimit(self, *args):
        """
        PlaneLimit(V3d_View self) -> Standard_Integer

        Returns the MAX number of clipping planes associated to the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.V3d_View_PlaneLimit(self, *args)


    def SetCamera(self, *args):
        """
        SetCamera(V3d_View self, Handle_Graphic3d_Camera theCamera)

        Change camera used by view.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _V3d.V3d_View_SetCamera(self, *args)


    def Camera(self, *args):
        """
        Returns camera object of the view.
        @return: handle to camera object, or NULL if 3D view does not use
        the camera approach.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _V3d.V3d_View_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefaultCamera(self, *args):
        """
        Return default camera.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _V3d.V3d_View_DefaultCamera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RenderingParams(self, *args):
        """
        Returns current rendering parameters and effect settings.
        By default it returns default parameters of current viewer.
        To define view-specific settings use method V3d_View::ChangeRenderingParams().
        @sa V3d_Viewer::DefaultRenderingParams()

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        res = _V3d.V3d_View_RenderingParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeRenderingParams(self, *args):
        """
        ChangeRenderingParams(V3d_View self) -> Graphic3d_RenderingParams

        Returns reference to current rendering parameters and effect settings.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        return _V3d.V3d_View_ChangeRenderingParams(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(V3d_View self) -> Standard_Boolean

        @return flag value of objects culling mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_View_IsCullingEnabled(self, *args)


    def SetFrustumCulling(self, *args):
        """
        SetFrustumCulling(V3d_View self, Standard_Boolean const theMode)

        Turn on/off automatic culling of objects outside frustrum (ON by default)

        :type theMode: bool

        """
        return _V3d.V3d_View_SetFrustumCulling(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(V3d_View self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with diagnostic info.
        Should be called within rendering thread.

        This API should be used only for user output or for creating automated reports.
        The format of returned information (e.g. key-value layout)
        is NOT part of this API and can be changed at any time.
        Thus application should not parse returned information to weed out specific parameters.
        @param theDict  destination map for information
        @param theFlags defines the information to be retrieved

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _V3d.V3d_View_DiagnosticInformation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_View_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_View_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_View_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _V3d.delete_V3d_View
V3d_View_swigregister = _V3d.V3d_View_swigregister
V3d_View_swigregister(V3d_View)

def V3d_View_get_type_name(*args):
    """
    V3d_View_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_View_get_type_name(*args)

def V3d_View_get_type_descriptor(*args):
    """
    V3d_View_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_View_get_type_descriptor(*args)

class V3d_Viewer(Standard.Standard_Transient):
    """
    Defines services on Viewer type objects.
    The methods of this class allow editing and
    interrogation of the parameters linked to the viewer
    its friend classes (View,light,plane).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_Viewer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_Viewer(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_Viewer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_Viewer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_Viewer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IfMoreViews(self, *args):
        """
        IfMoreViews(V3d_Viewer self) -> Standard_Boolean

        Returns True if One View more can be defined in this Viewer.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_IfMoreViews(self, *args)


    def CreateView(self, *args):
        """
        CreateView(V3d_Viewer self) -> Handle_V3d_View

        Creates a view in the viewer according to its default parameters.

        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.V3d_Viewer_CreateView(self, *args)


    def SetViewOn(self, *args):
        """
        SetViewOn(V3d_Viewer self)
        SetViewOn(V3d_Viewer self, Handle_V3d_View theView)

        Activates a particular view in the Viewer.
        Must be call if the Window attached to the view has been Deiconified.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.V3d_Viewer_SetViewOn(self, *args)


    def SetViewOff(self, *args):
        """
        SetViewOff(V3d_Viewer self)
        SetViewOff(V3d_Viewer self, Handle_V3d_View theView)

        Deactivates a particular view in the Viewer.
        Must be call if the Window attached to the view
        has been Iconified .

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.V3d_Viewer_SetViewOff(self, *args)


    def Update(self, *args):
        """
        Update(V3d_Viewer self)

        Deprecated, Redraw() should be used instead.


        """
        return _V3d.V3d_Viewer_Update(self, *args)


    def Redraw(self, *args):
        """
        Redraw(V3d_Viewer self)

        Redraws all the views of the Viewer even if no
        modification has taken place. Must be called if
        all the views of the Viewer are exposed, as for
        example in a global DeIconification.


        """
        return _V3d.V3d_Viewer_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(V3d_Viewer self)

        Updates layer of immediate presentations.


        """
        return _V3d.V3d_Viewer_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(V3d_Viewer self)

        Invalidates viewer content but does not redraw it.


        """
        return _V3d.V3d_Viewer_Invalidate(self, *args)


    def Remove(self, *args):
        """
        Remove(V3d_Viewer self)

        Suppresses the Viewer.


        """
        return _V3d.V3d_Viewer_Remove(self, *args)


    def Driver(self, *args):
        """
        Return Graphic Driver instance.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_GraphicDriver

        """
        res = _V3d.V3d_Viewer_Driver(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StructureManager(self, *args):
        """
        StructureManager(V3d_Viewer self) -> Handle_Graphic3d_StructureManager

        Returns the structure manager associated to this viewer.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager

        """
        return _V3d.V3d_Viewer_StructureManager(self, *args)


    def DefaultRenderingParams(self, *args):
        """
        Return default Rendering Parameters.
        By default these parameters are set in a new V3d_View.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        res = _V3d.V3d_Viewer_DefaultRenderingParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultRenderingParams(self, *args):
        """
        SetDefaultRenderingParams(V3d_Viewer self, Graphic3d_RenderingParams theParams)

        Set default Rendering Parameters.

        :type theParams: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        return _V3d.V3d_Viewer_SetDefaultRenderingParams(self, *args)


    def GetGradientBackground(self, *args):
        """
        Returns the gradient background of the view.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        res = _V3d.V3d_Viewer_GetGradientBackground(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultBgGradientColors(self, *args):
        """
        SetDefaultBgGradientColors(V3d_Viewer self, Quantity_Color theColor1, Quantity_Color theColor2, Aspect_GradientFillMethod const theFillStyle=Aspect_GFM_HOR)

        Defines the default gradient background colours of views
        attached to the viewer by supplying the colour objects

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _V3d.V3d_Viewer_SetDefaultBgGradientColors(self, *args)


    def DefaultViewSize(self, *args):
        """
        DefaultViewSize(V3d_Viewer self) -> Standard_Real

        Returns the default size of the view.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.V3d_Viewer_DefaultViewSize(self, *args)


    def SetDefaultViewSize(self, *args):
        """
        SetDefaultViewSize(V3d_Viewer self, Standard_Real const theSize)

        Gives a default size for the creation of views of the viewer.

        :type theSize: float

        """
        return _V3d.V3d_Viewer_SetDefaultViewSize(self, *args)


    def DefaultViewProj(self, *args):
        """
        DefaultViewProj(V3d_Viewer self) -> V3d_TypeOfOrientation

        Returns the default Projection.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_Viewer_DefaultViewProj(self, *args)


    def SetDefaultViewProj(self, *args):
        """
        SetDefaultViewProj(V3d_Viewer self, V3d_TypeOfOrientation const theOrientation)

        Sets the default projection for creating views in the viewer.

        :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_Viewer_SetDefaultViewProj(self, *args)


    def DefaultVisualization(self, *args):
        """
        DefaultVisualization(V3d_Viewer self) -> V3d_TypeOfVisualization

        Returns the default type of Visualization.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.V3d_Viewer_DefaultVisualization(self, *args)


    def SetDefaultVisualization(self, *args):
        """
        SetDefaultVisualization(V3d_Viewer self, V3d_TypeOfVisualization const theType)

        Gives the default visualization mode.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.V3d_Viewer_SetDefaultVisualization(self, *args)


    def DefaultShadingModel(self, *args):
        """
        DefaultShadingModel(V3d_Viewer self) -> Graphic3d_TypeOfShadingModel

        Returns the default type of Shading

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.V3d_Viewer_DefaultShadingModel(self, *args)


    def SetDefaultShadingModel(self, *args):
        """
        SetDefaultShadingModel(V3d_Viewer self, Graphic3d_TypeOfShadingModel const theType)

        Gives the default type of SHADING.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.V3d_Viewer_SetDefaultShadingModel(self, *args)


    def DefaultTypeOfView(self, *args):
        """
        DefaultTypeOfView(V3d_Viewer self) -> V3d_TypeOfView

        Returns the default type of View (orthographic or perspective projection) to be returned by CreateView() method.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.V3d_Viewer_DefaultTypeOfView(self, *args)


    def SetDefaultTypeOfView(self, *args):
        """
        SetDefaultTypeOfView(V3d_Viewer self, V3d_TypeOfView const theType)

        Set the default type of View (orthographic or perspective projection) to be returned by CreateView() method.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.V3d_Viewer_SetDefaultTypeOfView(self, *args)


    def DefaultBgGradientColors(self, *args):
        """
        DefaultBgGradientColors(V3d_Viewer self, Quantity_Color theColor1, Quantity_Color theColor2)

        Returns the gradient background colour objects of the view.

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_Viewer_DefaultBgGradientColors(self, *args)


    def GetAllZLayers(self, *args):
        """
        GetAllZLayers(V3d_Viewer self, NCollection_Sequence_Standard_Integer theLayerSeq)

        Return all Z layer ids in sequence ordered by overlay level from lowest layer to highest ( foreground ).
        The first layer ID in sequence is the default layer that can't be removed.

        :type theLayerSeq: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _V3d.V3d_Viewer_GetAllZLayers(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(V3d_Viewer self) -> Standard_Boolean

        Add a new top-level Z layer to all managed views and get its ID as <theLayerId> value.
        The Z layers are controlled entirely by viewer, it is not possible to add a layer to a particular view.
        The method returns Standard_False if the layer can not be created.
        The layer mechanism allows to display structures in higher layers in overlay of structures in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(V3d_Viewer self, Graphic3d_ZLayerId const theLayerId) -> Standard_Boolean

        Remove Z layer with ID <theLayerId>.
        Method returns Standard_False if the layer can not be removed or doesn't exists.
        By default, there are always default bottom-level layer that can't be removed.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_RemoveZLayer(self, *args)


    def ZLayerSettings(self, *args):
        """
        ZLayerSettings(V3d_Viewer self, Graphic3d_ZLayerId const theLayerId) -> Graphic3d_ZLayerSettings

        Returns the settings of a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _V3d.V3d_Viewer_ZLayerSettings(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(V3d_Viewer self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _V3d.V3d_Viewer_SetZLayerSettings(self, *args)


    def ActiveViewIterator(self, *args):
        """
        ActiveViewIterator(V3d_Viewer self) -> V3d_ListOfViewIterator

        Return an iterator for active views.

        :rtype: OCC.wrapper.V3d.V3d_ListOfViewIterator

        """
        return _V3d.V3d_Viewer_ActiveViewIterator(self, *args)


    def InitActiveViews(self, *args):
        """
        InitActiveViews(V3d_Viewer self)

        Initializes an internal iterator on the active views.


        """
        return _V3d.V3d_Viewer_InitActiveViews(self, *args)


    def MoreActiveViews(self, *args):
        """
        MoreActiveViews(V3d_Viewer self) -> Standard_Boolean

        Returns true if there are more active view(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_MoreActiveViews(self, *args)


    def NextActiveViews(self, *args):
        """
        NextActiveViews(V3d_Viewer self)

        Go to the next active view (if there is not, ActiveView will raise an exception)


        """
        return _V3d.V3d_Viewer_NextActiveViews(self, *args)


    def ActiveView(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _V3d.V3d_Viewer_ActiveView(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastActiveView(self, *args):
        """
        LastActiveView(V3d_Viewer self) -> Standard_Boolean

        returns true if there is only one active view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_LastActiveView(self, *args)


    def DefinedViewIterator(self, *args):
        """
        DefinedViewIterator(V3d_Viewer self) -> V3d_ListOfViewIterator

        Return an iterator for defined views.

        :rtype: OCC.wrapper.V3d.V3d_ListOfViewIterator

        """
        return _V3d.V3d_Viewer_DefinedViewIterator(self, *args)


    def InitDefinedViews(self, *args):
        """
        InitDefinedViews(V3d_Viewer self)

        Initializes an internal iterator on the Defined views.


        """
        return _V3d.V3d_Viewer_InitDefinedViews(self, *args)


    def MoreDefinedViews(self, *args):
        """
        MoreDefinedViews(V3d_Viewer self) -> Standard_Boolean

        returns true if there are more Defined view(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_MoreDefinedViews(self, *args)


    def NextDefinedViews(self, *args):
        """
        NextDefinedViews(V3d_Viewer self)

        Go to the next Defined view (if there is not, DefinedView will raise an exception)


        """
        return _V3d.V3d_Viewer_NextDefinedViews(self, *args)


    def DefinedView(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _V3d.V3d_Viewer_DefinedView(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultLights(self, *args):
        """
        SetDefaultLights(V3d_Viewer self)

        Defines default lights:
        positional-light 0.3 0. 0.
        directional-light V3d_XnegYposZpos
        directional-light V3d_XnegYneg
        ambient-light


        """
        return _V3d.V3d_Viewer_SetDefaultLights(self, *args)


    def SetLightOn(self, *args):
        """
        SetLightOn(V3d_Viewer self, Handle_Graphic3d_CLight theLight)
        SetLightOn(V3d_Viewer self)

        Activates all the lights defined in this viewer.


        """
        return _V3d.V3d_Viewer_SetLightOn(self, *args)


    def SetLightOff(self, *args):
        """
        SetLightOff(V3d_Viewer self, Handle_Graphic3d_CLight theLight)
        SetLightOff(V3d_Viewer self)

        Deactivate all the Lights defined in this viewer.


        """
        return _V3d.V3d_Viewer_SetLightOff(self, *args)


    def AddLight(self, *args):
        """
        AddLight(V3d_Viewer self, Handle_Graphic3d_CLight theLight)

        Adds Light in Sequence Of Lights.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light

        """
        return _V3d.V3d_Viewer_AddLight(self, *args)


    def DelLight(self, *args):
        """
        DelLight(V3d_Viewer self, Handle_Graphic3d_CLight theLight)

        Delete Light in Sequence Of Lights.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light

        """
        return _V3d.V3d_Viewer_DelLight(self, *args)


    def UpdateLights(self, *args):
        """
        UpdateLights(V3d_Viewer self)

        Updates the lights of all the views of a viewer.


        """
        return _V3d.V3d_Viewer_UpdateLights(self, *args)


    def IsGlobalLight(self, *args):
        """
        IsGlobalLight(V3d_Viewer self, Handle_Graphic3d_CLight TheLight) -> Standard_Boolean

        :type TheLight: OCC.wrapper.V3d.Handle_V3d_Light
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_IsGlobalLight(self, *args)


    def ActiveLightIterator(self, *args):
        """
        ActiveLightIterator(V3d_Viewer self) -> V3d_ListOfLightIterator

        Return an iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.V3d_Viewer_ActiveLightIterator(self, *args)


    def InitActiveLights(self, *args):
        """
        InitActiveLights(V3d_Viewer self)

        Initializes an internal iteratator on the active Lights.


        """
        return _V3d.V3d_Viewer_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args):
        """
        MoreActiveLights(V3d_Viewer self) -> Standard_Boolean

        returns true if there are more active Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args):
        """
        NextActiveLights(V3d_Viewer self)

        Go to the next active Light (if there is not, ActiveLight() will raise an exception)


        """
        return _V3d.V3d_Viewer_NextActiveLights(self, *args)


    def ActiveLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.V3d_Viewer_ActiveLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefinedLightIterator(self, *args):
        """
        DefinedLightIterator(V3d_Viewer self) -> V3d_ListOfLightIterator

        Return an iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.V3d_Viewer_DefinedLightIterator(self, *args)


    def InitDefinedLights(self, *args):
        """
        InitDefinedLights(V3d_Viewer self)

        Initializes an internal iterattor on the Defined Lights.


        """
        return _V3d.V3d_Viewer_InitDefinedLights(self, *args)


    def MoreDefinedLights(self, *args):
        """
        MoreDefinedLights(V3d_Viewer self) -> Standard_Boolean

        Returns true if there are more Defined Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_MoreDefinedLights(self, *args)


    def NextDefinedLights(self, *args):
        """
        NextDefinedLights(V3d_Viewer self)

        Go to the next Defined Light (if there is not, DefinedLight() will raise an exception)


        """
        return _V3d.V3d_Viewer_NextDefinedLights(self, *args)


    def DefinedLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.V3d_Viewer_DefinedLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Erase(self, *args):
        """
        Erase(V3d_Viewer self)

        Erase all Objects in All the views.


        """
        return _V3d.V3d_Viewer_Erase(self, *args)


    def UnHighlight(self, *args):
        """
        UnHighlight(V3d_Viewer self)

        UnHighlight all Objects in All the views.


        """
        return _V3d.V3d_Viewer_UnHighlight(self, *args)


    def ComputedMode(self, *args):
        """
        ComputedMode(V3d_Viewer self) -> Standard_Boolean

        returns true if the computed mode can be used.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_ComputedMode(self, *args)


    def SetComputedMode(self, *args):
        """
        SetComputedMode(V3d_Viewer self, Standard_Boolean const theMode)

        Set if the computed mode can be used.

        :type theMode: bool

        """
        return _V3d.V3d_Viewer_SetComputedMode(self, *args)


    def DefaultComputedMode(self, *args):
        """
        DefaultComputedMode(V3d_Viewer self) -> Standard_Boolean

        returns true if by default the computed mode must be used.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_DefaultComputedMode(self, *args)


    def SetDefaultComputedMode(self, *args):
        """
        SetDefaultComputedMode(V3d_Viewer self, Standard_Boolean const theMode)

        Set if by default the computed mode must be used.

        :type theMode: bool

        """
        return _V3d.V3d_Viewer_SetDefaultComputedMode(self, *args)


    def PrivilegedPlane(self, *args):
        """
        @name privileged plane management

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _V3d.V3d_Viewer_PrivilegedPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrivilegedPlane(self, *args):
        """
        SetPrivilegedPlane(V3d_Viewer self, gp_Ax3 thePlane)

        :type thePlane: OCC.wrapper.gp.gp_Ax3

        """
        return _V3d.V3d_Viewer_SetPrivilegedPlane(self, *args)


    def DisplayPrivilegedPlane(self, *args):
        """
        DisplayPrivilegedPlane(V3d_Viewer self, Standard_Boolean const theOnOff, Standard_Real const theSize=1)

        :type theOnOff: bool
        :type theSize: float

        """
        return _V3d.V3d_Viewer_DisplayPrivilegedPlane(self, *args)


    def ActivateGrid(self, *args):
        """
        ActivateGrid(V3d_Viewer self, Aspect_GridType const aGridType, Aspect_GridDrawMode const aGridDrawMode)

        Activates the grid in all views of <me>.

        :type aGridType: OCC.wrapper.Aspect.Aspect_GridType
        :type aGridDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.V3d_Viewer_ActivateGrid(self, *args)


    def DeactivateGrid(self, *args):
        """
        DeactivateGrid(V3d_Viewer self)

        Deactivates the grid in all views of <me>.


        """
        return _V3d.V3d_Viewer_DeactivateGrid(self, *args)


    def SetGridEcho(self, *args):
        """
        SetGridEcho(V3d_Viewer self, Standard_Boolean const showGrid)
        SetGridEcho(V3d_Viewer self, Handle_Graphic3d_AspectMarker3d aMarker)

        Show grid echo <aMarker> to the hit point.
        Warning: When the grid echo marker is not set,
        a default marker is build with the attributes:
        marker type : Aspect_TOM_STAR
        marker color : Quantity_NOC_GRAY90
        marker size : 3.0

        :type aMarker: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _V3d.V3d_Viewer_SetGridEcho(self, *args)


    def GridEcho(self, *args):
        """
        GridEcho(V3d_Viewer self) -> Standard_Boolean

        Returns TRUE when grid echo must be displayed at hit point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_GridEcho(self, *args)


    def IsActive(self, *args):
        """
        IsActive(V3d_Viewer self) -> Standard_Boolean

        Returns Standard_True if a grid is activated in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Viewer_IsActive(self, *args)


    def Grid(self, *args):
        """
        Grid(V3d_Viewer self) -> Handle_Aspect_Grid

        Returns the defined grid in <me>.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Grid

        """
        return _V3d.V3d_Viewer_Grid(self, *args)


    def GridType(self, *args):
        """
        GridType(V3d_Viewer self) -> Aspect_GridType

        Returns the current grid type defined in <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_GridType

        """
        return _V3d.V3d_Viewer_GridType(self, *args)


    def GridDrawMode(self, *args):
        """
        GridDrawMode(V3d_Viewer self) -> Aspect_GridDrawMode

        Returns the current grid draw mode defined in <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.V3d_Viewer_GridDrawMode(self, *args)


    def RectangularGridValues(self, *args):
        """
        RectangularGridValues(V3d_Viewer self)

        Returns the definition of the rectangular grid.

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _V3d.V3d_Viewer_RectangularGridValues(self, *args)


    def SetRectangularGridValues(self, *args):
        """
        SetRectangularGridValues(V3d_Viewer self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const XStep, Standard_Real const YStep, Standard_Real const RotationAngle)

        Sets the definition of the rectangular grid.
        <XOrigin>, <YOrigin> defines the origin of the grid.
        <XStep> defines the interval between 2 vertical lines.
        <YStep> defines the interval between 2 horizontal lines.
        <RotationAngle> defines the rotation angle of the grid.

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _V3d.V3d_Viewer_SetRectangularGridValues(self, *args)


    def CircularGridValues(self, *args):
        """
        CircularGridValues(V3d_Viewer self)

        Returns the definition of the circular grid.

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _V3d.V3d_Viewer_CircularGridValues(self, *args)


    def SetCircularGridValues(self, *args):
        """
        SetCircularGridValues(V3d_Viewer self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const RadiusStep, Standard_Integer const DivisionNumber, Standard_Real const RotationAngle)

        Sets the definition of the circular grid.
        <XOrigin>, <YOrigin> defines the origin of the grid.
        <RadiusStep> defines the interval between 2 circles.
        <DivisionNumber> defines the section number of one half circle.
        <RotationAngle> defines the rotation angle of the grid.

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _V3d.V3d_Viewer_SetCircularGridValues(self, *args)


    def CircularGridGraphicValues(self, *args):
        """
        CircularGridGraphicValues(V3d_Viewer self)

        Returns the location and the size of the grid.

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.V3d_Viewer_CircularGridGraphicValues(self, *args)


    def SetCircularGridGraphicValues(self, *args):
        """
        SetCircularGridGraphicValues(V3d_Viewer self, Standard_Real const Radius, Standard_Real const OffSet)

        Sets the location and the size of the grid.
        <XSize> defines the width of the grid.
        <YSize> defines the height of the grid.
        <OffSet> defines the displacement along the plane normal.

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.V3d_Viewer_SetCircularGridGraphicValues(self, *args)


    def RectangularGridGraphicValues(self, *args):
        """
        RectangularGridGraphicValues(V3d_Viewer self)

        Returns the location and the size of the grid.

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.V3d_Viewer_RectangularGridGraphicValues(self, *args)


    def SetRectangularGridGraphicValues(self, *args):
        """
        SetRectangularGridGraphicValues(V3d_Viewer self, Standard_Real const XSize, Standard_Real const YSize, Standard_Real const OffSet)

        Sets the location and the size of the grid.
        <XSize> defines the width of the grid.
        <YSize> defines the height of the grid.
        <OffSet> defines the displacement along the plane normal.

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.V3d_Viewer_SetRectangularGridGraphicValues(self, *args)


    def ShowGridEcho(self, *args):
        """
        ShowGridEcho(V3d_Viewer self, Handle_V3d_View theView, Graphic3d_Vertex thePoint)

        Display grid echo at requested point in the view.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type thePoint: OCC.wrapper.Graphic3d.Graphic3d_Vertex

        """
        return _V3d.V3d_Viewer_ShowGridEcho(self, *args)


    def HideGridEcho(self, *args):
        """
        HideGridEcho(V3d_Viewer self, Handle_V3d_View theView)

        Temporarly hide grid echo.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.V3d_Viewer_HideGridEcho(self, *args)


    def __init__(self, *args):
        """
        __init__(V3d_Viewer self, Handle_Graphic3d_GraphicDriver theDriver) -> V3d_Viewer
        __init__(V3d_Viewer self, Handle_Graphic3d_GraphicDriver theDriver, Standard_ExtString const theName, Standard_CString const theDomain, Standard_Real const theViewSize=1000.0, V3d_TypeOfOrientation const theViewProj=V3d_XposYnegZpos, Quantity_Color theViewBackground=Quantity_NOC_GRAY30, V3d_TypeOfVisualization const theVisualization=V3d_ZBUFFER, Graphic3d_TypeOfShadingModel const theShadingModel=Graphic3d_TOSM_VERTEX, Standard_Boolean const theComputedMode, Standard_Boolean const theDefaultComputedMode) -> V3d_Viewer

        @name deprecated methods

        :type theDriver: OCC.wrapper.Graphic3d.Handle_Graphic3d_GraphicDriver
        :type theName: OCC.wrapper.Standard.Standard_ExtString
        :type theDomain: OCC.wrapper.Standard.Standard_CString
        :type theViewSize: float
        :type theViewProj: OCC.wrapper.V3d.V3d_TypeOfOrientation
        :type theViewBackground: OCC.wrapper.Quantity.Quantity_Color
        :type theVisualization: OCC.wrapper.V3d.V3d_TypeOfVisualization
        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theComputedMode: bool
        :type theDefaultComputedMode: bool

        """
        this = _V3d.new_V3d_Viewer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDefaultBackgroundColor(self, *args):
        """
        SetDefaultBackgroundColor(V3d_Viewer self, Quantity_Color theColor)
        SetDefaultBackgroundColor(V3d_Viewer self, Quantity_TypeOfColor const theType, Standard_Real const theV1, Standard_Real const theV2, Standard_Real const theV3)

        Defines the default base colour of views attached
        to the Viewer by supplying the type of colour
        definition and the three component values.

        :type theType: OCC.wrapper.Quantity.Quantity_TypeOfColor
        :type theV1: float
        :type theV2: float
        :type theV3: float

        """
        return _V3d.V3d_Viewer_SetDefaultBackgroundColor(self, *args)


    def DefaultBackgroundColor(self, *args):
        """
        DefaultBackgroundColor(V3d_Viewer self) -> Quantity_Color
        DefaultBackgroundColor(V3d_Viewer self, Quantity_TypeOfColor const theType)

        :type theType: OCC.wrapper.Quantity.Quantity_TypeOfColor
        :type theV1: float
        :type theV2: float
        :type theV3: float

        """
        return _V3d.V3d_Viewer_DefaultBackgroundColor(self, *args)

    __swig_destroy__ = _V3d.delete_V3d_Viewer
V3d_Viewer_swigregister = _V3d.V3d_Viewer_swigregister
V3d_Viewer_swigregister(V3d_Viewer)

def V3d_Viewer_get_type_name(*args):
    """
    V3d_Viewer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_Viewer_get_type_name(*args)

def V3d_Viewer_get_type_descriptor(*args):
    """
    V3d_Viewer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_Viewer_get_type_descriptor(*args)

class Handle_V3d_PositionalLight(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_PositionalLight self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_PositionalLight_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_PositionalLight self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_PositionalLight_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_PositionalLight self, V3d_PositionalLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_PositionalLight_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_PositionalLight self, Handle_V3d_PositionalLight theHandle) -> Handle_V3d_PositionalLight
        assign(Handle_V3d_PositionalLight self, V3d_PositionalLight thePtr) -> Handle_V3d_PositionalLight
        assign(Handle_V3d_PositionalLight self, Handle_V3d_PositionalLight theHandle) -> Handle_V3d_PositionalLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_PositionalLight_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_PositionalLight self) -> V3d_PositionalLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_PositionalLight_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_PositionalLight self) -> V3d_PositionalLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_PositionalLight___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_PositionalLight self) -> V3d_PositionalLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_PositionalLight___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_PositionalLight___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_PositionalLight___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_PositionalLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_PositionalLight_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_PositionalLight

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_PositionalLight self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_PositionalLight_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_PositionalLight_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_PositionalLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_V3d_PositionalLight self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_PositionalLight_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_PositionalLight_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_PositionalLight self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_PositionalLight_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_PositionalLight_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_PositionalLight self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_PositionalLight_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_PositionalLight self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionalLight_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_PositionalLight self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_PositionalLight_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_PositionalLight self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionalLight_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_PositionalLight self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionalLight_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_PositionalLight self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_PositionalLight_SetHeadlight(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_PositionalLight self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_PositionalLight_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_PositionalLight self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_PositionalLight self) -> gp_Dir
        Direction(Handle_V3d_PositionalLight self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_PositionalLight_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_PositionalLight self, gp_Dir theDir)
        SetDirection(Handle_V3d_PositionalLight self, Standard_Real theVx, Standard_Real theVy, Standard_Real theVz)

        Sets direction of directional/spot light.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_PositionalLight self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_PositionalLight self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_PositionalLight self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_PositionalLight self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionalLight_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_PositionalLight self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_PositionalLight self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionalLight_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_PositionalLight_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionalLight_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionalLight_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionalLight_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_PositionalLight self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_PositionalLight_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_PositionalLight self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_PositionalLight_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_PositionalLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_PositionalLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionalLight_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_PositionalLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_PositionalLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionalLight_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_PositionalLight self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_PositionalLight_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_PositionalLight self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_PositionalLight_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_PositionalLight self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_PositionalLight_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_PositionalLight self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_PositionalLight_DecrementRefCounter(self, *args)

Handle_V3d_PositionalLight_swigregister = _V3d.Handle_V3d_PositionalLight_swigregister
Handle_V3d_PositionalLight_swigregister(Handle_V3d_PositionalLight)

def Handle_V3d_PositionalLight_DownCast(thing):
    return _V3d.Handle_V3d_PositionalLight_DownCast(thing)
Handle_V3d_PositionalLight_DownCast = _V3d.Handle_V3d_PositionalLight_DownCast

class V3d_AmbientLight(Graphic3d.Graphic3d_CLight):
    """Creation of an ambient light source in a viewer."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_AmbientLight
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_AmbientLight(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_AmbientLight_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_AmbientLight_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_AmbientLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(V3d_AmbientLight self, Quantity_Color theColor=Quantity_NOC_WHITE) -> V3d_AmbientLight
        __init__(V3d_AmbientLight self, Handle_V3d_Viewer theViewer, Quantity_Color theColor=Quantity_NOC_WHITE) -> V3d_AmbientLight

        Constructs an ambient light source in the viewer.
        The default Color of this light source is WHITE.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        this = _V3d.new_V3d_AmbientLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _V3d.delete_V3d_AmbientLight
V3d_AmbientLight_swigregister = _V3d.V3d_AmbientLight_swigregister
V3d_AmbientLight_swigregister(V3d_AmbientLight)

def V3d_AmbientLight_get_type_name(*args):
    """
    V3d_AmbientLight_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_AmbientLight_get_type_name(*args)

def V3d_AmbientLight_get_type_descriptor(*args):
    """
    V3d_AmbientLight_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_AmbientLight_get_type_descriptor(*args)

class V3d_DirectionalLight(V3d_PositionLight):
    """Directional light source for a viewer."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_DirectionalLight
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_DirectionalLight(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_DirectionalLight_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_DirectionalLight_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_DirectionalLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDirection(self, *args):
        """
        SetDirection(V3d_DirectionalLight self, V3d_TypeOfOrientation theDirection)

        Defines the direction of the light source by a predefined orientation.

        :type theDirection: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_DirectionalLight_SetDirection(self, *args)


    def __init__(self, *args):
        """
        __init__(V3d_DirectionalLight self, V3d_TypeOfOrientation const theDirection=V3d_XposYposZpos, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Boolean const theIsHeadlight) -> V3d_DirectionalLight
        __init__(V3d_DirectionalLight self, gp_Dir theDirection, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Boolean const theIsHeadlight) -> V3d_DirectionalLight
        __init__(V3d_DirectionalLight self, Handle_V3d_Viewer theViewer, V3d_TypeOfOrientation const theDirection=V3d_XposYposZpos, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Boolean const theIsHeadlight) -> V3d_DirectionalLight
        __init__(V3d_DirectionalLight self, Handle_V3d_Viewer theViewer, Standard_Real const theXt, Standard_Real const theYt, Standard_Real const theZt, Standard_Real const theXp, Standard_Real const theYp, Standard_Real const theZp, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Boolean const theIsHeadlight) -> V3d_DirectionalLight

        Creates a directional light source in the viewer.
        theXt, theYt, theZt : Coordinate of light source Target.
        theXp, theYp, theZp : Coordinate of light source Position.
        The others parameters describe before.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theXt: float
        :type theYt: float
        :type theZt: float
        :type theXp: float
        :type theYp: float
        :type theZp: float
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theIsHeadlight: bool

        """
        this = _V3d.new_V3d_DirectionalLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _V3d.delete_V3d_DirectionalLight
V3d_DirectionalLight_swigregister = _V3d.V3d_DirectionalLight_swigregister
V3d_DirectionalLight_swigregister(V3d_DirectionalLight)

def V3d_DirectionalLight_get_type_name(*args):
    """
    V3d_DirectionalLight_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_DirectionalLight_get_type_name(*args)

def V3d_DirectionalLight_get_type_descriptor(*args):
    """
    V3d_DirectionalLight_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_DirectionalLight_get_type_descriptor(*args)

class V3d_Plane(Standard.Standard_Transient):
    """
    Obsolete clip plane presentation class.
    Ported on new core of Graphic3d_ClipPlane approach.
    Please access Graphic3d_ClipPlane via ClipPlane() method
    to use it for standard clipping workflow.
    Example of use:
    @code

    Handle(V3d_Plane) aPlane (0, 1, 0, -20);
    Handle(V3d_View) aView;
    aView->AddClipPlane (aPlane->ClipPlane());

    aPlane->Display (aView);
    aPlane->SetPlane (0, 1, 0, -30);
    aView->RemoveClipPlane (aPlane->ClipPlane());

    @endcode
    Use interface of this class to modify plane equation synchronously
    with clipping equation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_Plane
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_Plane(self) 
            return h


    def __init__(self, *args):
        """
        __init__(V3d_Plane self, Standard_Real const theA=0.0, Standard_Real const theB=0.0, Standard_Real const theC=1.0, Standard_Real const theD=0.0) -> V3d_Plane

        Creates a clipping plane from plane coefficients.

        :type theA: float
        :type theB: float
        :type theC: float
        :type theD: float

        """
        this = _V3d.new_V3d_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPlane(self, *args):
        """
        SetPlane(V3d_Plane self, Standard_Real const theA, Standard_Real const theB, Standard_Real const theC, Standard_Real const theD)

        Change plane equation.

        :type theA: float
        :type theB: float
        :type theC: float
        :type theD: float

        """
        return _V3d.V3d_Plane_SetPlane(self, *args)


    def Display(self, *args):
        """
        Display(V3d_Plane self, Handle_V3d_View theView, Quantity_Color theColor=Quantity_NOC_GRAY)

        Display the plane representation in the choosen view.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_Plane_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(V3d_Plane self)

        Erase the plane representation.


        """
        return _V3d.V3d_Plane_Erase(self, *args)


    def Plane(self, *args):
        """
        Plane(V3d_Plane self)

        Returns the parameters of the plane.

        :type theA: float
        :type theB: float
        :type theC: float
        :type theD: float

        """
        return _V3d.V3d_Plane_Plane(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(V3d_Plane self) -> Standard_Boolean

        Returns TRUE when the plane representation is displayed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_Plane_IsDisplayed(self, *args)


    def ClipPlane(self, *args):
        """
        Use this method to pass clipping plane implementation for
        standard clipping workflow.
        @return clipping plane implementation handle.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        res = _V3d.V3d_Plane_ClipPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_Plane_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_Plane_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _V3d.delete_V3d_Plane
V3d_Plane_swigregister = _V3d.V3d_Plane_swigregister
V3d_Plane_swigregister(V3d_Plane)

def V3d_Plane_get_type_name(*args):
    """
    V3d_Plane_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_Plane_get_type_name(*args)

def V3d_Plane_get_type_descriptor(*args):
    """
    V3d_Plane_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_Plane_get_type_descriptor(*args)

class V3d_Trihedron(Standard.Standard_Transient):
    """Class for presentation of zbuffer trihedron object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_Trihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_Trihedron(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_Trihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_Trihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_Trihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(V3d_Trihedron self) -> V3d_Trihedron

        Creates a default trihedron.


        """
        this = _V3d.new_V3d_Trihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetWireframe(self, *args):
        """
        SetWireframe(V3d_Trihedron self, Standard_Boolean const theAsWireframe)

        Switch wireframe / shaded trihedron.

        :type theAsWireframe: bool

        """
        return _V3d.V3d_Trihedron_SetWireframe(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(V3d_Trihedron self, Aspect_TypeOfTriedronPosition const thePosition)

        Setup the corner to draw the trihedron.

        :type thePosition: OCC.wrapper.Aspect.Aspect_TypeOfTriedronPosition

        """
        return _V3d.V3d_Trihedron_SetPosition(self, *args)


    def SetScale(self, *args):
        """
        SetScale(V3d_Trihedron self, Standard_Real const theScale)

        Setup the scale factor.

        :type theScale: float

        """
        return _V3d.V3d_Trihedron_SetScale(self, *args)


    def SetSizeRatio(self, *args):
        """
        SetSizeRatio(V3d_Trihedron self, Standard_Real const theRatio)

        Setup the size ratio factor.

        :type theRatio: float

        """
        return _V3d.V3d_Trihedron_SetSizeRatio(self, *args)


    def SetArrowDiameter(self, *args):
        """
        SetArrowDiameter(V3d_Trihedron self, Standard_Real const theDiam)

        Setup the arrow diameter.

        :type theDiam: float

        """
        return _V3d.V3d_Trihedron_SetArrowDiameter(self, *args)


    def SetNbFacets(self, *args):
        """
        SetNbFacets(V3d_Trihedron self, Standard_Integer const theNbFacets)

        Setup the number of facets for tessellation.

        :type theNbFacets: int

        """
        return _V3d.V3d_Trihedron_SetNbFacets(self, *args)


    def SetLabelsColor(self, *args):
        """
        SetLabelsColor(V3d_Trihedron self, Quantity_Color theColor)

        Setup color of text labels.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_Trihedron_SetLabelsColor(self, *args)


    def SetArrowsColor(self, *args):
        """
        SetArrowsColor(V3d_Trihedron self, Quantity_Color theXColor, Quantity_Color theYColor, Quantity_Color theZColor)

        Setup colors of arrows.

        :type theXColor: OCC.wrapper.Quantity.Quantity_Color
        :type theYColor: OCC.wrapper.Quantity.Quantity_Color
        :type theZColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_Trihedron_SetArrowsColor(self, *args)


    def Display(self, *args):
        """
        Display(V3d_Trihedron self, V3d_View theView)

        Display trihedron.

        :type theView: OCC.wrapper.V3d.V3d_View

        """
        return _V3d.V3d_Trihedron_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(V3d_Trihedron self)

        Erase trihedron.


        """
        return _V3d.V3d_Trihedron_Erase(self, *args)

    __swig_destroy__ = _V3d.delete_V3d_Trihedron
V3d_Trihedron_swigregister = _V3d.V3d_Trihedron_swigregister
V3d_Trihedron_swigregister(V3d_Trihedron)

def V3d_Trihedron_get_type_name(*args):
    """
    V3d_Trihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_Trihedron_get_type_name(*args)

def V3d_Trihedron_get_type_descriptor(*args):
    """
    V3d_Trihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_Trihedron_get_type_descriptor(*args)

class V3d_UnMapped(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_UnMapped
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_UnMapped(self) 
            return h


    def __init__(self, *args):
        """
        __init__(V3d_UnMapped self) -> V3d_UnMapped
        __init__(V3d_UnMapped self, Standard_CString const theMessage) -> V3d_UnMapped

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _V3d.new_V3d_UnMapped(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_V3d_UnMapped

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.V3d.Handle_V3d_UnMapped

        """
        return _V3d.V3d_UnMapped_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_UnMapped_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_UnMapped_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_UnMapped_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _V3d.delete_V3d_UnMapped
V3d_UnMapped_swigregister = _V3d.V3d_UnMapped_swigregister
V3d_UnMapped_swigregister(V3d_UnMapped)

def V3d_UnMapped_NewInstance(*args):
    """
    V3d_UnMapped_NewInstance(Standard_CString const theMessage) -> Handle_V3d_UnMapped

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.V3d.Handle_V3d_UnMapped

    """
    return _V3d.V3d_UnMapped_NewInstance(*args)

def V3d_UnMapped_get_type_name(*args):
    """
    V3d_UnMapped_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_UnMapped_get_type_name(*args)

def V3d_UnMapped_get_type_descriptor(*args):
    """
    V3d_UnMapped_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_UnMapped_get_type_descriptor(*args)

class Handle_V3d_BadValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_BadValue self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_BadValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_BadValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_BadValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_BadValue self, V3d_BadValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_BadValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_BadValue self, Handle_V3d_BadValue theHandle) -> Handle_V3d_BadValue
        assign(Handle_V3d_BadValue self, V3d_BadValue thePtr) -> Handle_V3d_BadValue
        assign(Handle_V3d_BadValue self, Handle_V3d_BadValue theHandle) -> Handle_V3d_BadValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_BadValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_BadValue self) -> V3d_BadValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_BadValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_BadValue self) -> V3d_BadValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_BadValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_BadValue self) -> V3d_BadValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_BadValue___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_BadValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_BadValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_BadValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_BadValue_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_BadValue

    def NewInstance(self, *args):
        """
        NewInstance(Handle_V3d_BadValue self, Standard_CString const theMessage) -> Handle_V3d_BadValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.V3d.Handle_V3d_BadValue

        """
        return _V3d.Handle_V3d_BadValue_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_BadValue self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_BadValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_BadValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_BadValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_V3d_BadValue self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _V3d.Handle_V3d_BadValue_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_V3d_BadValue self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _V3d.Handle_V3d_BadValue_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_V3d_BadValue self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _V3d.Handle_V3d_BadValue_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_V3d_BadValue self)
        Reraise(Handle_V3d_BadValue self, Standard_CString const aMessage)
        Reraise(Handle_V3d_BadValue self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _V3d.Handle_V3d_BadValue_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_V3d_BadValue self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _V3d.Handle_V3d_BadValue_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_V3d_BadValue self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _V3d.Handle_V3d_BadValue_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_BadValue self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_BadValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_BadValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_BadValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_BadValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_BadValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_BadValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_BadValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_BadValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_BadValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_BadValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_BadValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_BadValue self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_BadValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_BadValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_BadValue_DecrementRefCounter(self, *args)

Handle_V3d_BadValue_swigregister = _V3d.Handle_V3d_BadValue_swigregister
Handle_V3d_BadValue_swigregister(Handle_V3d_BadValue)

def Handle_V3d_BadValue_DownCast(thing):
    return _V3d.Handle_V3d_BadValue_DownCast(thing)
Handle_V3d_BadValue_DownCast = _V3d.Handle_V3d_BadValue_DownCast

class Handle_V3d_AmbientLight(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_AmbientLight self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_AmbientLight_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_AmbientLight self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_AmbientLight_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_AmbientLight self, V3d_AmbientLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_AmbientLight_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_AmbientLight self, Handle_V3d_AmbientLight theHandle) -> Handle_V3d_AmbientLight
        assign(Handle_V3d_AmbientLight self, V3d_AmbientLight thePtr) -> Handle_V3d_AmbientLight
        assign(Handle_V3d_AmbientLight self, Handle_V3d_AmbientLight theHandle) -> Handle_V3d_AmbientLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_AmbientLight_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_AmbientLight self) -> V3d_AmbientLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_AmbientLight_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_AmbientLight self) -> V3d_AmbientLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_AmbientLight___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_AmbientLight self) -> V3d_AmbientLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_AmbientLight___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_AmbientLight___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_AmbientLight___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_AmbientLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_AmbientLight_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_AmbientLight

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_AmbientLight self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_AmbientLight_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_AmbientLight_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_AmbientLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_V3d_AmbientLight self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_AmbientLight_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_AmbientLight_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_AmbientLight self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_AmbientLight_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_AmbientLight_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_AmbientLight self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_AmbientLight_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_AmbientLight self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_AmbientLight_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_AmbientLight self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_AmbientLight_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_AmbientLight self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_AmbientLight_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_AmbientLight self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_AmbientLight_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_AmbientLight self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_AmbientLight_SetHeadlight(self, *args)


    def Position(self, *args):
        """
        Returns location of positional/spot light; (0, 0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _V3d.Handle_V3d_AmbientLight_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_V3d_AmbientLight self, gp_Pnt thePosition)
        SetPosition(Handle_V3d_AmbientLight self, Standard_Real theX, Standard_Real theY, Standard_Real theZ)

        Setup location of positional/spot light.

        :type theX: float
        :type theY: float
        :type theZ: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetPosition(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_AmbientLight self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_AmbientLight_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_AmbientLight self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_AmbientLight self) -> gp_Dir
        Direction(Handle_V3d_AmbientLight self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_AmbientLight_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_AmbientLight self, gp_Dir theDir)
        SetDirection(Handle_V3d_AmbientLight self, Standard_Real theVx, Standard_Real theVy, Standard_Real theVz)

        Sets direction of directional/spot light.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_AmbientLight self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_AmbientLight self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_AmbientLight self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_AmbientLight self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_AmbientLight_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_AmbientLight self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_AmbientLight self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_AmbientLight_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_AmbientLight_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_AmbientLight_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_AmbientLight_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_AmbientLight_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_AmbientLight self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_AmbientLight_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_AmbientLight self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_AmbientLight_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_AmbientLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_AmbientLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_AmbientLight_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_AmbientLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_AmbientLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_AmbientLight_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_AmbientLight self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_AmbientLight_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_AmbientLight self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_AmbientLight_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_AmbientLight self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_AmbientLight_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_AmbientLight self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_AmbientLight_DecrementRefCounter(self, *args)

Handle_V3d_AmbientLight_swigregister = _V3d.Handle_V3d_AmbientLight_swigregister
Handle_V3d_AmbientLight_swigregister(Handle_V3d_AmbientLight)

def Handle_V3d_AmbientLight_DownCast(thing):
    return _V3d.Handle_V3d_AmbientLight_DownCast(thing)
Handle_V3d_AmbientLight_DownCast = _V3d.Handle_V3d_AmbientLight_DownCast

class Handle_V3d_Plane(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_Plane self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_Plane_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_Plane self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_Plane_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_Plane self, V3d_Plane thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_Plane_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_Plane self, Handle_V3d_Plane theHandle) -> Handle_V3d_Plane
        assign(Handle_V3d_Plane self, V3d_Plane thePtr) -> Handle_V3d_Plane
        assign(Handle_V3d_Plane self, Handle_V3d_Plane theHandle) -> Handle_V3d_Plane

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_Plane_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_Plane self) -> V3d_Plane

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_Plane_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_Plane self) -> V3d_Plane

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_Plane___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_Plane self) -> V3d_Plane

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_Plane___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_Plane___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_Plane___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_Plane_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_Plane

    def SetPlane(self, *args):
        """
        SetPlane(Handle_V3d_Plane self, Standard_Real const theA, Standard_Real const theB, Standard_Real const theC, Standard_Real const theD)

        Change plane equation.

        :type theA: float
        :type theB: float
        :type theC: float
        :type theD: float

        """
        return _V3d.Handle_V3d_Plane_SetPlane(self, *args)


    def Display(self, *args):
        """
        Display(Handle_V3d_Plane self, Handle_V3d_View theView, Quantity_Color theColor=Quantity_NOC_GRAY)

        Display the plane representation in the choosen view.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_Plane_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_V3d_Plane self)

        Erase the plane representation.


        """
        return _V3d.Handle_V3d_Plane_Erase(self, *args)


    def Plane(self, *args):
        """
        Plane(Handle_V3d_Plane self)

        Returns the parameters of the plane.

        :type theA: float
        :type theB: float
        :type theC: float
        :type theD: float

        """
        return _V3d.Handle_V3d_Plane_Plane(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_V3d_Plane self) -> Standard_Boolean

        Returns TRUE when the plane representation is displayed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Plane_IsDisplayed(self, *args)


    def ClipPlane(self, *args):
        """
        Use this method to pass clipping plane implementation for
        standard clipping workflow.
        @return clipping plane implementation handle.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        res = _V3d.Handle_V3d_Plane_ClipPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_Plane self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_Plane_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Plane_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_V3d_Plane self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_Plane_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Plane_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Plane_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_Plane self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_Plane_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_Plane self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Plane_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_Plane self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_Plane_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_Plane self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Plane_DecrementRefCounter(self, *args)

Handle_V3d_Plane_swigregister = _V3d.Handle_V3d_Plane_swigregister
Handle_V3d_Plane_swigregister(Handle_V3d_Plane)

def Handle_V3d_Plane_DownCast(thing):
    return _V3d.Handle_V3d_Plane_DownCast(thing)
Handle_V3d_Plane_DownCast = _V3d.Handle_V3d_Plane_DownCast

class Handle_V3d_Light(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_Light self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_Light_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_Light self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_Light_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_Light self, Graphic3d_CLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_Light_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_Light self, Handle_Graphic3d_CLight theHandle) -> Handle_Graphic3d_CLight
        assign(Handle_V3d_Light self, Graphic3d_CLight thePtr) -> Handle_Graphic3d_CLight
        assign(Handle_V3d_Light self, Handle_Graphic3d_CLight theHandle) -> Handle_Graphic3d_CLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_Light_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_Light self) -> Graphic3d_CLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_Light_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_Light self) -> Graphic3d_CLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_Light___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_Light self) -> Graphic3d_CLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_Light___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_Light___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_Light___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_Light(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_Light_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_Light

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_Light self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_Light_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Light_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Light_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_V3d_Light self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_Light_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_Light_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_Light self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_Light_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_Light_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_Light self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_Light_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_Light self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Light_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_Light self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_Light_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_Light self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Light_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_Light self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Light_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_Light self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_Light_SetHeadlight(self, *args)


    def Position(self, *args):
        """
        Returns location of positional/spot light; (0, 0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _V3d.Handle_V3d_Light_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_V3d_Light self, gp_Pnt thePosition)
        SetPosition(Handle_V3d_Light self, Standard_Real theX, Standard_Real theY, Standard_Real theZ)

        Setup location of positional/spot light.

        :type theX: float
        :type theY: float
        :type theZ: float

        """
        return _V3d.Handle_V3d_Light_SetPosition(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_Light self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_Light self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_Light self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_Light_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_Light self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_Light_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_Light self) -> gp_Dir
        Direction(Handle_V3d_Light self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_Light_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_Light self, gp_Dir theDir)
        SetDirection(Handle_V3d_Light self, Standard_Real theVx, Standard_Real theVy, Standard_Real theVz)

        Sets direction of directional/spot light.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_Light_SetDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_Light self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_Light self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_Light_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_Light self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_Light self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_Light_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_Light self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_Light self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_Light_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_Light self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_Light_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_Light self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_Light_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_Light self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_Light_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_Light_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_Light_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_Light_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_Light_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_Light self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_Light_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_Light self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_Light_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_Light self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_Light self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Light_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_Light self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_Light self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Light_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_Light self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_Light_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_Light self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Light_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_Light self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_Light_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_Light self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Light_DecrementRefCounter(self, *args)

Handle_V3d_Light_swigregister = _V3d.Handle_V3d_Light_swigregister
Handle_V3d_Light_swigregister(Handle_V3d_Light)

def Handle_V3d_Light_DownCast(thing):
    return _V3d.Handle_V3d_Light_DownCast(thing)
Handle_V3d_Light_DownCast = _V3d.Handle_V3d_Light_DownCast

class V3d_SpotLight(V3d_PositionLight):
    """
    Creation and modification of a spot.
    The attenuation factor F determines the illumination of a surface:
    @code
    F = 1/(ConstAttenuation() + LinearAttenuation() * Distance)
    @endcode
    Where Distance is the distance from the source to the surface.
    The default values (1.0, 0.0) correspond to a minimum of attenuation.
    The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_SpotLight
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_SpotLight(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_SpotLight_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_SpotLight_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_SpotLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDirection(self, *args):
        """
        SetDirection(V3d_SpotLight self, V3d_TypeOfOrientation theOrientation)

        Defines the direction of the light source
        according to a predefined directional vector.

        :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.V3d_SpotLight_SetDirection(self, *args)


    def __init__(self, *args):
        """
        __init__(V3d_SpotLight self, gp_Pnt thePos, V3d_TypeOfOrientation const theDirection=V3d_XnegYnegZpos, Quantity_Color theColor=Quantity_NOC_WHITE) -> V3d_SpotLight
        __init__(V3d_SpotLight self, gp_Pnt thePos, gp_Dir theDirection, Quantity_Color theColor=Quantity_NOC_WHITE) -> V3d_SpotLight
        __init__(V3d_SpotLight self, Handle_V3d_Viewer theViewer, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, V3d_TypeOfOrientation const theDirection=V3d_XnegYnegZpos, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Real const theConstAttenuation=1.0, Standard_Real const theLinearAttenuation=0.0, Standard_Real const theConcentration=1.0, Standard_Real const theAngle=0.523599) -> V3d_SpotLight
        __init__(V3d_SpotLight self, Handle_V3d_Viewer theViewer, Standard_Real const theXt, Standard_Real const theYt, Standard_Real const theZt, Standard_Real const theXp, Standard_Real const theYp, Standard_Real const theZp, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Real const theConstAttenuation=1.0, Standard_Real const theLinearAttenuation=0.0, Standard_Real const theConcentration=1.0, Standard_Real const theAngle=0.523599) -> V3d_SpotLight

        theXt, theYt, theZt : Coordinate of light source Target.
        theXp, theYp, theZp : Coordinate of light source Position.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theXt: float
        :type theYt: float
        :type theZt: float
        :type theXp: float
        :type theYp: float
        :type theZp: float
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theConstAttenuation: float
        :type theLinearAttenuation: float
        :type theConcentration: float
        :type theAngle: float

        """
        this = _V3d.new_V3d_SpotLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _V3d.delete_V3d_SpotLight
V3d_SpotLight_swigregister = _V3d.V3d_SpotLight_swigregister
V3d_SpotLight_swigregister(V3d_SpotLight)

def V3d_SpotLight_get_type_name(*args):
    """
    V3d_SpotLight_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_SpotLight_get_type_name(*args)

def V3d_SpotLight_get_type_descriptor(*args):
    """
    V3d_SpotLight_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_SpotLight_get_type_descriptor(*args)

class V3d_RectangularGrid(Aspect.Aspect_RectangularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_RectangularGrid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_RectangularGrid(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_RectangularGrid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_RectangularGrid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_RectangularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(V3d_RectangularGrid self, V3d_Viewer aViewer, Quantity_Color aColor, Quantity_Color aTenthColor) -> V3d_RectangularGrid

        :type aViewer: OCC.wrapper.V3d.V3d_ViewerPointer
        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        this = _V3d.new_V3d_RectangularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetColors(self, *args):
        """
        SetColors(V3d_RectangularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_RectangularGrid_SetColors(self, *args)


    def Display(self, *args):
        """
        Display(V3d_RectangularGrid self)

        Display the grid at screen.


        """
        return _V3d.V3d_RectangularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(V3d_RectangularGrid self)

        Erase the grid from screen.


        """
        return _V3d.V3d_RectangularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(V3d_RectangularGrid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_RectangularGrid_IsDisplayed(self, *args)


    def GraphicValues(self, *args):
        """
        GraphicValues(V3d_RectangularGrid self)

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.V3d_RectangularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args):
        """
        SetGraphicValues(V3d_RectangularGrid self, Standard_Real const XSize, Standard_Real const YSize, Standard_Real const OffSet)

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.V3d_RectangularGrid_SetGraphicValues(self, *args)

    __swig_destroy__ = _V3d.delete_V3d_RectangularGrid
V3d_RectangularGrid_swigregister = _V3d.V3d_RectangularGrid_swigregister
V3d_RectangularGrid_swigregister(V3d_RectangularGrid)

def V3d_RectangularGrid_get_type_name(*args):
    """
    V3d_RectangularGrid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_RectangularGrid_get_type_name(*args)

def V3d_RectangularGrid_get_type_descriptor(*args):
    """
    V3d_RectangularGrid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_RectangularGrid_get_type_descriptor(*args)

class Handle_V3d_Viewer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_Viewer self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_Viewer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_Viewer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_Viewer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_Viewer self, V3d_Viewer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_Viewer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_Viewer self, Handle_V3d_Viewer theHandle) -> Handle_V3d_Viewer
        assign(Handle_V3d_Viewer self, V3d_Viewer thePtr) -> Handle_V3d_Viewer
        assign(Handle_V3d_Viewer self, Handle_V3d_Viewer theHandle) -> Handle_V3d_Viewer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_Viewer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_Viewer self) -> V3d_Viewer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_Viewer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_Viewer self) -> V3d_Viewer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_Viewer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_Viewer self) -> V3d_Viewer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_Viewer___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_Viewer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_Viewer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_Viewer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_Viewer_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_Viewer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_Viewer self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_Viewer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Viewer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Viewer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IfMoreViews(self, *args):
        """
        IfMoreViews(Handle_V3d_Viewer self) -> Standard_Boolean

        Returns True if One View more can be defined in this Viewer.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_IfMoreViews(self, *args)


    def CreateView(self, *args):
        """
        CreateView(Handle_V3d_Viewer self) -> Handle_V3d_View

        Creates a view in the viewer according to its default parameters.

        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.Handle_V3d_Viewer_CreateView(self, *args)


    def SetViewOn(self, *args):
        """
        SetViewOn(Handle_V3d_Viewer self)
        SetViewOn(Handle_V3d_Viewer self, Handle_V3d_View theView)

        Activates a particular view in the Viewer.
        Must be call if the Window attached to the view has been Deiconified.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.Handle_V3d_Viewer_SetViewOn(self, *args)


    def SetViewOff(self, *args):
        """
        SetViewOff(Handle_V3d_Viewer self)
        SetViewOff(Handle_V3d_Viewer self, Handle_V3d_View theView)

        Deactivates a particular view in the Viewer.
        Must be call if the Window attached to the view
        has been Iconified .

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.Handle_V3d_Viewer_SetViewOff(self, *args)


    def Update(self, *args):
        """
        Update(Handle_V3d_Viewer self)

        Deprecated, Redraw() should be used instead.


        """
        return _V3d.Handle_V3d_Viewer_Update(self, *args)


    def Redraw(self, *args):
        """
        Redraw(Handle_V3d_Viewer self)

        Redraws all the views of the Viewer even if no
        modification has taken place. Must be called if
        all the views of the Viewer are exposed, as for
        example in a global DeIconification.


        """
        return _V3d.Handle_V3d_Viewer_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(Handle_V3d_Viewer self)

        Updates layer of immediate presentations.


        """
        return _V3d.Handle_V3d_Viewer_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(Handle_V3d_Viewer self)

        Invalidates viewer content but does not redraw it.


        """
        return _V3d.Handle_V3d_Viewer_Invalidate(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_V3d_Viewer self)

        Suppresses the Viewer.


        """
        return _V3d.Handle_V3d_Viewer_Remove(self, *args)


    def Driver(self, *args):
        """
        Return Graphic Driver instance.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_GraphicDriver

        """
        res = _V3d.Handle_V3d_Viewer_Driver(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StructureManager(self, *args):
        """
        StructureManager(Handle_V3d_Viewer self) -> Handle_Graphic3d_StructureManager

        Returns the structure manager associated to this viewer.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager

        """
        return _V3d.Handle_V3d_Viewer_StructureManager(self, *args)


    def DefaultRenderingParams(self, *args):
        """
        Return default Rendering Parameters.
        By default these parameters are set in a new V3d_View.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        res = _V3d.Handle_V3d_Viewer_DefaultRenderingParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultRenderingParams(self, *args):
        """
        SetDefaultRenderingParams(Handle_V3d_Viewer self, Graphic3d_RenderingParams theParams)

        Set default Rendering Parameters.

        :type theParams: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultRenderingParams(self, *args)


    def SetDefaultBackgroundColor(self, *args):
        """
        SetDefaultBackgroundColor(Handle_V3d_Viewer self, Quantity_Color theColor)
        SetDefaultBackgroundColor(Handle_V3d_Viewer self, Quantity_TypeOfColor const theType, Standard_Real const theV1, Standard_Real const theV2, Standard_Real const theV3)

        Defines the default base colour of views attached
        to the Viewer by supplying the type of colour
        definition and the three component values.

        :type theType: OCC.wrapper.Quantity.Quantity_TypeOfColor
        :type theV1: float
        :type theV2: float
        :type theV3: float

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultBackgroundColor(self, *args)


    def GetGradientBackground(self, *args):
        """
        Returns the gradient background of the view.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        res = _V3d.Handle_V3d_Viewer_GetGradientBackground(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultBgGradientColors(self, *args):
        """
        SetDefaultBgGradientColors(Handle_V3d_Viewer self, Quantity_Color theColor1, Quantity_Color theColor2, Aspect_GradientFillMethod const theFillStyle=Aspect_GFM_HOR)

        Defines the default gradient background colours of views
        attached to the viewer by supplying the colour objects

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_GradientFillMethod

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultBgGradientColors(self, *args)


    def DefaultViewSize(self, *args):
        """
        DefaultViewSize(Handle_V3d_Viewer self) -> Standard_Real

        Returns the default size of the view.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_Viewer_DefaultViewSize(self, *args)


    def SetDefaultViewSize(self, *args):
        """
        SetDefaultViewSize(Handle_V3d_Viewer self, Standard_Real const theSize)

        Gives a default size for the creation of views of the viewer.

        :type theSize: float

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultViewSize(self, *args)


    def DefaultViewProj(self, *args):
        """
        DefaultViewProj(Handle_V3d_Viewer self) -> V3d_TypeOfOrientation

        Returns the default Projection.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_Viewer_DefaultViewProj(self, *args)


    def SetDefaultViewProj(self, *args):
        """
        SetDefaultViewProj(Handle_V3d_Viewer self, V3d_TypeOfOrientation const theOrientation)

        Sets the default projection for creating views in the viewer.

        :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultViewProj(self, *args)


    def DefaultVisualization(self, *args):
        """
        DefaultVisualization(Handle_V3d_Viewer self) -> V3d_TypeOfVisualization

        Returns the default type of Visualization.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.Handle_V3d_Viewer_DefaultVisualization(self, *args)


    def SetDefaultVisualization(self, *args):
        """
        SetDefaultVisualization(Handle_V3d_Viewer self, V3d_TypeOfVisualization const theType)

        Gives the default visualization mode.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultVisualization(self, *args)


    def DefaultShadingModel(self, *args):
        """
        DefaultShadingModel(Handle_V3d_Viewer self) -> Graphic3d_TypeOfShadingModel

        Returns the default type of Shading

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.Handle_V3d_Viewer_DefaultShadingModel(self, *args)


    def SetDefaultShadingModel(self, *args):
        """
        SetDefaultShadingModel(Handle_V3d_Viewer self, Graphic3d_TypeOfShadingModel const theType)

        Gives the default type of SHADING.

        :type theType: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultShadingModel(self, *args)


    def DefaultTypeOfView(self, *args):
        """
        DefaultTypeOfView(Handle_V3d_Viewer self) -> V3d_TypeOfView

        Returns the default type of View (orthographic or perspective projection) to be returned by CreateView() method.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.Handle_V3d_Viewer_DefaultTypeOfView(self, *args)


    def SetDefaultTypeOfView(self, *args):
        """
        SetDefaultTypeOfView(Handle_V3d_Viewer self, V3d_TypeOfView const theType)

        Set the default type of View (orthographic or perspective projection) to be returned by CreateView() method.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultTypeOfView(self, *args)


    def DefaultBackgroundColor(self, *args):
        """
        DefaultBackgroundColor(Handle_V3d_Viewer self) -> Quantity_Color
        DefaultBackgroundColor(Handle_V3d_Viewer self, Quantity_TypeOfColor const theType)

        :type theType: OCC.wrapper.Quantity.Quantity_TypeOfColor
        :type theV1: float
        :type theV2: float
        :type theV3: float

        """
        return _V3d.Handle_V3d_Viewer_DefaultBackgroundColor(self, *args)


    def DefaultBgGradientColors(self, *args):
        """
        DefaultBgGradientColors(Handle_V3d_Viewer self, Quantity_Color theColor1, Quantity_Color theColor2)

        Returns the gradient background colour objects of the view.

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_Viewer_DefaultBgGradientColors(self, *args)


    def GetAllZLayers(self, *args):
        """
        GetAllZLayers(Handle_V3d_Viewer self, NCollection_Sequence_Standard_Integer theLayerSeq)

        Return all Z layer ids in sequence ordered by overlay level from lowest layer to highest ( foreground ).
        The first layer ID in sequence is the default layer that can't be removed.

        :type theLayerSeq: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _V3d.Handle_V3d_Viewer_GetAllZLayers(self, *args)


    def AddZLayer(self, *args):
        """
        AddZLayer(Handle_V3d_Viewer self) -> Standard_Boolean

        Add a new top-level Z layer to all managed views and get its ID as <theLayerId> value.
        The Z layers are controlled entirely by viewer, it is not possible to add a layer to a particular view.
        The method returns Standard_False if the layer can not be created.
        The layer mechanism allows to display structures in higher layers in overlay of structures in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_AddZLayer(self, *args)


    def RemoveZLayer(self, *args):
        """
        RemoveZLayer(Handle_V3d_Viewer self, Graphic3d_ZLayerId const theLayerId) -> Standard_Boolean

        Remove Z layer with ID <theLayerId>.
        Method returns Standard_False if the layer can not be removed or doesn't exists.
        By default, there are always default bottom-level layer that can't be removed.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_RemoveZLayer(self, *args)


    def ZLayerSettings(self, *args):
        """
        ZLayerSettings(Handle_V3d_Viewer self, Graphic3d_ZLayerId const theLayerId) -> Graphic3d_ZLayerSettings

        Returns the settings of a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _V3d.Handle_V3d_Viewer_ZLayerSettings(self, *args)


    def SetZLayerSettings(self, *args):
        """
        SetZLayerSettings(Handle_V3d_Viewer self, Graphic3d_ZLayerId const theLayerId, Graphic3d_ZLayerSettings const & theSettings)

        Sets the settings for a single Z layer.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId
        :type theSettings: OCC.wrapper.Graphic3d.Graphic3d_ZLayerSettings

        """
        return _V3d.Handle_V3d_Viewer_SetZLayerSettings(self, *args)


    def ActiveViewIterator(self, *args):
        """
        ActiveViewIterator(Handle_V3d_Viewer self) -> V3d_ListOfViewIterator

        Return an iterator for active views.

        :rtype: OCC.wrapper.V3d.V3d_ListOfViewIterator

        """
        return _V3d.Handle_V3d_Viewer_ActiveViewIterator(self, *args)


    def InitActiveViews(self, *args):
        """
        InitActiveViews(Handle_V3d_Viewer self)

        Initializes an internal iterator on the active views.


        """
        return _V3d.Handle_V3d_Viewer_InitActiveViews(self, *args)


    def MoreActiveViews(self, *args):
        """
        MoreActiveViews(Handle_V3d_Viewer self) -> Standard_Boolean

        Returns true if there are more active view(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_MoreActiveViews(self, *args)


    def NextActiveViews(self, *args):
        """
        NextActiveViews(Handle_V3d_Viewer self)

        Go to the next active view (if there is not, ActiveView will raise an exception)


        """
        return _V3d.Handle_V3d_Viewer_NextActiveViews(self, *args)


    def ActiveView(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _V3d.Handle_V3d_Viewer_ActiveView(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastActiveView(self, *args):
        """
        LastActiveView(Handle_V3d_Viewer self) -> Standard_Boolean

        returns true if there is only one active view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_LastActiveView(self, *args)


    def DefinedViewIterator(self, *args):
        """
        DefinedViewIterator(Handle_V3d_Viewer self) -> V3d_ListOfViewIterator

        Return an iterator for defined views.

        :rtype: OCC.wrapper.V3d.V3d_ListOfViewIterator

        """
        return _V3d.Handle_V3d_Viewer_DefinedViewIterator(self, *args)


    def InitDefinedViews(self, *args):
        """
        InitDefinedViews(Handle_V3d_Viewer self)

        Initializes an internal iterator on the Defined views.


        """
        return _V3d.Handle_V3d_Viewer_InitDefinedViews(self, *args)


    def MoreDefinedViews(self, *args):
        """
        MoreDefinedViews(Handle_V3d_Viewer self) -> Standard_Boolean

        returns true if there are more Defined view(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_MoreDefinedViews(self, *args)


    def NextDefinedViews(self, *args):
        """
        NextDefinedViews(Handle_V3d_Viewer self)

        Go to the next Defined view (if there is not, DefinedView will raise an exception)


        """
        return _V3d.Handle_V3d_Viewer_NextDefinedViews(self, *args)


    def DefinedView(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _V3d.Handle_V3d_Viewer_DefinedView(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultLights(self, *args):
        """
        SetDefaultLights(Handle_V3d_Viewer self)

        Defines default lights:
        positional-light 0.3 0. 0.
        directional-light V3d_XnegYposZpos
        directional-light V3d_XnegYneg
        ambient-light


        """
        return _V3d.Handle_V3d_Viewer_SetDefaultLights(self, *args)


    def SetLightOn(self, *args):
        """
        SetLightOn(Handle_V3d_Viewer self, Handle_Graphic3d_CLight theLight)
        SetLightOn(Handle_V3d_Viewer self)

        Activates all the lights defined in this viewer.


        """
        return _V3d.Handle_V3d_Viewer_SetLightOn(self, *args)


    def SetLightOff(self, *args):
        """
        SetLightOff(Handle_V3d_Viewer self, Handle_Graphic3d_CLight theLight)
        SetLightOff(Handle_V3d_Viewer self)

        Deactivate all the Lights defined in this viewer.


        """
        return _V3d.Handle_V3d_Viewer_SetLightOff(self, *args)


    def AddLight(self, *args):
        """
        AddLight(Handle_V3d_Viewer self, Handle_Graphic3d_CLight theLight)

        Adds Light in Sequence Of Lights.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light

        """
        return _V3d.Handle_V3d_Viewer_AddLight(self, *args)


    def DelLight(self, *args):
        """
        DelLight(Handle_V3d_Viewer self, Handle_Graphic3d_CLight theLight)

        Delete Light in Sequence Of Lights.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light

        """
        return _V3d.Handle_V3d_Viewer_DelLight(self, *args)


    def UpdateLights(self, *args):
        """
        UpdateLights(Handle_V3d_Viewer self)

        Updates the lights of all the views of a viewer.


        """
        return _V3d.Handle_V3d_Viewer_UpdateLights(self, *args)


    def IsGlobalLight(self, *args):
        """
        IsGlobalLight(Handle_V3d_Viewer self, Handle_Graphic3d_CLight TheLight) -> Standard_Boolean

        :type TheLight: OCC.wrapper.V3d.Handle_V3d_Light
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_IsGlobalLight(self, *args)


    def ActiveLightIterator(self, *args):
        """
        ActiveLightIterator(Handle_V3d_Viewer self) -> V3d_ListOfLightIterator

        Return an iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.Handle_V3d_Viewer_ActiveLightIterator(self, *args)


    def InitActiveLights(self, *args):
        """
        InitActiveLights(Handle_V3d_Viewer self)

        Initializes an internal iteratator on the active Lights.


        """
        return _V3d.Handle_V3d_Viewer_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args):
        """
        MoreActiveLights(Handle_V3d_Viewer self) -> Standard_Boolean

        returns true if there are more active Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args):
        """
        NextActiveLights(Handle_V3d_Viewer self)

        Go to the next active Light (if there is not, ActiveLight() will raise an exception)


        """
        return _V3d.Handle_V3d_Viewer_NextActiveLights(self, *args)


    def ActiveLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.Handle_V3d_Viewer_ActiveLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefinedLightIterator(self, *args):
        """
        DefinedLightIterator(Handle_V3d_Viewer self) -> V3d_ListOfLightIterator

        Return an iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.Handle_V3d_Viewer_DefinedLightIterator(self, *args)


    def InitDefinedLights(self, *args):
        """
        InitDefinedLights(Handle_V3d_Viewer self)

        Initializes an internal iterattor on the Defined Lights.


        """
        return _V3d.Handle_V3d_Viewer_InitDefinedLights(self, *args)


    def MoreDefinedLights(self, *args):
        """
        MoreDefinedLights(Handle_V3d_Viewer self) -> Standard_Boolean

        Returns true if there are more Defined Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_MoreDefinedLights(self, *args)


    def NextDefinedLights(self, *args):
        """
        NextDefinedLights(Handle_V3d_Viewer self)

        Go to the next Defined Light (if there is not, DefinedLight() will raise an exception)


        """
        return _V3d.Handle_V3d_Viewer_NextDefinedLights(self, *args)


    def DefinedLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.Handle_V3d_Viewer_DefinedLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Erase(self, *args):
        """
        Erase(Handle_V3d_Viewer self)

        Erase all Objects in All the views.


        """
        return _V3d.Handle_V3d_Viewer_Erase(self, *args)


    def UnHighlight(self, *args):
        """
        UnHighlight(Handle_V3d_Viewer self)

        UnHighlight all Objects in All the views.


        """
        return _V3d.Handle_V3d_Viewer_UnHighlight(self, *args)


    def ComputedMode(self, *args):
        """
        ComputedMode(Handle_V3d_Viewer self) -> Standard_Boolean

        returns true if the computed mode can be used.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_ComputedMode(self, *args)


    def SetComputedMode(self, *args):
        """
        SetComputedMode(Handle_V3d_Viewer self, Standard_Boolean const theMode)

        Set if the computed mode can be used.

        :type theMode: bool

        """
        return _V3d.Handle_V3d_Viewer_SetComputedMode(self, *args)


    def DefaultComputedMode(self, *args):
        """
        DefaultComputedMode(Handle_V3d_Viewer self) -> Standard_Boolean

        returns true if by default the computed mode must be used.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_DefaultComputedMode(self, *args)


    def SetDefaultComputedMode(self, *args):
        """
        SetDefaultComputedMode(Handle_V3d_Viewer self, Standard_Boolean const theMode)

        Set if by default the computed mode must be used.

        :type theMode: bool

        """
        return _V3d.Handle_V3d_Viewer_SetDefaultComputedMode(self, *args)


    def PrivilegedPlane(self, *args):
        """
        @name privileged plane management

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _V3d.Handle_V3d_Viewer_PrivilegedPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPrivilegedPlane(self, *args):
        """
        SetPrivilegedPlane(Handle_V3d_Viewer self, gp_Ax3 thePlane)

        :type thePlane: OCC.wrapper.gp.gp_Ax3

        """
        return _V3d.Handle_V3d_Viewer_SetPrivilegedPlane(self, *args)


    def DisplayPrivilegedPlane(self, *args):
        """
        DisplayPrivilegedPlane(Handle_V3d_Viewer self, Standard_Boolean const theOnOff, Standard_Real const theSize=1)

        :type theOnOff: bool
        :type theSize: float

        """
        return _V3d.Handle_V3d_Viewer_DisplayPrivilegedPlane(self, *args)


    def ActivateGrid(self, *args):
        """
        ActivateGrid(Handle_V3d_Viewer self, Aspect_GridType const aGridType, Aspect_GridDrawMode const aGridDrawMode)

        Activates the grid in all views of <me>.

        :type aGridType: OCC.wrapper.Aspect.Aspect_GridType
        :type aGridDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_Viewer_ActivateGrid(self, *args)


    def DeactivateGrid(self, *args):
        """
        DeactivateGrid(Handle_V3d_Viewer self)

        Deactivates the grid in all views of <me>.


        """
        return _V3d.Handle_V3d_Viewer_DeactivateGrid(self, *args)


    def SetGridEcho(self, *args):
        """
        SetGridEcho(Handle_V3d_Viewer self, Standard_Boolean const showGrid)
        SetGridEcho(Handle_V3d_Viewer self, Handle_Graphic3d_AspectMarker3d aMarker)

        Show grid echo <aMarker> to the hit point.
        Warning: When the grid echo marker is not set,
        a default marker is build with the attributes:
        marker type : Aspect_TOM_STAR
        marker color : Quantity_NOC_GRAY90
        marker size : 3.0

        :type aMarker: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _V3d.Handle_V3d_Viewer_SetGridEcho(self, *args)


    def GridEcho(self, *args):
        """
        GridEcho(Handle_V3d_Viewer self) -> Standard_Boolean

        Returns TRUE when grid echo must be displayed at hit point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_GridEcho(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_V3d_Viewer self) -> Standard_Boolean

        Returns Standard_True if a grid is activated in <me>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_IsActive(self, *args)


    def Grid(self, *args):
        """
        Grid(Handle_V3d_Viewer self) -> Handle_Aspect_Grid

        Returns the defined grid in <me>.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Grid

        """
        return _V3d.Handle_V3d_Viewer_Grid(self, *args)


    def GridType(self, *args):
        """
        GridType(Handle_V3d_Viewer self) -> Aspect_GridType

        Returns the current grid type defined in <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_GridType

        """
        return _V3d.Handle_V3d_Viewer_GridType(self, *args)


    def GridDrawMode(self, *args):
        """
        GridDrawMode(Handle_V3d_Viewer self) -> Aspect_GridDrawMode

        Returns the current grid draw mode defined in <me>.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_Viewer_GridDrawMode(self, *args)


    def RectangularGridValues(self, *args):
        """
        RectangularGridValues(Handle_V3d_Viewer self)

        Returns the definition of the rectangular grid.

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_Viewer_RectangularGridValues(self, *args)


    def SetRectangularGridValues(self, *args):
        """
        SetRectangularGridValues(Handle_V3d_Viewer self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const XStep, Standard_Real const YStep, Standard_Real const RotationAngle)

        Sets the definition of the rectangular grid.
        <XOrigin>, <YOrigin> defines the origin of the grid.
        <XStep> defines the interval between 2 vertical lines.
        <YStep> defines the interval between 2 horizontal lines.
        <RotationAngle> defines the rotation angle of the grid.

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_Viewer_SetRectangularGridValues(self, *args)


    def CircularGridValues(self, *args):
        """
        CircularGridValues(Handle_V3d_Viewer self)

        Returns the definition of the circular grid.

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_Viewer_CircularGridValues(self, *args)


    def SetCircularGridValues(self, *args):
        """
        SetCircularGridValues(Handle_V3d_Viewer self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const RadiusStep, Standard_Integer const DivisionNumber, Standard_Real const RotationAngle)

        Sets the definition of the circular grid.
        <XOrigin>, <YOrigin> defines the origin of the grid.
        <RadiusStep> defines the interval between 2 circles.
        <DivisionNumber> defines the section number of one half circle.
        <RotationAngle> defines the rotation angle of the grid.

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_Viewer_SetCircularGridValues(self, *args)


    def CircularGridGraphicValues(self, *args):
        """
        CircularGridGraphicValues(Handle_V3d_Viewer self)

        Returns the location and the size of the grid.

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_Viewer_CircularGridGraphicValues(self, *args)


    def SetCircularGridGraphicValues(self, *args):
        """
        SetCircularGridGraphicValues(Handle_V3d_Viewer self, Standard_Real const Radius, Standard_Real const OffSet)

        Sets the location and the size of the grid.
        <XSize> defines the width of the grid.
        <YSize> defines the height of the grid.
        <OffSet> defines the displacement along the plane normal.

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_Viewer_SetCircularGridGraphicValues(self, *args)


    def RectangularGridGraphicValues(self, *args):
        """
        RectangularGridGraphicValues(Handle_V3d_Viewer self)

        Returns the location and the size of the grid.

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_Viewer_RectangularGridGraphicValues(self, *args)


    def SetRectangularGridGraphicValues(self, *args):
        """
        SetRectangularGridGraphicValues(Handle_V3d_Viewer self, Standard_Real const XSize, Standard_Real const YSize, Standard_Real const OffSet)

        Sets the location and the size of the grid.
        <XSize> defines the width of the grid.
        <YSize> defines the height of the grid.
        <OffSet> defines the displacement along the plane normal.

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_Viewer_SetRectangularGridGraphicValues(self, *args)


    def ShowGridEcho(self, *args):
        """
        ShowGridEcho(Handle_V3d_Viewer self, Handle_V3d_View theView, Graphic3d_Vertex thePoint)

        Display grid echo at requested point in the view.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type thePoint: OCC.wrapper.Graphic3d.Graphic3d_Vertex

        """
        return _V3d.Handle_V3d_Viewer_ShowGridEcho(self, *args)


    def HideGridEcho(self, *args):
        """
        HideGridEcho(Handle_V3d_Viewer self, Handle_V3d_View theView)

        Temporarly hide grid echo.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.Handle_V3d_Viewer_HideGridEcho(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_Viewer self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_Viewer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_Viewer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_Viewer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_Viewer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_Viewer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Viewer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_Viewer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_Viewer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_Viewer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Viewer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_Viewer self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_Viewer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_Viewer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Viewer_DecrementRefCounter(self, *args)

Handle_V3d_Viewer_swigregister = _V3d.Handle_V3d_Viewer_swigregister
Handle_V3d_Viewer_swigregister(Handle_V3d_Viewer)

def Handle_V3d_Viewer_DownCast(thing):
    return _V3d.Handle_V3d_Viewer_DownCast(thing)
Handle_V3d_Viewer_DownCast = _V3d.Handle_V3d_Viewer_DownCast

class Handle_V3d_UnMapped(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_UnMapped self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_UnMapped_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_UnMapped self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_UnMapped_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_UnMapped self, V3d_UnMapped thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_UnMapped_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_UnMapped self, Handle_V3d_UnMapped theHandle) -> Handle_V3d_UnMapped
        assign(Handle_V3d_UnMapped self, V3d_UnMapped thePtr) -> Handle_V3d_UnMapped
        assign(Handle_V3d_UnMapped self, Handle_V3d_UnMapped theHandle) -> Handle_V3d_UnMapped

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_UnMapped_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_UnMapped self) -> V3d_UnMapped

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_UnMapped_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_UnMapped self) -> V3d_UnMapped

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_UnMapped___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_UnMapped self) -> V3d_UnMapped

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_UnMapped___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_UnMapped___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_UnMapped___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_UnMapped(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_UnMapped_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_UnMapped

    def NewInstance(self, *args):
        """
        NewInstance(Handle_V3d_UnMapped self, Standard_CString const theMessage) -> Handle_V3d_UnMapped

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.V3d.Handle_V3d_UnMapped

        """
        return _V3d.Handle_V3d_UnMapped_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_UnMapped self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_UnMapped_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_UnMapped_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_UnMapped_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_V3d_UnMapped self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _V3d.Handle_V3d_UnMapped_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_V3d_UnMapped self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _V3d.Handle_V3d_UnMapped_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_V3d_UnMapped self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _V3d.Handle_V3d_UnMapped_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_V3d_UnMapped self)
        Reraise(Handle_V3d_UnMapped self, Standard_CString const aMessage)
        Reraise(Handle_V3d_UnMapped self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _V3d.Handle_V3d_UnMapped_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_V3d_UnMapped self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _V3d.Handle_V3d_UnMapped_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_V3d_UnMapped self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _V3d.Handle_V3d_UnMapped_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_UnMapped self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_UnMapped_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_UnMapped self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_UnMapped self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_UnMapped_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_UnMapped self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_UnMapped self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_UnMapped_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_UnMapped self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_UnMapped_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_UnMapped self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_UnMapped_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_UnMapped self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_UnMapped_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_UnMapped self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_UnMapped_DecrementRefCounter(self, *args)

Handle_V3d_UnMapped_swigregister = _V3d.Handle_V3d_UnMapped_swigregister
Handle_V3d_UnMapped_swigregister(Handle_V3d_UnMapped)

def Handle_V3d_UnMapped_DownCast(thing):
    return _V3d.Handle_V3d_UnMapped_DownCast(thing)
Handle_V3d_UnMapped_DownCast = _V3d.Handle_V3d_UnMapped_DownCast

class Handle_V3d_PositionLight(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_PositionLight self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_PositionLight_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_PositionLight self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_PositionLight_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_PositionLight self, V3d_PositionLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_PositionLight_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_PositionLight self, Handle_V3d_PositionLight theHandle) -> Handle_V3d_PositionLight
        assign(Handle_V3d_PositionLight self, V3d_PositionLight thePtr) -> Handle_V3d_PositionLight
        assign(Handle_V3d_PositionLight self, Handle_V3d_PositionLight theHandle) -> Handle_V3d_PositionLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_PositionLight_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_PositionLight self) -> V3d_PositionLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_PositionLight_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_PositionLight self) -> V3d_PositionLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_PositionLight___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_PositionLight self) -> V3d_PositionLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_PositionLight___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_PositionLight___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_PositionLight___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_PositionLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_PositionLight_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_PositionLight

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_PositionLight self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_PositionLight_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_PositionLight_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_PositionLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_V3d_PositionLight self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_PositionLight_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_PositionLight_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_PositionLight self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_PositionLight_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_PositionLight_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_PositionLight self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_PositionLight_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_PositionLight self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionLight_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_PositionLight self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_PositionLight_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_PositionLight self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionLight_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_PositionLight self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionLight_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_PositionLight self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_PositionLight_SetHeadlight(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_PositionLight self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_PositionLight_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_PositionLight self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_PositionLight_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_PositionLight self) -> gp_Dir
        Direction(Handle_V3d_PositionLight self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_PositionLight_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_PositionLight self, gp_Dir theDir)
        SetDirection(Handle_V3d_PositionLight self, Standard_Real theVx, Standard_Real theVy, Standard_Real theVz)

        Sets direction of directional/spot light.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_PositionLight_SetDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_PositionLight self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_PositionLight_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_PositionLight self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_PositionLight_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_PositionLight self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionLight_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_PositionLight self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_PositionLight_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_PositionLight self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionLight_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_PositionLight self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_PositionLight_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_PositionLight_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionLight_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionLight_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_PositionLight_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_PositionLight self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_PositionLight_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_PositionLight self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_PositionLight_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_PositionLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_PositionLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionLight_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_PositionLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_PositionLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_PositionLight_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_PositionLight self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_PositionLight_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_PositionLight self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_PositionLight_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_PositionLight self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_PositionLight_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_PositionLight self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_PositionLight_DecrementRefCounter(self, *args)

Handle_V3d_PositionLight_swigregister = _V3d.Handle_V3d_PositionLight_swigregister
Handle_V3d_PositionLight_swigregister(Handle_V3d_PositionLight)

def Handle_V3d_PositionLight_DownCast(thing):
    return _V3d.Handle_V3d_PositionLight_DownCast(thing)
Handle_V3d_PositionLight_DownCast = _V3d.Handle_V3d_PositionLight_DownCast

class V3d_CircularGrid(Aspect.Aspect_CircularGrid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_V3d_CircularGrid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_V3d_CircularGrid(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _V3d.V3d_CircularGrid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _V3d.V3d_CircularGrid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.V3d_CircularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(V3d_CircularGrid self, V3d_Viewer aViewer, Quantity_Color aColor, Quantity_Color aTenthColor) -> V3d_CircularGrid

        :type aViewer: OCC.wrapper.V3d.V3d_ViewerPointer
        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        this = _V3d.new_V3d_CircularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetColors(self, *args):
        """
        SetColors(V3d_CircularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.V3d_CircularGrid_SetColors(self, *args)


    def Display(self, *args):
        """
        Display(V3d_CircularGrid self)

        Display the grid at screen.


        """
        return _V3d.V3d_CircularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(V3d_CircularGrid self)

        Erase the grid from screen.


        """
        return _V3d.V3d_CircularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(V3d_CircularGrid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d_CircularGrid_IsDisplayed(self, *args)


    def GraphicValues(self, *args):
        """
        GraphicValues(V3d_CircularGrid self)

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.V3d_CircularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args):
        """
        SetGraphicValues(V3d_CircularGrid self, Standard_Real const Radius, Standard_Real const OffSet)

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.V3d_CircularGrid_SetGraphicValues(self, *args)

    __swig_destroy__ = _V3d.delete_V3d_CircularGrid
V3d_CircularGrid_swigregister = _V3d.V3d_CircularGrid_swigregister
V3d_CircularGrid_swigregister(V3d_CircularGrid)

def V3d_CircularGrid_get_type_name(*args):
    """
    V3d_CircularGrid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _V3d.V3d_CircularGrid_get_type_name(*args)

def V3d_CircularGrid_get_type_descriptor(*args):
    """
    V3d_CircularGrid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _V3d.V3d_CircularGrid_get_type_descriptor(*args)

class Handle_V3d_CircularGrid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_CircularGrid self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_CircularGrid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_CircularGrid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_CircularGrid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_CircularGrid self, V3d_CircularGrid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_CircularGrid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_CircularGrid self, Handle_V3d_CircularGrid theHandle) -> Handle_V3d_CircularGrid
        assign(Handle_V3d_CircularGrid self, V3d_CircularGrid thePtr) -> Handle_V3d_CircularGrid
        assign(Handle_V3d_CircularGrid self, Handle_V3d_CircularGrid theHandle) -> Handle_V3d_CircularGrid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_CircularGrid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_CircularGrid self) -> V3d_CircularGrid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_CircularGrid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_CircularGrid self) -> V3d_CircularGrid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_CircularGrid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_CircularGrid self) -> V3d_CircularGrid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_CircularGrid___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_CircularGrid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_CircularGrid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_CircularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_CircularGrid_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_CircularGrid

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_CircularGrid self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_CircularGrid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_CircularGrid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_CircularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(Handle_V3d_CircularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_CircularGrid_SetColors(self, *args)


    def Display(self, *args):
        """
        Display(Handle_V3d_CircularGrid self)

        Display the grid at screen.


        """
        return _V3d.Handle_V3d_CircularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_V3d_CircularGrid self)

        Erase the grid from screen.


        """
        return _V3d.Handle_V3d_CircularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_V3d_CircularGrid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_CircularGrid_IsDisplayed(self, *args)


    def GraphicValues(self, *args):
        """
        GraphicValues(Handle_V3d_CircularGrid self)

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_CircularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args):
        """
        SetGraphicValues(Handle_V3d_CircularGrid self, Standard_Real const Radius, Standard_Real const OffSet)

        :type Radius: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetGraphicValues(self, *args)


    def SetRadiusStep(self, *args):
        """
        SetRadiusStep(Handle_V3d_CircularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetRadiusStep(self, *args)


    def SetDivisionNumber(self, *args):
        """
        SetDivisionNumber(Handle_V3d_CircularGrid self, Standard_Integer const aNumber)

        defines the step of the grid.

        :type aNumber: int

        """
        return _V3d.Handle_V3d_CircularGrid_SetDivisionNumber(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Handle_V3d_CircularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const RadiusStep, Standard_Integer const DivisionNumber, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type RadiusStep: float
        :type DivisionNumber: int
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_V3d_CircularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _V3d.Handle_V3d_CircularGrid_Compute(self, *args)


    def RadiusStep(self, *args):
        """
        RadiusStep(Handle_V3d_CircularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_CircularGrid_RadiusStep(self, *args)


    def DivisionNumber(self, *args):
        """
        DivisionNumber(Handle_V3d_CircularGrid self) -> Standard_Integer

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_CircularGrid_DivisionNumber(self, *args)


    def Init(self, *args):
        """Init(Handle_V3d_CircularGrid self)"""
        return _V3d.Handle_V3d_CircularGrid_Init(self, *args)


    def SetXOrigin(self, *args):
        """
        SetXOrigin(Handle_V3d_CircularGrid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Handle_V3d_CircularGrid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Handle_V3d_CircularGrid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _V3d.Handle_V3d_CircularGrid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_V3d_CircularGrid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _V3d.Handle_V3d_CircularGrid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_V3d_CircularGrid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _V3d.Handle_V3d_CircularGrid_Translate(self, *args)


    def Hit(self, *args):
        """
        Hit(Handle_V3d_CircularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _V3d.Handle_V3d_CircularGrid_Hit(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_V3d_CircularGrid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _V3d.Handle_V3d_CircularGrid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_V3d_CircularGrid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _V3d.Handle_V3d_CircularGrid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Handle_V3d_CircularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_CircularGrid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Handle_V3d_CircularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_CircularGrid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Handle_V3d_CircularGrid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_CircularGrid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_V3d_CircularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_CircularGrid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Handle_V3d_CircularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_CircularGrid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Handle_V3d_CircularGrid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_CircularGrid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Handle_V3d_CircularGrid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_CircularGrid_DrawMode(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_CircularGrid self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_CircularGrid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_CircularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_CircularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_CircularGrid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_CircularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_CircularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_CircularGrid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_CircularGrid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_CircularGrid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_CircularGrid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_CircularGrid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_CircularGrid self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_CircularGrid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_CircularGrid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_CircularGrid_DecrementRefCounter(self, *args)

Handle_V3d_CircularGrid_swigregister = _V3d.Handle_V3d_CircularGrid_swigregister
Handle_V3d_CircularGrid_swigregister(Handle_V3d_CircularGrid)

def Handle_V3d_CircularGrid_DownCast(thing):
    return _V3d.Handle_V3d_CircularGrid_DownCast(thing)
Handle_V3d_CircularGrid_DownCast = _V3d.Handle_V3d_CircularGrid_DownCast

class Handle_V3d_View(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_View self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_View_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_View self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_View_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_View self, V3d_View thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_View_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_View self, Handle_V3d_View theHandle) -> Handle_V3d_View
        assign(Handle_V3d_View self, V3d_View thePtr) -> Handle_V3d_View
        assign(Handle_V3d_View self, Handle_V3d_View theHandle) -> Handle_V3d_View

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_View_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_View self) -> V3d_View

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_View_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_View self) -> V3d_View

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_View___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_View self) -> V3d_View

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_View___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_View___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_View___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_View(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_View_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_View

    def SetWindow(self, *args):
        """
        SetWindow(Handle_V3d_View self, Handle_Aspect_Window theWindow, Aspect_RenderingContext const theContext=None)

        Activates the view in the specified Window
        If <aContext> is not NULL the graphic context is used
        to draw something in this view.
        Otherwise an internal graphic context is created.
        Warning: The view is centered and resized to preserve
        the height/width ratio of the window.

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type theContext: OCC.wrapper.Aspect.Aspect_RenderingContext

        """
        return _V3d.Handle_V3d_View_SetWindow(self, *args)


    def SetMagnify(self, *args):
        """
        SetMagnify(Handle_V3d_View self, Handle_Aspect_Window theWindow, Handle_V3d_View thePreviousView, Standard_Integer const theX1, Standard_Integer const theY1, Standard_Integer const theX2, Standard_Integer const theY2)

        :type theWindow: OCC.wrapper.Aspect.Handle_Aspect_Window
        :type thePreviousView: OCC.wrapper.V3d.Handle_V3d_View
        :type theX1: int
        :type theY1: int
        :type theX2: int
        :type theY2: int

        """
        return _V3d.Handle_V3d_View_SetMagnify(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_V3d_View self)

        Destroys the view.


        """
        return _V3d.Handle_V3d_View_Remove(self, *args)


    def Update(self, *args):
        """
        Update(Handle_V3d_View self)

        Deprecated, Redraw() should be used instead.


        """
        return _V3d.Handle_V3d_View_Update(self, *args)


    def Redraw(self, *args):
        """
        Redraw(Handle_V3d_View self)

        Redisplays the view even if there has not
        been any modification.
        Must be called if the view is shown.
        (Ex: DeIconification ) .


        """
        return _V3d.Handle_V3d_View_Redraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(Handle_V3d_View self)

        Updates layer of immediate presentations.


        """
        return _V3d.Handle_V3d_View_RedrawImmediate(self, *args)


    def Invalidate(self, *args):
        """
        Invalidate(Handle_V3d_View self)

        Invalidates view content but does not redraw it.


        """
        return _V3d.Handle_V3d_View_Invalidate(self, *args)


    def IsInvalidated(self, *args):
        """
        IsInvalidated(Handle_V3d_View self) -> Standard_Boolean

        Returns true if cached view content has been invalidated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsInvalidated(self, *args)


    def MustBeResized(self, *args):
        """
        MustBeResized(Handle_V3d_View self)

        Must be called when the window supporting the
        view changes size.
        if the view is not mapped on a window.
        Warning: The view is centered and resized to preserve
        the height/width ratio of the window.


        """
        return _V3d.Handle_V3d_View_MustBeResized(self, *args)


    def DoMapping(self, *args):
        """
        DoMapping(Handle_V3d_View self)

        Must be called when the window supporting the
        view is mapped or unmapped.


        """
        return _V3d.Handle_V3d_View_DoMapping(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_V3d_View self) -> Standard_Boolean

        Returns the status of the view regarding
        the displayed structures inside
        Returns True is The View is empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsEmpty(self, *args)


    def UpdateLights(self, *args):
        """
        UpdateLights(Handle_V3d_View self)

        Updates the lights of the view.


        """
        return _V3d.Handle_V3d_View_UpdateLights(self, *args)


    def SetAutoZFitMode(self, *args):
        """
        SetAutoZFitMode(Handle_V3d_View self, Standard_Boolean const theIsOn, Standard_Real const theScaleFactor=1.0)

        Sets the automatic z-fit mode and its parameters.
        The auto z-fit has extra parameters which can controlled from application level
        to ensure that the size of viewing volume will be sufficiently large to cover
        the depth of unmanaged objects, for example, transformation persistent ones.
        @param theScaleFactor [in] the scale factor for Z-range.
        The range between Z-min, Z-max projection volume planes
        evaluated by z fitting method will be scaled using this coefficient.
        Program error exception is thrown if negative or zero value
        is passed.

        :type theIsOn: bool
        :type theScaleFactor: float

        """
        return _V3d.Handle_V3d_View_SetAutoZFitMode(self, *args)


    def AutoZFitMode(self, *args):
        """
        AutoZFitMode(Handle_V3d_View self) -> Standard_Boolean

        returns TRUE if automatic z-fit mode is turned on.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_AutoZFitMode(self, *args)


    def AutoZFitScaleFactor(self, *args):
        """
        AutoZFitScaleFactor(Handle_V3d_View self) -> Standard_Real

        returns scale factor parameter of automatic z-fit mode.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_AutoZFitScaleFactor(self, *args)


    def AutoZFit(self, *args):
        """
        AutoZFit(Handle_V3d_View self)

        If automatic z-range fitting is turned on, adjusts Z-min and Z-max
        projection volume planes with call to ZFitAll.


        """
        return _V3d.Handle_V3d_View_AutoZFit(self, *args)


    def ZFitAll(self, *args):
        """
        ZFitAll(Handle_V3d_View self, Standard_Real const theScaleFactor=1.0)

        Change Z-min and Z-max planes of projection volume to match the
        displayed objects.

        :type theScaleFactor: float

        """
        return _V3d.Handle_V3d_View_ZFitAll(self, *args)


    def SetBackgroundColor(self, *args):
        """
        SetBackgroundColor(Handle_V3d_View self, Quantity_TypeOfColor const theType, Standard_Real const theV1, Standard_Real const theV2, Standard_Real const theV3)
        SetBackgroundColor(Handle_V3d_View self, Quantity_Color theColor)

        Defines the background color of the view.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_View_SetBackgroundColor(self, *args)


    def SetBgGradientColors(self, *args):
        """
        SetBgGradientColors(Handle_V3d_View self, Quantity_Color theColor1, Quantity_Color theColor2, Aspect_GradientFillMethod const theFillStyle=Aspect_GFM_HOR, Standard_Boolean const theToUpdate)

        Defines the gradient background colors of the view by supplying the colors
        and the fill method (horizontal by default).

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_GradientFillMethod
        :type theToUpdate: bool

        """
        return _V3d.Handle_V3d_View_SetBgGradientColors(self, *args)


    def SetBgGradientStyle(self, *args):
        """
        SetBgGradientStyle(Handle_V3d_View self, Aspect_GradientFillMethod const theMethod=Aspect_GFM_HOR, Standard_Boolean const theToUpdate)

        Defines the gradient background fill method of the view.

        :type theMethod: OCC.wrapper.Aspect.Aspect_GradientFillMethod
        :type theToUpdate: bool

        """
        return _V3d.Handle_V3d_View_SetBgGradientStyle(self, *args)


    def SetBackgroundImage(self, *args):
        """
        SetBackgroundImage(Handle_V3d_View self, Standard_CString const theFileName, Aspect_FillMethod const theFillStyle=Aspect_FM_CENTERED, Standard_Boolean const theToUpdate)

        Defines the background texture of the view by supplying the texture image file name
        and fill method (centered by default).

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod
        :type theToUpdate: bool

        """
        return _V3d.Handle_V3d_View_SetBackgroundImage(self, *args)


    def SetBgImageStyle(self, *args):
        """
        SetBgImageStyle(Handle_V3d_View self, Aspect_FillMethod const theFillStyle, Standard_Boolean const theToUpdate)

        Defines the textured background fill method of the view.

        :type theFillStyle: OCC.wrapper.Aspect.Aspect_FillMethod
        :type theToUpdate: bool

        """
        return _V3d.Handle_V3d_View_SetBgImageStyle(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)

        Definition of an axis from its origin and
        its orientation .
        This will be the current axis for rotations and movements.
        Warning! raises BadValue from V3d if the vector normal is NULL. .

        :type X: float
        :type Y: float
        :type Z: float
        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.Handle_V3d_View_SetAxis(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(Handle_V3d_View self, Graphic3d_TypeOfShadingModel const theShadingModel)

        Defines the shading model for the visualization. Various models are available.

        :type theShadingModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.Handle_V3d_View_SetShadingModel(self, *args)


    def SetTextureEnv(self, *args):
        """
        SetTextureEnv(Handle_V3d_View self, Handle_Graphic3d_TextureEnv theTexture)

        Sets the environment texture to use. No environment texture by default.

        :type theTexture: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _V3d.Handle_V3d_View_SetTextureEnv(self, *args)


    def SetVisualization(self, *args):
        """
        SetVisualization(Handle_V3d_View self, V3d_TypeOfVisualization const theType)

        Defines the visualization type in the view.

        :type theType: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.Handle_V3d_View_SetVisualization(self, *args)


    def SetLightOn(self, *args):
        """
        SetLightOn(Handle_V3d_View self, Handle_Graphic3d_CLight theLight)
        SetLightOn(Handle_V3d_View self)

        Activates all the lights defined in this view.


        """
        return _V3d.Handle_V3d_View_SetLightOn(self, *args)


    def SetLightOff(self, *args):
        """
        SetLightOff(Handle_V3d_View self, Handle_Graphic3d_CLight theLight)
        SetLightOff(Handle_V3d_View self)

        Deactivate all the Lights defined in this view.


        """
        return _V3d.Handle_V3d_View_SetLightOff(self, *args)


    def IsActiveLight(self, *args):
        """
        IsActiveLight(Handle_V3d_View self, Handle_Graphic3d_CLight theLight) -> Standard_Boolean

        Returns TRUE when the light is active in this view.

        :type theLight: OCC.wrapper.V3d.Handle_V3d_Light
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsActiveLight(self, *args)


    def SetImmediateUpdate(self, *args):
        """
        SetImmediateUpdate(Handle_V3d_View self, Standard_Boolean const theImmediateUpdate) -> Standard_Boolean

        sets the immediate update mode and returns the previous one.

        :type theImmediateUpdate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_SetImmediateUpdate(self, *args)


    def ZBufferTriedronSetup(self, *args):
        """
        ZBufferTriedronSetup(Handle_V3d_View self, Quantity_Color theXColor=Quantity_NOC_RED, Quantity_Color theYColor=Quantity_NOC_GREEN, Quantity_Color theZColor=Quantity_NOC_BLUE1, Standard_Real const theSizeRatio=0.8, Standard_Real const theAxisDiametr=0.05, Standard_Integer const theNbFacettes=12)

        Customization of the ZBUFFER Triedron.
        XColor,YColor,ZColor - colors of axis
        SizeRatio - ratio of decreasing of the trihedron size when its physical
        position comes out of the view
        AxisDiametr - diameter relatively to axis length
        NbFacettes - number of facets of cylinders and cones

        :type theXColor: OCC.wrapper.Quantity.Quantity_Color
        :type theYColor: OCC.wrapper.Quantity.Quantity_Color
        :type theZColor: OCC.wrapper.Quantity.Quantity_Color
        :type theSizeRatio: float
        :type theAxisDiametr: float
        :type theNbFacettes: int

        """
        return _V3d.Handle_V3d_View_ZBufferTriedronSetup(self, *args)


    def TriedronDisplay(self, *args):
        """
        TriedronDisplay(Handle_V3d_View self, Aspect_TypeOfTriedronPosition const thePosition=Aspect_TOTP_CENTER, Quantity_Color theColor=Quantity_NOC_WHITE, Standard_Real const theScale=0.02, V3d_TypeOfVisualization const theMode=V3d_WIREFRAME)

        Display of the Triedron.
        Initialize position, color and length of Triedron axes.
        The scale is a percent of the window width.

        :type thePosition: OCC.wrapper.Aspect.Aspect_TypeOfTriedronPosition
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theScale: float
        :type theMode: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.Handle_V3d_View_TriedronDisplay(self, *args)


    def TriedronErase(self, *args):
        """
        TriedronErase(Handle_V3d_View self)

        Erases the Triedron.


        """
        return _V3d.Handle_V3d_View_TriedronErase(self, *args)


    def GetGraduatedTrihedron(self, *args):
        """
        Returns data of a graduated trihedron.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        res = _V3d.Handle_V3d_View_GetGraduatedTrihedron(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GraduatedTrihedronDisplay(self, *args):
        """
        GraduatedTrihedronDisplay(Handle_V3d_View self, Graphic3d_GraduatedTrihedron theTrihedronData)

        Displays a graduated trihedron.

        :type theTrihedronData: OCC.wrapper.Graphic3d.Graphic3d_GraduatedTrihedron

        """
        return _V3d.Handle_V3d_View_GraduatedTrihedronDisplay(self, *args)


    def GraduatedTrihedronErase(self, *args):
        """
        GraduatedTrihedronErase(Handle_V3d_View self)

        Erases a graduated trihedron from the view.


        """
        return _V3d.Handle_V3d_View_GraduatedTrihedronErase(self, *args)


    def SetFront(self, *args):
        """
        SetFront(Handle_V3d_View self)

        modify the Projection of the view perpendicularly to
        the privileged plane of the viewer.


        """
        return _V3d.Handle_V3d_View_SetFront(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Boolean const Start)
        Rotate(Handle_V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Boolean const Start)
        Rotate(Handle_V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Boolean const Start)
        Rotate(Handle_V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Boolean const Start)
        Rotate(Handle_V3d_View self, Standard_Real const Angle, Standard_Boolean const Start)

        Rotates the eye around the current axis a relative
        angular value in RADIANS with respect to the initial
        position expressed by Start = Standard_True

        :type Angle: float
        :type Start: bool

        """
        return _V3d.Handle_V3d_View_Rotate(self, *args)


    def Move(self, *args):
        """
        Move(Handle_V3d_View self, Standard_Real const Dx, Standard_Real const Dy, Standard_Real const Dz, Standard_Boolean const Start)
        Move(Handle_V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Length, Standard_Boolean const Start)
        Move(Handle_V3d_View self, Standard_Real const Length, Standard_Boolean const Start)

        Movement of the eye parllel to the current axis
        a distance relative to the initial position
        expressed by Start = Standard_True

        :type Length: float
        :type Start: bool

        """
        return _V3d.Handle_V3d_View_Move(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_V3d_View self, Standard_Real const Dx, Standard_Real const Dy, Standard_Real const Dz, Standard_Boolean const Start)
        Translate(Handle_V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Length, Standard_Boolean const Start)
        Translate(Handle_V3d_View self, Standard_Real const Length, Standard_Boolean const Start)

        Movement of the eye and view point parallel to
        the current axis a distance relative to the initial
        position expressed by Start = Standard_True

        :type Length: float
        :type Start: bool

        """
        return _V3d.Handle_V3d_View_Translate(self, *args)


    def Place(self, *args):
        """
        Place(Handle_V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp, Standard_Real const theZoomFactor=1)

        places the point of the view corresponding
        at the pixel position x,y at the center of the window
        and updates the view.

        :type theXp: int
        :type theYp: int
        :type theZoomFactor: float

        """
        return _V3d.Handle_V3d_View_Place(self, *args)


    def Turn(self, *args):
        """
        Turn(Handle_V3d_View self, Standard_Real const Ax, Standard_Real const Ay, Standard_Real const Az, Standard_Boolean const Start)
        Turn(Handle_V3d_View self, V3d_TypeOfAxe const Axe, Standard_Real const Angle, Standard_Boolean const Start)
        Turn(Handle_V3d_View self, Standard_Real const Angle, Standard_Boolean const Start)

        Rotation of the view point around the current axis an
        angular value in RADIANS relative to the initial
        position expressed by Start = Standard_True

        :type Angle: float
        :type Start: bool

        """
        return _V3d.Handle_V3d_View_Turn(self, *args)


    def SetTwist(self, *args):
        """
        SetTwist(Handle_V3d_View self, Standard_Real const Angle)

        Defines the angular position of the high point of
        the reference frame of the view with respect to the
        Y screen axis with an absolute angular value in
        RADIANS.

        :type Angle: float

        """
        return _V3d.Handle_V3d_View_SetTwist(self, *args)


    def SetEye(self, *args):
        """
        SetEye(Handle_V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Defines the position of the eye..

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.Handle_V3d_View_SetEye(self, *args)


    def SetDepth(self, *args):
        """
        SetDepth(Handle_V3d_View self, Standard_Real const Depth)

        Defines the Depth of the eye from the view point
        without update the projection .

        :type Depth: float

        """
        return _V3d.Handle_V3d_View_SetDepth(self, *args)


    def SetProj(self, *args):
        """
        SetProj(Handle_V3d_View self, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)
        SetProj(Handle_V3d_View self, V3d_TypeOfOrientation const Orientation)

        Defines the orientation of the projection .

        :type Orientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_View_SetProj(self, *args)


    def SetAt(self, *args):
        """
        SetAt(Handle_V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Defines the position of the view point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.Handle_V3d_View_SetAt(self, *args)


    def SetUp(self, *args):
        """
        SetUp(Handle_V3d_View self, Standard_Real const Vx, Standard_Real const Vy, Standard_Real const Vz)
        SetUp(Handle_V3d_View self, V3d_TypeOfOrientation const Orientation)

        Defines the orientation(SO) of the high point.

        :type Orientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_View_SetUp(self, *args)


    def SetViewOrientationDefault(self, *args):
        """
        SetViewOrientationDefault(Handle_V3d_View self)

        Saves the current state of the orientation of the view
        which will be the return state at ResetViewOrientation.


        """
        return _V3d.Handle_V3d_View_SetViewOrientationDefault(self, *args)


    def ResetViewOrientation(self, *args):
        """
        ResetViewOrientation(Handle_V3d_View self)

        Resets the orientation of the view.
        Updates the view


        """
        return _V3d.Handle_V3d_View_ResetViewOrientation(self, *args)


    def Panning(self, *args):
        """
        Panning(Handle_V3d_View self, Standard_Real const theDXv, Standard_Real const theDYv, Standard_Real const theZoomFactor=1, Standard_Boolean const theToStart)

        Translates the center of the view along "x" and "y" axes of
        view projection. Can be used to perform interactive panning operation.
        In that case the DXv, DXy parameters specify panning relative to the
        point where the operation is started.
        @param theDXv [in] the relative panning on "x" axis of view projection, in view space coordinates.
        @param theDYv [in] the relative panning on "y" axis of view projection, in view space coordinates.
        @param theZoomFactor [in] the zooming factor.
        @param theToStart [in] pass TRUE when starting panning to remember view
        state prior to panning for relative arguments. If panning is started,
        passing {0, 0} for {theDXv, theDYv} will return view to initial state.
        Performs update of view.

        :type theDXv: float
        :type theDYv: float
        :type theZoomFactor: float
        :type theToStart: bool

        """
        return _V3d.Handle_V3d_View_Panning(self, *args)


    def SetCenter(self, *args):
        """
        SetCenter(Handle_V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp)

        Relocates center of screen to the point, determined by
        {Xp, Yp} pixel coordinates relative to the bottom-left corner of
        screen. To calculate pixel coordinates for any point from world
        coordinate space, it can be projected using "Project".
        @param theXp [in] the x coordinate.
        @param theYp [in] the y coordinate.

        :type theXp: int
        :type theYp: int

        """
        return _V3d.Handle_V3d_View_SetCenter(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_V3d_View self, Standard_Real const theSize)

        Defines the view projection size in its maximum dimension,
        keeping the inital height/width ratio unchanged.

        :type theSize: float

        """
        return _V3d.Handle_V3d_View_SetSize(self, *args)


    def SetZSize(self, *args):
        """
        SetZSize(Handle_V3d_View self, Standard_Real const SetZSize)

        Defines the Depth size of the view
        Front Plane will be set to Size/2.
        Back  Plane will be set to -Size/2.
        Any Object located Above the Front Plane or
        behind the Back Plane will be Clipped .
        NOTE than the XY Size of the View is NOT modified .

        :type SetZSize: float

        """
        return _V3d.Handle_V3d_View_SetZSize(self, *args)


    def SetZoom(self, *args):
        """
        SetZoom(Handle_V3d_View self, Standard_Real const Coef, Standard_Boolean const Start)

        Zooms the view by a factor relative to the initial
        value expressed by Start = Standard_True
        Updates the view.

        :type Coef: float
        :type Start: bool

        """
        return _V3d.Handle_V3d_View_SetZoom(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_V3d_View self, Standard_Real const Coef)

        Zooms the view by a factor relative to the value
        initialised by SetViewMappingDefault().
        Updates the view.

        :type Coef: float

        """
        return _V3d.Handle_V3d_View_SetScale(self, *args)


    def SetAxialScale(self, *args):
        """
        SetAxialScale(Handle_V3d_View self, Standard_Real const Sx, Standard_Real const Sy, Standard_Real const Sz)

        Sets  anisotropic (axial)  scale  factors  <Sx>, <Sy>, <Sz>  for  view <me>.
        Anisotropic  scaling  operation  is  performed  through  multiplying
        the current view  orientation  matrix  by  a  scaling  matrix:
        || Sx  0   0   0 ||
        || 0   Sy  0   0 ||
        || 0   0   Sz  0 ||
        || 0   0   0   1 ||
        Updates the view.

        :type Sx: float
        :type Sy: float
        :type Sz: float

        """
        return _V3d.Handle_V3d_View_SetAxialScale(self, *args)


    def FitAll(self, *args):
        """
        FitAll(Handle_V3d_View self, Standard_Real const theMargin=0.01, Standard_Boolean const theToUpdate)
        FitAll(Handle_V3d_View self, Bnd_Box theBox, Standard_Real const theMargin=0.01, Standard_Boolean const theToUpdate)
        FitAll(Handle_V3d_View self, Standard_Real const theMinXv, Standard_Real const theMinYv, Standard_Real const theMaxXv, Standard_Real const theMaxYv)

        Centers the defined projection window so that it occupies
        the maximum space while respecting the initial
        height/width ratio.
        NOTE than the original Z size of the view is NOT modified .

        :type theMinXv: float
        :type theMinYv: float
        :type theMaxXv: float
        :type theMaxYv: float

        """
        return _V3d.Handle_V3d_View_FitAll(self, *args)


    def DepthFitAll(self, *args):
        """
        DepthFitAll(Handle_V3d_View self, Standard_Real const Aspect=0.01, Standard_Real const Margin=0.01)

        Adjusts the viewing volume so as not to clip the displayed objects by front and back
        and back clipping planes. Also sets depth value automatically depending on the
        calculated Z size and Aspect parameter.
        NOTE than the original XY size of the view is NOT modified .

        :type Aspect: float
        :type Margin: float

        """
        return _V3d.Handle_V3d_View_DepthFitAll(self, *args)


    def WindowFit(self, *args):
        """
        WindowFit(Handle_V3d_View self, Standard_Integer const theMinXp, Standard_Integer const theMinYp, Standard_Integer const theMaxXp, Standard_Integer const theMaxYp)

        Centers the defined PIXEL window so that it occupies
        the maximum space while respecting the initial height/width ratio.
        NOTE than the original Z size of the view is NOT modified.
        @param theMinXp [in] pixel coordinates of minimal corner on x screen axis.
        @param theMinYp [in] pixel coordinates of minimal corner on y screen axis.
        @param theMaxXp [in] pixel coordinates of maximal corner on x screen axis.
        @param theMaxYp [in] pixel coordinates of maximal corner on y screen axis.

        :type theMinXp: int
        :type theMinYp: int
        :type theMaxXp: int
        :type theMaxYp: int

        """
        return _V3d.Handle_V3d_View_WindowFit(self, *args)


    def SetViewMappingDefault(self, *args):
        """
        SetViewMappingDefault(Handle_V3d_View self)

        Saves the current view mapping. This will be the
        state returned from ResetViewmapping.


        """
        return _V3d.Handle_V3d_View_SetViewMappingDefault(self, *args)


    def ResetViewMapping(self, *args):
        """
        ResetViewMapping(Handle_V3d_View self)

        Resets the centering of the view.
        Updates the view


        """
        return _V3d.Handle_V3d_View_ResetViewMapping(self, *args)


    def Reset(self, *args):
        """
        Reset(Handle_V3d_View self, Standard_Boolean const theToUpdate)

        Resets the centering and the orientation of the view.

        :type theToUpdate: bool

        """
        return _V3d.Handle_V3d_View_Reset(self, *args)


    def Convert(self, *args):
        """
        Convert(Handle_V3d_View self, Standard_Integer const Vp) -> Standard_Real
        Convert(Handle_V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        Convert(Handle_V3d_View self, Standard_Real const Vv) -> Standard_Integer
        Convert(Handle_V3d_View self, Standard_Real const Xv, Standard_Real const Yv)
        Convert(Handle_V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        Convert(Handle_V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Projects the point defined in the reference frame of
        the view into the projected point in the associated window.

        :type X: float
        :type Y: float
        :type Z: float
        :type Xp: int
        :type Yp: int

        """
        return _V3d.Handle_V3d_View_Convert(self, *args)


    def ConvertWithProj(self, *args):
        """
        ConvertWithProj(Handle_V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)

        Converts the projected point into a point
        in the reference frame of the view corresponding
        to the intersection with the projection plane
        of the eye/view point vector and returns the
        projection ray for further computations.

        :type Xp: int
        :type Yp: int
        :type X: float
        :type Y: float
        :type Z: float
        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.Handle_V3d_View_ConvertWithProj(self, *args)


    def ConvertToGrid(self, *args):
        """
        ConvertToGrid(Handle_V3d_View self, Standard_Integer const Xp, Standard_Integer const Yp)
        ConvertToGrid(Handle_V3d_View self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Converts the point into the nearest grid point
        and display the grid marker.

        :type X: float
        :type Y: float
        :type Z: float
        :type Xg: float
        :type Yg: float
        :type Zg: float

        """
        return _V3d.Handle_V3d_View_ConvertToGrid(self, *args)


    def Project(self, *args):
        """
        Project(Handle_V3d_View self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ)
        Project(Handle_V3d_View self, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ)

        Converts the point defined in the user space of
        the view to the projection plane at the depth
        relative to theZ.

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theXp: float
        :type theYp: float
        :type theZp: float

        """
        return _V3d.Handle_V3d_View_Project(self, *args)


    def BackgroundColor(self, *args):
        """
        BackgroundColor(Handle_V3d_View self, Quantity_TypeOfColor const Type)
        BackgroundColor(Handle_V3d_View self) -> Quantity_Color

        Returns the Background color object of the view.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_View_BackgroundColor(self, *args)


    def GradientBackgroundColors(self, *args):
        """
        GradientBackgroundColors(Handle_V3d_View self, Quantity_Color theColor1, Quantity_Color theColor2)

        Returns the gradient background colors of the view.

        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_View_GradientBackgroundColors(self, *args)


    def GradientBackground(self, *args):
        """
        GradientBackground(Handle_V3d_View self) -> Aspect_GradientBackground

        Returns the gradient background of the view.

        :rtype: OCC.wrapper.Aspect.Aspect_GradientBackground

        """
        return _V3d.Handle_V3d_View_GradientBackground(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_V3d_View self) -> Standard_Real

        Returns the current value of the zoom expressed with
        respect to SetViewMappingDefault().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_Scale(self, *args)


    def AxialScale(self, *args):
        """
        AxialScale(Handle_V3d_View self)
        AxialScale(Handle_V3d_View self, Standard_Integer const Dx, Standard_Integer const Dy, V3d_TypeOfAxe const Axis)

        Performs  anisotropic scaling  of  <me>  view  along  the  given  <Axis>.
        The  scale  factor  is  calculated on a basis of
        the mouse pointer displacement <Dx,Dy>.
        The  calculated  scale  factor  is  then  passed  to  SetAxialScale(Sx,  Sy,  Sz)  method.

        :type Dx: int
        :type Dy: int
        :type Axis: OCC.wrapper.V3d.V3d_TypeOfAxe

        """
        return _V3d.Handle_V3d_View_AxialScale(self, *args)


    def Size(self, *args):
        """
        Size(Handle_V3d_View self)

        Returns the height and width of the view.

        :type Width: float
        :type Height: float

        """
        return _V3d.Handle_V3d_View_Size(self, *args)


    def ZSize(self, *args):
        """
        ZSize(Handle_V3d_View self) -> Standard_Real

        Returns the Depth of the view .

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_ZSize(self, *args)


    def Eye(self, *args):
        """
        Eye(Handle_V3d_View self)

        Returns the position of the eye.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.Handle_V3d_View_Eye(self, *args)


    def FocalReferencePoint(self, *args):
        """
        FocalReferencePoint(Handle_V3d_View self)

        Returns the position of point which emanating the
        projections.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.Handle_V3d_View_FocalReferencePoint(self, *args)


    def ProjReferenceAxe(self, *args):
        """
        ProjReferenceAxe(Handle_V3d_View self, Standard_Integer const Xpix, Standard_Integer const Ypix)

        Returns the coordinate of the point (Xpix,Ypix)
        in the view (XP,YP,ZP), and the projection vector of the
        view passing by the point (for PerspectiveView).

        :type Xpix: int
        :type Ypix: int
        :type XP: float
        :type YP: float
        :type ZP: float
        :type VX: float
        :type VY: float
        :type VZ: float

        """
        return _V3d.Handle_V3d_View_ProjReferenceAxe(self, *args)


    def Depth(self, *args):
        """
        Depth(Handle_V3d_View self) -> Standard_Real

        Returns the Distance between the Eye and View Point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_Depth(self, *args)


    def Proj(self, *args):
        """
        Proj(Handle_V3d_View self)

        Returns the projection vector.

        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.Handle_V3d_View_Proj(self, *args)


    def At(self, *args):
        """
        At(Handle_V3d_View self)

        Returns the position of the view point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _V3d.Handle_V3d_View_At(self, *args)


    def Up(self, *args):
        """
        Up(Handle_V3d_View self)

        Returns the vector giving the position of the high point.

        :type Vx: float
        :type Vy: float
        :type Vz: float

        """
        return _V3d.Handle_V3d_View_Up(self, *args)


    def Twist(self, *args):
        """
        Twist(Handle_V3d_View self) -> Standard_Real

        Returns in RADIANS the orientation of the view around
        the visual axis measured from the Y axis of the screen.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_Twist(self, *args)


    def ShadingModel(self, *args):
        """
        ShadingModel(Handle_V3d_View self) -> Graphic3d_TypeOfShadingModel

        Returns the current shading model.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel

        """
        return _V3d.Handle_V3d_View_ShadingModel(self, *args)


    def TextureEnv(self, *args):
        """
        TextureEnv(Handle_V3d_View self) -> Handle_Graphic3d_TextureEnv

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TextureEnv

        """
        return _V3d.Handle_V3d_View_TextureEnv(self, *args)


    def Visualization(self, *args):
        """
        Visualization(Handle_V3d_View self) -> V3d_TypeOfVisualization

        Returns the current visualisation mode.

        :rtype: OCC.wrapper.V3d.V3d_TypeOfVisualization

        """
        return _V3d.Handle_V3d_View_Visualization(self, *args)


    def IfMoreLights(self, *args):
        """
        IfMoreLights(Handle_V3d_View self) -> Standard_Boolean

        Returns True if One light more can be
        activated in this View.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IfMoreLights(self, *args)


    def ActiveLightIterator(self, *args):
        """
        ActiveLightIterator(Handle_V3d_View self) -> V3d_ListOfLightIterator

        Return iterator for defined lights.

        :rtype: OCC.wrapper.V3d.V3d_ListOfLightIterator

        """
        return _V3d.Handle_V3d_View_ActiveLightIterator(self, *args)


    def InitActiveLights(self, *args):
        """
        InitActiveLights(Handle_V3d_View self)

        initializes an iteration on the active Lights.


        """
        return _V3d.Handle_V3d_View_InitActiveLights(self, *args)


    def MoreActiveLights(self, *args):
        """
        MoreActiveLights(Handle_V3d_View self) -> Standard_Boolean

        returns true if there are more active Light(s) to return.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_MoreActiveLights(self, *args)


    def NextActiveLights(self, *args):
        """
        NextActiveLights(Handle_V3d_View self)

        Go to the next active Light (if there is not, ActiveLight will raise an exception)


        """
        return _V3d.Handle_V3d_View_NextActiveLights(self, *args)


    def ActiveLight(self, *args):
        """
        :rtype: OCC.wrapper.V3d.Handle_V3d_Light

        """
        res = _V3d.Handle_V3d_View_ActiveLight(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LightLimit(self, *args):
        """
        LightLimit(Handle_V3d_View self) -> Standard_Integer

        Returns the MAX number of light associated to the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_View_LightLimit(self, *args)


    def Viewer(self, *args):
        """
        Viewer(Handle_V3d_View self) -> Handle_V3d_Viewer

        Returns the viewer in which the view has been created.

        :rtype: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _V3d.Handle_V3d_View_Viewer(self, *args)


    def IfWindow(self, *args):
        """
        IfWindow(Handle_V3d_View self) -> Standard_Boolean

        Returns True if MyView is associated with a window .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IfWindow(self, *args)


    def Window(self, *args):
        """
        Window(Handle_V3d_View self) -> Handle_Aspect_Window

        Returns the Aspect Window associated with the view.

        :rtype: OCC.wrapper.Aspect.Handle_Aspect_Window

        """
        return _V3d.Handle_V3d_View_Window(self, *args)


    def Type(self, *args):
        """
        Type(Handle_V3d_View self) -> V3d_TypeOfView

        Returns the Type of the View

        :rtype: OCC.wrapper.V3d.V3d_TypeOfView

        """
        return _V3d.Handle_V3d_View_Type(self, *args)


    def Pan(self, *args):
        """
        Pan(Handle_V3d_View self, Standard_Integer const theDXp, Standard_Integer const theDYp, Standard_Real const theZoomFactor=1, Standard_Boolean const theToStart)

        Translates the center of the view along "x" and "y" axes of
        view projection. Can be used to perform interactive panning operation.
        In that case the DXp, DXp parameters specify panning relative to the
        point where the operation is started.
        @param theDXp [in] the relative panning on "x" axis of view projection, in pixels.
        @param theDYp [in] the relative panning on "y" axis of view projection, in pixels.
        @param theZoomFactor [in] the zooming factor.
        @param theToStart [in] pass TRUE when starting panning to remember view
        state prior to panning for relative arguments. Passing 0 for relative
        panning parameter should return view panning to initial state.
        Performs update of view.

        :type theDXp: int
        :type theDYp: int
        :type theZoomFactor: float
        :type theToStart: bool

        """
        return _V3d.Handle_V3d_View_Pan(self, *args)


    def Zoom(self, *args):
        """
        Zoom(Handle_V3d_View self, Standard_Integer const theXp1, Standard_Integer const theYp1, Standard_Integer const theXp2, Standard_Integer const theYp2)

        Zoom the view according to a zoom factor computed
        from the distance between the 2 mouse position.
        @param theXp1 [in] the x coordinate of first mouse position, in pixels.
        @param theYp1 [in] the y coordinate of first mouse position, in pixels.
        @param theXp2 [in] the x coordinate of second mouse position, in pixels.
        @param theYp2 [in] the y coordinate of second mouse position, in pixels.

        :type theXp1: int
        :type theYp1: int
        :type theXp2: int
        :type theYp2: int

        """
        return _V3d.Handle_V3d_View_Zoom(self, *args)


    def StartZoomAtPoint(self, *args):
        """
        StartZoomAtPoint(Handle_V3d_View self, Standard_Integer const theXp, Standard_Integer const theYp)

        Defines starting point for ZoomAtPoint view operation.
        @param theXp [in] the x mouse coordinate, in pixels.
        @param theYp [in] the y mouse coordinate, in pixels.

        :type theXp: int
        :type theYp: int

        """
        return _V3d.Handle_V3d_View_StartZoomAtPoint(self, *args)


    def ZoomAtPoint(self, *args):
        """
        ZoomAtPoint(Handle_V3d_View self, Standard_Integer const theMouseStartX, Standard_Integer const theMouseStartY, Standard_Integer const theMouseEndX, Standard_Integer const theMouseEndY)

        Zooms the model at a pixel defined by the method StartZoomAtPoint().

        :type theMouseStartX: int
        :type theMouseStartY: int
        :type theMouseEndX: int
        :type theMouseEndY: int

        """
        return _V3d.Handle_V3d_View_ZoomAtPoint(self, *args)


    def StartRotation(self, *args):
        """
        StartRotation(Handle_V3d_View self, Standard_Integer const X, Standard_Integer const Y, Standard_Real const zRotationThreshold=0.0)

        Begin the rotation of the view around the screen axis
        according to the mouse position <X,Y>.
        Warning: Enable rotation around the Z screen axis when <zRotationThreshold>
        factor is > 0 soon the distance from the start point and the center
        of the view is > (medium viewSize * <zRotationThreshold> ).
        Generally a value of 0.4 is usable to rotate around XY screen axis
        inside the circular threshold area and to rotate around Z screen axis
        outside this area.

        :type X: int
        :type Y: int
        :type zRotationThreshold: float

        """
        return _V3d.Handle_V3d_View_StartRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(Handle_V3d_View self, Standard_Integer const X, Standard_Integer const Y)

        Continues the rotation of the view
        with an angle computed from the last and new mouse position <X,Y>.

        :type X: int
        :type Y: int

        """
        return _V3d.Handle_V3d_View_Rotation(self, *args)


    def SetFocale(self, *args):
        """
        SetFocale(Handle_V3d_View self, Standard_Real const Focale)

        Change View Plane Distance for Perspective Views
        Warning! raises TypeMismatch from Standard if the view
        is not a perspective view.

        :type Focale: float

        """
        return _V3d.Handle_V3d_View_SetFocale(self, *args)


    def Focale(self, *args):
        """
        Focale(Handle_V3d_View self) -> Standard_Real

        Returns the View Plane Distance for Perspective Views

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_View_Focale(self, *args)


    def View(self, *args):
        """
        View(Handle_V3d_View self) -> Handle_Graphic3d_CView

        Returns the associated Graphic3d view.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_CView

        """
        return _V3d.Handle_V3d_View_View(self, *args)


    def SetComputedMode(self, *args):
        """
        SetComputedMode(Handle_V3d_View self, Standard_Boolean const theMode)

        Switches computed HLR mode in the view.

        :type theMode: bool

        """
        return _V3d.Handle_V3d_View_SetComputedMode(self, *args)


    def ComputedMode(self, *args):
        """
        ComputedMode(Handle_V3d_View self) -> Standard_Boolean

        Returns the computed HLR mode state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_ComputedMode(self, *args)


    def WindowFitAll(self, *args):
        """
        WindowFitAll(Handle_V3d_View self, Standard_Integer const Xmin, Standard_Integer const Ymin, Standard_Integer const Xmax, Standard_Integer const Ymax)

        idem than WindowFit

        :type Xmin: int
        :type Ymin: int
        :type Xmax: int
        :type Ymax: int

        """
        return _V3d.Handle_V3d_View_WindowFitAll(self, *args)


    def SetGrid(self, *args):
        """
        SetGrid(Handle_V3d_View self, gp_Ax3 aPlane, Handle_Aspect_Grid aGrid)

        Defines or Updates the definition of the
        grid in <me>

        :type aPlane: OCC.wrapper.gp.gp_Ax3
        :type aGrid: OCC.wrapper.Aspect.Handle_Aspect_Grid

        """
        return _V3d.Handle_V3d_View_SetGrid(self, *args)


    def SetGridActivity(self, *args):
        """
        SetGridActivity(Handle_V3d_View self, Standard_Boolean const aFlag)

        Defines or Updates the activity of the
        grid in <me>

        :type aFlag: bool

        """
        return _V3d.Handle_V3d_View_SetGridActivity(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_V3d_View self, Standard_CString const theFile, Graphic3d_BufferType const & theBufferType=Graphic3d_BT_RGB) -> Standard_Boolean

        dump the full contents of the view at the same
        scale in the file <theFile>. The file name
        extension must be one of ".png",".bmp",".jpg",".gif".
        Returns FALSE when the dump has failed

        :type theFile: OCC.wrapper.Standard.Standard_CString
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_Dump(self, *args)


    def Export(self, *args):
        """
        Export(Handle_V3d_View self, Standard_CString const theFileName, Graphic3d_ExportFormat const theFormat, Graphic3d_SortType const theSortType=Graphic3d_ST_BSP_Tree) -> Standard_Boolean

        Export scene into the one of the Vector graphics formats (SVG, PS, PDF...).
        In contrast to Bitmaps, Vector graphics is scalable (so you may got quality benefits
        on printing to laser printer). Notice however that results may differ a lot and
        do not contain some elements.

        :type theFileName: OCC.wrapper.Standard.Standard_CString
        :type theFormat: OCC.wrapper.Graphic3d.Graphic3d_ExportFormat
        :type theSortType: OCC.wrapper.Graphic3d.Graphic3d_SortType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_Export(self, *args)


    def ToPixMap(self, *args):
        """
        ToPixMap(Handle_V3d_View self, Image_PixMap theImage, V3d_ImageDumpOptions const & theParams) -> Standard_Boolean
        ToPixMap(Handle_V3d_View self, Image_PixMap theImage, Standard_Integer const theWidth, Standard_Integer const theHeight, Graphic3d_BufferType const & theBufferType=Graphic3d_BT_RGB, Standard_Boolean const theToAdjustAspect, V3d_StereoDumpOptions const theStereoOptions=V3d_SDO_MONO) -> Standard_Boolean

        Dumps the full contents of the view to a pixmap.
        @param theImage          target image, will be re-allocated to match theWidth x theHeight
        @param theWidth          target image width
        @param theHeight         target image height
        @param theBufferType     type of the view buffer to dump (color / depth)
        @param theToAdjustAspect when true, active view aspect ratio will be overridden by (theWidth / theHeight)
        @param theStereoOptions  how to dump stereographic camera

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :type theWidth: int
        :type theHeight: int
        :type theBufferType: OCC.wrapper.Graphic3d.Graphic3d_BufferType
        :type theToAdjustAspect: bool
        :type theStereoOptions: OCC.wrapper.V3d.V3d_StereoDumpOptions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_ToPixMap(self, *args)


    def SetBackFacingModel(self, *args):
        """
        SetBackFacingModel(Handle_V3d_View self, V3d_TypeOfBackfacingModel const theModel=V3d_TOBM_AUTOMATIC)

        Manages display of the back faces
        When <aModel> is TOBM_AUTOMATIC the object backfaces
        are displayed only for surface objects and
        never displayed for solid objects.
        this was the previous mode.
        <aModel> is TOBM_ALWAYS_DISPLAYED the object backfaces
        are always displayed both for surfaces or solids.
        <aModel> is TOBM_NEVER_DISPLAYED the object backfaces
        are never displayed.

        :type theModel: OCC.wrapper.V3d.V3d_TypeOfBackfacingModel

        """
        return _V3d.Handle_V3d_View_SetBackFacingModel(self, *args)


    def BackFacingModel(self, *args):
        """
        BackFacingModel(Handle_V3d_View self) -> V3d_TypeOfBackfacingModel

        Returns current state of the back faces display

        :rtype: OCC.wrapper.V3d.V3d_TypeOfBackfacingModel

        """
        return _V3d.Handle_V3d_View_BackFacingModel(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_V3d_View self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane to the view. The composition of clip planes truncates the
        rendering space to convex volume. Number of supported clip planes can be consulted
        by PlaneLimit method of associated Graphic3d_GraphicDriver.
        Please be aware that the planes which exceed the limit are ignored during rendering.
        @param thePlane [in] the clip plane to be added to view.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _V3d.Handle_V3d_View_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_V3d_View self, Handle_Graphic3d_ClipPlane thePlane)

        Removes clip plane from the view.
        @param thePlane [in] the clip plane to be removed from view.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _V3d.Handle_V3d_View_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_V3d_View self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_V3d_View self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _V3d.Handle_V3d_View_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return sequence clip planes that have been set for the view

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _V3d.Handle_V3d_View_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PlaneLimit(self, *args):
        """
        PlaneLimit(Handle_V3d_View self) -> Standard_Integer

        Returns the MAX number of clipping planes associated to the view.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_View_PlaneLimit(self, *args)


    def SetCamera(self, *args):
        """
        SetCamera(Handle_V3d_View self, Handle_Graphic3d_Camera theCamera)

        Change camera used by view.

        :type theCamera: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _V3d.Handle_V3d_View_SetCamera(self, *args)


    def Camera(self, *args):
        """
        Returns camera object of the view.
        @return: handle to camera object, or NULL if 3D view does not use
        the camera approach.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _V3d.Handle_V3d_View_Camera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DefaultCamera(self, *args):
        """
        Return default camera.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _V3d.Handle_V3d_View_DefaultCamera(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RenderingParams(self, *args):
        """
        Returns current rendering parameters and effect settings.
        By default it returns default parameters of current viewer.
        To define view-specific settings use method V3d_View::ChangeRenderingParams().
        @sa V3d_Viewer::DefaultRenderingParams()

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        res = _V3d.Handle_V3d_View_RenderingParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeRenderingParams(self, *args):
        """
        ChangeRenderingParams(Handle_V3d_View self) -> Graphic3d_RenderingParams

        Returns reference to current rendering parameters and effect settings.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_RenderingParams

        """
        return _V3d.Handle_V3d_View_ChangeRenderingParams(self, *args)


    def IsCullingEnabled(self, *args):
        """
        IsCullingEnabled(Handle_V3d_View self) -> Standard_Boolean

        @return flag value of objects culling mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsCullingEnabled(self, *args)


    def SetFrustumCulling(self, *args):
        """
        SetFrustumCulling(Handle_V3d_View self, Standard_Boolean const theMode)

        Turn on/off automatic culling of objects outside frustrum (ON by default)

        :type theMode: bool

        """
        return _V3d.Handle_V3d_View_SetFrustumCulling(self, *args)


    def DiagnosticInformation(self, *args):
        """
        DiagnosticInformation(Handle_V3d_View self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theDict, Graphic3d_DiagnosticInfo theFlags)

        Fill in the dictionary with diagnostic info.
        Should be called within rendering thread.

        This API should be used only for user output or for creating automated reports.
        The format of returned information (e.g. key-value layout)
        is NOT part of this API and can be changed at any time.
        Thus application should not parse returned information to weed out specific parameters.
        @param theDict  destination map for information
        @param theFlags defines the information to be retrieved

        :type theDict: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfStringString
        :type theFlags: OCC.wrapper.Graphic3d.Graphic3d_DiagnosticInfo

        """
        return _V3d.Handle_V3d_View_DiagnosticInformation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_View self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_View_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_View_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_View_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_V3d_View self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_View_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_View self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_View self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_View self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_View self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_View_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_View self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_View_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_View self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_View_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_View self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_View_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_View self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_View_DecrementRefCounter(self, *args)

Handle_V3d_View_swigregister = _V3d.Handle_V3d_View_swigregister
Handle_V3d_View_swigregister(Handle_V3d_View)

def Handle_V3d_View_DownCast(thing):
    return _V3d.Handle_V3d_View_DownCast(thing)
Handle_V3d_View_DownCast = _V3d.Handle_V3d_View_DownCast

class Handle_V3d_SpotLight(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_SpotLight self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_SpotLight_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_SpotLight self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_SpotLight_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_SpotLight self, V3d_SpotLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_SpotLight_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_SpotLight self, Handle_V3d_SpotLight theHandle) -> Handle_V3d_SpotLight
        assign(Handle_V3d_SpotLight self, V3d_SpotLight thePtr) -> Handle_V3d_SpotLight
        assign(Handle_V3d_SpotLight self, Handle_V3d_SpotLight theHandle) -> Handle_V3d_SpotLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_SpotLight_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_SpotLight self) -> V3d_SpotLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_SpotLight_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_SpotLight self) -> V3d_SpotLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_SpotLight___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_SpotLight self) -> V3d_SpotLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_SpotLight___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_SpotLight___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_SpotLight___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_SpotLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_SpotLight_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_SpotLight

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_SpotLight self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_SpotLight_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_SpotLight_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_SpotLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_SpotLight self, V3d_TypeOfOrientation theOrientation)

        Defines the direction of the light source
        according to a predefined directional vector.

        :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_SpotLight_SetDirection(self, *args)


    def Type(self, *args):
        """
        Type(Handle_V3d_SpotLight self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_SpotLight_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_SpotLight_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_SpotLight self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_SpotLight_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_SpotLight_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_SpotLight self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_SpotLight_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_SpotLight self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_SpotLight_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_SpotLight self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_SpotLight_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_SpotLight self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_SpotLight_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_SpotLight self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_SpotLight_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_SpotLight self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_SpotLight_SetHeadlight(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_SpotLight self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_SpotLight_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_SpotLight self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_SpotLight_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_SpotLight self) -> gp_Dir
        Direction(Handle_V3d_SpotLight self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_SpotLight_Direction(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_SpotLight self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_SpotLight_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_SpotLight self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_SpotLight_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_SpotLight self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_SpotLight_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_SpotLight self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_SpotLight_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_SpotLight self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_SpotLight_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_SpotLight self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_SpotLight_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_SpotLight_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_SpotLight_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_SpotLight_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_SpotLight_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_SpotLight self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_SpotLight_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_SpotLight self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_SpotLight_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_SpotLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_SpotLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_SpotLight_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_SpotLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_SpotLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_SpotLight_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_SpotLight self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_SpotLight_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_SpotLight self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_SpotLight_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_SpotLight self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_SpotLight_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_SpotLight self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_SpotLight_DecrementRefCounter(self, *args)

Handle_V3d_SpotLight_swigregister = _V3d.Handle_V3d_SpotLight_swigregister
Handle_V3d_SpotLight_swigregister(Handle_V3d_SpotLight)

def Handle_V3d_SpotLight_DownCast(thing):
    return _V3d.Handle_V3d_SpotLight_DownCast(thing)
Handle_V3d_SpotLight_DownCast = _V3d.Handle_V3d_SpotLight_DownCast

class NCollection_List_Handle_Graphic3d_CLight(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Graphic3d_CLight self) -> NCollection_List< opencascade::handle< Graphic3d_CLight > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Graphic3d_CLight self) -> NCollection_List< opencascade::handle< Graphic3d_CLight > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Graphic3d_CLight self) -> NCollection_List< opencascade::handle< Graphic3d_CLight > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Graphic3d_CLight self) -> NCollection_List< opencascade::handle< Graphic3d_CLight > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _V3d.new_NCollection_List_Handle_Graphic3d_CLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Graphic3d_CLight self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther) -> NCollection_List_Handle_Graphic3d_CLight

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther) -> NCollection_List_Handle_Graphic3d_CLight

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Graphic3d_CLight self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _V3d.NCollection_List_Handle_Graphic3d_CLight_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _V3d.NCollection_List_Handle_Graphic3d_CLight_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Graphic3d_CLight self, Handle_Graphic3d_CLight theItem) -> Handle_Graphic3d_CLight
        Append(NCollection_List_Handle_Graphic3d_CLight self, Handle_Graphic3d_CLight theItem, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter)
        Append(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Graphic3d_CLight self, Handle_Graphic3d_CLight theItem) -> Handle_Graphic3d_CLight
        Prepend(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Graphic3d_CLight self)

        RemoveFirst item


        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Graphic3d_CLight self, Handle_Graphic3d_CLight theItem, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter) -> Handle_Graphic3d_CLight
        InsertBefore(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Graphic3d_CLight self, Handle_Graphic3d_CLight theItem, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter) -> Handle_Graphic3d_CLight
        InsertAfter(NCollection_List_Handle_Graphic3d_CLight self, NCollection_List_Handle_Graphic3d_CLight theOther, NCollection_List< opencascade::handle< Graphic3d_CLight > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Graphic3d_CLight self)

        Reverse the list


        """
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_Reverse(self, *args)


    def __iter__(self):
        return _V3d.NCollection_List_Handle_Graphic3d_CLight___iter__(self)
    __swig_destroy__ = _V3d.delete_NCollection_List_Handle_Graphic3d_CLight
NCollection_List_Handle_Graphic3d_CLight_swigregister = _V3d.NCollection_List_Handle_Graphic3d_CLight_swigregister
NCollection_List_Handle_Graphic3d_CLight_swigregister(NCollection_List_Handle_Graphic3d_CLight)

class NCollection_List_Handle_Graphic3d_CLight_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _V3d.new_NCollection_List_Handle_Graphic3d_CLight_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _V3d.delete_NCollection_List_Handle_Graphic3d_CLight_IteratorHelper

    def __next__(self):
        return _V3d.NCollection_List_Handle_Graphic3d_CLight_IteratorHelper___next__(self)
NCollection_List_Handle_Graphic3d_CLight_IteratorHelper_swigregister = _V3d.NCollection_List_Handle_Graphic3d_CLight_IteratorHelper_swigregister
NCollection_List_Handle_Graphic3d_CLight_IteratorHelper_swigregister(NCollection_List_Handle_Graphic3d_CLight_IteratorHelper)


try:
	V3d_ListOfLight = NCollection_List_Handle_Graphic3d_CLight
except NameError:
	pass # does not exist, probably ignored

class Handle_V3d_DirectionalLight(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_DirectionalLight self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_DirectionalLight_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_DirectionalLight self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_DirectionalLight_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_DirectionalLight self, V3d_DirectionalLight thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_DirectionalLight_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_DirectionalLight self, Handle_V3d_DirectionalLight theHandle) -> Handle_V3d_DirectionalLight
        assign(Handle_V3d_DirectionalLight self, V3d_DirectionalLight thePtr) -> Handle_V3d_DirectionalLight
        assign(Handle_V3d_DirectionalLight self, Handle_V3d_DirectionalLight theHandle) -> Handle_V3d_DirectionalLight

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_DirectionalLight_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_DirectionalLight self) -> V3d_DirectionalLight

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_DirectionalLight_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_DirectionalLight self) -> V3d_DirectionalLight

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_DirectionalLight___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_DirectionalLight self) -> V3d_DirectionalLight

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_DirectionalLight___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_DirectionalLight___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_DirectionalLight___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_DirectionalLight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_DirectionalLight_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_DirectionalLight

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_DirectionalLight self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_DirectionalLight_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_DirectionalLight_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_DirectionalLight_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDirection(self, *args):
        """
        SetDirection(Handle_V3d_DirectionalLight self, V3d_TypeOfOrientation theDirection)

        Defines the direction of the light source by a predefined orientation.

        :type theDirection: OCC.wrapper.V3d.V3d_TypeOfOrientation

        """
        return _V3d.Handle_V3d_DirectionalLight_SetDirection(self, *args)


    def Type(self, *args):
        """
        Type(Handle_V3d_DirectionalLight self) -> Graphic3d_TypeOfLightSource

        Returns the Type of the Light, cannot be changed after object construction.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TypeOfLightSource

        """
        return _V3d.Handle_V3d_DirectionalLight_Type(self, *args)


    def Name(self, *args):
        """
        Returns light source name; empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_DirectionalLight_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_V3d_DirectionalLight self, TCollection_AsciiString theName)

        Sets light source name.

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _V3d.Handle_V3d_DirectionalLight_SetName(self, *args)


    def Color(self, *args):
        """
        Returns the color of the light source; WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _V3d.Handle_V3d_DirectionalLight_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_V3d_DirectionalLight self, Quantity_Color theColor)

        Defines the color of a light source by giving the basic color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_DirectionalLight_SetColor(self, *args)


    def IsEnabled(self, *args):
        """
        IsEnabled(Handle_V3d_DirectionalLight self) -> Standard_Boolean

        Check that the light source is turned on; TRUE by default.
        This flag affects all occurrences of light sources, where it was registered and activated;
        so that it is possible defining an active light in View which is actually in disabled state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_DirectionalLight_IsEnabled(self, *args)


    def SetEnabled(self, *args):
        """
        SetEnabled(Handle_V3d_DirectionalLight self, Standard_Boolean theIsOn)

        Change enabled state of the light state.
        This call does not remove or deactivate light source in Views/Viewers;
        instead it turns it OFF so that it just have no effect.

        :type theIsOn: bool

        """
        return _V3d.Handle_V3d_DirectionalLight_SetEnabled(self, *args)


    def IsHeadlight(self, *args):
        """
        IsHeadlight(Handle_V3d_DirectionalLight self) -> Standard_Boolean

        Returns true if the light is a headlight; FALSE by default.
        Headlight flag means that light position/direction are defined not in a World coordinate system, but relative to the camera orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_DirectionalLight_IsHeadlight(self, *args)


    def Headlight(self, *args):
        """
        Headlight(Handle_V3d_DirectionalLight self) -> Standard_Boolean

        Alias for IsHeadlight().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_DirectionalLight_Headlight(self, *args)


    def SetHeadlight(self, *args):
        """
        SetHeadlight(Handle_V3d_DirectionalLight self, Standard_Boolean theValue)

        Setup headlight flag.

        :type theValue: bool

        """
        return _V3d.Handle_V3d_DirectionalLight_SetHeadlight(self, *args)


    def ConstAttenuation(self, *args):
        """
        ConstAttenuation(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns constant attenuation factor of positional/spot light source; 1.0f by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_ConstAttenuation(self, *args)


    def LinearAttenuation(self, *args):
        """
        LinearAttenuation(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns linear attenuation factor of positional/spot light source; 0.0 by default.
        Distance attenuation factors of reducing positional/spot light intensity depending on the distance from its position:
        @code
        float anAttenuation = 1.0 / (ConstAttenuation() + LinearAttenuation() * theDistance + QuadraticAttenuation() * theDistance * theDistance);
        @endcode

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_LinearAttenuation(self, *args)


    def Attenuation(self, *args):
        """
        Attenuation(Handle_V3d_DirectionalLight self)

        Returns the attenuation factors.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_DirectionalLight_Attenuation(self, *args)


    def SetAttenuation(self, *args):
        """
        SetAttenuation(Handle_V3d_DirectionalLight self, Standard_ShortReal theConstAttenuation, Standard_ShortReal theLinearAttenuation)

        Defines the coefficients of attenuation; values should be >= 0.0 and their summ should not be equal to 0.

        :type theConstAttenuation: float
        :type theLinearAttenuation: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetAttenuation(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_V3d_DirectionalLight self) -> gp_Dir
        Direction(Handle_V3d_DirectionalLight self)

        Returns the theVx, theVy, theVz direction of the light source.

        :type theVx: float
        :type theVy: float
        :type theVz: float

        """
        return _V3d.Handle_V3d_DirectionalLight_Direction(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns an angle in radians of the cone created by the spot; 30 degrees by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_DirectionalLight self, Standard_ShortReal theAngle)

        Angle in radians of the cone created by the spot, should be within range (0.0, M_PI).

        :type theAngle: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetAngle(self, *args)


    def Concentration(self, *args):
        """
        Concentration(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns intensity distribution of the spot light, within [0.0, 1.0] range; 1.0 by default.
        This coefficient should be converted into spotlight exponent within [0.0, 128.0] range:
        @code
        float aSpotExponent = Concentration() * 128.0;
        anAttenuation *= pow (aCosA, aSpotExponent);"
        @endcode
        The concentration factor determines the dispersion of the light on the surface, the default value (1.0) corresponds to a minimum of dispersion.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_Concentration(self, *args)


    def SetConcentration(self, *args):
        """
        SetConcentration(Handle_V3d_DirectionalLight self, Standard_ShortReal theConcentration)

        Defines the coefficient of concentration; value should be within range [0.0, 1.0].

        :type theConcentration: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetConcentration(self, *args)


    def Intensity(self, *args):
        """
        Intensity(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns the intensity of light source; 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_Intensity(self, *args)


    def SetIntensity(self, *args):
        """
        SetIntensity(Handle_V3d_DirectionalLight self, Standard_ShortReal theValue)

        Modifies the intensity of light source, which should be > 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetIntensity(self, *args)


    def Smoothness(self, *args):
        """
        Smoothness(Handle_V3d_DirectionalLight self) -> Standard_ShortReal

        Returns the smoothness of light source (either smoothing angle for directional light or smoothing radius in case of positional light); 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _V3d.Handle_V3d_DirectionalLight_Smoothness(self, *args)


    def SetSmoothRadius(self, *args):
        """
        SetSmoothRadius(Handle_V3d_DirectionalLight self, Standard_ShortReal theValue)

        Modifies the smoothing radius of positional/spot light; should be >= 0.0.

        :type theValue: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetSmoothRadius(self, *args)


    def SetSmoothAngle(self, *args):
        """
        SetSmoothAngle(Handle_V3d_DirectionalLight self, Standard_ShortReal theValue)

        Modifies the smoothing angle (in radians) of directional light source; should be within range [0.0, M_PI/2].

        :type theValue: float

        """
        return _V3d.Handle_V3d_DirectionalLight_SetSmoothAngle(self, *args)


    def GetId(self, *args):
        """
        @return light resource identifier string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _V3d.Handle_V3d_DirectionalLight_GetId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedParams(self, *args):
        """
        Packed light parameters.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_DirectionalLight_PackedParams(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedColor(self, *args):
        """
        Returns the color of the light source with dummy Alpha component, which should be ignored.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_DirectionalLight_PackedColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PackedDirection(self, *args):
        """
        Returns direction of directional/spot light.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_Vec4

        """
        res = _V3d.Handle_V3d_DirectionalLight_PackedDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Revision(self, *args):
        """
        Revision(Handle_V3d_DirectionalLight self) -> Standard_Size

        @return modification counter

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _V3d.Handle_V3d_DirectionalLight_Revision(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_DirectionalLight self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_DirectionalLight_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_DirectionalLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_DirectionalLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_DirectionalLight_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_DirectionalLight self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_DirectionalLight self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_DirectionalLight_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_DirectionalLight self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_DirectionalLight_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_DirectionalLight self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_DirectionalLight_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_DirectionalLight self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_DirectionalLight_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_DirectionalLight self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_DirectionalLight_DecrementRefCounter(self, *args)

Handle_V3d_DirectionalLight_swigregister = _V3d.Handle_V3d_DirectionalLight_swigregister
Handle_V3d_DirectionalLight_swigregister(Handle_V3d_DirectionalLight)

def Handle_V3d_DirectionalLight_DownCast(thing):
    return _V3d.Handle_V3d_DirectionalLight_DownCast(thing)
Handle_V3d_DirectionalLight_DownCast = _V3d.Handle_V3d_DirectionalLight_DownCast

class Handle_V3d_RectangularGrid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_RectangularGrid self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_RectangularGrid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_RectangularGrid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_RectangularGrid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_RectangularGrid self, V3d_RectangularGrid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_RectangularGrid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_RectangularGrid self, Handle_V3d_RectangularGrid theHandle) -> Handle_V3d_RectangularGrid
        assign(Handle_V3d_RectangularGrid self, V3d_RectangularGrid thePtr) -> Handle_V3d_RectangularGrid
        assign(Handle_V3d_RectangularGrid self, Handle_V3d_RectangularGrid theHandle) -> Handle_V3d_RectangularGrid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_RectangularGrid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_RectangularGrid self) -> V3d_RectangularGrid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_RectangularGrid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_RectangularGrid self) -> V3d_RectangularGrid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_RectangularGrid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_RectangularGrid self) -> V3d_RectangularGrid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_RectangularGrid___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_RectangularGrid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_RectangularGrid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_RectangularGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_RectangularGrid_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_RectangularGrid

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_RectangularGrid self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_RectangularGrid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_RectangularGrid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_RectangularGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(Handle_V3d_RectangularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_RectangularGrid_SetColors(self, *args)


    def Display(self, *args):
        """
        Display(Handle_V3d_RectangularGrid self)

        Display the grid at screen.


        """
        return _V3d.Handle_V3d_RectangularGrid_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_V3d_RectangularGrid self)

        Erase the grid from screen.


        """
        return _V3d.Handle_V3d_RectangularGrid_Erase(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_V3d_RectangularGrid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_RectangularGrid_IsDisplayed(self, *args)


    def GraphicValues(self, *args):
        """
        GraphicValues(Handle_V3d_RectangularGrid self)

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_RectangularGrid_GraphicValues(self, *args)


    def SetGraphicValues(self, *args):
        """
        SetGraphicValues(Handle_V3d_RectangularGrid self, Standard_Real const XSize, Standard_Real const YSize, Standard_Real const OffSet)

        :type XSize: float
        :type YSize: float
        :type OffSet: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetGraphicValues(self, *args)


    def SetXStep(self, *args):
        """
        SetXStep(Handle_V3d_RectangularGrid self, Standard_Real const aStep)

        defines the x step of the grid.

        :type aStep: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetXStep(self, *args)


    def SetYStep(self, *args):
        """
        SetYStep(Handle_V3d_RectangularGrid self, Standard_Real const aStep)

        defines the y step of the grid.

        :type aStep: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetYStep(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_V3d_RectangularGrid self, Standard_Real const anAngle1, Standard_Real const anAngle2)

        defines the angle of the second network
        the fist angle is given relatively to the horizontal.
        the second angle is given relatively to the vertical.

        :type anAngle1: float
        :type anAngle2: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetAngle(self, *args)


    def SetGridValues(self, *args):
        """
        SetGridValues(Handle_V3d_RectangularGrid self, Standard_Real const XOrigin, Standard_Real const YOrigin, Standard_Real const XStep, Standard_Real const YStep, Standard_Real const RotationAngle)

        :type XOrigin: float
        :type YOrigin: float
        :type XStep: float
        :type YStep: float
        :type RotationAngle: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetGridValues(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_V3d_RectangularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _V3d.Handle_V3d_RectangularGrid_Compute(self, *args)


    def XStep(self, *args):
        """
        XStep(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_XStep(self, *args)


    def YStep(self, *args):
        """
        YStep(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x step of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_YStep(self, *args)


    def FirstAngle(self, *args):
        """
        FirstAngle(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x Angle of the grid, relatively to the horizontal.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_FirstAngle(self, *args)


    def SecondAngle(self, *args):
        """
        SecondAngle(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the y Angle of the grid, relatively to the vertical.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_SecondAngle(self, *args)


    def Init(self, *args):
        """Init(Handle_V3d_RectangularGrid self)"""
        return _V3d.Handle_V3d_RectangularGrid_Init(self, *args)


    def SetXOrigin(self, *args):
        """
        SetXOrigin(Handle_V3d_RectangularGrid self, Standard_Real const anOrigin)

        defines the x Origin of the grid.

        :type anOrigin: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetXOrigin(self, *args)


    def SetYOrigin(self, *args):
        """
        SetYOrigin(Handle_V3d_RectangularGrid self, Standard_Real const anOrigin)

        defines the y Origin of the grid.

        :type anOrigin: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetYOrigin(self, *args)


    def SetRotationAngle(self, *args):
        """
        SetRotationAngle(Handle_V3d_RectangularGrid self, Standard_Real const anAngle)

        defines the orientation of the grid.

        :type anAngle: float

        """
        return _V3d.Handle_V3d_RectangularGrid_SetRotationAngle(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_V3d_RectangularGrid self, Standard_Real const anAngle)

        Rotate the grid from a relative angle.

        :type anAngle: float

        """
        return _V3d.Handle_V3d_RectangularGrid_Rotate(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_V3d_RectangularGrid self, Standard_Real const aDx, Standard_Real const aDy)

        Translate the grid from a relative distance.

        :type aDx: float
        :type aDy: float

        """
        return _V3d.Handle_V3d_RectangularGrid_Translate(self, *args)


    def Hit(self, *args):
        """
        Hit(Handle_V3d_RectangularGrid self, Standard_Real const X, Standard_Real const Y)

        returns the point of the grid the closest to the point X,Y
        if the grid is active. If the grid is not active returns
        X,Y.

        :type X: float
        :type Y: float
        :type gridX: float
        :type gridY: float

        """
        return _V3d.Handle_V3d_RectangularGrid_Hit(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_V3d_RectangularGrid self)

        activates the grid. The Hit method will return
        gridx and gridx computed according to the steps
        of the grid.


        """
        return _V3d.Handle_V3d_RectangularGrid_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_V3d_RectangularGrid self)

        deactivates the grid. The hit method will return
        gridx and gridx as the enter value X & Y.


        """
        return _V3d.Handle_V3d_RectangularGrid_Deactivate(self, *args)


    def XOrigin(self, *args):
        """
        XOrigin(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_XOrigin(self, *args)


    def YOrigin(self, *args):
        """
        YOrigin(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x Origin of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_YOrigin(self, *args)


    def RotationAngle(self, *args):
        """
        RotationAngle(Handle_V3d_RectangularGrid self) -> Standard_Real

        returns the x Angle of the grid.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _V3d.Handle_V3d_RectangularGrid_RotationAngle(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Handle_V3d_RectangularGrid self) -> Standard_Boolean

        Returns TRUE when the grid is active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_RectangularGrid_IsActive(self, *args)


    def Colors(self, *args):
        """
        Colors(Handle_V3d_RectangularGrid self, Quantity_Color aColor, Quantity_Color aTenthColor)

        Returns the colors of the grid.

        :type aColor: OCC.wrapper.Quantity.Quantity_Color
        :type aTenthColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_RectangularGrid_Colors(self, *args)


    def SetDrawMode(self, *args):
        """
        SetDrawMode(Handle_V3d_RectangularGrid self, Aspect_GridDrawMode const aDrawMode)

        Change the grid aspect.

        :type aDrawMode: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_RectangularGrid_SetDrawMode(self, *args)


    def DrawMode(self, *args):
        """
        DrawMode(Handle_V3d_RectangularGrid self) -> Aspect_GridDrawMode

        Returns the grid aspect.

        :rtype: OCC.wrapper.Aspect.Aspect_GridDrawMode

        """
        return _V3d.Handle_V3d_RectangularGrid_DrawMode(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_RectangularGrid self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_RectangularGrid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_RectangularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_RectangularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_RectangularGrid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_RectangularGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_RectangularGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_RectangularGrid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_RectangularGrid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_RectangularGrid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_RectangularGrid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_RectangularGrid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_RectangularGrid self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_RectangularGrid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_RectangularGrid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_RectangularGrid_DecrementRefCounter(self, *args)

Handle_V3d_RectangularGrid_swigregister = _V3d.Handle_V3d_RectangularGrid_swigregister
Handle_V3d_RectangularGrid_swigregister(Handle_V3d_RectangularGrid)

def Handle_V3d_RectangularGrid_DownCast(thing):
    return _V3d.Handle_V3d_RectangularGrid_DownCast(thing)
Handle_V3d_RectangularGrid_DownCast = _V3d.Handle_V3d_RectangularGrid_DownCast

class NCollection_List_Handle_V3d_View(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_V3d_View self) -> NCollection_List< opencascade::handle< V3d_View > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_V3d_View self) -> NCollection_List< opencascade::handle< V3d_View > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_V3d_View self) -> NCollection_List< opencascade::handle< V3d_View > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_V3d_View self) -> NCollection_List< opencascade::handle< V3d_View > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _V3d.new_NCollection_List_Handle_V3d_View(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_V3d_View self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.NCollection_List_Handle_V3d_View_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther) -> NCollection_List_Handle_V3d_View

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_V3d_View_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther) -> NCollection_List_Handle_V3d_View

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_V3d_View_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_V3d_View self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _V3d.NCollection_List_Handle_V3d_View_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _V3d.NCollection_List_Handle_V3d_View_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _V3d.NCollection_List_Handle_V3d_View_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_V3d_View self, Handle_V3d_View theItem) -> Handle_V3d_View
        Append(NCollection_List_Handle_V3d_View self, Handle_V3d_View theItem, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter)
        Append(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_V3d_View_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_V3d_View self, Handle_V3d_View theItem) -> Handle_V3d_View
        Prepend(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _V3d.NCollection_List_Handle_V3d_View_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_V3d_View self)

        RemoveFirst item


        """
        return _V3d.NCollection_List_Handle_V3d_View_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_V3d_View self, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_V3d_View self, Handle_V3d_View theItem, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter) -> Handle_V3d_View
        InsertBefore(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_V3d_View self, Handle_V3d_View theItem, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter) -> Handle_V3d_View
        InsertAfter(NCollection_List_Handle_V3d_View self, NCollection_List_Handle_V3d_View theOther, NCollection_List< opencascade::handle< V3d_View > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _V3d.NCollection_List_Handle_V3d_View_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_V3d_View self)

        Reverse the list


        """
        return _V3d.NCollection_List_Handle_V3d_View_Reverse(self, *args)


    def __iter__(self):
        return _V3d.NCollection_List_Handle_V3d_View___iter__(self)
    __swig_destroy__ = _V3d.delete_NCollection_List_Handle_V3d_View
NCollection_List_Handle_V3d_View_swigregister = _V3d.NCollection_List_Handle_V3d_View_swigregister
NCollection_List_Handle_V3d_View_swigregister(NCollection_List_Handle_V3d_View)

class NCollection_List_Handle_V3d_View_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _V3d.new_NCollection_List_Handle_V3d_View_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _V3d.delete_NCollection_List_Handle_V3d_View_IteratorHelper

    def __next__(self):
        return _V3d.NCollection_List_Handle_V3d_View_IteratorHelper___next__(self)
NCollection_List_Handle_V3d_View_IteratorHelper_swigregister = _V3d.NCollection_List_Handle_V3d_View_IteratorHelper_swigregister
NCollection_List_Handle_V3d_View_IteratorHelper_swigregister(NCollection_List_Handle_V3d_View_IteratorHelper)


try:
	V3d_ListOfView = NCollection_List_Handle_V3d_View
except NameError:
	pass # does not exist, probably ignored

class V3d_(object):
    """
    This package contains the set of commands and services
    of the 3D Viewer. It provides a set of high level commands
    to control the views and viewing modes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetProjAxis(*args):
        """
        GetProjAxis(V3d_TypeOfOrientation const theOrientation) -> gp_Dir

        Determines the orientation vector corresponding to the predefined orientation type.

        :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _V3d.V3d__GetProjAxis(*args)

    GetProjAxis = staticmethod(GetProjAxis)

    def ArrowOfRadius(*args):
        """
        ArrowOfRadius(Handle_Graphic3d_Group garrow, Standard_Real const X0, Standard_Real const Y0, Standard_Real const Z0, Standard_Real const DX, Standard_Real const DY, Standard_Real const DZ, Standard_Real const Alpha, Standard_Real const Lng)

        Compute the graphic structure of arrow.
        X0,Y0,Z0 : coordinate of the arrow.
        DX,DY,DZ : Direction of the arrow.
        Alpha    : Angle of arrow.
        Lng      : Length of arrow.

        :type garrow: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group
        :type X0: float
        :type Y0: float
        :type Z0: float
        :type DX: float
        :type DY: float
        :type DZ: float
        :type Alpha: float
        :type Lng: float

        """
        return _V3d.V3d__ArrowOfRadius(*args)

    ArrowOfRadius = staticmethod(ArrowOfRadius)

    def CircleInPlane(*args):
        """
        CircleInPlane(Handle_Graphic3d_Group gcircle, Standard_Real const X0, Standard_Real const Y0, Standard_Real const Z0, Standard_Real const VX, Standard_Real const VY, Standard_Real const VZ, Standard_Real const Radius)

        Compute the graphic structure of circle.
        X0,Y0,Z0 : Center of circle.
        VX,VY,VZ : Axis of circle.
        Radius   : Radius of circle.

        :type gcircle: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group
        :type X0: float
        :type Y0: float
        :type Z0: float
        :type VX: float
        :type VY: float
        :type VZ: float
        :type Radius: float

        """
        return _V3d.V3d__CircleInPlane(*args)

    CircleInPlane = staticmethod(CircleInPlane)

    def SwitchViewsinWindow(*args):
        """
        SwitchViewsinWindow(Handle_V3d_View aPreviousView, Handle_V3d_View aNextView)

        :type aPreviousView: OCC.wrapper.V3d.Handle_V3d_View
        :type aNextView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _V3d.V3d__SwitchViewsinWindow(*args)

    SwitchViewsinWindow = staticmethod(SwitchViewsinWindow)

    def TypeOfOrientationToString(*args):
        """
        TypeOfOrientationToString(V3d_TypeOfOrientation theType) -> Standard_CString

        Returns the string name for a given orientation type.
        @param theType orientation type
        @return string identifier from the list Xpos, Ypos, Zpos and others

        :type theType: OCC.wrapper.V3d.V3d_TypeOfOrientation
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _V3d.V3d__TypeOfOrientationToString(*args)

    TypeOfOrientationToString = staticmethod(TypeOfOrientationToString)

    def TypeOfOrientationFromString(*args):
        """
        TypeOfOrientationFromString(Standard_CString theTypeString) -> V3d_TypeOfOrientation
        TypeOfOrientationFromString(Standard_CString const theTypeString) -> Standard_Boolean

        Determines the shape type from the given string identifier (using case-insensitive comparison).
        @param theTypeString string identifier
        @param theType detected shape type
        @return TRUE if string identifier is known

        :type theTypeString: OCC.wrapper.Standard.Standard_CString
        :type theType: OCC.wrapper.V3d.V3d_TypeOfOrientation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.V3d__TypeOfOrientationFromString(*args)

    TypeOfOrientationFromString = staticmethod(TypeOfOrientationFromString)

    def __init__(self):
        """
        This package contains the set of commands and services
        of the 3D Viewer. It provides a set of high level commands
        to control the views and viewing modes.
        """
        this = _V3d.new_V3d_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _V3d.delete_V3d_
V3d__swigregister = _V3d.V3d__swigregister
V3d__swigregister(V3d_)

def V3d__GetProjAxis(*args):
    """
    V3d__GetProjAxis(V3d_TypeOfOrientation const theOrientation) -> gp_Dir

    Determines the orientation vector corresponding to the predefined orientation type.

    :type theOrientation: OCC.wrapper.V3d.V3d_TypeOfOrientation
    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _V3d.V3d__GetProjAxis(*args)

def V3d__ArrowOfRadius(*args):
    """
    V3d__ArrowOfRadius(Handle_Graphic3d_Group garrow, Standard_Real const X0, Standard_Real const Y0, Standard_Real const Z0, Standard_Real const DX, Standard_Real const DY, Standard_Real const DZ, Standard_Real const Alpha, Standard_Real const Lng)

    Compute the graphic structure of arrow.
    X0,Y0,Z0 : coordinate of the arrow.
    DX,DY,DZ : Direction of the arrow.
    Alpha    : Angle of arrow.
    Lng      : Length of arrow.

    :type garrow: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group
    :type X0: float
    :type Y0: float
    :type Z0: float
    :type DX: float
    :type DY: float
    :type DZ: float
    :type Alpha: float
    :type Lng: float

    """
    return _V3d.V3d__ArrowOfRadius(*args)

def V3d__CircleInPlane(*args):
    """
    V3d__CircleInPlane(Handle_Graphic3d_Group gcircle, Standard_Real const X0, Standard_Real const Y0, Standard_Real const Z0, Standard_Real const VX, Standard_Real const VY, Standard_Real const VZ, Standard_Real const Radius)

    Compute the graphic structure of circle.
    X0,Y0,Z0 : Center of circle.
    VX,VY,VZ : Axis of circle.
    Radius   : Radius of circle.

    :type gcircle: OCC.wrapper.Graphic3d.Handle_Graphic3d_Group
    :type X0: float
    :type Y0: float
    :type Z0: float
    :type VX: float
    :type VY: float
    :type VZ: float
    :type Radius: float

    """
    return _V3d.V3d__CircleInPlane(*args)

def V3d__SwitchViewsinWindow(*args):
    """
    V3d__SwitchViewsinWindow(Handle_V3d_View aPreviousView, Handle_V3d_View aNextView)

    :type aPreviousView: OCC.wrapper.V3d.Handle_V3d_View
    :type aNextView: OCC.wrapper.V3d.Handle_V3d_View

    """
    return _V3d.V3d__SwitchViewsinWindow(*args)

def V3d__TypeOfOrientationToString(*args):
    """
    V3d__TypeOfOrientationToString(V3d_TypeOfOrientation theType) -> Standard_CString

    Returns the string name for a given orientation type.
    @param theType orientation type
    @return string identifier from the list Xpos, Ypos, Zpos and others

    :type theType: OCC.wrapper.V3d.V3d_TypeOfOrientation
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _V3d.V3d__TypeOfOrientationToString(*args)

def V3d__TypeOfOrientationFromString(*args):
    """
    TypeOfOrientationFromString(Standard_CString theTypeString) -> V3d_TypeOfOrientation
    V3d__TypeOfOrientationFromString(Standard_CString const theTypeString) -> Standard_Boolean

    Determines the shape type from the given string identifier (using case-insensitive comparison).
    @param theTypeString string identifier
    @param theType detected shape type
    @return TRUE if string identifier is known

    :type theTypeString: OCC.wrapper.Standard.Standard_CString
    :type theType: OCC.wrapper.V3d.V3d_TypeOfOrientation
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _V3d.V3d__TypeOfOrientationFromString(*args)

class Handle_V3d_Trihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_V3d_Trihedron self)

        Nullify the handle


        """
        return _V3d.Handle_V3d_Trihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_V3d_Trihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _V3d.Handle_V3d_Trihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_V3d_Trihedron self, V3d_Trihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _V3d.Handle_V3d_Trihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_V3d_Trihedron self, Handle_V3d_Trihedron theHandle) -> Handle_V3d_Trihedron
        assign(Handle_V3d_Trihedron self, V3d_Trihedron thePtr) -> Handle_V3d_Trihedron
        assign(Handle_V3d_Trihedron self, Handle_V3d_Trihedron theHandle) -> Handle_V3d_Trihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _V3d.Handle_V3d_Trihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_V3d_Trihedron self) -> V3d_Trihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _V3d.Handle_V3d_Trihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_V3d_Trihedron self) -> V3d_Trihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _V3d.Handle_V3d_Trihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_V3d_Trihedron self) -> V3d_Trihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _V3d.Handle_V3d_Trihedron___ref__(self, *args)


    def __hash__(self):
        return _V3d.Handle_V3d_Trihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _V3d.Handle_V3d_Trihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _V3d.new_Handle_V3d_Trihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_V3d.Handle_V3d_Trihedron_DownCast)
    __swig_destroy__ = _V3d.delete_Handle_V3d_Trihedron

    def get_type_name(self, *args):
        """
        get_type_name(Handle_V3d_Trihedron self) -> char const *

        :rtype: const char *

        """
        return _V3d.Handle_V3d_Trihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Trihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _V3d.Handle_V3d_Trihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWireframe(self, *args):
        """
        SetWireframe(Handle_V3d_Trihedron self, Standard_Boolean const theAsWireframe)

        Switch wireframe / shaded trihedron.

        :type theAsWireframe: bool

        """
        return _V3d.Handle_V3d_Trihedron_SetWireframe(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_V3d_Trihedron self, Aspect_TypeOfTriedronPosition const thePosition)

        Setup the corner to draw the trihedron.

        :type thePosition: OCC.wrapper.Aspect.Aspect_TypeOfTriedronPosition

        """
        return _V3d.Handle_V3d_Trihedron_SetPosition(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_V3d_Trihedron self, Standard_Real const theScale)

        Setup the scale factor.

        :type theScale: float

        """
        return _V3d.Handle_V3d_Trihedron_SetScale(self, *args)


    def SetSizeRatio(self, *args):
        """
        SetSizeRatio(Handle_V3d_Trihedron self, Standard_Real const theRatio)

        Setup the size ratio factor.

        :type theRatio: float

        """
        return _V3d.Handle_V3d_Trihedron_SetSizeRatio(self, *args)


    def SetArrowDiameter(self, *args):
        """
        SetArrowDiameter(Handle_V3d_Trihedron self, Standard_Real const theDiam)

        Setup the arrow diameter.

        :type theDiam: float

        """
        return _V3d.Handle_V3d_Trihedron_SetArrowDiameter(self, *args)


    def SetNbFacets(self, *args):
        """
        SetNbFacets(Handle_V3d_Trihedron self, Standard_Integer const theNbFacets)

        Setup the number of facets for tessellation.

        :type theNbFacets: int

        """
        return _V3d.Handle_V3d_Trihedron_SetNbFacets(self, *args)


    def SetLabelsColor(self, *args):
        """
        SetLabelsColor(Handle_V3d_Trihedron self, Quantity_Color theColor)

        Setup color of text labels.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_Trihedron_SetLabelsColor(self, *args)


    def SetArrowsColor(self, *args):
        """
        SetArrowsColor(Handle_V3d_Trihedron self, Quantity_Color theXColor, Quantity_Color theYColor, Quantity_Color theZColor)

        Setup colors of arrows.

        :type theXColor: OCC.wrapper.Quantity.Quantity_Color
        :type theYColor: OCC.wrapper.Quantity.Quantity_Color
        :type theZColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _V3d.Handle_V3d_Trihedron_SetArrowsColor(self, *args)


    def Display(self, *args):
        """
        Display(Handle_V3d_Trihedron self, V3d_View theView)

        Display trihedron.

        :type theView: OCC.wrapper.V3d.V3d_View

        """
        return _V3d.Handle_V3d_Trihedron_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_V3d_Trihedron self)

        Erase trihedron.


        """
        return _V3d.Handle_V3d_Trihedron_Erase(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_V3d_Trihedron self)

        Memory deallocator for transient classes


        """
        return _V3d.Handle_V3d_Trihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_V3d_Trihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_V3d_Trihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Trihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_V3d_Trihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_V3d_Trihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _V3d.Handle_V3d_Trihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_V3d_Trihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _V3d.Handle_V3d_Trihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_V3d_Trihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Trihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_V3d_Trihedron self)

        Increments the reference counter of this object


        """
        return _V3d.Handle_V3d_Trihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_V3d_Trihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _V3d.Handle_V3d_Trihedron_DecrementRefCounter(self, *args)

Handle_V3d_Trihedron_swigregister = _V3d.Handle_V3d_Trihedron_swigregister
Handle_V3d_Trihedron_swigregister(Handle_V3d_Trihedron)

def Handle_V3d_Trihedron_DownCast(thing):
    return _V3d.Handle_V3d_Trihedron_DownCast(thing)
Handle_V3d_Trihedron_DownCast = _V3d.Handle_V3d_Trihedron_DownCast




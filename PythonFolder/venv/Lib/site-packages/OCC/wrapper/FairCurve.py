# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_FairCurve')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_FairCurve')
    _FairCurve = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FairCurve', [dirname(__file__)])
        except ImportError:
            import _FairCurve
            return _FairCurve
        try:
            _mod = imp.load_module('_FairCurve', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _FairCurve = swig_import_helper()
    del swig_import_helper
else:
    import _FairCurve
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _FairCurve.delete_SwigPyIterator

    def value(self):
        return _FairCurve.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _FairCurve.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _FairCurve.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _FairCurve.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _FairCurve.SwigPyIterator_equal(self, x)

    def copy(self):
        return _FairCurve.SwigPyIterator_copy(self)

    def next(self):
        return _FairCurve.SwigPyIterator_next(self)

    def __next__(self):
        return _FairCurve.SwigPyIterator___next__(self)

    def previous(self):
        return _FairCurve.SwigPyIterator_previous(self)

    def advance(self, n):
        return _FairCurve.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _FairCurve.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _FairCurve.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _FairCurve.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _FairCurve.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _FairCurve.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _FairCurve.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _FairCurve.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _FairCurve.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_FairCurve.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _FairCurve.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _FairCurve.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _FairCurve.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _FairCurve.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _FairCurve.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _FairCurve.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _FairCurve.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_FairCurve.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _FairCurve.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _FairCurve.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _FairCurve.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _FairCurve.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _FairCurve.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _FairCurve.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _FairCurve.ptr_to_number(item)
ptr_to_number = _FairCurve.ptr_to_number

def HashCode(*args):
    return _FairCurve.HashCode(*args)
HashCode = _FairCurve.HashCode

def ptr_equal(a, b):
    return _FairCurve.ptr_equal(a, b)
ptr_equal = _FairCurve.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
FairCurve_OK = _FairCurve.FairCurve_OK
FairCurve_NotConverged = _FairCurve.FairCurve_NotConverged
FairCurve_InfiniteSliding = _FairCurve.FairCurve_InfiniteSliding
FairCurve_NullHeight = _FairCurve.FairCurve_NullHeight
class FairCurve_DistributionOfEnergy(math.math_FunctionSet):
    """Abstract class to use the Energy of an FairCurve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(FairCurve_DistributionOfEnergy self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _FairCurve.FairCurve_DistributionOfEnergy_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(FairCurve_DistributionOfEnergy self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _FairCurve.FairCurve_DistributionOfEnergy_NbEquations(self, *args)


    def SetDerivativeOrder(self, *args):
        """
        SetDerivativeOrder(FairCurve_DistributionOfEnergy self, Standard_Integer const DerivativeOrder)

        :type DerivativeOrder: int

        """
        return _FairCurve.FairCurve_DistributionOfEnergy_SetDerivativeOrder(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfEnergy
FairCurve_DistributionOfEnergy_swigregister = _FairCurve.FairCurve_DistributionOfEnergy_swigregister
FairCurve_DistributionOfEnergy_swigregister(FairCurve_DistributionOfEnergy)

class FairCurve_Energy(math.math_MultipleVarFunctionWithHessian):
    """necessary methodes to compute the energy of an FairCurve."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(FairCurve_Energy self) -> Standard_Integer

        returns the number of variables of the energy.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _FairCurve.FairCurve_Energy_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(FairCurve_Energy self, math_Vector X) -> Standard_Boolean

        computes the values of the Energys E for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type E: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Energy_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(FairCurve_Energy self, math_Vector X, math_Vector G) -> Standard_Boolean

        computes the gradient <G> of the energys for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Energy_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(FairCurve_Energy self, math_Vector X, math_Vector G) -> Standard_Boolean
        Values(FairCurve_Energy self, math_Vector X, math_Vector G, math_Matrix H) -> Standard_Boolean

        computes the Energy  <E>, the gradient <G> and the
        Hessian   <H> of  the  energy  for  the   variable <X>.
        Returns   True  if    the  computation   was  done
        successfully, False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type E: float
        :type G: OCC.wrapper.math.math_Vector
        :type H: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Energy_Values(self, *args)


    def Variable(self, *args):
        """
        Variable(FairCurve_Energy self, math_Vector X) -> Standard_Boolean

        compute the variables <X> wich correspond with the field <MyPoles>

        :type X: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Energy_Variable(self, *args)


    def Poles(self, *args):
        """
        return  the  poles

        :rtype: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d

        """
        res = _FairCurve.FairCurve_Energy_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _FairCurve.delete_FairCurve_Energy
FairCurve_Energy_swigregister = _FairCurve.FairCurve_Energy_swigregister
FairCurve_Energy_swigregister(FairCurve_Energy)

class FairCurve_Newton(math.math_NewtonMinimum):
    """Algorithme of Optimization used to make "FairCurve" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_Newton self, math_MultipleVarFunctionWithHessian theFunction, Standard_Real const theSpatialTolerance=1.0e-7, Standard_Real const theCriteriumTolerance=1.0e-7, Standard_Integer const theNbIterations=40, Standard_Real const theConvexity=1.0e-6, Standard_Boolean const theWithSingularity) -> FairCurve_Newton

        The tolerance  required on  the  solution is given  by Tolerance.
        Iteration are  stopped if (!WithSingularity)  and H(F(Xi)) is not definite
        positive  (if the smaller eigenvalue of H < Convexity)
        or IsConverged() returns True for 2 successives Iterations.
        Warning: This constructor do not computation

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithHessian
        :type theSpatialTolerance: float
        :type theCriteriumTolerance: float
        :type theNbIterations: int
        :type theConvexity: float
        :type theWithSingularity: bool

        """
        this = _FairCurve.new_FairCurve_Newton(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsConverged(self, *args):
        """
        IsConverged(FairCurve_Newton self) -> Standard_Boolean

        This method is  called    at the end  of   each
        iteration to  check the convergence :
        || Xi+1 - Xi || < SpatialTolerance/100 Or
        || Xi+1 - Xi || < SpatialTolerance and
        |F(Xi+1) - F(Xi)| < CriteriumTolerance * |F(xi)|
        It can be redefined in a sub-class to implement a specific test.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Newton_IsConverged(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_Newton
FairCurve_Newton_swigregister = _FairCurve.FairCurve_Newton_swigregister
FairCurve_Newton_swigregister(FairCurve_Newton)

class FairCurve_DistributionOfJerk(FairCurve_DistributionOfEnergy):
    """Compute the "Jerk" distribution."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_DistributionOfJerk self, Standard_Integer const BSplOrder, Handle_TColStd_HArray1OfReal FlatKnots, Handle_TColgp_HArray1OfPnt2d Poles, Standard_Integer const DerivativeOrder, FairCurve_BattenLaw Law, Standard_Integer const NbValAux=0) -> FairCurve_DistributionOfJerk

        :type BSplOrder: int
        :type FlatKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Poles: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type DerivativeOrder: int
        :type Law: OCC.wrapper.FairCurve.FairCurve_BattenLaw
        :type NbValAux: int

        """
        this = _FairCurve.new_FairCurve_DistributionOfJerk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(FairCurve_DistributionOfJerk self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_DistributionOfJerk_Value(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfJerk
FairCurve_DistributionOfJerk_swigregister = _FairCurve.FairCurve_DistributionOfJerk_swigregister
FairCurve_DistributionOfJerk_swigregister(FairCurve_DistributionOfJerk)

class FairCurve_Batten(object):
    """
    Constructs curves with a constant or linearly increasing
    section to be used in the design of wooden or plastic
    battens. These curves are two-dimensional, and
    simulate physical splines or battens.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_Batten self, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const Height, Standard_Real const Slope=0) -> FairCurve_Batten

        Constructor  with the two points and the geometrical
        characteristics of the batten (elastic beam)
        Height is the height of the deformation, and Slope is the
        slope value, initialized at 0. The user can then supply the
        desired slope value by the method, SetSlope.
        Other parameters are initialized as follow :
        - FreeSliding = False
        - ConstraintOrder1 = 1
        - ConstraintOrder2 = 1
        - Angle1 = 0
        - Angle2 = 0
        - SlidingFactor = 1
        Exceptions
        NegativeValue if Height is less than or equal to 0.
        NullValue if the distance between P1 and P2 is less
        than or equal to the tolerance value for distance in
        Precision::Confusion: P1.IsEqual(P2,
        Precision::Confusion()). The function
        gp_Pnt2d::IsEqual tests to see if this is the case.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Height: float
        :type Slope: float

        """
        this = _FairCurve.new_FairCurve_Batten(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFreeSliding(self, *args):
        """
        SetFreeSliding(FairCurve_Batten self, Standard_Boolean const FreeSliding)

        Freesliding is initialized with the default setting false.
        When Freesliding is set to true and, as a result, sliding
        is free, the sliding factor is automatically computed to
        satisfy the equilibrium of the batten.

        :type FreeSliding: bool

        """
        return _FairCurve.FairCurve_Batten_SetFreeSliding(self, *args)


    def SetConstraintOrder1(self, *args):
        """
        SetConstraintOrder1(FairCurve_Batten self, Standard_Integer const ConstraintOrder)

        Allows you to change the order of the constraint on the
        first point. ConstraintOrder has the default setting of 1.
        The following settings are available:
        -   0-the curve must pass through a point
        -   1-the curve must pass through a point and have a given tangent
        -   2-the curve must pass through a point, have a given tangent and a given curvature.
        The third setting is only valid for
        FairCurve_MinimalVariation curves.
        These constraints, though geometric, represent the
        mechanical constraints due, for example, to the
        resistance of the material the actual physical batten is made of.

        :type ConstraintOrder: int

        """
        return _FairCurve.FairCurve_Batten_SetConstraintOrder1(self, *args)


    def SetConstraintOrder2(self, *args):
        """
        SetConstraintOrder2(FairCurve_Batten self, Standard_Integer const ConstraintOrder)

        Allows you to change the order of the constraint on the
        second point. ConstraintOrder is initialized with the default setting of 1.
        The following settings are available:
        -   0-the curve must pass through a point
        -   1-the curve must pass through a point and have a given tangent
        -   2-the curve must pass through a point, have a given
        tangent and a given curvature.
        The third setting is only valid for
        FairCurve_MinimalVariation curves.
        These constraints, though geometric, represent the
        mechanical constraints due, for example, to the
        resistance of the material the actual physical batten is made of.

        :type ConstraintOrder: int

        """
        return _FairCurve.FairCurve_Batten_SetConstraintOrder2(self, *args)


    def SetP1(self, *args):
        """
        SetP1(FairCurve_Batten self, gp_Pnt2d P1)

        Allows you to change the location of the point, P1, and in
        doing so, modify the curve.
        Warning
        This method changes the angle as well as the point.
        Exceptions
        NullValue if the distance between P1 and P2 is less
        than or equal to the tolerance value for distance in
        Precision::Confusion: P1.IsEqual(P2,
        Precision::Confusion()). The function
        gp_Pnt2d::IsEqual tests to see if this is the case.

        :type P1: OCC.wrapper.gp.gp_Pnt2d

        """
        return _FairCurve.FairCurve_Batten_SetP1(self, *args)


    def SetP2(self, *args):
        """
        SetP2(FairCurve_Batten self, gp_Pnt2d P2)

        Allows you to change the location of the point, P1, and in
        doing so, modify the curve.
        Warning
        This method changes the angle as well as the point.
        Exceptions
        NullValue if the distance between P1 and P2 is less
        than or equal to the tolerance value for distance in
        Precision::Confusion: P1.IsEqual(P2,
        Precision::Confusion()). The function
        gp_Pnt2d::IsEqual tests to see if this is the case.

        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _FairCurve.FairCurve_Batten_SetP2(self, *args)


    def SetAngle1(self, *args):
        """
        SetAngle1(FairCurve_Batten self, Standard_Real const Angle1)

        Allows you to change the angle Angle1 at the first point,
        P1. The default setting is 0.

        :type Angle1: float

        """
        return _FairCurve.FairCurve_Batten_SetAngle1(self, *args)


    def SetAngle2(self, *args):
        """
        SetAngle2(FairCurve_Batten self, Standard_Real const Angle2)

        Allows you to change the angle Angle2 at the second
        point, P2. The default setting is 0.

        :type Angle2: float

        """
        return _FairCurve.FairCurve_Batten_SetAngle2(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(FairCurve_Batten self, Standard_Real const Height)

        Allows you to change the height of the deformation.
        Raises  NegativeValue; -- if  Height <= 0
        if  Height <= 0

        :type Height: float

        """
        return _FairCurve.FairCurve_Batten_SetHeight(self, *args)


    def SetSlope(self, *args):
        """
        SetSlope(FairCurve_Batten self, Standard_Real const Slope)

        Allows you to set the slope value, Slope.

        :type Slope: float

        """
        return _FairCurve.FairCurve_Batten_SetSlope(self, *args)


    def SetSlidingFactor(self, *args):
        """
        SetSlidingFactor(FairCurve_Batten self, Standard_Real const SlidingFactor)

        Allows you to change the ratio SlidingFactor. This
        compares the length of the batten and the reference
        length, which is, in turn, a function of the constraints.
        This modification has one of the following two effects:
        -   if you increase the value, it inflates the batten
        -   if you decrease the value, it flattens the batten.
        When sliding is free, the sliding factor is automatically
        computed to satisfy the equilibrium of the batten. When
        sliding is imposed, a value is required for the sliding factor.
        SlidingFactor is initialized with the default setting of 1.

        :type SlidingFactor: float

        """
        return _FairCurve.FairCurve_Batten_SetSlidingFactor(self, *args)


    def Compute(self, *args):
        """
        Compute(FairCurve_Batten self, Standard_Integer const NbIterations=50, Standard_Real const Tolerance=1.0e-3) -> Standard_Boolean

        Performs the algorithm, using the arguments Code,
        NbIterations and Tolerance and computes the curve
        with respect to the constraints.
        Code will have one of the following values:
        -   OK
        -   NotConverged
        -   InfiniteSliding
        -   NullHeight
        The parameters Tolerance and NbIterations control
        how precise the computation is, and how long it will take.

        :type Code: OCC.wrapper.FairCurve.FairCurve_AnalysisCode
        :type NbIterations: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Batten_Compute(self, *args)


    def SlidingOfReference(self, *args):
        """
        SlidingOfReference(FairCurve_Batten self) -> Standard_Real

        Computes the real number value for length Sliding of
        Reference for new constraints. If you want to give a
        specific length to a batten curve, use the following
        syntax: b.SetSlidingFactor(L /
        b.SlidingOfReference()) where b is the
        name of the batten curve object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_SlidingOfReference(self, *args)


    def GetFreeSliding(self, *args):
        """
        GetFreeSliding(FairCurve_Batten self) -> Standard_Boolean

        Returns the initial free sliding value, false by default.
        Free sliding is generally more aesthetically pleasing
        than constrained sliding. However, the computation can
        fail with values such as angles greater than PI/2. This is
        because the resulting batten length is theoretically infinite.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_Batten_GetFreeSliding(self, *args)


    def GetConstraintOrder1(self, *args):
        """
        GetConstraintOrder1(FairCurve_Batten self) -> Standard_Integer

        Returns the established first constraint order.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _FairCurve.FairCurve_Batten_GetConstraintOrder1(self, *args)


    def GetConstraintOrder2(self, *args):
        """
        GetConstraintOrder2(FairCurve_Batten self) -> Standard_Integer

        Returns the established second constraint order.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _FairCurve.FairCurve_Batten_GetConstraintOrder2(self, *args)


    def GetP1(self, *args):
        """
        Returns the established location of the point P1.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _FairCurve.FairCurve_Batten_GetP1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetP2(self, *args):
        """
        Returns the established location of the point P2.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _FairCurve.FairCurve_Batten_GetP2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAngle1(self, *args):
        """
        GetAngle1(FairCurve_Batten self) -> Standard_Real

        Returns the established first angle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_GetAngle1(self, *args)


    def GetAngle2(self, *args):
        """
        GetAngle2(FairCurve_Batten self) -> Standard_Real

        Returns the established second angle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_GetAngle2(self, *args)


    def GetHeight(self, *args):
        """
        GetHeight(FairCurve_Batten self) -> Standard_Real

        Returns the thickness of the lathe.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_GetHeight(self, *args)


    def GetSlope(self, *args):
        """
        GetSlope(FairCurve_Batten self) -> Standard_Real

        Returns the established slope value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_GetSlope(self, *args)


    def GetSlidingFactor(self, *args):
        """
        GetSlidingFactor(FairCurve_Batten self) -> Standard_Real

        Returns the initial sliding factor.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_Batten_GetSlidingFactor(self, *args)


    def Curve(self, *args):
        """
        Curve(FairCurve_Batten self) -> Handle_Geom2d_BSplineCurve

        Returns the computed curve a 2d BSpline.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _FairCurve.FairCurve_Batten_Curve(self, *args)


    def Dump(self, *args):
        """
        Dump(FairCurve_Batten self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.

        Private methodes  --------------------------------------

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _FairCurve.FairCurve_Batten_Dump(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_Batten
FairCurve_Batten_swigregister = _FairCurve.FairCurve_Batten_swigregister
FairCurve_Batten_swigregister(FairCurve_Batten)

class FairCurve_DistributionOfTension(FairCurve_DistributionOfEnergy):
    """Compute the Tension Distribution"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_DistributionOfTension self, Standard_Integer const BSplOrder, Handle_TColStd_HArray1OfReal FlatKnots, Handle_TColgp_HArray1OfPnt2d Poles, Standard_Integer const DerivativeOrder, Standard_Real const LengthSliding, FairCurve_BattenLaw Law, Standard_Integer const NbValAux=0, Standard_Boolean const Uniform) -> FairCurve_DistributionOfTension

        :type BSplOrder: int
        :type FlatKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Poles: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type DerivativeOrder: int
        :type LengthSliding: float
        :type Law: OCC.wrapper.FairCurve.FairCurve_BattenLaw
        :type NbValAux: int
        :type Uniform: bool

        """
        this = _FairCurve.new_FairCurve_DistributionOfTension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLengthSliding(self, *args):
        """
        SetLengthSliding(FairCurve_DistributionOfTension self, Standard_Real const LengthSliding)

        change the length sliding

        :type LengthSliding: float

        """
        return _FairCurve.FairCurve_DistributionOfTension_SetLengthSliding(self, *args)


    def Value(self, *args):
        """
        Value(FairCurve_DistributionOfTension self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_DistributionOfTension_Value(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfTension
FairCurve_DistributionOfTension_swigregister = _FairCurve.FairCurve_DistributionOfTension_swigregister
FairCurve_DistributionOfTension_swigregister(FairCurve_DistributionOfTension)

class FairCurve_BattenLaw(math.math_Function):
    """This class compute the Heigth of an batten"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_BattenLaw self, Standard_Real const Heigth, Standard_Real const Slope, Standard_Real const Sliding) -> FairCurve_BattenLaw

        Constructor of linear batten with
        Heigth : the Heigth at the middle point
        Slope  : the geometric slope of the batten
        Sliding : Active Length of the batten without extension

        :type Heigth: float
        :type Slope: float
        :type Sliding: float

        """
        this = _FairCurve.new_FairCurve_BattenLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSliding(self, *args):
        """
        SetSliding(FairCurve_BattenLaw self, Standard_Real const Sliding)

        Change the value of sliding

        :type Sliding: float

        """
        return _FairCurve.FairCurve_BattenLaw_SetSliding(self, *args)


    def SetHeigth(self, *args):
        """
        SetHeigth(FairCurve_BattenLaw self, Standard_Real const Heigth)

        Change the value of Heigth at the middle point.

        :type Heigth: float

        """
        return _FairCurve.FairCurve_BattenLaw_SetHeigth(self, *args)


    def SetSlope(self, *args):
        """
        SetSlope(FairCurve_BattenLaw self, Standard_Real const Slope)

        Change the value of the geometric slope.

        :type Slope: float

        """
        return _FairCurve.FairCurve_BattenLaw_SetSlope(self, *args)


    def Value(self, *args):
        """
        Value(FairCurve_BattenLaw self, Standard_Real const T) -> Standard_Boolean

        computes the value of  the heigth for the parameter T
        on  the neutral fibber

        :type T: float
        :type THeigth: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_BattenLaw_Value(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_BattenLaw
FairCurve_BattenLaw_swigregister = _FairCurve.FairCurve_BattenLaw_swigregister
FairCurve_BattenLaw_swigregister(FairCurve_BattenLaw)

class FairCurve_DistributionOfSagging(FairCurve_DistributionOfEnergy):
    """Compute the Sagging Distribution"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_DistributionOfSagging self, Standard_Integer const BSplOrder, Handle_TColStd_HArray1OfReal FlatKnots, Handle_TColgp_HArray1OfPnt2d Poles, Standard_Integer const DerivativeOrder, FairCurve_BattenLaw Law, Standard_Integer const NbValAux=0) -> FairCurve_DistributionOfSagging

        :type BSplOrder: int
        :type FlatKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Poles: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type DerivativeOrder: int
        :type Law: OCC.wrapper.FairCurve.FairCurve_BattenLaw
        :type NbValAux: int

        """
        this = _FairCurve.new_FairCurve_DistributionOfSagging(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(FairCurve_DistributionOfSagging self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_DistributionOfSagging_Value(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_DistributionOfSagging
FairCurve_DistributionOfSagging_swigregister = _FairCurve.FairCurve_DistributionOfSagging_swigregister
FairCurve_DistributionOfSagging_swigregister(FairCurve_DistributionOfSagging)

class FairCurve_EnergyOfBatten(FairCurve_Energy):
    """Energy Criterium to minimize in Batten."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_EnergyOfBatten self, Standard_Integer const BSplOrder, Handle_TColStd_HArray1OfReal FlatKnots, Handle_TColgp_HArray1OfPnt2d Poles, Standard_Integer const ContrOrder1, Standard_Integer const ContrOrder2, FairCurve_BattenLaw Law, Standard_Real const LengthSliding, Standard_Boolean const FreeSliding, Standard_Real const Angle1=0, Standard_Real const Angle2=0) -> FairCurve_EnergyOfBatten

        Angles corresspond to the Ox axis

        :type BSplOrder: int
        :type FlatKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Poles: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type ContrOrder1: int
        :type ContrOrder2: int
        :type Law: OCC.wrapper.FairCurve.FairCurve_BattenLaw
        :type LengthSliding: float
        :type FreeSliding: bool
        :type Angle1: float
        :type Angle2: float

        """
        this = _FairCurve.new_FairCurve_EnergyOfBatten(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LengthSliding(self, *args):
        """
        LengthSliding(FairCurve_EnergyOfBatten self) -> Standard_Real

        return  the  lengthSliding = P1P2 + Sliding

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_EnergyOfBatten_LengthSliding(self, *args)


    def Status(self, *args):
        """
        Status(FairCurve_EnergyOfBatten self) -> FairCurve_AnalysisCode

        return  the status

        :rtype: OCC.wrapper.FairCurve.FairCurve_AnalysisCode

        """
        return _FairCurve.FairCurve_EnergyOfBatten_Status(self, *args)


    def Variable(self, *args):
        """
        Variable(FairCurve_EnergyOfBatten self, math_Vector X) -> Standard_Boolean

        compute the variables <X> wich correspond with the field <MyPoles>

        :type X: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_EnergyOfBatten_Variable(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_EnergyOfBatten
FairCurve_EnergyOfBatten_swigregister = _FairCurve.FairCurve_EnergyOfBatten_swigregister
FairCurve_EnergyOfBatten_swigregister(FairCurve_EnergyOfBatten)

class FairCurve_EnergyOfMVC(FairCurve_Energy):
    """Energy Criterium to minimize in MinimalVariationCurve."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_EnergyOfMVC self, Standard_Integer const BSplOrder, Handle_TColStd_HArray1OfReal FlatKnots, Handle_TColgp_HArray1OfPnt2d Poles, Standard_Integer const ContrOrder1, Standard_Integer const ContrOrder2, FairCurve_BattenLaw Law, Standard_Real const PhysicalRatio, Standard_Real const LengthSliding, Standard_Boolean const FreeSliding, Standard_Real const Angle1=0, Standard_Real const Angle2=0, Standard_Real const Curvature1=0, Standard_Real const Curvature2=0) -> FairCurve_EnergyOfMVC

        Angles corresspond to the Ox axis

        :type BSplOrder: int
        :type FlatKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Poles: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type ContrOrder1: int
        :type ContrOrder2: int
        :type Law: OCC.wrapper.FairCurve.FairCurve_BattenLaw
        :type PhysicalRatio: float
        :type LengthSliding: float
        :type FreeSliding: bool
        :type Angle1: float
        :type Angle2: float
        :type Curvature1: float
        :type Curvature2: float

        """
        this = _FairCurve.new_FairCurve_EnergyOfMVC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LengthSliding(self, *args):
        """
        LengthSliding(FairCurve_EnergyOfMVC self) -> Standard_Real

        return  the  lengthSliding = P1P2 + Sliding

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_EnergyOfMVC_LengthSliding(self, *args)


    def Status(self, *args):
        """
        Status(FairCurve_EnergyOfMVC self) -> FairCurve_AnalysisCode

        return  the status

        :rtype: OCC.wrapper.FairCurve.FairCurve_AnalysisCode

        """
        return _FairCurve.FairCurve_EnergyOfMVC_Status(self, *args)


    def Variable(self, *args):
        """
        Variable(FairCurve_EnergyOfMVC self, math_Vector X) -> Standard_Boolean

        compute the variables <X> wich correspond with the field <MyPoles>

        :type X: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_EnergyOfMVC_Variable(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_EnergyOfMVC
FairCurve_EnergyOfMVC_swigregister = _FairCurve.FairCurve_EnergyOfMVC_swigregister
FairCurve_EnergyOfMVC_swigregister(FairCurve_EnergyOfMVC)

class FairCurve_MinimalVariation(FairCurve_Batten):
    """
    Computes a 2D curve using an algorithm which
    minimizes tension, sagging, and jerk energy. As in
    FairCurve_Batten, two reference points are used.
    Unlike that class, FairCurve_MinimalVariation
    requires curvature settings at the first and second
    reference points. These are defined by the rays of
    curvature desired at each point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(FairCurve_MinimalVariation self, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const Heigth, Standard_Real const Slope=0, Standard_Real const PhysicalRatio=0) -> FairCurve_MinimalVariation

        Constructs the two contact points P1 and P2  and the geometrical
        characteristics of the batten (elastic beam)
        These include the real number values for height of
        deformation Height, slope value Slope, and kind of
        energy PhysicalRatio. The kinds of energy include:
        -   Jerk (0)
        -   Sagging (1).
        Note that the default setting for Physical Ration is in FairCurve_Batten
        Other parameters are initialized as follow :
        - FreeSliding = False
        - ConstraintOrder1 = 1
        - ConstraintOrder2 = 1
        - Angle1 = 0
        - Angle2 = 0
        - Curvature1 = 0
        - Curvature2 = 0
        - SlidingFactor = 1
        Warning
        If PhysicalRatio equals 1, you cannot impose constraints on curvature.
        Exceptions
        NegativeValue if Height is less than or equal to 0.
        NullValue if the distance between P1 and P2 is less
        than or equal to the tolerance value for distance in
        Precision::Confusion: P1.IsEqual(P2,
        Precision::Confusion()). The function
        gp_Pnt2d::IsEqual tests to see if this is the case.
        Definition of the geometricals constraints

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Heigth: float
        :type Slope: float
        :type PhysicalRatio: float

        """
        this = _FairCurve.new_FairCurve_MinimalVariation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurvature1(self, *args):
        """
        SetCurvature1(FairCurve_MinimalVariation self, Standard_Real const Curvature)

        Allows you to set a new constraint on curvature at the first point.

        :type Curvature: float

        """
        return _FairCurve.FairCurve_MinimalVariation_SetCurvature1(self, *args)


    def SetCurvature2(self, *args):
        """
        SetCurvature2(FairCurve_MinimalVariation self, Standard_Real const Curvature)

        Allows you to set a new constraint on curvature at the second point.

        :type Curvature: float

        """
        return _FairCurve.FairCurve_MinimalVariation_SetCurvature2(self, *args)


    def SetPhysicalRatio(self, *args):
        """
        SetPhysicalRatio(FairCurve_MinimalVariation self, Standard_Real const Ratio)

        Allows you to set the physical ratio Ratio.
        The kinds of energy which you can specify include:
        0 is only "Jerk" Energy
        1 is only "Sagging" Energy like batten
        Warning: if Ratio is 1 it is impossible to impose curvature constraints.
        Raises  DomainError if Ratio < 0 or Ratio > 1

        :type Ratio: float

        """
        return _FairCurve.FairCurve_MinimalVariation_SetPhysicalRatio(self, *args)


    def Compute(self, *args):
        """
        Compute(FairCurve_MinimalVariation self, Standard_Integer const NbIterations=50, Standard_Real const Tolerance=1.0e-3) -> Standard_Boolean

        Computes the curve with respect to the constraints,
        NbIterations and Tolerance. The tolerance setting
        allows you to control the precision of computation, and
        the maximum number of iterations allows you to set a limit on computation time.

        :type ACode: OCC.wrapper.FairCurve.FairCurve_AnalysisCode
        :type NbIterations: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _FairCurve.FairCurve_MinimalVariation_Compute(self, *args)


    def GetCurvature1(self, *args):
        """
        GetCurvature1(FairCurve_MinimalVariation self) -> Standard_Real

        Returns the first established curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_MinimalVariation_GetCurvature1(self, *args)


    def GetCurvature2(self, *args):
        """
        GetCurvature2(FairCurve_MinimalVariation self) -> Standard_Real

        Returns the second established curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_MinimalVariation_GetCurvature2(self, *args)


    def GetPhysicalRatio(self, *args):
        """
        GetPhysicalRatio(FairCurve_MinimalVariation self) -> Standard_Real

        Returns the physical ratio, or kind of energy.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _FairCurve.FairCurve_MinimalVariation_GetPhysicalRatio(self, *args)


    def Dump(self, *args):
        """
        Dump(FairCurve_MinimalVariation self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _FairCurve.FairCurve_MinimalVariation_Dump(self, *args)

    __swig_destroy__ = _FairCurve.delete_FairCurve_MinimalVariation
FairCurve_MinimalVariation_swigregister = _FairCurve.FairCurve_MinimalVariation_swigregister
FairCurve_MinimalVariation_swigregister(FairCurve_MinimalVariation)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom')
    _Geom = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom', [dirname(__file__)])
        except ImportError:
            import _Geom
            return _Geom
        try:
            _mod = imp.load_module('_Geom', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom = swig_import_helper()
    del swig_import_helper
else:
    import _Geom
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom.delete_SwigPyIterator

    def value(self):
        return _Geom.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom.SwigPyIterator_copy(self)

    def next(self):
        return _Geom.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom.ptr_to_number(item)
ptr_to_number = _Geom.ptr_to_number

def HashCode(*args):
    return _Geom.HashCode(*args)
HashCode = _Geom.HashCode

def ptr_equal(a, b):
    return _Geom.ptr_equal(a, b)
ptr_equal = _Geom.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class Geom_Geometry(Standard.Standard_Transient):
    """
    The abstract class Geometry for 3D space is the root
    class of all geometric objects from the Geom
    package. It describes the common behavior of these objects when:
    - applying geometric transformations to objects, and
    - constructing objects by geometric transformation (including copying).
    Warning
    Only transformations which do not modify the nature
    of the geometry can be applied to Geom objects: this
    is the case with translations, rotations, symmetries
    and scales; this is also the case with gp_Trsf
    composite transformations which are used to define
    the geometric transformations applied using the
    Transform or Transformed functions.
    Note: Geometry defines the "prototype" of the
    abstract method Transform which is defined for each
    concrete type of derived object. All other
    transformations are implemented using the Transform method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Geometry
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Geometry(self) 
            return h


    def Mirror(self, *args):
        """
        Mirror(Geom_Geometry self, gp_Pnt P)
        Mirror(Geom_Geometry self, gp_Ax1 A1)
        Mirror(Geom_Geometry self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_Geometry_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Geom_Geometry self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Geom_Geometry_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Geom_Geometry self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Geom_Geometry_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Geom_Geometry self, gp_Vec V)
        Translate(Geom_Geometry self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Geometry_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Geometry self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Geometry_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Geom_Geometry self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Geom_Geometry self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Geom_Geometry self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Geom_Geometry self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Geom_Geometry self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Geom_Geometry self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Geom_Geometry self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Geom_Geometry self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Geometry self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Geometry_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Geometry_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Geometry_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Geometry
Geom_Geometry_swigregister = _Geom.Geom_Geometry_swigregister
Geom_Geometry_swigregister(Geom_Geometry)

def Geom_Geometry_get_type_name(*args):
    """
    Geom_Geometry_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Geometry_get_type_name(*args)

def Geom_Geometry_get_type_descriptor(*args):
    """
    Geom_Geometry_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Geometry_get_type_descriptor(*args)

class Geom_Surface(Geom_Geometry):
    """
    Describes the common behavior of surfaces in 3D
    space. The Geom package provides many
    implementations of concrete derived surfaces, such as
    planes, cylinders, cones, spheres and tori, surfaces of
    linear extrusion, surfaces of revolution, Bezier and
    BSpline surfaces, and so on.
    The key characteristic of these surfaces is that they
    are parameterized. Geom_Surface demonstrates:
    - how to work with the parametric equation of a
    surface to compute the point of parameters (u,
    v), and, at this point, the 1st, 2nd ... Nth derivative,
    - how to find global information about a surface in
    each parametric direction (for example, level of
    continuity, whether the surface is closed, its
    periodicity, the bounds of the parameters and so on), and
    - how the parameters change when geometric
    transformations are applied to the surface, or the
    orientation is modified.
    Note that all surfaces must have a geometric
    continuity, and any surface is at least "C0". Generally,
    continuity is checked at construction time or when the
    curve is edited. Where this is not the case, the
    documentation makes this explicit.
    Warning
    The Geom package does not prevent the construction of
    surfaces with null areas, or surfaces which self-intersect.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Surface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Surface(self) 
            return h


    def UReverse(self, *args):
        """
        UReverse(Geom_Surface self)

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Geom_Surface_UReverse(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Geom_Surface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Geom_Surface_UReversed(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_Surface self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)

        is the same point as

        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Surface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_Surface self)

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Geom_Surface_VReverse(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Geom_Surface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Geom_Surface_VReversed(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_Surface self, Standard_Real const V) -> Standard_Real

        Returns the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))

        is the same point as

        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Surface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_Surface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Surface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_Surface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_Surface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_Surface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this surface.
        If the surface is infinite, this function can return a value
        equal to Precision::Infinite: instead of Standard_Real::LastReal.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_Surface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_Surface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the u parametric direction: taking
        uFirst and uLast as the parametric bounds in
        the u parametric direction, for each parameter v, the
        distance between the points P(uFirst, v) and
        P(uLast, v) is less than or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_Surface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the v parametric
        direction: taking vFirst and vLast as the
        parametric bounds in the v parametric direction, for
        each parameter u, the distance between the points
        P(u, vFirst) and P(u, vLast) is less than
        or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_Surface self) -> Standard_Boolean

        Checks if this surface is periodic in the u
        parametric direction. Returns true if:
        - this surface is closed in the u parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the u parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Geom_Surface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Surface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_Surface self) -> Standard_Boolean

        Checks if this surface is periodic in the v
        parametric direction. Returns true if:
        - this surface is closed in the v parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Geom_Surface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Surface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_Surface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_Surface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_Surface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_Surface_VIso(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_Surface self) -> GeomAbs_Shape

        Returns the Global Continuity of the surface in direction U and V :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.
        Example :
        If the surface is C1 in the V parametric direction and C2
        in the U parametric direction Shape = C1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_Surface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_Surface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        U parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_Surface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        V parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Surface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the surface.

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Surface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Surface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Surface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Surface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Surface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        ---Purpose ;
        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        Raised if the continuity of the surface is not CNu in the U
        direction or not CNv in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Surface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Geom_Surface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Surface_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Surface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Surface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Surface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Surface
Geom_Surface_swigregister = _Geom.Geom_Surface_swigregister
Geom_Surface_swigregister(Geom_Surface)

def Geom_Surface_get_type_name(*args):
    """
    Geom_Surface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Surface_get_type_name(*args)

def Geom_Surface_get_type_descriptor(*args):
    """
    Geom_Surface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Surface_get_type_descriptor(*args)

class Geom_AxisPlacement(Geom_Geometry):
    """
    The abstract class AxisPlacement describes the
    common behavior of positioning systems in 3D space,
    such as axis or coordinate systems.
    The Geom package provides two implementations of
    3D positioning systems:
    - the axis (Geom_Axis1Placement class), which is defined by:
    - its origin, also termed the "Location point" of the  axis,
    - its unit vector, termed the "Direction" or "main
    Direction" of the axis;
    - the right-handed coordinate system
    (Geom_Axis2Placement class), which is defined by:
    - its origin, also termed the "Location point" of the coordinate system,
    - three orthogonal unit vectors, termed
    respectively the "X Direction", the "Y Direction"
    and the "Direction" of the coordinate system. As
    the coordinate system is right-handed, these
    unit vectors have the following relation:
    "Direction" = "X Direction" ^
    "Y Direction". The "Direction" is also
    called the "main Direction" because, when the
    unit vector is modified, the "X Direction" and "Y
    Direction" are recomputed, whereas when the "X
    Direction" or "Y Direction" is modified, the "main Direction" does not change.
    The axis whose origin is the origin of the positioning
    system and whose unit vector is its "main Direction" is
    also called the "Axis" or "main Axis" of the positioning system.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_AxisPlacement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_AxisPlacement(self) 
            return h


    def SetAxis(self, *args):
        """
        SetAxis(Geom_AxisPlacement self, gp_Ax1 A1)

        Assigns A1 as the "main Axis" of this positioning system. This modifies
        - its origin, and
        - its "main Direction".
        If this positioning system is a
        Geom_Axis2Placement, then its "X Direction" and
        "Y Direction" are recomputed.
        Exceptions
        For a Geom_Axis2Placement:
        Standard_ConstructionError if A1 and the
        previous "X Direction" of the coordinate system are parallel.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_AxisPlacement_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_AxisPlacement self, gp_Dir V)

        Changes the direction of the axis placement.
        If <me> is an axis placement two axis the main "Direction"
        is modified and the "XDirection" and "YDirection" are
        recomputed.
        Raises ConstructionError only for an axis placement two axis if V and the
        previous "XDirection" are parallel because it is not possible
        to calculate the new "XDirection" and the new "YDirection".

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_AxisPlacement_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom_AxisPlacement self, gp_Pnt P)

        Assigns the point P as the origin of this positioning  system.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_AxisPlacement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Geom_AxisPlacement self, Handle_Geom_AxisPlacement Other) -> Standard_Real

        Computes the angular value, in radians, between the
        "main Direction" of this positioning system and that
        of positioning system Other. The result is a value between 0 and Pi.

        :type Other: OCC.wrapper.Geom.Handle_Geom_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_AxisPlacement_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the axis placement.
        For an "Axis2placement" it is the main axis (Location, Direction ).
        For an "Axis1Placement" this method returns a copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Geom_AxisPlacement_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Direction(Geom_AxisPlacement self) -> gp_Dir

        Returns the main "Direction" of an axis placement.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_AxisPlacement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Geom_AxisPlacement self) -> gp_Pnt

        Returns the Location point (origin) of the axis placement.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_AxisPlacement_Location(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_AxisPlacement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_AxisPlacement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_AxisPlacement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_AxisPlacement
Geom_AxisPlacement_swigregister = _Geom.Geom_AxisPlacement_swigregister
Geom_AxisPlacement_swigregister(Geom_AxisPlacement)

def Geom_AxisPlacement_get_type_name(*args):
    """
    Geom_AxisPlacement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_AxisPlacement_get_type_name(*args)

def Geom_AxisPlacement_get_type_descriptor(*args):
    """
    Geom_AxisPlacement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_AxisPlacement_get_type_descriptor(*args)

class Geom_Curve(Geom_Geometry):
    """
    The abstract class Curve describes the common
    behavior of curves in 3D space. The Geom package
    provides numerous concrete classes of derived
    curves, including lines, circles, conics, Bezier or
    BSpline curves, etc.
    The main characteristic of these curves is that they
    are parameterized. The Geom_Curve class shows:
    - how to work with the parametric equation of a curve
    in order to calculate the point of parameter u,
    together with the vector tangent and the derivative
    vectors of order 2, 3,..., N at this point;
    - how to obtain general information about the curve
    (for example, level of continuity, closed
    characteristics, periodicity, bounds of the parameter field);
    - how the parameter changes when a geometric
    transformation is applied to the curve or when the
    orientation of the curve is inverted.
    All curves must have a geometric continuity: a curve is
    at least "C0". Generally, this property is checked at
    the time of construction or when the curve is edited.
    Where this is not the case, the documentation states so explicitly.
    Warning
    The Geom package does not prevent the
    construction of curves with null length or curves which
    self-intersect.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Curve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Curve(self) 
            return h


    def Reverse(self, *args):
        """
        Reverse(Geom_Curve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom.Geom_Curve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Curve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        me->Reversed()->Value(me->ReversedParameter(U))

        is the same point as

        me->Value(U)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom_Curve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_Curve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom_Curve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_Curve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Curve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Curve self) -> Standard_Real

        Returns the value of the last parameter.
        Warnings :
        It can be RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Curve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Curve self) -> Standard_Boolean

        Is the parametrization of the curve periodic ?
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom_Curve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Curve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_Curve self) -> GeomAbs_Shape

        It is the global continuity of the curve
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_Curve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_Curve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions -  Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Curve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Curve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the curve is not CN.

        Raised if the   derivative  cannot  be  computed
        easily. e.g. rational bspline and n > 3.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Curve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Geom_Curve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Curve_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Curve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Curve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Curve
Geom_Curve_swigregister = _Geom.Geom_Curve_swigregister
Geom_Curve_swigregister(Geom_Curve)

def Geom_Curve_get_type_name(*args):
    """
    Geom_Curve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Curve_get_type_name(*args)

def Geom_Curve_get_type_descriptor(*args):
    """
    Geom_Curve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Curve_get_type_descriptor(*args)

class Geom_BoundedCurve(Geom_Curve):
    """
    The abstract class BoundedCurve describes the
    common behavior of bounded curves in 3D space. A
    bounded curve is limited by two finite values of the
    parameter, termed respectively "first parameter" and
    "last parameter". The "first parameter" gives the "start
    point" of the bounded curve, and the "last parameter"
    gives the "end point" of the bounded curve.
    The length of a bounded curve is finite.
    The Geom package provides three concrete classes of bounded curves:
    - two frequently used mathematical formulations of complex curves:
    - Geom_BezierCurve,
    - Geom_BSplineCurve, and
    - Geom_TrimmedCurve to trim a curve, i.e. to only
    take part of the curve limited by two values of the
    parameter of the basis curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BoundedCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BoundedCurve(self) 
            return h


    def EndPoint(self, *args):
        """
        EndPoint(Geom_BoundedCurve self) -> gp_Pnt

        Returns the end point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BoundedCurve_EndPoint(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Geom_BoundedCurve self) -> gp_Pnt

        Returns the start point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BoundedCurve_StartPoint(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BoundedCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BoundedCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BoundedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BoundedCurve
Geom_BoundedCurve_swigregister = _Geom.Geom_BoundedCurve_swigregister
Geom_BoundedCurve_swigregister(Geom_BoundedCurve)

def Geom_BoundedCurve_get_type_name(*args):
    """
    Geom_BoundedCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BoundedCurve_get_type_name(*args)

def Geom_BoundedCurve_get_type_descriptor(*args):
    """
    Geom_BoundedCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BoundedCurve_get_type_descriptor(*args)

class Geom_BoundedSurface(Geom_Surface):
    """
    The root class for bounded surfaces in 3D space. A
    bounded surface is defined by a rectangle in its 2D parametric space, i.e.
    - its u parameter, which ranges between two finite
    values u0 and u1, referred to as "First u
    parameter" and "Last u parameter" respectively, and
    - its v parameter, which ranges between two finite
    values v0 and v1, referred to as "First v
    parameter" and the "Last v parameter" respectively.
    The surface is limited by four curves which are the
    boundaries of the surface:
    - its u0 and u1 isoparametric curves in the u parametric direction, and
    - its v0 and v1 isoparametric curves in the v parametric direction.
    A bounded surface is finite.
    The common behavior of all bounded surfaces is
    described by the Geom_Surface class.
    The Geom package provides three concrete
    implementations of bounded surfaces:
    - Geom_BezierSurface,
    - Geom_BSplineSurface, and
    - Geom_RectangularTrimmedSurface.
    The first two of these implement well known
    mathematical definitions of complex surfaces, the third
    trims a surface using four isoparametric curves, i.e. it
    limits the variation of its parameters to a rectangle in
    2D parametric space.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BoundedSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BoundedSurface(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BoundedSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BoundedSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BoundedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BoundedSurface
Geom_BoundedSurface_swigregister = _Geom.Geom_BoundedSurface_swigregister
Geom_BoundedSurface_swigregister(Geom_BoundedSurface)

def Geom_BoundedSurface_get_type_name(*args):
    """
    Geom_BoundedSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BoundedSurface_get_type_name(*args)

def Geom_BoundedSurface_get_type_descriptor(*args):
    """
    Geom_BoundedSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BoundedSurface_get_type_descriptor(*args)

class Geom_Vector(Geom_Geometry):
    """
    The abstract class Vector describes the common
    behavior of vectors in 3D space.
    The Geom package provides two concrete classes of
    vectors: Geom_Direction (unit vector) and Geom_VectorWithMagnitude.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Vector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Vector(self) 
            return h


    def Reverse(self, *args):
        """
        Reverse(Geom_Vector self)

        Reverses the vector <me>.


        """
        return _Geom.Geom_Vector_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom_Vector self) -> Handle_Geom_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Vector_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Geom_Vector self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value between 0 and Pi.
        Exceptions
        gp_VectorWithNullMagnitude if:
        - the magnitude of this vector is less than or equal to
        gp::Resolution(), or
        - the magnitude of vector Other is less than or equal
        to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(Geom_Vector self, Handle_Geom_Vector Other, Handle_Geom_Vector VRef) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The vector VRef defines the
        positive sense of rotation: the angular value is positive
        if the cross product this ^ Other has the same
        orientation as VRef (in relation to the plane defined
        by this vector and vector Other). Otherwise, it is negative.
        Exceptions
        Standard_DomainError if this vector, vector Other
        and vector VRef are coplanar, except if this vector
        and vector Other are parallel.
        gp_VectorWithNullMagnitude if the magnitude of
        this vector, vector Other or vector VRef is less than
        or equal to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :type VRef: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_AngleWithRef(self, *args)


    def Coord(self, *args):
        """
        Coord(Geom_Vector self)

        Returns the coordinates X, Y and Z of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_Vector_Coord(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom_Vector self) -> Standard_Real

        Returns the  Magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom_Vector self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_SquareMagnitude(self, *args)


    def X(self, *args):
        """
        X(Geom_Vector self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom_Vector self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_Y(self, *args)


    def Z(self, *args):
        """
        Z(Geom_Vector self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_Z(self, *args)


    def Cross(self, *args):
        """
        Cross(Geom_Vector self, Handle_Geom_Vector Other)

        Computes the cross product between <me> and <Other>.

        Raised if <me> is a "Direction" and if <me> and <Other>
        are parallel because it is not possible to build a
        "Direction" with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Vector_Cross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom_Vector self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product between <me> and <Other>.
        A new direction is returned.

        Raised if <me> is a "Direction" and if the two vectors
        are parallel because it is not possible to create a
        "Direction" with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Vector_Crossed(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^(V1 ^ V2).

        Raised if <me> is a "Direction" and if V1 and V2 are parallel
        or <me> and (V1 ^ V2) are  parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Vector_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product <me> ^(V1 ^ V2).

        Raised if <me> is a direction and if V1 and V2 are
        parallel or <me> and (V1 ^ V2) are parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Vector_CrossCrossed(self, *args)


    def Dot(self, *args):
        """
        Dot(Geom_Vector self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the scalar product of this vector and vector Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_Dot(self, *args)


    def DotCross(self, *args):
        """
        DotCross(Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Standard_Real

        Computes the triple scalar product. Returns me . (V1 ^ V2)

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Vector_DotCross(self, *args)


    def Vec(self, *args):
        """
        Converts this vector into a gp_Vec vector.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Geom.Geom_Vector_Vec(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Vector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Vector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Vector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Vector
Geom_Vector_swigregister = _Geom.Geom_Vector_swigregister
Geom_Vector_swigregister(Geom_Vector)

def Geom_Vector_get_type_name(*args):
    """
    Geom_Vector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Vector_get_type_name(*args)

def Geom_Vector_get_type_descriptor(*args):
    """
    Geom_Vector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Vector_get_type_descriptor(*args)

class Geom_ElementarySurface(Geom_Surface):
    """
    Describes the common behavior of surfaces which
    have a simple parametric equation in a local
    coordinate system. The Geom package provides
    several implementations of concrete elementary surfaces:
    - the plane, and
    - four simple surfaces of revolution: the cylinder, the
    cone, the sphere and the torus.
    An elementary surface inherits the common behavior
    of Geom_Surface surfaces. Furthermore, it is located
    in 3D space by a coordinate system (a gp_Ax3
    object) which is also its local coordinate system.
    Any elementary surface is oriented, i.e. the normal
    vector is always defined, and gives the same
    orientation to the surface, at any point on the surface.
    In topology this property is referred to as the "outside
    region of the surface". This orientation is related to
    the two parametric directions of the surface.
    Rotation of a surface around the "main Axis" of its
    coordinate system, in the trigonometric sense given
    by the "X Direction" and the "Y Direction" of the
    coordinate system, defines the u parametric direction
    of that elementary surface of revolution. This is the
    default construction mode.
    It is also possible, however, to change the orientation
    of a surface by reversing one of the two parametric
    directions: use the UReverse or VReverse functions
    to change the orientation of the normal at any point on the surface.
    Warning
    The local coordinate system of an elementary surface
    is not necessarily direct:
    - if it is direct, the trigonometric sense defined by its
    "main Direction" is the same as the trigonometric
    sense defined by its two vectors "X Direction" and "Y Direction":
    "main Direction" = "X Direction" ^ "Y Direction"
    - if it is indirect, the two definitions of trigonometric
    sense are opposite:
    "main Direction" = - "X Direction" ^ "Y Direction" 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_ElementarySurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_ElementarySurface(self) 
            return h


    def SetAxis(self, *args):
        """
        SetAxis(Geom_ElementarySurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_ElementarySurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom_ElementarySurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_ElementarySurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Geom_ElementarySurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Geom_ElementarySurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Geom_ElementarySurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_ElementarySurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Geom_ElementarySurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_ElementarySurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Geom_ElementarySurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Geom_ElementarySurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Geom_ElementarySurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_ElementarySurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)
        is the same point as
        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ElementarySurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_ElementarySurface self)

        Reverses the V parametric direction of the surface.


        """
        return _Geom.Geom_ElementarySurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_ElementarySurface self, Standard_Real const V) -> Standard_Real

        Return the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))
        is the same point as
        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ElementarySurface_VReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_ElementarySurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_ElementarySurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_ElementarySurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ElementarySurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_ElementarySurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ElementarySurface_IsCNv(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_ElementarySurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_ElementarySurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_ElementarySurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_ElementarySurface
Geom_ElementarySurface_swigregister = _Geom.Geom_ElementarySurface_swigregister
Geom_ElementarySurface_swigregister(Geom_ElementarySurface)

def Geom_ElementarySurface_get_type_name(*args):
    """
    Geom_ElementarySurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_ElementarySurface_get_type_name(*args)

def Geom_ElementarySurface_get_type_descriptor(*args):
    """
    Geom_ElementarySurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_ElementarySurface_get_type_descriptor(*args)

class Geom_SweptSurface(Geom_Surface):
    """
    Describes the common behavior for surfaces
    constructed by sweeping a curve with another curve.
    The Geom package provides two concrete derived
    surfaces: surface of revolution (a revolved surface),
    and surface of linear extrusion (an extruded surface).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_SweptSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_SweptSurface(self) 
            return h


    def Continuity(self, *args):
        """
        Continuity(Geom_SweptSurface self) -> GeomAbs_Shape

        returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_SweptSurface_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference direction of the swept surface.
        For a surface of revolution it is the direction of the
        revolution axis, for a surface of linear extrusion it is
        the direction of extrusion.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Geom_SweptSurface_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisCurve(self, *args):
        """
        BasisCurve(Geom_SweptSurface self) -> Handle_Geom_Curve

        Returns the referenced curve of the surface.
        For a surface of revolution it is the revolution curve,
        for a surface of linear extrusion it is the extruded curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SweptSurface_BasisCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_SweptSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_SweptSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_SweptSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_SweptSurface
Geom_SweptSurface_swigregister = _Geom.Geom_SweptSurface_swigregister
Geom_SweptSurface_swigregister(Geom_SweptSurface)

def Geom_SweptSurface_get_type_name(*args):
    """
    Geom_SweptSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_SweptSurface_get_type_name(*args)

def Geom_SweptSurface_get_type_descriptor(*args):
    """
    Geom_SweptSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_SweptSurface_get_type_descriptor(*args)

class Geom_Conic(Geom_Curve):
    """
    The abstract class Conic describes the common
    behavior of conic curves in 3D space and, in
    particular, their general characteristics. The Geom
    package provides four concrete classes of conics:
    Geom_Circle, Geom_Ellipse, Geom_Hyperbola and Geom_Parabola.
    A conic is positioned in space with a right-handed
    coordinate system (gp_Ax2 object), where:
    - the origin is the center of the conic (or the apex in
    the case of a parabola),
    - the origin, "X Direction" and "Y Direction" define the
    plane of the conic.
    This coordinate system is the local coordinate
    system of the conic.
    The "main Direction" of this coordinate system is the
    vector normal to the plane of the conic. The axis, of
    which the origin and unit vector are respectively the
    origin and "main Direction" of the local coordinate
    system, is termed the "Axis" or "main Axis" of the conic.
    The "main Direction" of the local coordinate system
    gives an explicit orientation to the conic, determining
    the direction in which the parameter increases along
    the conic. The "X Axis" of the local coordinate system
    also defines the origin of the parameter of the conic.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Conic
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Conic(self) 
            return h


    def SetAxis(self, *args):
        """
        SetAxis(Geom_Conic self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Conic_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom_Conic self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Conic_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Geom_Conic self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_Conic_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Geom_Conic self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Conic_Axis(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom_Conic self) -> Standard_Real

        Returns the eccentricity value of the conic e.
        e = 0 for a circle
        0 < e < 1 for an ellipse  (e = 0 if MajorRadius = MinorRadius)
        e > 1 for a hyperbola
        e = 1 for a parabola
        Exceptions
        Standard_DomainError in the case of a hyperbola if
        its major radius is null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Conic_Eccentricity(self, *args)


    def Location(self, *args):
        """
        Location(Geom_Conic self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Conic_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Geom_Conic_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Geom_Conic self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Conic_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Geom_Conic self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Conic_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom_Conic self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Geom_Conic_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Conic self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Conic_ReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_Conic self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_Conic_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_Conic self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Conic_IsCN(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Conic_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Conic_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Conic_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Conic
Geom_Conic_swigregister = _Geom.Geom_Conic_swigregister
Geom_Conic_swigregister(Geom_Conic)

def Geom_Conic_get_type_name(*args):
    """
    Geom_Conic_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Conic_get_type_name(*args)

def Geom_Conic_get_type_descriptor(*args):
    """
    Geom_Conic_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Conic_get_type_descriptor(*args)

class Geom_Axis1Placement(Geom_AxisPlacement):
    """
    Describes an axis in 3D space.
    An axis is defined by:
    - its origin, also termed the "Location point" of the axis,
    - its unit vector, termed the "Direction" of the axis.
    Note: Geom_Axis1Placement axes provide the
    same kind of "geometric" services as gp_Ax1 axes
    but have more complex data structures. The
    geometric objects provided by the Geom package
    use gp_Ax1 objects to include axes in their data
    structures, or to define an axis of symmetry or axis of rotation.
    Geom_Axis1Placement axes are used in a context
    where they can be shared by several objects
    contained inside a common data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Axis1Placement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Axis1Placement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Axis1Placement self, gp_Ax1 A1) -> Geom_Axis1Placement
        __init__(Geom_Axis1Placement self, gp_Pnt P, gp_Dir V) -> Geom_Axis1Placement

        P is the origin of the axis placement and V is the direction
        of the axis placement.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _Geom.new_Geom_Axis1Placement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Ax1(self, *args):
        """
        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Geom_Axis1Placement_Ax1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Geom_Axis1Placement self)

        Reverses the direction of the axis placement.


        """
        return _Geom.Geom_Axis1Placement_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Geom_Axis1Placement self) -> Handle_Geom_Axis1Placement

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis1Placement

        """
        return _Geom.Geom_Axis1Placement_Reversed(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_Axis1Placement self, gp_Dir V)

        Assigns V to the unit vector of this axis.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Axis1Placement_SetDirection(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Axis1Placement self, gp_Trsf T)

        Applies the transformation T to this axis.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Axis1Placement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Axis1Placement self) -> Handle_Geom_Geometry

        Creates a new object, which is a copy of this axis.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Axis1Placement_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Axis1Placement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Axis1Placement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Axis1Placement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Axis1Placement
Geom_Axis1Placement_swigregister = _Geom.Geom_Axis1Placement_swigregister
Geom_Axis1Placement_swigregister(Geom_Axis1Placement)

def Geom_Axis1Placement_get_type_name(*args):
    """
    Geom_Axis1Placement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Axis1Placement_get_type_name(*args)

def Geom_Axis1Placement_get_type_descriptor(*args):
    """
    Geom_Axis1Placement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Axis1Placement_get_type_descriptor(*args)

class Geom_TrimmedCurve(Geom_BoundedCurve):
    """
    Describes a portion of a curve (termed the "basis
    curve") limited by two parameter values inside the
    parametric domain of the basis curve.
    The trimmed curve is defined by:
    - the basis curve, and
    - the two parameter values which limit it.
    The trimmed curve can either have the same
    orientation as the basis curve or the opposite orientation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_TrimmedCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_TrimmedCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_TrimmedCurve self, Handle_Geom_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic) -> Geom_TrimmedCurve

        Constructs a trimmed curve from the basis curve C
        which is limited between parameter values U1 and U2.
        Note: - U1 can be greater or less than U2; in both cases,
        the returned curve is oriented from U1 to U2.
        - If the basis curve C is periodic, there is an
        ambiguity because two parts are available. In this
        case, the trimmed curve has the same orientation
        as the basis curve if Sense is true (default value)
        or the opposite orientation if Sense is false.
        - If the curve is closed but not periodic, it is not
        possible to keep the part of the curve which
        includes the junction point (except if the junction
        point is at the beginning or at the end of the
        trimmed curve). If you tried to do this, you could
        alter the fundamental characteristics of the basis
        curve, which are used, for example, to compute
        the derivatives of the trimmed curve. The rules
        for a closed curve are therefore the same as
        those for an open curve.
        Warning: The trimmed curve is built from a copy of curve C.
        Therefore, when C is modified, the trimmed curve
        is not modified.
        - If the basis curve is periodic and theAdjustPeriodic is True,
        the bounds of the trimmed curve may be different from U1 and U2
        if the parametric origin of the basis curve is within
        the arc of the trimmed curve. In this case, the
        modified parameter will be equal to U1 or U2
        plus or minus the period.
        When theAdjustPeriodic is False, parameters U1 and U2 will be
        the same, without adjustment into the first period.
        Exceptions
        Standard_ConstructionError if:
        - C is not periodic and U1 or U2 is outside the
        bounds of C, or
        - U1 is equal to U2.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        this = _Geom.new_Geom_TrimmedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(Geom_TrimmedCurve self)

        Changes the orientation of this trimmed curve.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the
        end point of the reversed curve,
        - the end point of the initial curve becomes the
        start point of the reversed curve,
        - the first and last parameters are recomputed.
        If the trimmed curve was defined by:
        - a basis curve whose parameter range is [ 0., 1. ],
        - the two trim values U1 (first parameter) and U2 (last parameter),
        the reversed trimmed curve is defined by:
        - the reversed basis curve, whose parameter range is still [ 0., 1. ],
        - the two trim values 1. - U2 (first parameter) and 1. - U1 (last parameter).


        """
        return _Geom.Geom_TrimmedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_TrimmedCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this trimmed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_ReversedParameter(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Geom_TrimmedCurve self, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic)

        Changes this trimmed curve, by redefining the
        parameter values U1 and U2 which limit its basis curve.
        Note: If the basis curve is periodic, the trimmed curve
        has the same orientation as the basis curve if Sense
        is true (default value) or the opposite orientation if Sense is false.
        Warning
        If the basis curve is periodic and theAdjustPeriodic is True,
        the bounds of the trimmed curve may be different from U1 and U2 if the
        parametric origin of the basis curve is within the arc of
        the trimmed curve. In this case, the modified
        parameter will be equal to U1 or U2 plus or minus the period.
        When theAdjustPeriodic is False, parameters U1 and U2 will be
        the same, without adjustment into the first period.
        Exceptions
        Standard_ConstructionError if:
        - the basis curve is not periodic, and either U1 or U2
        are outside the bounds of the basis curve, or
        - U1 is equal to U2.

        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        return _Geom.Geom_TrimmedCurve_SetTrim(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Geom_TrimmedCurve self) -> Handle_Geom_Curve

        Returns the basis curve.
        Warning
        This function does not return a constant reference.
        Consequently, any modification of the returned value
        directly modifies the trimmed curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_TrimmedCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_TrimmedCurve self) -> GeomAbs_Shape

        Returns the continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_TrimmedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_TrimmedCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of the basis
        curve of this trimmed curve is at least N. A trimmed
        curve is at least "C0" continuous.
        Warnings :
        The continuity of the trimmed curve can be greater than
        the continuity of the basis curve because you consider
        only a part of the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_TrimmedCurve_IsCN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom_TrimmedCurve self) -> gp_Pnt

        Returns the end point of <me>. This point is the
        evaluation of the curve for the "LastParameter".

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_TrimmedCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_TrimmedCurve self) -> Standard_Real

        Returns the value of the first parameter of <me>.
        The first parameter is the parameter of the "StartPoint"
        of the trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_FirstParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_TrimmedCurve self) -> Standard_Boolean

        Returns True if the distance between the StartPoint and
        the EndPoint is lower or equal to Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_TrimmedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_TrimmedCurve self) -> Standard_Boolean

        Always returns FALSE (independently of the type of basis curve).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_TrimmedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom_TrimmedCurve self) -> Standard_Real

        Returns the period of the basis curve of this trimmed curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_Period(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_TrimmedCurve self) -> Standard_Real

        Returns the value of the last parameter of <me>.
        The last parameter is the parameter of the "EndPoint" of the
        trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_LastParameter(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Geom_TrimmedCurve self) -> gp_Pnt

        Returns the start point of <me>.
        This point is the evaluation of the curve from the
        "FirstParameter".
        value and derivatives
        Warnings :
        The returned derivatives have the same orientation as the
        derivatives of the basis curve even if the trimmed curve
        has not the same orientation as the basis curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_TrimmedCurve_StartPoint(self, *args)


    def D0(self, *args):
        """
        D0(Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.

        If the basis curve is an OffsetCurve sometimes it is not
        possible to do the evaluation of the curve at the parameter
        U (see class OffsetCurve).

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_TrimmedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_TrimmedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_TrimmedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_TrimmedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_TrimmedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        N is the order of derivation.
        Raised if the continuity of the curve is not CN.
        Raised if N < 1.
        geometric transformations

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_TrimmedCurve_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_TrimmedCurve self, gp_Trsf T)

        Applies the transformation T to this trimmed curve.
        Warning The basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_TrimmedCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom_TrimmedCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_TrimmedCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_TrimmedCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_TrimmedCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this trimmed curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_TrimmedCurve_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_TrimmedCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_TrimmedCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_TrimmedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_TrimmedCurve
Geom_TrimmedCurve_swigregister = _Geom.Geom_TrimmedCurve_swigregister
Geom_TrimmedCurve_swigregister(Geom_TrimmedCurve)

def Geom_TrimmedCurve_get_type_name(*args):
    """
    Geom_TrimmedCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_TrimmedCurve_get_type_name(*args)

def Geom_TrimmedCurve_get_type_descriptor(*args):
    """
    Geom_TrimmedCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_TrimmedCurve_get_type_descriptor(*args)

class Geom_BSplineCurve(Geom_BoundedCurve):
    """
    Definition of the B_spline curve.
    A B-spline curve can be
    Uniform  or non-uniform
    Rational or non-rational
    Periodic or non-periodic

    a b-spline curve is defined by :
    its degree; the degree for a
    Geom_BSplineCurve is limited to a value (25)
    which is defined and controlled by the system.
    This value is returned by the function MaxDegree;
    - its periodic or non-periodic nature;
    - a table of poles (also called control points), with
    their associated weights if the BSpline curve is
    rational. The poles of the curve are "control
    points" used to deform the curve. If the curve is
    non-periodic, the first pole is the start point of
    the curve, and the last pole is the end point of
    the curve. The segment which joins the first pole
    to the second pole is the tangent to the curve at
    its start point, and the segment which joins the
    last pole to the second-from-last pole is the
    tangent to the curve at its end point. If the curve
    is periodic, these geometric properties are not
    verified. It is more difficult to give a geometric
    signification to the weights but are useful for
    providing exact representations of the arcs of a
    circle or ellipse. Moreover, if the weights of all the
    poles are equal, the curve has a polynomial
    equation; it is therefore a non-rational curve.
    - a table of knots with their multiplicities. For a
    Geom_BSplineCurve, the table of knots is an
    increasing sequence of reals without repetition;
    the multiplicities define the repetition of the knots.
    A BSpline curve is a piecewise polynomial or
    rational curve. The knots are the parameters of
    junction points between two pieces. The
    multiplicity Mult(i) of the knot Knot(i) of
    the BSpline curve is related to the degree of
    continuity of the curve at the knot Knot(i),
    which is equal to Degree - Mult(i)
    where Degree is the degree of the BSpline curve.
    If the knots are regularly spaced (i.e. the difference
    between two consecutive knots is a constant), three
    specific and frequently used cases of knot
    distribution can be identified:
    - "uniform" if all multiplicities are equal to 1,
    - "quasi-uniform" if all multiplicities are equal to 1,
    except the first and the last knot which have a
    multiplicity of Degree + 1, where Degree is
    the degree of the BSpline curve,
    - "Piecewise Bezier" if all multiplicities are equal to
    Degree except the first and last knot which
    have a multiplicity of Degree + 1, where
    Degree is the degree of the BSpline curve. A
    curve of this type is a concatenation of arcs of Bezier curves.
    If the BSpline curve is not periodic:
    - the bounds of the Poles and Weights tables are 1
    and NbPoles, where NbPoles is the number
    of poles of the BSpline curve,
    - the bounds of the Knots and Multiplicities tables
    are 1 and NbKnots, where NbKnots is the
    number of knots of the BSpline curve.
    If the BSpline curve is periodic, and if there are k
    periodic knots and p periodic poles, the period is:
    period = Knot(k + 1) - Knot(1)
    and the poles and knots tables can be considered
    as infinite tables, verifying:
    - Knot(i+k) = Knot(i) + period
    - Pole(i+p) = Pole(i)
    Note: data structures of a periodic BSpline curve
    are more complex than those of a non-periodic one.
    Warning
    In this class, weight value is considered to be zero if
    the weight is less than or equal to gp::Resolution().

    References :
    . A survey of curve and surface methods in CADG Wolfgang BOHM
    CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BSplineCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BSplineCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_BSplineCurve self, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Geom_BSplineCurve
        __init__(Geom_BSplineCurve self, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic, Standard_Boolean const CheckRational) -> Geom_BSplineCurve

        Creates  a rational B_spline  curve  on the basis
        <Knots, Multiplicities> of degree <Degree>.
        Raises ConstructionError subject to the following conditions
        0 < Degree <= MaxDegree.

        Weights.Length() == Poles.Length()

        Knots.Length() == Mults.Length() >= 2

        Knots(i) < Knots(i+1) (Knots are increasing)

        1 <= Mults(i) <= Degree

        On a non periodic curve the first and last multiplicities
        may be Degree+1 (this is even recommanded if you want the
        curve to start and finish on the first and last pole).

        On a periodic  curve the first  and  the last multicities
        must be the same.

        on non-periodic curves

        Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2

        on periodic curves

        Poles.Length() == Sum(Mults(i)) except the first or last

        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Multiplicities: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool
        :type CheckRational: bool

        """
        this = _Geom.new_Geom_BSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Geom_BSplineCurve self, Standard_Integer const Degree)

        Increases the degree of this BSpline curve to
        Degree. As a result, the poles, weights and
        multiplicities tables are modified; the knots table is
        not changed. Nothing is done if Degree is less than
        or equal to the current degree.
        Exceptions
        Standard_ConstructionError if Degree is greater than
        Geom_BSplineCurve::MaxDegree().

        :type Degree: int

        """
        return _Geom.Geom_BSplineCurve_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Geom_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Geom_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom.Geom_BSplineCurve_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Geom_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increment  the  multiplicities   of  the knots  in
        [I1,I2] by <M>.

        If <M> is not positive nithing is done.

        For   each  knot   the resulting   multiplicity  is
        limited to the Degree.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom.Geom_BSplineCurve_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineCurve_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Geom_BSplineCurve self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a set of knots  values in  the sequence of
        knots.

        For each U = Knots(i), M = Mults(i)

        If <U>  is an existing  knot  the  multiplicity is
        increased by  <M> if  <Add>  is True, increased to
        <M> if <Add> is False.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineCurve_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Geom_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces the multiplicity of the knot of index Index
        to M. If M is equal to 0, the knot is removed.
        With a modification of this type, the array of poles is also modified.
        Two different algorithms are systematically used to
        compute the new poles of the curve. If, for each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is less than
        Tolerance, this ensures that the curve is not
        modified by more than Tolerance. Under these
        conditions, true is returned; otherwise, false is returned.
        A low tolerance is used to prevent modification of
        the curve. A high tolerance is used to "smooth" the curve.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table.
        pole insertion and pole removing
        this operation is limited to the Uniform or QuasiUniform
        BSplineCurve. The knot values are modified . If the BSpline is
        NonUniform or Piecewise Bezier an exception Construction error
        is raised.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_RemoveKnot(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom_BSplineCurve self)

        Changes the direction of parametrization of <me>. The Knot
        sequence is modified, the FirstParameter and the
        LastParameter are not modified. The StartPoint of the
        initial curve becomes the EndPoint of the reversed curve
        and the EndPoint of the initial curve becomes the StartPoint
        of the reversed curve.


        """
        return _Geom.Geom_BSplineCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_BSplineCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom_BSplineCurve self, Standard_Real const U1, Standard_Real const U2)

        Modifies this BSpline curve by segmenting it between
        U1 and U2. Either of these values can be outside the
        bounds of the curve, but U2 must be greater than U1.
        All data structure tables of this BSpline curve are
        modified, but the knots located between U1 and U2
        are retained. The degree of the curve is not modified.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        raises if U2 < U1.
        Standard_DomainError if U2 - U1 exceeds the period for periodic curves.
        i.e. ((U2 - U1) - Period) > Precision::PConfusion().

        :type U1: float
        :type U2: float

        """
        return _Geom.Geom_BSplineCurve_Segment(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Geom_BSplineCurve self, NCollection_Array1_Standard_Real K)

        Modifies this BSpline curve by assigning the array
        K to its knots table. The multiplicity of the knots is not modified.
        Exceptions
        Standard_ConstructionError if the values in the
        array K are not in ascending order.
        Standard_OutOfRange if the bounds of the array
        K are not respectively 1 and the number of knots of this BSpline curve.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineCurve_SetKnots(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Changes the knot of range Index with its multiplicity.
        You can increase the multiplicity of a knot but it is
        not allowed to decrease the multiplicity of an existing knot.

        Raised if K >= Knots(Index+1) or K <= Knots(Index-1).
        Raised if M is greater than Degree or lower than the previous
        multiplicity of knot of range Index.
        Raised if Index < 1 || Index > NbKnots

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Geom.Geom_BSplineCurve_SetKnot(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Geom_BSplineCurve self)

        returns the parameter normalized within
        the period if the curve is periodic : otherwise
        does not do anything

        :type U: float

        """
        return _Geom.Geom_BSplineCurve_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Geom_BSplineCurve self)

        Changes this BSpline curve into a periodic curve.
        To become periodic, the curve must first be closed.
        Next, the knot sequence must be periodic. For this,
        FirstUKnotIndex and LastUKnotIndex are used
        to compute I1 and I2, the indexes in the knots
        array of the knots corresponding to the first and
        last parameters of this BSpline curve.
        The period is therefore: Knots(I2) - Knots(I1).
        Consequently, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if this BSpline curve is not closed.


        """
        return _Geom.Geom_BSplineCurve_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Geom_BSplineCurve self, Standard_Integer const Index)
        SetOrigin(Geom_BSplineCurve self, Standard_Real const U, Standard_Real const Tol)

        Set the origin of a periodic curve at Knot U. If U
        is  not a  knot  of  the  BSpline  a  new knot  is
        inseted. KnotVector and poles are modified.
        Raised if the curve is not periodic

        :type U: float
        :type Tol: float

        """
        return _Geom.Geom_BSplineCurve_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Geom_BSplineCurve self)

        Changes this BSpline curve into a non-periodic
        curve. If this curve is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.
        Warning
        If this curve is periodic, as the multiplicity of the first
        and last knots is not modified, and is not equal to
        Degree + 1, where Degree is the degree of
        this BSpline curve, the start and end points of the
        curve are not its first and last poles.


        """
        return _Geom.Geom_BSplineCurve_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom_BSplineCurve self, Standard_Integer const Index, gp_Pnt P)
        SetPole(Geom_BSplineCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Modifies this BSpline curve by assigning P to the pole
        of index Index in the poles table.
        This syntax also allows you to modify the
        weight of the modified pole, which becomes Weight.
        In this case, if this BSpline curve is non-rational, it
        can become rational and vice versa.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BSplineCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight for the pole of range Index.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type Weight: float

        """
        return _Geom.Geom_BSplineCurve_SetWeight(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, Standard_Integer const Index1, Standard_Integer const Index2)

        Moves the point of parameter U of this BSpline curve
        to P. Index1 and Index2 are the indexes in the table
        of poles of this BSpline curve of the first and last
        poles designated to be moved.
        FirstModifiedPole and LastModifiedPole are the
        indexes of the first and last poles which are effectively modified.
        In the event of incompatibility between Index1, Index2 and the value U:
        - no change is made to this BSpline curve, and
        - the FirstModifiedPole and LastModifiedPole are returned null.
        Exceptions
        Standard_OutOfRange if:
        - Index1 is greater than or equal to Index2, or
        - Index1 or Index2 is less than 1 or greater than the
        number of poles of this BSpline curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Index1: int
        :type Index2: int
        :type FirstModifiedPole: int
        :type LastModifiedPole: int

        """
        return _Geom.Geom_BSplineCurve_MovePoint(self, *args)


    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec Tangent, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Move a point with parameter U to P.
        and makes it tangent at U be Tangent.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Geom.Geom_BSplineCurve_MovePointAndTangent(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_BSplineCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns the continuity of the curve, the curve is at least C0.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsCN(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Geom_BSplineCurve self, Standard_Real const theTf, Standard_Real const theTl, Standard_Real const theAngTol) -> Standard_Boolean

        Check if curve has at least G1 continuity in interval [theTf, theTl]
        Returns true if IsCN(1)
        or
        angle betweem "left" and "right" first derivatives at
        knots with C0 continuity is less then theAngTol
        only knots in interval [theTf, theTl] is checked

        :type theTf: float
        :type theTl: float
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsG1(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_BSplineCurve self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_BSplineCurve self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Geom_BSplineCurve self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_BSplineCurve self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_BSplineCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Geom_BSplineCurve self) -> Standard_Integer

        Returns the degree of this BSpline curve.
        The degree of a Geom_BSplineCurve curve cannot
        be greater than Geom_BSplineCurve::MaxDegree().
        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this BSpline curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        On a point where the continuity of the curve is not the
        one requested, this function impacts the part defined
        by the parameter with a value greater than U, i.e. the
        part of the curve to the "right" of the singularity.
        Exceptions
        Standard_RangeError if N is less than 1.

        The following functions compute the point of parameter U
        and the derivatives at this point on the B-spline curve
        arc defined between the knot FromK1 and the knot ToK2.
        U can be out of bounds [Knot (FromK1),  Knot (ToK2)] but
        for the computation we only use the definition of the curve
        between these two knots. This method is useful to compute
        local derivative, if the order of continuity of the whole
        curve is not greater enough.    Inside the parametric
        domain Knot (FromK1), Knot (ToK2) the evaluations are
        the same as if we consider the whole definition of the
        curve. Of course the evaluations are different outside
        this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> gp_Pnt

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineCurve_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P)

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineCurve_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1)

        Raised if the local continuity of the curve is not C1
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the local continuity of the curve is not C2
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the local continuity of the curve is not C3
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> gp_Vec

        Raised if the local continuity of the curve is not CN
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.
        Raised if N < 1.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineCurve_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom_BSplineCurve self) -> gp_Pnt

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineCurve_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Geom_BSplineCurve self) -> Standard_Integer

        Returns the index in the knot array of the knot
        corresponding to the first or last parameter of this BSpline curve.
        For a BSpline curve, the first (or last) parameter
        (which gives the start (or end) point of the curve) is a
        knot value. However, if the multiplicity of the first (or
        last) knot is less than Degree + 1, where
        Degree is the degree of the curve, it is not the first
        (or last) knot of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_BSplineCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        BSpline curve. This is a knot value.
        The first parameter is the one of the start point of the BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineCurve_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineCurve_Knot(self, *args)


    def Knots(self, *args):
        """
        returns the knot values of the B-spline curve;
        Warning
        A knot with a multiplicity greater than 1 is not
        repeated in the knot table. The Multiplicity function
        can be used to obtain the multiplicity of each knot.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineCurve_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotSequence(self, *args):
        """
        returns the knots of the B-spline curve.
        Knots with multiplicit greater than 1 are repeated

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineCurve_KnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotDistribution(self, *args):
        """
        KnotDistribution(Geom_BSplineCurve self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Geom_BSplineCurve_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Geom_BSplineCurve self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineCurve_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Geom_BSplineCurve self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Geom_BSplineCurve_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        returns the multiplicity of the knots of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Geom_BSplineCurve_Multiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbKnots(self, *args):
        """
        NbKnots(Geom_BSplineCurve self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Geom_BSplineCurve self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Geom_BSplineCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline curve;

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Geom.Geom_BSplineCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Geom_BSplineCurve self) -> gp_Pnt

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom_BSplineCurve self, NCollection_Array1_Standard_Real W)
        Weights(Geom_BSplineCurve self) -> NCollection_Array1_Standard_Real

        Returns the weights of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_BSplineCurve self, gp_Trsf T)

        Applies the transformation T to this BSpline curve.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_BSplineCurve_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineCurve_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom_BSplineCurve self, Standard_Real const Tolerance3D)

        Computes for this BSpline curve the parametric
        tolerance UTolerance for a given 3D tolerance Tolerance3D.
        If f(t) is the equation of this BSpline curve,
        UTolerance ensures that:
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Geom.Geom_BSplineCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_BSplineCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this BSpline curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_BSplineCurve_Copy(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Geom_BSplineCurve self, Handle_Geom_BSplineCurve theOther, Standard_Real const thePreci) -> Standard_Boolean

        Comapare two Bspline curve on identity;

        :type theOther: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type thePreci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineCurve_IsEqual(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BSplineCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BSplineCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BSplineCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BSplineCurve
Geom_BSplineCurve_swigregister = _Geom.Geom_BSplineCurve_swigregister
Geom_BSplineCurve_swigregister(Geom_BSplineCurve)

def Geom_BSplineCurve_MaxDegree(*args):
    """
    Geom_BSplineCurve_MaxDegree() -> Standard_Integer

    Returns the value of the maximum degree of the normalized
    B-spline basis functions in this package.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom.Geom_BSplineCurve_MaxDegree(*args)

def Geom_BSplineCurve_get_type_name(*args):
    """
    Geom_BSplineCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BSplineCurve_get_type_name(*args)

def Geom_BSplineCurve_get_type_descriptor(*args):
    """
    Geom_BSplineCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BSplineCurve_get_type_descriptor(*args)

class Geom_Axis2Placement(Geom_AxisPlacement):
    """
    Describes a right-handed coordinate system in 3D space.
    A coordinate system is defined by:
    - its origin, also termed the "Location point" of the coordinate system,
    - three orthogonal unit vectors, termed respectively
    the "X Direction", "Y Direction" and "Direction" (or
    "main Direction") of the coordinate system.
    As a Geom_Axis2Placement coordinate system is
    right-handed, its "Direction" is always equal to the
    cross product of its "X Direction" and "Y Direction".
    The "Direction" of a coordinate system is called the
    "main Direction" because when this unit vector is
    modified, the "X Direction" and "Y Direction" are
    recomputed, whereas when the "X Direction" or "Y
    Direction" is changed, the "main Direction" is
    retained. The "main Direction" is also the "Z Direction".
    Note: Geom_Axis2Placement coordinate systems
    provide the same kind of "geometric" services as
    gp_Ax2 coordinate systems but have more complex
    data structures. The geometric objects provided by
    the Geom package use gp_Ax2 objects to include
    coordinate systems in their data structures, or to
    define the geometric transformations, which are applied to them.
    Geom_Axis2Placement coordinate systems are
    used in a context where they can be shared by
    several objects contained inside a common data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Axis2Placement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Axis2Placement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Axis2Placement self, gp_Ax2 A2) -> Geom_Axis2Placement
        __init__(Geom_Axis2Placement self, gp_Pnt P, gp_Dir N, gp_Dir Vx) -> Geom_Axis2Placement

        P is the origin of the axis placement, N is the main
        direction of the axis placement and Vx is the "XDirection".
        If the two directions N and Vx are not orthogonal the
        "XDirection" is computed as follow :
        XDirection = N ^ (Vx ^ N).
        Raised if N and Vx are parallel.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type N: OCC.wrapper.gp.gp_Dir
        :type Vx: OCC.wrapper.gp.gp_Dir

        """
        this = _Geom.new_Geom_Axis2Placement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetAx2(self, *args):
        """
        SetAx2(Geom_Axis2Placement self, gp_Ax2 A2)

        Assigns the origin and the three unit vectors of A2 to
        this coordinate system.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_Axis2Placement_SetAx2(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_Axis2Placement self, gp_Dir V)

        Changes the main direction of the axis placement.
        The "Xdirection" is modified :
        New XDirection = V ^ (Previous_Xdirection ^ V).

        Raised if V and the previous "XDirection" are parallel
        because it is impossible to calculate the new "XDirection"
        and the new "YDirection".

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Axis2Placement_SetDirection(self, *args)


    def SetXDirection(self, *args):
        """
        SetXDirection(Geom_Axis2Placement self, gp_Dir Vx)

        Changes the "XDirection" of the axis placement, Vx is the
        new "XDirection". If Vx is not normal to the main direction
        then "XDirection" is computed as follow :
        XDirection = Direction ^ ( Vx ^ Direction).
        The main direction is not modified.
        Raised if Vx and "Direction"  are parallel.

        :type Vx: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Axis2Placement_SetXDirection(self, *args)


    def SetYDirection(self, *args):
        """
        SetYDirection(Geom_Axis2Placement self, gp_Dir Vy)

        Changes the "YDirection" of the axis placement, Vy is the
        new "YDirection". If Vy is not normal to the main direction
        then "YDirection" is computed as follow :
        YDirection = Direction ^ ( Vy ^ Direction).
        The main direction is not modified. The "XDirection" is
        modified.
        Raised if Vy and the main direction are parallel.

        :type Vy: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Axis2Placement_SetYDirection(self, *args)


    def Ax2(self, *args):
        """
        Ax2(Geom_Axis2Placement self) -> gp_Ax2

        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_Axis2Placement_Ax2(self, *args)


    def XDirection(self, *args):
        """
        Returns the "XDirection". This is a unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Geom_Axis2Placement_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the "YDirection". This is a unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Geom_Axis2Placement_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transform(self, *args):
        """
        Transform(Geom_Axis2Placement self, gp_Trsf T)

        Transforms an axis placement with a Trsf.
        The "Location" point, the "XDirection" and the
        "YDirection" are transformed with T.  The resulting
        main "Direction" of <me> is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Axis2Placement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Axis2Placement self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this coordinate system.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Axis2Placement_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Axis2Placement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Axis2Placement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Axis2Placement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Axis2Placement
Geom_Axis2Placement_swigregister = _Geom.Geom_Axis2Placement_swigregister
Geom_Axis2Placement_swigregister(Geom_Axis2Placement)

def Geom_Axis2Placement_get_type_name(*args):
    """
    Geom_Axis2Placement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Axis2Placement_get_type_name(*args)

def Geom_Axis2Placement_get_type_descriptor(*args):
    """
    Geom_Axis2Placement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Axis2Placement_get_type_descriptor(*args)

class Geom_UndefinedDerivative(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_UndefinedDerivative
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_UndefinedDerivative(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_UndefinedDerivative self) -> Geom_UndefinedDerivative
        __init__(Geom_UndefinedDerivative self, Standard_CString const theMessage) -> Geom_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Geom.new_Geom_UndefinedDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Geom_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedDerivative

        """
        return _Geom.Geom_UndefinedDerivative_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_UndefinedDerivative_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_UndefinedDerivative_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_UndefinedDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_UndefinedDerivative
Geom_UndefinedDerivative_swigregister = _Geom.Geom_UndefinedDerivative_swigregister
Geom_UndefinedDerivative_swigregister(Geom_UndefinedDerivative)

def Geom_UndefinedDerivative_NewInstance(*args):
    """
    Geom_UndefinedDerivative_NewInstance(Standard_CString const theMessage) -> Handle_Geom_UndefinedDerivative

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedDerivative

    """
    return _Geom.Geom_UndefinedDerivative_NewInstance(*args)

def Geom_UndefinedDerivative_get_type_name(*args):
    """
    Geom_UndefinedDerivative_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_UndefinedDerivative_get_type_name(*args)

def Geom_UndefinedDerivative_get_type_descriptor(*args):
    """
    Geom_UndefinedDerivative_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_UndefinedDerivative_get_type_descriptor(*args)

class Geom_BezierSurface(Geom_BoundedSurface):
    """
    Describes a rational or non-rational Bezier surface.
    - A non-rational Bezier surface is defined by a table
    of poles (also known as control points).
    - A rational Bezier surface is defined by a table of
    poles with varying associated weights.
    This data is manipulated using two associative 2D arrays:
    - the poles table, which is a 2D array of gp_Pnt, and
    - the weights table, which is a 2D array of reals.
    The bounds of these arrays are:
    - 1 and NbUPoles for the row bounds, where
    NbUPoles is the number of poles of the surface
    in the u parametric direction, and
    - 1 and NbVPoles for the column bounds, where
    NbVPoles is the number of poles of the surface
    in the v parametric direction.
    The poles of the surface, the "control points", are the
    points used to shape and reshape the surface. They
    comprise a rectangular network of points:
    - The points (1, 1), (NbUPoles, 1), (1,
    NbVPoles) and (NbUPoles, NbVPoles)
    are the four parametric "corners" of the surface.
    - The first column of poles and the last column of
    poles define two Bezier curves which delimit the
    surface in the v parametric direction. These are
    the v isoparametric curves corresponding to
    values 0 and 1 of the v parameter.
    - The first row of poles and the last row of poles
    define two Bezier curves which delimit the surface
    in the u parametric direction. These are the u
    isoparametric curves corresponding to values 0
    and 1 of the u parameter.
    It is more difficult to define a geometrical significance
    for the weights. However they are useful for
    representing a quadric surface precisely. Moreover, if
    the weights of all the poles are equal, the surface has
    a polynomial equation, and hence is a "non-rational surface".
    The non-rational surface is a special, but frequently
    used, case, where all poles have identical weights.
    The weights are defined and used only in the case of
    a rational surface. This rational characteristic is
    defined in each parametric direction. Hence, a
    surface can be rational in the u parametric direction,
    and non-rational in the v parametric direction.
    Likewise, the degree of a surface is defined in each
    parametric direction. The degree of a Bezier surface
    in a given parametric direction is equal to the number
    of poles of the surface in that parametric direction,
    minus 1. This must be greater than or equal to 1.
    However, the degree for a Geom_BezierSurface is
    limited to a value of (25) which is defined and
    controlled by the system. This value is returned by the
    function MaxDegree.
    The parameter range for a Bezier surface is [ 0, 1 ]
    in the two parametric directions.
    A Bezier surface can also be closed, or open, in each
    parametric direction. If the first row of poles is
    identical to the last row of poles, the surface is closed
    in the u parametric direction. If the first column of
    poles is identical to the last column of poles, the
    surface is closed in the v parametric direction.
    The continuity of a Bezier surface is infinite in the u
    parametric direction and the in v parametric direction.
    Note: It is not possible to build a Bezier surface with
    negative weights. Any weight value that is less than,
    or equal to, gp::Resolution() is considered
    to be zero. Two weight values, W1 and W2, are
    considered equal if: |W2-W1| <= gp::Resolution()
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BezierSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BezierSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_BezierSurface self, NCollection_Array2_gp_Pnt SurfacePoles) -> Geom_BezierSurface
        __init__(Geom_BezierSurface self, NCollection_Array2_gp_Pnt SurfacePoles, NCollection_Array2_Standard_Real PoleWeights) -> Geom_BezierSurface

        ---Purpose
        Creates a rational Bezier surface with a set of poles and a
        set of weights.
        For the double array the row indice corresponds to the parametric
        U direction and the columns indice corresponds to the parametric
        V direction.
        If all the weights are identical the surface is considered as
        non-rational (the tolerance criterion is Resolution from package
        gp).

        Raised if SurfacePoles and PoleWeights have not the same
        Rowlength or have not the same ColLength.
        Raised if PoleWeights (i, j) <= Resolution from gp;
        Raised if the number of poles of the surface is lower than 2
        or greater than MaxDegree + 1 in one of the two directions U or V.

        :type SurfacePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type PoleWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        this = _Geom.new_Geom_BezierSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ExchangeUV(self, *args):
        """
        ExchangeUV(Geom_BezierSurface self)

        Exchanges the direction U and V on a Bezier surface
        As a consequence:
        - the poles and weights tables are transposed,
        - degrees, rational characteristics and so on are
        exchanged between the two parametric directions, and
        - the orientation of the surface is reversed.


        """
        return _Geom.Geom_BezierSurface_ExchangeUV(self, *args)


    def Increase(self, *args):
        """
        Increase(Geom_BezierSurface self, Standard_Integer const UDeg, Standard_Integer const VDeg)

        Increases the degree of this Bezier surface in the two parametric directions.

        Raised if UDegree < UDegree <me>  or VDegree < VDegree <me>
        Raised if the degree of the surface is greater than MaxDegree
        in one of the two directions U or V.

        :type UDeg: int
        :type VDeg: int

        """
        return _Geom.Geom_BezierSurface_Increase(self, *args)


    def InsertPoleColAfter(self, *args):
        """
        InsertPoleColAfter(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleColAfter(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a column of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Vindex < 1 or VIndex > NbVPoles.
        Raised if
        . VDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbUPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_InsertPoleColAfter(self, *args)


    def InsertPoleColBefore(self, *args):
        """
        InsertPoleColBefore(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleColBefore(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a column of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Vindex < 1 or VIndex > NbVPoles.
        Raised if :
        . VDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbUPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_InsertPoleColBefore(self, *args)


    def InsertPoleRowAfter(self, *args):
        """
        InsertPoleRowAfter(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleRowAfter(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a row of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Uindex < 1 or UIndex > NbUPoles.
        Raised if :
        . UDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbVPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_InsertPoleRowAfter(self, *args)


    def InsertPoleRowBefore(self, *args):
        """
        InsertPoleRowBefore(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleRowBefore(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a row of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Uindex < 1 or UIndex > NbUPoles.
        Raised if :
        . UDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbVPoles
        . a weight value is lower or equal to Resolution from
        pacakage gp

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_InsertPoleRowBefore(self, *args)


    def RemovePoleCol(self, *args):
        """
        RemovePoleCol(Geom_BezierSurface self, Standard_Integer const VIndex)

        Removes a column of poles.
        If the surface was rational it can become non-rational.

        Raised if NbVPoles <= 2 after removing, a Bezier surface
        must have at least two columns of poles.
        Raised if Vindex < 1 or VIndex > NbVPoles

        :type VIndex: int

        """
        return _Geom.Geom_BezierSurface_RemovePoleCol(self, *args)


    def RemovePoleRow(self, *args):
        """
        RemovePoleRow(Geom_BezierSurface self, Standard_Integer const UIndex)

        Removes a row of poles.
        If the surface was rational it can become non-rational.

        Raised if NbUPoles <= 2 after removing, a Bezier surface
        must have at least two rows of poles.
        Raised if Uindex < 1 or UIndex > NbUPoles

        :type UIndex: int

        """
        return _Geom.Geom_BezierSurface_RemovePoleRow(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom_BezierSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Modifies this Bezier surface by segmenting it
        between U1 and U2 in the u parametric direction,
        and between V1 and V2 in the v parametric
        direction. U1, U2, V1, and V2 can be outside the
        bounds of this surface.
        - U1 and U2 isoparametric Bezier curves,
        segmented between V1 and V2, become the two
        bounds of the surface in the v parametric
        direction (0. and 1. u isoparametric curves).
        - V1 and V2 isoparametric Bezier curves,
        segmented between U1 and U2, become the two
        bounds of the surface in the u parametric
        direction (0. and 1. v isoparametric curves).
        The poles and weights tables are modified, but the
        degree of this surface in the u and v parametric
        directions does not change.
        U1 can be greater than U2, and V1 can be greater
        than V2. In these cases, the corresponding
        parametric direction is inverted. The orientation of
        the surface is inverted if one (and only one)
        parametric direction is inverted.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_BezierSurface_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P)
        SetPole(Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weight of range UIndex, VIndex.
        If the surface <me> is not rational it can become rational.
        if the surface was rational it can become non-rational.

        raises if  UIndex < 1 or UIndex > NbUPoles  or  VIndex < 1
        or VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BezierSurface_SetPole(self, *args)


    def SetPoleCol(self, *args):
        """
        SetPoleCol(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleCol(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a column of poles.
        If the surface was rational it can become non-rational
        If the surface was non-rational it can become rational.
        The length of CPoles can be lower but not greater than NbUPoles
        so you can modify just a part of the column.
        Raised if VIndex < 1 or  VIndex > NbVPoles

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbUPoles
        Raised if CPoleWeights and CPoles have not the same bounds.
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_SetPoleCol(self, *args)


    def SetPoleRow(self, *args):
        """
        SetPoleRow(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleRow(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a row of poles and weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoles can be lower but not greater than NbVPoles
        so you can modify just a part of the row.
        Raised if UIndex < 1 or  UIndex > NbUPoles

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbVPoles
        Raised if CPoleWeights and CPoles have not the same bounds.
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from gp.

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_SetPoleRow(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, Standard_Real const Weight)

        Modifies the weight of the pole of range UIndex, VIndex.
        If the surface was non-rational it can become rational.
        If the surface was rational it can become non-rational.

        Raised if UIndex < 1  or  UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type Weight: float

        """
        return _Geom.Geom_BezierSurface_SetWeight(self, *args)


    def SetWeightCol(self, *args):
        """
        SetWeightCol(Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a column of weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoleWeights can be lower but not greater than
        NbUPoles.
        Raised if VIndex < 1 or  VIndex > NbVPoles

        Raised if CPoleWeights.Lower() < 1 or CPoleWeights.Upper() >
        NbUPoles
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type VIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_SetWeightCol(self, *args)


    def SetWeightRow(self, *args):
        """
        SetWeightRow(Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a row of weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoleWeights can be lower but not greater than
        NbVPoles.
        Raised if UIndex < 1 or  UIndex > NbUPoles

        Raised if CPoleWeights.Lower() < 1 or CPoleWeights.Upper() >
        NbVPoles
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type UIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierSurface_SetWeightRow(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_BezierSurface self)

        Changes the orientation of this Bezier surface in the
        u  parametric direction. The bounds of the
        surface are not changed, but the given parametric
        direction is reversed. Hence, the orientation of the surface is reversed.


        """
        return _Geom.Geom_BezierSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_BezierSurface self, Standard_Real const U) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, produced by reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this Bezier surface.
        In the case of a Bezier surface, these functions return respectively:
        - 1.-U, or 1.-V.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_BezierSurface self)

        Changes the orientation of this Bezier surface in the
        v parametric direction. The bounds of the
        surface are not changed, but the given parametric
        direction is reversed. Hence, the orientation of the
        surface is reversed.


        """
        return _Geom.Geom_BezierSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_BezierSurface self, Standard_Real const V) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, produced by reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this Bezier surface.
        In the case of a Bezier surface, these functions return respectively:
        - 1.-U, or 1.-V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_BezierSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this Bezier surface.
        In the case of a Bezier surface, this function returns
        U1 = 0, V1 = 0, U2 = 1, V2 = 1.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_BezierSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_BezierSurface self) -> GeomAbs_Shape

        Returns the continuity of the surface CN : the order of
        continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_BezierSurface_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BezierSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes P, the point of parameters (U, V) of this Bezier surface, and
        - one or more of the following sets of vectors:
        - D1U and D1V, the first derivative vectors at this point,
        - D2U, D2V and D2UV, the second derivative
        vectors at this point,
        - D3U, D3V, D3UUV and D3UVV, the third
        derivative vectors at this point.
        Note: The parameters U and V can be outside the bounds of the surface.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the u
        parametric direction, and Nv in the v parametric
        direction, at the point of parameters (U, V) of this Bezier surface.
        Note: The parameters U and V can be outside the bounds of the surface.
        Exceptions
        Standard_RangeError if:
        - Nu + Nv is less than 1, or Nu or Nv is negative.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierSurface_DN(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Geom_BezierSurface self) -> Standard_Integer

        Returns the number of poles in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierSurface_NbUPoles(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Geom_BezierSurface self) -> Standard_Integer

        Returns the number of poles in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierSurface_NbVPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range UIndex, VIndex
        Raised if UIndex < 1 or UIndex > NbUPoles, or
        VIndex < 1 or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Geom_BezierSurface_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the Bezier surface.

        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _Geom.Geom_BezierSurface_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(Geom_BezierSurface self) -> Standard_Integer

        Returns the degree of the surface in the U direction it is
        NbUPoles - 1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierSurface_UDegree(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_BezierSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve. For a Bezier surface the
        UIso curve is a Bezier curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_BezierSurface_UIso(self, *args)


    def VDegree(self, *args):
        """
        VDegree(Geom_BezierSurface self) -> Standard_Integer

        Returns the degree of the surface in the V direction it is
        NbVPoles - 1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierSurface_VDegree(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_BezierSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve. For a Bezier surface the
        VIso  curve is a Bezier curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_BezierSurface_VIso(self, *args)


    def Weight(self, *args):
        """
        Weight(Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Standard_Real

        Returns the weight of range UIndex, VIndex

        Raised if UIndex < 1 or UIndex > NbUPoles, or
        VIndex < 1 or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierSurface_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom_BezierSurface self, NCollection_Array2_Standard_Real W)
        Weights(Geom_BezierSurface self) -> NCollection_Array2_Standard_Real

        Returns the weights of the Bezier surface.

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _Geom.Geom_BezierSurface_Weights(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_BezierSurface self) -> Standard_Boolean

        Returns True if the first control points row and the
        last control points row are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_BezierSurface self) -> Standard_Boolean

        Returns True if the first control points column
        and the last control points column are identical.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_BezierSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True, a Bezier surface is always  CN

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_BezierSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True, a BezierSurface is always  CN

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_BezierSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_BezierSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsVPeriodic(self, *args)


    def IsURational(self, *args):
        """
        IsURational(Geom_BezierSurface self) -> Standard_Boolean

        Returns False if the weights are identical in the U direction,
        The tolerance criterion is Resolution from package gp.
        Example :
        |1.0, 1.0, 1.0|
        if Weights =  |0.5, 0.5, 0.5|   returns False
        |2.0, 2.0, 2.0|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsURational(self, *args)


    def IsVRational(self, *args):
        """
        IsVRational(Geom_BezierSurface self) -> Standard_Boolean

        Returns False if the weights are identical in the V direction,
        The tolerance criterion is Resolution from package gp.
        Example :
        |1.0, 2.0, 0.5|
        if Weights =  |1.0, 2.0, 0.5|   returns False
        |1.0, 2.0, 0.5|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierSurface_IsVRational(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_BezierSurface self, gp_Trsf T)

        Applies the transformation T to this Bezier surface.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_BezierSurface_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum polynomial degree of a
        Bezier surface. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierSurface_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom_BezierSurface self, Standard_Real const Tolerance3D)

        Computes two tolerance values for this Bezier
        surface, based on the given tolerance in 3D space
        Tolerance3D. The tolerances computed are:
        - UTolerance in the u parametric direction, and
        - VTolerance in the v parametric direction.
        If f(u,v) is the equation of this Bezier surface,
        UTolerance and VTolerance guarantee that:
        | u1 - u0 | < UTolerance and
        | v1 - v0 | < VTolerance
        ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float
        :type VTolerance: float

        """
        return _Geom.Geom_BezierSurface_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_BezierSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this Bezier surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_BezierSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BezierSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BezierSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BezierSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BezierSurface
Geom_BezierSurface_swigregister = _Geom.Geom_BezierSurface_swigregister
Geom_BezierSurface_swigregister(Geom_BezierSurface)

def Geom_BezierSurface_MaxDegree(*args):
    """
    Geom_BezierSurface_MaxDegree() -> Standard_Integer

    Returns the value of the maximum polynomial degree of a
    Bezier surface. This value is 25.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom.Geom_BezierSurface_MaxDegree(*args)

def Geom_BezierSurface_get_type_name(*args):
    """
    Geom_BezierSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BezierSurface_get_type_name(*args)

def Geom_BezierSurface_get_type_descriptor(*args):
    """
    Geom_BezierSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BezierSurface_get_type_descriptor(*args)

class Geom_Direction(Geom_Vector):
    """
    The class Direction specifies a vector that is never null.
    It is a unit vector.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Direction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Direction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Direction self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> Geom_Direction
        __init__(Geom_Direction self, gp_Dir V) -> Geom_Direction

        Creates a transient copy of <me>.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _Geom.new_Geom_Direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom_Direction self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Sets <me> to X,Y,Z coordinates.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_Direction_SetCoord(self, *args)


    def SetDir(self, *args):
        """
        SetDir(Geom_Direction self, gp_Dir V)

        Converts the gp_Dir unit vector V into this unit vector.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Direction_SetDir(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom_Direction self, Standard_Real const X)

        Changes the X coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type X: float

        """
        return _Geom.Geom_Direction_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom_Direction self, Standard_Real const Y)

        Changes the Y coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type Y: float

        """
        return _Geom.Geom_Direction_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Geom_Direction self, Standard_Real const Z)

        Changes the Z coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type Z: float

        """
        return _Geom.Geom_Direction_SetZ(self, *args)


    def Dir(self, *args):
        """
        Dir(Geom_Direction self) -> gp_Dir

        Returns the non transient direction with the same
        coordinates as <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Direction_Dir(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom_Direction self) -> Standard_Real

        returns 1.0 which is the magnitude of any unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Direction_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom_Direction self) -> Standard_Real

        returns 1.0 which is the square magnitude of any unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Direction_SquareMagnitude(self, *args)


    def Cross(self, *args):
        """
        Cross(Geom_Direction self, Handle_Geom_Vector Other)

        Computes the cross product between <me> and <Other>.

        Raised if the two vectors are parallel because it is
        not possible to have a direction with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Direction_Cross(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Geom_Direction self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^(V1 ^ V2).

        Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are
        parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Direction_CrossCross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom_Direction self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product between <me> and <Other>.
        A new direction is returned.

        Raised if the two vectors are parallel because it is
        not possible to have a direction with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Direction_Crossed(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Geom_Direction self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product <me> ^(V1 ^ V2).

        Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are
        parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_Direction_CrossCrossed(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Direction self, gp_Trsf T)

        Applies the transformation T to this unit vector, then normalizes it.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Direction_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Direction self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this unit vector.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Direction_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Direction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Direction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Direction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Direction
Geom_Direction_swigregister = _Geom.Geom_Direction_swigregister
Geom_Direction_swigregister(Geom_Direction)

def Geom_Direction_get_type_name(*args):
    """
    Geom_Direction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Direction_get_type_name(*args)

def Geom_Direction_get_type_descriptor(*args):
    """
    Geom_Direction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Direction_get_type_descriptor(*args)

class Geom_Ellipse(Geom_Conic):
    """
    Describes an ellipse in 3D space.
    An ellipse is defined by its major and minor radii and,
    as with any conic curve, is positioned in space with a
    right-handed coordinate system (gp_Ax2 object) where:
    - the origin is the center of the ellipse,
    - the "X Direction" defines the major axis, and
    - the "Y Direction" defines the minor axis.
    The origin, "X Direction" and "Y Direction" of this
    coordinate system define the plane of the ellipse. The
    coordinate system is the local coordinate system of the ellipse.
    The "main Direction" of this coordinate system is the
    vector normal to the plane of the ellipse. The axis, of
    which the origin and unit vector are respectively the
    origin and "main Direction" of the local coordinate
    system, is termed the "Axis" or "main Axis" of the ellipse.
    The "main Direction" of the local coordinate system
    gives an explicit orientation to the ellipse (definition of
    the trigonometric sense), determining the direction in
    which the parameter increases along the ellipse.
    The Geom_Ellipse ellipse is parameterized by an angle:
    P(U) = O + MajorRad*Cos(U)*XDir + MinorRad*Sin(U)*YDir
    where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - MajorRad and MinorRad are the major and minor radii of the ellipse.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the ellipse.
    An ellipse is a closed and periodic curve. The period
    is 2.*Pi and the parameter range is [ 0, 2.*Pi [.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Ellipse
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Ellipse(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Ellipse self, gp_Elips E) -> Geom_Ellipse
        __init__(Geom_Ellipse self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> Geom_Ellipse

        Constructs an ellipse
        defined by its major and minor radii, MajorRadius
        and MinorRadius, where A2 locates the ellipse
        and defines its orientation in 3D space such that:
        - the center of the ellipse is the origin of A2,
        - the "X Direction" of A2 defines the major axis
        of the ellipse, i.e. the major radius
        MajorRadius is measured along this axis,
        - the "Y Direction" of A2 defines the minor axis
        of the ellipse, i.e. the minor radius
        MinorRadius is measured along this axis,
        - A2 is the local coordinate system of the ellipse.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than MinorRadius, or
        - MinorRadius is less than 0.
        Warning The Geom package does not prevent the
        construction of an ellipse where MajorRadius and
        MinorRadius are equal.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _Geom.new_Geom_Ellipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetElips(self, *args):
        """
        SetElips(Geom_Ellipse self, gp_Elips E)

        Converts the gp_Elips ellipse E into this ellipse.

        :type E: OCC.wrapper.gp.gp_Elips

        """
        return _Geom.Geom_Ellipse_SetElips(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Geom_Ellipse self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this ellipse.
        ConstructionError raised if MajorRadius < MinorRadius.

        :type MajorRadius: float

        """
        return _Geom.Geom_Ellipse_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Geom_Ellipse self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this ellipse.
        ConstructionError raised if MajorRadius < MinorRadius or if MinorRadius < 0.

        :type MinorRadius: float

        """
        return _Geom.Geom_Ellipse_SetMinorRadius(self, *args)


    def Elips(self, *args):
        """
        Elips(Geom_Ellipse self) -> gp_Elips

        returns the non transient ellipse from gp with the same

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _Geom.Geom_Ellipse_Elips(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Ellipse self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed ellipse for
        the point of parameter U on this ellipse.
        For an ellipse, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_ReversedParameter(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Geom_Ellipse self) -> gp_Ax1

        This directrix is the line normal to the XAxis of the ellipse
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the ellipse, where e is the eccentricity of
        the ellipse.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the "Location" point
        of the directrix1. This point is on the positive side of
        the "XAxis".
        Raised if Eccentricity = 0.0. (The ellipse degenerates
        into a circle)

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Ellipse_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Geom_Ellipse self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the ellipse.

        Raised if Eccentricity = 0.0. (The ellipse degenerates into a
        circle).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Ellipse_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom_Ellipse self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom_Ellipse self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        the two focus of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Geom_Ellipse self) -> gp_Pnt

        Returns the first focus of the ellipse. This focus is on the
        positive side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Ellipse_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Geom_Ellipse self) -> gp_Pnt

        Returns the second focus of the ellipse. This focus is on
        the negative side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Ellipse_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Geom_Ellipse self) -> Standard_Real

        Returns the major  radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Geom_Ellipse self) -> Standard_Real

        Returns the minor radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom_Ellipse self) -> Standard_Real

        Returns p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_Parameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Ellipse self) -> Standard_Real

        Returns the value of the first parameter of this
        ellipse. This is respectively:
        - 0.0, which gives the start point of this ellipse, or
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Ellipse self) -> Standard_Real

        Returns the value of the  last parameter of this
        ellipse. This is respectively:
        - 2.*Pi, which gives the end point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Ellipse_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Ellipse_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Ellipse_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Ellipse self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cos (U) * XDir + MinorRadius * Sin (U) * YDir
        where C is the center of the ellipse , XDir the direction of
        the "XAxis" and "YDir" the "YAxis" of the ellipse.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Ellipse_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Ellipse_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U. The vectors V1 and V2
        are the first and second derivatives at this point.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Ellipse_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Ellipse_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Ellipse self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this ellipse, computes
        the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Ellipse_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Ellipse self, gp_Trsf T)

        Applies the transformation T to this ellipse.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Ellipse_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Ellipse self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this ellipse.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Ellipse_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Ellipse_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Ellipse_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Ellipse_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Ellipse
Geom_Ellipse_swigregister = _Geom.Geom_Ellipse_swigregister
Geom_Ellipse_swigregister(Geom_Ellipse)

def Geom_Ellipse_get_type_name(*args):
    """
    Geom_Ellipse_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Ellipse_get_type_name(*args)

def Geom_Ellipse_get_type_descriptor(*args):
    """
    Geom_Ellipse_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Ellipse_get_type_descriptor(*args)

class Geom_Hyperbola(Geom_Conic):
    """
    Describes a branch of a hyperbola in 3D space.
    A hyperbola is defined by its major and minor radii
    and, as with any conic curve, is positioned in space
    with a right-handed coordinate system (gp_Ax2 object) where:
    - the origin is the center of the hyperbola,
    - the "X Direction" defines the major axis, and
    - the "Y Direction" defines the minor axis.
    The origin, "X Direction" and "Y Direction" of this
    coordinate system define the plane of the hyperbola.
    The coordinate system is the local coordinate
    system of the hyperbola.
    The branch of the hyperbola described is the one
    located on the positive side of the major axis.
    The "main Direction" of the local coordinate system is
    a vector normal to the plane of the hyperbola. The
    axis, of which the origin and unit vector are
    respectively the origin and "main Direction" of the
    local coordinate system, is termed the "Axis" or "main
    Axis" of the hyperbola.
    The "main Direction" of the local coordinate system
    gives an explicit orientation to the hyperbola,
    determining the direction in which the parameter
    increases along the hyperbola.
    The Geom_Hyperbola hyperbola is parameterized as follows:
    P(U) = O + MajRad*Cosh(U)*XDir + MinRad*Sinh(U)*YDir, where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - MajRad and MinRad are the major and minor radii of the hyperbola.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the hyperbola.
    The parameter range is ] -infinite, +infinite [.
    The following diagram illustrates the respective
    positions, in the plane of the hyperbola, of the three
    branches of hyperbolas constructed using the
    functions OtherBranch, ConjugateBranch1 and
    ConjugateBranch2: Defines the main branch of an hyperbola.
    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    SecondConjugateBranch
    |
    Warning
    The value of the major radius (on the major axis) can
    be less than the value of the minor radius (on the minor axis).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Hyperbola
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Hyperbola(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Hyperbola self, gp_Hypr H) -> Geom_Hyperbola
        __init__(Geom_Hyperbola self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> Geom_Hyperbola

        Constructs a hyperbola defined by its major and
        minor radii, MajorRadius and MinorRadius, where A2 locates the
        hyperbola and defines its orientation in 3D space such that:
        - the center of the hyperbola is the origin of A2,
        - the "X Direction" of A2 defines the major axis
        of the hyperbola, i.e. the major radius
        MajorRadius is measured along this axis,
        - the "Y Direction" of A2 defines the minor axis
        of the hyperbola, i.e. the minor radius
        MinorRadius is measured along this axis,
        - A2 is the local coordinate system of the   hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0,
        - MinorRadius is less than 0.0.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _Geom.new_Geom_Hyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetHypr(self, *args):
        """
        SetHypr(Geom_Hyperbola self, gp_Hypr H)

        Converts the gp_Hypr hyperbola H into this hyperbola.

        :type H: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Geom_Hyperbola_SetHypr(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Geom_Hyperbola self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0, or
        - MinorRadius is less than 0.0.Raised if MajorRadius < 0.0

        :type MajorRadius: float

        """
        return _Geom.Geom_Hyperbola_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Geom_Hyperbola self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0, or
        - MinorRadius is less than 0.0.Raised if MajorRadius < 0.0

        :type MinorRadius: float

        """
        return _Geom.Geom_Hyperbola_SetMinorRadius(self, *args)


    def Hypr(self, *args):
        """
        Hypr(Geom_Hyperbola self) -> gp_Hypr

        returns the non transient parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Geom_Hyperbola_Hypr(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Hyperbola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed hyperbola,
        for the point of parameter U on this hyperbola.
        For a hyperbola, the returned value is: -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Hyperbola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Hyperbola self) -> Standard_Real

        returns RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Hyperbola self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Hyperbola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Hyperbola self) -> Standard_Boolean

        return False for an hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Hyperbola_IsPeriodic(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(Geom_Hyperbola self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = (B/A)*X.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Hyperbola_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(Geom_Hyperbola self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = -(B/A)*X.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Hyperbola_Asymptote2(self, *args)


    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(Geom_Hyperbola self) -> gp_Hypr

        This branch of hyperbola is on the positive side of the
        YAxis of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Geom_Hyperbola_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(Geom_Hyperbola self) -> gp_Hypr

        This branch of hyperbola is on the negative side of the
        YAxis of <me>.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Geom_Hyperbola_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Geom_Hyperbola self) -> gp_Ax1

        This directrix is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the YAxis. The intersection point between
        directrix1 and the XAxis is the location point of the directrix1.
        This point is on the positive side of the XAxis.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Hyperbola_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Geom_Hyperbola self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "directrix1" with respect to the YAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Hyperbola_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom_Hyperbola self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom_Hyperbola self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        two focus of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Geom_Hyperbola self) -> gp_Pnt

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the XAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Hyperbola_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Geom_Hyperbola self) -> gp_Pnt

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the XAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Hyperbola_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Geom_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The major radius is also the distance between the
        center of the hyperbola and the apex of the main
        branch (located on the "X Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Geom_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The minor radius is also the distance between the
        center of the hyperbola and the apex of a conjugate
        branch (located on the "Y Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(Geom_Hyperbola self) -> gp_Hypr

        Computes the "other" branch of this hyperbola. This
        is the symmetrical branch with respect to the center of this hyperbola.
        Note: The diagram given under the class purpose
        indicates where the "other" branch is positioned in
        relation to this branch of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Geom_Hyperbola_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom_Hyperbola self) -> Standard_Real

        Returns p = (e * e - 1) * MajorRadius where e is the
        eccentricity of the hyperbola.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Hyperbola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Hyperbola self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cosh (U) * XDir +
        MinorRadius * Sinh (U) * YDir
        where C is the center of the hyperbola , XDir the XDirection and
        YDir the YDirection of the hyperbola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Hyperbola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Hyperbola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Hyperbola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Hyperbola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Hyperbola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Hyperbola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Hyperbola self, gp_Trsf T)

        Applies the transformation T to this hyperbola.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Hyperbola_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Hyperbola self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this hyperbola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Hyperbola_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Hyperbola_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Hyperbola_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Hyperbola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Hyperbola
Geom_Hyperbola_swigregister = _Geom.Geom_Hyperbola_swigregister
Geom_Hyperbola_swigregister(Geom_Hyperbola)

def Geom_Hyperbola_get_type_name(*args):
    """
    Geom_Hyperbola_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Hyperbola_get_type_name(*args)

def Geom_Hyperbola_get_type_descriptor(*args):
    """
    Geom_Hyperbola_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Hyperbola_get_type_descriptor(*args)

class Geom_UndefinedValue(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_UndefinedValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_UndefinedValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_UndefinedValue self) -> Geom_UndefinedValue
        __init__(Geom_UndefinedValue self, Standard_CString const theMessage) -> Geom_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Geom.new_Geom_UndefinedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Geom_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedValue

        """
        return _Geom.Geom_UndefinedValue_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_UndefinedValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_UndefinedValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_UndefinedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_UndefinedValue
Geom_UndefinedValue_swigregister = _Geom.Geom_UndefinedValue_swigregister
Geom_UndefinedValue_swigregister(Geom_UndefinedValue)

def Geom_UndefinedValue_NewInstance(*args):
    """
    Geom_UndefinedValue_NewInstance(Standard_CString const theMessage) -> Handle_Geom_UndefinedValue

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedValue

    """
    return _Geom.Geom_UndefinedValue_NewInstance(*args)

def Geom_UndefinedValue_get_type_name(*args):
    """
    Geom_UndefinedValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_UndefinedValue_get_type_name(*args)

def Geom_UndefinedValue_get_type_descriptor(*args):
    """
    Geom_UndefinedValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_UndefinedValue_get_type_descriptor(*args)

class Geom_Point(Geom_Geometry):
    """
    The abstract class Point describes the common
    behavior of geometric points in 3D space.
    The Geom package also provides the concrete class
    Geom_CartesianPoint.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Point
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Point(self) 
            return h


    def Coord(self, *args):
        """
        Coord(Geom_Point self)

        returns the Coordinates of <me>.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_Point_Coord(self, *args)


    def Pnt(self, *args):
        """
        Pnt(Geom_Point self) -> gp_Pnt

        returns a non transient copy of <me>

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Point_Pnt(self, *args)


    def X(self, *args):
        """
        X(Geom_Point self) -> Standard_Real

        returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Point_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom_Point self) -> Standard_Real

        returns  the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Point_Y(self, *args)


    def Z(self, *args):
        """
        Z(Geom_Point self) -> Standard_Real

        returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Point_Z(self, *args)


    def Distance(self, *args):
        """
        Distance(Geom_Point self, Handle_Geom_Point Other) -> Standard_Real

        Computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Point_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Geom_Point self, Handle_Geom_Point Other) -> Standard_Real

        Computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Point_SquareDistance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Point_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Point_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Point
Geom_Point_swigregister = _Geom.Geom_Point_swigregister
Geom_Point_swigregister(Geom_Point)

def Geom_Point_get_type_name(*args):
    """
    Geom_Point_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Point_get_type_name(*args)

def Geom_Point_get_type_descriptor(*args):
    """
    Geom_Point_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Point_get_type_descriptor(*args)

class Geom_HSequenceOfBSplineSurface(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_HSequenceOfBSplineSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_HSequenceOfBSplineSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_HSequenceOfBSplineSurface self) -> Geom_HSequenceOfBSplineSurface
        __init__(Geom_HSequenceOfBSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theOther) -> Geom_HSequenceOfBSplineSurface

        :type theOther: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        this = _Geom.new_Geom_HSequenceOfBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        res = _Geom.Geom_HSequenceOfBSplineSurface_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Geom_HSequenceOfBSplineSurface self, Handle_Geom_BSplineSurface theItem)
        Append(Geom_HSequenceOfBSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theSequence)

        :type theSequence: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        return _Geom.Geom_HSequenceOfBSplineSurface_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Geom_HSequenceOfBSplineSurface self) -> NCollection_Sequence_Handle_Geom_BSplineSurface

        :rtype: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        return _Geom.Geom_HSequenceOfBSplineSurface_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_HSequenceOfBSplineSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_HSequenceOfBSplineSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_HSequenceOfBSplineSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_HSequenceOfBSplineSurface
Geom_HSequenceOfBSplineSurface_swigregister = _Geom.Geom_HSequenceOfBSplineSurface_swigregister
Geom_HSequenceOfBSplineSurface_swigregister(Geom_HSequenceOfBSplineSurface)

def Geom_HSequenceOfBSplineSurface_get_type_name(*args):
    """
    Geom_HSequenceOfBSplineSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_HSequenceOfBSplineSurface_get_type_name(*args)

def Geom_HSequenceOfBSplineSurface_get_type_descriptor(*args):
    """
    Geom_HSequenceOfBSplineSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_HSequenceOfBSplineSurface_get_type_descriptor(*args)

class Geom_ConicalSurface(Geom_ElementarySurface):
    """
    Describes a cone.
    A cone is defined by the half-angle (can be negative) at its apex, and
    is positioned in space by a coordinate system (a
    gp_Ax3 object) and a reference radius as follows:
    - The "main Axis" of the coordinate system is the
    axis of revolution of the cone.
    - The plane defined by the origin, the "X Direction"
    and the "Y Direction" of the coordinate system is
    the reference plane of the cone. The intersection
    of the cone with this reference plane is a circle of
    radius equal to the reference radius.
    - The apex of the cone is on the negative side of
    the "main Axis" of the coordinate system if the
    half-angle is positive, and on the positive side if
    the half-angle is negative.
    This coordinate system is the "local coordinate
    system" of the cone. The following apply:
    - Rotation around its "main Axis", in the
    trigonometric sense given by the "X Direction"
    and the "Y Direction", defines the u parametric direction.
    - Its "X Axis" gives the origin for the u parameter.
    - Its "main Direction" is the v parametric direction of the cone.
    - Its origin is the origin of the v parameter.
    The parametric range of the two parameters is:
    - [ 0, 2.*Pi ] for u, and - ] -infinity, +infinity [ for v
    The parametric equation of the cone is:  P(u, v) =
    O + (R + v*sin(Ang)) * (cos(u)*XDir + sin(u)*YDir) + v*cos(Ang)*ZDir where:
    - O, XDir, YDir and ZDir are respectively
    the origin, the "X Direction", the "Y Direction" and
    the "Z Direction" of the cone's local coordinate system,
    - Ang is the half-angle at the apex of the cone,   and
    - R is the reference radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_ConicalSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_ConicalSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_ConicalSurface self, gp_Ax3 A3, Standard_Real const Ang, Standard_Real const Radius) -> Geom_ConicalSurface
        __init__(Geom_ConicalSurface self, gp_Cone C) -> Geom_ConicalSurface

        Creates a ConicalSurface from a non transient Cone from
        package gp.

        :type C: OCC.wrapper.gp.gp_Cone

        """
        this = _Geom.new_Geom_ConicalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCone(self, *args):
        """
        SetCone(Geom_ConicalSurface self, gp_Cone C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Cone

        """
        return _Geom.Geom_ConicalSurface_SetCone(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Geom_ConicalSurface self, Standard_Real const R)

        Changes the radius of the conical surface in the placement
        plane (Z = 0, V = 0).  The local coordinate system is not
        modified.
        Raised if R < 0.0

        :type R: float

        """
        return _Geom.Geom_ConicalSurface_SetRadius(self, *args)


    def SetSemiAngle(self, *args):
        """
        SetSemiAngle(Geom_ConicalSurface self, Standard_Real const Ang)

        Changes the semi angle of the conical surface.
        Semi-angle can be negative. Its absolute value
        Abs(Ang) is in range ]0,PI/2[.
        Raises ConstructionError if Abs(Ang) < Resolution from gp or
        Abs(Ang) >= PI/2 - Resolution

        :type Ang: float

        """
        return _Geom.Geom_ConicalSurface_SetSemiAngle(self, *args)


    def Cone(self, *args):
        """
        Cone(Geom_ConicalSurface self) -> gp_Cone

        returns a non transient cone with the same geometric properties
        as <me>.

        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _Geom.Geom_ConicalSurface_Cone(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_ConicalSurface self, Standard_Real const U) -> Standard_Real

        return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ConicalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_ConicalSurface self, Standard_Real const V) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, when reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this cone.
        In the case of a cone, these functions return respectively:
        - 2.*Pi - U, -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ConicalSurface_VReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_ConicalSurface self)

        Changes the orientation of this cone in the v
        parametric direction. The bounds of the surface are
        not changed but the v parametric direction is reversed.
        As a consequence, for a cone:
        - the "main Direction" of the local coordinate system
        is reversed, and
        - the half-angle at the apex is inverted.


        """
        return _Geom.Geom_ConicalSurface_VReverse(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_ConicalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_ConicalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_ConicalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale  centered  on  the
        U axis with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_ConicalSurface_ParametricTransformation(self, *args)


    def Apex(self, *args):
        """
        Apex(Geom_ConicalSurface self) -> gp_Pnt

        Computes the apex of this cone. It is on the negative
        side of the axis of revolution of this cone if the
        half-angle at the apex is positive, and on the positive
        side of the "main Axis" if the half-angle is negative.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_ConicalSurface_Apex(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_ConicalSurface self)

        The conical surface is infinite in the V direction so
        V1 = Realfirst from Standard and V2 = RealLast.
        U1 = 0 and U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_ConicalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Geom_ConicalSurface self)

        Returns the coefficients of the implicit equation of the
        quadric in the absolute cartesian coordinate system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Geom_ConicalSurface_Coefficients(self, *args)


    def RefRadius(self, *args):
        """
        RefRadius(Geom_ConicalSurface self) -> Standard_Real

        Returns the reference radius of this cone.
        The reference radius is the radius of the circle formed
        by the intersection of this cone and its reference
        plane (i.e. the plane defined by the origin, "X
        Direction" and "Y Direction" of the local coordinate
        system of this cone).
        If the apex of this cone is on the origin of the local
        coordinate system of this cone, the returned value is 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ConicalSurface_RefRadius(self, *args)


    def SemiAngle(self, *args):
        """
        SemiAngle(Geom_ConicalSurface self) -> Standard_Real

        Returns the semi-angle at the apex of this cone.
        Attention! Semi-angle can be negative.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ConicalSurface_SemiAngle(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_ConicalSurface self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ConicalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_ConicalSurface self) -> Standard_Boolean

        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ConicalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_ConicalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ConicalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_ConicalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ConicalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_ConicalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Builds the U isoparametric line of this cone. The
        origin of this line is on the reference plane of this
        cone (i.e. the plane defined by the origin, "X Direction"
        and "Y Direction" of the local coordinate system of this cone).

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_ConicalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_ConicalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Builds the V isoparametric circle of this cone. It is the
        circle on this cone, located in the plane of Z
        coordinate V*cos(Semi-Angle) in the local coordinate system of this
        cone. The "Axis" of this circle is the axis of revolution
        of this cone. Its starting point is defined by the "X
        Direction" of this cone.
        Warning
        If the V isoparametric circle is close to the apex of
        this cone, the radius of the circle becomes very small.
        It is possible to have a circle with radius equal to 0.0.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_ConicalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc +
        (RefRadius + V * sin (Semi-Angle)) * (cos (U) * XDir + sin (U) * YDir) +
        V * cos (Semi-Angle) * ZDir
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_ConicalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ConicalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ConicalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ConicalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the u
        parametric direction, and Nv in the v parametric
        direction at the point of parameters (U, V) of this cone.
        Exceptions
        Standard_RangeError if:
        - Nu + Nv is less than 1,
        - Nu or Nv is negative.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ConicalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_ConicalSurface self, gp_Trsf T)

        Applies the transformation T to this cone.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_ConicalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_ConicalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this cone.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_ConicalSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_ConicalSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_ConicalSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_ConicalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_ConicalSurface
Geom_ConicalSurface_swigregister = _Geom.Geom_ConicalSurface_swigregister
Geom_ConicalSurface_swigregister(Geom_ConicalSurface)

def Geom_ConicalSurface_get_type_name(*args):
    """
    Geom_ConicalSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_ConicalSurface_get_type_name(*args)

def Geom_ConicalSurface_get_type_descriptor(*args):
    """
    Geom_ConicalSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_ConicalSurface_get_type_descriptor(*args)

class Geom_OffsetCurve(Geom_Curve):
    """
    This class implements the basis services for an offset curve
    in 3D space. The Offset curve in this package can be a self
    intersecting curve even if the basis curve does not
    self-intersect. The self intersecting portions are not deleted
    at the construction time.
    An offset curve is a curve at constant distance (Offset) from
    a basis curve in a reference direction V. The offset curve
    takes its parametrization from the basis curve.
    The Offset curve is in the direction of the normal N
    defined with the cross product  T^V, where the vector T
    is given by the first derivative on the basis curve with
    non zero length.
    The distance offset may be positive or negative to indicate the
    preferred side of the curve :
    . distance offset >0 => the curve is in the direction of N
    . distance offset <0 => the curve is in the direction of - N

    On the Offset curve :
    Value (U) = BasisCurve.Value(U) + (Offset * (T ^ V)) / ||T ^ V||

    At any point the Offset direction V must not be parallel to the
    vector T and the vector T must not have null length else the
    offset curve is not defined. So the offset curve has not the
    same continuity as the basis curve.

    Warnings :

    In this package we suppose that the continuity of the offset
    curve is one degree less than the continuity of the basis
    curve and we don't check that at any point ||T^V|| != 0.0

    So to evaluate the curve it is better to check that the offset
    curve is well defined at any point because an exception could
    be raised. The check is not done in this package at the creation
    of the offset curve because the control needs the use of an
    algorithm which cannot be implemented in this package.

    The OffsetCurve is closed if the first point and the last point
    are the same (The distance between these two points is lower or
    equal to the Resolution sea package gp) . The OffsetCurve can be
    closed even if the basis curve is not closed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_OffsetCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_OffsetCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_OffsetCurve self, Handle_Geom_Curve C, Standard_Real const Offset, gp_Dir V, Standard_Boolean const isNotCheckC0) -> Geom_OffsetCurve

        C is the basis curve, Offset is the distance between <me> and
        the basis curve at any point. V defines the fixed reference
        direction (offset direction). If P is a point on the basis
        curve and T the first derivative with non zero length
        at this point, the corresponding point on the offset curve is
        in the direction of the vector-product N = V ^ T   where
        N is a unitary vector.
        If isNotCheckC0 = TRUE checking if basis curve has C0-continuity
        is not made.
        Warnings :
        In this package the entities are not shared. The OffsetCurve is
        built with a copy of the curve C. So when C is modified the
        OffsetCurve is not modified

        Raised if the basis curve C is not at least C1.
        Warnings :
        No check is done to know if ||V^T|| != 0.0 at any point.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Offset: float
        :type V: OCC.wrapper.gp.gp_Dir
        :type isNotCheckC0: bool

        """
        this = _Geom.new_Geom_OffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(Geom_OffsetCurve self)

        Changes the orientation of this offset curve.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the
        end point of the reversed curve,
        - the end point of the initial curve becomes the
        start point of the reversed curve, and
        - the first and last parameters are recomputed.


        """
        return _Geom.Geom_OffsetCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_OffsetCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this offset curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_ReversedParameter(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Geom_OffsetCurve self, Handle_Geom_Curve C, Standard_Boolean const isNotCheckC0)

        Changes this offset curve by assigning C
        as the basis curve from which it is built.
        If isNotCheckC0 = TRUE checking if basis curve
        has C0-continuity is not made.
        Exceptions
        Standard_ConstructionError if the curve C is not at least "C1" continuous.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type isNotCheckC0: bool

        """
        return _Geom.Geom_OffsetCurve_SetBasisCurve(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_OffsetCurve self, gp_Dir V)

        Changes this offset curve by assigning V as the
        reference vector used to compute the offset direction.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_OffsetCurve_SetDirection(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Geom_OffsetCurve self, Standard_Real const D)

        Changes this offset curve by assigning D as the offset value.

        :type D: float

        """
        return _Geom.Geom_OffsetCurve_SetOffsetValue(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Geom_OffsetCurve self) -> Handle_Geom_Curve

        Returns the basis curve of this offset curve.
        Note: The basis curve can be an offset curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_OffsetCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_OffsetCurve self) -> GeomAbs_Shape

        Returns the global continuity of this offset curve as a
        value of the GeomAbs_Shape enumeration.
        The degree of continuity of this offset curve is equal
        to the degree of continuity of the basis curve minus 1.
        Continuity of the Offset curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.
        Warnings :
        Returns the continuity of the basis curve - 1.
        The offset curve must have a unique offset direction defined
        at any point.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_OffsetCurve_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference vector of this offset curve.
        Value and derivatives
        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        If T is the first derivative with not null length and
        V the offset direction the relation ||T(U) ^ V|| != 0
        must be satisfied to evaluate the offset curve.
        No check is done at the creation time and we suppose
        in this package that the offset curve is well defined.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Geom_OffsetCurve_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D0(self, *args):
        """
        D0(Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P)

        Warning! this should not be called
        if the basis curve is not at least C1. Nevertheless
        if used on portion where the curve is C1, it is OK

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_OffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Warning! this should not be called
        if the continuity of the basis curve is not C2.
        Nevertheless, it's OK to use it  on portion
        where the curve is C2

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Warning! this should not be called
        if the continuity of the basis curve is not C3.
        Nevertheless, it's OK to use it  on portion
        where the curve is C3

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_OffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative
        for the order of derivation N.

        The following functions compute the value and derivatives
        on the offset curve and returns the derivatives on the
        basis curve too.
        The computation of the value and derivatives on the basis
        curve are used to evaluate the offset curve

        Warning:
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetCurve_DN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_OffsetCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        offset curve. The first parameter corresponds to the
        start point of the curve.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_OffsetCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        offset curve. The last parameter
        corresponds to the end point.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_LastParameter(self, *args)


    def Offset(self, *args):
        """
        Offset(Geom_OffsetCurve self) -> Standard_Real

        Returns the offset value of this offset curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_Offset(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_OffsetCurve self) -> Standard_Boolean

        Returns True if the distance between the start point
        and the end point of the curve is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_OffsetCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of the basis
        curve of this offset curve is at least N + 1.
        This method answer True if the continuity of the basis curve
        is N + 1.  We suppose in this class that a normal direction
        to the basis curve (used to compute the offset curve) is
        defined at any point on the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_OffsetCurve self) -> Standard_Boolean

        Returns true if this offset curve is periodic, i.e. if the
        basis curve of this offset curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Geom_OffsetCurve self) -> Standard_Real

        Returns the period of this offset curve, i.e. the period
        of the basis curve of this offset curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_Period(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_OffsetCurve self, gp_Trsf T)

        Applies the transformation T to this offset curve.
        Note: the basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_OffsetCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom_OffsetCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.
        me->Transformed(T)->Value(me->TransformedParameter(U,T))
        is the same point as
        me->Value(U).Transformed(T)
        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_OffsetCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))
        is the same point as
        Value(U).Transformed(T)
        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_OffsetCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this offset curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_OffsetCurve_Copy(self, *args)


    def GetBasisCurveContinuity(self, *args):
        """
        GetBasisCurveContinuity(Geom_OffsetCurve self) -> GeomAbs_Shape

        Returns continuity of the basis curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_OffsetCurve_GetBasisCurveContinuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_OffsetCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_OffsetCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_OffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_OffsetCurve
Geom_OffsetCurve_swigregister = _Geom.Geom_OffsetCurve_swigregister
Geom_OffsetCurve_swigregister(Geom_OffsetCurve)

def Geom_OffsetCurve_get_type_name(*args):
    """
    Geom_OffsetCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_OffsetCurve_get_type_name(*args)

def Geom_OffsetCurve_get_type_descriptor(*args):
    """
    Geom_OffsetCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_OffsetCurve_get_type_descriptor(*args)

class Geom_OsculatingSurface(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_OsculatingSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_OsculatingSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_OsculatingSurface self) -> Geom_OsculatingSurface
        __init__(Geom_OsculatingSurface self, Handle_Geom_Surface BS, Standard_Real const Tol) -> Geom_OsculatingSurface

        detects if the  surface has punctual U  or  V
        isoparametric  curve along on  the bounds of the surface
        relativly to the tolerance Tol and Builds the corresponding
        osculating surfaces.

        :type BS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        this = _Geom.new_Geom_OsculatingSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(Geom_OsculatingSurface self, Handle_Geom_Surface BS, Standard_Real const Tol)

        :type BS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        return _Geom.Geom_OsculatingSurface_Init(self, *args)


    def BasisSurface(self, *args):
        """
        BasisSurface(Geom_OsculatingSurface self) -> Handle_Geom_Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Geom_OsculatingSurface_BasisSurface(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Geom_OsculatingSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OsculatingSurface_Tolerance(self, *args)


    def UOscSurf(self, *args):
        """
        UOscSurf(Geom_OsculatingSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface L) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along U at the point U,V.

        :type U: float
        :type V: float
        :type t: bool
        :type L: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OsculatingSurface_UOscSurf(self, *args)


    def VOscSurf(self, *args):
        """
        VOscSurf(Geom_OsculatingSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface L) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along V at the point U,V.

        :type U: float
        :type V: float
        :type t: bool
        :type L: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OsculatingSurface_VOscSurf(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_OsculatingSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_OsculatingSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_OsculatingSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_OsculatingSurface
Geom_OsculatingSurface_swigregister = _Geom.Geom_OsculatingSurface_swigregister
Geom_OsculatingSurface_swigregister(Geom_OsculatingSurface)

def Geom_OsculatingSurface_get_type_name(*args):
    """
    Geom_OsculatingSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_OsculatingSurface_get_type_name(*args)

def Geom_OsculatingSurface_get_type_descriptor(*args):
    """
    Geom_OsculatingSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_OsculatingSurface_get_type_descriptor(*args)

class Geom_VectorWithMagnitude(Geom_Vector):
    """
    Defines a vector with magnitude.
    A vector with magnitude can have a zero length.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_VectorWithMagnitude
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_VectorWithMagnitude(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_VectorWithMagnitude self, gp_Vec V) -> Geom_VectorWithMagnitude
        __init__(Geom_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> Geom_VectorWithMagnitude
        __init__(Geom_VectorWithMagnitude self, gp_Pnt P1, gp_Pnt P2) -> Geom_VectorWithMagnitude

        Creates a vector from the point P1 to the point P2.
        The magnitude of the vector is the distance between P1 and P2

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _Geom.new_Geom_VectorWithMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Assigns the values X, Y and Z to the coordinates of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_VectorWithMagnitude_SetCoord(self, *args)


    def SetVec(self, *args):
        """
        SetVec(Geom_VectorWithMagnitude self, gp_Vec V)

        Converts the gp_Vec vector V into this vector.

        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_VectorWithMagnitude_SetVec(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom_VectorWithMagnitude self, Standard_Real const X)

        Changes the X coordinate of <me>.

        :type X: float

        """
        return _Geom.Geom_VectorWithMagnitude_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom_VectorWithMagnitude self, Standard_Real const Y)

        Changes the Y coordinate of <me>

        :type Y: float

        """
        return _Geom.Geom_VectorWithMagnitude_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Geom_VectorWithMagnitude self, Standard_Real const Z)

        Changes the Z coordinate of <me>.

        :type Z: float

        """
        return _Geom.Geom_VectorWithMagnitude_SetZ(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_VectorWithMagnitude_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_VectorWithMagnitude_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Adds the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_Add(self, *args)


    def Added(self, *args):
        """
        Added(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_VectorWithMagnitude

        Adds the vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Geom_VectorWithMagnitude_Added(self, *args)


    def Cross(self, *args):
        """
        Cross(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Computes the cross product  between <me> and Other
        <me> ^ Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_Cross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product  between <me> and Other
        <me> ^ Other. A new vector is returned.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_Crossed(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Geom_VectorWithMagnitude self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^ (V1 ^ V2).

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Geom_VectorWithMagnitude self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product  <me> ^ (V1 ^ V2).
        A new vector is returned.

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_CrossCrossed(self, *args)


    def Divide(self, *args):
        """
        Divide(Geom_VectorWithMagnitude self, Standard_Real const Scalar)

        Divides <me> by a scalar.

        :type Scalar: float

        """
        return _Geom.Geom_VectorWithMagnitude_Divide(self, *args)


    def Divided(self, *args):
        """
        Divided(Geom_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom_VectorWithMagnitude

        Divides <me> by a scalar. A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Geom_VectorWithMagnitude_Divided(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Geom_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom_VectorWithMagnitude

        Computes the product of the vector <me> by a scalar.
        A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Geom_VectorWithMagnitude_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Geom_VectorWithMagnitude self, Standard_Real const Scalar)

        Computes the product of the vector <me> by a scalar.

        :type Scalar: float

        """
        return _Geom.Geom_VectorWithMagnitude_Multiply(self, *args)


    def Normalize(self, *args):
        """
        Normalize(Geom_VectorWithMagnitude self)

        Normalizes <me>.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.


        """
        return _Geom.Geom_VectorWithMagnitude_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(Geom_VectorWithMagnitude self) -> Handle_Geom_VectorWithMagnitude

        Returns a copy of <me> Normalized.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Geom_VectorWithMagnitude_Normalized(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Subtracts the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Geom_VectorWithMagnitude_Subtract(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_VectorWithMagnitude

        Subtracts the vector Other to <me>. A new vector is returned.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Geom_VectorWithMagnitude_Subtracted(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_VectorWithMagnitude self, gp_Trsf T)

        Applies the transformation T to this vector.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_VectorWithMagnitude_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_VectorWithMagnitude self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this vector.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_VectorWithMagnitude_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_VectorWithMagnitude_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_VectorWithMagnitude_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_VectorWithMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_VectorWithMagnitude
Geom_VectorWithMagnitude_swigregister = _Geom.Geom_VectorWithMagnitude_swigregister
Geom_VectorWithMagnitude_swigregister(Geom_VectorWithMagnitude)

def Geom_VectorWithMagnitude_get_type_name(*args):
    """
    Geom_VectorWithMagnitude_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_VectorWithMagnitude_get_type_name(*args)

def Geom_VectorWithMagnitude_get_type_descriptor(*args):
    """
    Geom_VectorWithMagnitude_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_VectorWithMagnitude_get_type_descriptor(*args)

class Geom_RectangularTrimmedSurface(Geom_BoundedSurface):
    """
    Describes a portion of a surface (a patch) limited
    by two values of the u parameter in the u
    parametric direction, and two values of the v
    parameter in the v parametric direction. The
    domain of the trimmed surface must be within the
    domain of the surface being trimmed.
    The trimmed surface is defined by:
    - the basis surface, and
    - the values (umin, umax) and (vmin, vmax)
    which limit it in the u and v parametric directions.
    The trimmed surface is built from a copy of the basis
    surface. Therefore, when the basis surface is
    modified the trimmed surface is not changed.
    Consequently, the trimmed surface does not
    necessarily have the same orientation as the basis surface.
    Warning:  The  case of surface   being trimmed is  periodic and
    parametrics values are outside the domain is possible.
    But, domain of the  trimmed surface can be translated
    by (n X) the period.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_RectangularTrimmedSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_RectangularTrimmedSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_RectangularTrimmedSurface self, Handle_Geom_Surface S, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Boolean const USense, Standard_Boolean const VSense) -> Geom_RectangularTrimmedSurface
        __init__(Geom_RectangularTrimmedSurface self, Handle_Geom_Surface S, Standard_Real const Param1, Standard_Real const Param2, Standard_Boolean const UTrim, Standard_Boolean const Sense) -> Geom_RectangularTrimmedSurface

        The basis surface S is only trim in one parametric direction.
        If UTrim = True the surface is trimmed in the U parametric
        direction else the surface is trimmed in the V parametric
        direction.
        In the considered parametric direction the resulting surface is
        oriented from Param1 to Param2. If S is periodic Sense gives the
        available part of the surface. By default the trimmed surface has
        the same orientation as the basis surface S in the considered
        parametric direction (Sense = True).
        If the basis surface S is closed or periodic in the parametric
        direction opposite to the trimming direction the trimmed surface
        has the same characteristics as the surface S in this direction.
        Warnings :
        In this package the entities are not shared.
        The RectangularTrimmedSurface is built with a copy of the
        surface S. So when S is modified the RectangularTrimmedSurface
        is not modified
        Raised if
        S is not periodic in the considered parametric direction and
        Param1 or Param2 are out of the bounds of S.
        Param1 = Param2

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Param1: float
        :type Param2: float
        :type UTrim: bool
        :type Sense: bool

        """
        this = _Geom.new_Geom_RectangularTrimmedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetTrim(self, *args):
        """
        SetTrim(Geom_RectangularTrimmedSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Boolean const USense, Standard_Boolean const VSense)
        SetTrim(Geom_RectangularTrimmedSurface self, Standard_Real const Param1, Standard_Real const Param2, Standard_Boolean const UTrim, Standard_Boolean const Sense)

        Modifies this patch by changing the trim values
        applied to the original surface
        The basis surface is trimmed only in one parametric direction: if UTrim
        is true, the surface is trimmed in the u parametric
        direction; if it is false, it is trimmed in the v
        parametric direction. In the "trimmed" direction,
        this patch is oriented from Param1 to Param2. If
        the basis surface is periodic in the "trimmed"
        direction, Sense defines its available part. By
        default in this case, this patch has the same
        orientation as the basis surface in this parametric
        direction. If the basis surface is closed or periodic
        in the other parametric direction (i.e. not the
        "trimmed" direction), this patch has the same
        characteristics as the basis surface in that parametric direction.
        Raised if
        The BasisSurface is not periodic in the considered direction and
        Param1 or Param2 are out of the bounds of the BasisSurface.
        Param1 = Param2

        :type Param1: float
        :type Param2: float
        :type UTrim: bool
        :type Sense: bool

        """
        return _Geom.Geom_RectangularTrimmedSurface_SetTrim(self, *args)


    def BasisSurface(self, *args):
        """
        BasisSurface(Geom_RectangularTrimmedSurface self) -> Handle_Geom_Surface

        Returns the Basis surface of <me>.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Geom_RectangularTrimmedSurface_BasisSurface(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_RectangularTrimmedSurface self)

        Changes the orientation of this patch in the u
        parametric direction. The bounds of the surface are
        not changed, but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Geom_RectangularTrimmedSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_RectangularTrimmedSurface self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, produced by when reversing its u
        parametric direction, for any point of u parameter U on this patch.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_RectangularTrimmedSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_RectangularTrimmedSurface self)

        Changes the orientation of this patch in the v
        parametric direction. The bounds of the surface are
        not changed, but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Geom_RectangularTrimmedSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_RectangularTrimmedSurface self, Standard_Real const V) -> Standard_Real

        Computes the v  parameter on the modified
        surface, produced by when reversing its v
        parametric direction, for any point of v parameter V on this patch.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_RectangularTrimmedSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_RectangularTrimmedSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this patch.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_RectangularTrimmedSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_RectangularTrimmedSurface self) -> GeomAbs_Shape

        Returns  the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_RectangularTrimmedSurface_Continuity(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is closed in the given parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is closed in the given parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_RectangularTrimmedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the order of derivation in the U parametric
        direction is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_RectangularTrimmedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the order of derivation in the V parametric
        direction is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is periodic and not trimmed in the given
        parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Geom_RectangularTrimmedSurface self) -> Standard_Real

        Returns the period of this patch in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_RectangularTrimmedSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is periodic and not trimmed in the given
        parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_RectangularTrimmedSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Geom_RectangularTrimmedSurface self) -> Standard_Real

        Returns the period of this patch in the v
        parametric direction.
        raises if the surface is not vperiodic.
        value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_RectangularTrimmedSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_RectangularTrimmedSurface self, Standard_Real const U) -> Handle_Geom_Curve

        computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_RectangularTrimmedSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_RectangularTrimmedSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_RectangularTrimmedSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Can be raised if the basis surface is an OffsetSurface.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_RectangularTrimmedSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning!  UndefinedDerivative  raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_RectangularTrimmedSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning! UndefinedDerivative raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_RectangularTrimmedSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning UndefinedDerivative raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_RectangularTrimmedSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        The returned derivative has the same orientation as the
        derivative of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning!  UndefinedDerivative raised if the continuity of the surface is not CNu in the U
        parametric direction and CNv in the V parametric direction.
        RangeError Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_RectangularTrimmedSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_RectangularTrimmedSurface self, gp_Trsf T)

        Applies the transformation T to this patch.
        Warning
        As a consequence, the basis surface included in the
        data structure of this patch is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_RectangularTrimmedSurface_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_RectangularTrimmedSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods calls the basis surface method.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_RectangularTrimmedSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_RectangularTrimmedSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods calls the basis surface method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_RectangularTrimmedSurface_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_RectangularTrimmedSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this patch.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_RectangularTrimmedSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_RectangularTrimmedSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_RectangularTrimmedSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_RectangularTrimmedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_RectangularTrimmedSurface
Geom_RectangularTrimmedSurface_swigregister = _Geom.Geom_RectangularTrimmedSurface_swigregister
Geom_RectangularTrimmedSurface_swigregister(Geom_RectangularTrimmedSurface)

def Geom_RectangularTrimmedSurface_get_type_name(*args):
    """
    Geom_RectangularTrimmedSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_RectangularTrimmedSurface_get_type_name(*args)

def Geom_RectangularTrimmedSurface_get_type_descriptor(*args):
    """
    Geom_RectangularTrimmedSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_RectangularTrimmedSurface_get_type_descriptor(*args)

class Geom_Parabola(Geom_Conic):
    """
    Describes a parabola in 3D space.
    A parabola is defined by its focal length (i.e. the
    distance between its focus and its apex) and is
    positioned in space with a coordinate system
    (gp_Ax2 object) where:
    - the origin is the apex of the parabola,
    - the "X Axis" defines the axis of symmetry; the
    parabola is on the positive side of this axis,
    - the origin, "X Direction" and "Y Direction" define the
    plane of the parabola.
    This coordinate system is the local coordinate
    system of the parabola.
    The "main Direction" of this coordinate system is a
    vector normal to the plane of the parabola. The axis,
    of which the origin and unit vector are respectively the
    origin and "main Direction" of the local coordinate
    system, is termed the "Axis" or "main Axis" of the parabola.
    The "main Direction" of the local coordinate system
    gives an explicit orientation to the parabola,
    determining the direction in which the parameter
    increases along the parabola.
    The Geom_Parabola parabola is parameterized as follows:
    P(U) = O + U*U/(4.*F)*XDir + U*YDir
    where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - F is the focal length of the parabola.
    The parameter of the parabola is therefore its Y
    coordinate in the local coordinate system, with the "X
    Axis" of the local coordinate system defining the origin
    of the parameter.
    The parameter range is ] -infinite, +infinite [.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Parabola
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Parabola(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Parabola self, gp_Parab Prb) -> Geom_Parabola
        __init__(Geom_Parabola self, gp_Ax2 A2, Standard_Real const Focal) -> Geom_Parabola
        __init__(Geom_Parabola self, gp_Ax1 D, gp_Pnt F) -> Geom_Parabola

        D is the directrix of the parabola and F the focus point.
        The symmetry axis (XAxis) of the parabola is normal to the
        directrix and pass through the focus point F, but its
        location point is the vertex of the parabola.
        The YAxis of the parabola is parallel to D and its location
        point is the vertex of the parabola. The normal to the plane
        of the parabola is the cross product between the XAxis and the
        YAxis.

        :type D: OCC.wrapper.gp.gp_Ax1
        :type F: OCC.wrapper.gp.gp_Pnt

        """
        this = _Geom.new_Geom_Parabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFocal(self, *args):
        """
        SetFocal(Geom_Parabola self, Standard_Real const Focal)

        Assigns the value Focal to the focal distance of this parabola.
        Exceptions Standard_ConstructionError if Focal is negative.

        :type Focal: float

        """
        return _Geom.Geom_Parabola_SetFocal(self, *args)


    def SetParab(self, *args):
        """
        SetParab(Geom_Parabola self, gp_Parab Prb)

        Converts the gp_Parab parabola Prb into this parabola.

        :type Prb: OCC.wrapper.gp.gp_Parab

        """
        return _Geom.Geom_Parabola_SetParab(self, *args)


    def Parab(self, *args):
        """
        Parab(Geom_Parabola self) -> gp_Parab

        Returns the non transient parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _Geom.Geom_Parabola_Parab(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Parabola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed parabola,
        for the point of parameter U on this parabola.
        For a parabola, the returned value is: -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Parabola self) -> Standard_Real

        Returns the value of the first or last parameter of this
        parabola. This is, respectively:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Parabola self) -> Standard_Real

        Returns the value of the first or last parameter of this
        parabola. This is, respectively:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Parabola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Parabola_IsPeriodic(self, *args)


    def Directrix(self, *args):
        """
        Directrix(Geom_Parabola self) -> gp_Ax1

        Computes the directrix of this parabola.
        This is a line normal to the axis of symmetry, in the
        plane of this parabola, located on the negative side
        of its axis of symmetry, at a distance from the apex
        equal to the focal length.
        The directrix is returned as an axis (gp_Ax1 object),
        where the origin is located on the "X Axis" of this parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Parabola_Directrix(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom_Parabola self) -> Standard_Real

        Returns 1. (which is the eccentricity of any parabola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_Eccentricity(self, *args)


    def Focus(self, *args):
        """
        Focus(Geom_Parabola self) -> gp_Pnt

        Computes the focus of this parabola. The focus is on the
        positive side of the "X Axis" of the local coordinate
        system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Parabola_Focus(self, *args)


    def Focal(self, *args):
        """
        Focal(Geom_Parabola self) -> Standard_Real

        Computes the focal distance of this parabola
        The focal distance is the distance between the apex
        and the focus of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_Focal(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom_Parabola self) -> Standard_Real

        Computes the parameter of this parabola which is the
        distance between its focus and its directrix. This
        distance is twice the focal length.
        If P is the parameter of the parabola, the equation of
        the parabola in its local coordinate system is: Y**2 = 2.*P*X.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Parabola self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If U = 0 the returned point is the origin of the XAxis and
        the YAxis of the parabola and it is the vertex of the parabola.
        P = S + F * (U * U * XDir +  * U * YDir)
        where S is the vertex of the parabola, XDir the XDirection and
        YDir the YDirection of the parabola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Parabola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Parabola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Parabola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Parabola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Parabola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this parabola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Parabola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Parabola self, gp_Trsf T)

        Applies the transformation T to this parabola.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Parabola_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom_Parabola self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U> * T.ScaleFactor()

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_Parabola self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Parabola_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Parabola self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this parabola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Parabola_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Parabola_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Parabola_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Parabola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Parabola
Geom_Parabola_swigregister = _Geom.Geom_Parabola_swigregister
Geom_Parabola_swigregister(Geom_Parabola)

def Geom_Parabola_get_type_name(*args):
    """
    Geom_Parabola_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Parabola_get_type_name(*args)

def Geom_Parabola_get_type_descriptor(*args):
    """
    Geom_Parabola_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Parabola_get_type_descriptor(*args)

class Geom_ToroidalSurface(Geom_ElementarySurface):
    """
    Describes a torus.
    A torus is defined by its major and minor radii, and
    positioned in space with a coordinate system (a
    gp_Ax3 object) as follows:
    - The origin is the center of the torus.
    - The surface is obtained by rotating a circle around
    the "main Direction". This circle has a radius equal
    to the minor radius, and is located in the plane
    defined by the origin, "X Direction" and "main
    Direction". It is centered on the "X Axis", on its
    positive side, and positioned at a distance from the
    origin equal to the major radius. This circle is the
    "reference circle" of the torus.
    - The plane defined by the origin, the "X Direction"
    and the "Y Direction" is called the "reference plane" of the torus.
    This coordinate system is the "local coordinate
    system" of the torus. The following apply:
    - Rotation around its "main Axis", in the trigonometric
    sense given by "X Direction" and "Y Direction",
    defines the u parametric direction.
    - The "X Axis" gives the origin for the u parameter.
    - Rotation around an axis parallel to the "Y Axis" and
    passing through the center of the "reference circle"
    gives the v parameter on the "reference circle".
    - The "X Axis" gives the origin of the v parameter on
    the "reference circle".
    - The v parametric direction is oriented by the
    inverse of the "main Direction", i.e. near 0, as v
    increases, the Z coordinate decreases. (This
    implies that the "Y Direction" orients the reference
    circle only when the local coordinate system is direct.)
    - The u isoparametric curve is a circle obtained by
    rotating the "reference circle" of the torus through
    an angle u about the "main Axis".
    The parametric equation of the torus is :
    P(u, v) = O + (R + r*cos(v)) * (cos(u)*XDir +
    sin(u)*YDir ) + r*sin(v)*ZDir, where:
    - O, XDir, YDir and ZDir are respectively the
    origin, the "X Direction", the "Y Direction" and the "Z
    Direction" of the local coordinate system,
    - r and R are, respectively, the minor and major radius.
    The parametric range of the two parameters is:
    - [ 0, 2.*Pi ] for u
    - [ 0, 2.*Pi ] for v
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_ToroidalSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_ToroidalSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_ToroidalSurface self, gp_Ax3 A3, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> Geom_ToroidalSurface
        __init__(Geom_ToroidalSurface self, gp_Torus T) -> Geom_ToroidalSurface

        Creates a ToroidalSurface from a non transient Torus from
        package gp.

        :type T: OCC.wrapper.gp.gp_Torus

        """
        this = _Geom.new_Geom_ToroidalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Geom_ToroidalSurface self, Standard_Real const MajorRadius)

        Modifies this torus by changing its major radius.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is negative, or
        - MajorRadius - r is less than or equal to
        gp::Resolution(), where r is the minor radius of this torus.

        :type MajorRadius: float

        """
        return _Geom.Geom_ToroidalSurface_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Geom_ToroidalSurface self, Standard_Real const MinorRadius)

        Modifies this torus by changing its minor radius.
        Exceptions
        Standard_ConstructionError if:
        - MinorRadius is negative, or
        - R - MinorRadius is less than or equal to
        gp::Resolution(), where R is the major radius of this torus.

        :type MinorRadius: float

        """
        return _Geom.Geom_ToroidalSurface_SetMinorRadius(self, *args)


    def SetTorus(self, *args):
        """
        SetTorus(Geom_ToroidalSurface self, gp_Torus T)

        Converts the gp_Torus torus T into this torus.

        :type T: OCC.wrapper.gp.gp_Torus

        """
        return _Geom.Geom_ToroidalSurface_SetTorus(self, *args)


    def Torus(self, *args):
        """
        Torus(Geom_ToroidalSurface self) -> gp_Torus

        Returns the non transient torus with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _Geom.Geom_ToroidalSurface_Torus(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_ToroidalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_ToroidalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_VReversedParameter(self, *args)


    def Area(self, *args):
        """
        Area(Geom_ToroidalSurface self) -> Standard_Real

        Computes the aera of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_Area(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_ToroidalSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this torus.
        For a torus: U1 = V1 = 0 and U2 = V2 = 2*PI .

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_ToroidalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Geom_ToroidalSurface self, NCollection_Array1_Standard_Real Coef)

        Returns the coefficients of the implicit equation of the surface
        in the absolute cartesian coordinate system :
        Coef(1) * X**4 + Coef(2) * Y**4 + Coef(3) * Z**4 +
        Coef(4) * X**3 * Y + Coef(5) * X**3 * Z + Coef(6) * Y**3 * X +
        Coef(7) * Y**3 * Z + Coef(8) * Z**3 * X + Coef(9) * Z**3 * Y +
        Coef(10) * X**2 * Y**2 + Coef(11) * X**2 * Z**2 +
        Coef(12) * Y**2 * Z**2 + Coef(13) * X**3 + Coef(14) * Y**3 +
        Coef(15) * Z**3 + Coef(16) * X**2 * Y + Coef(17) * X**2 * Z +
        Coef(18) * Y**2 * X + Coef(19) * Y**2 * Z + Coef(20) * Z**2 * X +
        Coef(21) * Z**2 * Y + Coef(22) * X**2 + Coef(23) * Y**2 +
        Coef(24) * Z**2 + Coef(25) * X * Y + Coef(26) * X * Z +
        Coef(27) * Y * Z + Coef(28) * X + Coef(29) * Y + Coef(30) *  Z +
        Coef(31) = 0.0
        Raised if the length of Coef is lower than 31.

        :type Coef: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_ToroidalSurface_Coefficients(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Geom_ToroidalSurface self) -> Standard_Real

        Returns the major radius, or the minor radius, of this torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Geom_ToroidalSurface self) -> Standard_Real

        Returns the major radius, or the minor radius, of this torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_MinorRadius(self, *args)


    def Volume(self, *args):
        """
        Volume(Geom_ToroidalSurface self) -> Standard_Real

        Computes the volume.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_ToroidalSurface_Volume(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ToroidalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ToroidalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ToroidalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_ToroidalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_ToroidalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        For a toroidal surface the UIso curve is a circle.
        The center of the Uiso circle is at the distance MajorRadius
        from the location point of the toroidal surface.
        Warnings :
        The radius of the circle can be zero if for the surface
        MinorRadius = 0.0

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_ToroidalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_ToroidalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        For a ToroidalSurface the VIso curve is a circle.
        The axis of the circle is the main axis (ZAxis) of the
        toroidal  surface.
        Warnings :
        The radius of the circle can be zero if for the surface
        MajorRadius = MinorRadius

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_ToroidalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + MinorRadius * Sin (V) * Zdir +
        (MajorRadius + MinorRadius * Cos(V)) *
        (cos (U) * XDir + sin (U) * YDir)
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis and ZDir the direction of the ZAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_ToroidalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in
        the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ToroidalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ToroidalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the
        third derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ToroidalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and
        Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_ToroidalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_ToroidalSurface self, gp_Trsf T)

        Applies the transformation T to this torus.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_ToroidalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_ToroidalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this torus.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_ToroidalSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_ToroidalSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_ToroidalSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_ToroidalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_ToroidalSurface
Geom_ToroidalSurface_swigregister = _Geom.Geom_ToroidalSurface_swigregister
Geom_ToroidalSurface_swigregister(Geom_ToroidalSurface)

def Geom_ToroidalSurface_get_type_name(*args):
    """
    Geom_ToroidalSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_ToroidalSurface_get_type_name(*args)

def Geom_ToroidalSurface_get_type_descriptor(*args):
    """
    Geom_ToroidalSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_ToroidalSurface_get_type_descriptor(*args)

class Geom_BSplineSurface(Geom_BoundedSurface):
    """
    Describes a BSpline surface.
    In each parametric direction, a BSpline surface can be:
    - uniform or non-uniform,
    - rational or non-rational,
    - periodic or non-periodic.
    A BSpline surface is defined by:
    - its degrees, in the u and v parametric directions,
    - its periodic characteristic, in the u and v parametric directions,
    - a table of poles, also called control points (together
    with the associated weights if the surface is rational), and
    - a table of knots, together with the associated multiplicities.
    The degree of a Geom_BSplineSurface is limited to
    a value (25) which is defined and controlled by the
    system. This value is returned by the function MaxDegree.
    Poles and Weights
    Poles and Weights are manipulated using two associative double arrays:
    - the poles table, which is a double array of gp_Pnt points, and
    - the weights table, which is a double array of reals.
    The bounds of the poles and weights arrays are:
    - 1 and NbUPoles for the row bounds (provided
    that the BSpline surface is not periodic in the u
    parametric direction), where NbUPoles is the
    number of poles of the surface in the u parametric direction, and
    - 1 and NbVPoles for the column bounds (provided
    that the BSpline surface is not periodic in the v
    parametric direction), where NbVPoles is the
    number of poles of the surface in the v parametric direction.
    The poles of the surface are the points used to shape
    and reshape the surface. They comprise a rectangular network.
    If the surface is not periodic:
    - The points (1, 1), (NbUPoles, 1), (1,
    NbVPoles), and (NbUPoles, NbVPoles)
    are the four parametric "corners" of the surface.
    - The first column of poles and the last column of
    poles define two BSpline curves which delimit the
    surface in the v parametric direction. These are the
    v isoparametric curves corresponding to the two
    bounds of the v parameter.
    - The first row of poles and the last row of poles
    define two BSpline curves which delimit the surface
    in the u parametric direction. These are the u
    isoparametric curves corresponding to the two bounds of the u parameter.
    If the surface is periodic, these geometric properties are not verified.
    It is more difficult to define a geometrical significance
    for the weights. However they are useful for
    representing a quadric surface precisely. Moreover, if
    the weights of all the poles are equal, the surface has
    a polynomial equation, and hence is a "non-rational surface".
    The non-rational surface is a special, but frequently
    used, case, where all poles have identical weights.
    The weights are defined and used only in the case of
    a rational surface. The rational characteristic is
    defined in each parametric direction. A surface can be
    rational in the u parametric direction, and
    non-rational in the v parametric direction.
    Knots and Multiplicities
    For a Geom_BSplineSurface the table of knots is
    made up of two increasing sequences of reals, without
    repetition, one for each parametric direction. The
    multiplicities define the repetition of the knots.
    A BSpline surface comprises multiple contiguous
    patches, which are themselves polynomial or rational
    surfaces. The knots are the parameters of the
    isoparametric curves which limit these contiguous
    patches. The multiplicity of a knot on a BSpline
    surface (in a given parametric direction) is related to
    the degree of continuity of the surface at that knot in
    that parametric direction:
    Degree of continuity at knot(i) = Degree - Multi(i) where:
    - Degree is the degree of the BSpline surface in
    the given parametric direction, and
    - Multi(i) is the multiplicity of knot number i in
    the given parametric direction.
    There are some special cases, where the knots are
    regularly spaced in one parametric direction (i.e. the
    difference between two consecutive knots is a constant).
    - "Uniform": all the multiplicities are equal to 1.
    - "Quasi-uniform": all the multiplicities are equal to 1,
    except for the first and last knots in this parametric
    direction, and these are equal to Degree + 1.
    - "Piecewise Bezier": all the multiplicities are equal to
    Degree except for the first and last knots, which
    are equal to Degree + 1. This surface is a
    concatenation of Bezier patches in the given
    parametric direction.
    If the BSpline surface is not periodic in a given
    parametric direction, the bounds of the knots and
    multiplicities tables are 1 and NbKnots, where
    NbKnots is the number of knots of the BSpline
    surface in that parametric direction.
    If the BSpline surface is periodic in a given parametric
    direction, and there are k periodic knots and p
    periodic poles in that parametric direction:
    - the period is such that:
    period = Knot(k+1) - Knot(1), and
    - the poles and knots tables in that parametric
    direction can be considered as infinite tables, such that:
    Knot(i+k) = Knot(i) + period, and
    Pole(i+p) = Pole(i)
    Note: The data structure tables for a periodic BSpline
    surface are more complex than those of a non-periodic one.
    References :
    . A survey of curve and surface methods in CADG Wolfgang BOHM
    CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BSplineSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BSplineSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_BSplineSurface self, NCollection_Array2_gp_Pnt Poles, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const UPeriodic, Standard_Boolean const VPeriodic) -> Geom_BSplineSurface
        __init__(Geom_BSplineSurface self, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const UPeriodic, Standard_Boolean const VPeriodic) -> Geom_BSplineSurface

        Creates  a non-rational b-spline surface (weights
        default value is 1.).

        The following conditions must be verified.
        0 < UDegree <= MaxDegree.

        UKnots.Length() == UMults.Length() >= 2

        UKnots(i) < UKnots(i+1) (Knots are increasing)
        1 <= UMults(i) <= UDegree

        On a   non  uperiodic   surface    the  first and    last
        umultiplicities  may  be     UDegree+1  (this   is   even
        recommanded if you want the curve  to start and finish on
        the first and last pole).

        On a uperiodic     surface  the first    and   the   last
        umultiplicities must be the same.

        on non-uperiodic surfaces

        Poles.ColLength() == Sum(UMults(i)) - UDegree - 1 >= 2

        on uperiodic surfaces

        Poles.ColLength() == Sum(UMults(i)) except the first or
        last

        The previous conditions for U holds  also for V, with the
        RowLength of the poles.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type UPeriodic: bool
        :type VPeriodic: bool

        """
        this = _Geom.new_Geom_BSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ExchangeUV(self, *args):
        """
        ExchangeUV(Geom_BSplineSurface self)

        Exchanges the u and v parametric directions on
        this BSpline surface.
        As a consequence:
        - the poles and weights tables are transposed,
        - the knots and multiplicities tables are exchanged,
        - degrees of continuity, and rational, periodic and
        uniform characteristics are exchanged, and
        - the orientation of the surface is inverted.


        """
        return _Geom.Geom_BSplineSurface_ExchangeUV(self, *args)


    def SetUPeriodic(self, *args):
        """
        SetUPeriodic(Geom_BSplineSurface self)

        Sets the surface U periodic.
        Modifies this surface to be periodic in the U 
        parametric direction.
        To become periodic in a given parametric direction a
        surface must be closed in that parametric direction,
        and the knot sequence relative to that direction must be periodic.
        To generate this periodic sequence of knots, the
        functions FirstUKnotIndex and LastUKnotIndex  are used to
        compute I1 and I2. These are the indexes, in the
        knot array associated with the given parametric
        direction, of the knots that correspond to the first and
        last parameters of this BSpline surface in the given
        parametric direction. Hence the period is:
        Knots(I1) - Knots(I2)
        As a result, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if the surface is not
        closed in the given parametric direction.


        """
        return _Geom.Geom_BSplineSurface_SetUPeriodic(self, *args)


    def SetVPeriodic(self, *args):
        """
        SetVPeriodic(Geom_BSplineSurface self)

        Sets the surface V periodic.
        Modifies this surface to be periodic in the V
        parametric direction.
        To become periodic in a given parametric direction a
        surface must be closed in that parametric direction,
        and the knot sequence relative to that direction must be periodic.
        To generate this periodic sequence of knots, the
        functions FirstVKnotIndex and LastVKnotIndex are used to
        compute I1 and I2. These are the indexes, in the
        knot array associated with the given parametric
        direction, of the knots that correspond to the first and
        last parameters of this BSpline surface in the given
        parametric direction. Hence the period is:
        Knots(I1) - Knots(I2)
        As a result, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if the surface is not
        closed in the given parametric direction.


        """
        return _Geom.Geom_BSplineSurface_SetVPeriodic(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Geom_BSplineSurface self)

        returns the parameter normalized within
        the period if the surface is periodic : otherwise
        does not do anything

        :type U: float
        :type V: float

        """
        return _Geom.Geom_BSplineSurface_PeriodicNormalization(self, *args)


    def SetUOrigin(self, *args):
        """
        SetUOrigin(Geom_BSplineSurface self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table in
        the corresponding parametric direction to be the
        origin of this periodic BSpline surface. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this BSpline surface is
        not periodic in the given parametric direction.
        Standard_DomainError if Index is outside the
        bounds of the knots table in the given parametric direction.

        :type Index: int

        """
        return _Geom.Geom_BSplineSurface_SetUOrigin(self, *args)


    def SetVOrigin(self, *args):
        """
        SetVOrigin(Geom_BSplineSurface self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table in
        the corresponding parametric direction to be the
        origin of this periodic BSpline surface. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this BSpline surface is
        not periodic in the given parametric direction.
        Standard_DomainError if Index is outside the
        bounds of the knots table in the given parametric direction.

        :type Index: int

        """
        return _Geom.Geom_BSplineSurface_SetVOrigin(self, *args)


    def SetUNotPeriodic(self, *args):
        """
        SetUNotPeriodic(Geom_BSplineSurface self)

        Sets the surface U not periodic.
        Changes this BSpline surface into a non-periodic
        surface along U direction. 
        If this surface is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.


        """
        return _Geom.Geom_BSplineSurface_SetUNotPeriodic(self, *args)


    def SetVNotPeriodic(self, *args):
        """
        SetVNotPeriodic(Geom_BSplineSurface self)

        Sets the surface V not periodic.
        Changes this BSpline surface into a non-periodic
        surface along V direction. 
        If this surface is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.


        """
        return _Geom.Geom_BSplineSurface_SetVNotPeriodic(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_BSplineSurface self)

        Changes the orientation of this BSpline surface in the
        U parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        The knots and poles tables are modified.


        """
        return _Geom.Geom_BSplineSurface_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_BSplineSurface self)

        Changes the orientation of this BSpline surface in the
        V parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        The knots and poles tables are modified.


        """
        return _Geom.Geom_BSplineSurface_VReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_BSplineSurface self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, produced by reversing its U parametric
        direction, for the point of u parameter U,  on this BSpline surface.
        For a BSpline surface, these functions return respectively:
        - UFirst + ULast - U, 
        where UFirst, ULast are
        the values of the first and last parameters of this
        BSpline surface, in the u parametric directions.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_BSplineSurface self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, produced by reversing its V parametric
        direction, for the point of v parameter V on this BSpline surface.
        For a BSpline surface, these functions return respectively:
        - VFirst + VLast - V,
        VFirst and VLast are
        the values of the first and last parameters of this
        BSpline surface, in the v pametric directions.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineSurface_VReversedParameter(self, *args)


    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Geom_BSplineSurface self, Standard_Integer const UDegree, Standard_Integer const VDegree)

        Increases the degrees of this BSpline surface to
        UDegree and VDegree in the u and v parametric
        directions respectively. As a result, the tables of poles,
        weights and multiplicities are modified. The tables of
        knots is not changed.
        Note: Nothing is done if the given degree is less than
        or equal to the current degree in the corresponding
        parametric direction.
        Exceptions
        Standard_ConstructionError if UDegree or
        VDegree is greater than
        Geom_BSplineSurface::MaxDegree().

        :type UDegree: int
        :type VDegree: int

        """
        return _Geom.Geom_BSplineSurface_IncreaseDegree(self, *args)


    def InsertUKnots(self, *args):
        """
        InsertUKnots(Geom_BSplineSurface self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts into the knots table for the U
        parametric direction of this BSpline surface:
        - the values of the array Knots, with their respective
        multiplicities, Mults.
        If the knot value to insert already exists in the table, its multiplicity is:
        - increased by M, if Add is true (the default), or
        - increased to M, if Add is false.
        The tolerance criterion used to check the equality of
        the knots is the larger of the values ParametricTolerance and
        Standard_Real::Epsilon(val), where val is the knot value to be inserted.
        Warning
        - If a given multiplicity coefficient is null, or negative, nothing is done.
        - The new multiplicity of a knot is limited to the degree of this BSpline surface in the
        corresponding parametric direction.
        Exceptions
        Standard_ConstructionError if a knot value to
        insert is outside the bounds of this BSpline surface in
        the specified parametric direction. The comparison
        uses the precision criterion ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineSurface_InsertUKnots(self, *args)


    def InsertVKnots(self, *args):
        """
        InsertVKnots(Geom_BSplineSurface self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts into the knots table for the V
        parametric direction of this BSpline surface:
        - the values of the array Knots, with their respective
        multiplicities, Mults.
        If the knot value to insert already exists in the table, its multiplicity is:
        - increased by M, if Add is true (the default), or
        - increased to M, if Add is false.
        The tolerance criterion used to check the equality of
        the knots is the larger of the values ParametricTolerance and
        Standard_Real::Epsilon(val), where val is the knot value to be inserted.
        Warning
        - If a given multiplicity coefficient is null, or negative, nothing is done.
        - The new multiplicity of a knot is limited to the degree of this BSpline surface in the
        corresponding parametric direction.
        Exceptions
        Standard_ConstructionError if a knot value to
        insert is outside the bounds of this BSpline surface in
        the specified parametric direction. The comparison
        uses the precision criterion ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineSurface_InsertVKnots(self, *args)


    def RemoveUKnot(self, *args):
        """
        RemoveUKnot(Geom_BSplineSurface self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces to M the multiplicity of the knot of index
        Index in the U parametric direction. If M is 0, the knot is removed.
        With a modification of this type, the table of poles is also modified.
        Two different algorithms are used systematically to
        compute the new poles of the surface. For each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is checked. If
        this distance is less than Tolerance it ensures that
        the surface is not modified by more than Tolerance.
        Under these conditions, the function returns true;
        otherwise, it returns false.
        A low tolerance prevents modification of the
        surface. A high tolerance "smoothes" the surface.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table of this BSpline surface.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_RemoveUKnot(self, *args)


    def RemoveVKnot(self, *args):
        """
        RemoveVKnot(Geom_BSplineSurface self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces to M the multiplicity of the knot of index
        Index in the V parametric direction. If M is 0, the knot is removed.
        With a modification of this type, the table of poles is also modified.
        Two different algorithms are used systematically to
        compute the new poles of the surface. For each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is checked. If
        this distance is less than Tolerance it ensures that
        the surface is not modified by more than Tolerance.
        Under these conditions, the function returns true;
        otherwise, it returns false.
        A low tolerance prevents modification of the
        surface. A high tolerance "smoothes" the surface.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table of this BSpline surface.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_RemoveVKnot(self, *args)


    def IncreaseUMultiplicity(self, *args):
        """
        IncreaseUMultiplicity(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const M)
        IncreaseUMultiplicity(Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const M)

        Increases until order M the multiplicity of the set of knots
        FromI1,...., ToI2 in the U direction. This method can be used
        to make a B_spline surface into a PiecewiseBezier B_spline
        surface.
        If <me> was uniform, it can become non uniform.

        Raised if FromI1 or ToI2 is out of the range [FirstUKnotIndex,
        LastUKnotIndex].

        M should be greater than the previous multiplicity of the
        all the knots FromI1,..., ToI2 and lower or equal to the
        Degree of the surface in the U parametric direction.

        :type FromI1: int
        :type ToI2: int
        :type M: int

        """
        return _Geom.Geom_BSplineSurface_IncreaseUMultiplicity(self, *args)


    def IncrementUMultiplicity(self, *args):
        """
        IncrementUMultiplicity(Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const Step)

        Increments the multiplicity of the consecutives uknots FromI1..ToI2
        by step.   The multiplicity of each knot FromI1,.....,ToI2 must be
        lower or equal to the UDegree of the B_spline.

        Raised if FromI1 or ToI2 is not in the range
        [FirstUKnotIndex, LastUKnotIndex]

        Raised if one knot has a multiplicity greater than UDegree.

        :type FromI1: int
        :type ToI2: int
        :type Step: int

        """
        return _Geom.Geom_BSplineSurface_IncrementUMultiplicity(self, *args)


    def IncreaseVMultiplicity(self, *args):
        """
        IncreaseVMultiplicity(Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Integer const M)
        IncreaseVMultiplicity(Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const M)

        Increases until order M the multiplicity of the set of knots
        FromI1,...., ToI2 in the V direction. This method can be used to
        make a BSplineSurface into a PiecewiseBezier B_spline
        surface. If <me> was uniform, it can become non-uniform.

        Raised if FromI1 or ToI2 is out of the range [FirstVKnotIndex,
        LastVKnotIndex] given by the methods with the same name.

        M should be greater than the previous multiplicity of the
        all the knots FromI1,..., ToI2 and lower or equal to the
        Degree of the surface in the V parametric direction.

        :type FromI1: int
        :type ToI2: int
        :type M: int

        """
        return _Geom.Geom_BSplineSurface_IncreaseVMultiplicity(self, *args)


    def IncrementVMultiplicity(self, *args):
        """
        IncrementVMultiplicity(Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const Step)

        Increments the multiplicity of the consecutives vknots FromI1..ToI2
        by step.  The multiplicity of each knot FromI1,.....,ToI2 must be
        lower or equal to the VDegree of the B_spline.

        Raised if FromI1 or ToI2 is not in the range
        [FirstVKnotIndex, LastVKnotIndex]

        Raised if one knot has a multiplicity greater than VDegree.

        :type FromI1: int
        :type ToI2: int
        :type Step: int

        """
        return _Geom.Geom_BSplineSurface_IncrementVMultiplicity(self, *args)


    def InsertUKnot(self, *args):
        """
        InsertUKnot(Geom_BSplineSurface self, Standard_Real const U, Standard_Integer const M, Standard_Real const ParametricTolerance, Standard_Boolean const Add)

        Inserts a knot value in the sequence of UKnots. If U is a knot
        value this method increases the multiplicity of the knot if the
        previous multiplicity was lower than M else it does nothing. The
        tolerance criterion is ParametricTolerance. ParametricTolerance
        should be greater or equal than Resolution from package gp.

        Raised if U is out of the bounds [U1, U2] given by the methods
        Bounds, the criterion ParametricTolerance is used.
        Raised if M is not in the range [1, UDegree].

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineSurface_InsertUKnot(self, *args)


    def InsertVKnot(self, *args):
        """
        InsertVKnot(Geom_BSplineSurface self, Standard_Real const V, Standard_Integer const M, Standard_Real const ParametricTolerance, Standard_Boolean const Add)

        Inserts a knot value in the sequence of VKnots. If V is a knot
        value this method increases the multiplicity of the knot if the
        previous multiplicity was lower than M otherwise it does nothing.
        The tolerance criterion is ParametricTolerance.
        ParametricTolerance should be greater or equal than Resolution
        from package gp.

        raises if V is out of the Bounds [V1, V2] given by the methods
        Bounds, the criterion ParametricTolerance is used.
        raises if M is not in the range [1, VDegree].

        :type V: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Geom_BSplineSurface_InsertVKnot(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom_BSplineSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Segments the surface between U1 and U2 in the U-Direction.
        between V1 and V2 in the V-Direction.
        The control points are modified, the first and the last point
        are not the same.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the surface <me> or if the surface makes loop.
        raises if U2 < U1 or V2 < V1.
        Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces.
        i.e. ((U2 - U1) - UPeriod) > Precision::PConfusion().
        Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces.
        i.e. ((V2 - V1) - VPeriod) > Precision::PConfusion()).

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_BSplineSurface_Segment(self, *args)


    def CheckAndSegment(self, *args):
        """
        CheckAndSegment(Geom_BSplineSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Segments the surface between U1 and U2 in the U-Direction.
        between V1 and V2 in the V-Direction.

        same as Segment but do nothing if U1 and U2 (resp. V1 and V2) are
        equal to the bounds in U (resp. in V) of <me>.
        For example, if <me> is periodic in V, it will be always periodic
        in V after the segmentation if the bounds in V are unchanged

        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the surface <me> or if the surface makes loop.
        raises if U2 < U1 or V2 < V1.
        Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces.
        i.e. ((U2 - U1) - UPeriod) > Precision::PConfusion().
        Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces.
        i.e. ((V2 - V1) - VPeriod) > Precision::PConfusion()).

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_BSplineSurface_CheckAndSegment(self, *args)


    def SetUKnots(self, *args):
        """
        SetUKnots(Geom_BSplineSurface self, NCollection_Array1_Standard_Real UK)

        Changes all the U-knots of the surface.
        The multiplicity of the knots are not modified.

        Raised if there is an index such that UK (Index+1) <= UK (Index).

        Raised if  UK.Lower() < 1 or UK.Upper() > NbUKnots

        :type UK: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineSurface_SetUKnots(self, *args)


    def SetUKnot(self, *args):
        """
        SetUKnot(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Real const K)
        SetUKnot(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Real const K, Standard_Integer const M)

        Changes the value of the UKnots of range UIndex and
        increases its multiplicity.

        Raised if UIndex is not in the range [FirstUKnotIndex,
        LastUKnotIndex] given by the methods with the same name.

        Raised if K >= UKnots(UIndex+1) or K <= UKnots(UIndex-1)
        M must be lower than UDegree and greater than the previous
        multiplicity of the knot of range UIndex.

        :type UIndex: int
        :type K: float
        :type M: int

        """
        return _Geom.Geom_BSplineSurface_SetUKnot(self, *args)


    def SetVKnots(self, *args):
        """
        SetVKnots(Geom_BSplineSurface self, NCollection_Array1_Standard_Real VK)

        Changes all the V-knots of the surface.
        The multiplicity of the knots are not modified.

        Raised if there is an index such that VK (Index+1) <= VK (Index).

        Raised if  VK.Lower() < 1 or VK.Upper() > NbVKnots

        :type VK: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineSurface_SetVKnots(self, *args)


    def SetVKnot(self, *args):
        """
        SetVKnot(Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Real const K)
        SetVKnot(Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Real const K, Standard_Integer const M)

        Changes the value of the VKnots of range VIndex and increases
        its multiplicity.

        Raised if VIndex is not in the range [FirstVKnotIndex,
        LastVKnotIndex] given by the methods with the same name.

        Raised if K >= VKnots(VIndex+1) or K <= VKnots(VIndex-1)
        M must be lower than VDegree and greater than the previous
        multiplicity of the knot of range VIndex.

        :type VIndex: int
        :type K: float
        :type M: int

        """
        return _Geom.Geom_BSplineSurface_SetVKnot(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of UKnots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        UKnots (I1) <= U <= UKnots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < UKnots(1) - Abs(ParametricTolerance)
        . if I2 > NbUKnots => U > UKnots(NbUKnots)+Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Geom_BSplineSurface_LocateU(self, *args)


    def LocateV(self, *args):
        """
        LocateV(Geom_BSplineSurface self, Standard_Real const V, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value V in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        VKnots (I1) <= V <= VKnots (I2)
        . if I1 = I2  V is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => V < VKnots(1) - Abs(ParametricTolerance)
        . if I2 > NbVKnots => V > VKnots(NbVKnots)+Abs(ParametricTolerance)
        poles insertion and removing
        The following methods are available only if the surface
        is Uniform or QuasiUniform in the considered direction
        The knot repartition is modified.

        :type V: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Geom_BSplineSurface_LocateV(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P)
        SetPole(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weight of range (UIndex, VIndex)
        with P and W.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BSplineSurface_SetPole(self, *args)


    def SetPoleCol(self, *args):
        """
        SetPoleCol(Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleCol(Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a column of poles or a part of this column with the
        corresponding weights. If the surface was rational it can
        become non rational. If the surface was non rational it can
        become rational.
        Raised if Vindex < 1 or VIndex > NbVPoles.

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbUPoles
        Raised if the bounds of CPoleWeights are not the same as the
        bounds of CPoles.
        Raised if one of the weight value of CPoleWeights is lower or
        equal to Resolution from package gp.

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineSurface_SetPoleCol(self, *args)


    def SetPoleRow(self, *args):
        """
        SetPoleRow(Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)
        SetPoleRow(Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)

        Changes a row of poles or a part of this row.
        Raised if Uindex < 1 or UIndex > NbUPoles.

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbVPoles.

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Geom.Geom_BSplineSurface_SetPoleRow(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, Standard_Real const Weight)

        Changes the weight of the pole of range UIndex, VIndex.
        If the surface was non rational it can become rational.
        If the surface was rational it can become non rational.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles

        Raised if weight is lower or equal to Resolution from
        package gp

        :type UIndex: int
        :type VIndex: int
        :type Weight: float

        """
        return _Geom.Geom_BSplineSurface_SetWeight(self, *args)


    def SetWeightCol(self, *args):
        """
        SetWeightCol(Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a column of weights of a part of this column.

        Raised if VIndex < 1 or VIndex > NbVPoles

        Raised if CPoleWeights.Lower() < 1 or
        CPoleWeights.Upper() > NbUPoles.
        Raised if a weight value is lower or equal to Resolution
        from package gp.

        :type VIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineSurface_SetWeightCol(self, *args)


    def SetWeightRow(self, *args):
        """
        SetWeightRow(Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a row of weights or a part of this row.

        Raised if UIndex < 1 or UIndex > NbUPoles

        Raised if CPoleWeights.Lower() < 1 or
        CPoleWeights.Upper() > NbVPoles.
        Raised  if a weight value is lower or equal to Resolution
        from package gp.

        :type UIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BSplineSurface_SetWeightRow(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, Standard_Integer const UIndex1, Standard_Integer const UIndex2, Standard_Integer const VIndex1, Standard_Integer const VIndex2)

        Move a point with parameter U and V to P.
        given u,v  as parameters)  to  reach a  new position
        UIndex1, UIndex2, VIndex1, VIndex2:
        indicates the poles which can be moved
        if Problem in BSplineBasis calculation, no change
        for the curve and
        UFirstIndex, VLastIndex = 0
        VFirstIndex, VLastIndex = 0

        Raised if UIndex1 < UIndex2 or VIndex1 < VIndex2 or
        UIndex1 < 1 || UIndex1 > NbUPoles or
        UIndex2 < 1 || UIndex2 > NbUPoles
        VIndex1 < 1 || VIndex1 > NbVPoles or
        VIndex2 < 1 || VIndex2 > NbVPoles
        characteristics of the surface

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type UIndex1: int
        :type UIndex2: int
        :type VIndex1: int
        :type VIndex2: int
        :type UFirstIndex: int
        :type ULastIndex: int
        :type VFirstIndex: int
        :type VLastIndex: int

        """
        return _Geom.Geom_BSplineSurface_MovePoint(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_BSplineSurface self) -> Standard_Boolean

        Returns true if the first control points row and the last
        control points row are identical. The tolerance criterion
        is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_BSplineSurface self) -> Standard_Boolean

        Returns true if the first control points column and the
        last last control points column are identical.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_BSplineSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the order of continuity of the surface in the
        U direction  is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_BSplineSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the order of continuity of the surface
        in the V direction  is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_BSplineSurface self) -> Standard_Boolean

        Returns True if the surface is closed in the U direction
        and if the B-spline has been turned into a periodic surface
        using the function SetUPeriodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsUPeriodic(self, *args)


    def IsURational(self, *args):
        """
        IsURational(Geom_BSplineSurface self) -> Standard_Boolean

        Returns False if for each row of weights all the weights
        are identical.
        The tolerance criterion is resolution from package gp.
        Example :
        |1.0, 1.0, 1.0|
        if Weights =  |0.5, 0.5, 0.5|   returns False
        |2.0, 2.0, 2.0|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsURational(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_BSplineSurface self) -> Standard_Boolean

        Returns True if the surface is closed in the V direction
        and if the B-spline has been turned into a periodic
        surface using the function SetVPeriodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsVPeriodic(self, *args)


    def IsVRational(self, *args):
        """
        IsVRational(Geom_BSplineSurface self) -> Standard_Boolean

        Returns False if for each column of weights all the weights
        are identical.
        The tolerance criterion is resolution from package gp.
        Examples :
        |1.0, 2.0, 0.5|
        if Weights =  |1.0, 2.0, 0.5|   returns False
        |1.0, 2.0, 0.5|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BSplineSurface_IsVRational(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_BSplineSurface self)

        Returns the parametric bounds of the surface.
        Warnings :
        These parametric values are the bounds of the array of
        knots UKnots and VKnots only if the first knots and the
        last knots have a multiplicity equal to UDegree + 1 or
        VDegree + 1

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_BSplineSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_BSplineSurface self) -> GeomAbs_Shape

        Returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.
        A B-spline surface is infinitely continuously differentiable
        for the couple of parameters U, V such thats U != UKnots(i)
        and V != VKnots(i). The continuity of the surface at a knot
        value depends on the multiplicity of this knot.
        Example :
        If the surface is C1 in the V direction and C2 in the U
        direction this function returns Shape = C1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_BSplineSurface_Continuity(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the UKnots which gives the first
        parametric value of the surface in the U direction.
        The UIso curve corresponding to this value is a
        boundary curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_FirstUKnotIndex(self, *args)


    def FirstVKnotIndex(self, *args):
        """
        FirstVKnotIndex(Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the VKnots which gives the
        first parametric value of the surface in the V direction.
        The VIso curve corresponding to this knot is a boundary
        curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_FirstVKnotIndex(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the UKnots which gives the
        last parametric value of the surface in the U direction.
        The UIso curve corresponding to this knot is a boundary
        curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_LastUKnotIndex(self, *args)


    def LastVKnotIndex(self, *args):
        """
        LastVKnotIndex(Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the VKnots which gives the
        last parametric value of the surface in the V direction.
        The VIso curve corresponding to this knot is a
        boundary curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_LastVKnotIndex(self, *args)


    def NbUKnots(self, *args):
        """
        NbUKnots(Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of knots in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_NbUKnots(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Geom_BSplineSurface self) -> Standard_Integer

        Returns number of poles in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_NbUPoles(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of knots in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_NbVKnots(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of poles in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_NbVPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range (UIndex, VIndex).

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Geom_BSplineSurface_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline surface.

        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _Geom.Geom_BSplineSurface_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(Geom_BSplineSurface self) -> Standard_Integer

        Returns the degree of the normalized B-splines Ni,n in the U
        direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_UDegree(self, *args)


    def UKnot(self, *args):
        """
        UKnot(Geom_BSplineSurface self, Standard_Integer const UIndex) -> Standard_Real

        Returns the Knot value of range UIndex.
        Raised if UIndex < 1 or UIndex > NbUKnots

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineSurface_UKnot(self, *args)


    def UKnotDistribution(self, *args):
        """
        UKnotDistribution(Geom_BSplineSurface self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or
        PiecewiseBezier.  If all the knots differ by a
        positive constant from the preceding knot in the U
        direction the B-spline surface can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1
        except for the first and last knot which are of
        multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have
        multiplicity Degree + 1 and if interior knots have
        multiplicity Degree
        otherwise the surface is non uniform in the U direction
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Geom_BSplineSurface_UKnotDistribution(self, *args)


    def UKnots(self, *args):
        """
        Returns the knots in the U direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineSurface_UKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UKnotSequence(self, *args):
        """
        Returns the uknots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineSurface_UKnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UMultiplicity(self, *args):
        """
        UMultiplicity(Geom_BSplineSurface self, Standard_Integer const UIndex) -> Standard_Integer

        Returns the multiplicity value of knot of range UIndex in
        the u direction.
        Raised if UIndex < 1 or UIndex > NbUKnots.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_UMultiplicity(self, *args)


    def UMultiplicities(self, *args):
        """
        Returns the multiplicities of the knots in the U direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Geom_BSplineSurface_UMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VDegree(self, *args):
        """
        VDegree(Geom_BSplineSurface self) -> Standard_Integer

        Returns the degree of the normalized B-splines Ni,d in the
        V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_VDegree(self, *args)


    def VKnot(self, *args):
        """
        VKnot(Geom_BSplineSurface self, Standard_Integer const VIndex) -> Standard_Real

        Returns the Knot value of range VIndex.
        Raised if VIndex < 1 or VIndex > NbVKnots

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineSurface_VKnot(self, *args)


    def VKnotDistribution(self, *args):
        """
        VKnotDistribution(Geom_BSplineSurface self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or
        PiecewiseBezier. If all the knots differ by a positive
        constant from the preceding knot in the V direction the
        B-spline surface can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1
        except for the first and last knot which are of
        multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have
        multiplicity  Degree + 1 and if interior knots have
        multiplicity Degree
        otherwise the surface is non uniform in the V direction.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Geom_BSplineSurface_VKnotDistribution(self, *args)


    def VKnots(self, *args):
        """
        Returns the knots in the V direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineSurface_VKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VKnotSequence(self, *args):
        """
        Returns the vknots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Geom_BSplineSurface_VKnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VMultiplicity(self, *args):
        """
        VMultiplicity(Geom_BSplineSurface self, Standard_Integer const VIndex) -> Standard_Integer

        Returns the multiplicity value of knot of range VIndex in
        the v direction.
        Raised if VIndex < 1 or VIndex > NbVKnots

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_VMultiplicity(self, *args)


    def VMultiplicities(self, *args):
        """
        Returns the multiplicities of the knots in the V direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Geom_BSplineSurface_VMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Weight(self, *args):
        """
        Weight(Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Standard_Real

        Returns the weight value of range UIndex, VIndex.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1
        or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BSplineSurface_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom_BSplineSurface self, NCollection_Array2_Standard_Real W)
        Weights(Geom_BSplineSurface self) -> NCollection_Array2_Standard_Real

        Returns the weights of the B-spline surface.
        value and derivatives computation

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _Geom.Geom_BSplineSurface_Weights(self, *args)


    def D0(self, *args):
        """
        D0(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Nu is the order of derivation in the U parametric direction and
        Nv is the order of derivation in the V parametric direction.

        Raised if the continuity of the surface is not CNu in the U
        direction and CNv in the V direction.

        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        The following functions computes the point for the
        parametric values (U, V) and the derivatives at
        this point on the B-spline surface patch delimited
        with the knots FromUK1, FromVK1 and the knots ToUK2,
        ToVK2.  (U, V) can be out of these parametric bounds
        but for the computation we only use the definition
        of the surface between these knots. This method is
        useful to compute local derivative, if the order of
        continuity of the whole surface is not greater enough.
        Inside the parametric knot's domain previously defined
        the evaluations are the same as if we consider the whole
        definition of the surface. Of course the evaluations are
        different outside this parametric domain.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_DN(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P)

        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineSurface_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the local continuity of the surface is not C1
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Raised if the local continuity of the surface is not C2
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the local continuity of the surface is not C3
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Raised if the local continuity of the surface is not CNu
        between the knots FromUK1, ToUK2 and CNv between the knots
        FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BSplineSurface_LocalDN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2) -> gp_Pnt

        Computes the point of parameter U, V on the BSpline surface patch
        defines between the knots UK1 UK2, VK1, VK2. U can be out of the
        bounds [Knot UK1, Knot UK2] and V can be outof the bounds
        [Knot VK1, Knot VK2]  but for the computation we only use the
        definition of the surface between these knot values.
        Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BSplineSurface_LocalValue(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_BSplineSurface self, Standard_Real const U) -> Handle_Geom_Curve
        UIso(Geom_BSplineSurface self, Standard_Real const U, Standard_Boolean const CheckRational) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        If CheckRational=False, no try to make it non-rational.
        A B-spline curve is returned.

        :type U: float
        :type CheckRational: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_BSplineSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_BSplineSurface self, Standard_Real const V) -> Handle_Geom_Curve
        VIso(Geom_BSplineSurface self, Standard_Real const V, Standard_Boolean const CheckRational) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        If CheckRational=False, no try to make it non-rational.
        A B-spline curve is returned.
        transformations

        :type V: float
        :type CheckRational: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_BSplineSurface_VIso(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_BSplineSurface self, gp_Trsf T)

        Applies the transformation T to this BSpline surface.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_BSplineSurface_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in the u and v directions.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BSplineSurface_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom_BSplineSurface self, Standard_Real const Tolerance3D)

        Computes two tolerance values for this BSpline
        surface, based on the given tolerance in 3D space
        Tolerance3D. The tolerances computed are:
        - UTolerance in the u parametric direction, and
        - VTolerance in the v parametric direction.
        If f(u,v) is the equation of this BSpline surface,
        UTolerance and VTolerance guarantee that :
        | u1 - u0 | < UTolerance and
        | v1 - v0 | < VTolerance
        ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float
        :type VTolerance: float

        """
        return _Geom.Geom_BSplineSurface_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_BSplineSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this BSpline surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_BSplineSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BSplineSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BSplineSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BSplineSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BSplineSurface
Geom_BSplineSurface_swigregister = _Geom.Geom_BSplineSurface_swigregister
Geom_BSplineSurface_swigregister(Geom_BSplineSurface)

def Geom_BSplineSurface_MaxDegree(*args):
    """
    Geom_BSplineSurface_MaxDegree() -> Standard_Integer

    Returns the value of the maximum degree of the normalized
    B-spline basis functions in the u and v directions.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom.Geom_BSplineSurface_MaxDegree(*args)

def Geom_BSplineSurface_get_type_name(*args):
    """
    Geom_BSplineSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BSplineSurface_get_type_name(*args)

def Geom_BSplineSurface_get_type_descriptor(*args):
    """
    Geom_BSplineSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BSplineSurface_get_type_descriptor(*args)

class Geom_SurfaceOfRevolution(Geom_SweptSurface):
    """
    Describes a surface of revolution (revolved surface).
    Such a surface is obtained by rotating a curve (called
    the "meridian") through a complete revolution about
    an axis (referred to as the "axis of revolution"). The
    curve and the axis must be in the same plane (the
    "reference plane" of the surface).
    Rotation around the axis of revolution in the
    trigonometric sense defines the u parametric
    direction. So the u parameter is an angle, and its
    origin is given by the position of the meridian on the surface.
    The parametric range for the u parameter is: [ 0, 2.*Pi ]
    The v parameter is that of the meridian.
    Note: A surface of revolution is built from a copy of the
    original meridian. As a result the original meridian is
    not modified when the surface is modified.
    The form of a surface of revolution is typically a
    general revolution surface
    (GeomAbs_RevolutionForm). It can be:
    - a conical surface, if the meridian is a line or a
    trimmed line (GeomAbs_ConicalForm),
    - a cylindrical surface, if the meridian is a line or a
    trimmed line parallel to the axis of revolution
    (GeomAbs_CylindricalForm),
    - a planar surface if the meridian is a line or a
    trimmed line perpendicular to the axis of revolution
    of the surface (GeomAbs_PlanarForm),
    - a toroidal surface, if the meridian is a circle or a
    trimmed circle (GeomAbs_ToroidalForm), or
    - a spherical surface, if the meridian is a circle, the
    center of which is located on the axis of the
    revolved surface (GeomAbs_SphericalForm).
    Warning
    Be careful not to construct a surface of revolution
    where the curve and the axis or revolution are not
    defined in the same plane. If you do not have a
    correct configuration, you can correct your initial
    curve, using a cylindrical projection in the reference plane.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_SurfaceOfRevolution
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_SurfaceOfRevolution(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_SurfaceOfRevolution self, Handle_Geom_Curve C, gp_Ax1 A1) -> Geom_SurfaceOfRevolution

        C : is the meridian  or the referenced curve.
        A1 is the axis of revolution.
        The form of a SurfaceOfRevolution can be :
        . a general revolution surface (RevolutionForm),
        . a conical surface if the meridian is a line or a trimmed line
        (ConicalForm),
        . a cylindrical surface if the meridian is a line or a trimmed
        line parallel to the revolution axis (CylindricalForm),
        . a planar surface if the meridian is a line perpendicular to
        the revolution axis of the surface (PlanarForm).
        . a spherical surface,
        . a toroidal surface,
        . a quadric surface.
        Warnings :
        It is not checked that the curve C is planar and that the
        surface axis is in the plane of the curve.
        It is not checked that the revolved curve C doesn't
        self-intersects.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        this = _Geom.new_Geom_SurfaceOfRevolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetAxis(self, *args):
        """
        SetAxis(Geom_SurfaceOfRevolution self, gp_Ax1 A1)

        Changes the axis of revolution.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_SurfaceOfRevolution_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_SurfaceOfRevolution self, gp_Dir V)

        Changes the direction of the revolution axis.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_SurfaceOfRevolution_SetDirection(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Geom_SurfaceOfRevolution self, Handle_Geom_Curve C)

        Changes the revolved curve of the surface.
        Warnings :
        It is not checked that the curve C is planar and that the
        surface axis is in the plane of the curve.
        It is not checked that the revolved curve C doesn't
        self-intersects.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfRevolution_SetBasisCurve(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom_SurfaceOfRevolution self, gp_Pnt P)

        Changes the location point of the revolution axis.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_SurfaceOfRevolution_SetLocation(self, *args)


    def Axis(self, *args):
        """
        Axis(Geom_SurfaceOfRevolution self) -> gp_Ax1

        Returns the revolution axis of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_SurfaceOfRevolution_Axis(self, *args)


    def Location(self, *args):
        """
        Returns the location point of the axis of revolution.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Geom_SurfaceOfRevolution_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReferencePlane(self, *args):
        """
        ReferencePlane(Geom_SurfaceOfRevolution self) -> gp_Ax2

        Computes the position of the reference plane of the surface
        defined by the basis curve and the symmetry axis.
        The location point is the location point of the revolution's
        axis, the XDirection of the plane is given by the revolution's
        axis and the orientation of the normal to the plane is given
        by the sense of revolution.

        Raised if the revolved curve is not planar or if the revolved
        curve and the symmetry axis are not in the same plane or if
        the maximum of distance between the axis and the revolved
        curve is lower or equal to Resolution from gp.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_SurfaceOfRevolution_ReferencePlane(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_SurfaceOfRevolution self)

        Changes the orientation of this surface of revolution
        in the u  parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        As a consequence:
        - UReverse reverses the direction of the axis of
        revolution of this surface,


        """
        return _Geom.Geom_SurfaceOfRevolution_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_SurfaceOfRevolution self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, when reversing its u  parametric
        direction, for any point of u parameter U  on this surface of revolution.
        In the case of a revolved surface:
        - UReversedParameter returns 2.*Pi - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SurfaceOfRevolution_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_SurfaceOfRevolution self)

        Changes the orientation of this surface of revolution
        in the v parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        As a consequence:
        - VReverse reverses the meridian of this surface of revolution.


        """
        return _Geom.Geom_SurfaceOfRevolution_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_SurfaceOfRevolution self, Standard_Real const V) -> Standard_Real

        Computes the  v parameter on the modified
        surface, when reversing its  v parametric
        direction, for any point of v parameter V on this surface of revolution.
        In the case of a revolved surface:
        - VReversedParameter returns the reversed
        parameter given by the function
        ReversedParameter called with V on the meridian.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SurfaceOfRevolution_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_SurfaceOfRevolution self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies V by
        BasisCurve()->ParametricTransformation(T)

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_SurfaceOfRevolution_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_SurfaceOfRevolution self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale  centered  on  the
        U axis with BasisCurve()->ParametricTransformation(T)

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_SurfaceOfRevolution_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_SurfaceOfRevolution self)

        Returns the parametric bounds U1, U2 , V1 and V2 of this surface.
        A surface of revolution is always complete, so U1 = 0, U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_SurfaceOfRevolution_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsUClosed always returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsVClosed returns true if the meridian of this
        surface of revolution is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_SurfaceOfRevolution self, Standard_Integer const N) -> Standard_Boolean

        IsCNu always returns true.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_SurfaceOfRevolution self, Standard_Integer const N) -> Standard_Boolean

        IsCNv returns true if the degree of continuity of the
        meridian of this surface of revolution is at least N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_SurfaceOfRevolution self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsVPeriodic returns true if the meridian of this
        surface of revolution is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfRevolution_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_SurfaceOfRevolution self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of revolution. It is the curve obtained by rotating the
        meridian through an angle U about the axis of revolution.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfRevolution_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_SurfaceOfRevolution self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of revolution. It is the curve obtained by rotating the
        meridian through an angle U about the axis of revolution.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfRevolution_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        U is the angle of the rotation around the revolution axis.
        The direction of this axis gives the sense of rotation.
        V is the parameter of the revolved curve.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_SurfaceOfRevolution_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives
        in the directions U and V.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfRevolution_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfRevolution_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.
        Raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfRevolution_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and
        Nv in the direction v.

        Raised if the continuity of the surface is not CNu in the u
        direction and CNv in the v direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.
        The following  functions  evaluates the  local
        derivatives on surface. Useful to manage discontinuities
        on the surface.
        if    Side  =  1  ->  P  =  S( U+,V )
        if    Side  = -1  ->  P  =  S( U-,V )
        else  P  is betveen discontinuities
        can be evaluated using methods  of
        global evaluations    P  =  S( U ,V )

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfRevolution_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_SurfaceOfRevolution self, gp_Trsf T)

        Applies the transformation T to this surface of revolution.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_SurfaceOfRevolution_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_SurfaceOfRevolution self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this surface of revolution.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_SurfaceOfRevolution_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_SurfaceOfRevolution_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_SurfaceOfRevolution_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_SurfaceOfRevolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_SurfaceOfRevolution
Geom_SurfaceOfRevolution_swigregister = _Geom.Geom_SurfaceOfRevolution_swigregister
Geom_SurfaceOfRevolution_swigregister(Geom_SurfaceOfRevolution)

def Geom_SurfaceOfRevolution_get_type_name(*args):
    """
    Geom_SurfaceOfRevolution_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_SurfaceOfRevolution_get_type_name(*args)

def Geom_SurfaceOfRevolution_get_type_descriptor(*args):
    """
    Geom_SurfaceOfRevolution_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_SurfaceOfRevolution_get_type_descriptor(*args)

class Geom_Line(Geom_Curve):
    """
    Describes an infinite line.
    A line is defined and positioned in space with an axis
    (gp_Ax1 object) which gives it an origin and a unit vector.
    The Geom_Line line is parameterized:
    P (U) = O + U*Dir, where:
    - P is the point of parameter U,
    - O is the origin and Dir the unit vector of its positioning axis.
    The parameter range is ] -infinite, +infinite [.
    The orientation of the line is given by the unit vector
    of its positioning axis.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Line(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Line self, gp_Ax1 A1) -> Geom_Line
        __init__(Geom_Line self, gp_Lin L) -> Geom_Line
        __init__(Geom_Line self, gp_Pnt P, gp_Dir V) -> Geom_Line

        Constructs a line passing through point P and parallel to vector V
        (P and V are, respectively, the origin and the unit
        vector of the positioning axis of the line).

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _Geom.new_Geom_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetLin(self, *args):
        """
        SetLin(Geom_Line self, gp_Lin L)

        Set <me> so that <me> has the same geometric properties as L.

        :type L: OCC.wrapper.gp.gp_Lin

        """
        return _Geom.Geom_Line_SetLin(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Geom_Line self, gp_Dir V)

        changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_Line_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Geom_Line self, gp_Pnt P)

        changes the "Location" point (origin) of the line.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Line_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Geom_Line self, gp_Ax1 A1)

        changes the "Location" and a the "Direction" of <me>.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Geom_Line_SetPosition(self, *args)


    def Lin(self, *args):
        """
        Lin(Geom_Line self) -> gp_Lin

        Returns non transient line from gp with the same geometric
        properties as <me>

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _Geom.Geom_Line_Lin(self, *args)


    def Position(self, *args):
        """
        Returns the positioning axis of this line; this is also its local coordinate system.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Geom_Line_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Geom_Line self)

        Changes the orientation of this line. As a result, the
        unit vector of the positioning axis of this line is reversed.


        """
        return _Geom.Geom_Line_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Line self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed line for the
        point of parameter U on this line.
        For a line, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Line_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Line self) -> Standard_Real

        Returns the value of the first parameter of this
        line. This is Standard_Real::RealFirst().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Line_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Line self) -> Standard_Real

        Returns the value of the last parameter of this
        line. This is  Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Line_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Line self) -> Standard_Boolean

        returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Line_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Line self) -> Standard_Boolean

        returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Line_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_Line self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the global continuity of any line.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_Line_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_Line self, Standard_Integer const N) -> Standard_Boolean

        returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Line_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Line self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P (U) = O + U * Dir where O is the "Location" point of the
        line and Dir the direction of the line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Line_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter u and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Line_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2. V2 is a vector with null magnitude
        for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Line_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        V2 and V3 are vectors with null magnitude for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Line_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Line self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Line_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Line self, gp_Trsf T)

        Applies the transformation T to this line.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Line_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Geom_Line self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U> * T.ScaleFactor()

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Line_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_Line self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Line_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Line self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this line.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Line_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Line
Geom_Line_swigregister = _Geom.Geom_Line_swigregister
Geom_Line_swigregister(Geom_Line)

def Geom_Line_get_type_name(*args):
    """
    Geom_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Line_get_type_name(*args)

def Geom_Line_get_type_descriptor(*args):
    """
    Geom_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Line_get_type_descriptor(*args)

class Geom_CartesianPoint(Geom_Point):
    """
    Describes a point in 3D space. A
    Geom_CartesianPoint is defined by a gp_Pnt point,
    with its three Cartesian coordinates X, Y and Z.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_CartesianPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_CartesianPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_CartesianPoint self, gp_Pnt P) -> Geom_CartesianPoint
        __init__(Geom_CartesianPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> Geom_CartesianPoint

        Constructs a point defined by its three Cartesian coordinates X, Y and Z.

        :type X: float
        :type Y: float
        :type Z: float

        """
        this = _Geom.new_Geom_CartesianPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCoord(self, *args):
        """
        SetCoord(Geom_CartesianPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Assigns the coordinates X, Y and Z to this point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_CartesianPoint_SetCoord(self, *args)


    def SetPnt(self, *args):
        """
        SetPnt(Geom_CartesianPoint self, gp_Pnt P)

        Set <me> to P.X(), P.Y(), P.Z() coordinates.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_CartesianPoint_SetPnt(self, *args)


    def SetX(self, *args):
        """
        SetX(Geom_CartesianPoint self, Standard_Real const X)

        Changes the X coordinate of me.

        :type X: float

        """
        return _Geom.Geom_CartesianPoint_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Geom_CartesianPoint self, Standard_Real const Y)

        Changes the Y coordinate of me.

        :type Y: float

        """
        return _Geom.Geom_CartesianPoint_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Geom_CartesianPoint self, Standard_Real const Z)

        Changes the Z coordinate of me.

        :type Z: float

        """
        return _Geom.Geom_CartesianPoint_SetZ(self, *args)


    def Coord(self, *args):
        """
        Coord(Geom_CartesianPoint self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Geom_CartesianPoint_Coord(self, *args)


    def Pnt(self, *args):
        """
        Pnt(Geom_CartesianPoint self) -> gp_Pnt

        Returns a non transient cartesian point with
        the same coordinates as <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_CartesianPoint_Pnt(self, *args)


    def X(self, *args):
        """
        X(Geom_CartesianPoint self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CartesianPoint_X(self, *args)


    def Y(self, *args):
        """
        Y(Geom_CartesianPoint self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CartesianPoint_Y(self, *args)


    def Z(self, *args):
        """
        Z(Geom_CartesianPoint self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CartesianPoint_Z(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_CartesianPoint self, gp_Trsf T)

        Applies the transformation T to this point.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_CartesianPoint_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_CartesianPoint self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this point.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_CartesianPoint_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_CartesianPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_CartesianPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_CartesianPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_CartesianPoint
Geom_CartesianPoint_swigregister = _Geom.Geom_CartesianPoint_swigregister
Geom_CartesianPoint_swigregister(Geom_CartesianPoint)

def Geom_CartesianPoint_get_type_name(*args):
    """
    Geom_CartesianPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_CartesianPoint_get_type_name(*args)

def Geom_CartesianPoint_get_type_descriptor(*args):
    """
    Geom_CartesianPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_CartesianPoint_get_type_descriptor(*args)

class Handle_Geom_Axis1Placement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Axis1Placement self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Axis1Placement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Axis1Placement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Axis1Placement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Axis1Placement self, Geom_Axis1Placement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Axis1Placement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Axis1Placement self, Handle_Geom_Axis1Placement theHandle) -> Handle_Geom_Axis1Placement
        assign(Handle_Geom_Axis1Placement self, Geom_Axis1Placement thePtr) -> Handle_Geom_Axis1Placement
        assign(Handle_Geom_Axis1Placement self, Handle_Geom_Axis1Placement theHandle) -> Handle_Geom_Axis1Placement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Axis1Placement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Axis1Placement self) -> Geom_Axis1Placement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Axis1Placement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Axis1Placement self) -> Geom_Axis1Placement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Axis1Placement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Axis1Placement self) -> Geom_Axis1Placement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Axis1Placement___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Axis1Placement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Axis1Placement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Axis1Placement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Axis1Placement_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Axis1Placement

    def Ax1(self, *args):
        """
        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Handle_Geom_Axis1Placement_Ax1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Axis1Placement self)

        Reverses the direction of the axis placement.


        """
        return _Geom.Handle_Geom_Axis1Placement_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Axis1Placement self) -> Handle_Geom_Axis1Placement

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis1Placement

        """
        return _Geom.Handle_Geom_Axis1Placement_Reversed(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_Axis1Placement self, gp_Dir V)

        Assigns V to the unit vector of this axis.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis1Placement_SetDirection(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Axis1Placement self, gp_Trsf T)

        Applies the transformation T to this axis.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Axis1Placement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Axis1Placement self) -> Handle_Geom_Geometry

        Creates a new object, which is a copy of this axis.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Axis1Placement self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Axis1Placement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Axis1Placement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Axis1Placement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Axis1Placement self, gp_Ax1 A1)

        Assigns A1 as the "main Axis" of this positioning system. This modifies
        - its origin, and
        - its "main Direction".
        If this positioning system is a
        Geom_Axis2Placement, then its "X Direction" and
        "Y Direction" are recomputed.
        Exceptions
        For a Geom_Axis2Placement:
        Standard_ConstructionError if A1 and the
        previous "X Direction" of the coordinate system are parallel.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Axis1Placement_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Axis1Placement self, gp_Pnt P)

        Assigns the point P as the origin of this positioning  system.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis1Placement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_Axis1Placement self, Handle_Geom_AxisPlacement Other) -> Standard_Real

        Computes the angular value, in radians, between the
        "main Direction" of this positioning system and that
        of positioning system Other. The result is a value between 0 and Pi.

        :type Other: OCC.wrapper.Geom.Handle_Geom_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Axis1Placement_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the axis placement.
        For an "Axis2placement" it is the main axis (Location, Direction ).
        For an "Axis1Placement" this method returns a copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Handle_Geom_Axis1Placement_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Direction(Handle_Geom_Axis1Placement self) -> gp_Dir

        Returns the main "Direction" of an axis placement.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis1Placement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Axis1Placement self) -> gp_Pnt

        Returns the Location point (origin) of the axis placement.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis1Placement_Location(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Axis1Placement self, gp_Pnt P)
        Mirror(Handle_Geom_Axis1Placement self, gp_Ax1 A1)
        Mirror(Handle_Geom_Axis1Placement self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Axis1Placement_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Axis1Placement self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Axis1Placement_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Axis1Placement self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Axis1Placement_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Axis1Placement self, gp_Vec V)
        Translate(Handle_Geom_Axis1Placement self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis1Placement_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Axis1Placement self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Axis1Placement self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Axis1Placement self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Axis1Placement self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Axis1Placement self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Axis1Placement self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Axis1Placement self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Axis1Placement self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis1Placement_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Axis1Placement self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Axis1Placement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Axis1Placement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Axis1Placement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Axis1Placement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Axis1Placement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Axis1Placement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Axis1Placement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Axis1Placement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Axis1Placement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Axis1Placement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Axis1Placement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Axis1Placement self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Axis1Placement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Axis1Placement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Axis1Placement_DecrementRefCounter(self, *args)

Handle_Geom_Axis1Placement_swigregister = _Geom.Handle_Geom_Axis1Placement_swigregister
Handle_Geom_Axis1Placement_swigregister(Handle_Geom_Axis1Placement)

def Handle_Geom_Axis1Placement_DownCast(thing):
    return _Geom.Handle_Geom_Axis1Placement_DownCast(thing)
Handle_Geom_Axis1Placement_DownCast = _Geom.Handle_Geom_Axis1Placement_DownCast

class Handle_Geom_OffsetCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_OffsetCurve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_OffsetCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_OffsetCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_OffsetCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_OffsetCurve self, Geom_OffsetCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_OffsetCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_OffsetCurve self, Handle_Geom_OffsetCurve theHandle) -> Handle_Geom_OffsetCurve
        assign(Handle_Geom_OffsetCurve self, Geom_OffsetCurve thePtr) -> Handle_Geom_OffsetCurve
        assign(Handle_Geom_OffsetCurve self, Handle_Geom_OffsetCurve theHandle) -> Handle_Geom_OffsetCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_OffsetCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_OffsetCurve self) -> Geom_OffsetCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_OffsetCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_OffsetCurve self) -> Geom_OffsetCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_OffsetCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_OffsetCurve self) -> Geom_OffsetCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_OffsetCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_OffsetCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_OffsetCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_OffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_OffsetCurve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_OffsetCurve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_OffsetCurve self)

        Changes the orientation of this offset curve.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the
        end point of the reversed curve,
        - the end point of the initial curve becomes the
        start point of the reversed curve, and
        - the first and last parameters are recomputed.


        """
        return _Geom.Handle_Geom_OffsetCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_OffsetCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this offset curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_ReversedParameter(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Handle_Geom_OffsetCurve self, Handle_Geom_Curve C, Standard_Boolean const isNotCheckC0)

        Changes this offset curve by assigning C
        as the basis curve from which it is built.
        If isNotCheckC0 = TRUE checking if basis curve
        has C0-continuity is not made.
        Exceptions
        Standard_ConstructionError if the curve C is not at least "C1" continuous.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type isNotCheckC0: bool

        """
        return _Geom.Handle_Geom_OffsetCurve_SetBasisCurve(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_OffsetCurve self, gp_Dir V)

        Changes this offset curve by assigning V as the
        reference vector used to compute the offset direction.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_OffsetCurve_SetDirection(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Handle_Geom_OffsetCurve self, Standard_Real const D)

        Changes this offset curve by assigning D as the offset value.

        :type D: float

        """
        return _Geom.Handle_Geom_OffsetCurve_SetOffsetValue(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom_OffsetCurve self) -> Handle_Geom_Curve

        Returns the basis curve of this offset curve.
        Note: The basis curve can be an offset curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_OffsetCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_OffsetCurve self) -> GeomAbs_Shape

        Returns the global continuity of this offset curve as a
        value of the GeomAbs_Shape enumeration.
        The degree of continuity of this offset curve is equal
        to the degree of continuity of the basis curve minus 1.
        Continuity of the Offset curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.
        Warnings :
        Returns the continuity of the basis curve - 1.
        The offset curve must have a unique offset direction defined
        at any point.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_OffsetCurve_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference vector of this offset curve.
        Value and derivatives
        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        If T is the first derivative with not null length and
        V the offset direction the relation ||T(U) ^ V|| != 0
        must be satisfied to evaluate the offset curve.
        No check is done at the creation time and we suppose
        in this package that the offset curve is well defined.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_OffsetCurve_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D0(self, *args):
        """
        D0(Handle_Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P)

        Warning! this should not be called
        if the basis curve is not at least C1. Nevertheless
        if used on portion where the curve is C1, it is OK

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Warning! this should not be called
        if the continuity of the basis curve is not C2.
        Nevertheless, it's OK to use it  on portion
        where the curve is C2

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Warning! this should not be called
        if the continuity of the basis curve is not C3.
        Nevertheless, it's OK to use it  on portion
        where the curve is C3

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_OffsetCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_OffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative
        for the order of derivation N.

        The following functions compute the value and derivatives
        on the offset curve and returns the derivatives on the
        basis curve too.
        The computation of the value and derivatives on the basis
        curve are used to evaluate the offset curve

        Warning:
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetCurve_DN(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_OffsetCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        offset curve. The first parameter corresponds to the
        start point of the curve.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_OffsetCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        offset curve. The last parameter
        corresponds to the end point.
        Note: the first and last parameters of this offset curve
        are also the ones of its basis curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_LastParameter(self, *args)


    def Offset(self, *args):
        """
        Offset(Handle_Geom_OffsetCurve self) -> Standard_Real

        Returns the offset value of this offset curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_Offset(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_OffsetCurve self) -> Standard_Boolean

        Returns True if the distance between the start point
        and the end point of the curve is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_OffsetCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of the basis
        curve of this offset curve is at least N + 1.
        This method answer True if the continuity of the basis curve
        is N + 1.  We suppose in this class that a normal direction
        to the basis curve (used to compute the offset curve) is
        defined at any point on the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_OffsetCurve self) -> Standard_Boolean

        Returns true if this offset curve is periodic, i.e. if the
        basis curve of this offset curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_OffsetCurve self) -> Standard_Real

        Returns the period of this offset curve, i.e. the period
        of the basis curve of this offset curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_Period(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_OffsetCurve self, gp_Trsf T)

        Applies the transformation T to this offset curve.
        Note: the basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_OffsetCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_OffsetCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.
        me->Transformed(T)->Value(me->TransformedParameter(U,T))
        is the same point as
        me->Value(U).Transformed(T)
        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_OffsetCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))
        is the same point as
        Value(U).Transformed(T)
        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_OffsetCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this offset curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Copy(self, *args)


    def GetBasisCurveContinuity(self, *args):
        """
        GetBasisCurveContinuity(Handle_Geom_OffsetCurve self) -> GeomAbs_Shape

        Returns continuity of the basis curve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_OffsetCurve_GetBasisCurveContinuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_OffsetCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_OffsetCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OffsetCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_OffsetCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_OffsetCurve_Reversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_OffsetCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_OffsetCurve self, gp_Pnt P)
        Mirror(Handle_Geom_OffsetCurve self, gp_Ax1 A1)
        Mirror(Handle_Geom_OffsetCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_OffsetCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_OffsetCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_OffsetCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_OffsetCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_OffsetCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_OffsetCurve self, gp_Vec V)
        Translate(Handle_Geom_OffsetCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_OffsetCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_OffsetCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_OffsetCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_OffsetCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_OffsetCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_OffsetCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_OffsetCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_OffsetCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_OffsetCurve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_OffsetCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_OffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_OffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_OffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_OffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_OffsetCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_OffsetCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_OffsetCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OffsetCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_OffsetCurve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_OffsetCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_OffsetCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OffsetCurve_DecrementRefCounter(self, *args)

Handle_Geom_OffsetCurve_swigregister = _Geom.Handle_Geom_OffsetCurve_swigregister
Handle_Geom_OffsetCurve_swigregister(Handle_Geom_OffsetCurve)

def Handle_Geom_OffsetCurve_DownCast(thing):
    return _Geom.Handle_Geom_OffsetCurve_DownCast(thing)
Handle_Geom_OffsetCurve_DownCast = _Geom.Handle_Geom_OffsetCurve_DownCast

class Geom_OffsetSurface(Geom_Surface):
    """
    Describes an offset surface in 3D space.
    An offset surface is defined by:
    - the basis surface to which it is parallel, and
    - the distance between the offset surface and its basis surface.
    A point on the offset surface is built by measuring the
    offset value along the normal vector at a point on the
    basis surface. This normal vector is given by the cross
    product D1u^D1v, where D1u and D1v are the
    vectors tangential to the basis surface in the u and v
    parametric directions at this point. The side of the
    basis surface on which the offset is measured
    depends on the sign of the offset value.
    A Geom_OffsetSurface surface can be
    self-intersecting, even if the basis surface does not
    self-intersect. The self-intersecting portions are not
    deleted at the time of construction.
    Warning
    There must be only one normal vector defined at any
    point on the basis surface. This must be verified by the
    user as no check is made at the time of construction
    to detect points with multiple possible normal
    directions (for example, the top of a conical surface).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_OffsetSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_OffsetSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_OffsetSurface self, Handle_Geom_Surface S, Standard_Real const Offset, Standard_Boolean const isNotCheckC0) -> Geom_OffsetSurface

        Constructs a surface offset from the basis surface
        S, where Offset is the distance between the offset
        surface and the basis surface at any point.
        A point on the offset surface is built by measuring
        the offset value along a normal vector at a point on
        S. This normal vector is given by the cross product
        D1u^D1v, where D1u and D1v are the vectors
        tangential to the basis surface in the u and v
        parametric directions at this point. The side of S on
        which the offset value is measured is indicated by
        this normal vector if Offset is positive, or is the
        inverse sense if Offset is negative.
        If isNotCheckC0 = TRUE checking if basis surface has C0-continuity
        is not made.
        Warnings :
        - The offset surface is built with a copy of the
        surface S. Therefore, when S is modified the
        offset surface is not modified.
        - No check is made at the time of construction to
        detect points on S with multiple possible normal directions.
        Raised if S is not at least C1.
        Warnings :
        No check is done to verify that a unique normal direction is
        defined at any point of the basis surface S.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Offset: float
        :type isNotCheckC0: bool

        """
        this = _Geom.new_Geom_OffsetSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetBasisSurface(self, *args):
        """
        SetBasisSurface(Geom_OffsetSurface self, Handle_Geom_Surface S, Standard_Boolean const isNotCheckC0)

        Raised if S is not at least C1.
        Warnings :
        No check is done to verify that a unique normal direction is
        defined at any point of the basis surface S.
        If isNotCheckC0 = TRUE checking if basis surface has C0-continuity
        is not made.
        Exceptions
        Standard_ConstructionError if the surface S is not
        at least "C1" continuous.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type isNotCheckC0: bool

        """
        return _Geom.Geom_OffsetSurface_SetBasisSurface(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Geom_OffsetSurface self, Standard_Real const D)

        Changes this offset surface by assigning D as the offset value.

        :type D: float

        """
        return _Geom.Geom_OffsetSurface_SetOffsetValue(self, *args)


    def Offset(self, *args):
        """
        Offset(Geom_OffsetSurface self) -> Standard_Real

        Returns the offset value of this offset surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetSurface_Offset(self, *args)


    def BasisSurface(self, *args):
        """
        Returns the basis surface of this offset surface.
        Note: The basis surface can be an offset surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _Geom.Geom_OffsetSurface_BasisSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OsculatingSurface(self, *args):
        """
        Returns osculating surface if base surface is B-spline or Bezier

        :rtype: OCC.wrapper.Geom.Handle_Geom_OsculatingSurface

        """
        res = _Geom.Geom_OffsetSurface_OsculatingSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Geom_OffsetSurface self)

        Changes the orientation of this offset surface in the u
        parametric direction. The bounds of the surface
        are not changed but the given parametric direction is reversed.


        """
        return _Geom.Geom_OffsetSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_OffsetSurface self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, produced by reversing the u
        parametric direction of this offset surface, for any
        point of u parameter U  on this offset surface.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_OffsetSurface self)

        Changes the orientation of this offset surface in the v parametric direction. The bounds of the surface
        are not changed but the given parametric direction is reversed.


        """
        return _Geom.Geom_OffsetSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_OffsetSurface self, Standard_Real const V) -> Standard_Real

        Computes the  v parameter on the modified
        surface, produced by reversing the or v
        parametric direction of this offset surface, for any
        point of  v parameter V on this offset surface.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_OffsetSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this offset surface.
        If the surface is infinite, this function can return:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_OffsetSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_OffsetSurface self) -> GeomAbs_Shape

        This method returns the continuity of the basis surface - 1.
        Continuity of the Offset surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.
        Example :
        If the basis surface is C2 in the V direction and C3 in the U
        direction Shape = C1.
        Warnings :
        If the basis surface has a unique normal direction defined at
        any point this method gives the continuity of the offset
        surface otherwise the effective continuity can be lower than
        the continuity of the basis surface - 1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_OffsetSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_OffsetSurface self, Standard_Integer const N) -> Standard_Boolean

        This method answer True if the continuity of the basis surface
        is N + 1 in the U parametric direction. We suppose in this
        class that a unique normal is defined at any point on the basis
        surface.
        Raised if N <0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_OffsetSurface self, Standard_Integer const N) -> Standard_Boolean

        This method answer True if the continuity of the basis surface
        is N + 1 in the V parametric direction. We suppose in this
        class that a unique normal is defined at any point on the basis
        surface.
        Raised if N <0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsCNv(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_OffsetSurface self) -> Standard_Boolean

        Checks whether this offset surface is closed in the u
        parametric direction.
        Returns true if, taking uFirst and uLast as
        the parametric bounds in the u parametric direction,
        the distance between the points P(uFirst,v)
        and P(uLast,v) is less than or equal to
        gp::Resolution() for each value of the   parameter v.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_OffsetSurface self) -> Standard_Boolean

        Checks whether this offset surface is closed in the u
        or v parametric direction. Returns true if taking vFirst and vLast as the
        parametric bounds in the v parametric direction, the
        distance between the points P(u,vFirst) and
        P(u,vLast) is less than or equal to
        gp::Resolution() for each value of the parameter u.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_OffsetSurface self) -> Standard_Boolean

        Returns true if this offset surface is periodic in the u
        parametric direction, i.e. if the basis
        surface of this offset surface is periodic in this direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Geom_OffsetSurface self) -> Standard_Real

        Returns the period of this offset surface in the u
        parametric direction respectively, i.e. the period of the
        basis surface of this offset surface in this parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_OffsetSurface self) -> Standard_Boolean

        Returns true if this offset surface is periodic in the v
        parametric direction, i.e. if the basis
        surface of this offset surface is periodic in this direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Geom_OffsetSurface self) -> Standard_Real

        Returns the period of this offset surface in the v
        parametric direction respectively, i.e. the period of the
        basis surface of this offset surface in this parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_OffsetSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_OffsetSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_OffsetSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_OffsetSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        Te followings methods compute value and derivatives.

        Warnings
        An exception is raised if a unique normal vector is
        not defined on the basis surface for the parametric
        value (U,V).
        No check is done at the creation time and we suppose
        in this package that the offset surface can be defined
        at any point.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_OffsetSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        P (U, V) = Pbasis + Offset * Ndir   where
        Ndir = D1Ubasis ^ D1Vbasis / ||D1Ubasis ^ D1Vbasis|| is the
        normal direction of the basis surface. Pbasis, D1Ubasis,
        D1Vbasis are the point and the first derivatives on the basis
        surface.
        If Ndir is undefined this method computes an approched normal
        direction using the following limited development :
        Ndir = N0 + DNdir/DU + DNdir/DV + Eps with Eps->0 which
        requires to compute the second derivatives on the basis surface.
        If the normal direction cannot be approximate for this order
        of derivation the exception UndefinedValue is raised.

        Raised if the continuity of the basis surface is not C1.
        Raised if the order of derivation required to compute the
        normal direction is greater than the second order.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_OffsetSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the continuity of the basis surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        ---Purpose ;
        Raised if the continuity of the basis surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the continuity of the basis surface is not C4.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and Nv
        in the direction v.
        ---Purpose ;
        Raised if the continuity of the basis surface is not CNu + 1
        in the U direction and CNv + 1 in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        The following methods compute the value and derivatives
        on the offset surface and returns the derivatives on the
        basis surface too.
        The computation of the value and derivatives on the basis
        surface are used to evaluate the offset surface.

        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_OffsetSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_OffsetSurface self, gp_Trsf T)

        Applies the transformation T to this offset surface.
        Note: the basis surface is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_OffsetSurface_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_OffsetSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)
        This methods calls the basis surface method.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_OffsetSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_OffsetSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods calls the basis surface method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_OffsetSurface_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_OffsetSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this offset surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_OffsetSurface_Copy(self, *args)


    def Surface(self, *args):
        """
        Surface(Geom_OffsetSurface self) -> Handle_Geom_Surface

        returns an  equivalent surface of the offset surface
        when  the basis surface   is a canonic  surface or a
        rectangular  limited surface on canonic surface or if
        the offset is null.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Geom_OffsetSurface_Surface(self, *args)


    def UOsculatingSurface(self, *args):
        """
        UOsculatingSurface(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface UOsculSurf) -> Standard_Boolean

        if Standard_True, L is  the local osculating surface
        along U at  the point U,V.   It means that  DL/DU is
        collinear to DS/DU .  If IsOpposite == Standard_True
        these vectors have opposite direction.

        :type U: float
        :type V: float
        :type IsOpposite: bool
        :type UOsculSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_UOsculatingSurface(self, *args)


    def VOsculatingSurface(self, *args):
        """
        VOsculatingSurface(Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface VOsculSurf) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along V at the point U,V.
        It means that  DL/DV is
        collinear to DS/DV .  If IsOpposite == Standard_True
        these vectors have opposite direction.

        :type U: float
        :type V: float
        :type IsOpposite: bool
        :type VOsculSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_OffsetSurface_VOsculatingSurface(self, *args)


    def GetBasisSurfContinuity(self, *args):
        """
        GetBasisSurfContinuity(Geom_OffsetSurface self) -> GeomAbs_Shape

        Returns continuity of the basis surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_OffsetSurface_GetBasisSurfContinuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_OffsetSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_OffsetSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_OffsetSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_OffsetSurface
Geom_OffsetSurface_swigregister = _Geom.Geom_OffsetSurface_swigregister
Geom_OffsetSurface_swigregister(Geom_OffsetSurface)

def Geom_OffsetSurface_get_type_name(*args):
    """
    Geom_OffsetSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_OffsetSurface_get_type_name(*args)

def Geom_OffsetSurface_get_type_descriptor(*args):
    """
    Geom_OffsetSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_OffsetSurface_get_type_descriptor(*args)

class Handle_Geom_Axis2Placement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Axis2Placement self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Axis2Placement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Axis2Placement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Axis2Placement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Axis2Placement self, Geom_Axis2Placement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Axis2Placement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Axis2Placement self, Handle_Geom_Axis2Placement theHandle) -> Handle_Geom_Axis2Placement
        assign(Handle_Geom_Axis2Placement self, Geom_Axis2Placement thePtr) -> Handle_Geom_Axis2Placement
        assign(Handle_Geom_Axis2Placement self, Handle_Geom_Axis2Placement theHandle) -> Handle_Geom_Axis2Placement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Axis2Placement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Axis2Placement self) -> Geom_Axis2Placement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Axis2Placement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Axis2Placement self) -> Geom_Axis2Placement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Axis2Placement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Axis2Placement self) -> Geom_Axis2Placement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Axis2Placement___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Axis2Placement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Axis2Placement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Axis2Placement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Axis2Placement_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Axis2Placement

    def SetAx2(self, *args):
        """
        SetAx2(Handle_Geom_Axis2Placement self, gp_Ax2 A2)

        Assigns the origin and the three unit vectors of A2 to
        this coordinate system.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Axis2Placement_SetAx2(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_Axis2Placement self, gp_Dir V)

        Changes the main direction of the axis placement.
        The "Xdirection" is modified :
        New XDirection = V ^ (Previous_Xdirection ^ V).

        Raised if V and the previous "XDirection" are parallel
        because it is impossible to calculate the new "XDirection"
        and the new "YDirection".

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis2Placement_SetDirection(self, *args)


    def SetXDirection(self, *args):
        """
        SetXDirection(Handle_Geom_Axis2Placement self, gp_Dir Vx)

        Changes the "XDirection" of the axis placement, Vx is the
        new "XDirection". If Vx is not normal to the main direction
        then "XDirection" is computed as follow :
        XDirection = Direction ^ ( Vx ^ Direction).
        The main direction is not modified.
        Raised if Vx and "Direction"  are parallel.

        :type Vx: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis2Placement_SetXDirection(self, *args)


    def SetYDirection(self, *args):
        """
        SetYDirection(Handle_Geom_Axis2Placement self, gp_Dir Vy)

        Changes the "YDirection" of the axis placement, Vy is the
        new "YDirection". If Vy is not normal to the main direction
        then "YDirection" is computed as follow :
        YDirection = Direction ^ ( Vy ^ Direction).
        The main direction is not modified. The "XDirection" is
        modified.
        Raised if Vy and the main direction are parallel.

        :type Vy: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis2Placement_SetYDirection(self, *args)


    def Ax2(self, *args):
        """
        Ax2(Handle_Geom_Axis2Placement self) -> gp_Ax2

        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Axis2Placement_Ax2(self, *args)


    def XDirection(self, *args):
        """
        Returns the "XDirection". This is a unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_Axis2Placement_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the "YDirection". This is a unit vector.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_Axis2Placement_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transform(self, *args):
        """
        Transform(Handle_Geom_Axis2Placement self, gp_Trsf T)

        Transforms an axis placement with a Trsf.
        The "Location" point, the "XDirection" and the
        "YDirection" are transformed with T.  The resulting
        main "Direction" of <me> is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Axis2Placement_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Axis2Placement self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this coordinate system.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Axis2Placement self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Axis2Placement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Axis2Placement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Axis2Placement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Axis2Placement self, gp_Ax1 A1)

        Assigns A1 as the "main Axis" of this positioning system. This modifies
        - its origin, and
        - its "main Direction".
        If this positioning system is a
        Geom_Axis2Placement, then its "X Direction" and
        "Y Direction" are recomputed.
        Exceptions
        For a Geom_Axis2Placement:
        Standard_ConstructionError if A1 and the
        previous "X Direction" of the coordinate system are parallel.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Axis2Placement_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Axis2Placement self, gp_Pnt P)

        Assigns the point P as the origin of this positioning  system.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis2Placement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_Axis2Placement self, Handle_Geom_AxisPlacement Other) -> Standard_Real

        Computes the angular value, in radians, between the
        "main Direction" of this positioning system and that
        of positioning system Other. The result is a value between 0 and Pi.

        :type Other: OCC.wrapper.Geom.Handle_Geom_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Axis2Placement_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the axis placement.
        For an "Axis2placement" it is the main axis (Location, Direction ).
        For an "Axis1Placement" this method returns a copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Handle_Geom_Axis2Placement_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Direction(Handle_Geom_Axis2Placement self) -> gp_Dir

        Returns the main "Direction" of an axis placement.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Axis2Placement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Axis2Placement self) -> gp_Pnt

        Returns the Location point (origin) of the axis placement.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis2Placement_Location(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Axis2Placement self, gp_Pnt P)
        Mirror(Handle_Geom_Axis2Placement self, gp_Ax1 A1)
        Mirror(Handle_Geom_Axis2Placement self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Axis2Placement_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Axis2Placement self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Axis2Placement_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Axis2Placement self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Axis2Placement_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Axis2Placement self, gp_Vec V)
        Translate(Handle_Geom_Axis2Placement self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Axis2Placement_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Axis2Placement self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Axis2Placement self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Axis2Placement self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Axis2Placement self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Axis2Placement self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Axis2Placement self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Axis2Placement self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Axis2Placement self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Axis2Placement_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Axis2Placement self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Axis2Placement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Axis2Placement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Axis2Placement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Axis2Placement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Axis2Placement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Axis2Placement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Axis2Placement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Axis2Placement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Axis2Placement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Axis2Placement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Axis2Placement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Axis2Placement self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Axis2Placement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Axis2Placement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Axis2Placement_DecrementRefCounter(self, *args)

Handle_Geom_Axis2Placement_swigregister = _Geom.Handle_Geom_Axis2Placement_swigregister
Handle_Geom_Axis2Placement_swigregister(Handle_Geom_Axis2Placement)

def Handle_Geom_Axis2Placement_DownCast(thing):
    return _Geom.Handle_Geom_Axis2Placement_DownCast(thing)
Handle_Geom_Axis2Placement_DownCast = _Geom.Handle_Geom_Axis2Placement_DownCast

class Handle_Geom_Ellipse(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Ellipse self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Ellipse_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Ellipse self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Ellipse_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Ellipse self, Geom_Ellipse thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Ellipse_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Ellipse self, Handle_Geom_Ellipse theHandle) -> Handle_Geom_Ellipse
        assign(Handle_Geom_Ellipse self, Geom_Ellipse thePtr) -> Handle_Geom_Ellipse
        assign(Handle_Geom_Ellipse self, Handle_Geom_Ellipse theHandle) -> Handle_Geom_Ellipse

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Ellipse_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Ellipse self) -> Geom_Ellipse

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Ellipse_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Ellipse self) -> Geom_Ellipse

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Ellipse___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Ellipse self) -> Geom_Ellipse

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Ellipse___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Ellipse___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Ellipse___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Ellipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Ellipse_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Ellipse

    def SetElips(self, *args):
        """
        SetElips(Handle_Geom_Ellipse self, gp_Elips E)

        Converts the gp_Elips ellipse E into this ellipse.

        :type E: OCC.wrapper.gp.gp_Elips

        """
        return _Geom.Handle_Geom_Ellipse_SetElips(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_Geom_Ellipse self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this ellipse.
        ConstructionError raised if MajorRadius < MinorRadius.

        :type MajorRadius: float

        """
        return _Geom.Handle_Geom_Ellipse_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_Geom_Ellipse self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this ellipse.
        ConstructionError raised if MajorRadius < MinorRadius or if MinorRadius < 0.

        :type MinorRadius: float

        """
        return _Geom.Handle_Geom_Ellipse_SetMinorRadius(self, *args)


    def Elips(self, *args):
        """
        Elips(Handle_Geom_Ellipse self) -> gp_Elips

        returns the non transient ellipse from gp with the same

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _Geom.Handle_Geom_Ellipse_Elips(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Ellipse self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed ellipse for
        the point of parameter U on this ellipse.
        For an ellipse, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_ReversedParameter(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Handle_Geom_Ellipse self) -> gp_Ax1

        This directrix is the line normal to the XAxis of the ellipse
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the ellipse, where e is the eccentricity of
        the ellipse.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the "Location" point
        of the directrix1. This point is on the positive side of
        the "XAxis".
        Raised if Eccentricity = 0.0. (The ellipse degenerates
        into a circle)

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Handle_Geom_Ellipse self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the ellipse.

        Raised if Eccentricity = 0.0. (The ellipse degenerates into a
        circle).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom_Ellipse self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        the two focus of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Handle_Geom_Ellipse self) -> gp_Pnt

        Returns the first focus of the ellipse. This focus is on the
        positive side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Handle_Geom_Ellipse self) -> gp_Pnt

        Returns the second focus of the ellipse. This focus is on
        the negative side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the major  radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the minor radius of this ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom_Ellipse self) -> Standard_Real

        Returns p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_Parameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the value of the first parameter of this
        ellipse. This is respectively:
        - 0.0, which gives the start point of this ellipse, or
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the value of the  last parameter of this
        ellipse. This is respectively:
        - 2.*Pi, which gives the end point of this ellipse.
        The start point and end point of an ellipse are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Ellipse_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Ellipse self) -> Standard_Boolean

        return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Ellipse_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Ellipse self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cos (U) * XDir + MinorRadius * Sin (U) * YDir
        where C is the center of the ellipse , XDir the direction of
        the "XAxis" and "YDir" the "YAxis" of the ellipse.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Ellipse_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U. The vectors V1 and V2
        are the first and second derivatives at this point.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Ellipse_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Ellipse self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Ellipse_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Ellipse self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this ellipse, computes
        the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Ellipse_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Ellipse self, gp_Trsf T)

        Applies the transformation T to this ellipse.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Ellipse_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Ellipse self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this ellipse.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Ellipse self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Ellipse_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Ellipse_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Ellipse_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Ellipse self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Ellipse self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Ellipse self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Ellipse_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Ellipse self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Ellipse self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Handle_Geom_Ellipse_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Handle_Geom_Ellipse self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom_Ellipse self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Ellipse_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Ellipse self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Handle_Geom_Ellipse_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Ellipse self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Ellipse_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Ellipse self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Ellipse_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Ellipse self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Ellipse self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Ellipse self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Ellipse_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Ellipse self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Ellipse_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Ellipse self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Ellipse self, gp_Pnt P)
        Mirror(Handle_Geom_Ellipse self, gp_Ax1 A1)
        Mirror(Handle_Geom_Ellipse self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Ellipse_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Ellipse self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Ellipse_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Ellipse self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Ellipse_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Ellipse self, gp_Vec V)
        Translate(Handle_Geom_Ellipse self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Ellipse_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Ellipse self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Ellipse self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Ellipse self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Ellipse self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Ellipse self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Ellipse self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Ellipse self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Ellipse self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Ellipse_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Ellipse self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Ellipse_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Ellipse self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Ellipse self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Ellipse_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Ellipse self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Ellipse self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Ellipse_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Ellipse self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Ellipse_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Ellipse self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Ellipse_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Ellipse self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Ellipse_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Ellipse self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Ellipse_DecrementRefCounter(self, *args)

Handle_Geom_Ellipse_swigregister = _Geom.Handle_Geom_Ellipse_swigregister
Handle_Geom_Ellipse_swigregister(Handle_Geom_Ellipse)

def Handle_Geom_Ellipse_DownCast(thing):
    return _Geom.Handle_Geom_Ellipse_DownCast(thing)
Handle_Geom_Ellipse_DownCast = _Geom.Handle_Geom_Ellipse_DownCast

class Geom_Transformation(Standard.Standard_Transient):
    """
    Describes how to construct the following elementary transformations
    - translations,
    - rotations,
    - symmetries,
    - scales.
    The Transformation class can also be used to
    construct complex transformations by combining these
    elementary transformations.
    However, these transformations can never change
    the type of an object. For example, the projection
    transformation can change a circle into an ellipse, and
    therefore change the real type of the object. Such a
    transformation is forbidden in this environment and
    cannot be a Geom_Transformation.
    The transformation can be represented as follow :

    V1   V2   V3    T
    | a11  a12  a13   a14 |   | x |      | x'|
    | a21  a22  a23   a24 |   | y |      | y'|
    | a31  a32  a33   a34 |   | z |   =  | z'|
    |  0    0    0     1  |   | 1 |      | 1 |

    where {V1, V2, V3} defines the vectorial part of the
    transformation and T defines the translation part of
    the transformation.
    Note: Geom_Transformation transformations
    provide the same kind of "geometric" services as
    gp_Trsf ones but have more complex data structures.
    The geometric objects provided by the Geom
    package use gp_Trsf transformations in the syntaxes
    Transform and Transformed.
    Geom_Transformation transformations are used in
    a context where they can be shared by several
    objects contained inside a common data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Transformation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Transformation(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Transformation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Transformation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Transformation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Geom_Transformation self) -> Geom_Transformation
        __init__(Geom_Transformation self, gp_Trsf T) -> Geom_Transformation

        Creates a transient copy of T.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        this = _Geom.new_Geom_Transformation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMirror(self, *args):
        """
        SetMirror(Geom_Transformation self, gp_Pnt thePnt)
        SetMirror(Geom_Transformation self, gp_Ax1 theA1)
        SetMirror(Geom_Transformation self, gp_Ax2 theA2)

        Makes the transformation into a symmetrical transformation
        with respect to a plane.  The plane of the symmetry is
        defined with the axis placement A2. It is the plane
        (Location, XDirection, YDirection).

        :type theA2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Geom_Transformation_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(Geom_Transformation self, gp_Ax1 theA1, Standard_Real const theAng)

        Makes the transformation into a rotation.
        A1 is the axis rotation and Ang is the angular value
        of the rotation in radians.

        :type theA1: OCC.wrapper.gp.gp_Ax1
        :type theAng: float

        """
        return _Geom.Geom_Transformation_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Geom_Transformation self, gp_Pnt thePnt, Standard_Real const theScale)

        Makes the transformation into a scale. P is the center of
        the scale and S is the scaling value.

        :type thePnt: OCC.wrapper.gp.gp_Pnt
        :type theScale: float

        """
        return _Geom.Geom_Transformation_SetScale(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Geom_Transformation self, gp_Ax3 theFromSystem1, gp_Ax3 theToSystem2)
        SetTransformation(Geom_Transformation self, gp_Ax3 theToSystem)

        Makes the transformation allowing passage from the basic
        coordinate system
        {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.), VZ (0., 0. ,1.) }
        to the local coordinate system defined with the Ax2 ToSystem.
        Same utilisation as the previous method. FromSystem1 is
        defaulted to the absolute coordinate system.

        :type theToSystem: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Geom_Transformation_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(Geom_Transformation self, gp_Vec theVec)
        SetTranslation(Geom_Transformation self, gp_Pnt P1, gp_Pnt P2)

        Makes the transformation into a translation from the point
        P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Transformation_SetTranslation(self, *args)


    def SetTrsf(self, *args):
        """
        SetTrsf(Geom_Transformation self, gp_Trsf theTrsf)

        Converts the gp_Trsf transformation T into this transformation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Transformation_SetTrsf(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(Geom_Transformation self) -> Standard_Boolean

        Checks whether this transformation is an indirect
        transformation: returns true if the determinant of the
        matrix of the vectorial part of the transformation is less than 0.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Transformation_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(Geom_Transformation self) -> gp_TrsfForm

        Returns the nature of this transformation as a value
        of the gp_TrsfForm enumeration.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _Geom.Geom_Transformation_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(Geom_Transformation self) -> Standard_Real

        Returns the scale value of the transformation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Transformation_ScaleFactor(self, *args)


    def Trsf(self, *args):
        """
        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _Geom.Geom_Transformation_Trsf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(Geom_Transformation self, Standard_Integer const theRow, Standard_Integer const theCol) -> Standard_Real

        Returns the coefficients of the global matrix of transformation.
        It is a 3 rows X 4 columns matrix.

        Raised if  Row < 1 or Row > 3  or  Col < 1 or Col > 4

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Transformation_Value(self, *args)


    def Invert(self, *args):
        """
        Invert(Geom_Transformation self)

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.


        """
        return _Geom.Geom_Transformation_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(Geom_Transformation self) -> Handle_Geom_Transformation

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Geom_Transformation self, Handle_Geom_Transformation Other) -> Handle_Geom_Transformation

        Computes the transformation composed with Other and <me>.
        <me> * Other.
        Returns a new transformation

        :type Other: OCC.wrapper.Geom.Handle_Geom_Transformation
        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Geom_Transformation self, Handle_Geom_Transformation theOther)

        Computes the transformation composed with Other and <me> .
        <me> = <me> * Other.

        :type theOther: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_Multiply(self, *args)


    def Power(self, *args):
        """
        Power(Geom_Transformation self, Standard_Integer const N)

        Computes the following composition of transformations
        if N > 0  <me> * <me> * .......* <me>.
        if N = 0  Identity
        if N < 0  <me>.Invert() * .........* <me>.Invert()

        Raised if N < 0 and if the transformation is not inversible

        :type N: int

        """
        return _Geom.Geom_Transformation_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(Geom_Transformation self, Standard_Integer const N) -> Handle_Geom_Transformation

        Raised if N < 0 and if the transformation is not inversible

        :type N: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_Powered(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(Geom_Transformation self, Handle_Geom_Transformation Other)

        Computes the matrix of the transformation composed with
        <me> and Other.     <me> = Other * <me>

        :type Other: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_PreMultiply(self, *args)


    def Transforms(self, *args):
        """
        Transforms(Geom_Transformation self)

        Applies the transformation <me> to the triplet {X, Y, Z}.

        :type theX: float
        :type theY: float
        :type theZ: float

        """
        return _Geom.Geom_Transformation_Transforms(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Transformation self) -> Handle_Geom_Transformation

        Creates a new object which is a copy of this transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Geom_Transformation_Copy(self, *args)

    __swig_destroy__ = _Geom.delete_Geom_Transformation
Geom_Transformation_swigregister = _Geom.Geom_Transformation_swigregister
Geom_Transformation_swigregister(Geom_Transformation)

def Geom_Transformation_get_type_name(*args):
    """
    Geom_Transformation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Transformation_get_type_name(*args)

def Geom_Transformation_get_type_descriptor(*args):
    """
    Geom_Transformation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Transformation_get_type_descriptor(*args)

class Handle_Geom_BSplineCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BSplineCurve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BSplineCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BSplineCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BSplineCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BSplineCurve self, Geom_BSplineCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BSplineCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BSplineCurve self, Handle_Geom_BSplineCurve theHandle) -> Handle_Geom_BSplineCurve
        assign(Handle_Geom_BSplineCurve self, Geom_BSplineCurve thePtr) -> Handle_Geom_BSplineCurve
        assign(Handle_Geom_BSplineCurve self, Handle_Geom_BSplineCurve theHandle) -> Handle_Geom_BSplineCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BSplineCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BSplineCurve self) -> Geom_BSplineCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BSplineCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BSplineCurve self) -> Geom_BSplineCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BSplineCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BSplineCurve self) -> Geom_BSplineCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BSplineCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BSplineCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BSplineCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BSplineCurve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BSplineCurve

    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Handle_Geom_BSplineCurve self, Standard_Integer const Degree)

        Increases the degree of this BSpline curve to
        Degree. As a result, the poles, weights and
        multiplicities tables are modified; the knots table is
        not changed. Nothing is done if Degree is less than
        or equal to the current degree.
        Exceptions
        Standard_ConstructionError if Degree is greater than
        Geom_BSplineCurve::MaxDegree().

        :type Degree: int

        """
        return _Geom.Handle_Geom_BSplineCurve_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Handle_Geom_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Handle_Geom_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineCurve_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Handle_Geom_BSplineCurve self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increment  the  multiplicities   of  the knots  in
        [I1,I2] by <M>.

        If <M> is not positive nithing is done.

        For   each  knot   the resulting   multiplicity  is
        limited to the Degree.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineCurve_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineCurve_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Handle_Geom_BSplineCurve self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a set of knots  values in  the sequence of
        knots.

        For each U = Knots(i), M = Mults(i)

        If <U>  is an existing  knot  the  multiplicity is
        increased by  <M> if  <Add>  is True, increased to
        <M> if <Add> is False.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineCurve_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Handle_Geom_BSplineCurve self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces the multiplicity of the knot of index Index
        to M. If M is equal to 0, the knot is removed.
        With a modification of this type, the array of poles is also modified.
        Two different algorithms are systematically used to
        compute the new poles of the curve. If, for each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is less than
        Tolerance, this ensures that the curve is not
        modified by more than Tolerance. Under these
        conditions, true is returned; otherwise, false is returned.
        A low tolerance is used to prevent modification of
        the curve. A high tolerance is used to "smooth" the curve.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table.
        pole insertion and pole removing
        this operation is limited to the Uniform or QuasiUniform
        BSplineCurve. The knot values are modified . If the BSpline is
        NonUniform or Piecewise Bezier an exception Construction error
        is raised.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_RemoveKnot(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_BSplineCurve self)

        Changes the direction of parametrization of <me>. The Knot
        sequence is modified, the FirstParameter and the
        LastParameter are not modified. The StartPoint of the
        initial curve becomes the EndPoint of the reversed curve
        and the EndPoint of the initial curve becomes the StartPoint
        of the reversed curve.


        """
        return _Geom.Handle_Geom_BSplineCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_BSplineCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom_BSplineCurve self, Standard_Real const U1, Standard_Real const U2)

        Modifies this BSpline curve by segmenting it between
        U1 and U2. Either of these values can be outside the
        bounds of the curve, but U2 must be greater than U1.
        All data structure tables of this BSpline curve are
        modified, but the knots located between U1 and U2
        are retained. The degree of the curve is not modified.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        raises if U2 < U1.
        Standard_DomainError if U2 - U1 exceeds the period for periodic curves.
        i.e. ((U2 - U1) - Period) > Precision::PConfusion().

        :type U1: float
        :type U2: float

        """
        return _Geom.Handle_Geom_BSplineCurve_Segment(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Handle_Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Handle_Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Changes the knot of range Index with its multiplicity.
        You can increase the multiplicity of a knot but it is
        not allowed to decrease the multiplicity of an existing knot.

        Raised if K >= Knots(Index+1) or K <= Knots(Index-1).
        Raised if M is greater than Degree or lower than the previous
        multiplicity of knot of range Index.
        Raised if Index < 1 || Index > NbKnots

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineCurve_SetKnot(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Handle_Geom_BSplineCurve self, NCollection_Array1_Standard_Real K)

        Modifies this BSpline curve by assigning the array
        K to its knots table. The multiplicity of the knots is not modified.
        Exceptions
        Standard_ConstructionError if the values in the
        array K are not in ascending order.
        Standard_OutOfRange if the bounds of the array
        K are not respectively 1 and the number of knots of this BSpline curve.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineCurve_SetKnots(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Handle_Geom_BSplineCurve self)

        returns the parameter normalized within
        the period if the curve is periodic : otherwise
        does not do anything

        :type U: float

        """
        return _Geom.Handle_Geom_BSplineCurve_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Handle_Geom_BSplineCurve self)

        Changes this BSpline curve into a periodic curve.
        To become periodic, the curve must first be closed.
        Next, the knot sequence must be periodic. For this,
        FirstUKnotIndex and LastUKnotIndex are used
        to compute I1 and I2, the indexes in the knots
        array of the knots corresponding to the first and
        last parameters of this BSpline curve.
        The period is therefore: Knots(I2) - Knots(I1).
        Consequently, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if this BSpline curve is not closed.


        """
        return _Geom.Handle_Geom_BSplineCurve_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Handle_Geom_BSplineCurve self, Standard_Integer const Index)
        SetOrigin(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Real const Tol)

        Set the origin of a periodic curve at Knot U. If U
        is  not a  knot  of  the  BSpline  a  new knot  is
        inseted. KnotVector and poles are modified.
        Raised if the curve is not periodic

        :type U: float
        :type Tol: float

        """
        return _Geom.Handle_Geom_BSplineCurve_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Handle_Geom_BSplineCurve self)

        Changes this BSpline curve into a non-periodic
        curve. If this curve is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.
        Warning
        If this curve is periodic, as the multiplicity of the first
        and last knots is not modified, and is not equal to
        Degree + 1, where Degree is the degree of
        this BSpline curve, the start and end points of the
        curve are not its first and last poles.


        """
        return _Geom.Handle_Geom_BSplineCurve_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom_BSplineCurve self, Standard_Integer const Index, gp_Pnt P)
        SetPole(Handle_Geom_BSplineCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Modifies this BSpline curve by assigning P to the pole
        of index Index in the poles table.
        This syntax also allows you to modify the
        weight of the modified pole, which becomes Weight.
        In this case, if this BSpline curve is non-rational, it
        can become rational and vice versa.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the poles table.
        Standard_ConstructionError if Weight is negative or null.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BSplineCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom_BSplineCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight for the pole of range Index.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type Weight: float

        """
        return _Geom.Handle_Geom_BSplineCurve_SetWeight(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, Standard_Integer const Index1, Standard_Integer const Index2)

        Moves the point of parameter U of this BSpline curve
        to P. Index1 and Index2 are the indexes in the table
        of poles of this BSpline curve of the first and last
        poles designated to be moved.
        FirstModifiedPole and LastModifiedPole are the
        indexes of the first and last poles which are effectively modified.
        In the event of incompatibility between Index1, Index2 and the value U:
        - no change is made to this BSpline curve, and
        - the FirstModifiedPole and LastModifiedPole are returned null.
        Exceptions
        Standard_OutOfRange if:
        - Index1 is greater than or equal to Index2, or
        - Index1 or Index2 is less than 1 or greater than the
        number of poles of this BSpline curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Index1: int
        :type Index2: int
        :type FirstModifiedPole: int
        :type LastModifiedPole: int

        """
        return _Geom.Handle_Geom_BSplineCurve_MovePoint(self, *args)


    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec Tangent, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Move a point with parameter U to P.
        and makes it tangent at U be Tangent.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Geom.Handle_Geom_BSplineCurve_MovePointAndTangent(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_BSplineCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns the continuity of the curve, the curve is at least C0.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsCN(self, *args)


    def IsG1(self, *args):
        """
        IsG1(Handle_Geom_BSplineCurve self, Standard_Real const theTf, Standard_Real const theTl, Standard_Real const theAngTol) -> Standard_Boolean

        Check if curve has at least G1 continuity in interval [theTf, theTl]
        Returns true if IsCN(1)
        or
        angle betweem "left" and "right" first derivatives at
        knots with C0 continuity is less then theAngTol
        only knots in interval [theTf, theTl] is checked

        :type theTf: float
        :type theTl: float
        :type theAngTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsG1(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_BSplineCurve self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_BSplineCurve self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Geom_BSplineCurve self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BSplineCurve self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BSplineCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Returns the degree of this BSpline curve.
        The degree of a Geom_BSplineCurve curve cannot
        be greater than Geom_BSplineCurve::MaxDegree().
        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this BSpline curve,
        computes the vector corresponding to the Nth derivative.
        Warning
        On a point where the continuity of the curve is not the
        one requested, this function impacts the part defined
        by the parameter with a value greater than U, i.e. the
        part of the curve to the "right" of the singularity.
        Exceptions
        Standard_RangeError if N is less than 1.

        The following functions compute the point of parameter U
        and the derivatives at this point on the B-spline curve
        arc defined between the knot FromK1 and the knot ToK2.
        U can be out of bounds [Knot (FromK1),  Knot (ToK2)] but
        for the computation we only use the definition of the curve
        between these two knots. This method is useful to compute
        local derivative, if the order of continuity of the whole
        curve is not greater enough.    Inside the parametric
        domain Knot (FromK1), Knot (ToK2) the evaluations are
        the same as if we consider the whole definition of the
        curve. Of course the evaluations are different outside
        this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> gp_Pnt

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P)

        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1)

        Raised if the local continuity of the curve is not C1
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the local continuity of the curve is not C2
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the local continuity of the curve is not C3
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> gp_Vec

        Raised if the local continuity of the curve is not CN
        between the knot K1 and the knot K2.
        Raised if FromK1 = ToK2.
        Raised if N < 1.

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineCurve_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom_BSplineCurve self) -> gp_Pnt

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Returns the index in the knot array of the knot
        corresponding to the first or last parameter of this BSpline curve.
        For a BSpline curve, the first (or last) parameter
        (which gives the start (or end) point of the curve) is a
        knot value. However, if the multiplicity of the first (or
        last) knot is less than Degree + 1, where
        Degree is the degree of the curve, it is not the first
        (or last) knot of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_BSplineCurve self) -> Standard_Real

        Returns the value of the first parameter of this
        BSpline curve. This is a knot value.
        The first parameter is the one of the start point of the BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Handle_Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_Knot(self, *args)


    def Knots(self, *args):
        """
        returns the knot values of the B-spline curve;
        Warning
        A knot with a multiplicity greater than 1 is not
        repeated in the knot table. The Multiplicity function
        can be used to obtain the multiplicity of each knot.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineCurve_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotSequence(self, *args):
        """
        returns the knots of the B-spline curve.
        Knots with multiplicit greater than 1 are repeated

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineCurve_KnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KnotDistribution(self, *args):
        """
        KnotDistribution(Handle_Geom_BSplineCurve self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Handle_Geom_BSplineCurve_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Handle_Geom_BSplineCurve self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_BSplineCurve self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Handle_Geom_BSplineCurve self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Handle_Geom_BSplineCurve_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Handle_Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        returns the multiplicity of the knots of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Handle_Geom_BSplineCurve_Multiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbKnots(self, *args):
        """
        NbKnots(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Handle_Geom_BSplineCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline curve;

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Geom.Handle_Geom_BSplineCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom_BSplineCurve self) -> gp_Pnt

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Handle_Geom_BSplineCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom_BSplineCurve self, NCollection_Array1_Standard_Real W)
        Weights(Handle_Geom_BSplineCurve self) -> NCollection_Array1_Standard_Real

        Returns the weights of the B-spline curve;

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BSplineCurve self, gp_Trsf T)

        Applies the transformation T to this BSpline curve.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BSplineCurve_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom_BSplineCurve self, Standard_Real const Tolerance3D)

        Computes for this BSpline curve the parametric
        tolerance UTolerance for a given 3D tolerance Tolerance3D.
        If f(t) is the equation of this BSpline curve,
        UTolerance ensures that:
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Geom.Handle_Geom_BSplineCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BSplineCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this BSpline curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Copy(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Geom_BSplineCurve self, Handle_Geom_BSplineCurve theOther, Standard_Real const thePreci) -> Standard_Boolean

        Comapare two Bspline curve on identity;

        :type theOther: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type thePreci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsEqual(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BSplineCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BSplineCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BSplineCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BSplineCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_BSplineCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BSplineCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_BSplineCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BSplineCurve_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_BSplineCurve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BSplineCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BSplineCurve self, gp_Pnt P)
        Mirror(Handle_Geom_BSplineCurve self, gp_Ax1 A1)
        Mirror(Handle_Geom_BSplineCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BSplineCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BSplineCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BSplineCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BSplineCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BSplineCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BSplineCurve self, gp_Vec V)
        Translate(Handle_Geom_BSplineCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BSplineCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BSplineCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BSplineCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BSplineCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BSplineCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BSplineCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BSplineCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BSplineCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BSplineCurve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BSplineCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BSplineCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BSplineCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BSplineCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BSplineCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BSplineCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BSplineCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BSplineCurve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BSplineCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BSplineCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineCurve_DecrementRefCounter(self, *args)

Handle_Geom_BSplineCurve_swigregister = _Geom.Handle_Geom_BSplineCurve_swigregister
Handle_Geom_BSplineCurve_swigregister(Handle_Geom_BSplineCurve)

def Handle_Geom_BSplineCurve_DownCast(thing):
    return _Geom.Handle_Geom_BSplineCurve_DownCast(thing)
Handle_Geom_BSplineCurve_DownCast = _Geom.Handle_Geom_BSplineCurve_DownCast

class Handle_Geom_BezierSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BezierSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BezierSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BezierSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BezierSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BezierSurface self, Geom_BezierSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BezierSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BezierSurface self, Handle_Geom_BezierSurface theHandle) -> Handle_Geom_BezierSurface
        assign(Handle_Geom_BezierSurface self, Geom_BezierSurface thePtr) -> Handle_Geom_BezierSurface
        assign(Handle_Geom_BezierSurface self, Handle_Geom_BezierSurface theHandle) -> Handle_Geom_BezierSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BezierSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BezierSurface self) -> Geom_BezierSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BezierSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BezierSurface self) -> Geom_BezierSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BezierSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BezierSurface self) -> Geom_BezierSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BezierSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BezierSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BezierSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BezierSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BezierSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BezierSurface

    def ExchangeUV(self, *args):
        """
        ExchangeUV(Handle_Geom_BezierSurface self)

        Exchanges the direction U and V on a Bezier surface
        As a consequence:
        - the poles and weights tables are transposed,
        - degrees, rational characteristics and so on are
        exchanged between the two parametric directions, and
        - the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_BezierSurface_ExchangeUV(self, *args)


    def Increase(self, *args):
        """
        Increase(Handle_Geom_BezierSurface self, Standard_Integer const UDeg, Standard_Integer const VDeg)

        Increases the degree of this Bezier surface in the two parametric directions.

        Raised if UDegree < UDegree <me>  or VDegree < VDegree <me>
        Raised if the degree of the surface is greater than MaxDegree
        in one of the two directions U or V.

        :type UDeg: int
        :type VDeg: int

        """
        return _Geom.Handle_Geom_BezierSurface_Increase(self, *args)


    def InsertPoleColAfter(self, *args):
        """
        InsertPoleColAfter(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleColAfter(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a column of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Vindex < 1 or VIndex > NbVPoles.
        Raised if
        . VDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbUPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_InsertPoleColAfter(self, *args)


    def InsertPoleColBefore(self, *args):
        """
        InsertPoleColBefore(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleColBefore(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a column of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Vindex < 1 or VIndex > NbVPoles.
        Raised if :
        . VDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbUPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_InsertPoleColBefore(self, *args)


    def InsertPoleRowAfter(self, *args):
        """
        InsertPoleRowAfter(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleRowAfter(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a row of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Uindex < 1 or UIndex > NbUPoles.
        Raised if :
        . UDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbVPoles
        . a weight value is lower or equal to Resolution from
        package gp

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_InsertPoleRowAfter(self, *args)


    def InsertPoleRowBefore(self, *args):
        """
        InsertPoleRowBefore(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        InsertPoleRowBefore(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Inserts a row of poles and weights.
        If the surface was non-rational it can become rational.

        Raised if Uindex < 1 or UIndex > NbUPoles.
        Raised if :
        . UDegree is greater than MaxDegree.
        . the Length of CPoles is not equal to NbVPoles
        . a weight value is lower or equal to Resolution from
        pacakage gp

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_InsertPoleRowBefore(self, *args)


    def RemovePoleCol(self, *args):
        """
        RemovePoleCol(Handle_Geom_BezierSurface self, Standard_Integer const VIndex)

        Removes a column of poles.
        If the surface was rational it can become non-rational.

        Raised if NbVPoles <= 2 after removing, a Bezier surface
        must have at least two columns of poles.
        Raised if Vindex < 1 or VIndex > NbVPoles

        :type VIndex: int

        """
        return _Geom.Handle_Geom_BezierSurface_RemovePoleCol(self, *args)


    def RemovePoleRow(self, *args):
        """
        RemovePoleRow(Handle_Geom_BezierSurface self, Standard_Integer const UIndex)

        Removes a row of poles.
        If the surface was rational it can become non-rational.

        Raised if NbUPoles <= 2 after removing, a Bezier surface
        must have at least two rows of poles.
        Raised if Uindex < 1 or UIndex > NbUPoles

        :type UIndex: int

        """
        return _Geom.Handle_Geom_BezierSurface_RemovePoleRow(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom_BezierSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Modifies this Bezier surface by segmenting it
        between U1 and U2 in the u parametric direction,
        and between V1 and V2 in the v parametric
        direction. U1, U2, V1, and V2 can be outside the
        bounds of this surface.
        - U1 and U2 isoparametric Bezier curves,
        segmented between V1 and V2, become the two
        bounds of the surface in the v parametric
        direction (0. and 1. u isoparametric curves).
        - V1 and V2 isoparametric Bezier curves,
        segmented between U1 and U2, become the two
        bounds of the surface in the u parametric
        direction (0. and 1. v isoparametric curves).
        The poles and weights tables are modified, but the
        degree of this surface in the u and v parametric
        directions does not change.
        U1 can be greater than U2, and V1 can be greater
        than V2. In these cases, the corresponding
        parametric direction is inverted. The orientation of
        the surface is inverted if one (and only one)
        parametric direction is inverted.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BezierSurface_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P)
        SetPole(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weight of range UIndex, VIndex.
        If the surface <me> is not rational it can become rational.
        if the surface was rational it can become non-rational.

        raises if  UIndex < 1 or UIndex > NbUPoles  or  VIndex < 1
        or VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierSurface_SetPole(self, *args)


    def SetPoleCol(self, *args):
        """
        SetPoleCol(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleCol(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a column of poles.
        If the surface was rational it can become non-rational
        If the surface was non-rational it can become rational.
        The length of CPoles can be lower but not greater than NbUPoles
        so you can modify just a part of the column.
        Raised if VIndex < 1 or  VIndex > NbVPoles

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbUPoles
        Raised if CPoleWeights and CPoles have not the same bounds.
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_SetPoleCol(self, *args)


    def SetPoleRow(self, *args):
        """
        SetPoleRow(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleRow(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a row of poles and weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoles can be lower but not greater than NbVPoles
        so you can modify just a part of the row.
        Raised if UIndex < 1 or  UIndex > NbUPoles

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbVPoles
        Raised if CPoleWeights and CPoles have not the same bounds.
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from gp.

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_SetPoleRow(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, Standard_Real const Weight)

        Modifies the weight of the pole of range UIndex, VIndex.
        If the surface was non-rational it can become rational.
        If the surface was rational it can become non-rational.

        Raised if UIndex < 1  or  UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierSurface_SetWeight(self, *args)


    def SetWeightCol(self, *args):
        """
        SetWeightCol(Handle_Geom_BezierSurface self, Standard_Integer const VIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a column of weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoleWeights can be lower but not greater than
        NbUPoles.
        Raised if VIndex < 1 or  VIndex > NbVPoles

        Raised if CPoleWeights.Lower() < 1 or CPoleWeights.Upper() >
        NbUPoles
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type VIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_SetWeightCol(self, *args)


    def SetWeightRow(self, *args):
        """
        SetWeightRow(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Modifies a row of weights.
        If the surface was rational it can become non-rational.
        If the surface was non-rational it can become rational.
        The length of CPoleWeights can be lower but not greater than
        NbVPoles.
        Raised if UIndex < 1 or  UIndex > NbUPoles

        Raised if CPoleWeights.Lower() < 1 or CPoleWeights.Upper() >
        NbVPoles
        Raised if one of the weight value CPoleWeights (i) is lower
        or equal to Resolution from package gp.

        :type UIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_SetWeightRow(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_BezierSurface self)

        Changes the orientation of this Bezier surface in the
        u  parametric direction. The bounds of the
        surface are not changed, but the given parametric
        direction is reversed. Hence, the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_BezierSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_BezierSurface self, Standard_Real const U) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, produced by reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this Bezier surface.
        In the case of a Bezier surface, these functions return respectively:
        - 1.-U, or 1.-V.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_BezierSurface self)

        Changes the orientation of this Bezier surface in the
        v parametric direction. The bounds of the
        surface are not changed, but the given parametric
        direction is reversed. Hence, the orientation of the
        surface is reversed.


        """
        return _Geom.Handle_Geom_BezierSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_BezierSurface self, Standard_Real const V) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, produced by reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this Bezier surface.
        In the case of a Bezier surface, these functions return respectively:
        - 1.-U, or 1.-V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_BezierSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this Bezier surface.
        In the case of a Bezier surface, this function returns
        U1 = 0, V1 = 0, U2 = 1, V2 = 1.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BezierSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BezierSurface self) -> GeomAbs_Shape

        Returns the continuity of the surface CN : the order of
        continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BezierSurface_Continuity(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes P, the point of parameters (U, V) of this Bezier surface, and
        - one or more of the following sets of vectors:
        - D1U and D1V, the first derivative vectors at this point,
        - D2U, D2V and D2UV, the second derivative
        vectors at this point,
        - D3U, D3V, D3UUV and D3UVV, the third
        derivative vectors at this point.
        Note: The parameters U and V can be outside the bounds of the surface.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the u
        parametric direction, and Nv in the v parametric
        direction, at the point of parameters (U, V) of this Bezier surface.
        Note: The parameters U and V can be outside the bounds of the surface.
        Exceptions
        Standard_RangeError if:
        - Nu + Nv is less than 1, or Nu or Nv is negative.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierSurface_DN(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Handle_Geom_BezierSurface self) -> Standard_Integer

        Returns the number of poles in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_NbUPoles(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Handle_Geom_BezierSurface self) -> Standard_Integer

        Returns the number of poles in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_NbVPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range UIndex, VIndex
        Raised if UIndex < 1 or UIndex > NbUPoles, or
        VIndex < 1 or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Handle_Geom_BezierSurface_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the Bezier surface.

        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _Geom.Handle_Geom_BezierSurface_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(Handle_Geom_BezierSurface self) -> Standard_Integer

        Returns the degree of the surface in the U direction it is
        NbUPoles - 1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_UDegree(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_BezierSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve. For a Bezier surface the
        UIso curve is a Bezier curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BezierSurface_UIso(self, *args)


    def VDegree(self, *args):
        """
        VDegree(Handle_Geom_BezierSurface self) -> Standard_Integer

        Returns the degree of the surface in the V direction it is
        NbVPoles - 1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_VDegree(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_BezierSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve. For a Bezier surface the
        VIso  curve is a Bezier curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BezierSurface_VIso(self, *args)


    def Weight(self, *args):
        """
        Weight(Handle_Geom_BezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Standard_Real

        Returns the weight of range UIndex, VIndex

        Raised if UIndex < 1 or UIndex > NbUPoles, or
        VIndex < 1 or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierSurface_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom_BezierSurface self, NCollection_Array2_Standard_Real W)
        Weights(Handle_Geom_BezierSurface self) -> NCollection_Array2_Standard_Real

        Returns the weights of the Bezier surface.

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _Geom.Handle_Geom_BezierSurface_Weights(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns True if the first control points row and the
        last control points row are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns True if the first control points column
        and the last control points column are identical.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_BezierSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True, a Bezier surface is always  CN

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_BezierSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True, a BezierSurface is always  CN

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsVPeriodic(self, *args)


    def IsURational(self, *args):
        """
        IsURational(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns False if the weights are identical in the U direction,
        The tolerance criterion is Resolution from package gp.
        Example :
        |1.0, 1.0, 1.0|
        if Weights =  |0.5, 0.5, 0.5|   returns False
        |2.0, 2.0, 2.0|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsURational(self, *args)


    def IsVRational(self, *args):
        """
        IsVRational(Handle_Geom_BezierSurface self) -> Standard_Boolean

        Returns False if the weights are identical in the V direction,
        The tolerance criterion is Resolution from package gp.
        Example :
        |1.0, 2.0, 0.5|
        if Weights =  |1.0, 2.0, 0.5|   returns False
        |1.0, 2.0, 0.5|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsVRational(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BezierSurface self, gp_Trsf T)

        Applies the transformation T to this Bezier surface.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BezierSurface_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom_BezierSurface self) -> Standard_Integer

        Returns the value of the maximum polynomial degree of a
        Bezier surface. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom_BezierSurface self, Standard_Real const Tolerance3D)

        Computes two tolerance values for this Bezier
        surface, based on the given tolerance in 3D space
        Tolerance3D. The tolerances computed are:
        - UTolerance in the u parametric direction, and
        - VTolerance in the v parametric direction.
        If f(u,v) is the equation of this Bezier surface,
        UTolerance and VTolerance guarantee that:
        | u1 - u0 | < UTolerance and
        | v1 - v0 | < VTolerance
        ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float
        :type VTolerance: float

        """
        return _Geom.Handle_Geom_BezierSurface_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BezierSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this Bezier surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BezierSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BezierSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BezierSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BezierSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_BezierSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BezierSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_BezierSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BezierSurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_BezierSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BezierSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BezierSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_BezierSurface_ParametricTransformation(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_BezierSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_BezierSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BezierSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BezierSurface self, gp_Pnt P)
        Mirror(Handle_Geom_BezierSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_BezierSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BezierSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BezierSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BezierSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BezierSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BezierSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BezierSurface self, gp_Vec V)
        Translate(Handle_Geom_BezierSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BezierSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BezierSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BezierSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BezierSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BezierSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BezierSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BezierSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BezierSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BezierSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BezierSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BezierSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BezierSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BezierSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BezierSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BezierSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BezierSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BezierSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BezierSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BezierSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BezierSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierSurface_DecrementRefCounter(self, *args)

Handle_Geom_BezierSurface_swigregister = _Geom.Handle_Geom_BezierSurface_swigregister
Handle_Geom_BezierSurface_swigregister(Handle_Geom_BezierSurface)

def Handle_Geom_BezierSurface_DownCast(thing):
    return _Geom.Handle_Geom_BezierSurface_DownCast(thing)
Handle_Geom_BezierSurface_DownCast = _Geom.Handle_Geom_BezierSurface_DownCast

class Geom_BezierCurve(Geom_BoundedCurve):
    """
    Describes a rational or non-rational Bezier curve
    - a non-rational Bezier curve is defined by a table of
    poles (also called control points),
    - a rational Bezier curve is defined by a table of
    poles with varying weights.
    These data are manipulated by two parallel arrays:
    - the poles table, which is an array of gp_Pnt points, and
    - the weights table, which is an array of reals.
    The bounds of these arrays are 1 and "the number of "poles" of the curve.
    The poles of the curve are "control points" used to deform the curve.
    The first pole is the start point of the curve, and the
    last pole is the end point of the curve. The segment
    that joins the first pole to the second pole is the
    tangent to the curve at its start point, and the
    segment that joins the last pole to the
    second-from-last pole is the tangent to the curve at its end point.
    It is more difficult to give a geometric signification to
    the weights but they are useful for providing the exact
    representations of arcs of a circle or ellipse.
    Moreover, if the weights of all poles are equal, the
    curve is polynomial; it is therefore a non-rational
    curve. The non-rational curve is a special and
    frequently used case. The weights are defined and
    used only in the case of a rational curve.
    The degree of a Bezier curve is equal to the number
    of poles, minus 1. It must be greater than or equal to
    1. However, the degree of a Geom_BezierCurve
    curve is limited to a value (25) which is defined and
    controlled by the system. This value is returned by the function MaxDegree.
    The parameter range for a Bezier curve is [ 0, 1 ].
    If the first and last control points of the Bezier curve
    are the same point then the curve is closed. For
    example, to create a closed Bezier curve with four
    control points, you have to give the set of control
    points P1, P2, P3 and P1.
    The continuity of a Bezier curve is infinite.
    It is not possible to build a Bezier curve with negative
    weights. We consider that a weight value is zero if it
    is less than or equal to gp::Resolution(). We
    also consider that two weight values W1 and W2 are equal if:
    |W2 - W1| <= gp::Resolution().
    Warning
    - When considering the continuity of a closed Bezier
    curve at the junction point, remember that a curve
    of this type is never periodic. This means that the
    derivatives for the parameter u = 0 have no
    reason to be the same as the derivatives for the
    parameter u = 1 even if the curve is closed.
    - The length of a Bezier curve can be null.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_BezierCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_BezierCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_BezierCurve self, NCollection_Array1_gp_Pnt CurvePoles) -> Geom_BezierCurve
        __init__(Geom_BezierCurve self, NCollection_Array1_gp_Pnt CurvePoles, NCollection_Array1_Standard_Real PoleWeights) -> Geom_BezierCurve

        Creates a rational Bezier curve with the set of poles
        CurvePoles and the set of weights  PoleWeights .
        If all the weights are identical the curve is considered
        as non rational. Raises ConstructionError if
        the number of poles is greater than  MaxDegree + 1 or lower
        than 2 or CurvePoles and CurveWeights have not the same length
        or one weight value is lower or equal to Resolution from package gp.

        :type CurvePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type PoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _Geom.new_Geom_BezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Increase(self, *args):
        """
        Increase(Geom_BezierCurve self, Standard_Integer const Degree)

        Increases the degree of a bezier curve. Degree is the new
        degree of <me>. Raises ConstructionError
        if Degree is greater than MaxDegree or lower than 2
        or lower than the initial degree of <me>.

        :type Degree: int

        """
        return _Geom.Geom_BezierCurve_Increase(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        InsertPoleAfter(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Inserts a pole with its weight in the set of poles after the
        pole of range Index. If the curve was non rational it can
        become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.
        Raised if Weight is lower or equal to Resolution from package gp.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BezierCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        InsertPoleBefore(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Inserts a pole with its weight in the set of poles after
        the pole of range Index. If the curve was non rational it
        can become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.
        Raised if Weight is lower or equal to Resolution from
        package gp.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BezierCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Geom_BezierCurve self, Standard_Integer const Index)

        Removes the pole of range Index.
        If the curve was rational it can become non rational.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Degree is lower than 2.

        :type Index: int

        """
        return _Geom.Geom_BezierCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Geom_BezierCurve self)

        Reverses the direction of parametrization of <me>
        Value (NewU) =  Value (1 - OldU)


        """
        return _Geom.Geom_BezierCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_BezierCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns 1-U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom_BezierCurve self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2 which can be out
        of the bounds of the curve. The curve is oriented from U1
        to U2.
        The control points are modified, the first and the last point
        are not the same but the parametrization range is [0, 1]
        else it could not be a Bezier curve.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.

        :type U1: float
        :type U2: float

        """
        return _Geom.Geom_BezierCurve_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        SetPole(Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weights of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Geom_BezierCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Geom_BezierCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight of the pole of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type Weight: float

        """
        return _Geom.Geom_BezierCurve_SetWeight(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_BezierCurve self) -> Standard_Boolean

        Returns True if the distance between the first point
        and the last point of the curve is lower or equal to
        the Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Geom_BezierCurve self, Standard_Integer const N) -> Standard_Boolean

        Continuity of the curve, returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_BezierCurve self) -> Standard_Boolean

        Returns True if the parametrization of a curve is periodic.
        (P(u) = P(u + T) T = constante)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Geom_BezierCurve self) -> Standard_Boolean

        Returns false if all the weights are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_BezierCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Geom_BezierCurve self) -> GeomAbs_Shape

        a Bezier curve is CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Geom_BezierCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Geom_BezierCurve self) -> Standard_Integer

        Returns the polynomial degree of the curve.
        it is the number of poles - 1
        point P and derivatives (V1, V2, V3) computation
        The Bezier Curve has a Polynomial representation so the
        parameter U can be out of the bounds of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Geom_BezierCurve self, Standard_Real const U, gp_Pnt P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BezierCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        For this Bezier curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Note: the parameter U can be outside the bounds of the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_BezierCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this Bezier curve,
        computes the vector corresponding to the Nth derivative.
        Note: the parameter U can be outside the bounds of the curve.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_BezierCurve_DN(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Geom_BezierCurve self) -> gp_Pnt

        Returns Value (U=0.), it is the first control point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BezierCurve_StartPoint(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Geom_BezierCurve self) -> gp_Pnt

        Returns Value (U=1.), it is the last control point of the Bezier curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_BezierCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_BezierCurve self) -> Standard_Real

        Returns the value of the first  parameter of this
        Bezier curve. This is 0.0, which gives the start point of this Bezier curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_BezierCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        Bezier curve. This is  1.0, which gives the end point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierCurve_LastParameter(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Geom_BezierCurve self) -> Standard_Integer

        Returns the number of poles of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Geom_BezierCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns all the poles of the curve.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Geom.Geom_BezierCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Weight(self, *args):
        """
        Weight(Geom_BezierCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_BezierCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Geom_BezierCurve self, NCollection_Array1_Standard_Real W)
        Weights(Geom_BezierCurve self) -> NCollection_Array1_Standard_Real

        Returns all the weights of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Geom_BezierCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_BezierCurve self, gp_Trsf T)

        Applies the transformation T to this Bezier curve.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_BezierCurve_Transform(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum polynomial degree
        of any Geom_BezierCurve curve. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Geom_BezierCurve_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def Resolution(self, *args):
        """
        Resolution(Geom_BezierCurve self, Standard_Real const Tolerance3D)

        Computes for this Bezier curve the parametric
        tolerance UTolerance for a given 3D tolerance Tolerance3D.
        If f(t) is the equation of this Bezier curve,
        UTolerance ensures that:
        |t1-t0| < UTolerance ===> |f(t1)-f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Geom.Geom_BezierCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_BezierCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this Bezier curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_BezierCurve_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_BezierCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_BezierCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_BezierCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_BezierCurve
Geom_BezierCurve_swigregister = _Geom.Geom_BezierCurve_swigregister
Geom_BezierCurve_swigregister(Geom_BezierCurve)

def Geom_BezierCurve_MaxDegree(*args):
    """
    Geom_BezierCurve_MaxDegree() -> Standard_Integer

    Returns the value of the maximum polynomial degree
    of any Geom_BezierCurve curve. This value is 25.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom.Geom_BezierCurve_MaxDegree(*args)

def Geom_BezierCurve_get_type_name(*args):
    """
    Geom_BezierCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_BezierCurve_get_type_name(*args)

def Geom_BezierCurve_get_type_descriptor(*args):
    """
    Geom_BezierCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_BezierCurve_get_type_descriptor(*args)

class Geom_Plane(Geom_ElementarySurface):
    """
    Describes a plane in 3D space.
    A plane is positioned in space by a coordinate system
    (a gp_Ax3 object) such that the plane is defined by
    the origin, "X Direction" and "Y Direction" of this
    coordinate system.
    This coordinate system is the "local coordinate
    system" of the plane. The following apply:
    - Its "X Direction" and "Y Direction" are respectively
    the u and v parametric directions of the plane.
    - Its origin is the origin of the u and v parameters
    (also called the "origin" of the plane).
    - Its "main Direction" is a vector normal to the plane.
    This normal vector gives the orientation of the
    plane only if the local coordinate system is "direct".
    (The orientation of the plane is always defined by
    the "X Direction" and the "Y Direction" of its local
    coordinate system.)
    The parametric equation of the plane is:
    P(u, v) = O + u*XDir + v*YDir
    where O, XDir and YDir are respectively the
    origin, the "X Direction" and the "Y Direction" of the
    local coordinate system of the plane.
    The parametric range of the two parameters u and v
    is ] -infinity, +infinity [.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Plane
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Plane(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Plane self, gp_Ax3 A3) -> Geom_Plane
        __init__(Geom_Plane self, gp_Pln Pl) -> Geom_Plane
        __init__(Geom_Plane self, gp_Pnt P, gp_Dir V) -> Geom_Plane
        __init__(Geom_Plane self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D) -> Geom_Plane

        Creates a plane from its cartesian equation :
        Ax + By + Cz + D = 0.0

        Raised if Sqrt (A*A + B*B + C*C) <= Resolution from gp

        :type A: float
        :type B: float
        :type C: float
        :type D: float

        """
        this = _Geom.new_Geom_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPln(self, *args):
        """
        SetPln(Geom_Plane self, gp_Pln Pl)

        Set <me> so that <me> has the same geometric properties as Pl.

        :type Pl: OCC.wrapper.gp.gp_Pln

        """
        return _Geom.Geom_Plane_SetPln(self, *args)


    def Pln(self, *args):
        """
        Pln(Geom_Plane self) -> gp_Pln

        Converts this plane into a gp_Pln plane.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _Geom.Geom_Plane_Pln(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_Plane self)

        Changes the orientation of this plane in the u (or v)
        parametric direction. The bounds of the plane are not
        changed but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Geom_Plane_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_Plane self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        plane, produced when reversing the u
        parametric of this plane, for any point of u parameter U  on this plane.
        In the case of a plane, these methods return - -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Plane_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_Plane self)

        Changes the orientation of this plane in the u (or v)
        parametric direction. The bounds of the plane are not
        changed but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Geom_Plane_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_Plane self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        plane, produced when reversing the  v
        parametric of this plane, for any point of v parameter V on this plane.
        In the case of a plane, these methods return -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Plane_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_Plane self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are the new values of U,V after calling
        me->TranformParameters(U,V,T)
        This methods multiplies U and V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Plane_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_Plane self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by
        me->ParametricTransformation(T)
        This  methods  returns  a scale  centered  on  the
        origin with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_Plane_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_Plane self)

        Returns the parametric bounds U1, U2, V1 and V2 of this plane.
        Because a plane is an infinite surface, the following is always true:
        - U1 = V1 =   Standard_Real::RealFirst()
        - U2 = V2 =   Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_Plane_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Geom_Plane self)

        Computes the normalized coefficients of the plane's
        cartesian equation : Ax + By + Cz + D = 0.0

        :type A: float
        :type B: float
        :type C: float
        :type D: float

        """
        return _Geom.Geom_Plane_Coefficients(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_Plane self) -> Standard_Boolean

        return False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Plane_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_Plane self) -> Standard_Boolean

        return False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Plane_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_Plane self) -> Standard_Boolean

        return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Plane_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_Plane self) -> Standard_Boolean

        return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Plane_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_Plane self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        This is a Line parallel to the YAxis of the plane.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_Plane_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_Plane self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        This is a Line parallel to the XAxis of the plane.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_Plane_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point P (U, V) on <me>.
        P = O + U * XDir + V * YDir.
        where O is the "Location" point of the plane, XDir the
        "XDirection" and YDir the "YDirection" of the plane's local
        coordinate system.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Plane_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Plane_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Plane_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the
        third derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Plane_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Plane self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Plane_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Plane self, gp_Trsf T)

        Applies the transformation T to this plane.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Plane_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Plane self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Plane_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Plane_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Plane_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Plane
Geom_Plane_swigregister = _Geom.Geom_Plane_swigregister
Geom_Plane_swigregister(Geom_Plane)

def Geom_Plane_get_type_name(*args):
    """
    Geom_Plane_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Plane_get_type_name(*args)

def Geom_Plane_get_type_descriptor(*args):
    """
    Geom_Plane_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Plane_get_type_descriptor(*args)

class Handle_Geom_Point(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Point self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Point_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Point self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Point_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Point self, Geom_Point thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Point_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Point self, Handle_Geom_Point theHandle) -> Handle_Geom_Point
        assign(Handle_Geom_Point self, Geom_Point thePtr) -> Handle_Geom_Point
        assign(Handle_Geom_Point self, Handle_Geom_Point theHandle) -> Handle_Geom_Point

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Point_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Point self) -> Geom_Point

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Point_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Point self) -> Geom_Point

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Point___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Point self) -> Geom_Point

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Point___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Point___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Point___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Point_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Point

    def Coord(self, *args):
        """
        Coord(Handle_Geom_Point self)

        returns the Coordinates of <me>.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_Point_Coord(self, *args)


    def Pnt(self, *args):
        """
        Pnt(Handle_Geom_Point self) -> gp_Pnt

        returns a non transient copy of <me>

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Point_Pnt(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom_Point self) -> Standard_Real

        returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Point_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom_Point self) -> Standard_Real

        returns  the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Point_Y(self, *args)


    def Z(self, *args):
        """
        Z(Handle_Geom_Point self) -> Standard_Real

        returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Point_Z(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_Geom_Point self, Handle_Geom_Point Other) -> Standard_Real

        Computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Point_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Geom_Point self, Handle_Geom_Point Other) -> Standard_Real

        Computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Point_SquareDistance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Point self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Point_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Point_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Point self, gp_Pnt P)
        Mirror(Handle_Geom_Point self, gp_Ax1 A1)
        Mirror(Handle_Geom_Point self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Point_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Point self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Point_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Point self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Point_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Point self, gp_Vec V)
        Translate(Handle_Geom_Point self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Point_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Point self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Point_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Point self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Point self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Point self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Point self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Point self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Point self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Point self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Point self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Point self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Point_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Point self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Point_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Point_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Point_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Point self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Point_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Point self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Point_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Point self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Point_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Point self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Point_DecrementRefCounter(self, *args)

Handle_Geom_Point_swigregister = _Geom.Handle_Geom_Point_swigregister
Handle_Geom_Point_swigregister(Handle_Geom_Point)

def Handle_Geom_Point_DownCast(thing):
    return _Geom.Handle_Geom_Point_DownCast(thing)
Handle_Geom_Point_DownCast = _Geom.Handle_Geom_Point_DownCast

class Handle_Geom_RectangularTrimmedSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_RectangularTrimmedSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_RectangularTrimmedSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_RectangularTrimmedSurface self, Geom_RectangularTrimmedSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_RectangularTrimmedSurface self, Handle_Geom_RectangularTrimmedSurface theHandle) -> Handle_Geom_RectangularTrimmedSurface
        assign(Handle_Geom_RectangularTrimmedSurface self, Geom_RectangularTrimmedSurface thePtr) -> Handle_Geom_RectangularTrimmedSurface
        assign(Handle_Geom_RectangularTrimmedSurface self, Handle_Geom_RectangularTrimmedSurface theHandle) -> Handle_Geom_RectangularTrimmedSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_RectangularTrimmedSurface self) -> Geom_RectangularTrimmedSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_RectangularTrimmedSurface self) -> Geom_RectangularTrimmedSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_RectangularTrimmedSurface self) -> Geom_RectangularTrimmedSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_RectangularTrimmedSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_RectangularTrimmedSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_RectangularTrimmedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_RectangularTrimmedSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_RectangularTrimmedSurface

    def SetTrim(self, *args):
        """
        SetTrim(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Boolean const USense, Standard_Boolean const VSense)
        SetTrim(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const Param1, Standard_Real const Param2, Standard_Boolean const UTrim, Standard_Boolean const Sense)

        Modifies this patch by changing the trim values
        applied to the original surface
        The basis surface is trimmed only in one parametric direction: if UTrim
        is true, the surface is trimmed in the u parametric
        direction; if it is false, it is trimmed in the v
        parametric direction. In the "trimmed" direction,
        this patch is oriented from Param1 to Param2. If
        the basis surface is periodic in the "trimmed"
        direction, Sense defines its available part. By
        default in this case, this patch has the same
        orientation as the basis surface in this parametric
        direction. If the basis surface is closed or periodic
        in the other parametric direction (i.e. not the
        "trimmed" direction), this patch has the same
        characteristics as the basis surface in that parametric direction.
        Raised if
        The BasisSurface is not periodic in the considered direction and
        Param1 or Param2 are out of the bounds of the BasisSurface.
        Param1 = Param2

        :type Param1: float
        :type Param2: float
        :type UTrim: bool
        :type Sense: bool

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_SetTrim(self, *args)


    def BasisSurface(self, *args):
        """
        BasisSurface(Handle_Geom_RectangularTrimmedSurface self) -> Handle_Geom_Surface

        Returns the Basis surface of <me>.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_BasisSurface(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_RectangularTrimmedSurface self)

        Changes the orientation of this patch in the u
        parametric direction. The bounds of the surface are
        not changed, but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, produced by when reversing its u
        parametric direction, for any point of u parameter U on this patch.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_RectangularTrimmedSurface self)

        Changes the orientation of this patch in the v
        parametric direction. The bounds of the surface are
        not changed, but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const V) -> Standard_Real

        Computes the v  parameter on the modified
        surface, produced by when reversing its v
        parametric direction, for any point of v parameter V on this patch.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_RectangularTrimmedSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this patch.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_RectangularTrimmedSurface self) -> GeomAbs_Shape

        Returns  the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Continuity(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is closed in the given parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is closed in the given parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_RectangularTrimmedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the order of derivation in the U parametric
        direction is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_RectangularTrimmedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the order of derivation in the V parametric
        direction is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is periodic and not trimmed in the given
        parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Real

        Returns the period of this patch in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Boolean

        Returns true if this patch is periodic and not trimmed in the given
        parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Real

        Returns the period of this patch in the v
        parametric direction.
        raises if the surface is not vperiodic.
        value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U) -> Handle_Geom_Curve

        computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Can be raised if the basis surface is an OffsetSurface.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning!  UndefinedDerivative  raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning! UndefinedDerivative raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        The returned derivatives have the same orientation as the
        derivatives of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning UndefinedDerivative raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        The returned derivative has the same orientation as the
        derivative of the basis surface even if the trimmed surface
        has not the same parametric orientation.
        Warning!  UndefinedDerivative raised if the continuity of the surface is not CNu in the U
        parametric direction and CNv in the V parametric direction.
        RangeError Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_RectangularTrimmedSurface self, gp_Trsf T)

        Applies the transformation T to this patch.
        Warning
        As a consequence, the basis surface included in the
        data structure of this patch is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_RectangularTrimmedSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods calls the basis surface method.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_RectangularTrimmedSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods calls the basis surface method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_RectangularTrimmedSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this patch.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_RectangularTrimmedSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_RectangularTrimmedSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_RectangularTrimmedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_RectangularTrimmedSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_RectangularTrimmedSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_VReversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_RectangularTrimmedSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P)
        Mirror(Handle_Geom_RectangularTrimmedSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_RectangularTrimmedSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_RectangularTrimmedSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_RectangularTrimmedSurface self, gp_Vec V)
        Translate(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_RectangularTrimmedSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_RectangularTrimmedSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_RectangularTrimmedSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_RectangularTrimmedSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_RectangularTrimmedSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_RectangularTrimmedSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_RectangularTrimmedSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_RectangularTrimmedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_RectangularTrimmedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_RectangularTrimmedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_RectangularTrimmedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_RectangularTrimmedSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_RectangularTrimmedSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_RectangularTrimmedSurface_DecrementRefCounter(self, *args)

Handle_Geom_RectangularTrimmedSurface_swigregister = _Geom.Handle_Geom_RectangularTrimmedSurface_swigregister
Handle_Geom_RectangularTrimmedSurface_swigregister(Handle_Geom_RectangularTrimmedSurface)

def Handle_Geom_RectangularTrimmedSurface_DownCast(thing):
    return _Geom.Handle_Geom_RectangularTrimmedSurface_DownCast(thing)
Handle_Geom_RectangularTrimmedSurface_DownCast = _Geom.Handle_Geom_RectangularTrimmedSurface_DownCast

class Handle_Geom_CartesianPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_CartesianPoint self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_CartesianPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_CartesianPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_CartesianPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_CartesianPoint self, Geom_CartesianPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_CartesianPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_CartesianPoint self, Handle_Geom_CartesianPoint theHandle) -> Handle_Geom_CartesianPoint
        assign(Handle_Geom_CartesianPoint self, Geom_CartesianPoint thePtr) -> Handle_Geom_CartesianPoint
        assign(Handle_Geom_CartesianPoint self, Handle_Geom_CartesianPoint theHandle) -> Handle_Geom_CartesianPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_CartesianPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_CartesianPoint self) -> Geom_CartesianPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_CartesianPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_CartesianPoint self) -> Geom_CartesianPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_CartesianPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_CartesianPoint self) -> Geom_CartesianPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_CartesianPoint___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_CartesianPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_CartesianPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_CartesianPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_CartesianPoint_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_CartesianPoint

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom_CartesianPoint self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Assigns the coordinates X, Y and Z to this point.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_CartesianPoint_SetCoord(self, *args)


    def SetPnt(self, *args):
        """
        SetPnt(Handle_Geom_CartesianPoint self, gp_Pnt P)

        Set <me> to P.X(), P.Y(), P.Z() coordinates.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CartesianPoint_SetPnt(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom_CartesianPoint self, Standard_Real const X)

        Changes the X coordinate of me.

        :type X: float

        """
        return _Geom.Handle_Geom_CartesianPoint_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom_CartesianPoint self, Standard_Real const Y)

        Changes the Y coordinate of me.

        :type Y: float

        """
        return _Geom.Handle_Geom_CartesianPoint_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Handle_Geom_CartesianPoint self, Standard_Real const Z)

        Changes the Z coordinate of me.

        :type Z: float

        """
        return _Geom.Handle_Geom_CartesianPoint_SetZ(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom_CartesianPoint self)

        Returns the coordinates of <me>.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_CartesianPoint_Coord(self, *args)


    def Pnt(self, *args):
        """
        Pnt(Handle_Geom_CartesianPoint self) -> gp_Pnt

        Returns a non transient cartesian point with
        the same coordinates as <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CartesianPoint_Pnt(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom_CartesianPoint self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CartesianPoint_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom_CartesianPoint self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CartesianPoint_Y(self, *args)


    def Z(self, *args):
        """
        Z(Handle_Geom_CartesianPoint self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CartesianPoint_Z(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_CartesianPoint self, gp_Trsf T)

        Applies the transformation T to this point.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_CartesianPoint_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_CartesianPoint self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this point.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_CartesianPoint self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_CartesianPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_CartesianPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_CartesianPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Distance(self, *args):
        """
        Distance(Handle_Geom_CartesianPoint self, Handle_Geom_Point Other) -> Standard_Real

        Computes the distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CartesianPoint_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Handle_Geom_CartesianPoint self, Handle_Geom_Point Other) -> Standard_Real

        Computes the square distance between <me> and <Other>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CartesianPoint_SquareDistance(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_CartesianPoint self, gp_Pnt P)
        Mirror(Handle_Geom_CartesianPoint self, gp_Ax1 A1)
        Mirror(Handle_Geom_CartesianPoint self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_CartesianPoint_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_CartesianPoint self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_CartesianPoint_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_CartesianPoint self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_CartesianPoint_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_CartesianPoint self, gp_Vec V)
        Translate(Handle_Geom_CartesianPoint self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CartesianPoint_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_CartesianPoint self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_CartesianPoint self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_CartesianPoint self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_CartesianPoint self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_CartesianPoint self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_CartesianPoint self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_CartesianPoint self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_CartesianPoint self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CartesianPoint_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_CartesianPoint self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_CartesianPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_CartesianPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_CartesianPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CartesianPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_CartesianPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_CartesianPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CartesianPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_CartesianPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_CartesianPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_CartesianPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_CartesianPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_CartesianPoint self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_CartesianPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_CartesianPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_CartesianPoint_DecrementRefCounter(self, *args)

Handle_Geom_CartesianPoint_swigregister = _Geom.Handle_Geom_CartesianPoint_swigregister
Handle_Geom_CartesianPoint_swigregister(Handle_Geom_CartesianPoint)

def Handle_Geom_CartesianPoint_DownCast(thing):
    return _Geom.Handle_Geom_CartesianPoint_DownCast(thing)
Handle_Geom_CartesianPoint_DownCast = _Geom.Handle_Geom_CartesianPoint_DownCast

class NCollection_Sequence_Handle_Geom_BSplineSurface(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Geom.new_NCollection_Sequence_Handle_Geom_BSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Geom_BSplineSurface self)

        Reverse sequence


        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Geom_BSplineSurface self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theOther) -> NCollection_Sequence_Handle_Geom_BSplineSurface

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theOther) -> NCollection_Sequence_Handle_Geom_BSplineSurface

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Geom_BSplineSurface self, Handle_Geom_BSplineSurface theItem)
        Append(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Geom_BSplineSurface self, Handle_Geom_BSplineSurface theItem)
        Prepend(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, Handle_Geom_BSplineSurface theItem)
        InsertBefore(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Geom_BSplineSurface theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Geom_BSplineSurface self, NCollection_Sequence< opencascade::handle< Geom_BSplineSurface > >::Iterator & thePosition, Handle_Geom_BSplineSurface theItem)
        InsertAfter(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Geom_BSplineSurface theSeq)
        InsertAfter(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, Handle_Geom_BSplineSurface theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Geom_BSplineSurface theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Handle_Geom_BSplineSurface

        First item access

        :rtype: TheItemType &

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Geom_BSplineSurface self) -> Handle_Geom_BSplineSurface

        Last item access

        :rtype: TheItemType &

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex) -> Handle_Geom_BSplineSurface

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Geom_BSplineSurface self, Standard_Integer const theIndex, Handle_Geom_BSplineSurface theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_SetValue(self, *args)


    def __iter__(self):
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface___iter__(self)
    __swig_destroy__ = _Geom.delete_NCollection_Sequence_Handle_Geom_BSplineSurface
NCollection_Sequence_Handle_Geom_BSplineSurface_swigregister = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_swigregister
NCollection_Sequence_Handle_Geom_BSplineSurface_swigregister(NCollection_Sequence_Handle_Geom_BSplineSurface)

def NCollection_Sequence_Handle_Geom_BSplineSurface_delNode(*args):
    """
    NCollection_Sequence_Handle_Geom_BSplineSurface_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_delNode(*args)

class NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Geom.new_NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom.delete_NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper

    def __next__(self):
        return _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper_swigregister = _Geom.NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper_swigregister
NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper_swigregister(NCollection_Sequence_Handle_Geom_BSplineSurface_IteratorHelper)


try:
	Geom_SequenceOfBSplineSurface = NCollection_Sequence_Handle_Geom_BSplineSurface
except NameError:
	pass # does not exist, probably ignored

class Handle_Geom_OsculatingSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_OsculatingSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_OsculatingSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_OsculatingSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_OsculatingSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_OsculatingSurface self, Geom_OsculatingSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_OsculatingSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_OsculatingSurface self, Handle_Geom_OsculatingSurface theHandle) -> Handle_Geom_OsculatingSurface
        assign(Handle_Geom_OsculatingSurface self, Geom_OsculatingSurface thePtr) -> Handle_Geom_OsculatingSurface
        assign(Handle_Geom_OsculatingSurface self, Handle_Geom_OsculatingSurface theHandle) -> Handle_Geom_OsculatingSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_OsculatingSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_OsculatingSurface self) -> Geom_OsculatingSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_OsculatingSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_OsculatingSurface self) -> Geom_OsculatingSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_OsculatingSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_OsculatingSurface self) -> Geom_OsculatingSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_OsculatingSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_OsculatingSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_OsculatingSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_OsculatingSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_OsculatingSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_OsculatingSurface

    def Init(self, *args):
        """
        Init(Handle_Geom_OsculatingSurface self, Handle_Geom_Surface BS, Standard_Real const Tol)

        :type BS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        return _Geom.Handle_Geom_OsculatingSurface_Init(self, *args)


    def BasisSurface(self, *args):
        """
        BasisSurface(Handle_Geom_OsculatingSurface self) -> Handle_Geom_Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_OsculatingSurface_BasisSurface(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_Geom_OsculatingSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OsculatingSurface_Tolerance(self, *args)


    def UOscSurf(self, *args):
        """
        UOscSurf(Handle_Geom_OsculatingSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface L) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along U at the point U,V.

        :type U: float
        :type V: float
        :type t: bool
        :type L: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OsculatingSurface_UOscSurf(self, *args)


    def VOscSurf(self, *args):
        """
        VOscSurf(Handle_Geom_OsculatingSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface L) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along V at the point U,V.

        :type U: float
        :type V: float
        :type t: bool
        :type L: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OsculatingSurface_VOscSurf(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_OsculatingSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_OsculatingSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OsculatingSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OsculatingSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Geom_OsculatingSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_OsculatingSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_OsculatingSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_OsculatingSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OsculatingSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_OsculatingSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_OsculatingSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OsculatingSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_OsculatingSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_OsculatingSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_OsculatingSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OsculatingSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_OsculatingSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_OsculatingSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_OsculatingSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OsculatingSurface_DecrementRefCounter(self, *args)

Handle_Geom_OsculatingSurface_swigregister = _Geom.Handle_Geom_OsculatingSurface_swigregister
Handle_Geom_OsculatingSurface_swigregister(Handle_Geom_OsculatingSurface)

def Handle_Geom_OsculatingSurface_DownCast(thing):
    return _Geom.Handle_Geom_OsculatingSurface_DownCast(thing)
Handle_Geom_OsculatingSurface_DownCast = _Geom.Handle_Geom_OsculatingSurface_DownCast

class Handle_Geom_TrimmedCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_TrimmedCurve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_TrimmedCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_TrimmedCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_TrimmedCurve self, Geom_TrimmedCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_TrimmedCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_TrimmedCurve self, Handle_Geom_TrimmedCurve theHandle) -> Handle_Geom_TrimmedCurve
        assign(Handle_Geom_TrimmedCurve self, Geom_TrimmedCurve thePtr) -> Handle_Geom_TrimmedCurve
        assign(Handle_Geom_TrimmedCurve self, Handle_Geom_TrimmedCurve theHandle) -> Handle_Geom_TrimmedCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_TrimmedCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_TrimmedCurve self) -> Geom_TrimmedCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_TrimmedCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_TrimmedCurve self) -> Geom_TrimmedCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_TrimmedCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_TrimmedCurve self) -> Geom_TrimmedCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_TrimmedCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_TrimmedCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_TrimmedCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_TrimmedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_TrimmedCurve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_TrimmedCurve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_TrimmedCurve self)

        Changes the orientation of this trimmed curve.
        As a result:
        - the basis curve is reversed,
        - the start point of the initial curve becomes the
        end point of the reversed curve,
        - the end point of the initial curve becomes the
        start point of the reversed curve,
        - the first and last parameters are recomputed.
        If the trimmed curve was defined by:
        - a basis curve whose parameter range is [ 0., 1. ],
        - the two trim values U1 (first parameter) and U2 (last parameter),
        the reversed trimmed curve is defined by:
        - the reversed basis curve, whose parameter range is still [ 0., 1. ],
        - the two trim values 1. - U2 (first parameter) and 1. - U1 (last parameter).


        """
        return _Geom.Handle_Geom_TrimmedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_TrimmedCurve self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed curve for
        the point of parameter U on this trimmed curve.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_ReversedParameter(self, *args)


    def SetTrim(self, *args):
        """
        SetTrim(Handle_Geom_TrimmedCurve self, Standard_Real const U1, Standard_Real const U2, Standard_Boolean const Sense, Standard_Boolean const theAdjustPeriodic)

        Changes this trimmed curve, by redefining the
        parameter values U1 and U2 which limit its basis curve.
        Note: If the basis curve is periodic, the trimmed curve
        has the same orientation as the basis curve if Sense
        is true (default value) or the opposite orientation if Sense is false.
        Warning
        If the basis curve is periodic and theAdjustPeriodic is True,
        the bounds of the trimmed curve may be different from U1 and U2 if the
        parametric origin of the basis curve is within the arc of
        the trimmed curve. In this case, the modified
        parameter will be equal to U1 or U2 plus or minus the period.
        When theAdjustPeriodic is False, parameters U1 and U2 will be
        the same, without adjustment into the first period.
        Exceptions
        Standard_ConstructionError if:
        - the basis curve is not periodic, and either U1 or U2
        are outside the bounds of the basis curve, or
        - U1 is equal to U2.

        :type U1: float
        :type U2: float
        :type Sense: bool
        :type theAdjustPeriodic: bool

        """
        return _Geom.Handle_Geom_TrimmedCurve_SetTrim(self, *args)


    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom_TrimmedCurve self) -> Handle_Geom_Curve

        Returns the basis curve.
        Warning
        This function does not return a constant reference.
        Consequently, any modification of the returned value
        directly modifies the trimmed curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_TrimmedCurve_BasisCurve(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_TrimmedCurve self) -> GeomAbs_Shape

        Returns the continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_TrimmedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_TrimmedCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of the basis
        curve of this trimmed curve is at least N. A trimmed
        curve is at least "C0" continuous.
        Warnings :
        The continuity of the trimmed curve can be greater than
        the continuity of the basis curve because you consider
        only a part of the basis curve.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsCN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom_TrimmedCurve self) -> gp_Pnt

        Returns the end point of <me>. This point is the
        evaluation of the curve for the "LastParameter".

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_TrimmedCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_TrimmedCurve self) -> Standard_Real

        Returns the value of the first parameter of <me>.
        The first parameter is the parameter of the "StartPoint"
        of the trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_FirstParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_TrimmedCurve self) -> Standard_Boolean

        Returns True if the distance between the StartPoint and
        the EndPoint is lower or equal to Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_TrimmedCurve self) -> Standard_Boolean

        Always returns FALSE (independently of the type of basis curve).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_TrimmedCurve self) -> Standard_Real

        Returns the period of the basis curve of this trimmed curve.
        Exceptions
        Standard_NoSuchObject if the basis curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_Period(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_TrimmedCurve self) -> Standard_Real

        Returns the value of the last parameter of <me>.
        The last parameter is the parameter of the "EndPoint" of the
        trimmed curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_LastParameter(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom_TrimmedCurve self) -> gp_Pnt

        Returns the start point of <me>.
        This point is the evaluation of the curve from the
        "FirstParameter".
        value and derivatives
        Warnings :
        The returned derivatives have the same orientation as the
        derivatives of the basis curve even if the trimmed curve
        has not the same orientation as the basis curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_TrimmedCurve_StartPoint(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.

        If the basis curve is an OffsetCurve sometimes it is not
        possible to do the evaluation of the curve at the parameter
        U (see class OffsetCurve).

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_TrimmedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_TrimmedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_TrimmedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_TrimmedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_TrimmedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_TrimmedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        N is the order of derivation.
        Raised if the continuity of the curve is not CN.
        Raised if N < 1.
        geometric transformations

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_TrimmedCurve_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_TrimmedCurve self, gp_Trsf T)

        Applies the transformation T to this trimmed curve.
        Warning The basis curve is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_TrimmedCurve_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_TrimmedCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_TrimmedCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods calls the basis curve method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_TrimmedCurve_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_TrimmedCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this trimmed curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_TrimmedCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_TrimmedCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_TrimmedCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_TrimmedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_TrimmedCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_TrimmedCurve_Reversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_TrimmedCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_TrimmedCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_TrimmedCurve self, gp_Pnt P)
        Mirror(Handle_Geom_TrimmedCurve self, gp_Ax1 A1)
        Mirror(Handle_Geom_TrimmedCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_TrimmedCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_TrimmedCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_TrimmedCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_TrimmedCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_TrimmedCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_TrimmedCurve self, gp_Vec V)
        Translate(Handle_Geom_TrimmedCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_TrimmedCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_TrimmedCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_TrimmedCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_TrimmedCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_TrimmedCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_TrimmedCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_TrimmedCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_TrimmedCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_TrimmedCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_TrimmedCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_TrimmedCurve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_TrimmedCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_TrimmedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_TrimmedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_TrimmedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_TrimmedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_TrimmedCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_TrimmedCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_TrimmedCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_TrimmedCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_TrimmedCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_TrimmedCurve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_TrimmedCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_TrimmedCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_TrimmedCurve_DecrementRefCounter(self, *args)

Handle_Geom_TrimmedCurve_swigregister = _Geom.Handle_Geom_TrimmedCurve_swigregister
Handle_Geom_TrimmedCurve_swigregister(Handle_Geom_TrimmedCurve)

def Handle_Geom_TrimmedCurve_DownCast(thing):
    return _Geom.Handle_Geom_TrimmedCurve_DownCast(thing)
Handle_Geom_TrimmedCurve_DownCast = _Geom.Handle_Geom_TrimmedCurve_DownCast

class Handle_Geom_ToroidalSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_ToroidalSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_ToroidalSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_ToroidalSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_ToroidalSurface self, Geom_ToroidalSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_ToroidalSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_ToroidalSurface self, Handle_Geom_ToroidalSurface theHandle) -> Handle_Geom_ToroidalSurface
        assign(Handle_Geom_ToroidalSurface self, Geom_ToroidalSurface thePtr) -> Handle_Geom_ToroidalSurface
        assign(Handle_Geom_ToroidalSurface self, Handle_Geom_ToroidalSurface theHandle) -> Handle_Geom_ToroidalSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_ToroidalSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_ToroidalSurface self) -> Geom_ToroidalSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_ToroidalSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_ToroidalSurface self) -> Geom_ToroidalSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_ToroidalSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_ToroidalSurface self) -> Geom_ToroidalSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_ToroidalSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_ToroidalSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_ToroidalSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_ToroidalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_ToroidalSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_ToroidalSurface

    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_Geom_ToroidalSurface self, Standard_Real const MajorRadius)

        Modifies this torus by changing its major radius.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is negative, or
        - MajorRadius - r is less than or equal to
        gp::Resolution(), where r is the minor radius of this torus.

        :type MajorRadius: float

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_Geom_ToroidalSurface self, Standard_Real const MinorRadius)

        Modifies this torus by changing its minor radius.
        Exceptions
        Standard_ConstructionError if:
        - MinorRadius is negative, or
        - R - MinorRadius is less than or equal to
        gp::Resolution(), where R is the major radius of this torus.

        :type MinorRadius: float

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetMinorRadius(self, *args)


    def SetTorus(self, *args):
        """
        SetTorus(Handle_Geom_ToroidalSurface self, gp_Torus T)

        Converts the gp_Torus torus T into this torus.

        :type T: OCC.wrapper.gp.gp_Torus

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetTorus(self, *args)


    def Torus(self, *args):
        """
        Torus(Handle_Geom_ToroidalSurface self) -> gp_Torus

        Returns the non transient torus with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _Geom.Handle_Geom_ToroidalSurface_Torus(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_ToroidalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_ToroidalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_VReversedParameter(self, *args)


    def Area(self, *args):
        """
        Area(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Computes the aera of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_Area(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_ToroidalSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this torus.
        For a torus: U1 = V1 = 0 and U2 = V2 = 2*PI .

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_ToroidalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Handle_Geom_ToroidalSurface self, NCollection_Array1_Standard_Real Coef)

        Returns the coefficients of the implicit equation of the surface
        in the absolute cartesian coordinate system :
        Coef(1) * X**4 + Coef(2) * Y**4 + Coef(3) * Z**4 +
        Coef(4) * X**3 * Y + Coef(5) * X**3 * Z + Coef(6) * Y**3 * X +
        Coef(7) * Y**3 * Z + Coef(8) * Z**3 * X + Coef(9) * Z**3 * Y +
        Coef(10) * X**2 * Y**2 + Coef(11) * X**2 * Z**2 +
        Coef(12) * Y**2 * Z**2 + Coef(13) * X**3 + Coef(14) * Y**3 +
        Coef(15) * Z**3 + Coef(16) * X**2 * Y + Coef(17) * X**2 * Z +
        Coef(18) * Y**2 * X + Coef(19) * Y**2 * Z + Coef(20) * Z**2 * X +
        Coef(21) * Z**2 * Y + Coef(22) * X**2 + Coef(23) * Y**2 +
        Coef(24) * Z**2 + Coef(25) * X * Y + Coef(26) * X * Z +
        Coef(27) * Y * Z + Coef(28) * X + Coef(29) * Y + Coef(30) *  Z +
        Coef(31) = 0.0
        Raised if the length of Coef is lower than 31.

        :type Coef: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_ToroidalSurface_Coefficients(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Returns the major radius, or the minor radius, of this torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Returns the major radius, or the minor radius, of this torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_MinorRadius(self, *args)


    def Volume(self, *args):
        """
        Volume(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Computes the volume.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_Volume(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_ToroidalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_ToroidalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        For a toroidal surface the UIso curve is a circle.
        The center of the Uiso circle is at the distance MajorRadius
        from the location point of the toroidal surface.
        Warnings :
        The radius of the circle can be zero if for the surface
        MinorRadius = 0.0

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ToroidalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_ToroidalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        For a ToroidalSurface the VIso curve is a circle.
        The axis of the circle is the main axis (ZAxis) of the
        toroidal  surface.
        Warnings :
        The radius of the circle can be zero if for the surface
        MajorRadius = MinorRadius

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ToroidalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + MinorRadius * Sin (V) * Zdir +
        (MajorRadius + MinorRadius * Cos(V)) *
        (cos (U) * XDir + sin (U) * YDir)
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis and ZDir the direction of the ZAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ToroidalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in
        the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ToroidalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ToroidalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the
        third derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ToroidalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and
        Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ToroidalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_ToroidalSurface self, gp_Trsf T)

        Applies the transformation T to this torus.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ToroidalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_ToroidalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this torus.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_ToroidalSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_ToroidalSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ToroidalSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ToroidalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_ToroidalSurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_ToroidalSurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_ToroidalSurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_ToroidalSurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_ToroidalSurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ToroidalSurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_ToroidalSurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ToroidalSurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_ToroidalSurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_ToroidalSurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Handle_Geom_ToroidalSurface_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_ToroidalSurface self)

        Reverses the V parametric direction of the surface.


        """
        return _Geom.Handle_Geom_ToroidalSurface_VReverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_ToroidalSurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_ToroidalSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_ToroidalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_ToroidalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsCNv(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_ToroidalSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ToroidalSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_ToroidalSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ToroidalSurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_ToroidalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ToroidalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_ToroidalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_ToroidalSurface_ParametricTransformation(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_ToroidalSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ToroidalSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_ToroidalSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ToroidalSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_ToroidalSurface self, gp_Pnt P)
        Mirror(Handle_Geom_ToroidalSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_ToroidalSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_ToroidalSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_ToroidalSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_ToroidalSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_ToroidalSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_ToroidalSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_ToroidalSurface self, gp_Vec V)
        Translate(Handle_Geom_ToroidalSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ToroidalSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_ToroidalSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ToroidalSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ToroidalSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_ToroidalSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_ToroidalSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_ToroidalSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_ToroidalSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_ToroidalSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ToroidalSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_ToroidalSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_ToroidalSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_ToroidalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_ToroidalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_ToroidalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_ToroidalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ToroidalSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_ToroidalSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_ToroidalSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_ToroidalSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ToroidalSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_ToroidalSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_ToroidalSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_ToroidalSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ToroidalSurface_DecrementRefCounter(self, *args)

Handle_Geom_ToroidalSurface_swigregister = _Geom.Handle_Geom_ToroidalSurface_swigregister
Handle_Geom_ToroidalSurface_swigregister(Handle_Geom_ToroidalSurface)

def Handle_Geom_ToroidalSurface_DownCast(thing):
    return _Geom.Handle_Geom_ToroidalSurface_DownCast(thing)
Handle_Geom_ToroidalSurface_DownCast = _Geom.Handle_Geom_ToroidalSurface_DownCast

class Handle_Geom_Parabola(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Parabola self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Parabola_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Parabola self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Parabola_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Parabola self, Geom_Parabola thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Parabola_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Parabola self, Handle_Geom_Parabola theHandle) -> Handle_Geom_Parabola
        assign(Handle_Geom_Parabola self, Geom_Parabola thePtr) -> Handle_Geom_Parabola
        assign(Handle_Geom_Parabola self, Handle_Geom_Parabola theHandle) -> Handle_Geom_Parabola

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Parabola_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Parabola self) -> Geom_Parabola

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Parabola_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Parabola self) -> Geom_Parabola

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Parabola___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Parabola self) -> Geom_Parabola

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Parabola___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Parabola___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Parabola___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Parabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Parabola_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Parabola

    def SetFocal(self, *args):
        """
        SetFocal(Handle_Geom_Parabola self, Standard_Real const Focal)

        Assigns the value Focal to the focal distance of this parabola.
        Exceptions Standard_ConstructionError if Focal is negative.

        :type Focal: float

        """
        return _Geom.Handle_Geom_Parabola_SetFocal(self, *args)


    def SetParab(self, *args):
        """
        SetParab(Handle_Geom_Parabola self, gp_Parab Prb)

        Converts the gp_Parab parabola Prb into this parabola.

        :type Prb: OCC.wrapper.gp.gp_Parab

        """
        return _Geom.Handle_Geom_Parabola_SetParab(self, *args)


    def Parab(self, *args):
        """
        Parab(Handle_Geom_Parabola self) -> gp_Parab

        Returns the non transient parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _Geom.Handle_Geom_Parabola_Parab(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Parabola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed parabola,
        for the point of parameter U on this parabola.
        For a parabola, the returned value is: -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Parabola self) -> Standard_Real

        Returns the value of the first or last parameter of this
        parabola. This is, respectively:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Parabola self) -> Standard_Real

        Returns the value of the first or last parameter of this
        parabola. This is, respectively:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Parabola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Parabola self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Parabola_IsPeriodic(self, *args)


    def Directrix(self, *args):
        """
        Directrix(Handle_Geom_Parabola self) -> gp_Ax1

        Computes the directrix of this parabola.
        This is a line normal to the axis of symmetry, in the
        plane of this parabola, located on the negative side
        of its axis of symmetry, at a distance from the apex
        equal to the focal length.
        The directrix is returned as an axis (gp_Ax1 object),
        where the origin is located on the "X Axis" of this parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Parabola_Directrix(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom_Parabola self) -> Standard_Real

        Returns 1. (which is the eccentricity of any parabola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_Eccentricity(self, *args)


    def Focus(self, *args):
        """
        Focus(Handle_Geom_Parabola self) -> gp_Pnt

        Computes the focus of this parabola. The focus is on the
        positive side of the "X Axis" of the local coordinate
        system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_Focus(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom_Parabola self) -> Standard_Real

        Computes the focal distance of this parabola
        The focal distance is the distance between the apex
        and the focus of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_Focal(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom_Parabola self) -> Standard_Real

        Computes the parameter of this parabola which is the
        distance between its focus and its directrix. This
        distance is twice the focal length.
        If P is the parameter of the parabola, the equation of
        the parabola in its local coordinate system is: Y**2 = 2.*P*X.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Parabola self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If U = 0 the returned point is the origin of the XAxis and
        the YAxis of the parabola and it is the vertex of the parabola.
        P = S + F * (U * U * XDir +  * U * YDir)
        where S is the vertex of the parabola, XDir the XDirection and
        YDir the YDirection of the parabola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Parabola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Parabola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Parabola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Parabola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Parabola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this parabola,
        computes the vector corresponding to the Nth derivative.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Parabola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Parabola self, gp_Trsf T)

        Applies the transformation T to this parabola.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Parabola_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Parabola self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U> * T.ScaleFactor()

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Parabola self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Parabola self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this parabola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Parabola self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Parabola_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Parabola_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Parabola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Parabola self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Parabola_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Parabola self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Parabola self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Parabola_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Parabola self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Parabola_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Parabola self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Handle_Geom_Parabola_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Handle_Geom_Parabola self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Parabola_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom_Parabola self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Parabola_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Parabola self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Handle_Geom_Parabola_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Parabola self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Parabola_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Parabola self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Parabola_IsCN(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Parabola self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Parabola_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Parabola self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Parabola_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Parabola self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Parabola self, gp_Pnt P)
        Mirror(Handle_Geom_Parabola self, gp_Ax1 A1)
        Mirror(Handle_Geom_Parabola self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Parabola_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Parabola self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Parabola_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Parabola self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Parabola_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Parabola self, gp_Vec V)
        Translate(Handle_Geom_Parabola self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Parabola_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Parabola self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Parabola self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Parabola self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Parabola self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Parabola self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Parabola self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Parabola self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Parabola self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Parabola_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Parabola self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Parabola_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Parabola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Parabola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Parabola_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Parabola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Parabola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Parabola_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Parabola self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Parabola_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Parabola self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Parabola_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Parabola self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Parabola_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Parabola self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Parabola_DecrementRefCounter(self, *args)

Handle_Geom_Parabola_swigregister = _Geom.Handle_Geom_Parabola_swigregister
Handle_Geom_Parabola_swigregister(Handle_Geom_Parabola)

def Handle_Geom_Parabola_DownCast(thing):
    return _Geom.Handle_Geom_Parabola_DownCast(thing)
Handle_Geom_Parabola_DownCast = _Geom.Handle_Geom_Parabola_DownCast

class Handle_Geom_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Line self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Line self, Geom_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Line self, Handle_Geom_Line theHandle) -> Handle_Geom_Line
        assign(Handle_Geom_Line self, Geom_Line thePtr) -> Handle_Geom_Line
        assign(Handle_Geom_Line self, Handle_Geom_Line theHandle) -> Handle_Geom_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Line self) -> Geom_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Line self) -> Geom_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Line self) -> Geom_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Line___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Line_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Line

    def SetLin(self, *args):
        """
        SetLin(Handle_Geom_Line self, gp_Lin L)

        Set <me> so that <me> has the same geometric properties as L.

        :type L: OCC.wrapper.gp.gp_Lin

        """
        return _Geom.Handle_Geom_Line_SetLin(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_Line self, gp_Dir V)

        changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Line_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Line self, gp_Pnt P)

        changes the "Location" point (origin) of the line.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Line_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Line self, gp_Ax1 A1)

        changes the "Location" and a the "Direction" of <me>.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Line_SetPosition(self, *args)


    def Lin(self, *args):
        """
        Lin(Handle_Geom_Line self) -> gp_Lin

        Returns non transient line from gp with the same geometric
        properties as <me>

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _Geom.Handle_Geom_Line_Lin(self, *args)


    def Position(self, *args):
        """
        Returns the positioning axis of this line; this is also its local coordinate system.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Handle_Geom_Line_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Line self)

        Changes the orientation of this line. As a result, the
        unit vector of the positioning axis of this line is reversed.


        """
        return _Geom.Handle_Geom_Line_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Line self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed line for the
        point of parameter U on this line.
        For a line, the returned value is -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Line self) -> Standard_Real

        Returns the value of the first parameter of this
        line. This is Standard_Real::RealFirst().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Line self) -> Standard_Real

        Returns the value of the last parameter of this
        line. This is  Standard_Real::RealLast().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Line self) -> Standard_Boolean

        returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Line_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Line self) -> Standard_Boolean

        returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Line_IsPeriodic(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Line self) -> GeomAbs_Shape

        Returns GeomAbs_CN, which is the global continuity of any line.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Line_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Line self, Standard_Integer const N) -> Standard_Boolean

        returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Line_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Line self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P (U) = O + U * Dir where O is the "Location" point of the
        line and Dir the direction of the line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Line_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter u and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Line_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2. V2 is a vector with null magnitude
        for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Line_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Line self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        V2 and V3 are vectors with null magnitude for a line.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Line_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Line self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Line_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Line self, gp_Trsf T)

        Applies the transformation T to this line.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Line_Transform(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Line self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U> * T.ScaleFactor()

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Line self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Line self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this line.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Line self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Line self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Line_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Line self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Line_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Line self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Line_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Line self, gp_Pnt P)
        Mirror(Handle_Geom_Line self, gp_Ax1 A1)
        Mirror(Handle_Geom_Line self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Line_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Line self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Line_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Line self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Line_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Line self, gp_Vec V)
        Translate(Handle_Geom_Line self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Line_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Line self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Line self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Line self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Line self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Line self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Line self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Line self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Line self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Line_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Line self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Line self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Line_DecrementRefCounter(self, *args)

Handle_Geom_Line_swigregister = _Geom.Handle_Geom_Line_swigregister
Handle_Geom_Line_swigregister(Handle_Geom_Line)

def Handle_Geom_Line_DownCast(thing):
    return _Geom.Handle_Geom_Line_DownCast(thing)
Handle_Geom_Line_DownCast = _Geom.Handle_Geom_Line_DownCast

class Handle_Geom_ElementarySurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_ElementarySurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_ElementarySurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_ElementarySurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_ElementarySurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_ElementarySurface self, Geom_ElementarySurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_ElementarySurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_ElementarySurface self, Handle_Geom_ElementarySurface theHandle) -> Handle_Geom_ElementarySurface
        assign(Handle_Geom_ElementarySurface self, Geom_ElementarySurface thePtr) -> Handle_Geom_ElementarySurface
        assign(Handle_Geom_ElementarySurface self, Handle_Geom_ElementarySurface theHandle) -> Handle_Geom_ElementarySurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_ElementarySurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_ElementarySurface self) -> Geom_ElementarySurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_ElementarySurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_ElementarySurface self) -> Geom_ElementarySurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_ElementarySurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_ElementarySurface self) -> Geom_ElementarySurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_ElementarySurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_ElementarySurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_ElementarySurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_ElementarySurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_ElementarySurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_ElementarySurface

    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_ElementarySurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ElementarySurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_ElementarySurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ElementarySurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_ElementarySurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_ElementarySurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_ElementarySurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ElementarySurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_ElementarySurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ElementarySurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_ElementarySurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_ElementarySurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Handle_Geom_ElementarySurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_ElementarySurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)
        is the same point as
        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ElementarySurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_ElementarySurface self)

        Reverses the V parametric direction of the surface.


        """
        return _Geom.Handle_Geom_ElementarySurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_ElementarySurface self, Standard_Real const V) -> Standard_Real

        Return the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))
        is the same point as
        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ElementarySurface_VReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_ElementarySurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_ElementarySurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_ElementarySurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_ElementarySurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsCNv(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_ElementarySurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_ElementarySurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ElementarySurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ElementarySurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_ElementarySurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ElementarySurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_ElementarySurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ElementarySurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_ElementarySurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ElementarySurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_ElementarySurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_ElementarySurface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_ElementarySurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this surface.
        If the surface is infinite, this function can return a value
        equal to Precision::Infinite: instead of Standard_Real::LastReal.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_ElementarySurface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_ElementarySurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the u parametric direction: taking
        uFirst and uLast as the parametric bounds in
        the u parametric direction, for each parameter v, the
        distance between the points P(uFirst, v) and
        P(uLast, v) is less than or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_ElementarySurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the v parametric
        direction: taking vFirst and vLast as the
        parametric bounds in the v parametric direction, for
        each parameter u, the distance between the points
        P(u, vFirst) and P(u, vLast) is less than
        or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_ElementarySurface self) -> Standard_Boolean

        Checks if this surface is periodic in the u
        parametric direction. Returns true if:
        - this surface is closed in the u parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the u parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_ElementarySurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ElementarySurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_ElementarySurface self) -> Standard_Boolean

        Checks if this surface is periodic in the v
        parametric direction. Returns true if:
        - this surface is closed in the v parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_ElementarySurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ElementarySurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_ElementarySurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ElementarySurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_ElementarySurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ElementarySurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the surface.

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ElementarySurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ElementarySurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ElementarySurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ElementarySurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        ---Purpose ;
        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        Raised if the continuity of the surface is not CNu in the U
        direction or not CNv in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ElementarySurface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_ElementarySurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ElementarySurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_ElementarySurface self, gp_Pnt P)
        Mirror(Handle_Geom_ElementarySurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_ElementarySurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_ElementarySurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_ElementarySurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_ElementarySurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_ElementarySurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_ElementarySurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_ElementarySurface self, gp_Vec V)
        Translate(Handle_Geom_ElementarySurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ElementarySurface_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_ElementarySurface self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ElementarySurface_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_ElementarySurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ElementarySurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ElementarySurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_ElementarySurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_ElementarySurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_ElementarySurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_ElementarySurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_ElementarySurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_ElementarySurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ElementarySurface_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_ElementarySurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_ElementarySurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_ElementarySurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_ElementarySurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_ElementarySurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_ElementarySurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ElementarySurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_ElementarySurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_ElementarySurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_ElementarySurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ElementarySurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_ElementarySurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_ElementarySurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_ElementarySurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ElementarySurface_DecrementRefCounter(self, *args)

Handle_Geom_ElementarySurface_swigregister = _Geom.Handle_Geom_ElementarySurface_swigregister
Handle_Geom_ElementarySurface_swigregister(Handle_Geom_ElementarySurface)

def Handle_Geom_ElementarySurface_DownCast(thing):
    return _Geom.Handle_Geom_ElementarySurface_DownCast(thing)
Handle_Geom_ElementarySurface_DownCast = _Geom.Handle_Geom_ElementarySurface_DownCast

class Geom_CylindricalSurface(Geom_ElementarySurface):
    """
    This class defines the infinite cylindrical surface.

    Every cylindrical surface is set by the following equation:
    S(U,V) = Location + R*cos(U)*XAxis + R*sin(U)*YAxis + V*ZAxis,
    where R is cylinder radius.

    The local coordinate system of the CylindricalSurface is defined
    with an axis placement (see class ElementarySurface).

    The "ZAxis" is the symmetry axis of the CylindricalSurface,
    it gives the direction of increasing parametric value V.

    The parametrization range is :
    U [0, 2*PI],  V ]- infinite, + infinite[

    The "XAxis" and the "YAxis" define the placement plane of the
    surface (Z = 0, and parametric value V = 0)  perpendicular to
    the symmetry axis. The "XAxis" defines the origin of the
    parameter U = 0.  The trigonometric sense gives the positive
    orientation for the parameter U.

    When you create a CylindricalSurface the U and V directions of
    parametrization are such that at each point of the surface the
    normal is oriented towards the "outside region".

    The methods UReverse VReverse change the orientation of the
    surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_CylindricalSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_CylindricalSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_CylindricalSurface self, gp_Ax3 A3, Standard_Real const Radius) -> Geom_CylindricalSurface
        __init__(Geom_CylindricalSurface self, gp_Cylinder C) -> Geom_CylindricalSurface

        Creates a CylindricalSurface from a non transient Cylinder
        from package gp.

        :type C: OCC.wrapper.gp.gp_Cylinder

        """
        this = _Geom.new_Geom_CylindricalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCylinder(self, *args):
        """
        SetCylinder(Geom_CylindricalSurface self, gp_Cylinder C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Cylinder

        """
        return _Geom.Geom_CylindricalSurface_SetCylinder(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Geom_CylindricalSurface self, Standard_Real const R)

        Changes the radius of the cylinder.
        Raised if R < 0.0

        :type R: float

        """
        return _Geom.Geom_CylindricalSurface_SetRadius(self, *args)


    def Cylinder(self, *args):
        """
        Cylinder(Geom_CylindricalSurface self) -> gp_Cylinder

        returns a non transient cylinder with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _Geom.Geom_CylindricalSurface_Cylinder(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_CylindricalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CylindricalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_CylindricalSurface self, Standard_Real const V) -> Standard_Real

        Return the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.
        Return -V

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CylindricalSurface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_CylindricalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are the new values of U,V after calling
        me->TranformParameters(U,V,T)
        This methods multiplies V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_CylindricalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_CylindricalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by
        me->ParametricTransformation(T)
        This  methods  returns  a scale  centered  on  the
        U axis with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_CylindricalSurface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_CylindricalSurface self)

        The CylindricalSurface is infinite in the V direction so
        V1 = Realfirst, V2 = RealLast from package Standard.
        U1 = 0 and U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_CylindricalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Geom_CylindricalSurface self)

        Returns the coefficients of the implicit equation of the quadric
        in the absolute cartesian coordinate system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Geom_CylindricalSurface_Coefficients(self, *args)


    def Radius(self, *args):
        """
        Radius(Geom_CylindricalSurface self) -> Standard_Real

        Returns the radius of this cylinder.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_CylindricalSurface_Radius(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_CylindricalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_CylindricalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_CylindricalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_CylindricalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_CylindricalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_CylindricalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_CylindricalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_CylindricalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_CylindricalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        The UIso curve is a Line. The location point of this line is
        on the placement plane (XAxis, YAxis) of the surface.
        This line is parallel to the axis of symmetry of the surface.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_CylindricalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_CylindricalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        The VIso curve is a circle. The start point of this circle
        (U = 0) is defined with the "XAxis" of the surface.
        The center of the circle is on the symmetry axis.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_CylindricalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + Radius * (cos (U) * XDir + sin (U) * YDir) +
        V * ZDir
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_CylindricalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_CylindricalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_CylindricalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first, the second and the
        third   derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_CylindricalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and Nv
        in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_CylindricalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_CylindricalSurface self, gp_Trsf T)

        Applies the transformation T to this cylinder.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_CylindricalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_CylindricalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this cylinder.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_CylindricalSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_CylindricalSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_CylindricalSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_CylindricalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_CylindricalSurface
Geom_CylindricalSurface_swigregister = _Geom.Geom_CylindricalSurface_swigregister
Geom_CylindricalSurface_swigregister(Geom_CylindricalSurface)

def Geom_CylindricalSurface_get_type_name(*args):
    """
    Geom_CylindricalSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_CylindricalSurface_get_type_name(*args)

def Geom_CylindricalSurface_get_type_descriptor(*args):
    """
    Geom_CylindricalSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_CylindricalSurface_get_type_descriptor(*args)

class Handle_Geom_CylindricalSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_CylindricalSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_CylindricalSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_CylindricalSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_CylindricalSurface self, Geom_CylindricalSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_CylindricalSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_CylindricalSurface self, Handle_Geom_CylindricalSurface theHandle) -> Handle_Geom_CylindricalSurface
        assign(Handle_Geom_CylindricalSurface self, Geom_CylindricalSurface thePtr) -> Handle_Geom_CylindricalSurface
        assign(Handle_Geom_CylindricalSurface self, Handle_Geom_CylindricalSurface theHandle) -> Handle_Geom_CylindricalSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_CylindricalSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_CylindricalSurface self) -> Geom_CylindricalSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_CylindricalSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_CylindricalSurface self) -> Geom_CylindricalSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_CylindricalSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_CylindricalSurface self) -> Geom_CylindricalSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_CylindricalSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_CylindricalSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_CylindricalSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_CylindricalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_CylindricalSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_CylindricalSurface

    def SetCylinder(self, *args):
        """
        SetCylinder(Handle_Geom_CylindricalSurface self, gp_Cylinder C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Cylinder

        """
        return _Geom.Handle_Geom_CylindricalSurface_SetCylinder(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_Geom_CylindricalSurface self, Standard_Real const R)

        Changes the radius of the cylinder.
        Raised if R < 0.0

        :type R: float

        """
        return _Geom.Handle_Geom_CylindricalSurface_SetRadius(self, *args)


    def Cylinder(self, *args):
        """
        Cylinder(Handle_Geom_CylindricalSurface self) -> gp_Cylinder

        returns a non transient cylinder with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _Geom.Handle_Geom_CylindricalSurface_Cylinder(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_CylindricalSurface self, Standard_Real const U) -> Standard_Real

        Return the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.
        Return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CylindricalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_CylindricalSurface self, Standard_Real const V) -> Standard_Real

        Return the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.
        Return -V

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CylindricalSurface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_CylindricalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are the new values of U,V after calling
        me->TranformParameters(U,V,T)
        This methods multiplies V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_CylindricalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_CylindricalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by
        me->ParametricTransformation(T)
        This  methods  returns  a scale  centered  on  the
        U axis with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_CylindricalSurface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_CylindricalSurface self)

        The CylindricalSurface is infinite in the V direction so
        V1 = Realfirst, V2 = RealLast from package Standard.
        U1 = 0 and U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_CylindricalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Handle_Geom_CylindricalSurface self)

        Returns the coefficients of the implicit equation of the quadric
        in the absolute cartesian coordinate system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Handle_Geom_CylindricalSurface_Coefficients(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_Geom_CylindricalSurface self) -> Standard_Real

        Returns the radius of this cylinder.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CylindricalSurface_Radius(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_CylindricalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_CylindricalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_CylindricalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_CylindricalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_CylindricalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        The UIso curve is a Line. The location point of this line is
        on the placement plane (XAxis, YAxis) of the surface.
        This line is parallel to the axis of symmetry of the surface.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_CylindricalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_CylindricalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        The VIso curve is a circle. The start point of this circle
        (U = 0) is defined with the "XAxis" of the surface.
        The center of the circle is on the symmetry axis.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_CylindricalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + Radius * (cos (U) * XDir + sin (U) * YDir) +
        V * ZDir
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CylindricalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_CylindricalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_CylindricalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first, the second and the
        third   derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_CylindricalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and Nv
        in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_CylindricalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_CylindricalSurface self, gp_Trsf T)

        Applies the transformation T to this cylinder.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_CylindricalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_CylindricalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this cylinder.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_CylindricalSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_CylindricalSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_CylindricalSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_CylindricalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_CylindricalSurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_CylindricalSurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_CylindricalSurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CylindricalSurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_CylindricalSurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_CylindricalSurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_CylindricalSurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_CylindricalSurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_CylindricalSurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CylindricalSurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_CylindricalSurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_CylindricalSurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Handle_Geom_CylindricalSurface_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_CylindricalSurface self)

        Reverses the V parametric direction of the surface.


        """
        return _Geom.Handle_Geom_CylindricalSurface_VReverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_CylindricalSurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_CylindricalSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_CylindricalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_CylindricalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsCNv(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_CylindricalSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_CylindricalSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_CylindricalSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_CylindricalSurface_VReversed(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_CylindricalSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CylindricalSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_CylindricalSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_CylindricalSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_CylindricalSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CylindricalSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_CylindricalSurface self, gp_Pnt P)
        Mirror(Handle_Geom_CylindricalSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_CylindricalSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_CylindricalSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_CylindricalSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_CylindricalSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_CylindricalSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_CylindricalSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_CylindricalSurface self, gp_Vec V)
        Translate(Handle_Geom_CylindricalSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_CylindricalSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_CylindricalSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_CylindricalSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_CylindricalSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_CylindricalSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_CylindricalSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_CylindricalSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_CylindricalSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_CylindricalSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_CylindricalSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_CylindricalSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_CylindricalSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_CylindricalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_CylindricalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_CylindricalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_CylindricalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_CylindricalSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_CylindricalSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_CylindricalSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_CylindricalSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_CylindricalSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_CylindricalSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_CylindricalSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_CylindricalSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_CylindricalSurface_DecrementRefCounter(self, *args)

Handle_Geom_CylindricalSurface_swigregister = _Geom.Handle_Geom_CylindricalSurface_swigregister
Handle_Geom_CylindricalSurface_swigregister(Handle_Geom_CylindricalSurface)

def Handle_Geom_CylindricalSurface_DownCast(thing):
    return _Geom.Handle_Geom_CylindricalSurface_DownCast(thing)
Handle_Geom_CylindricalSurface_DownCast = _Geom.Handle_Geom_CylindricalSurface_DownCast

class Handle_Geom_BoundedSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BoundedSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BoundedSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BoundedSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BoundedSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BoundedSurface self, Geom_BoundedSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BoundedSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BoundedSurface self, Handle_Geom_BoundedSurface theHandle) -> Handle_Geom_BoundedSurface
        assign(Handle_Geom_BoundedSurface self, Geom_BoundedSurface thePtr) -> Handle_Geom_BoundedSurface
        assign(Handle_Geom_BoundedSurface self, Handle_Geom_BoundedSurface theHandle) -> Handle_Geom_BoundedSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BoundedSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BoundedSurface self) -> Geom_BoundedSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BoundedSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BoundedSurface self) -> Geom_BoundedSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BoundedSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BoundedSurface self) -> Geom_BoundedSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BoundedSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BoundedSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BoundedSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BoundedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BoundedSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BoundedSurface

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BoundedSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BoundedSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BoundedSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BoundedSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_BoundedSurface self)

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_BoundedSurface_UReverse(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_BoundedSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BoundedSurface_UReversed(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_BoundedSurface self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)

        is the same point as

        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_BoundedSurface self)

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_BoundedSurface_VReverse(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_BoundedSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BoundedSurface_VReversed(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_BoundedSurface self, Standard_Real const V) -> Standard_Real

        Returns the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))

        is the same point as

        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedSurface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_BoundedSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BoundedSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BoundedSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_BoundedSurface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_BoundedSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this surface.
        If the surface is infinite, this function can return a value
        equal to Precision::Infinite: instead of Standard_Real::LastReal.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BoundedSurface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_BoundedSurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the u parametric direction: taking
        uFirst and uLast as the parametric bounds in
        the u parametric direction, for each parameter v, the
        distance between the points P(uFirst, v) and
        P(uLast, v) is less than or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_BoundedSurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the v parametric
        direction: taking vFirst and vLast as the
        parametric bounds in the v parametric direction, for
        each parameter u, the distance between the points
        P(u, vFirst) and P(u, vLast) is less than
        or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_BoundedSurface self) -> Standard_Boolean

        Checks if this surface is periodic in the u
        parametric direction. Returns true if:
        - this surface is closed in the u parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the u parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_BoundedSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_BoundedSurface self) -> Standard_Boolean

        Checks if this surface is periodic in the v
        parametric direction. Returns true if:
        - this surface is closed in the v parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_BoundedSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_BoundedSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BoundedSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_BoundedSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BoundedSurface_VIso(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BoundedSurface self) -> GeomAbs_Shape

        Returns the Global Continuity of the surface in direction U and V :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.
        Example :
        If the surface is C1 in the V parametric direction and C2
        in the U parametric direction Shape = C1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BoundedSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_BoundedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        U parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_BoundedSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        V parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the surface.

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        ---Purpose ;
        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        Raised if the continuity of the surface is not CNu in the U
        direction or not CNv in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedSurface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BoundedSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BoundedSurface self, gp_Pnt P)
        Mirror(Handle_Geom_BoundedSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_BoundedSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BoundedSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BoundedSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BoundedSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BoundedSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BoundedSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BoundedSurface self, gp_Vec V)
        Translate(Handle_Geom_BoundedSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedSurface_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BoundedSurface self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BoundedSurface_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BoundedSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BoundedSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BoundedSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BoundedSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BoundedSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BoundedSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BoundedSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BoundedSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BoundedSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedSurface_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BoundedSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BoundedSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BoundedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BoundedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BoundedSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BoundedSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BoundedSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BoundedSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BoundedSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BoundedSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BoundedSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BoundedSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BoundedSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BoundedSurface_DecrementRefCounter(self, *args)

Handle_Geom_BoundedSurface_swigregister = _Geom.Handle_Geom_BoundedSurface_swigregister
Handle_Geom_BoundedSurface_swigregister(Handle_Geom_BoundedSurface)

def Handle_Geom_BoundedSurface_DownCast(thing):
    return _Geom.Handle_Geom_BoundedSurface_DownCast(thing)
Handle_Geom_BoundedSurface_DownCast = _Geom.Handle_Geom_BoundedSurface_DownCast

class Handle_Geom_UndefinedDerivative(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_UndefinedDerivative self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_UndefinedDerivative_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_UndefinedDerivative self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_UndefinedDerivative_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_UndefinedDerivative self, Geom_UndefinedDerivative thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_UndefinedDerivative_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_UndefinedDerivative self, Handle_Geom_UndefinedDerivative theHandle) -> Handle_Geom_UndefinedDerivative
        assign(Handle_Geom_UndefinedDerivative self, Geom_UndefinedDerivative thePtr) -> Handle_Geom_UndefinedDerivative
        assign(Handle_Geom_UndefinedDerivative self, Handle_Geom_UndefinedDerivative theHandle) -> Handle_Geom_UndefinedDerivative

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_UndefinedDerivative_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_UndefinedDerivative self) -> Geom_UndefinedDerivative

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_UndefinedDerivative_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_UndefinedDerivative self) -> Geom_UndefinedDerivative

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_UndefinedDerivative___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_UndefinedDerivative self) -> Geom_UndefinedDerivative

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_UndefinedDerivative___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_UndefinedDerivative___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_UndefinedDerivative___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_UndefinedDerivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_UndefinedDerivative_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_UndefinedDerivative

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Geom_UndefinedDerivative self, Standard_CString const theMessage) -> Handle_Geom_UndefinedDerivative

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedDerivative

        """
        return _Geom.Handle_Geom_UndefinedDerivative_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_UndefinedDerivative self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_UndefinedDerivative_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_UndefinedDerivative_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_UndefinedDerivative_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Geom_UndefinedDerivative self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom.Handle_Geom_UndefinedDerivative_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Geom_UndefinedDerivative self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom.Handle_Geom_UndefinedDerivative_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Geom_UndefinedDerivative self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom.Handle_Geom_UndefinedDerivative_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Geom_UndefinedDerivative self)
        Reraise(Handle_Geom_UndefinedDerivative self, Standard_CString const aMessage)
        Reraise(Handle_Geom_UndefinedDerivative self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Geom.Handle_Geom_UndefinedDerivative_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Geom_UndefinedDerivative self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Geom.Handle_Geom_UndefinedDerivative_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Geom_UndefinedDerivative self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Geom.Handle_Geom_UndefinedDerivative_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_UndefinedDerivative self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_UndefinedDerivative_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_UndefinedDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_UndefinedDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_UndefinedDerivative_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_UndefinedDerivative self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_UndefinedDerivative self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_UndefinedDerivative_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_UndefinedDerivative self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_UndefinedDerivative_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_UndefinedDerivative self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_UndefinedDerivative_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_UndefinedDerivative self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_UndefinedDerivative_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_UndefinedDerivative self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_UndefinedDerivative_DecrementRefCounter(self, *args)

Handle_Geom_UndefinedDerivative_swigregister = _Geom.Handle_Geom_UndefinedDerivative_swigregister
Handle_Geom_UndefinedDerivative_swigregister(Handle_Geom_UndefinedDerivative)

def Handle_Geom_UndefinedDerivative_DownCast(thing):
    return _Geom.Handle_Geom_UndefinedDerivative_DownCast(thing)
Handle_Geom_UndefinedDerivative_DownCast = _Geom.Handle_Geom_UndefinedDerivative_DownCast

class Handle_Geom_UndefinedValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_UndefinedValue self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_UndefinedValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_UndefinedValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_UndefinedValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_UndefinedValue self, Geom_UndefinedValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_UndefinedValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_UndefinedValue self, Handle_Geom_UndefinedValue theHandle) -> Handle_Geom_UndefinedValue
        assign(Handle_Geom_UndefinedValue self, Geom_UndefinedValue thePtr) -> Handle_Geom_UndefinedValue
        assign(Handle_Geom_UndefinedValue self, Handle_Geom_UndefinedValue theHandle) -> Handle_Geom_UndefinedValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_UndefinedValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_UndefinedValue self) -> Geom_UndefinedValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_UndefinedValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_UndefinedValue self) -> Geom_UndefinedValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_UndefinedValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_UndefinedValue self) -> Geom_UndefinedValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_UndefinedValue___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_UndefinedValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_UndefinedValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_UndefinedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_UndefinedValue_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_UndefinedValue

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Geom_UndefinedValue self, Standard_CString const theMessage) -> Handle_Geom_UndefinedValue

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Geom.Handle_Geom_UndefinedValue

        """
        return _Geom.Handle_Geom_UndefinedValue_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_UndefinedValue self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_UndefinedValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_UndefinedValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_UndefinedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Geom_UndefinedValue self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom.Handle_Geom_UndefinedValue_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Geom_UndefinedValue self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom.Handle_Geom_UndefinedValue_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Geom_UndefinedValue self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Geom.Handle_Geom_UndefinedValue_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Geom_UndefinedValue self)
        Reraise(Handle_Geom_UndefinedValue self, Standard_CString const aMessage)
        Reraise(Handle_Geom_UndefinedValue self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Geom.Handle_Geom_UndefinedValue_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Geom_UndefinedValue self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Geom.Handle_Geom_UndefinedValue_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Geom_UndefinedValue self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Geom.Handle_Geom_UndefinedValue_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_UndefinedValue self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_UndefinedValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_UndefinedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_UndefinedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_UndefinedValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_UndefinedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_UndefinedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_UndefinedValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_UndefinedValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_UndefinedValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_UndefinedValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_UndefinedValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_UndefinedValue self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_UndefinedValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_UndefinedValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_UndefinedValue_DecrementRefCounter(self, *args)

Handle_Geom_UndefinedValue_swigregister = _Geom.Handle_Geom_UndefinedValue_swigregister
Handle_Geom_UndefinedValue_swigregister(Handle_Geom_UndefinedValue)

def Handle_Geom_UndefinedValue_DownCast(thing):
    return _Geom.Handle_Geom_UndefinedValue_DownCast(thing)
Handle_Geom_UndefinedValue_DownCast = _Geom.Handle_Geom_UndefinedValue_DownCast

class Handle_Geom_Transformation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Transformation self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Transformation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Transformation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Transformation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Transformation self, Geom_Transformation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Transformation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Transformation self, Handle_Geom_Transformation theHandle) -> Handle_Geom_Transformation
        assign(Handle_Geom_Transformation self, Geom_Transformation thePtr) -> Handle_Geom_Transformation
        assign(Handle_Geom_Transformation self, Handle_Geom_Transformation theHandle) -> Handle_Geom_Transformation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Transformation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Transformation self) -> Geom_Transformation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Transformation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Transformation self) -> Geom_Transformation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Transformation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Transformation self) -> Geom_Transformation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Transformation___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Transformation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Transformation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Transformation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Transformation_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Transformation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Transformation self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Transformation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Transformation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Transformation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMirror(self, *args):
        """
        SetMirror(Handle_Geom_Transformation self, gp_Pnt thePnt)
        SetMirror(Handle_Geom_Transformation self, gp_Ax1 theA1)
        SetMirror(Handle_Geom_Transformation self, gp_Ax2 theA2)

        Makes the transformation into a symmetrical transformation
        with respect to a plane.  The plane of the symmetry is
        defined with the axis placement A2. It is the plane
        (Location, XDirection, YDirection).

        :type theA2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Transformation_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(Handle_Geom_Transformation self, gp_Ax1 theA1, Standard_Real const theAng)

        Makes the transformation into a rotation.
        A1 is the axis rotation and Ang is the angular value
        of the rotation in radians.

        :type theA1: OCC.wrapper.gp.gp_Ax1
        :type theAng: float

        """
        return _Geom.Handle_Geom_Transformation_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(Handle_Geom_Transformation self, gp_Pnt thePnt, Standard_Real const theScale)

        Makes the transformation into a scale. P is the center of
        the scale and S is the scaling value.

        :type thePnt: OCC.wrapper.gp.gp_Pnt
        :type theScale: float

        """
        return _Geom.Handle_Geom_Transformation_SetScale(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(Handle_Geom_Transformation self, gp_Ax3 theFromSystem1, gp_Ax3 theToSystem2)
        SetTransformation(Handle_Geom_Transformation self, gp_Ax3 theToSystem)

        Makes the transformation allowing passage from the basic
        coordinate system
        {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.), VZ (0., 0. ,1.) }
        to the local coordinate system defined with the Ax2 ToSystem.
        Same utilisation as the previous method. FromSystem1 is
        defaulted to the absolute coordinate system.

        :type theToSystem: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_Transformation_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(Handle_Geom_Transformation self, gp_Vec theVec)
        SetTranslation(Handle_Geom_Transformation self, gp_Pnt P1, gp_Pnt P2)

        Makes the transformation into a translation from the point
        P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Transformation_SetTranslation(self, *args)


    def SetTrsf(self, *args):
        """
        SetTrsf(Handle_Geom_Transformation self, gp_Trsf theTrsf)

        Converts the gp_Trsf transformation T into this transformation.

        :type theTrsf: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Transformation_SetTrsf(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(Handle_Geom_Transformation self) -> Standard_Boolean

        Checks whether this transformation is an indirect
        transformation: returns true if the determinant of the
        matrix of the vectorial part of the transformation is less than 0.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Transformation_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(Handle_Geom_Transformation self) -> gp_TrsfForm

        Returns the nature of this transformation as a value
        of the gp_TrsfForm enumeration.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _Geom.Handle_Geom_Transformation_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(Handle_Geom_Transformation self) -> Standard_Real

        Returns the scale value of the transformation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Transformation_ScaleFactor(self, *args)


    def Trsf(self, *args):
        """
        Returns a non transient copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _Geom.Handle_Geom_Transformation_Trsf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(Handle_Geom_Transformation self, Standard_Integer const theRow, Standard_Integer const theCol) -> Standard_Real

        Returns the coefficients of the global matrix of transformation.
        It is a 3 rows X 4 columns matrix.

        Raised if  Row < 1 or Row > 3  or  Col < 1 or Col > 4

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Transformation_Value(self, *args)


    def Invert(self, *args):
        """
        Invert(Handle_Geom_Transformation self)

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.


        """
        return _Geom.Handle_Geom_Transformation_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(Handle_Geom_Transformation self) -> Handle_Geom_Transformation

        Raised if the the transformation is singular. This means that
        the ScaleFactor is lower or equal to Resolution from
        package gp.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Handle_Geom_Transformation self, Handle_Geom_Transformation Other) -> Handle_Geom_Transformation

        Computes the transformation composed with Other and <me>.
        <me> * Other.
        Returns a new transformation

        :type Other: OCC.wrapper.Geom.Handle_Geom_Transformation
        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Geom_Transformation self, Handle_Geom_Transformation theOther)

        Computes the transformation composed with Other and <me> .
        <me> = <me> * Other.

        :type theOther: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_Multiply(self, *args)


    def Power(self, *args):
        """
        Power(Handle_Geom_Transformation self, Standard_Integer const N)

        Computes the following composition of transformations
        if N > 0  <me> * <me> * .......* <me>.
        if N = 0  Identity
        if N < 0  <me>.Invert() * .........* <me>.Invert()

        Raised if N < 0 and if the transformation is not inversible

        :type N: int

        """
        return _Geom.Handle_Geom_Transformation_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(Handle_Geom_Transformation self, Standard_Integer const N) -> Handle_Geom_Transformation

        Raised if N < 0 and if the transformation is not inversible

        :type N: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_Powered(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(Handle_Geom_Transformation self, Handle_Geom_Transformation Other)

        Computes the matrix of the transformation composed with
        <me> and Other.     <me> = Other * <me>

        :type Other: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_PreMultiply(self, *args)


    def Transforms(self, *args):
        """
        Transforms(Handle_Geom_Transformation self)

        Applies the transformation <me> to the triplet {X, Y, Z}.

        :type theX: float
        :type theY: float
        :type theZ: float

        """
        return _Geom.Handle_Geom_Transformation_Transforms(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Transformation self) -> Handle_Geom_Transformation

        Creates a new object which is a copy of this transformation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _Geom.Handle_Geom_Transformation_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Transformation self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Transformation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Transformation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Transformation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Transformation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Transformation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Transformation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Transformation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Transformation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Transformation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Transformation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Transformation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Transformation self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Transformation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Transformation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Transformation_DecrementRefCounter(self, *args)

Handle_Geom_Transformation_swigregister = _Geom.Handle_Geom_Transformation_swigregister
Handle_Geom_Transformation_swigregister(Handle_Geom_Transformation)

def Handle_Geom_Transformation_DownCast(thing):
    return _Geom.Handle_Geom_Transformation_DownCast(thing)
Handle_Geom_Transformation_DownCast = _Geom.Handle_Geom_Transformation_DownCast

class Handle_Geom_Direction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Direction self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Direction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Direction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Direction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Direction self, Geom_Direction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Direction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Direction self, Handle_Geom_Direction theHandle) -> Handle_Geom_Direction
        assign(Handle_Geom_Direction self, Geom_Direction thePtr) -> Handle_Geom_Direction
        assign(Handle_Geom_Direction self, Handle_Geom_Direction theHandle) -> Handle_Geom_Direction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Direction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Direction self) -> Geom_Direction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Direction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Direction self) -> Geom_Direction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Direction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Direction self) -> Geom_Direction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Direction___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Direction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Direction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Direction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Direction_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Direction

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom_Direction self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Sets <me> to X,Y,Z coordinates.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_Direction_SetCoord(self, *args)


    def SetDir(self, *args):
        """
        SetDir(Handle_Geom_Direction self, gp_Dir V)

        Converts the gp_Dir unit vector V into this unit vector.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Direction_SetDir(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom_Direction self, Standard_Real const X)

        Changes the X coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type X: float

        """
        return _Geom.Handle_Geom_Direction_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom_Direction self, Standard_Real const Y)

        Changes the Y coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type Y: float

        """
        return _Geom.Handle_Geom_Direction_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Handle_Geom_Direction self, Standard_Real const Z)

        Changes the Z coordinate of <me>.

        Raised if Sqrt( X*X + Y*Y + Z*Z) <= Resolution from gp.

        :type Z: float

        """
        return _Geom.Handle_Geom_Direction_SetZ(self, *args)


    def Dir(self, *args):
        """
        Dir(Handle_Geom_Direction self) -> gp_Dir

        Returns the non transient direction with the same
        coordinates as <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_Direction_Dir(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom_Direction self) -> Standard_Real

        returns 1.0 which is the magnitude of any unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom_Direction self) -> Standard_Real

        returns 1.0 which is the square magnitude of any unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_SquareMagnitude(self, *args)


    def Cross(self, *args):
        """
        Cross(Handle_Geom_Direction self, Handle_Geom_Vector Other)

        Computes the cross product between <me> and <Other>.

        Raised if the two vectors are parallel because it is
        not possible to have a direction with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Direction_Cross(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Handle_Geom_Direction self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^(V1 ^ V2).

        Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are
        parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Direction_CrossCross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom_Direction self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product between <me> and <Other>.
        A new direction is returned.

        Raised if the two vectors are parallel because it is
        not possible to have a direction with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Direction_Crossed(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Handle_Geom_Direction self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product <me> ^(V1 ^ V2).

        Raised if V1 and V2 are parallel or <me> and (V1 ^ V2) are
        parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Direction_CrossCrossed(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Direction self, gp_Trsf T)

        Applies the transformation T to this unit vector, then normalizes it.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Direction_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Direction self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this unit vector.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Direction self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Direction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Direction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Direction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Direction self)

        Reverses the vector <me>.


        """
        return _Geom.Handle_Geom_Direction_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Direction self) -> Handle_Geom_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Direction_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_Direction self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value between 0 and Pi.
        Exceptions
        gp_VectorWithNullMagnitude if:
        - the magnitude of this vector is less than or equal to
        gp::Resolution(), or
        - the magnitude of vector Other is less than or equal
        to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(Handle_Geom_Direction self, Handle_Geom_Vector Other, Handle_Geom_Vector VRef) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The vector VRef defines the
        positive sense of rotation: the angular value is positive
        if the cross product this ^ Other has the same
        orientation as VRef (in relation to the plane defined
        by this vector and vector Other). Otherwise, it is negative.
        Exceptions
        Standard_DomainError if this vector, vector Other
        and vector VRef are coplanar, except if this vector
        and vector Other are parallel.
        gp_VectorWithNullMagnitude if the magnitude of
        this vector, vector Other or vector VRef is less than
        or equal to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :type VRef: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_AngleWithRef(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom_Direction self)

        Returns the coordinates X, Y and Z of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_Direction_Coord(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom_Direction self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom_Direction self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_Y(self, *args)


    def Z(self, *args):
        """
        Z(Handle_Geom_Direction self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_Z(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom_Direction self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the scalar product of this vector and vector Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_Dot(self, *args)


    def DotCross(self, *args):
        """
        DotCross(Handle_Geom_Direction self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Standard_Real

        Computes the triple scalar product. Returns me . (V1 ^ V2)

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Direction_DotCross(self, *args)


    def Vec(self, *args):
        """
        Converts this vector into a gp_Vec vector.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Geom.Handle_Geom_Direction_Vec(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Direction self, gp_Pnt P)
        Mirror(Handle_Geom_Direction self, gp_Ax1 A1)
        Mirror(Handle_Geom_Direction self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Direction_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Direction self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Direction_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Direction self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Direction_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Direction self, gp_Vec V)
        Translate(Handle_Geom_Direction self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Direction_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Direction self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Direction self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Direction self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Direction self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Direction self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Direction self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Direction self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Direction self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Direction_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Direction self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Direction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Direction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Direction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Direction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Direction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Direction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Direction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Direction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Direction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Direction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Direction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Direction self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Direction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Direction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Direction_DecrementRefCounter(self, *args)

Handle_Geom_Direction_swigregister = _Geom.Handle_Geom_Direction_swigregister
Handle_Geom_Direction_swigregister(Handle_Geom_Direction)

def Handle_Geom_Direction_DownCast(thing):
    return _Geom.Handle_Geom_Direction_DownCast(thing)
Handle_Geom_Direction_DownCast = _Geom.Handle_Geom_Direction_DownCast

class Geom_SphericalSurface(Geom_ElementarySurface):
    """
    Describes a sphere.
    A sphere is defined by its radius, and is positioned in
    space by a coordinate system (a gp_Ax3 object), the
    origin of which is the center of the sphere.
    This coordinate system is the "local coordinate
    system" of the sphere. The following apply:
    - Rotation around its "main Axis", in the trigonometric
    sense given by the "X Direction" and the "Y
    Direction", defines the u parametric direction.
    - Its "X Axis" gives the origin for the u parameter.
    - The "reference meridian" of the sphere is a
    half-circle, of radius equal to the radius of the
    sphere. It is located in the plane defined by the
    origin, "X Direction" and "main Direction", centered
    on the origin, and positioned on the positive side of the "X Axis".
    - Rotation around the "Y Axis" gives the v parameter
    on the reference meridian.
    - The "X Axis" gives the origin of the v parameter on
    the reference meridian.
    - The v parametric direction is oriented by the "main
    Direction", i.e. when v increases, the Z coordinate
    increases. (This implies that the "Y Direction"
    orients the reference meridian only when the local
    coordinate system is indirect.)
    - The u isoparametric curve is a half-circle obtained
    by rotating the reference meridian of the sphere
    through an angle u around the "main Axis", in the
    trigonometric sense defined by the "X Direction"
    and the "Y Direction".
    The parametric equation of the sphere is:
    P(u,v) = O + R*cos(v)*(cos(u)*XDir + sin(u)*YDir)+R*sin(v)*ZDir
    where:
    - O, XDir, YDir and ZDir are respectively the
    origin, the "X Direction", the "Y Direction" and the "Z
    Direction" of its local coordinate system, and
    - R is the radius of the sphere.
    The parametric range of the two parameters is:
    - [ 0, 2.*Pi ] for u, and
    - [ - Pi/2., + Pi/2. ] for v.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_SphericalSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_SphericalSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_SphericalSurface self, gp_Ax3 A3, Standard_Real const Radius) -> Geom_SphericalSurface
        __init__(Geom_SphericalSurface self, gp_Sphere S) -> Geom_SphericalSurface

        Creates a SphericalSurface from a non persistent Sphere from
        package gp.

        :type S: OCC.wrapper.gp.gp_Sphere

        """
        this = _Geom.new_Geom_SphericalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetRadius(self, *args):
        """
        SetRadius(Geom_SphericalSurface self, Standard_Real const R)

        Assigns the value R to the radius of this sphere.
        Exceptions Standard_ConstructionError if R is less than 0.0.

        :type R: float

        """
        return _Geom.Geom_SphericalSurface_SetRadius(self, *args)


    def SetSphere(self, *args):
        """
        SetSphere(Geom_SphericalSurface self, gp_Sphere S)

        Converts the gp_Sphere S into this sphere.

        :type S: OCC.wrapper.gp.gp_Sphere

        """
        return _Geom.Geom_SphericalSurface_SetSphere(self, *args)


    def Sphere(self, *args):
        """
        Sphere(Geom_SphericalSurface self) -> gp_Sphere

        Returns a non persistent sphere with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _Geom.Geom_SphericalSurface_Sphere(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_SphericalSurface self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, when reversing its u  parametric
        direction, for any point of u parameter U on this sphere.
        In the case of a sphere, these functions returns 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SphericalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_SphericalSurface self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, when reversing its v parametric
        direction, for any point of v parameter V on this sphere.
        In the case of a sphere, these functions returns   -U.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SphericalSurface_VReversedParameter(self, *args)


    def Area(self, *args):
        """
        Area(Geom_SphericalSurface self) -> Standard_Real

        Computes the aera of the spherical surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SphericalSurface_Area(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_SphericalSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this sphere.
        For a sphere: U1 = 0, U2 = 2*PI, V1 = -PI/2, V2 = PI/2.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_SphericalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Geom_SphericalSurface self)

        Returns the coefficients of the implicit equation of the
        quadric in the absolute cartesian coordinates system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Geom_SphericalSurface_Coefficients(self, *args)


    def Radius(self, *args):
        """
        Radius(Geom_SphericalSurface self) -> Standard_Real

        Computes the coefficients of the implicit equation of
        this quadric in the absolute Cartesian coordinate system:
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0
        An implicit normalization is applied (i.e. A1 = A2 = 1.
        in the local coordinate system of this sphere).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SphericalSurface_Radius(self, *args)


    def Volume(self, *args):
        """
        Volume(Geom_SphericalSurface self) -> Standard_Real

        Computes the volume of the spherical surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SphericalSurface_Volume(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_SphericalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SphericalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_SphericalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SphericalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_SphericalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SphericalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_SphericalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SphericalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_SphericalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        The U isoparametric curves of the surface are defined by the
        section of the spherical surface with plane obtained by rotation
        of the plane (Location, XAxis, ZAxis) around ZAxis. This plane
        defines the origin of parametrization u.
        For a SphericalSurface the UIso curve is a Circle.
        Warnings : The radius of this circle can be zero.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SphericalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_SphericalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        The V isoparametric curves of the surface  are defined by
        the section of the spherical surface with plane parallel to the
        plane (Location, XAxis, YAxis). This plane defines the origin of
        parametrization V.
        Be careful if  V is close to PI/2 or 3*PI/2 the radius of the
        circle becomes tiny. It is not forbidden in this toolkit to
        create circle with radius = 0.0
        For a SphericalSurface the VIso curve is a Circle.
        Warnings : The radius of this circle can be zero.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SphericalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + Radius * Sin (V) * Zdir +
        Radius * Cos (V) * (cos (U) * XDir + sin (U) * YDir)
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis and ZDir the direction of the ZAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_SphericalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SphericalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SphericalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SphericalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SphericalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_SphericalSurface self, gp_Trsf T)

        Applies the transformation T to this sphere.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_SphericalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_SphericalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this sphere.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_SphericalSurface_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_SphericalSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_SphericalSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_SphericalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_SphericalSurface
Geom_SphericalSurface_swigregister = _Geom.Geom_SphericalSurface_swigregister
Geom_SphericalSurface_swigregister(Geom_SphericalSurface)

def Geom_SphericalSurface_get_type_name(*args):
    """
    Geom_SphericalSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_SphericalSurface_get_type_name(*args)

def Geom_SphericalSurface_get_type_descriptor(*args):
    """
    Geom_SphericalSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_SphericalSurface_get_type_descriptor(*args)

class Handle_Geom_BoundedCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BoundedCurve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BoundedCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BoundedCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BoundedCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BoundedCurve self, Geom_BoundedCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BoundedCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BoundedCurve self, Handle_Geom_BoundedCurve theHandle) -> Handle_Geom_BoundedCurve
        assign(Handle_Geom_BoundedCurve self, Geom_BoundedCurve thePtr) -> Handle_Geom_BoundedCurve
        assign(Handle_Geom_BoundedCurve self, Handle_Geom_BoundedCurve theHandle) -> Handle_Geom_BoundedCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BoundedCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BoundedCurve self) -> Geom_BoundedCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BoundedCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BoundedCurve self) -> Geom_BoundedCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BoundedCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BoundedCurve self) -> Geom_BoundedCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BoundedCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BoundedCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BoundedCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BoundedCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BoundedCurve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BoundedCurve

    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom_BoundedCurve self) -> gp_Pnt

        Returns the end point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedCurve_EndPoint(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom_BoundedCurve self) -> gp_Pnt

        Returns the start point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedCurve_StartPoint(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BoundedCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BoundedCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BoundedCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BoundedCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_BoundedCurve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom.Handle_Geom_BoundedCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_BoundedCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        me->Reversed()->Value(me->ReversedParameter(U))

        is the same point as

        me->Value(U)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_BoundedCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BoundedCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_BoundedCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BoundedCurve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_BoundedCurve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_BoundedCurve self) -> Standard_Real

        Returns the value of the last parameter.
        Warnings :
        It can be RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_BoundedCurve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_BoundedCurve self) -> Standard_Boolean

        Is the parametrization of the curve periodic ?
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_BoundedCurve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BoundedCurve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BoundedCurve self) -> GeomAbs_Shape

        It is the global continuity of the curve
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BoundedCurve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_BoundedCurve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions -  Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedCurve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BoundedCurve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BoundedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BoundedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BoundedCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BoundedCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the curve is not CN.

        Raised if the   derivative  cannot  be  computed
        easily. e.g. rational bspline and n > 3.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BoundedCurve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BoundedCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BoundedCurve self, gp_Pnt P)
        Mirror(Handle_Geom_BoundedCurve self, gp_Ax1 A1)
        Mirror(Handle_Geom_BoundedCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BoundedCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BoundedCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BoundedCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BoundedCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BoundedCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BoundedCurve self, gp_Vec V)
        Translate(Handle_Geom_BoundedCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BoundedCurve_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BoundedCurve self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BoundedCurve_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BoundedCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BoundedCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BoundedCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BoundedCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BoundedCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BoundedCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BoundedCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BoundedCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BoundedCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BoundedCurve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BoundedCurve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BoundedCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BoundedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BoundedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BoundedCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BoundedCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BoundedCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BoundedCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BoundedCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BoundedCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BoundedCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BoundedCurve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BoundedCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BoundedCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BoundedCurve_DecrementRefCounter(self, *args)

Handle_Geom_BoundedCurve_swigregister = _Geom.Handle_Geom_BoundedCurve_swigregister
Handle_Geom_BoundedCurve_swigregister(Handle_Geom_BoundedCurve)

def Handle_Geom_BoundedCurve_DownCast(thing):
    return _Geom.Handle_Geom_BoundedCurve_DownCast(thing)
Handle_Geom_BoundedCurve_DownCast = _Geom.Handle_Geom_BoundedCurve_DownCast

class Geom_SurfaceOfLinearExtrusion(Geom_SweptSurface):
    """
    Describes a surface of linear extrusion ("extruded
    surface"), e.g. a generalized cylinder. Such a surface
    is obtained by sweeping a curve (called the "extruded
    curve" or "basis") in a given direction (referred to as
    the "direction of extrusion" and defined by a unit vector).
    The u parameter is along the extruded curve. The v
    parameter is along the direction of extrusion.
    The parameter range for the u parameter is defined
    by the reference curve.
    The parameter range for the v parameter is ] -
    infinity, + infinity [.
    The position of the curve gives the origin of the v parameter.
    The surface is "CN" in the v parametric direction.
    The form of a surface of linear extrusion is generally a
    ruled surface (GeomAbs_RuledForm). It can be:
    - a cylindrical surface, if the extruded curve is a circle,
    or a trimmed circle, with an axis parallel to the
    direction of extrusion (GeomAbs_CylindricalForm), or
    - a planar surface, if the extruded curve is a line
    (GeomAbs_PlanarForm).
    Note: The surface of extrusion is built from a copy of
    the original basis curve, so the original curve is not
    modified when the surface is modified.
    Warning
    Degenerate surfaces are not detected. A degenerate
    surface is obtained, for example, when the extruded
    curve is a line and the direction of extrusion is parallel
    to that line.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_SurfaceOfLinearExtrusion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_SurfaceOfLinearExtrusion(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_SurfaceOfLinearExtrusion self, Handle_Geom_Curve C, gp_Dir V) -> Geom_SurfaceOfLinearExtrusion

        V is the direction of extrusion.
        C is the extruded curve.
        The form of a SurfaceOfLinearExtrusion can be :
        . ruled surface (RuledForm),
        . a cylindrical surface if the extruded curve is a circle or
        a trimmed circle (CylindricalForm),
        . a plane surface if the extruded curve is a Line (PlanarForm).
        Warnings :
        Degenerated surface cases are not detected. For example if the
        curve C is a line and V is parallel to the direction of this
        line.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _Geom.new_Geom_SurfaceOfLinearExtrusion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDirection(self, *args):
        """
        SetDirection(Geom_SurfaceOfLinearExtrusion self, gp_Dir V)

        Assigns V as the "direction of extrusion" for this
        surface of linear extrusion.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_SetDirection(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Geom_SurfaceOfLinearExtrusion self, Handle_Geom_Curve C)

        Modifies this surface of linear extrusion by redefining
        its "basis curve" (the "extruded curve").

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_SetBasisCurve(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Geom_SurfaceOfLinearExtrusion self)

        Changes the orientation of this surface of linear
        extrusion in the u  parametric direction. The
        bounds of the surface are not changed, but the given
        parametric direction is reversed. Hence the
        orientation of the surface is reversed.
        In the case of a surface of linear extrusion:
        - UReverse reverses the basis curve, and
        - VReverse reverses the direction of linear extrusion.


        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, produced by reversing its u  parametric
        direction, for any point of u parameter U  on this surface of linear extrusion.
        In the case of an extruded surface:
        - UReverseParameter returns the reversed
        parameter given by the function
        ReversedParameter called with U on the basis   curve,

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Geom_SurfaceOfLinearExtrusion self)

        Changes the orientation of this surface of linear
        extrusion in the v parametric direction. The
        bounds of the surface are not changed, but the given
        parametric direction is reversed. Hence the
        orientation of the surface is reversed.
        In the case of a surface of linear extrusion:
        - UReverse reverses the basis curve, and
        - VReverse reverses the direction of linear extrusion.


        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Geom_SurfaceOfLinearExtrusion self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, produced by reversing its u v parametric
        direction, for any point of v parameter V on this surface of linear extrusion.
        In the case of an extruded surface VReverse returns -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Geom_SurfaceOfLinearExtrusion self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this surface of linear extrusion.
        A surface of linear extrusion is infinite in the v
        parametric direction, so:
        - V1 = Standard_Real::RealFirst()
        - V2 = Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsUClosed returns true if the "basis curve" of this
        surface of linear extrusion is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsVClosed always returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Geom_SurfaceOfLinearExtrusion self, Standard_Integer const N) -> Standard_Boolean

        IsCNu returns true if the degree of continuity for the
        "basis curve" of this surface of linear extrusion is at least N.
        Raises RangeError if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Geom_SurfaceOfLinearExtrusion self, Standard_Integer const N) -> Standard_Boolean

        IsCNv always returns true.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsUPeriodic returns true if the "basis curve" of this
        surface of linear extrusion is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsVPeriodic always returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of linear extrusion. This is the line parallel to the
        direction of extrusion, passing through the point of
        parameter U of the basis curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Geom_SurfaceOfLinearExtrusion self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve of this surface
        of linear extrusion. This curve is obtained by
        translating the extruded curve in the direction of
        extrusion, with the magnitude V.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        The parameter U is the parameter on the extruded curve.
        The parametrization V is a linear parametrization, and
        the direction of parametrization is the direction of
        extrusion. If the point is on the extruded curve, V = 0.0

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        --- Purpose ;
        Computes the current point, the first and the second derivatives
        in the directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raises UndefinedDerivative if the continuity of the surface is not CNu in the u
        direction and CNv in the v direction.
        Raises RangeError if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_SurfaceOfLinearExtrusion self, gp_Trsf T)

        Applies the transformation T to this surface of linear extrusion.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Geom_SurfaceOfLinearExtrusion self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies :
        U by BasisCurve()->ParametricTransformation(T)
        V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Geom_SurfaceOfLinearExtrusion self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale
        U by BasisCurve()->ParametricTransformation(T)
        V by T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_SurfaceOfLinearExtrusion self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this surface of linear extrusion.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_SurfaceOfLinearExtrusion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_SurfaceOfLinearExtrusion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_SurfaceOfLinearExtrusion
Geom_SurfaceOfLinearExtrusion_swigregister = _Geom.Geom_SurfaceOfLinearExtrusion_swigregister
Geom_SurfaceOfLinearExtrusion_swigregister(Geom_SurfaceOfLinearExtrusion)

def Geom_SurfaceOfLinearExtrusion_get_type_name(*args):
    """
    Geom_SurfaceOfLinearExtrusion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_SurfaceOfLinearExtrusion_get_type_name(*args)

def Geom_SurfaceOfLinearExtrusion_get_type_descriptor(*args):
    """
    Geom_SurfaceOfLinearExtrusion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_SurfaceOfLinearExtrusion_get_type_descriptor(*args)

class Handle_Geom_VectorWithMagnitude(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_VectorWithMagnitude self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_VectorWithMagnitude self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_VectorWithMagnitude self, Geom_VectorWithMagnitude thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_VectorWithMagnitude self, Handle_Geom_VectorWithMagnitude theHandle) -> Handle_Geom_VectorWithMagnitude
        assign(Handle_Geom_VectorWithMagnitude self, Geom_VectorWithMagnitude thePtr) -> Handle_Geom_VectorWithMagnitude
        assign(Handle_Geom_VectorWithMagnitude self, Handle_Geom_VectorWithMagnitude theHandle) -> Handle_Geom_VectorWithMagnitude

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_VectorWithMagnitude self) -> Geom_VectorWithMagnitude

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_VectorWithMagnitude self) -> Geom_VectorWithMagnitude

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_VectorWithMagnitude___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_VectorWithMagnitude self) -> Geom_VectorWithMagnitude

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_VectorWithMagnitude___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_VectorWithMagnitude___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_VectorWithMagnitude___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_VectorWithMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_VectorWithMagnitude_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_VectorWithMagnitude

    def SetCoord(self, *args):
        """
        SetCoord(Handle_Geom_VectorWithMagnitude self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)

        Assigns the values X, Y and Z to the coordinates of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SetCoord(self, *args)


    def SetVec(self, *args):
        """
        SetVec(Handle_Geom_VectorWithMagnitude self, gp_Vec V)

        Converts the gp_Vec vector V into this vector.

        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SetVec(self, *args)


    def SetX(self, *args):
        """
        SetX(Handle_Geom_VectorWithMagnitude self, Standard_Real const X)

        Changes the X coordinate of <me>.

        :type X: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(Handle_Geom_VectorWithMagnitude self, Standard_Real const Y)

        Changes the Y coordinate of <me>

        :type Y: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(Handle_Geom_VectorWithMagnitude self, Standard_Real const Z)

        Changes the Z coordinate of <me>.

        :type Z: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SetZ(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Adds the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Add(self, *args)


    def Added(self, *args):
        """
        Added(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_VectorWithMagnitude

        Adds the vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Added(self, *args)


    def Cross(self, *args):
        """
        Cross(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Computes the cross product  between <me> and Other
        <me> ^ Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Cross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product  between <me> and Other
        <me> ^ Other. A new vector is returned.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Crossed(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^ (V1 ^ V2).

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product  <me> ^ (V1 ^ V2).
        A new vector is returned.

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_CrossCrossed(self, *args)


    def Divide(self, *args):
        """
        Divide(Handle_Geom_VectorWithMagnitude self, Standard_Real const Scalar)

        Divides <me> by a scalar.

        :type Scalar: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Divide(self, *args)


    def Divided(self, *args):
        """
        Divided(Handle_Geom_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom_VectorWithMagnitude

        Divides <me> by a scalar. A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Divided(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Handle_Geom_VectorWithMagnitude self, Standard_Real const Scalar) -> Handle_Geom_VectorWithMagnitude

        Computes the product of the vector <me> by a scalar.
        A new vector is returned.

        :type Scalar: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Multiplied(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Geom_VectorWithMagnitude self, Standard_Real const Scalar)

        Computes the product of the vector <me> by a scalar.

        :type Scalar: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Multiply(self, *args)


    def Normalize(self, *args):
        """
        Normalize(Handle_Geom_VectorWithMagnitude self)

        Normalizes <me>.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.


        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(Handle_Geom_VectorWithMagnitude self) -> Handle_Geom_VectorWithMagnitude

        Returns a copy of <me> Normalized.

        Raised if the magnitude of the vector is lower or equal to
        Resolution from package gp.

        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Normalized(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other)

        Subtracts the Vector Other to <me>.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Subtract(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Handle_Geom_VectorWithMagnitude

        Subtracts the vector Other to <me>. A new vector is returned.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_VectorWithMagnitude

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Subtracted(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_VectorWithMagnitude self, gp_Trsf T)

        Applies the transformation T to this vector.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_VectorWithMagnitude self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this vector.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_VectorWithMagnitude self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_VectorWithMagnitude_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_VectorWithMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_VectorWithMagnitude self)

        Reverses the vector <me>.


        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_VectorWithMagnitude self) -> Handle_Geom_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value between 0 and Pi.
        Exceptions
        gp_VectorWithNullMagnitude if:
        - the magnitude of this vector is less than or equal to
        gp::Resolution(), or
        - the magnitude of vector Other is less than or equal
        to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other, Handle_Geom_Vector VRef) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The vector VRef defines the
        positive sense of rotation: the angular value is positive
        if the cross product this ^ Other has the same
        orientation as VRef (in relation to the plane defined
        by this vector and vector Other). Otherwise, it is negative.
        Exceptions
        Standard_DomainError if this vector, vector Other
        and vector VRef are coplanar, except if this vector
        and vector Other are parallel.
        gp_VectorWithNullMagnitude if the magnitude of
        this vector, vector Other or vector VRef is less than
        or equal to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :type VRef: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_AngleWithRef(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom_VectorWithMagnitude self)

        Returns the coordinates X, Y and Z of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Coord(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Y(self, *args)


    def Z(self, *args):
        """
        Z(Handle_Geom_VectorWithMagnitude self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Z(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the scalar product of this vector and vector Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Dot(self, *args)


    def DotCross(self, *args):
        """
        DotCross(Handle_Geom_VectorWithMagnitude self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Standard_Real

        Computes the triple scalar product. Returns me . (V1 ^ V2)

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_DotCross(self, *args)


    def Vec(self, *args):
        """
        Converts this vector into a gp_Vec vector.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Geom.Handle_Geom_VectorWithMagnitude_Vec(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_VectorWithMagnitude self, gp_Pnt P)
        Mirror(Handle_Geom_VectorWithMagnitude self, gp_Ax1 A1)
        Mirror(Handle_Geom_VectorWithMagnitude self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_VectorWithMagnitude self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_VectorWithMagnitude self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_VectorWithMagnitude self, gp_Vec V)
        Translate(Handle_Geom_VectorWithMagnitude self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_VectorWithMagnitude self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_VectorWithMagnitude self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_VectorWithMagnitude self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_VectorWithMagnitude self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_VectorWithMagnitude self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_VectorWithMagnitude self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_VectorWithMagnitude self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_VectorWithMagnitude self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_VectorWithMagnitude self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_VectorWithMagnitude_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_VectorWithMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_VectorWithMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_VectorWithMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_VectorWithMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_VectorWithMagnitude self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_VectorWithMagnitude self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_VectorWithMagnitude self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_VectorWithMagnitude_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_VectorWithMagnitude self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_VectorWithMagnitude_DecrementRefCounter(self, *args)

Handle_Geom_VectorWithMagnitude_swigregister = _Geom.Handle_Geom_VectorWithMagnitude_swigregister
Handle_Geom_VectorWithMagnitude_swigregister(Handle_Geom_VectorWithMagnitude)

def Handle_Geom_VectorWithMagnitude_DownCast(thing):
    return _Geom.Handle_Geom_VectorWithMagnitude_DownCast(thing)
Handle_Geom_VectorWithMagnitude_DownCast = _Geom.Handle_Geom_VectorWithMagnitude_DownCast

class Handle_Geom_Hyperbola(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Hyperbola self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Hyperbola_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Hyperbola self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Hyperbola_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Hyperbola self, Geom_Hyperbola thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Hyperbola_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Hyperbola self, Handle_Geom_Hyperbola theHandle) -> Handle_Geom_Hyperbola
        assign(Handle_Geom_Hyperbola self, Geom_Hyperbola thePtr) -> Handle_Geom_Hyperbola
        assign(Handle_Geom_Hyperbola self, Handle_Geom_Hyperbola theHandle) -> Handle_Geom_Hyperbola

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Hyperbola_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Hyperbola self) -> Geom_Hyperbola

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Hyperbola_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Hyperbola self) -> Geom_Hyperbola

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Hyperbola___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Hyperbola self) -> Geom_Hyperbola

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Hyperbola___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Hyperbola___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Hyperbola___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Hyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Hyperbola_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Hyperbola

    def SetHypr(self, *args):
        """
        SetHypr(Handle_Geom_Hyperbola self, gp_Hypr H)

        Converts the gp_Hypr hyperbola H into this hyperbola.

        :type H: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Handle_Geom_Hyperbola_SetHypr(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(Handle_Geom_Hyperbola self, Standard_Real const MajorRadius)

        Assigns a value to the major radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0, or
        - MinorRadius is less than 0.0.Raised if MajorRadius < 0.0

        :type MajorRadius: float

        """
        return _Geom.Handle_Geom_Hyperbola_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(Handle_Geom_Hyperbola self, Standard_Real const MinorRadius)

        Assigns a value to the minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if:
        - MajorRadius is less than 0.0, or
        - MinorRadius is less than 0.0.Raised if MajorRadius < 0.0

        :type MinorRadius: float

        """
        return _Geom.Handle_Geom_Hyperbola_SetMinorRadius(self, *args)


    def Hypr(self, *args):
        """
        Hypr(Handle_Geom_Hyperbola self) -> gp_Hypr

        returns the non transient parabola from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Handle_Geom_Hyperbola_Hypr(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Hyperbola self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed hyperbola,
        for the point of parameter U on this hyperbola.
        For a hyperbola, the returned value is: -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_ReversedParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns RealFirst from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Hyperbola self) -> Standard_Real

        returns RealLast from Standard.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Hyperbola self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Hyperbola_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Hyperbola self) -> Standard_Boolean

        return False for an hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Hyperbola_IsPeriodic(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(Handle_Geom_Hyperbola self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = (B/A)*X.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(Handle_Geom_Hyperbola self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = -(B/A)*X.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_Asymptote2(self, *args)


    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(Handle_Geom_Hyperbola self) -> gp_Hypr

        This branch of hyperbola is on the positive side of the
        YAxis of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Handle_Geom_Hyperbola_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(Handle_Geom_Hyperbola self) -> gp_Hypr

        This branch of hyperbola is on the negative side of the
        YAxis of <me>.
        Note: The diagram given under the class purpose
        indicates where these two branches of hyperbola are
        positioned in relation to this branch of hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Handle_Geom_Hyperbola_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(Handle_Geom_Hyperbola self) -> gp_Ax1

        This directrix is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the YAxis. The intersection point between
        directrix1 and the XAxis is the location point of the directrix1.
        This point is on the positive side of the XAxis.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(Handle_Geom_Hyperbola self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "directrix1" with respect to the YAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(Handle_Geom_Hyperbola self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        two focus of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(Handle_Geom_Hyperbola self) -> gp_Pnt

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the XAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(Handle_Geom_Hyperbola self) -> gp_Pnt

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the XAxis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_Focus2(self, *args)


    def MajorRadius(self, *args):
        """
        MajorRadius(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The major radius is also the distance between the
        center of the hyperbola and the apex of the main
        branch (located on the "X Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns the major or minor radius of this hyperbola.
        The minor radius is also the distance between the
        center of the hyperbola and the apex of a conjugate
        branch (located on the "Y Axis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(Handle_Geom_Hyperbola self) -> gp_Hypr

        Computes the "other" branch of this hyperbola. This
        is the symmetrical branch with respect to the center of this hyperbola.
        Note: The diagram given under the class purpose
        indicates where the "other" branch is positioned in
        relation to this branch of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _Geom.Handle_Geom_Hyperbola_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns p = (e * e - 1) * MajorRadius where e is the
        eccentricity of the hyperbola.
        raised if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_Parameter(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Hyperbola self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + MajorRadius * Cosh (U) * XDir +
        MinorRadius * Sinh (U) * YDir
        where C is the center of the hyperbola , XDir the XDirection and
        YDir the YDirection of the hyperbola's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Hyperbola_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Hyperbola_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Hyperbola self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first second and
        third derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Hyperbola_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Hyperbola self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Hyperbola_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Hyperbola self, gp_Trsf T)

        Applies the transformation T to this hyperbola.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Hyperbola_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Hyperbola self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this hyperbola.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Hyperbola self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Hyperbola_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Hyperbola_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Hyperbola_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Hyperbola self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Hyperbola self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Hyperbola self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Hyperbola_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Hyperbola self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Hyperbola self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Handle_Geom_Hyperbola_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Handle_Geom_Hyperbola self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom_Hyperbola self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Hyperbola_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Hyperbola self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Handle_Geom_Hyperbola_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Hyperbola self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Hyperbola_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Hyperbola self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Hyperbola_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Hyperbola self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Hyperbola self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Hyperbola self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Hyperbola_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Hyperbola self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Hyperbola_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Hyperbola self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Hyperbola self, gp_Pnt P)
        Mirror(Handle_Geom_Hyperbola self, gp_Ax1 A1)
        Mirror(Handle_Geom_Hyperbola self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Hyperbola_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Hyperbola self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Hyperbola_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Hyperbola self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Hyperbola_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Hyperbola self, gp_Vec V)
        Translate(Handle_Geom_Hyperbola self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Hyperbola_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Hyperbola self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Hyperbola self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Hyperbola self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Hyperbola self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Hyperbola self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Hyperbola self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Hyperbola self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Hyperbola self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Hyperbola_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Hyperbola self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Hyperbola_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Hyperbola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Hyperbola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Hyperbola_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Hyperbola self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Hyperbola self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Hyperbola_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Hyperbola self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Hyperbola_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Hyperbola self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Hyperbola_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Hyperbola self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Hyperbola_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Hyperbola self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Hyperbola_DecrementRefCounter(self, *args)

Handle_Geom_Hyperbola_swigregister = _Geom.Handle_Geom_Hyperbola_swigregister
Handle_Geom_Hyperbola_swigregister(Handle_Geom_Hyperbola)

def Handle_Geom_Hyperbola_DownCast(thing):
    return _Geom.Handle_Geom_Hyperbola_DownCast(thing)
Handle_Geom_Hyperbola_DownCast = _Geom.Handle_Geom_Hyperbola_DownCast

class Handle_Geom_SurfaceOfRevolution(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_SurfaceOfRevolution self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_SurfaceOfRevolution self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_SurfaceOfRevolution self, Geom_SurfaceOfRevolution thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_SurfaceOfRevolution self, Handle_Geom_SurfaceOfRevolution theHandle) -> Handle_Geom_SurfaceOfRevolution
        assign(Handle_Geom_SurfaceOfRevolution self, Geom_SurfaceOfRevolution thePtr) -> Handle_Geom_SurfaceOfRevolution
        assign(Handle_Geom_SurfaceOfRevolution self, Handle_Geom_SurfaceOfRevolution theHandle) -> Handle_Geom_SurfaceOfRevolution

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_SurfaceOfRevolution self) -> Geom_SurfaceOfRevolution

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_SurfaceOfRevolution self) -> Geom_SurfaceOfRevolution

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_SurfaceOfRevolution self) -> Geom_SurfaceOfRevolution

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_SurfaceOfRevolution___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_SurfaceOfRevolution___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_SurfaceOfRevolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_SurfaceOfRevolution_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_SurfaceOfRevolution

    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_SurfaceOfRevolution self, gp_Ax1 A1)

        Changes the axis of revolution.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_SurfaceOfRevolution self, gp_Dir V)

        Changes the direction of the revolution axis.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_SetDirection(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Handle_Geom_SurfaceOfRevolution self, Handle_Geom_Curve C)

        Changes the revolved curve of the surface.
        Warnings :
        It is not checked that the curve C is planar and that the
        surface axis is in the plane of the curve.
        It is not checked that the revolved curve C doesn't
        self-intersects.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_SetBasisCurve(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P)

        Changes the location point of the revolution axis.
        Warnings :
        It is not checked that the axis is in the plane of the
        revolved curve.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_SetLocation(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_SurfaceOfRevolution self) -> gp_Ax1

        Returns the revolution axis of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Axis(self, *args)


    def Location(self, *args):
        """
        Returns the location point of the axis of revolution.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Handle_Geom_SurfaceOfRevolution_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReferencePlane(self, *args):
        """
        ReferencePlane(Handle_Geom_SurfaceOfRevolution self) -> gp_Ax2

        Computes the position of the reference plane of the surface
        defined by the basis curve and the symmetry axis.
        The location point is the location point of the revolution's
        axis, the XDirection of the plane is given by the revolution's
        axis and the orientation of the normal to the plane is given
        by the sense of revolution.

        Raised if the revolved curve is not planar or if the revolved
        curve and the symmetry axis are not in the same plane or if
        the maximum of distance between the axis and the revolved
        curve is lower or equal to Resolution from gp.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_ReferencePlane(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_SurfaceOfRevolution self)

        Changes the orientation of this surface of revolution
        in the u  parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        As a consequence:
        - UReverse reverses the direction of the axis of
        revolution of this surface,


        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, when reversing its u  parametric
        direction, for any point of u parameter U  on this surface of revolution.
        In the case of a revolved surface:
        - UReversedParameter returns 2.*Pi - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_SurfaceOfRevolution self)

        Changes the orientation of this surface of revolution
        in the v parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        As a consequence:
        - VReverse reverses the meridian of this surface of revolution.


        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_SurfaceOfRevolution self, Standard_Real const V) -> Standard_Real

        Computes the  v parameter on the modified
        surface, when reversing its  v parametric
        direction, for any point of v parameter V on this surface of revolution.
        In the case of a revolved surface:
        - VReversedParameter returns the reversed
        parameter given by the function
        ReversedParameter called with V on the meridian.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_SurfaceOfRevolution self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies V by
        BasisCurve()->ParametricTransformation(T)

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_SurfaceOfRevolution self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale  centered  on  the
        U axis with BasisCurve()->ParametricTransformation(T)

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_SurfaceOfRevolution self)

        Returns the parametric bounds U1, U2 , V1 and V2 of this surface.
        A surface of revolution is always complete, so U1 = 0, U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsUClosed always returns true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsVClosed returns true if the meridian of this
        surface of revolution is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_SurfaceOfRevolution self, Standard_Integer const N) -> Standard_Boolean

        IsCNu always returns true.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_SurfaceOfRevolution self, Standard_Integer const N) -> Standard_Boolean

        IsCNv returns true if the degree of continuity of the
        meridian of this surface of revolution is at least N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_SurfaceOfRevolution self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_SurfaceOfRevolution self) -> Standard_Boolean

        IsVPeriodic returns true if the meridian of this
        surface of revolution is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of revolution. It is the curve obtained by rotating the
        meridian through an angle U about the axis of revolution.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_SurfaceOfRevolution self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of revolution. It is the curve obtained by rotating the
        meridian through an angle U about the axis of revolution.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        U is the angle of the rotation around the revolution axis.
        The direction of this axis gives the sense of rotation.
        V is the parameter of the revolved curve.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives
        in the directions U and V.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.
        Raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and
        Nv in the direction v.

        Raised if the continuity of the surface is not CNu in the u
        direction and CNv in the v direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.
        The following  functions  evaluates the  local
        derivatives on surface. Useful to manage discontinuities
        on the surface.
        if    Side  =  1  ->  P  =  S( U+,V )
        if    Side  = -1  ->  P  =  S( U-,V )
        else  P  is betveen discontinuities
        can be evaluated using methods  of
        global evaluations    P  =  S( U ,V )

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_SurfaceOfRevolution self, gp_Trsf T)

        Applies the transformation T to this surface of revolution.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_SurfaceOfRevolution self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this surface of revolution.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_SurfaceOfRevolution self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SurfaceOfRevolution_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SurfaceOfRevolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_SurfaceOfRevolution self) -> GeomAbs_Shape

        returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference direction of the swept surface.
        For a surface of revolution it is the direction of the
        revolution axis, for a surface of linear extrusion it is
        the direction of extrusion.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_SurfaceOfRevolution_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom_SurfaceOfRevolution self) -> Handle_Geom_Curve

        Returns the referenced curve of the surface.
        For a surface of revolution it is the revolution curve,
        for a surface of linear extrusion it is the extruded curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_BasisCurve(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_SurfaceOfRevolution self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_SurfaceOfRevolution self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_VReversed(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_SurfaceOfRevolution self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_SurfaceOfRevolution self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_SurfaceOfRevolution self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P)
        Mirror(Handle_Geom_SurfaceOfRevolution self, gp_Ax1 A1)
        Mirror(Handle_Geom_SurfaceOfRevolution self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_SurfaceOfRevolution self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_SurfaceOfRevolution self, gp_Vec V)
        Translate(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SurfaceOfRevolution self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SurfaceOfRevolution self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_SurfaceOfRevolution self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_SurfaceOfRevolution self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_SurfaceOfRevolution self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_SurfaceOfRevolution self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_SurfaceOfRevolution self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_SurfaceOfRevolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_SurfaceOfRevolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_SurfaceOfRevolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_SurfaceOfRevolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_SurfaceOfRevolution self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_SurfaceOfRevolution self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_SurfaceOfRevolution self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_SurfaceOfRevolution self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SurfaceOfRevolution_DecrementRefCounter(self, *args)

Handle_Geom_SurfaceOfRevolution_swigregister = _Geom.Handle_Geom_SurfaceOfRevolution_swigregister
Handle_Geom_SurfaceOfRevolution_swigregister(Handle_Geom_SurfaceOfRevolution)

def Handle_Geom_SurfaceOfRevolution_DownCast(thing):
    return _Geom.Handle_Geom_SurfaceOfRevolution_DownCast(thing)
Handle_Geom_SurfaceOfRevolution_DownCast = _Geom.Handle_Geom_SurfaceOfRevolution_DownCast

class Handle_Geom_HSequenceOfBSplineSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_HSequenceOfBSplineSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_HSequenceOfBSplineSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_HSequenceOfBSplineSurface self, Geom_HSequenceOfBSplineSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_HSequenceOfBSplineSurface self, Handle_Geom_HSequenceOfBSplineSurface theHandle) -> Handle_Geom_HSequenceOfBSplineSurface
        assign(Handle_Geom_HSequenceOfBSplineSurface self, Geom_HSequenceOfBSplineSurface thePtr) -> Handle_Geom_HSequenceOfBSplineSurface
        assign(Handle_Geom_HSequenceOfBSplineSurface self, Handle_Geom_HSequenceOfBSplineSurface theHandle) -> Handle_Geom_HSequenceOfBSplineSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_HSequenceOfBSplineSurface self) -> Geom_HSequenceOfBSplineSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_HSequenceOfBSplineSurface self) -> Geom_HSequenceOfBSplineSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_HSequenceOfBSplineSurface self) -> Geom_HSequenceOfBSplineSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_HSequenceOfBSplineSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_HSequenceOfBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_HSequenceOfBSplineSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_HSequenceOfBSplineSurface

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        res = _Geom.Handle_Geom_HSequenceOfBSplineSurface_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Geom_HSequenceOfBSplineSurface self, Handle_Geom_BSplineSurface theItem)
        Append(Handle_Geom_HSequenceOfBSplineSurface self, NCollection_Sequence_Handle_Geom_BSplineSurface theSequence)

        :type theSequence: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Geom_HSequenceOfBSplineSurface self) -> NCollection_Sequence_Handle_Geom_BSplineSurface

        :rtype: OCC.wrapper.Geom.Geom_SequenceOfBSplineSurface

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_HSequenceOfBSplineSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_HSequenceOfBSplineSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_HSequenceOfBSplineSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Geom_HSequenceOfBSplineSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_HSequenceOfBSplineSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_HSequenceOfBSplineSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_HSequenceOfBSplineSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_HSequenceOfBSplineSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_HSequenceOfBSplineSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_HSequenceOfBSplineSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_HSequenceOfBSplineSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_HSequenceOfBSplineSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_HSequenceOfBSplineSurface_DecrementRefCounter(self, *args)

Handle_Geom_HSequenceOfBSplineSurface_swigregister = _Geom.Handle_Geom_HSequenceOfBSplineSurface_swigregister
Handle_Geom_HSequenceOfBSplineSurface_swigregister(Handle_Geom_HSequenceOfBSplineSurface)

def Handle_Geom_HSequenceOfBSplineSurface_DownCast(thing):
    return _Geom.Handle_Geom_HSequenceOfBSplineSurface_DownCast(thing)
Handle_Geom_HSequenceOfBSplineSurface_DownCast = _Geom.Handle_Geom_HSequenceOfBSplineSurface_DownCast

class Geom_Circle(Geom_Conic):
    """
    Describes a circle in 3D space.
    A circle is defined by its radius and, as with any conic
    curve, is positioned in space with a right-handed
    coordinate system (gp_Ax2 object) where:
    - the origin is the center of the circle, and
    - the origin, "X Direction" and "Y Direction" define the
    plane of the circle.
    This coordinate system is the local coordinate
    system of the circle.
    The "main Direction" of this coordinate system is the
    vector normal to the plane of the circle. The axis, of
    which the origin and unit vector are respectively the
    origin and "main Direction" of the local coordinate
    system, is termed the "Axis" or "main Axis" of the circle.
    The "main Direction" of the local coordinate system
    gives an explicit orientation to the circle (definition of
    the trigonometric sense), determining the direction in
    which the parameter increases along the circle.
    The Geom_Circle circle is parameterized by an angle:
    P(U) = O + R*Cos(U)*XDir + R*Sin(U)*YDir, where:
    - P is the point of parameter U,
    - O, XDir and YDir are respectively the origin, "X
    Direction" and "Y Direction" of its local coordinate system,
    - R is the radius of the circle.
    The "X Axis" of the local coordinate system therefore
    defines the origin of the parameter of the circle. The
    parameter is the angle with this "X Direction".
    A circle is a closed and periodic curve. The period is
    2.*Pi and the parameter range is [ 0, 2.*Pi [.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Geom_Circle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Geom_Circle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Geom_Circle self, gp_Circ C) -> Geom_Circle
        __init__(Geom_Circle self, gp_Ax2 A2, Standard_Real const Radius) -> Geom_Circle

        Constructs a circle of radius Radius, where A2 locates the circle and
        defines its orientation in 3D space such that:
        - the center of the circle is the origin of A2,
        - the origin, "X Direction" and "Y Direction" of A2
        define the plane of the circle,
        - A2 is the local coordinate system of the circle.
        Note: It is possible to create a circle where Radius is equal to 0.0.
        raised if Radius < 0.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type Radius: float

        """
        this = _Geom.new_Geom_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCirc(self, *args):
        """
        SetCirc(Geom_Circle self, gp_Circ C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Circ

        """
        return _Geom.Geom_Circle_SetCirc(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Geom_Circle self, Standard_Real const R)

        Assigns the value R to the radius of this circle.
        Note: it is possible to have a circle with a radius equal to 0.0.
        Exceptions - Standard_ConstructionError if R is negative.

        :type R: float

        """
        return _Geom.Geom_Circle_SetRadius(self, *args)


    def Circ(self, *args):
        """
        Circ(Geom_Circle self) -> gp_Circ

        returns the non transient circle from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _Geom.Geom_Circle_Circ(self, *args)


    def Radius(self, *args):
        """
        Radius(Geom_Circle self) -> Standard_Real

        Returns the radius of this circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Circle_Radius(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Geom_Circle self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed circle for
        the point of parameter U on this circle.
        For a circle, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Circle_ReversedParameter(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Geom_Circle self) -> Standard_Real

        Returns the eccentricity  e = 0 for a circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Circle_Eccentricity(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Geom_Circle self) -> Standard_Real

        Returns the value of the first parameter of this
        circle. This is  0.0, which gives the start point of this circle, or
        The start point and end point of a circle are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Circle_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Geom_Circle self) -> Standard_Real

        Returns the value of the last parameter of this
        circle. This is 2.*Pi, which gives the end point of this circle.
        The start point and end point of a circle are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Geom_Circle_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Geom_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Circle_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Geom_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Geom_Circle_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Geom_Circle self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + R * Cos (U) * XDir + R * Sin (U) * YDir
        where C is the center of the circle , XDir the XDirection and
        YDir the YDirection of the circle's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Geom_Circle_D0(self, *args)


    def D1(self, *args):
        """
        D1(Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Circle_D1(self, *args)


    def D2(self, *args):
        """
        D2(Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Circle_D2(self, *args)


    def D3(self, *args):
        """
        D3(Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter u, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Circle_D3(self, *args)


    def DN(self, *args):
        """
        DN(Geom_Circle self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Geom_Circle_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Geom_Circle self, gp_Trsf T)

        Applies the transformation T to this circle.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Geom_Circle_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Geom_Circle self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this circle.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Geom_Circle_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Geom.Geom_Circle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Geom.Geom_Circle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Geom_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom.delete_Geom_Circle
Geom_Circle_swigregister = _Geom.Geom_Circle_swigregister
Geom_Circle_swigregister(Geom_Circle)

def Geom_Circle_get_type_name(*args):
    """
    Geom_Circle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Geom.Geom_Circle_get_type_name(*args)

def Geom_Circle_get_type_descriptor(*args):
    """
    Geom_Circle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Geom.Geom_Circle_get_type_descriptor(*args)

class Handle_Geom_ConicalSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_ConicalSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_ConicalSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_ConicalSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_ConicalSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_ConicalSurface self, Geom_ConicalSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_ConicalSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_ConicalSurface self, Handle_Geom_ConicalSurface theHandle) -> Handle_Geom_ConicalSurface
        assign(Handle_Geom_ConicalSurface self, Geom_ConicalSurface thePtr) -> Handle_Geom_ConicalSurface
        assign(Handle_Geom_ConicalSurface self, Handle_Geom_ConicalSurface theHandle) -> Handle_Geom_ConicalSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_ConicalSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_ConicalSurface self) -> Geom_ConicalSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_ConicalSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_ConicalSurface self) -> Geom_ConicalSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_ConicalSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_ConicalSurface self) -> Geom_ConicalSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_ConicalSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_ConicalSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_ConicalSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_ConicalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_ConicalSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_ConicalSurface

    def SetCone(self, *args):
        """
        SetCone(Handle_Geom_ConicalSurface self, gp_Cone C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Cone

        """
        return _Geom.Handle_Geom_ConicalSurface_SetCone(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_Geom_ConicalSurface self, Standard_Real const R)

        Changes the radius of the conical surface in the placement
        plane (Z = 0, V = 0).  The local coordinate system is not
        modified.
        Raised if R < 0.0

        :type R: float

        """
        return _Geom.Handle_Geom_ConicalSurface_SetRadius(self, *args)


    def SetSemiAngle(self, *args):
        """
        SetSemiAngle(Handle_Geom_ConicalSurface self, Standard_Real const Ang)

        Changes the semi angle of the conical surface.
        Semi-angle can be negative. Its absolute value
        Abs(Ang) is in range ]0,PI/2[.
        Raises ConstructionError if Abs(Ang) < Resolution from gp or
        Abs(Ang) >= PI/2 - Resolution

        :type Ang: float

        """
        return _Geom.Handle_Geom_ConicalSurface_SetSemiAngle(self, *args)


    def Cone(self, *args):
        """
        Cone(Handle_Geom_ConicalSurface self) -> gp_Cone

        returns a non transient cone with the same geometric properties
        as <me>.

        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _Geom.Handle_Geom_ConicalSurface_Cone(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_ConicalSurface self, Standard_Real const U) -> Standard_Real

        return 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_ConicalSurface self, Standard_Real const V) -> Standard_Real

        Computes the u (or v) parameter on the modified
        surface, when reversing its u (or v) parametric
        direction, for any point of u parameter U (or of v
        parameter V) on this cone.
        In the case of a cone, these functions return respectively:
        - 2.*Pi - U, -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_VReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_ConicalSurface self)

        Changes the orientation of this cone in the v
        parametric direction. The bounds of the surface are
        not changed but the v parametric direction is reversed.
        As a consequence, for a cone:
        - the "main Direction" of the local coordinate system
        is reversed, and
        - the half-angle at the apex is inverted.


        """
        return _Geom.Handle_Geom_ConicalSurface_VReverse(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_ConicalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ConicalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_ConicalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale  centered  on  the
        U axis with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_ConicalSurface_ParametricTransformation(self, *args)


    def Apex(self, *args):
        """
        Apex(Handle_Geom_ConicalSurface self) -> gp_Pnt

        Computes the apex of this cone. It is on the negative
        side of the axis of revolution of this cone if the
        half-angle at the apex is positive, and on the positive
        side of the "main Axis" if the half-angle is negative.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_Apex(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_ConicalSurface self)

        The conical surface is infinite in the V direction so
        V1 = Realfirst from Standard and V2 = RealLast.
        U1 = 0 and U2 = 2*PI.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_ConicalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Handle_Geom_ConicalSurface self)

        Returns the coefficients of the implicit equation of the
        quadric in the absolute cartesian coordinate system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Handle_Geom_ConicalSurface_Coefficients(self, *args)


    def RefRadius(self, *args):
        """
        RefRadius(Handle_Geom_ConicalSurface self) -> Standard_Real

        Returns the reference radius of this cone.
        The reference radius is the radius of the circle formed
        by the intersection of this cone and its reference
        plane (i.e. the plane defined by the origin, "X
        Direction" and "Y Direction" of the local coordinate
        system of this cone).
        If the apex of this cone is on the origin of the local
        coordinate system of this cone, the returned value is 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_RefRadius(self, *args)


    def SemiAngle(self, *args):
        """
        SemiAngle(Handle_Geom_ConicalSurface self) -> Standard_Real

        Returns the semi-angle at the apex of this cone.
        Attention! Semi-angle can be negative.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_SemiAngle(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_ConicalSurface self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_ConicalSurface self) -> Standard_Boolean

        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_ConicalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_ConicalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_ConicalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Builds the U isoparametric line of this cone. The
        origin of this line is on the reference plane of this
        cone (i.e. the plane defined by the origin, "X Direction"
        and "Y Direction" of the local coordinate system of this cone).

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ConicalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_ConicalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Builds the V isoparametric circle of this cone. It is the
        circle on this cone, located in the plane of Z
        coordinate V*cos(Semi-Angle) in the local coordinate system of this
        cone. The "Axis" of this circle is the axis of revolution
        of this cone. Its starting point is defined by the "X
        Direction" of this cone.
        Warning
        If the V isoparametric circle is close to the apex of
        this cone, the radius of the circle becomes very small.
        It is possible to have a circle with radius equal to 0.0.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_ConicalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc +
        (RefRadius + V * sin (Semi-Angle)) * (cos (U) * XDir + sin (U) * YDir) +
        V * cos (Semi-Angle) * ZDir
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ConicalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ConicalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ConicalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the u
        parametric direction, and Nv in the v parametric
        direction at the point of parameters (U, V) of this cone.
        Exceptions
        Standard_RangeError if:
        - Nu + Nv is less than 1,
        - Nu or Nv is negative.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_ConicalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_ConicalSurface self, gp_Trsf T)

        Applies the transformation T to this cone.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_ConicalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_ConicalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this cone.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_ConicalSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_ConicalSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ConicalSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_ConicalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_ConicalSurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ConicalSurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_ConicalSurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_ConicalSurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_ConicalSurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_ConicalSurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_ConicalSurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_ConicalSurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_ConicalSurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_ConicalSurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Handle_Geom_ConicalSurface_UReverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_ConicalSurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_ConicalSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_ConicalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_ConicalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsCNv(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_ConicalSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ConicalSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_ConicalSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_ConicalSurface_VReversed(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_ConicalSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_ConicalSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_ConicalSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_ConicalSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_ConicalSurface self, gp_Pnt P)
        Mirror(Handle_Geom_ConicalSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_ConicalSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_ConicalSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_ConicalSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_ConicalSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_ConicalSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_ConicalSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_ConicalSurface self, gp_Vec V)
        Translate(Handle_Geom_ConicalSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_ConicalSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_ConicalSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ConicalSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_ConicalSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_ConicalSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_ConicalSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_ConicalSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_ConicalSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_ConicalSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_ConicalSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_ConicalSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_ConicalSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_ConicalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_ConicalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_ConicalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_ConicalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_ConicalSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_ConicalSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_ConicalSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_ConicalSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ConicalSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_ConicalSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_ConicalSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_ConicalSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_ConicalSurface_DecrementRefCounter(self, *args)

Handle_Geom_ConicalSurface_swigregister = _Geom.Handle_Geom_ConicalSurface_swigregister
Handle_Geom_ConicalSurface_swigregister(Handle_Geom_ConicalSurface)

def Handle_Geom_ConicalSurface_DownCast(thing):
    return _Geom.Handle_Geom_ConicalSurface_DownCast(thing)
Handle_Geom_ConicalSurface_DownCast = _Geom.Handle_Geom_ConicalSurface_DownCast

class Handle_Geom_Surface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Surface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Surface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Surface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Surface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Surface self, Geom_Surface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Surface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Surface self, Handle_Geom_Surface theHandle) -> Handle_Geom_Surface
        assign(Handle_Geom_Surface self, Geom_Surface thePtr) -> Handle_Geom_Surface
        assign(Handle_Geom_Surface self, Handle_Geom_Surface theHandle) -> Handle_Geom_Surface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Surface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Surface self) -> Geom_Surface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Surface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Surface self) -> Geom_Surface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Surface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Surface self) -> Geom_Surface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Surface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Surface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Surface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Surface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Surface

    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_Surface self)

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_Surface_UReverse(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_Surface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_Surface_UReversed(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_Surface self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)

        is the same point as

        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Surface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_Surface self)

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_Surface_VReverse(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_Surface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_Surface_VReversed(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_Surface self, Standard_Real const V) -> Standard_Real

        Returns the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))

        is the same point as

        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Surface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_Surface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Surface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Surface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_Surface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_Surface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this surface.
        If the surface is infinite, this function can return a value
        equal to Precision::Infinite: instead of Standard_Real::LastReal.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_Surface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_Surface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the u parametric direction: taking
        uFirst and uLast as the parametric bounds in
        the u parametric direction, for each parameter v, the
        distance between the points P(uFirst, v) and
        P(uLast, v) is less than or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_Surface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the v parametric
        direction: taking vFirst and vLast as the
        parametric bounds in the v parametric direction, for
        each parameter u, the distance between the points
        P(u, vFirst) and P(u, vLast) is less than
        or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_Surface self) -> Standard_Boolean

        Checks if this surface is periodic in the u
        parametric direction. Returns true if:
        - this surface is closed in the u parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the u parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_Surface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Surface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_Surface self) -> Standard_Boolean

        Checks if this surface is periodic in the v
        parametric direction. Returns true if:
        - this surface is closed in the v parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_Surface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Surface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_Surface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Surface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_Surface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Surface_VIso(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Surface self) -> GeomAbs_Shape

        Returns the Global Continuity of the surface in direction U and V :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.
        Example :
        If the surface is C1 in the V parametric direction and C2
        in the U parametric direction Shape = C1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Surface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_Surface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        U parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_Surface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        V parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the surface.

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Surface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Surface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Surface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Surface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        ---Purpose ;
        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        Raised if the continuity of the surface is not CNu in the U
        direction or not CNv in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Surface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Surface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Surface_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Surface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Surface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Surface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Surface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Surface self, gp_Pnt P)
        Mirror(Handle_Geom_Surface self, gp_Ax1 A1)
        Mirror(Handle_Geom_Surface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Surface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Surface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Surface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Surface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Surface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Surface self, gp_Vec V)
        Translate(Handle_Geom_Surface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Surface_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Surface self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Surface_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Surface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Surface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Surface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Surface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Surface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Surface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Surface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Surface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Surface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Surface_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Surface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Surface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Surface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Surface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Surface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Surface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Surface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Surface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Surface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Surface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Surface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Surface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Surface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Surface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Surface_DecrementRefCounter(self, *args)

Handle_Geom_Surface_swigregister = _Geom.Handle_Geom_Surface_swigregister
Handle_Geom_Surface_swigregister(Handle_Geom_Surface)

def Handle_Geom_Surface_DownCast(thing):
    return _Geom.Handle_Geom_Surface_DownCast(thing)
Handle_Geom_Surface_DownCast = _Geom.Handle_Geom_Surface_DownCast

class Handle_Geom_SweptSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_SweptSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_SweptSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_SweptSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_SweptSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_SweptSurface self, Geom_SweptSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_SweptSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_SweptSurface self, Handle_Geom_SweptSurface theHandle) -> Handle_Geom_SweptSurface
        assign(Handle_Geom_SweptSurface self, Geom_SweptSurface thePtr) -> Handle_Geom_SweptSurface
        assign(Handle_Geom_SweptSurface self, Handle_Geom_SweptSurface theHandle) -> Handle_Geom_SweptSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_SweptSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_SweptSurface self) -> Geom_SweptSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_SweptSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_SweptSurface self) -> Geom_SweptSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_SweptSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_SweptSurface self) -> Geom_SweptSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_SweptSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_SweptSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_SweptSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_SweptSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_SweptSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_SweptSurface

    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_SweptSurface self) -> GeomAbs_Shape

        returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_SweptSurface_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference direction of the swept surface.
        For a surface of revolution it is the direction of the
        revolution axis, for a surface of linear extrusion it is
        the direction of extrusion.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_SweptSurface_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom_SweptSurface self) -> Handle_Geom_Curve

        Returns the referenced curve of the surface.
        For a surface of revolution it is the revolution curve,
        for a surface of linear extrusion it is the extruded curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SweptSurface_BasisCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_SweptSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_SweptSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SweptSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SweptSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_SweptSurface self)

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_SweptSurface_UReverse(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_SweptSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SweptSurface_UReversed(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_SweptSurface self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  Ureversed surface for
        the point of parameter U on <me>.

        me->UReversed()->Value(me->UReversedParameter(U),V)

        is the same point as

        me->Value(U,V)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SweptSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_SweptSurface self)

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.


        """
        return _Geom.Handle_Geom_SweptSurface_VReverse(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_SweptSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SweptSurface_VReversed(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_SweptSurface self, Standard_Real const V) -> Standard_Real

        Returns the  parameter on the  Vreversed surface for
        the point of parameter V on <me>.

        me->VReversed()->Value(U,me->VReversedParameter(V))

        is the same point as

        me->Value(U,V)

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SweptSurface_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_SweptSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SweptSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_SweptSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_SweptSurface_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_SweptSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this surface.
        If the surface is infinite, this function can return a value
        equal to Precision::Infinite: instead of Standard_Real::LastReal.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_SweptSurface_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_SweptSurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the u parametric direction: taking
        uFirst and uLast as the parametric bounds in
        the u parametric direction, for each parameter v, the
        distance between the points P(uFirst, v) and
        P(uLast, v) is less than or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_SweptSurface self) -> Standard_Boolean

        Checks whether this surface is closed in the u
        parametric direction.
        Returns true if, in the v parametric
        direction: taking vFirst and vLast as the
        parametric bounds in the v parametric direction, for
        each parameter u, the distance between the points
        P(u, vFirst) and P(u, vLast) is less than
        or equal to gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_SweptSurface self) -> Standard_Boolean

        Checks if this surface is periodic in the u
        parametric direction. Returns true if:
        - this surface is closed in the u parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the u parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_SweptSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SweptSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_SweptSurface self) -> Standard_Boolean

        Checks if this surface is periodic in the v
        parametric direction. Returns true if:
        - this surface is closed in the v parametric direction, and
        - there is a constant T such that the distance
        between the points P (u, v) and P (u + T,
        v) (or the points P (u, v) and P (u, v +
        T)) is less than or equal to gp::Resolution().
        Note: T is the parametric period in the v parametric direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_SweptSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SweptSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_SweptSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SweptSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_SweptSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SweptSurface_VIso(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_SweptSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        U parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_SweptSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns the order of continuity of the surface in the
        V parametric direction.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsCNv(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point of parameter U,V on the surface.

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SweptSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point P and the first derivatives in the
        directions U and V at this point.
        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SweptSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the point P, the first and the second derivatives in
        the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SweptSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the point P, the first,the second and the third
        derivatives in the directions U and V at this point.
        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SweptSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        ---Purpose ;
        Computes the derivative of order Nu in the direction U and Nv
        in the direction V at the point P(U, V).

        Raised if the continuity of the surface is not CNu in the U
        direction or not CNv in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SweptSurface_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_SweptSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SweptSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_SweptSurface self, gp_Pnt P)
        Mirror(Handle_Geom_SweptSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_SweptSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_SweptSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_SweptSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_SweptSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_SweptSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_SweptSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_SweptSurface self, gp_Vec V)
        Translate(Handle_Geom_SweptSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SweptSurface_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_SweptSurface self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SweptSurface_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_SweptSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SweptSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SweptSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_SweptSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_SweptSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_SweptSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_SweptSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_SweptSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_SweptSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SweptSurface_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_SweptSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_SweptSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_SweptSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_SweptSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_SweptSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_SweptSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SweptSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_SweptSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_SweptSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_SweptSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SweptSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_SweptSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_SweptSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_SweptSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SweptSurface_DecrementRefCounter(self, *args)

Handle_Geom_SweptSurface_swigregister = _Geom.Handle_Geom_SweptSurface_swigregister
Handle_Geom_SweptSurface_swigregister(Handle_Geom_SweptSurface)

def Handle_Geom_SweptSurface_DownCast(thing):
    return _Geom.Handle_Geom_SweptSurface_DownCast(thing)
Handle_Geom_SweptSurface_DownCast = _Geom.Handle_Geom_SweptSurface_DownCast

class Handle_Geom_OffsetSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_OffsetSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_OffsetSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_OffsetSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_OffsetSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_OffsetSurface self, Geom_OffsetSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_OffsetSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_OffsetSurface self, Handle_Geom_OffsetSurface theHandle) -> Handle_Geom_OffsetSurface
        assign(Handle_Geom_OffsetSurface self, Geom_OffsetSurface thePtr) -> Handle_Geom_OffsetSurface
        assign(Handle_Geom_OffsetSurface self, Handle_Geom_OffsetSurface theHandle) -> Handle_Geom_OffsetSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_OffsetSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_OffsetSurface self) -> Geom_OffsetSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_OffsetSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_OffsetSurface self) -> Geom_OffsetSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_OffsetSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_OffsetSurface self) -> Geom_OffsetSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_OffsetSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_OffsetSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_OffsetSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_OffsetSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_OffsetSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_OffsetSurface

    def SetBasisSurface(self, *args):
        """
        SetBasisSurface(Handle_Geom_OffsetSurface self, Handle_Geom_Surface S, Standard_Boolean const isNotCheckC0)

        Raised if S is not at least C1.
        Warnings :
        No check is done to verify that a unique normal direction is
        defined at any point of the basis surface S.
        If isNotCheckC0 = TRUE checking if basis surface has C0-continuity
        is not made.
        Exceptions
        Standard_ConstructionError if the surface S is not
        at least "C1" continuous.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type isNotCheckC0: bool

        """
        return _Geom.Handle_Geom_OffsetSurface_SetBasisSurface(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(Handle_Geom_OffsetSurface self, Standard_Real const D)

        Changes this offset surface by assigning D as the offset value.

        :type D: float

        """
        return _Geom.Handle_Geom_OffsetSurface_SetOffsetValue(self, *args)


    def Offset(self, *args):
        """
        Offset(Handle_Geom_OffsetSurface self) -> Standard_Real

        Returns the offset value of this offset surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetSurface_Offset(self, *args)


    def BasisSurface(self, *args):
        """
        Returns the basis surface of this offset surface.
        Note: The basis surface can be an offset surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _Geom.Handle_Geom_OffsetSurface_BasisSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OsculatingSurface(self, *args):
        """
        Returns osculating surface if base surface is B-spline or Bezier

        :rtype: OCC.wrapper.Geom.Handle_Geom_OsculatingSurface

        """
        res = _Geom.Handle_Geom_OffsetSurface_OsculatingSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_OffsetSurface self)

        Changes the orientation of this offset surface in the u
        parametric direction. The bounds of the surface
        are not changed but the given parametric direction is reversed.


        """
        return _Geom.Handle_Geom_OffsetSurface_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_OffsetSurface self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        surface, produced by reversing the u
        parametric direction of this offset surface, for any
        point of u parameter U  on this offset surface.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetSurface_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_OffsetSurface self)

        Changes the orientation of this offset surface in the v parametric direction. The bounds of the surface
        are not changed but the given parametric direction is reversed.


        """
        return _Geom.Handle_Geom_OffsetSurface_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_OffsetSurface self, Standard_Real const V) -> Standard_Real

        Computes the  v parameter on the modified
        surface, produced by reversing the or v
        parametric direction of this offset surface, for any
        point of  v parameter V on this offset surface.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetSurface_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_OffsetSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this offset surface.
        If the surface is infinite, this function can return:
        - Standard_Real::RealFirst(), or
        - Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_OffsetSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_OffsetSurface self) -> GeomAbs_Shape

        This method returns the continuity of the basis surface - 1.
        Continuity of the Offset surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.
        Example :
        If the basis surface is C2 in the V direction and C3 in the U
        direction Shape = C1.
        Warnings :
        If the basis surface has a unique normal direction defined at
        any point this method gives the continuity of the offset
        surface otherwise the effective continuity can be lower than
        the continuity of the basis surface - 1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_OffsetSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_OffsetSurface self, Standard_Integer const N) -> Standard_Boolean

        This method answer True if the continuity of the basis surface
        is N + 1 in the U parametric direction. We suppose in this
        class that a unique normal is defined at any point on the basis
        surface.
        Raised if N <0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_OffsetSurface self, Standard_Integer const N) -> Standard_Boolean

        This method answer True if the continuity of the basis surface
        is N + 1 in the V parametric direction. We suppose in this
        class that a unique normal is defined at any point on the basis
        surface.
        Raised if N <0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsCNv(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_OffsetSurface self) -> Standard_Boolean

        Checks whether this offset surface is closed in the u
        parametric direction.
        Returns true if, taking uFirst and uLast as
        the parametric bounds in the u parametric direction,
        the distance between the points P(uFirst,v)
        and P(uLast,v) is less than or equal to
        gp::Resolution() for each value of the   parameter v.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_OffsetSurface self) -> Standard_Boolean

        Checks whether this offset surface is closed in the u
        or v parametric direction. Returns true if taking vFirst and vLast as the
        parametric bounds in the v parametric direction, the
        distance between the points P(u,vFirst) and
        P(u,vLast) is less than or equal to
        gp::Resolution() for each value of the parameter u.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_OffsetSurface self) -> Standard_Boolean

        Returns true if this offset surface is periodic in the u
        parametric direction, i.e. if the basis
        surface of this offset surface is periodic in this direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsUPeriodic(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_OffsetSurface self) -> Standard_Real

        Returns the period of this offset surface in the u
        parametric direction respectively, i.e. the period of the
        basis surface of this offset surface in this parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetSurface_UPeriod(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_OffsetSurface self) -> Standard_Boolean

        Returns true if this offset surface is periodic in the v
        parametric direction, i.e. if the basis
        surface of this offset surface is periodic in this direction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsVPeriodic(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_OffsetSurface self) -> Standard_Real

        Returns the period of this offset surface in the v
        parametric direction respectively, i.e. the period of the
        basis surface of this offset surface in this parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_OffsetSurface_VPeriod(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_OffsetSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_OffsetSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_OffsetSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.

        Te followings methods compute value and derivatives.

        Warnings
        An exception is raised if a unique normal vector is
        not defined on the basis surface for the parametric
        value (U,V).
        No check is done at the creation time and we suppose
        in this package that the offset surface can be defined
        at any point.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_OffsetSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        P (U, V) = Pbasis + Offset * Ndir   where
        Ndir = D1Ubasis ^ D1Vbasis / ||D1Ubasis ^ D1Vbasis|| is the
        normal direction of the basis surface. Pbasis, D1Ubasis,
        D1Vbasis are the point and the first derivatives on the basis
        surface.
        If Ndir is undefined this method computes an approched normal
        direction using the following limited development :
        Ndir = N0 + DNdir/DU + DNdir/DV + Eps with Eps->0 which
        requires to compute the second derivatives on the basis surface.
        If the normal direction cannot be approximate for this order
        of derivation the exception UndefinedValue is raised.

        Raised if the continuity of the basis surface is not C1.
        Raised if the order of derivation required to compute the
        normal direction is greater than the second order.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the continuity of the basis surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        ---Purpose ;
        Raised if the continuity of the basis surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the continuity of the basis surface is not C4.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u and Nv
        in the direction v.
        ---Purpose ;
        Raised if the continuity of the basis surface is not CNu + 1
        in the U direction and CNv + 1 in the V direction.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        The following methods compute the value and derivatives
        on the offset surface and returns the derivatives on the
        basis surface too.
        The computation of the value and derivatives on the basis
        surface are used to evaluate the offset surface.

        Warnings :
        The exception UndefinedValue or UndefinedDerivative is
        raised if it is not possible to compute a unique offset
        direction.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_OffsetSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_OffsetSurface self, gp_Trsf T)

        Applies the transformation T to this offset surface.
        Note: the basis surface is also modified.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_OffsetSurface_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_OffsetSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)
        This methods calls the basis surface method.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_OffsetSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_OffsetSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods calls the basis surface method.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_OffsetSurface_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_OffsetSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this offset surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Copy(self, *args)


    def Surface(self, *args):
        """
        Surface(Handle_Geom_OffsetSurface self) -> Handle_Geom_Surface

        returns an  equivalent surface of the offset surface
        when  the basis surface   is a canonic  surface or a
        rectangular  limited surface on canonic surface or if
        the offset is null.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_OffsetSurface_Surface(self, *args)


    def UOsculatingSurface(self, *args):
        """
        UOsculatingSurface(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface UOsculSurf) -> Standard_Boolean

        if Standard_True, L is  the local osculating surface
        along U at  the point U,V.   It means that  DL/DU is
        collinear to DS/DU .  If IsOpposite == Standard_True
        these vectors have opposite direction.

        :type U: float
        :type V: float
        :type IsOpposite: bool
        :type UOsculSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_UOsculatingSurface(self, *args)


    def VOsculatingSurface(self, *args):
        """
        VOsculatingSurface(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V, Handle_Geom_BSplineSurface VOsculSurf) -> Standard_Boolean

        if Standard_True, L is the local osculating surface
        along V at the point U,V.
        It means that  DL/DV is
        collinear to DS/DV .  If IsOpposite == Standard_True
        these vectors have opposite direction.

        :type U: float
        :type V: float
        :type IsOpposite: bool
        :type VOsculSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_VOsculatingSurface(self, *args)


    def GetBasisSurfContinuity(self, *args):
        """
        GetBasisSurfContinuity(Handle_Geom_OffsetSurface self) -> GeomAbs_Shape

        Returns continuity of the basis surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_OffsetSurface_GetBasisSurfContinuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_OffsetSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_OffsetSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OffsetSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_OffsetSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_OffsetSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_OffsetSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_OffsetSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_OffsetSurface_VReversed(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_OffsetSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_OffsetSurface self, gp_Pnt P)
        Mirror(Handle_Geom_OffsetSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_OffsetSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_OffsetSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_OffsetSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_OffsetSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_OffsetSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_OffsetSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_OffsetSurface self, gp_Vec V)
        Translate(Handle_Geom_OffsetSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_OffsetSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_OffsetSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_OffsetSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_OffsetSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_OffsetSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_OffsetSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_OffsetSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_OffsetSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_OffsetSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_OffsetSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_OffsetSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_OffsetSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_OffsetSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_OffsetSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_OffsetSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_OffsetSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_OffsetSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_OffsetSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_OffsetSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_OffsetSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OffsetSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_OffsetSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_OffsetSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_OffsetSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_OffsetSurface_DecrementRefCounter(self, *args)

Handle_Geom_OffsetSurface_swigregister = _Geom.Handle_Geom_OffsetSurface_swigregister
Handle_Geom_OffsetSurface_swigregister(Handle_Geom_OffsetSurface)

def Handle_Geom_OffsetSurface_DownCast(thing):
    return _Geom.Handle_Geom_OffsetSurface_DownCast(thing)
Handle_Geom_OffsetSurface_DownCast = _Geom.Handle_Geom_OffsetSurface_DownCast

class Handle_Geom_BSplineSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BSplineSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BSplineSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BSplineSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BSplineSurface self, Geom_BSplineSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BSplineSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BSplineSurface self, Handle_Geom_BSplineSurface theHandle) -> Handle_Geom_BSplineSurface
        assign(Handle_Geom_BSplineSurface self, Geom_BSplineSurface thePtr) -> Handle_Geom_BSplineSurface
        assign(Handle_Geom_BSplineSurface self, Handle_Geom_BSplineSurface theHandle) -> Handle_Geom_BSplineSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BSplineSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BSplineSurface self) -> Geom_BSplineSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BSplineSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BSplineSurface self) -> Geom_BSplineSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BSplineSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BSplineSurface self) -> Geom_BSplineSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BSplineSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BSplineSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BSplineSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BSplineSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BSplineSurface

    def ExchangeUV(self, *args):
        """
        ExchangeUV(Handle_Geom_BSplineSurface self)

        Exchanges the u and v parametric directions on
        this BSpline surface.
        As a consequence:
        - the poles and weights tables are transposed,
        - the knots and multiplicities tables are exchanged,
        - degrees of continuity, and rational, periodic and
        uniform characteristics are exchanged, and
        - the orientation of the surface is inverted.


        """
        return _Geom.Handle_Geom_BSplineSurface_ExchangeUV(self, *args)


    def SetUPeriodic(self, *args):
        """
        SetUPeriodic(Handle_Geom_BSplineSurface self)

        Sets the surface U periodic.
        Modifies this surface to be periodic in the U 
        parametric direction.
        To become periodic in a given parametric direction a
        surface must be closed in that parametric direction,
        and the knot sequence relative to that direction must be periodic.
        To generate this periodic sequence of knots, the
        functions FirstUKnotIndex and LastUKnotIndex  are used to
        compute I1 and I2. These are the indexes, in the
        knot array associated with the given parametric
        direction, of the knots that correspond to the first and
        last parameters of this BSpline surface in the given
        parametric direction. Hence the period is:
        Knots(I1) - Knots(I2)
        As a result, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if the surface is not
        closed in the given parametric direction.


        """
        return _Geom.Handle_Geom_BSplineSurface_SetUPeriodic(self, *args)


    def SetVPeriodic(self, *args):
        """
        SetVPeriodic(Handle_Geom_BSplineSurface self)

        Sets the surface V periodic.
        Modifies this surface to be periodic in the V
        parametric direction.
        To become periodic in a given parametric direction a
        surface must be closed in that parametric direction,
        and the knot sequence relative to that direction must be periodic.
        To generate this periodic sequence of knots, the
        functions FirstVKnotIndex and LastVKnotIndex are used to
        compute I1 and I2. These are the indexes, in the
        knot array associated with the given parametric
        direction, of the knots that correspond to the first and
        last parameters of this BSpline surface in the given
        parametric direction. Hence the period is:
        Knots(I1) - Knots(I2)
        As a result, the knots and poles tables are modified.
        Exceptions
        Standard_ConstructionError if the surface is not
        closed in the given parametric direction.


        """
        return _Geom.Handle_Geom_BSplineSurface_SetVPeriodic(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Handle_Geom_BSplineSurface self)

        returns the parameter normalized within
        the period if the surface is periodic : otherwise
        does not do anything

        :type U: float
        :type V: float

        """
        return _Geom.Handle_Geom_BSplineSurface_PeriodicNormalization(self, *args)


    def SetUOrigin(self, *args):
        """
        SetUOrigin(Handle_Geom_BSplineSurface self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table in
        the corresponding parametric direction to be the
        origin of this periodic BSpline surface. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this BSpline surface is
        not periodic in the given parametric direction.
        Standard_DomainError if Index is outside the
        bounds of the knots table in the given parametric direction.

        :type Index: int

        """
        return _Geom.Handle_Geom_BSplineSurface_SetUOrigin(self, *args)


    def SetVOrigin(self, *args):
        """
        SetVOrigin(Handle_Geom_BSplineSurface self, Standard_Integer const Index)

        Assigns the knot of index Index in the knots table in
        the corresponding parametric direction to be the
        origin of this periodic BSpline surface. As a
        consequence, the knots and poles tables are modified.
        Exceptions
        Standard_NoSuchObject if this BSpline surface is
        not periodic in the given parametric direction.
        Standard_DomainError if Index is outside the
        bounds of the knots table in the given parametric direction.

        :type Index: int

        """
        return _Geom.Handle_Geom_BSplineSurface_SetVOrigin(self, *args)


    def SetUNotPeriodic(self, *args):
        """
        SetUNotPeriodic(Handle_Geom_BSplineSurface self)

        Sets the surface U not periodic.
        Changes this BSpline surface into a non-periodic
        surface along U direction. 
        If this surface is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.


        """
        return _Geom.Handle_Geom_BSplineSurface_SetUNotPeriodic(self, *args)


    def SetVNotPeriodic(self, *args):
        """
        SetVNotPeriodic(Handle_Geom_BSplineSurface self)

        Sets the surface V not periodic.
        Changes this BSpline surface into a non-periodic
        surface along V direction. 
        If this surface is already non-periodic, it is not modified.
        Note: the poles and knots tables are modified.


        """
        return _Geom.Handle_Geom_BSplineSurface_SetVNotPeriodic(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_BSplineSurface self)

        Changes the orientation of this BSpline surface in the
        U parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        The knots and poles tables are modified.


        """
        return _Geom.Handle_Geom_BSplineSurface_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_BSplineSurface self)

        Changes the orientation of this BSpline surface in the
        V parametric direction. The bounds of the
        surface are not changed but the given parametric
        direction is reversed. Hence the orientation of the
        surface is reversed.
        The knots and poles tables are modified.


        """
        return _Geom.Handle_Geom_BSplineSurface_VReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_BSplineSurface self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, produced by reversing its U parametric
        direction, for the point of u parameter U,  on this BSpline surface.
        For a BSpline surface, these functions return respectively:
        - UFirst + ULast - U, 
        where UFirst, ULast are
        the values of the first and last parameters of this
        BSpline surface, in the u parametric directions.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_BSplineSurface self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, produced by reversing its V parametric
        direction, for the point of v parameter V on this BSpline surface.
        For a BSpline surface, these functions return respectively:
        - VFirst + VLast - V,
        VFirst and VLast are
        the values of the first and last parameters of this
        BSpline surface, in the v pametric directions.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_VReversedParameter(self, *args)


    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Handle_Geom_BSplineSurface self, Standard_Integer const UDegree, Standard_Integer const VDegree)

        Increases the degrees of this BSpline surface to
        UDegree and VDegree in the u and v parametric
        directions respectively. As a result, the tables of poles,
        weights and multiplicities are modified. The tables of
        knots is not changed.
        Note: Nothing is done if the given degree is less than
        or equal to the current degree in the corresponding
        parametric direction.
        Exceptions
        Standard_ConstructionError if UDegree or
        VDegree is greater than
        Geom_BSplineSurface::MaxDegree().

        :type UDegree: int
        :type VDegree: int

        """
        return _Geom.Handle_Geom_BSplineSurface_IncreaseDegree(self, *args)


    def InsertUKnots(self, *args):
        """
        InsertUKnots(Handle_Geom_BSplineSurface self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts into the knots table for the U
        parametric direction of this BSpline surface:
        - the values of the array Knots, with their respective
        multiplicities, Mults.
        If the knot value to insert already exists in the table, its multiplicity is:
        - increased by M, if Add is true (the default), or
        - increased to M, if Add is false.
        The tolerance criterion used to check the equality of
        the knots is the larger of the values ParametricTolerance and
        Standard_Real::Epsilon(val), where val is the knot value to be inserted.
        Warning
        - If a given multiplicity coefficient is null, or negative, nothing is done.
        - The new multiplicity of a knot is limited to the degree of this BSpline surface in the
        corresponding parametric direction.
        Exceptions
        Standard_ConstructionError if a knot value to
        insert is outside the bounds of this BSpline surface in
        the specified parametric direction. The comparison
        uses the precision criterion ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_InsertUKnots(self, *args)


    def InsertVKnots(self, *args):
        """
        InsertVKnots(Handle_Geom_BSplineSurface self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts into the knots table for the V
        parametric direction of this BSpline surface:
        - the values of the array Knots, with their respective
        multiplicities, Mults.
        If the knot value to insert already exists in the table, its multiplicity is:
        - increased by M, if Add is true (the default), or
        - increased to M, if Add is false.
        The tolerance criterion used to check the equality of
        the knots is the larger of the values ParametricTolerance and
        Standard_Real::Epsilon(val), where val is the knot value to be inserted.
        Warning
        - If a given multiplicity coefficient is null, or negative, nothing is done.
        - The new multiplicity of a knot is limited to the degree of this BSpline surface in the
        corresponding parametric direction.
        Exceptions
        Standard_ConstructionError if a knot value to
        insert is outside the bounds of this BSpline surface in
        the specified parametric direction. The comparison
        uses the precision criterion ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_InsertVKnots(self, *args)


    def RemoveUKnot(self, *args):
        """
        RemoveUKnot(Handle_Geom_BSplineSurface self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces to M the multiplicity of the knot of index
        Index in the U parametric direction. If M is 0, the knot is removed.
        With a modification of this type, the table of poles is also modified.
        Two different algorithms are used systematically to
        compute the new poles of the surface. For each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is checked. If
        this distance is less than Tolerance it ensures that
        the surface is not modified by more than Tolerance.
        Under these conditions, the function returns true;
        otherwise, it returns false.
        A low tolerance prevents modification of the
        surface. A high tolerance "smoothes" the surface.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table of this BSpline surface.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_RemoveUKnot(self, *args)


    def RemoveVKnot(self, *args):
        """
        RemoveVKnot(Handle_Geom_BSplineSurface self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Reduces to M the multiplicity of the knot of index
        Index in the V parametric direction. If M is 0, the knot is removed.
        With a modification of this type, the table of poles is also modified.
        Two different algorithms are used systematically to
        compute the new poles of the surface. For each
        pole, the distance between the pole calculated
        using the first algorithm and the same pole
        calculated using the second algorithm, is checked. If
        this distance is less than Tolerance it ensures that
        the surface is not modified by more than Tolerance.
        Under these conditions, the function returns true;
        otherwise, it returns false.
        A low tolerance prevents modification of the
        surface. A high tolerance "smoothes" the surface.
        Exceptions
        Standard_OutOfRange if Index is outside the
        bounds of the knots table of this BSpline surface.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_RemoveVKnot(self, *args)


    def IncreaseUMultiplicity(self, *args):
        """
        IncreaseUMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const M)
        IncreaseUMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const M)

        Increases until order M the multiplicity of the set of knots
        FromI1,...., ToI2 in the U direction. This method can be used
        to make a B_spline surface into a PiecewiseBezier B_spline
        surface.
        If <me> was uniform, it can become non uniform.

        Raised if FromI1 or ToI2 is out of the range [FirstUKnotIndex,
        LastUKnotIndex].

        M should be greater than the previous multiplicity of the
        all the knots FromI1,..., ToI2 and lower or equal to the
        Degree of the surface in the U parametric direction.

        :type FromI1: int
        :type ToI2: int
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineSurface_IncreaseUMultiplicity(self, *args)


    def IncrementUMultiplicity(self, *args):
        """
        IncrementUMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const Step)

        Increments the multiplicity of the consecutives uknots FromI1..ToI2
        by step.   The multiplicity of each knot FromI1,.....,ToI2 must be
        lower or equal to the UDegree of the B_spline.

        Raised if FromI1 or ToI2 is not in the range
        [FirstUKnotIndex, LastUKnotIndex]

        Raised if one knot has a multiplicity greater than UDegree.

        :type FromI1: int
        :type ToI2: int
        :type Step: int

        """
        return _Geom.Handle_Geom_BSplineSurface_IncrementUMultiplicity(self, *args)


    def IncreaseVMultiplicity(self, *args):
        """
        IncreaseVMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Integer const M)
        IncreaseVMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const M)

        Increases until order M the multiplicity of the set of knots
        FromI1,...., ToI2 in the V direction. This method can be used to
        make a BSplineSurface into a PiecewiseBezier B_spline
        surface. If <me> was uniform, it can become non-uniform.

        Raised if FromI1 or ToI2 is out of the range [FirstVKnotIndex,
        LastVKnotIndex] given by the methods with the same name.

        M should be greater than the previous multiplicity of the
        all the knots FromI1,..., ToI2 and lower or equal to the
        Degree of the surface in the V parametric direction.

        :type FromI1: int
        :type ToI2: int
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineSurface_IncreaseVMultiplicity(self, *args)


    def IncrementVMultiplicity(self, *args):
        """
        IncrementVMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const FromI1, Standard_Integer const ToI2, Standard_Integer const Step)

        Increments the multiplicity of the consecutives vknots FromI1..ToI2
        by step.  The multiplicity of each knot FromI1,.....,ToI2 must be
        lower or equal to the VDegree of the B_spline.

        Raised if FromI1 or ToI2 is not in the range
        [FirstVKnotIndex, LastVKnotIndex]

        Raised if one knot has a multiplicity greater than VDegree.

        :type FromI1: int
        :type ToI2: int
        :type Step: int

        """
        return _Geom.Handle_Geom_BSplineSurface_IncrementVMultiplicity(self, *args)


    def InsertUKnot(self, *args):
        """
        InsertUKnot(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Integer const M, Standard_Real const ParametricTolerance, Standard_Boolean const Add)

        Inserts a knot value in the sequence of UKnots. If U is a knot
        value this method increases the multiplicity of the knot if the
        previous multiplicity was lower than M else it does nothing. The
        tolerance criterion is ParametricTolerance. ParametricTolerance
        should be greater or equal than Resolution from package gp.

        Raised if U is out of the bounds [U1, U2] given by the methods
        Bounds, the criterion ParametricTolerance is used.
        Raised if M is not in the range [1, UDegree].

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_InsertUKnot(self, *args)


    def InsertVKnot(self, *args):
        """
        InsertVKnot(Handle_Geom_BSplineSurface self, Standard_Real const V, Standard_Integer const M, Standard_Real const ParametricTolerance, Standard_Boolean const Add)

        Inserts a knot value in the sequence of VKnots. If V is a knot
        value this method increases the multiplicity of the knot if the
        previous multiplicity was lower than M otherwise it does nothing.
        The tolerance criterion is ParametricTolerance.
        ParametricTolerance should be greater or equal than Resolution
        from package gp.

        raises if V is out of the Bounds [V1, V2] given by the methods
        Bounds, the criterion ParametricTolerance is used.
        raises if M is not in the range [1, VDegree].

        :type V: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_InsertVKnot(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom_BSplineSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Segments the surface between U1 and U2 in the U-Direction.
        between V1 and V2 in the V-Direction.
        The control points are modified, the first and the last point
        are not the same.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the surface <me> or if the surface makes loop.
        raises if U2 < U1 or V2 < V1.
        Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces.
        i.e. ((U2 - U1) - UPeriod) > Precision::PConfusion().
        Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces.
        i.e. ((V2 - V1) - VPeriod) > Precision::PConfusion()).

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BSplineSurface_Segment(self, *args)


    def CheckAndSegment(self, *args):
        """
        CheckAndSegment(Handle_Geom_BSplineSurface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        Segments the surface between U1 and U2 in the U-Direction.
        between V1 and V2 in the V-Direction.

        same as Segment but do nothing if U1 and U2 (resp. V1 and V2) are
        equal to the bounds in U (resp. in V) of <me>.
        For example, if <me> is periodic in V, it will be always periodic
        in V after the segmentation if the bounds in V are unchanged

        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the surface <me> or if the surface makes loop.
        raises if U2 < U1 or V2 < V1.
        Standard_DomainError if U2 - U1 exceeds the uperiod for uperiodic surfaces.
        i.e. ((U2 - U1) - UPeriod) > Precision::PConfusion().
        Standard_DomainError if V2 - V1 exceeds the vperiod for vperiodic surfaces.
        i.e. ((V2 - V1) - VPeriod) > Precision::PConfusion()).

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BSplineSurface_CheckAndSegment(self, *args)


    def SetUKnot(self, *args):
        """
        SetUKnot(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Real const K)
        SetUKnot(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Real const K, Standard_Integer const M)

        Changes the value of the UKnots of range UIndex and
        increases its multiplicity.

        Raised if UIndex is not in the range [FirstUKnotIndex,
        LastUKnotIndex] given by the methods with the same name.

        Raised if K >= UKnots(UIndex+1) or K <= UKnots(UIndex-1)
        M must be lower than UDegree and greater than the previous
        multiplicity of the knot of range UIndex.

        :type UIndex: int
        :type K: float
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineSurface_SetUKnot(self, *args)


    def SetUKnots(self, *args):
        """
        SetUKnots(Handle_Geom_BSplineSurface self, NCollection_Array1_Standard_Real UK)

        Changes all the U-knots of the surface.
        The multiplicity of the knots are not modified.

        Raised if there is an index such that UK (Index+1) <= UK (Index).

        Raised if  UK.Lower() < 1 or UK.Upper() > NbUKnots

        :type UK: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_SetUKnots(self, *args)


    def SetVKnot(self, *args):
        """
        SetVKnot(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Real const K)
        SetVKnot(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, Standard_Real const K, Standard_Integer const M)

        Changes the value of the VKnots of range VIndex and increases
        its multiplicity.

        Raised if VIndex is not in the range [FirstVKnotIndex,
        LastVKnotIndex] given by the methods with the same name.

        Raised if K >= VKnots(VIndex+1) or K <= VKnots(VIndex-1)
        M must be lower than VDegree and greater than the previous
        multiplicity of the knot of range VIndex.

        :type VIndex: int
        :type K: float
        :type M: int

        """
        return _Geom.Handle_Geom_BSplineSurface_SetVKnot(self, *args)


    def SetVKnots(self, *args):
        """
        SetVKnots(Handle_Geom_BSplineSurface self, NCollection_Array1_Standard_Real VK)

        Changes all the V-knots of the surface.
        The multiplicity of the knots are not modified.

        Raised if there is an index such that VK (Index+1) <= VK (Index).

        Raised if  VK.Lower() < 1 or VK.Upper() > NbVKnots

        :type VK: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_SetVKnots(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of UKnots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        UKnots (I1) <= U <= UKnots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < UKnots(1) - Abs(ParametricTolerance)
        . if I2 > NbUKnots => U > UKnots(NbUKnots)+Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_LocateU(self, *args)


    def LocateV(self, *args):
        """
        LocateV(Handle_Geom_BSplineSurface self, Standard_Real const V, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value V in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        VKnots (I1) <= V <= VKnots (I2)
        . if I1 = I2  V is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => V < VKnots(1) - Abs(ParametricTolerance)
        . if I2 > NbVKnots => V > VKnots(NbVKnots)+Abs(ParametricTolerance)
        poles insertion and removing
        The following methods are available only if the surface
        is Uniform or QuasiUniform in the considered direction
        The knot repartition is modified.

        :type V: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Geom.Handle_Geom_BSplineSurface_LocateV(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P)
        SetPole(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weight of range (UIndex, VIndex)
        with P and W.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.
        Raised if Weight <= Resolution from package gp.

        :type UIndex: int
        :type VIndex: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BSplineSurface_SetPole(self, *args)


    def SetPoleCol(self, *args):
        """
        SetPoleCol(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles)
        SetPoleCol(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a column of poles or a part of this column with the
        corresponding weights. If the surface was rational it can
        become non rational. If the surface was non rational it can
        become rational.
        Raised if Vindex < 1 or VIndex > NbVPoles.

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbUPoles
        Raised if the bounds of CPoleWeights are not the same as the
        bounds of CPoles.
        Raised if one of the weight value of CPoleWeights is lower or
        equal to Resolution from package gp.

        :type VIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_SetPoleCol(self, *args)


    def SetPoleRow(self, *args):
        """
        SetPoleRow(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CPoleWeights)
        SetPoleRow(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_gp_Pnt CPoles)

        Changes a row of poles or a part of this row.
        Raised if Uindex < 1 or UIndex > NbUPoles.

        Raised if CPoles.Lower() < 1 or CPoles.Upper() > NbVPoles.

        :type UIndex: int
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Geom.Handle_Geom_BSplineSurface_SetPoleRow(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex, Standard_Real const Weight)

        Changes the weight of the pole of range UIndex, VIndex.
        If the surface was non rational it can become rational.
        If the surface was rational it can become non rational.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles

        Raised if weight is lower or equal to Resolution from
        package gp

        :type UIndex: int
        :type VIndex: int
        :type Weight: float

        """
        return _Geom.Handle_Geom_BSplineSurface_SetWeight(self, *args)


    def SetWeightCol(self, *args):
        """
        SetWeightCol(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a column of weights of a part of this column.

        Raised if VIndex < 1 or VIndex > NbVPoles

        Raised if CPoleWeights.Lower() < 1 or
        CPoleWeights.Upper() > NbUPoles.
        Raised if a weight value is lower or equal to Resolution
        from package gp.

        :type VIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_SetWeightCol(self, *args)


    def SetWeightRow(self, *args):
        """
        SetWeightRow(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, NCollection_Array1_Standard_Real CPoleWeights)

        Changes a row of weights or a part of this row.

        Raised if UIndex < 1 or UIndex > NbUPoles

        Raised if CPoleWeights.Lower() < 1 or
        CPoleWeights.Upper() > NbVPoles.
        Raised  if a weight value is lower or equal to Resolution
        from package gp.

        :type UIndex: int
        :type CPoleWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_SetWeightRow(self, *args)


    def MovePoint(self, *args):
        """
        MovePoint(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, Standard_Integer const UIndex1, Standard_Integer const UIndex2, Standard_Integer const VIndex1, Standard_Integer const VIndex2)

        Move a point with parameter U and V to P.
        given u,v  as parameters)  to  reach a  new position
        UIndex1, UIndex2, VIndex1, VIndex2:
        indicates the poles which can be moved
        if Problem in BSplineBasis calculation, no change
        for the curve and
        UFirstIndex, VLastIndex = 0
        VFirstIndex, VLastIndex = 0

        Raised if UIndex1 < UIndex2 or VIndex1 < VIndex2 or
        UIndex1 < 1 || UIndex1 > NbUPoles or
        UIndex2 < 1 || UIndex2 > NbUPoles
        VIndex1 < 1 || VIndex1 > NbVPoles or
        VIndex2 < 1 || VIndex2 > NbVPoles
        characteristics of the surface

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type UIndex1: int
        :type UIndex2: int
        :type VIndex1: int
        :type VIndex2: int
        :type UFirstIndex: int
        :type ULastIndex: int
        :type VFirstIndex: int
        :type VLastIndex: int

        """
        return _Geom.Handle_Geom_BSplineSurface_MovePoint(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns true if the first control points row and the last
        control points row are identical. The tolerance criterion
        is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns true if the first control points column and the
        last last control points column are identical.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_BSplineSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the order of continuity of the surface in the
        U direction  is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_BSplineSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True if the order of continuity of the surface
        in the V direction  is N.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns True if the surface is closed in the U direction
        and if the B-spline has been turned into a periodic surface
        using the function SetUPeriodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsUPeriodic(self, *args)


    def IsURational(self, *args):
        """
        IsURational(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns False if for each row of weights all the weights
        are identical.
        The tolerance criterion is resolution from package gp.
        Example :
        |1.0, 1.0, 1.0|
        if Weights =  |0.5, 0.5, 0.5|   returns False
        |2.0, 2.0, 2.0|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsURational(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns True if the surface is closed in the V direction
        and if the B-spline has been turned into a periodic
        surface using the function SetVPeriodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsVPeriodic(self, *args)


    def IsVRational(self, *args):
        """
        IsVRational(Handle_Geom_BSplineSurface self) -> Standard_Boolean

        Returns False if for each column of weights all the weights
        are identical.
        The tolerance criterion is resolution from package gp.
        Examples :
        |1.0, 2.0, 0.5|
        if Weights =  |1.0, 2.0, 0.5|   returns False
        |1.0, 2.0, 0.5|

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsVRational(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_BSplineSurface self)

        Returns the parametric bounds of the surface.
        Warnings :
        These parametric values are the bounds of the array of
        knots UKnots and VKnots only if the first knots and the
        last knots have a multiplicity equal to UDegree + 1 or
        VDegree + 1

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_BSplineSurface_Bounds(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BSplineSurface self) -> GeomAbs_Shape

        Returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Surface,
        C2 : continuity of the second derivative all along the Surface,
        C3 : continuity of the third derivative all along the Surface,
        CN : the order of continuity is infinite.
        A B-spline surface is infinitely continuously differentiable
        for the couple of parameters U, V such thats U != UKnots(i)
        and V != VKnots(i). The continuity of the surface at a knot
        value depends on the multiplicity of this knot.
        Example :
        If the surface is C1 in the V direction and C2 in the U
        direction this function returns Shape = C1.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BSplineSurface_Continuity(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the UKnots which gives the first
        parametric value of the surface in the U direction.
        The UIso curve corresponding to this value is a
        boundary curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_FirstUKnotIndex(self, *args)


    def FirstVKnotIndex(self, *args):
        """
        FirstVKnotIndex(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the VKnots which gives the
        first parametric value of the surface in the V direction.
        The VIso curve corresponding to this knot is a boundary
        curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_FirstVKnotIndex(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the UKnots which gives the
        last parametric value of the surface in the U direction.
        The UIso curve corresponding to this knot is a boundary
        curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_LastUKnotIndex(self, *args)


    def LastVKnotIndex(self, *args):
        """
        LastVKnotIndex(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Computes the Index of the VKnots which gives the
        last parametric value of the surface in the V direction.
        The VIso curve corresponding to this knot is a
        boundary curve of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_LastVKnotIndex(self, *args)


    def NbUKnots(self, *args):
        """
        NbUKnots(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of knots in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_NbUKnots(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns number of poles in the U direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_NbUPoles(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of knots in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_NbVKnots(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the number of poles in the V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_NbVPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range (UIndex, VIndex).

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1 or
        VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Handle_Geom_BSplineSurface_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns the poles of the B-spline surface.

        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _Geom.Handle_Geom_BSplineSurface_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the degree of the normalized B-splines Ni,n in the U
        direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_UDegree(self, *args)


    def UKnot(self, *args):
        """
        UKnot(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex) -> Standard_Real

        Returns the Knot value of range UIndex.
        Raised if UIndex < 1 or UIndex > NbUKnots

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_UKnot(self, *args)


    def UKnotDistribution(self, *args):
        """
        UKnotDistribution(Handle_Geom_BSplineSurface self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or
        PiecewiseBezier.  If all the knots differ by a
        positive constant from the preceding knot in the U
        direction the B-spline surface can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1
        except for the first and last knot which are of
        multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have
        multiplicity Degree + 1 and if interior knots have
        multiplicity Degree
        otherwise the surface is non uniform in the U direction
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Handle_Geom_BSplineSurface_UKnotDistribution(self, *args)


    def UKnots(self, *args):
        """
        Returns the knots in the U direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineSurface_UKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UKnotSequence(self, *args):
        """
        Returns the uknots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineSurface_UKnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UMultiplicity(self, *args):
        """
        UMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex) -> Standard_Integer

        Returns the multiplicity value of knot of range UIndex in
        the u direction.
        Raised if UIndex < 1 or UIndex > NbUKnots.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_UMultiplicity(self, *args)


    def UMultiplicities(self, *args):
        """
        Returns the multiplicities of the knots in the U direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Handle_Geom_BSplineSurface_UMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VDegree(self, *args):
        """
        VDegree(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the degree of the normalized B-splines Ni,d in the
        V direction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_VDegree(self, *args)


    def VKnot(self, *args):
        """
        VKnot(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex) -> Standard_Real

        Returns the Knot value of range VIndex.
        Raised if VIndex < 1 or VIndex > NbVKnots

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_VKnot(self, *args)


    def VKnotDistribution(self, *args):
        """
        VKnotDistribution(Handle_Geom_BSplineSurface self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or
        PiecewiseBezier. If all the knots differ by a positive
        constant from the preceding knot in the V direction the
        B-spline surface can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1
        except for the first and last knot which are of
        multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have
        multiplicity  Degree + 1 and if interior knots have
        multiplicity Degree
        otherwise the surface is non uniform in the V direction.
        The tolerance criterion is Resolution from package gp.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Geom.Handle_Geom_BSplineSurface_VKnotDistribution(self, *args)


    def VKnots(self, *args):
        """
        Returns the knots in the V direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineSurface_VKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VKnotSequence(self, *args):
        """
        Returns the vknots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        Ku = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Geom.Handle_Geom_BSplineSurface_VKnotSequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VMultiplicity(self, *args):
        """
        VMultiplicity(Handle_Geom_BSplineSurface self, Standard_Integer const VIndex) -> Standard_Integer

        Returns the multiplicity value of knot of range VIndex in
        the v direction.
        Raised if VIndex < 1 or VIndex > NbVKnots

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_VMultiplicity(self, *args)


    def VMultiplicities(self, *args):
        """
        Returns the multiplicities of the knots in the V direction.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Geom.Handle_Geom_BSplineSurface_VMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Weight(self, *args):
        """
        Weight(Handle_Geom_BSplineSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Standard_Real

        Returns the weight value of range UIndex, VIndex.

        Raised if UIndex < 1 or UIndex > NbUPoles or VIndex < 1
        or VIndex > NbVPoles.

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom_BSplineSurface self, NCollection_Array2_Standard_Real W)
        Weights(Handle_Geom_BSplineSurface self) -> NCollection_Array2_Standard_Real

        Returns the weights of the B-spline surface.
        value and derivatives computation

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _Geom.Handle_Geom_BSplineSurface_Weights(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Raised if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Nu is the order of derivation in the U parametric direction and
        Nv is the order of derivation in the V parametric direction.

        Raised if the continuity of the surface is not CNu in the U
        direction and CNv in the V direction.

        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        The following functions computes the point for the
        parametric values (U, V) and the derivatives at
        this point on the B-spline surface patch delimited
        with the knots FromUK1, FromVK1 and the knots ToUK2,
        ToVK2.  (U, V) can be out of these parametric bounds
        but for the computation we only use the definition
        of the surface between these knots. This method is
        useful to compute local derivative, if the order of
        continuity of the whole surface is not greater enough.
        Inside the parametric knot's domain previously defined
        the evaluations are the same as if we consider the whole
        definition of the surface. Of course the evaluations are
        different outside this parametric domain.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_DN(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P)

        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Raised if the local continuity of the surface is not C1
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Raised if the local continuity of the surface is not C2
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Raised if the local continuity of the surface is not C3
        between the knots FromUK1, ToUK2 and FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Raised if the local continuity of the surface is not CNu
        between the knots FromUK1, ToUK2 and CNv between the knots
        FromVK1, ToVK2.
        Raised if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalDN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2) -> gp_Pnt

        Computes the point of parameter U, V on the BSpline surface patch
        defines between the knots UK1 UK2, VK1, VK2. U can be out of the
        bounds [Knot UK1, Knot UK2] and V can be outof the bounds
        [Knot VK1, Knot VK2]  but for the computation we only use the
        definition of the surface between these knot values.
        Raises if FromUK1 = ToUK2 or FromVK1 = ToVK2.

        :type U: float
        :type V: float
        :type FromUK1: int
        :type ToUK2: int
        :type FromVK1: int
        :type ToVK2: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineSurface_LocalValue(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_BSplineSurface self, Standard_Real const U) -> Handle_Geom_Curve
        UIso(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Boolean const CheckRational) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        If CheckRational=False, no try to make it non-rational.
        A B-spline curve is returned.

        :type U: float
        :type CheckRational: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BSplineSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_BSplineSurface self, Standard_Real const V) -> Handle_Geom_Curve
        VIso(Handle_Geom_BSplineSurface self, Standard_Real const V, Standard_Boolean const CheckRational) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        If CheckRational=False, no try to make it non-rational.
        A B-spline curve is returned.
        transformations

        :type V: float
        :type CheckRational: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BSplineSurface_VIso(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BSplineSurface self, gp_Trsf T)

        Applies the transformation T to this BSpline surface.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BSplineSurface_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in the u and v directions.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom_BSplineSurface self, Standard_Real const Tolerance3D)

        Computes two tolerance values for this BSpline
        surface, based on the given tolerance in 3D space
        Tolerance3D. The tolerances computed are:
        - UTolerance in the u parametric direction, and
        - VTolerance in the v parametric direction.
        If f(u,v) is the equation of this BSpline surface,
        UTolerance and VTolerance guarantee that :
        | u1 - u0 | < UTolerance and
        | v1 - v0 | < VTolerance
        ====> |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float
        :type VTolerance: float

        """
        return _Geom.Handle_Geom_BSplineSurface_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BSplineSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this BSpline surface.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BSplineSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BSplineSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BSplineSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BSplineSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_BSplineSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BSplineSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_BSplineSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_BSplineSurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_BSplineSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BSplineSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BSplineSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_BSplineSurface_ParametricTransformation(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_BSplineSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_BSplineSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BSplineSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BSplineSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BSplineSurface self, gp_Pnt P)
        Mirror(Handle_Geom_BSplineSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_BSplineSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BSplineSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BSplineSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BSplineSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BSplineSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BSplineSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BSplineSurface self, gp_Vec V)
        Translate(Handle_Geom_BSplineSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BSplineSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BSplineSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BSplineSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BSplineSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BSplineSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BSplineSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BSplineSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BSplineSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BSplineSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BSplineSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BSplineSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BSplineSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BSplineSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BSplineSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BSplineSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BSplineSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BSplineSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BSplineSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BSplineSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BSplineSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BSplineSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BSplineSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BSplineSurface_DecrementRefCounter(self, *args)

Handle_Geom_BSplineSurface_swigregister = _Geom.Handle_Geom_BSplineSurface_swigregister
Handle_Geom_BSplineSurface_swigregister(Handle_Geom_BSplineSurface)

def Handle_Geom_BSplineSurface_DownCast(thing):
    return _Geom.Handle_Geom_BSplineSurface_DownCast(thing)
Handle_Geom_BSplineSurface_DownCast = _Geom.Handle_Geom_BSplineSurface_DownCast

class Handle_Geom_AxisPlacement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_AxisPlacement self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_AxisPlacement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_AxisPlacement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_AxisPlacement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_AxisPlacement self, Geom_AxisPlacement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_AxisPlacement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_AxisPlacement self, Handle_Geom_AxisPlacement theHandle) -> Handle_Geom_AxisPlacement
        assign(Handle_Geom_AxisPlacement self, Geom_AxisPlacement thePtr) -> Handle_Geom_AxisPlacement
        assign(Handle_Geom_AxisPlacement self, Handle_Geom_AxisPlacement theHandle) -> Handle_Geom_AxisPlacement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_AxisPlacement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_AxisPlacement self) -> Geom_AxisPlacement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_AxisPlacement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_AxisPlacement self) -> Geom_AxisPlacement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_AxisPlacement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_AxisPlacement self) -> Geom_AxisPlacement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_AxisPlacement___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_AxisPlacement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_AxisPlacement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_AxisPlacement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_AxisPlacement_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_AxisPlacement

    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_AxisPlacement self, gp_Ax1 A1)

        Assigns A1 as the "main Axis" of this positioning system. This modifies
        - its origin, and
        - its "main Direction".
        If this positioning system is a
        Geom_Axis2Placement, then its "X Direction" and
        "Y Direction" are recomputed.
        Exceptions
        For a Geom_Axis2Placement:
        Standard_ConstructionError if A1 and the
        previous "X Direction" of the coordinate system are parallel.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_AxisPlacement_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_AxisPlacement self, gp_Dir V)

        Changes the direction of the axis placement.
        If <me> is an axis placement two axis the main "Direction"
        is modified and the "XDirection" and "YDirection" are
        recomputed.
        Raises ConstructionError only for an axis placement two axis if V and the
        previous "XDirection" are parallel because it is not possible
        to calculate the new "XDirection" and the new "YDirection".

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_AxisPlacement_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_AxisPlacement self, gp_Pnt P)

        Assigns the point P as the origin of this positioning  system.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_AxisPlacement_SetLocation(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_AxisPlacement self, Handle_Geom_AxisPlacement Other) -> Standard_Real

        Computes the angular value, in radians, between the
        "main Direction" of this positioning system and that
        of positioning system Other. The result is a value between 0 and Pi.

        :type Other: OCC.wrapper.Geom.Handle_Geom_AxisPlacement
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_AxisPlacement_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the axis placement.
        For an "Axis2placement" it is the main axis (Location, Direction ).
        For an "Axis1Placement" this method returns a copy of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _Geom.Handle_Geom_AxisPlacement_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Direction(Handle_Geom_AxisPlacement self) -> gp_Dir

        Returns the main "Direction" of an axis placement.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_AxisPlacement_Direction(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_AxisPlacement self) -> gp_Pnt

        Returns the Location point (origin) of the axis placement.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_AxisPlacement_Location(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_AxisPlacement self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_AxisPlacement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_AxisPlacement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_AxisPlacement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_AxisPlacement self, gp_Pnt P)
        Mirror(Handle_Geom_AxisPlacement self, gp_Ax1 A1)
        Mirror(Handle_Geom_AxisPlacement self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_AxisPlacement_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_AxisPlacement self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_AxisPlacement_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_AxisPlacement self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_AxisPlacement_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_AxisPlacement self, gp_Vec V)
        Translate(Handle_Geom_AxisPlacement self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_AxisPlacement_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_AxisPlacement self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_AxisPlacement_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_AxisPlacement self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_AxisPlacement self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_AxisPlacement self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_AxisPlacement self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_AxisPlacement self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_AxisPlacement self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_AxisPlacement self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_AxisPlacement self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_AxisPlacement self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_AxisPlacement_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_AxisPlacement self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_AxisPlacement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_AxisPlacement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_AxisPlacement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_AxisPlacement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_AxisPlacement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_AxisPlacement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_AxisPlacement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_AxisPlacement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_AxisPlacement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_AxisPlacement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_AxisPlacement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_AxisPlacement self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_AxisPlacement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_AxisPlacement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_AxisPlacement_DecrementRefCounter(self, *args)

Handle_Geom_AxisPlacement_swigregister = _Geom.Handle_Geom_AxisPlacement_swigregister
Handle_Geom_AxisPlacement_swigregister(Handle_Geom_AxisPlacement)

def Handle_Geom_AxisPlacement_DownCast(thing):
    return _Geom.Handle_Geom_AxisPlacement_DownCast(thing)
Handle_Geom_AxisPlacement_DownCast = _Geom.Handle_Geom_AxisPlacement_DownCast

class Handle_Geom_Circle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Circle self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Circle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Circle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Circle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Circle self, Geom_Circle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Circle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Circle self, Handle_Geom_Circle theHandle) -> Handle_Geom_Circle
        assign(Handle_Geom_Circle self, Geom_Circle thePtr) -> Handle_Geom_Circle
        assign(Handle_Geom_Circle self, Handle_Geom_Circle theHandle) -> Handle_Geom_Circle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Circle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Circle self) -> Geom_Circle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Circle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Circle self) -> Geom_Circle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Circle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Circle self) -> Geom_Circle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Circle___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Circle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Circle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Circle_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Circle

    def SetCirc(self, *args):
        """
        SetCirc(Handle_Geom_Circle self, gp_Circ C)

        Set <me> so that <me> has the same geometric properties as C.

        :type C: OCC.wrapper.gp.gp_Circ

        """
        return _Geom.Handle_Geom_Circle_SetCirc(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_Geom_Circle self, Standard_Real const R)

        Assigns the value R to the radius of this circle.
        Note: it is possible to have a circle with a radius equal to 0.0.
        Exceptions - Standard_ConstructionError if R is negative.

        :type R: float

        """
        return _Geom.Handle_Geom_Circle_SetRadius(self, *args)


    def Circ(self, *args):
        """
        Circ(Handle_Geom_Circle self) -> gp_Circ

        returns the non transient circle from gp with the same
        geometric properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _Geom.Handle_Geom_Circle_Circ(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_Geom_Circle self) -> Standard_Real

        Returns the radius of this circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_Radius(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Circle self, Standard_Real const U) -> Standard_Real

        Computes the parameter on the reversed circle for
        the point of parameter U on this circle.
        For a circle, the returned value is: 2.*Pi - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_ReversedParameter(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom_Circle self) -> Standard_Real

        Returns the eccentricity  e = 0 for a circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_Eccentricity(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Circle self) -> Standard_Real

        Returns the value of the first parameter of this
        circle. This is  0.0, which gives the start point of this circle, or
        The start point and end point of a circle are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Circle self) -> Standard_Real

        Returns the value of the last parameter of this
        circle. This is 2.*Pi, which gives the end point of this circle.
        The start point and end point of a circle are coincident.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Circle_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Circle self) -> Standard_Boolean

        returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Circle_IsPeriodic(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Circle self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        P = C + R * Cos (U) * XDir + R * Sin (U) * YDir
        where C is the center of the circle , XDir the XDirection and
        YDir the YDirection of the circle's local coordinate system.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Circle_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Circle_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Circle_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Circle self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter u, the first second and third
        derivatives V1 V2 and V3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Circle_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Circle self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Circle_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Circle self, gp_Trsf T)

        Applies the transformation T to this circle.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Circle_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Circle self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this circle.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Circle self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Circle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Circle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Circle self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Circle_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Circle self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Circle_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Circle self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Circle_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Circle self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Circle_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Circle self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Circle_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Handle_Geom_Circle_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Handle_Geom_Circle self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Circle_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom_Circle self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Circle_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Circle self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Handle_Geom_Circle_Reverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Circle self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Circle_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Circle self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Circle_IsCN(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Circle self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Circle self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Circle self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Circle_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Circle self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Circle_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Circle self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Circle_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Circle self, gp_Pnt P)
        Mirror(Handle_Geom_Circle self, gp_Ax1 A1)
        Mirror(Handle_Geom_Circle self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Circle_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Circle self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Circle_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Circle self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Circle_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Circle self, gp_Vec V)
        Translate(Handle_Geom_Circle self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Circle_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Circle self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Circle self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Circle self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Circle self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Circle self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Circle self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Circle self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Circle self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Circle_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Circle self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Circle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Circle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Circle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Circle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Circle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Circle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Circle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Circle self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Circle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Circle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Circle_DecrementRefCounter(self, *args)

Handle_Geom_Circle_swigregister = _Geom.Handle_Geom_Circle_swigregister
Handle_Geom_Circle_swigregister(Handle_Geom_Circle)

def Handle_Geom_Circle_DownCast(thing):
    return _Geom.Handle_Geom_Circle_DownCast(thing)
Handle_Geom_Circle_DownCast = _Geom.Handle_Geom_Circle_DownCast

class Handle_Geom_Plane(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Plane self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Plane_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Plane self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Plane_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Plane self, Geom_Plane thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Plane_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Plane self, Handle_Geom_Plane theHandle) -> Handle_Geom_Plane
        assign(Handle_Geom_Plane self, Geom_Plane thePtr) -> Handle_Geom_Plane
        assign(Handle_Geom_Plane self, Handle_Geom_Plane theHandle) -> Handle_Geom_Plane

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Plane_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Plane self) -> Geom_Plane

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Plane_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Plane self) -> Geom_Plane

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Plane___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Plane self) -> Geom_Plane

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Plane___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Plane___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Plane___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Plane_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Plane

    def SetPln(self, *args):
        """
        SetPln(Handle_Geom_Plane self, gp_Pln Pl)

        Set <me> so that <me> has the same geometric properties as Pl.

        :type Pl: OCC.wrapper.gp.gp_Pln

        """
        return _Geom.Handle_Geom_Plane_SetPln(self, *args)


    def Pln(self, *args):
        """
        Pln(Handle_Geom_Plane self) -> gp_Pln

        Converts this plane into a gp_Pln plane.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _Geom.Handle_Geom_Plane_Pln(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_Plane self)

        Changes the orientation of this plane in the u (or v)
        parametric direction. The bounds of the plane are not
        changed but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_Plane_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_Plane self, Standard_Real const U) -> Standard_Real

        Computes the u  parameter on the modified
        plane, produced when reversing the u
        parametric of this plane, for any point of u parameter U  on this plane.
        In the case of a plane, these methods return - -U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Plane_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_Plane self)

        Changes the orientation of this plane in the u (or v)
        parametric direction. The bounds of the plane are not
        changed but the given parametric direction is
        reversed. Hence the orientation of the surface is reversed.


        """
        return _Geom.Handle_Geom_Plane_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_Plane self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        plane, produced when reversing the  v
        parametric of this plane, for any point of v parameter V on this plane.
        In the case of a plane, these methods return -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Plane_VReversedParameter(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_Plane self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are the new values of U,V after calling
        me->TranformParameters(U,V,T)
        This methods multiplies U and V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Plane_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Plane self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.
        me->Transformed(T)->Value(U',V')
        is the same point as
        me->Value(U,V).Transformed(T)
        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by
        me->ParametricTransformation(T)
        This  methods  returns  a scale  centered  on  the
        origin with T.ScaleFactor

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_Plane_ParametricTransformation(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_Plane self)

        Returns the parametric bounds U1, U2, V1 and V2 of this plane.
        Because a plane is an infinite surface, the following is always true:
        - U1 = V1 =   Standard_Real::RealFirst()
        - U2 = V2 =   Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_Plane_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Handle_Geom_Plane self)

        Computes the normalized coefficients of the plane's
        cartesian equation : Ax + By + Cz + D = 0.0

        :type A: float
        :type B: float
        :type C: float
        :type D: float

        """
        return _Geom.Handle_Geom_Plane_Coefficients(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_Plane self) -> Standard_Boolean

        return False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_Plane self) -> Standard_Boolean

        return False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_Plane self) -> Standard_Boolean

        return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_Plane self) -> Standard_Boolean

        return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_Plane self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        This is a Line parallel to the YAxis of the plane.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Plane_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_Plane self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        This is a Line parallel to the XAxis of the plane.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Plane_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point P (U, V) on <me>.
        P = O + U * XDir + V * YDir.
        where O is the "Location" point of the plane, XDir the
        "XDirection" and YDir the "YDirection" of the plane's local
        coordinate system.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Plane_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Plane_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Plane_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the
        third derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Plane_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Plane_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Plane self, gp_Trsf T)

        Applies the transformation T to this plane.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Plane_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Plane self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Plane self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Plane_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Plane_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Plane self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Plane_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Plane self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Plane_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Plane self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_Plane_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Plane self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Plane_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Plane self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Plane_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_Plane_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Plane self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Plane_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_Plane self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_Plane self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsCNv(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_Plane self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_Plane_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_Plane self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_Plane_VReversed(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_Plane self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Plane_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_Plane self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Plane_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Plane self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Plane_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Plane self, gp_Pnt P)
        Mirror(Handle_Geom_Plane self, gp_Ax1 A1)
        Mirror(Handle_Geom_Plane self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Plane_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Plane self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Plane_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Plane self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Plane_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Plane self, gp_Vec V)
        Translate(Handle_Geom_Plane self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Plane_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Plane self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Plane self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Plane self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Plane self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Plane self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Plane self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Plane self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Plane self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Plane_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Plane self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Plane_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Plane_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Plane self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Plane_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Plane self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Plane_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Plane self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Plane_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Plane self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Plane_DecrementRefCounter(self, *args)

Handle_Geom_Plane_swigregister = _Geom.Handle_Geom_Plane_swigregister
Handle_Geom_Plane_swigregister(Handle_Geom_Plane)

def Handle_Geom_Plane_DownCast(thing):
    return _Geom.Handle_Geom_Plane_DownCast(thing)
Handle_Geom_Plane_DownCast = _Geom.Handle_Geom_Plane_DownCast

class Handle_Geom_Vector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Vector self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Vector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Vector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Vector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Vector self, Geom_Vector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Vector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Vector self, Handle_Geom_Vector theHandle) -> Handle_Geom_Vector
        assign(Handle_Geom_Vector self, Geom_Vector thePtr) -> Handle_Geom_Vector
        assign(Handle_Geom_Vector self, Handle_Geom_Vector theHandle) -> Handle_Geom_Vector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Vector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Vector self) -> Geom_Vector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Vector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Vector self) -> Geom_Vector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Vector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Vector self) -> Geom_Vector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Vector___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Vector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Vector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Vector_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Vector

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Vector self)

        Reverses the vector <me>.


        """
        return _Geom.Handle_Geom_Vector_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Vector self) -> Handle_Geom_Vector

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Vector_Reversed(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_Geom_Vector self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value between 0 and Pi.
        Exceptions
        gp_VectorWithNullMagnitude if:
        - the magnitude of this vector is less than or equal to
        gp::Resolution(), or
        - the magnitude of vector Other is less than or equal
        to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(Handle_Geom_Vector self, Handle_Geom_Vector Other, Handle_Geom_Vector VRef) -> Standard_Real

        Computes the angular value, in radians, between this
        vector and vector Other. The result is a value
        between -Pi and Pi. The vector VRef defines the
        positive sense of rotation: the angular value is positive
        if the cross product this ^ Other has the same
        orientation as VRef (in relation to the plane defined
        by this vector and vector Other). Otherwise, it is negative.
        Exceptions
        Standard_DomainError if this vector, vector Other
        and vector VRef are coplanar, except if this vector
        and vector Other are parallel.
        gp_VectorWithNullMagnitude if the magnitude of
        this vector, vector Other or vector VRef is less than
        or equal to gp::Resolution().

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :type VRef: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_AngleWithRef(self, *args)


    def Coord(self, *args):
        """
        Coord(Handle_Geom_Vector self)

        Returns the coordinates X, Y and Z of this vector.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _Geom.Handle_Geom_Vector_Coord(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(Handle_Geom_Vector self) -> Standard_Real

        Returns the  Magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(Handle_Geom_Vector self) -> Standard_Real

        Returns the square magnitude of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_SquareMagnitude(self, *args)


    def X(self, *args):
        """
        X(Handle_Geom_Vector self) -> Standard_Real

        Returns the X coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_X(self, *args)


    def Y(self, *args):
        """
        Y(Handle_Geom_Vector self) -> Standard_Real

        Returns the Y coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_Y(self, *args)


    def Z(self, *args):
        """
        Z(Handle_Geom_Vector self) -> Standard_Real

        Returns the Z coordinate of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_Z(self, *args)


    def Cross(self, *args):
        """
        Cross(Handle_Geom_Vector self, Handle_Geom_Vector Other)

        Computes the cross product between <me> and <Other>.

        Raised if <me> is a "Direction" and if <me> and <Other>
        are parallel because it is not possible to build a
        "Direction" with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Vector_Cross(self, *args)


    def Crossed(self, *args):
        """
        Crossed(Handle_Geom_Vector self, Handle_Geom_Vector Other) -> Handle_Geom_Vector

        Computes the cross product between <me> and <Other>.
        A new direction is returned.

        Raised if <me> is a "Direction" and if the two vectors
        are parallel because it is not possible to create a
        "Direction" with null length.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Vector_Crossed(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(Handle_Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2)

        Computes the triple vector product  <me> ^(V1 ^ V2).

        Raised if <me> is a "Direction" and if V1 and V2 are parallel
        or <me> and (V1 ^ V2) are  parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Vector_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(Handle_Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Handle_Geom_Vector

        Computes the triple vector product <me> ^(V1 ^ V2).

        Raised if <me> is a direction and if V1 and V2 are
        parallel or <me> and (V1 ^ V2) are parallel

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Geom.Handle_Geom_Vector

        """
        return _Geom.Handle_Geom_Vector_CrossCrossed(self, *args)


    def Dot(self, *args):
        """
        Dot(Handle_Geom_Vector self, Handle_Geom_Vector Other) -> Standard_Real

        Computes the scalar product of this vector and vector Other.

        :type Other: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_Dot(self, *args)


    def DotCross(self, *args):
        """
        DotCross(Handle_Geom_Vector self, Handle_Geom_Vector V1, Handle_Geom_Vector V2) -> Standard_Real

        Computes the triple scalar product. Returns me . (V1 ^ V2)

        :type V1: OCC.wrapper.Geom.Handle_Geom_Vector
        :type V2: OCC.wrapper.Geom.Handle_Geom_Vector
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Vector_DotCross(self, *args)


    def Vec(self, *args):
        """
        Converts this vector into a gp_Vec vector.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Geom.Handle_Geom_Vector_Vec(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Vector self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Vector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Vector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Vector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Vector self, gp_Pnt P)
        Mirror(Handle_Geom_Vector self, gp_Ax1 A1)
        Mirror(Handle_Geom_Vector self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Vector_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Vector self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Vector_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Vector self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Vector_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Vector self, gp_Vec V)
        Translate(Handle_Geom_Vector self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Vector_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Vector self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Vector_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Vector self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Vector self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Vector self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Vector self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Vector self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Vector self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Vector self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Vector self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Vector self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Vector_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Vector self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Vector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Vector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Vector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Vector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Vector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Vector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Vector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Vector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Vector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Vector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Vector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Vector self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Vector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Vector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Vector_DecrementRefCounter(self, *args)

Handle_Geom_Vector_swigregister = _Geom.Handle_Geom_Vector_swigregister
Handle_Geom_Vector_swigregister(Handle_Geom_Vector)

def Handle_Geom_Vector_DownCast(thing):
    return _Geom.Handle_Geom_Vector_DownCast(thing)
Handle_Geom_Vector_DownCast = _Geom.Handle_Geom_Vector_DownCast

class Handle_Geom_Geometry(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Geometry self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Geometry_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Geometry self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Geometry_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Geometry self, Geom_Geometry thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Geometry_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Geometry self, Handle_Geom_Geometry theHandle) -> Handle_Geom_Geometry
        assign(Handle_Geom_Geometry self, Geom_Geometry thePtr) -> Handle_Geom_Geometry
        assign(Handle_Geom_Geometry self, Handle_Geom_Geometry theHandle) -> Handle_Geom_Geometry

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Geometry_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Geometry self) -> Geom_Geometry

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Geometry_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Geometry self) -> Geom_Geometry

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Geometry___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Geometry self) -> Geom_Geometry

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Geometry___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Geometry___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Geometry___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Geometry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Geometry_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Geometry

    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Geometry self, gp_Pnt P)
        Mirror(Handle_Geom_Geometry self, gp_Ax1 A1)
        Mirror(Handle_Geom_Geometry self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Geometry_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Geometry self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Geometry_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Geometry self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Geometry_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Geometry self, gp_Vec V)
        Translate(Handle_Geom_Geometry self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Geometry_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Geometry self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Geometry_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Geometry self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Geometry self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Geometry self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Geometry self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Geometry self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Geometry self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Geometry self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Geometry self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Geometry self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Geometry_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Geometry self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Geometry_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Geometry_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Geometry_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Geom_Geometry self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Geometry_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Geometry_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Geometry self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Geometry self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Geometry_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Geometry self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Geometry_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Geometry self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Geometry_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Geometry self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Geometry_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Geometry self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Geometry_DecrementRefCounter(self, *args)

Handle_Geom_Geometry_swigregister = _Geom.Handle_Geom_Geometry_swigregister
Handle_Geom_Geometry_swigregister(Handle_Geom_Geometry)

def Handle_Geom_Geometry_DownCast(thing):
    return _Geom.Handle_Geom_Geometry_DownCast(thing)
Handle_Geom_Geometry_DownCast = _Geom.Handle_Geom_Geometry_DownCast

class Handle_Geom_BezierCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_BezierCurve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_BezierCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_BezierCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_BezierCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_BezierCurve self, Geom_BezierCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_BezierCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_BezierCurve self, Handle_Geom_BezierCurve theHandle) -> Handle_Geom_BezierCurve
        assign(Handle_Geom_BezierCurve self, Geom_BezierCurve thePtr) -> Handle_Geom_BezierCurve
        assign(Handle_Geom_BezierCurve self, Handle_Geom_BezierCurve theHandle) -> Handle_Geom_BezierCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_BezierCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_BezierCurve self) -> Geom_BezierCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_BezierCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_BezierCurve self) -> Geom_BezierCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_BezierCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_BezierCurve self) -> Geom_BezierCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_BezierCurve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_BezierCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_BezierCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_BezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_BezierCurve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_BezierCurve

    def Increase(self, *args):
        """
        Increase(Handle_Geom_BezierCurve self, Standard_Integer const Degree)

        Increases the degree of a bezier curve. Degree is the new
        degree of <me>. Raises ConstructionError
        if Degree is greater than MaxDegree or lower than 2
        or lower than the initial degree of <me>.

        :type Degree: int

        """
        return _Geom.Handle_Geom_BezierCurve_Increase(self, *args)


    def InsertPoleAfter(self, *args):
        """
        InsertPoleAfter(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        InsertPoleAfter(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Inserts a pole with its weight in the set of poles after the
        pole of range Index. If the curve was non rational it can
        become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.
        Raised if Weight is lower or equal to Resolution from package gp.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierCurve_InsertPoleAfter(self, *args)


    def InsertPoleBefore(self, *args):
        """
        InsertPoleBefore(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        InsertPoleBefore(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Inserts a pole with its weight in the set of poles after
        the pole of range Index. If the curve was non rational it
        can become rational if all the weights are not identical.
        Raised if Index is not in the range [1, NbPoles]

        Raised if the resulting number of poles is greater than
        MaxDegree + 1.
        Raised if Weight is lower or equal to Resolution from
        package gp.

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierCurve_InsertPoleBefore(self, *args)


    def RemovePole(self, *args):
        """
        RemovePole(Handle_Geom_BezierCurve self, Standard_Integer const Index)

        Removes the pole of range Index.
        If the curve was rational it can become non rational.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Degree is lower than 2.

        :type Index: int

        """
        return _Geom.Handle_Geom_BezierCurve_RemovePole(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_BezierCurve self)

        Reverses the direction of parametrization of <me>
        Value (NewU) =  Value (1 - OldU)


        """
        return _Geom.Handle_Geom_BezierCurve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_BezierCurve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns 1-U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Geom_BezierCurve self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2 which can be out
        of the bounds of the curve. The curve is oriented from U1
        to U2.
        The control points are modified, the first and the last point
        are not the same but the parametrization range is [0, 1]
        else it could not be a Bezier curve.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.

        :type U1: float
        :type U2: float

        """
        return _Geom.Handle_Geom_BezierCurve_Segment(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P)
        SetPole(Handle_Geom_BezierCurve self, Standard_Integer const Index, gp_Pnt P, Standard_Real const Weight)

        Substitutes the pole and the weights of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierCurve_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Geom_BezierCurve self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight of the pole of range Index.
        If the curve <me> is not rational it can become rational
        if all the weights are not identical.
        If the curve was rational it can become non rational if
        all the weights are identical.
        Raised if Index is not in the range [1, NbPoles]
        Raised if Weight <= Resolution from package gp

        :type Index: int
        :type Weight: float

        """
        return _Geom.Handle_Geom_BezierCurve_SetWeight(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_BezierCurve self) -> Standard_Boolean

        Returns True if the distance between the first point
        and the last point of the curve is lower or equal to
        the Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsClosed(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_BezierCurve self, Standard_Integer const N) -> Standard_Boolean

        Continuity of the curve, returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsCN(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_BezierCurve self) -> Standard_Boolean

        Returns True if the parametrization of a curve is periodic.
        (P(u) = P(u + T) T = constante)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Geom_BezierCurve self) -> Standard_Boolean

        Returns false if all the weights are identical. The tolerance
        criterion is Resolution from package gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_BezierCurve self) -> GeomAbs_Shape

        a Bezier curve is CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_BezierCurve_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Geom_BezierCurve self) -> Standard_Integer

        Returns the polynomial degree of the curve.
        it is the number of poles - 1
        point P and derivatives (V1, V2, V3) computation
        The Bezier Curve has a Polynomial representation so the
        parameter U can be out of the bounds of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierCurve_Degree(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_BezierCurve self, Standard_Real const U, gp_Pnt P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_BezierCurve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        For this Bezier curve, computes
        - the point P of parameter U, or
        - the point P and one or more of the following values:
        - V1, the first derivative vector,
        - V2, the second derivative vector,
        - V3, the third derivative vector.
        Note: the parameter U can be outside the bounds of the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_BezierCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        For the point of parameter U of this Bezier curve,
        computes the vector corresponding to the Nth derivative.
        Note: the parameter U can be outside the bounds of the curve.
        Exceptions Standard_RangeError if N is less than 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_BezierCurve_DN(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Geom_BezierCurve self) -> gp_Pnt

        Returns Value (U=0.), it is the first control point of the curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierCurve_StartPoint(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Geom_BezierCurve self) -> gp_Pnt

        Returns Value (U=1.), it is the last control point of the Bezier curve.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierCurve_EndPoint(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_BezierCurve self) -> Standard_Real

        Returns the value of the first  parameter of this
        Bezier curve. This is 0.0, which gives the start point of this Bezier curve

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_BezierCurve self) -> Standard_Real

        Returns the value of the last parameter of this
        Bezier curve. This is  1.0, which gives the end point of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_LastParameter(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Geom_BezierCurve self) -> Standard_Integer

        Returns the number of poles of this Bezier curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierCurve_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Returns the pole of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Geom.Handle_Geom_BezierCurve_Pole(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        Returns all the poles of the curve.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Geom.Handle_Geom_BezierCurve_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Weight(self, *args):
        """
        Weight(Handle_Geom_BezierCurve self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of range Index.
        Raised if Index is not in the range [1, NbPoles]

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Geom_BezierCurve self, NCollection_Array1_Standard_Real W)
        Weights(Handle_Geom_BezierCurve self) -> NCollection_Array1_Standard_Real

        Returns all the weights of the curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom.Handle_Geom_BezierCurve_Weights(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_BezierCurve self, gp_Trsf T)

        Applies the transformation T to this Bezier curve.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_BezierCurve_Transform(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Geom_BezierCurve self) -> Standard_Integer

        Returns the value of the maximum polynomial degree
        of any Geom_BezierCurve curve. This value is 25.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierCurve_MaxDegree(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Geom_BezierCurve self, Standard_Real const Tolerance3D)

        Computes for this Bezier curve the parametric
        tolerance UTolerance for a given 3D tolerance Tolerance3D.
        If f(t) is the equation of this Bezier curve,
        UTolerance ensures that:
        |t1-t0| < UTolerance ===> |f(t1)-f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Geom.Handle_Geom_BezierCurve_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_BezierCurve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this Bezier curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_BezierCurve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_BezierCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BezierCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_BezierCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_BezierCurve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_BezierCurve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_BezierCurve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_BezierCurve_Reversed(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_BezierCurve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_BezierCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_BezierCurve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierCurve_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_BezierCurve self, gp_Pnt P)
        Mirror(Handle_Geom_BezierCurve self, gp_Ax1 A1)
        Mirror(Handle_Geom_BezierCurve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_BezierCurve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_BezierCurve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_BezierCurve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_BezierCurve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_BezierCurve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_BezierCurve self, gp_Vec V)
        Translate(Handle_Geom_BezierCurve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_BezierCurve_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_BezierCurve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BezierCurve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_BezierCurve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_BezierCurve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_BezierCurve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_BezierCurve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_BezierCurve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_BezierCurve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_BezierCurve_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_BezierCurve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_BezierCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_BezierCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_BezierCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_BezierCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_BezierCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_BezierCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_BezierCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_BezierCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_BezierCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_BezierCurve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_BezierCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_BezierCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_BezierCurve_DecrementRefCounter(self, *args)

Handle_Geom_BezierCurve_swigregister = _Geom.Handle_Geom_BezierCurve_swigregister
Handle_Geom_BezierCurve_swigregister(Handle_Geom_BezierCurve)

def Handle_Geom_BezierCurve_DownCast(thing):
    return _Geom.Handle_Geom_BezierCurve_DownCast(thing)
Handle_Geom_BezierCurve_DownCast = _Geom.Handle_Geom_BezierCurve_DownCast

class Handle_Geom_Curve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Curve self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Curve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Curve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Curve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Curve self, Geom_Curve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Curve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Curve self, Handle_Geom_Curve theHandle) -> Handle_Geom_Curve
        assign(Handle_Geom_Curve self, Geom_Curve thePtr) -> Handle_Geom_Curve
        assign(Handle_Geom_Curve self, Handle_Geom_Curve theHandle) -> Handle_Geom_Curve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Curve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Curve self) -> Geom_Curve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Curve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Curve self) -> Geom_Curve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Curve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Curve self) -> Geom_Curve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Curve___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Curve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Curve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Curve_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Curve

    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Curve self)

        Changes the direction of parametrization of <me>.
        The "FirstParameter" and the "LastParameter" are not changed
        but the orientation  of the curve is modified. If the curve
        is bounded the StartPoint of the initial curve becomes the
        EndPoint of the reversed curve  and the EndPoint of the initial
        curve becomes the StartPoint of the reversed curve.


        """
        return _Geom.Handle_Geom_Curve_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Curve self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        me->Reversed()->Value(me->ReversedParameter(U))

        is the same point as

        me->Value(U)

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_ReversedParameter(self, *args)


    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Curve self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Curve self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Curve self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Curve_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Curve self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Curve self) -> Standard_Real

        Returns the value of the last parameter.
        Warnings :
        It can be RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Curve self) -> Standard_Boolean

        Returns true if the curve is closed.
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Curve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Curve self) -> Standard_Boolean

        Is the parametrization of the curve periodic ?
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Curve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Curve self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Curve_Period(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Curve self) -> GeomAbs_Shape

        It is the global continuity of the curve
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        G1 : tangency continuity all along the Curve,
        G2 : curvature continuity all along the Curve,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Curve_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Curve self, Standard_Integer const N) -> Standard_Boolean

        Returns true if the degree of continuity of this curve is at least N.
        Exceptions -  Standard_RangeError if N is less than 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Curve_IsCN(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Curve self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Curve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Curve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Curve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Curve self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Curve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Curve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the curve is not CN.

        Raised if the   derivative  cannot  be  computed
        easily. e.g. rational bspline and n > 3.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Curve_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Curve self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Curve_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Curve self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Curve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Curve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Curve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Curve self, gp_Pnt P)
        Mirror(Handle_Geom_Curve self, gp_Ax1 A1)
        Mirror(Handle_Geom_Curve self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Curve_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Curve self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Curve_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Curve self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Curve_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Curve self, gp_Vec V)
        Translate(Handle_Geom_Curve self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Curve_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Curve self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Curve_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Curve self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Curve self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Curve self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Curve self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Curve self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Curve self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Curve self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Curve self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Curve self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Curve_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Curve self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Curve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Curve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Curve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Curve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Curve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Curve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Curve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Curve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Curve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Curve self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Curve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Curve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Curve_DecrementRefCounter(self, *args)

Handle_Geom_Curve_swigregister = _Geom.Handle_Geom_Curve_swigregister
Handle_Geom_Curve_swigregister(Handle_Geom_Curve)

def Handle_Geom_Curve_DownCast(thing):
    return _Geom.Handle_Geom_Curve_DownCast(thing)
Handle_Geom_Curve_DownCast = _Geom.Handle_Geom_Curve_DownCast

class Handle_Geom_SurfaceOfLinearExtrusion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_SurfaceOfLinearExtrusion self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_SurfaceOfLinearExtrusion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_SurfaceOfLinearExtrusion self, Geom_SurfaceOfLinearExtrusion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_SurfaceOfLinearExtrusion self, Handle_Geom_SurfaceOfLinearExtrusion theHandle) -> Handle_Geom_SurfaceOfLinearExtrusion
        assign(Handle_Geom_SurfaceOfLinearExtrusion self, Geom_SurfaceOfLinearExtrusion thePtr) -> Handle_Geom_SurfaceOfLinearExtrusion
        assign(Handle_Geom_SurfaceOfLinearExtrusion self, Handle_Geom_SurfaceOfLinearExtrusion theHandle) -> Handle_Geom_SurfaceOfLinearExtrusion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_SurfaceOfLinearExtrusion self) -> Geom_SurfaceOfLinearExtrusion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_SurfaceOfLinearExtrusion self) -> Geom_SurfaceOfLinearExtrusion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_SurfaceOfLinearExtrusion self) -> Geom_SurfaceOfLinearExtrusion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_SurfaceOfLinearExtrusion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_SurfaceOfLinearExtrusion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_SurfaceOfLinearExtrusion_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_SurfaceOfLinearExtrusion

    def SetDirection(self, *args):
        """
        SetDirection(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Dir V)

        Assigns V as the "direction of extrusion" for this
        surface of linear extrusion.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_SetDirection(self, *args)


    def SetBasisCurve(self, *args):
        """
        SetBasisCurve(Handle_Geom_SurfaceOfLinearExtrusion self, Handle_Geom_Curve C)

        Modifies this surface of linear extrusion by redefining
        its "basis curve" (the "extruded curve").

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_SetBasisCurve(self, *args)


    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_SurfaceOfLinearExtrusion self)

        Changes the orientation of this surface of linear
        extrusion in the u  parametric direction. The
        bounds of the surface are not changed, but the given
        parametric direction is reversed. Hence the
        orientation of the surface is reversed.
        In the case of a surface of linear extrusion:
        - UReverse reverses the basis curve, and
        - VReverse reverses the direction of linear extrusion.


        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_UReverse(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, produced by reversing its u  parametric
        direction, for any point of u parameter U  on this surface of linear extrusion.
        In the case of an extruded surface:
        - UReverseParameter returns the reversed
        parameter given by the function
        ReversedParameter called with U on the basis   curve,

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_UReversedParameter(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_SurfaceOfLinearExtrusion self)

        Changes the orientation of this surface of linear
        extrusion in the v parametric direction. The
        bounds of the surface are not changed, but the given
        parametric direction is reversed. Hence the
        orientation of the surface is reversed.
        In the case of a surface of linear extrusion:
        - UReverse reverses the basis curve, and
        - VReverse reverses the direction of linear extrusion.


        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_VReverse(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, produced by reversing its u v parametric
        direction, for any point of v parameter V on this surface of linear extrusion.
        In the case of an extruded surface VReverse returns -V.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_VReversedParameter(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_SurfaceOfLinearExtrusion self)

        Returns the parametric bounds U1, U2, V1 and V2 of
        this surface of linear extrusion.
        A surface of linear extrusion is infinite in the v
        parametric direction, so:
        - V1 = Standard_Real::RealFirst()
        - V2 = Standard_Real::RealLast().

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Bounds(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsUClosed returns true if the "basis curve" of this
        surface of linear extrusion is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsVClosed always returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsVClosed(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Integer const N) -> Standard_Boolean

        IsCNu returns true if the degree of continuity for the
        "basis curve" of this surface of linear extrusion is at least N.
        Raises RangeError if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Integer const N) -> Standard_Boolean

        IsCNv always returns true.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsCNv(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsUPeriodic returns true if the "basis curve" of this
        surface of linear extrusion is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Boolean

        IsVPeriodic always returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve of this surface
        of linear extrusion. This is the line parallel to the
        direction of extrusion, passing through the point of
        parameter U of the basis curve.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve of this surface
        of linear extrusion. This curve is obtained by
        translating the extruded curve in the direction of
        extrusion, with the magnitude V.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        The parameter U is the parameter on the extruded curve.
        The parametrization V is a linear parametrization, and
        the direction of parametrization is the direction of
        extrusion. If the point is on the extruded curve, V = 0.0

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C1.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        --- Purpose ;
        Computes the current point, the first and the second derivatives
        in the directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C2.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.
        Raises UndefinedDerivative if the continuity of the surface is not C3.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raises UndefinedDerivative if the continuity of the surface is not CNu in the u
        direction and CNv in the v direction.
        Raises RangeError if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Trsf T)

        Applies the transformation T to this surface of linear extrusion.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Transform(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods multiplies :
        U by BasisCurve()->ParametricTransformation(T)
        V by T.ScaleFactor()

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This  methods  returns  a scale
        U by BasisCurve()->ParametricTransformation(T)
        V by T.ScaleFactor()

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_ParametricTransformation(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_SurfaceOfLinearExtrusion self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this surface of linear extrusion.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_SurfaceOfLinearExtrusion self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_SurfaceOfLinearExtrusion self) -> GeomAbs_Shape

        returns the continuity of the surface :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the surface,
        C2 : continuity of the second derivative all along the surface,
        C3 : continuity of the third derivative all along the surface,
        G1 : tangency continuity all along the surface,
        G2 : curvature continuity all along the surface,
        CN : the order of continuity is infinite.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Continuity(self, *args)


    def Direction(self, *args):
        """
        Returns the reference direction of the swept surface.
        For a surface of revolution it is the direction of the
        revolution axis, for a surface of linear extrusion it is
        the direction of extrusion.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisCurve(self, *args):
        """
        BasisCurve(Handle_Geom_SurfaceOfLinearExtrusion self) -> Handle_Geom_Curve

        Returns the referenced curve of the surface.
        For a surface of revolution it is the revolution curve,
        for a surface of linear extrusion it is the extruded curve.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_BasisCurve(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_SurfaceOfLinearExtrusion self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_SurfaceOfLinearExtrusion self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_VReversed(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P)
        Mirror(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax1 A1)
        Mirror(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Vec V)
        Translate(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_SurfaceOfLinearExtrusion self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_SurfaceOfLinearExtrusion self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_SurfaceOfLinearExtrusion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_SurfaceOfLinearExtrusion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_SurfaceOfLinearExtrusion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_SurfaceOfLinearExtrusion self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_SurfaceOfLinearExtrusion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DecrementRefCounter(self, *args)

Handle_Geom_SurfaceOfLinearExtrusion_swigregister = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_swigregister
Handle_Geom_SurfaceOfLinearExtrusion_swigregister(Handle_Geom_SurfaceOfLinearExtrusion)

def Handle_Geom_SurfaceOfLinearExtrusion_DownCast(thing):
    return _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DownCast(thing)
Handle_Geom_SurfaceOfLinearExtrusion_DownCast = _Geom.Handle_Geom_SurfaceOfLinearExtrusion_DownCast

class Handle_Geom_Conic(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_Conic self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_Conic_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_Conic self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_Conic_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_Conic self, Geom_Conic thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_Conic_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_Conic self, Handle_Geom_Conic theHandle) -> Handle_Geom_Conic
        assign(Handle_Geom_Conic self, Geom_Conic thePtr) -> Handle_Geom_Conic
        assign(Handle_Geom_Conic self, Handle_Geom_Conic theHandle) -> Handle_Geom_Conic

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_Conic_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_Conic self) -> Geom_Conic

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_Conic_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_Conic self) -> Geom_Conic

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_Conic___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_Conic self) -> Geom_Conic

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_Conic___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_Conic___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_Conic___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_Conic(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_Conic_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_Conic

    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_Conic self, gp_Ax1 A1)

        Changes the orientation of the conic's plane. The normal
        axis to the plane is A1. The XAxis and the YAxis are recomputed.

        raised if the A1 is parallel to the XAxis of the conic.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Conic_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_Conic self, gp_Pnt P)

        changes the location point of the conic.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Conic_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_Conic self, gp_Ax2 A2)

        changes the local coordinate system of the conic.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Conic_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_Conic self) -> gp_Ax1

        Returns the "main Axis" of this conic. This axis is
        normal to the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Conic_Axis(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(Handle_Geom_Conic self) -> Standard_Real

        Returns the eccentricity value of the conic e.
        e = 0 for a circle
        0 < e < 1 for an ellipse  (e = 0 if MajorRadius = MinorRadius)
        e > 1 for a hyperbola
        e = 1 for a parabola
        Exceptions
        Standard_DomainError in the case of a hyperbola if
        its major radius is null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_Eccentricity(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_Conic self) -> gp_Pnt

        Returns the location point of the conic.
        For the circle, the ellipse and the hyperbola it is the center of
        the conic. For the parabola it is the Apex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Conic_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the conic.
        The main direction of the Axis2Placement is normal to the
        plane of the conic. The X direction of the Axis2placement
        is in the plane of the conic and corresponds to the origin
        for the conic's parametric value u.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _Geom.Handle_Geom_Conic_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(Handle_Geom_Conic self) -> gp_Ax1

        Returns the XAxis of the conic.
        This axis defines the origin of parametrization of the conic.
        This axis is perpendicular to the Axis of the conic.
        This axis and the Yaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Conic_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_Geom_Conic self) -> gp_Ax1

        Returns the YAxis of the conic.
        The YAxis is perpendicular to the Xaxis.
        This axis and the Xaxis define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_Conic_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Geom_Conic self)

        Reverses the direction of parameterization of <me>.
        The local coordinate system of the conic is modified.


        """
        return _Geom.Handle_Geom_Conic_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Geom_Conic self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_ReversedParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_Conic self) -> GeomAbs_Shape

        The continuity of the conic is Cn.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_Conic_Continuity(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Geom_Conic self, Standard_Integer const N) -> Standard_Boolean

        Returns True.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Conic_IsCN(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_Conic self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_Conic_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Conic_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_Conic_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransformedParameter(self, *args):
        """
        TransformedParameter(Handle_Geom_Conic self, Standard_Real const U, gp_Trsf T) -> Standard_Real

        Returns the  parameter on the  transformed  curve for
        the transform of the point of parameter U on <me>.

        me->Transformed(T)->Value(me->TransformedParameter(U,T))

        is the same point as

        me->Value(U).Transformed(T)

        This methods returns <U>

        It can be redefined. For example on the Line.

        :type U: float
        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_TransformedParameter(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_Conic self, gp_Trsf T) -> Standard_Real

        Returns a  coefficient to compute the parameter on
        the transformed  curve  for  the transform  of the
        point on <me>.

        Transformed(T)->Value(U * ParametricTransformation(T))

        is the same point as

        Value(U).Transformed(T)

        This methods returns 1.

        It can be redefined. For example on the Line.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_ParametricTransformation(self, *args)


    def Reversed(self, *args):
        """
        Reversed(Handle_Geom_Conic self) -> Handle_Geom_Curve

        Returns a copy of <me> reversed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_Conic_Reversed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Geom_Conic self) -> Standard_Real

        Returns the value of the first parameter.
        Warnings :
        It can be RealFirst from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Geom_Conic self) -> Standard_Real

        Returns the value of the last parameter.
        Warnings :
        It can be RealLast from package Standard
        if the curve is infinite

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_LastParameter(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Geom_Conic self) -> Standard_Boolean

        Returns true if the curve is closed.
        Some curves such as circle are always closed, others such as line
        are never closed (by definition).
        Some Curves such as OffsetCurve can be closed or not. These curves
        are considered as closed if the distance between the first point
        and the last point of the curve is lower or equal to the Resolution
        from package gp wich is a fixed criterion independant of the
        application.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Conic_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Geom_Conic self) -> Standard_Boolean

        Is the parametrization of the curve periodic ?
        It is possible only if the curve is closed and if the
        following relation is satisfied :
        for each parametric value U the distance between the point
        P(u) and the point P (u + T) is lower or equal to Resolution
        from package gp, T is the period and must be a constant.
        There are three possibilities :
        . the curve is never periodic by definition (SegmentLine)
        . the curve is always periodic by definition (Circle)
        . the curve can be defined as periodic (BSpline). In this case
        a function SetPeriodic allows you to give the shape of the
        curve.  The general rule for this case is : if a curve can be
        periodic or not the default periodicity set is non periodic
        and you have to turn (explicitly) the curve into a periodic
        curve  if you want the curve to be periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Conic_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Geom_Conic self) -> Standard_Real

        Returns the period of this curve.
        Exceptions Standard_NoSuchObject if this curve is not periodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_Conic_Period(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_Conic self, Standard_Real const U, gp_Pnt P)

        Returns in P the point of parameter U.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction
        are parallel.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Conic_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_Conic self, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point P of parameter U and the first derivative V1.
        Raised if the continuity of the curve is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Conic_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_Conic self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the curve is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Conic_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_Conic self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the curve is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Conic_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_Conic self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the curve is not CN.

        Raised if the   derivative  cannot  be  computed
        easily. e.g. rational bspline and n > 3.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_Conic_DN(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_Conic self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on <me>.
        If the curve is periodic  then the returned point is P(U) with
        U = Ustart + (U - Uend)  where Ustart and Uend are the
        parametric bounds of the curve.
        it is implemented with D0.

        Raised only for the "OffsetCurve" if it is not possible to
        compute the current point. For example when the first
        derivative on the basis curve and the offset direction are parallel.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Conic_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_Conic self, gp_Pnt P)
        Mirror(Handle_Geom_Conic self, gp_Ax1 A1)
        Mirror(Handle_Geom_Conic self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_Conic_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_Conic self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_Conic_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_Conic self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_Conic_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_Conic self, gp_Vec V)
        Translate(Handle_Geom_Conic self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_Conic_Translate(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_Conic self, gp_Trsf T)

        Transformation of a geometric object. This tansformation
        can be a translation, a rotation, a symmetry, a scaling
        or a complex transformation obtained by combination of
        the previous elementaries transformations.
        (see class Transformation of the package Geom).

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_Conic_Transform(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_Conic self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Conic self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_Conic self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_Conic self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_Conic self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_Conic self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_Conic self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_Conic self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Translated(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_Conic self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this geometric object.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_Conic_Copy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_Conic self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_Conic_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_Conic self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_Conic self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Conic_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_Conic self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_Conic self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_Conic_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_Conic self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_Conic_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_Conic self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Conic_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_Conic self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_Conic_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_Conic self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_Conic_DecrementRefCounter(self, *args)

Handle_Geom_Conic_swigregister = _Geom.Handle_Geom_Conic_swigregister
Handle_Geom_Conic_swigregister(Handle_Geom_Conic)

def Handle_Geom_Conic_DownCast(thing):
    return _Geom.Handle_Geom_Conic_DownCast(thing)
Handle_Geom_Conic_DownCast = _Geom.Handle_Geom_Conic_DownCast

class Handle_Geom_SphericalSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Geom_SphericalSurface self)

        Nullify the handle


        """
        return _Geom.Handle_Geom_SphericalSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Geom_SphericalSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Geom.Handle_Geom_SphericalSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Geom_SphericalSurface self, Geom_SphericalSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Geom.Handle_Geom_SphericalSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Geom_SphericalSurface self, Handle_Geom_SphericalSurface theHandle) -> Handle_Geom_SphericalSurface
        assign(Handle_Geom_SphericalSurface self, Geom_SphericalSurface thePtr) -> Handle_Geom_SphericalSurface
        assign(Handle_Geom_SphericalSurface self, Handle_Geom_SphericalSurface theHandle) -> Handle_Geom_SphericalSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Geom.Handle_Geom_SphericalSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Geom_SphericalSurface self) -> Geom_SphericalSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Geom.Handle_Geom_SphericalSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Geom_SphericalSurface self) -> Geom_SphericalSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Geom.Handle_Geom_SphericalSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Geom_SphericalSurface self) -> Geom_SphericalSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Geom.Handle_Geom_SphericalSurface___ref__(self, *args)


    def __hash__(self):
        return _Geom.Handle_Geom_SphericalSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Geom.Handle_Geom_SphericalSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Geom.new_Handle_Geom_SphericalSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Geom.Handle_Geom_SphericalSurface_DownCast)
    __swig_destroy__ = _Geom.delete_Handle_Geom_SphericalSurface

    def SetRadius(self, *args):
        """
        SetRadius(Handle_Geom_SphericalSurface self, Standard_Real const R)

        Assigns the value R to the radius of this sphere.
        Exceptions Standard_ConstructionError if R is less than 0.0.

        :type R: float

        """
        return _Geom.Handle_Geom_SphericalSurface_SetRadius(self, *args)


    def SetSphere(self, *args):
        """
        SetSphere(Handle_Geom_SphericalSurface self, gp_Sphere S)

        Converts the gp_Sphere S into this sphere.

        :type S: OCC.wrapper.gp.gp_Sphere

        """
        return _Geom.Handle_Geom_SphericalSurface_SetSphere(self, *args)


    def Sphere(self, *args):
        """
        Sphere(Handle_Geom_SphericalSurface self) -> gp_Sphere

        Returns a non persistent sphere with the same geometric
        properties as <me>.

        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _Geom.Handle_Geom_SphericalSurface_Sphere(self, *args)


    def UReversedParameter(self, *args):
        """
        UReversedParameter(Handle_Geom_SphericalSurface self, Standard_Real const U) -> Standard_Real

        Computes the u parameter on the modified
        surface, when reversing its u  parametric
        direction, for any point of u parameter U on this sphere.
        In the case of a sphere, these functions returns 2.PI - U.

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_UReversedParameter(self, *args)


    def VReversedParameter(self, *args):
        """
        VReversedParameter(Handle_Geom_SphericalSurface self, Standard_Real const V) -> Standard_Real

        Computes the v parameter on the modified
        surface, when reversing its v parametric
        direction, for any point of v parameter V on this sphere.
        In the case of a sphere, these functions returns   -U.

        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_VReversedParameter(self, *args)


    def Area(self, *args):
        """
        Area(Handle_Geom_SphericalSurface self) -> Standard_Real

        Computes the aera of the spherical surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_Area(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Geom_SphericalSurface self)

        Returns the parametric bounds U1, U2, V1 and V2 of this sphere.
        For a sphere: U1 = 0, U2 = 2*PI, V1 = -PI/2, V2 = PI/2.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _Geom.Handle_Geom_SphericalSurface_Bounds(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(Handle_Geom_SphericalSurface self)

        Returns the coefficients of the implicit equation of the
        quadric in the absolute cartesian coordinates system :
        These coefficients are normalized.
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _Geom.Handle_Geom_SphericalSurface_Coefficients(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_Geom_SphericalSurface self) -> Standard_Real

        Computes the coefficients of the implicit equation of
        this quadric in the absolute Cartesian coordinate system:
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0
        An implicit normalization is applied (i.e. A1 = A2 = 1.
        in the local coordinate system of this sphere).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_Radius(self, *args)


    def Volume(self, *args):
        """
        Volume(Handle_Geom_SphericalSurface self) -> Standard_Real

        Computes the volume of the spherical surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_Volume(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_Geom_SphericalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_Geom_SphericalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsVClosed(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_Geom_SphericalSurface self) -> Standard_Boolean

        Returns True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_Geom_SphericalSurface self) -> Standard_Boolean

        Returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsVPeriodic(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_Geom_SphericalSurface self, Standard_Real const U) -> Handle_Geom_Curve

        Computes the U isoparametric curve.
        The U isoparametric curves of the surface are defined by the
        section of the spherical surface with plane obtained by rotation
        of the plane (Location, XAxis, ZAxis) around ZAxis. This plane
        defines the origin of parametrization u.
        For a SphericalSurface the UIso curve is a Circle.
        Warnings : The radius of this circle can be zero.

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SphericalSurface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_Geom_SphericalSurface self, Standard_Real const V) -> Handle_Geom_Curve

        Computes the V isoparametric curve.
        The V isoparametric curves of the surface  are defined by
        the section of the spherical surface with plane parallel to the
        plane (Location, XAxis, YAxis). This plane defines the origin of
        parametrization V.
        Be careful if  V is close to PI/2 or 3*PI/2 the radius of the
        circle becomes tiny. It is not forbidden in this toolkit to
        create circle with radius = 0.0
        For a SphericalSurface the VIso curve is a Circle.
        Warnings : The radius of this circle can be zero.

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _Geom.Handle_Geom_SphericalSurface_VIso(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the  point P (U, V) on the surface.
        P (U, V) = Loc + Radius * Sin (V) * Zdir +
        Radius * Cos (V) * (cos (U) * XDir + sin (U) * YDir)
        where Loc is the origin of the placement plane (XAxis, YAxis)
        XDir is the direction of the XAxis and YDir the direction of
        the YAxis and ZDir the direction of the ZAxis.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SphericalSurface_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the current point and the first derivatives in the
        directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SphericalSurface_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV)

        Computes the current point, the first and the second derivatives
        in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SphericalSurface_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec D2UV, gp_Vec D3U, gp_Vec D3V, gp_Vec D3UUV, gp_Vec D3UVV)

        Computes the current point, the first,the second and the third
        derivatives in the directions U and V.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type D2UV: OCC.wrapper.gp.gp_Vec
        :type D3U: OCC.wrapper.gp.gp_Vec
        :type D3V: OCC.wrapper.gp.gp_Vec
        :type D3UUV: OCC.wrapper.gp.gp_Vec
        :type D3UVV: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SphericalSurface_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        Computes the derivative of order Nu in the direction u
        and Nv in the direction v.
        Raised if Nu + Nv < 1 or Nu < 0 or Nv < 0.

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _Geom.Handle_Geom_SphericalSurface_DN(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_Geom_SphericalSurface self, gp_Trsf T)

        Applies the transformation T to this sphere.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SphericalSurface_Transform(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Geom_SphericalSurface self) -> Handle_Geom_Geometry

        Creates a new object which is a copy of this sphere.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Geom_SphericalSurface self) -> char const *

        :rtype: const char *

        """
        return _Geom.Handle_Geom_SphericalSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SphericalSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Geom.Handle_Geom_SphericalSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_Geom_SphericalSurface self, gp_Ax1 A1)

        Changes the main axis (ZAxis) of the elementary surface.

        Raised if the direction of A1 is parallel to the XAxis of the
        coordinate system of the surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_SphericalSurface_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_Geom_SphericalSurface self, gp_Pnt Loc)

        Changes the location of the local coordinates system of the
        surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SphericalSurface_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_Geom_SphericalSurface self, gp_Ax3 A3)

        Changes the local coordinates system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _Geom.Handle_Geom_SphericalSurface_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_Geom_SphericalSurface self) -> gp_Ax1

        Returns the main axis of the surface (ZAxis).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _Geom.Handle_Geom_SphericalSurface_Axis(self, *args)


    def Location(self, *args):
        """
        Location(Handle_Geom_SphericalSurface self) -> gp_Pnt

        Returns the location point of the local coordinate system of the
        surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SphericalSurface_Location(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinates system of the surface.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _Geom.Handle_Geom_SphericalSurface_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UReverse(self, *args):
        """
        UReverse(Handle_Geom_SphericalSurface self)

        Reverses the U parametric direction of the surface.


        """
        return _Geom.Handle_Geom_SphericalSurface_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(Handle_Geom_SphericalSurface self)

        Reverses the V parametric direction of the surface.


        """
        return _Geom.Handle_Geom_SphericalSurface_VReverse(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Geom_SphericalSurface self) -> GeomAbs_Shape

        Returns GeomAbs_CN, the global continuity of any elementary surface.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Geom.Handle_Geom_SphericalSurface_Continuity(self, *args)


    def IsCNu(self, *args):
        """
        IsCNu(Handle_Geom_SphericalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsCNu(self, *args)


    def IsCNv(self, *args):
        """
        IsCNv(Handle_Geom_SphericalSurface self, Standard_Integer const N) -> Standard_Boolean

        Returns True.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsCNv(self, *args)


    def UReversed(self, *args):
        """
        UReversed(Handle_Geom_SphericalSurface self) -> Handle_Geom_Surface

        Reverses the U direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SphericalSurface_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(Handle_Geom_SphericalSurface self) -> Handle_Geom_Surface

        Reverses the V direction of parametrization of <me>.
        The bounds of the surface are not modified.
        A copy of <me> is returned.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _Geom.Handle_Geom_SphericalSurface_VReversed(self, *args)


    def TransformParameters(self, *args):
        """
        TransformParameters(Handle_Geom_SphericalSurface self, gp_Trsf T)

        Computes the  parameters on the  transformed  surface for
        the transform of the point of parameters U,V on <me>.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are the new values of U,V after calling

        me->TranformParameters(U,V,T)

        This methods does not change <U> and <V>

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _Geom.Handle_Geom_SphericalSurface_TransformParameters(self, *args)


    def ParametricTransformation(self, *args):
        """
        ParametricTransformation(Handle_Geom_SphericalSurface self, gp_Trsf T) -> gp_GTrsf2d

        Returns a 2d transformation  used to find the  new
        parameters of a point on the transformed surface.

        me->Transformed(T)->Value(U',V')

        is the same point as

        me->Value(U,V).Transformed(T)

        Where U',V' are  obtained by transforming U,V with
        th 2d transformation returned by

        me->ParametricTransformation(T)

        This methods returns an identity transformation

        It  can be redefined.  For  example on  the Plane,
        Cylinder, Cone, Revolved and Extruded surfaces.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _Geom.Handle_Geom_SphericalSurface_ParametricTransformation(self, *args)


    def UPeriod(self, *args):
        """
        UPeriod(Handle_Geom_SphericalSurface self) -> Standard_Real

        Returns the period of this surface in the u
        parametric direction.
        raises if the surface is not uperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_UPeriod(self, *args)


    def VPeriod(self, *args):
        """
        VPeriod(Handle_Geom_SphericalSurface self) -> Standard_Real

        Returns the period of this surface in the v parametric direction.
        raises if the surface is not vperiodic.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom.Handle_Geom_SphericalSurface_VPeriod(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Geom_SphericalSurface self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes the point of parameter U on the surface.

        It is implemented with D0

        Raised only for an "OffsetSurface" if it is not possible to
        compute the current point.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SphericalSurface_Value(self, *args)


    def Mirror(self, *args):
        """
        Mirror(Handle_Geom_SphericalSurface self, gp_Pnt P)
        Mirror(Handle_Geom_SphericalSurface self, gp_Ax1 A1)
        Mirror(Handle_Geom_SphericalSurface self, gp_Ax2 A2)

        Performs the symmetrical transformation of a Geometry
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _Geom.Handle_Geom_SphericalSurface_Mirror(self, *args)


    def Rotate(self, *args):
        """
        Rotate(Handle_Geom_SphericalSurface self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates a Geometry. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _Geom.Handle_Geom_SphericalSurface_Rotate(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_Geom_SphericalSurface self, gp_Pnt P, Standard_Real const S)

        Scales a Geometry. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _Geom.Handle_Geom_SphericalSurface_Scale(self, *args)


    def Translate(self, *args):
        """
        Translate(Handle_Geom_SphericalSurface self, gp_Vec V)
        Translate(Handle_Geom_SphericalSurface self, gp_Pnt P1, gp_Pnt P2)

        Translates a Geometry from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _Geom.Handle_Geom_SphericalSurface_Translate(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(Handle_Geom_SphericalSurface self, gp_Pnt P) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SphericalSurface self, gp_Ax1 A1) -> Handle_Geom_Geometry
        Mirrored(Handle_Geom_SphericalSurface self, gp_Ax2 A2) -> Handle_Geom_Geometry

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Mirrored(self, *args)


    def Rotated(self, *args):
        """
        Rotated(Handle_Geom_SphericalSurface self, gp_Ax1 A1, Standard_Real const Ang) -> Handle_Geom_Geometry

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Rotated(self, *args)


    def Scaled(self, *args):
        """
        Scaled(Handle_Geom_SphericalSurface self, gp_Pnt P, Standard_Real const S) -> Handle_Geom_Geometry

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Scaled(self, *args)


    def Transformed(self, *args):
        """
        Transformed(Handle_Geom_SphericalSurface self, gp_Trsf T) -> Handle_Geom_Geometry

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Transformed(self, *args)


    def Translated(self, *args):
        """
        Translated(Handle_Geom_SphericalSurface self, gp_Vec V) -> Handle_Geom_Geometry
        Translated(Handle_Geom_SphericalSurface self, gp_Pnt P1, gp_Pnt P2) -> Handle_Geom_Geometry

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        return _Geom.Handle_Geom_SphericalSurface_Translated(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Geom_SphericalSurface self)

        Memory deallocator for transient classes


        """
        return _Geom.Handle_Geom_SphericalSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Geom_SphericalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Geom_SphericalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Geom_SphericalSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Geom_SphericalSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom.Handle_Geom_SphericalSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Geom_SphericalSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Geom.Handle_Geom_SphericalSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Geom_SphericalSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SphericalSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Geom_SphericalSurface self)

        Increments the reference counter of this object


        """
        return _Geom.Handle_Geom_SphericalSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Geom_SphericalSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom.Handle_Geom_SphericalSurface_DecrementRefCounter(self, *args)

Handle_Geom_SphericalSurface_swigregister = _Geom.Handle_Geom_SphericalSurface_swigregister
Handle_Geom_SphericalSurface_swigregister(Handle_Geom_SphericalSurface)

def Handle_Geom_SphericalSurface_DownCast(thing):
    return _Geom.Handle_Geom_SphericalSurface_DownCast(thing)
Handle_Geom_SphericalSurface_DownCast = _Geom.Handle_Geom_SphericalSurface_DownCast




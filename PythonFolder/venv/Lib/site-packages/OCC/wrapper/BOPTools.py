# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BOPTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BOPTools')
    _BOPTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPTools', [dirname(__file__)])
        except ImportError:
            import _BOPTools
            return _BOPTools
        try:
            _mod = imp.load_module('_BOPTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BOPTools = swig_import_helper()
    del swig_import_helper
else:
    import _BOPTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPTools.delete_SwigPyIterator

    def value(self):
        return _BOPTools.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BOPTools.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BOPTools.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BOPTools.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BOPTools.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BOPTools.SwigPyIterator_copy(self)

    def next(self):
        return _BOPTools.SwigPyIterator_next(self)

    def __next__(self):
        return _BOPTools.SwigPyIterator___next__(self)

    def previous(self):
        return _BOPTools.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BOPTools.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BOPTools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BOPTools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BOPTools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BOPTools.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BOPTools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BOPTools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BOPTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPTools.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BOPTools.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPTools.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPTools.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BOPTools.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BOPTools.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BOPTools.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BOPTools.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BOPTools.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BOPTools.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BOPTools.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BOPTools.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BOPTools.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BOPTools.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BOPTools.ptr_to_number(item)
ptr_to_number = _BOPTools.ptr_to_number

def HashCode(*args):
    return _BOPTools.HashCode(*args)
HashCode = _BOPTools.HashCode

def ptr_equal(a, b):
    return _BOPTools.ptr_equal(a, b)
ptr_equal = _BOPTools.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
class BOPTools_ConnexityBlock(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPTools_ConnexityBlock self) -> BOPTools_ConnexityBlock
        __init__(BOPTools_ConnexityBlock self, Handle_NCollection_BaseAllocator theAllocator) -> BOPTools_ConnexityBlock

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPTools.new_BOPTools_ConnexityBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Shapes(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPTools.BOPTools_ConnexityBlock_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShapes(self, *args):
        """
        ChangeShapes(BOPTools_ConnexityBlock self) -> NCollection_List_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeShapes(self, *args)


    def SetRegular(self, *args):
        """
        SetRegular(BOPTools_ConnexityBlock self, Standard_Boolean const theFlag)

        :type theFlag: bool

        """
        return _BOPTools.BOPTools_ConnexityBlock_SetRegular(self, *args)


    def IsRegular(self, *args):
        """
        IsRegular(BOPTools_ConnexityBlock self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_ConnexityBlock_IsRegular(self, *args)


    def Loops(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BOPTools.BOPTools_ConnexityBlock_Loops(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLoops(self, *args):
        """
        ChangeLoops(BOPTools_ConnexityBlock self) -> NCollection_List_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeLoops(self, *args)

    __swig_destroy__ = _BOPTools.delete_BOPTools_ConnexityBlock
BOPTools_ConnexityBlock_swigregister = _BOPTools.BOPTools_ConnexityBlock_swigregister
BOPTools_ConnexityBlock_swigregister(BOPTools_ConnexityBlock)

class BOPTools_AlgoTools3D(object):
    """
    The class contains handy static functions
    dealing with the topology
    This is the copy of BOPTools_AlgoTools3D.cdl file
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DoSplitSEAMOnFace(*args):
        """
        DoSplitSEAMOnFace(TopoDS_Edge aSp, TopoDS_Face aF)

        Make the edge <aSp> seam edge for the face <aF>

        :type aSp: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

    DoSplitSEAMOnFace = staticmethod(DoSplitSEAMOnFace)

    def GetNormalToFaceOnEdge(*args):
        """
        GetNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Dir aD, Handle_IntTools_Context theContext)
        GetNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, gp_Dir aD, Handle_IntTools_Context theContext)

        Computes normal to the face <aF> for the point on the edge <aE>
        at arbitrary intermediate parameter.<br>
        <theContext> - storage for caching the geometrical tools

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aD: OCC.wrapper.gp.gp_Dir
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

    GetNormalToFaceOnEdge = staticmethod(GetNormalToFaceOnEdge)

    def SenseFlag(*args):
        """
        SenseFlag(gp_Dir aNF1, gp_Dir aNF2) -> Standard_Integer

        Returns 1  if scalar product aNF1* aNF2>0.<br>
        Returns 0  if directions aNF1 aNF2 coincide<br>
        Returns -1 if scalar product aNF1* aNF2<0.

        :type aNF1: OCC.wrapper.gp.gp_Dir
        :type aNF2: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

    SenseFlag = staticmethod(SenseFlag)

    def GetNormalToSurface(*args):
        """
        GetNormalToSurface(Handle_Geom_Surface aS, Standard_Real const U, Standard_Real const V, gp_Dir aD) -> Standard_Boolean

        Compute normal <aD> to surface <aS> in point (U,V)
        Returns TRUE if directions aD1U, aD1V coincide

        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type U: float
        :type V: float
        :type aD: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

    GetNormalToSurface = staticmethod(GetNormalToSurface)

    def GetApproxNormalToFaceOnEdge(*args):
        """
        GetApproxNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Pnt aPx, gp_Dir aD, Handle_IntTools_Context theContext) -> Standard_Boolean
        GetApproxNormalToFaceOnEdge(TopoDS_Edge theE, TopoDS_Face theF, Standard_Real const aT, gp_Pnt aP, gp_Dir aDNF, Standard_Real const aDt2D) -> Standard_Boolean
        GetApproxNormalToFaceOnEdge(TopoDS_Edge theE, TopoDS_Face theF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt aP, gp_Dir aDNF, Handle_IntTools_Context theContext) -> Standard_Boolean

        Computes normal to the face <aF> for the 3D-point that
        belongs to the edge <aE> at parameter <aT>.<br>
        Output:<br>
        aPx  -  the 3D-point where the normal computed<br>
        aD   -  the normal;<br>
        Warning:<br>
        The normal is computed not exactly in the point on the
        edge, but in point that is near to the edge towards to
        the face material (so, we'll have approx. normal);<br>
        The point is computed using PointNearEdge function
        with the shifting value <aDt2D> from the edge,
        but if this value is too big the point will be 
        computed using Hatcher (PointInFace function).<br>
        Returns TRUE in case of success.

        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aT: float
        :type aDt2D: float
        :type aP: OCC.wrapper.gp.gp_Pnt
        :type aDNF: OCC.wrapper.gp.gp_Dir
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

    GetApproxNormalToFaceOnEdge = staticmethod(GetApproxNormalToFaceOnEdge)

    def PointNearEdge(*args):
        """
        PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer
        PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt2d aP2D, gp_Pnt aPx) -> Standard_Integer
        PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer
        PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer

        Compute the point <aPx>,  (<aP2D>)  that is near to
        the edge <aE>   at arbitrary  parameter  towards to the
        material of the face <aF>. The value of shifting in
        2D is  dt2D=BOPTools_AlgoTools3D::MinStepIn2d().<br>
        If the value of shifting is too big the point will be computed
        using Hatcher (PointInFace function).<br>
        Returns error status:<br>
        0 - in case of success;<br>
        1 - <aE> does not have 2d curve on the face <aF>;<br>
        2 - the computed point is out of the face.

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aP2D: OCC.wrapper.gp.gp_Pnt2d
        :type aPx: OCC.wrapper.gp.gp_Pnt
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

    PointNearEdge = staticmethod(PointNearEdge)

    def MinStepIn2d(*args):
        """
        MinStepIn2d() -> Standard_Real

        Returns simple step value that is used in 2D-computations
        = 1.e-5

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

    MinStepIn2d = staticmethod(MinStepIn2d)

    def IsEmptyShape(*args):
        """
        IsEmptyShape(TopoDS_Shape aS) -> Standard_Boolean

        Returns TRUE if the shape <aS> does not contain
        geometry information  (e.g. empty compound)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

    IsEmptyShape = staticmethod(IsEmptyShape)

    def OrientEdgeOnFace(*args):
        """
        OrientEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, TopoDS_Edge aER)

        Get the edge <aER> from the face <aF> that is the same as
        the edge <aE>

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aER: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

    OrientEdgeOnFace = staticmethod(OrientEdgeOnFace)

    def PointInFace(*args):
        """
        PointInFace(TopoDS_Face theF, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext) -> Standard_Integer
        PointInFace(TopoDS_Face theF, TopoDS_Edge theE, Standard_Real const theT, Standard_Real const theDt2D, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext) -> Standard_Integer
        PointInFace(TopoDS_Face theF, Handle_Geom2d_Curve theL, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext, Standard_Real const theDt2D=0.0) -> Standard_Integer

        Computes a point <theP> inside the face <theF> 
        using the line <theL> so that 2D point
        <theP2D>, 2D representation of <theP>
        on the surface of <theF>, lies on that line.<br>
        Returns 0 in case of success.

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theL: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theP2D: OCC.wrapper.gp.gp_Pnt2d
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theDt2D: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

    PointInFace = staticmethod(PointInFace)

    def __init__(self):
        """
        The class contains handy static functions
        dealing with the topology
        This is the copy of BOPTools_AlgoTools3D.cdl file
        """
        this = _BOPTools.new_BOPTools_AlgoTools3D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools3D
BOPTools_AlgoTools3D_swigregister = _BOPTools.BOPTools_AlgoTools3D_swigregister
BOPTools_AlgoTools3D_swigregister(BOPTools_AlgoTools3D)

def BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args):
    """
    BOPTools_AlgoTools3D_DoSplitSEAMOnFace(TopoDS_Edge aSp, TopoDS_Face aF)

    Make the edge <aSp> seam edge for the face <aF>

    :type aSp: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

def BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args):
    """
    GetNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Dir aD, Handle_IntTools_Context theContext)
    BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, gp_Dir aD, Handle_IntTools_Context theContext)

    Computes normal to the face <aF> for the point on the edge <aE>
    at arbitrary intermediate parameter.<br>
    <theContext> - storage for caching the geometrical tools

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aD: OCC.wrapper.gp.gp_Dir
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_SenseFlag(*args):
    """
    BOPTools_AlgoTools3D_SenseFlag(gp_Dir aNF1, gp_Dir aNF2) -> Standard_Integer

    Returns 1  if scalar product aNF1* aNF2>0.<br>
    Returns 0  if directions aNF1 aNF2 coincide<br>
    Returns -1 if scalar product aNF1* aNF2<0.

    :type aNF1: OCC.wrapper.gp.gp_Dir
    :type aNF2: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

def BOPTools_AlgoTools3D_GetNormalToSurface(*args):
    """
    BOPTools_AlgoTools3D_GetNormalToSurface(Handle_Geom_Surface aS, Standard_Real const U, Standard_Real const V, gp_Dir aD) -> Standard_Boolean

    Compute normal <aD> to surface <aS> in point (U,V)
    Returns TRUE if directions aD1U, aD1V coincide

    :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
    :type U: float
    :type V: float
    :type aD: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

def BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args):
    """
    GetApproxNormalToFaceOnEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Pnt aPx, gp_Dir aD, Handle_IntTools_Context theContext) -> Standard_Boolean
    GetApproxNormalToFaceOnEdge(TopoDS_Edge theE, TopoDS_Face theF, Standard_Real const aT, gp_Pnt aP, gp_Dir aDNF, Standard_Real const aDt2D) -> Standard_Boolean
    BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(TopoDS_Edge theE, TopoDS_Face theF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt aP, gp_Dir aDNF, Handle_IntTools_Context theContext) -> Standard_Boolean

    Computes normal to the face <aF> for the 3D-point that
    belongs to the edge <aE> at parameter <aT>.<br>
    Output:<br>
    aPx  -  the 3D-point where the normal computed<br>
    aD   -  the normal;<br>
    Warning:<br>
    The normal is computed not exactly in the point on the
    edge, but in point that is near to the edge towards to
    the face material (so, we'll have approx. normal);<br>
    The point is computed using PointNearEdge function
    with the shifting value <aDt2D> from the edge,
    but if this value is too big the point will be 
    computed using Hatcher (PointInFace function).<br>
    Returns TRUE in case of success.

    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aT: float
    :type aDt2D: float
    :type aP: OCC.wrapper.gp.gp_Pnt
    :type aDNF: OCC.wrapper.gp.gp_Dir
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_PointNearEdge(*args):
    """
    PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer
    PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Standard_Real const aDt2D, gp_Pnt2d aP2D, gp_Pnt aPx) -> Standard_Integer
    PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer
    BOPTools_AlgoTools3D_PointNearEdge(TopoDS_Edge aE, TopoDS_Face aF, gp_Pnt2d aP2D, gp_Pnt aPx, Handle_IntTools_Context theContext) -> Standard_Integer

    Compute the point <aPx>,  (<aP2D>)  that is near to
    the edge <aE>   at arbitrary  parameter  towards to the
    material of the face <aF>. The value of shifting in
    2D is  dt2D=BOPTools_AlgoTools3D::MinStepIn2d().<br>
    If the value of shifting is too big the point will be computed
    using Hatcher (PointInFace function).<br>
    Returns error status:<br>
    0 - in case of success;<br>
    1 - <aE> does not have 2d curve on the face <aF>;<br>
    2 - the computed point is out of the face.

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aP2D: OCC.wrapper.gp.gp_Pnt2d
    :type aPx: OCC.wrapper.gp.gp_Pnt
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

def BOPTools_AlgoTools3D_MinStepIn2d(*args):
    """
    BOPTools_AlgoTools3D_MinStepIn2d() -> Standard_Real

    Returns simple step value that is used in 2D-computations
    = 1.e-5

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

def BOPTools_AlgoTools3D_IsEmptyShape(*args):
    """
    BOPTools_AlgoTools3D_IsEmptyShape(TopoDS_Shape aS) -> Standard_Boolean

    Returns TRUE if the shape <aS> does not contain
    geometry information  (e.g. empty compound)

    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

def BOPTools_AlgoTools3D_OrientEdgeOnFace(*args):
    """
    BOPTools_AlgoTools3D_OrientEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, TopoDS_Edge aER)

    Get the edge <aER> from the face <aF> that is the same as
    the edge <aE>

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aER: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

def BOPTools_AlgoTools3D_PointInFace(*args):
    """
    PointInFace(TopoDS_Face theF, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext) -> Standard_Integer
    PointInFace(TopoDS_Face theF, TopoDS_Edge theE, Standard_Real const theT, Standard_Real const theDt2D, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext) -> Standard_Integer
    BOPTools_AlgoTools3D_PointInFace(TopoDS_Face theF, Handle_Geom2d_Curve theL, gp_Pnt theP, gp_Pnt2d theP2D, Handle_IntTools_Context theContext, Standard_Real const theDt2D=0.0) -> Standard_Integer

    Computes a point <theP> inside the face <theF> 
    using the line <theL> so that 2D point
    <theP2D>, 2D representation of <theP>
    on the surface of <theF>, lies on that line.<br>
    Returns 0 in case of success.

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theL: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theP: OCC.wrapper.gp.gp_Pnt
    :type theP2D: OCC.wrapper.gp.gp_Pnt2d
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theDt2D: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

class BOPTools_AlgoTools(object):
    """
    Provides tools used in Boolean Operations algorithm:
    - Vertices intersection;
    - Vertex construction;
    - Edge construction;
    - Classification algorithms;
    - Making connexity blocks;
    - Shape validation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ComputeVV(*args):
        """
        ComputeVV(TopoDS_Vertex theV, gp_Pnt theP, Standard_Real const theTolP) -> Standard_Integer
        ComputeVV(TopoDS_Vertex theV1, TopoDS_Vertex theV2, Standard_Real const theFuzz) -> Standard_Integer

        Intersects the given vertices with given fuzzy value.
        Returns the error status:
        - 0 - no error, meaning that the vertices interferes with given tolerance;
        - 1 - the distance between vertices is grater than the sum of their tolerances.

        :type theV1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theV2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

    ComputeVV = staticmethod(ComputeVV)

    def MakeVertex(*args):
        """
        MakeVertex(NCollection_List_TopoDS_Shape theLV, TopoDS_Vertex theV)

        Makes the vertex in the middle of given vertices with
        the tolerance covering all tolerance spheres of vertices.

        :type theLV: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

    MakeVertex = staticmethod(MakeVertex)

    def MakeNewVertex(*args):
        """
        MakeNewVertex(gp_Pnt aP1, Standard_Real const aTol, TopoDS_Vertex aNewVertex)
        MakeNewVertex(TopoDS_Vertex aV1, TopoDS_Vertex aV2, TopoDS_Vertex aNewVertex)
        MakeNewVertex(TopoDS_Edge aE1, Standard_Real const aP1, TopoDS_Edge aE2, Standard_Real const aP2, TopoDS_Vertex aNewVertex)
        MakeNewVertex(TopoDS_Edge aE1, Standard_Real const aP1, TopoDS_Face aF2, TopoDS_Vertex aNewVertex)

        Make a vertex in place of intersection between the edge <aE1>
        with parameter <aP1> and the face <aF2>

        :type aE1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aP1: float
        :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type aNewVertex: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

    MakeNewVertex = staticmethod(MakeNewVertex)

    def UpdateVertex(*args):
        """
        UpdateVertex(IntTools_Curve aIC, Standard_Real const aT, TopoDS_Vertex aV)
        UpdateVertex(TopoDS_Edge aE, Standard_Real const aT, TopoDS_Vertex aV)
        UpdateVertex(TopoDS_Vertex aVF, TopoDS_Vertex aVN)

        Update the tolerance value for vertex  <aVN>
        taking into account the fact that <aVN> should
        cover tolerance zone of <aVF>

        :type aVF: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aVN: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

    UpdateVertex = staticmethod(UpdateVertex)

    def MakeEdge(*args):
        """
        MakeEdge(IntTools_Curve theCurve, TopoDS_Vertex theV1, Standard_Real const theT1, TopoDS_Vertex theV2, Standard_Real const theT2, Standard_Real const theTolR3D, TopoDS_Edge theE)

        Makes the edge based on the given curve with given bounding vertices.

        :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
        :type theV1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theT1: float
        :type theV2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theT2: float
        :type theTolR3D: float
        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

    MakeEdge = staticmethod(MakeEdge)

    def CopyEdge(*args):
        """
        CopyEdge(TopoDS_Edge theEdge) -> TopoDS_Edge

        Makes a copy of <theEdge> with vertices.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools_CopyEdge(*args)

    CopyEdge = staticmethod(CopyEdge)

    def MakeSplitEdge(*args):
        """
        MakeSplitEdge(TopoDS_Edge aE1, TopoDS_Vertex aV1, Standard_Real const aP1, TopoDS_Vertex aV2, Standard_Real const aP2, TopoDS_Edge aNewEdge)

        Make the edge from base edge <aE1> and two vertices <aV1,aV2>
        at parameters <aP1,aP2>

        :type aE1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aV1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aP1: float
        :type aV2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aP2: float
        :type aNewEdge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

    MakeSplitEdge = staticmethod(MakeSplitEdge)

    def MakeSectEdge(*args):
        """
        MakeSectEdge(IntTools_Curve aIC, TopoDS_Vertex aV1, Standard_Real const aP1, TopoDS_Vertex aV2, Standard_Real const aP2, TopoDS_Edge aNewEdge)

        Make the edge from 3D-Curve <aIC>  and two vertices <aV1,aV2>
        at parameters <aP1,aP2>

        :type aIC: OCC.wrapper.IntTools.IntTools_Curve
        :type aV1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aP1: float
        :type aV2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type aP2: float
        :type aNewEdge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

    MakeSectEdge = staticmethod(MakeSectEdge)

    def ComputeState(*args):
        """
        ComputeState(gp_Pnt thePoint, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
        ComputeState(TopoDS_Vertex theVertex, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
        ComputeState(TopoDS_Edge theEdge, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
        ComputeState(TopoDS_Face theFace, TopoDS_Solid theSolid, Standard_Real const theTol, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theBounds, Handle_IntTools_Context theContext) -> TopAbs_State

        Computes the 3-D state of the face theFace
        toward solid theSolid.
        theTol - value of precision of computation
        theBounds - set of edges of <theSolid> to avoid
        theContext- cahed geometrical tools
        Returns 3-D state.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :type theTol: float
        :type theBounds: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

    ComputeState = staticmethod(ComputeState)

    def ComputeStateByOnePoint(*args):
        """
        ComputeStateByOnePoint(TopoDS_Shape theShape, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State

        Computes the 3-D state of the shape theShape
        toward solid theSolid.
        theTol - value of precision of computation
        theContext- cahed geometrical tools
        Returns 3-D state.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :type theTol: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

    ComputeStateByOnePoint = staticmethod(ComputeStateByOnePoint)

    def GetFaceOff(*args):
        """
        GetFaceOff(TopoDS_Edge theEdge, TopoDS_Face theFace, BOPTools_ListOfCoupleOfShape & theLCEF, TopoDS_Face theFaceOff, Handle_IntTools_Context theContext) -> Standard_Boolean

        For the face theFace and its edge theEdge
        finds the face suitable to produce shell.
        theLCEF - set of faces to search. All faces
        from theLCEF must share edge theEdge

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theLCEF: OCC.wrapper.BOPTools.BOPTools_ListOfCoupleOfShape
        :type theFaceOff: OCC.wrapper.TopoDS.TopoDS_Face
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

    GetFaceOff = staticmethod(GetFaceOff)

    def IsInternalFace(*args):
        """
        IsInternalFace(TopoDS_Face theFace, TopoDS_Edge theEdge, TopoDS_Face theFace1, TopoDS_Face theFace2, Handle_IntTools_Context theContext) -> Standard_Integer
        IsInternalFace(TopoDS_Face theFace, TopoDS_Edge theEdge, NCollection_List_TopoDS_Shape theLF, Handle_IntTools_Context theContext) -> Standard_Integer
        IsInternalFace(TopoDS_Face theFace, TopoDS_Solid theSolid, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theMEF, Standard_Real const theTol, Handle_IntTools_Context theContext) -> Standard_Boolean

        Returns True if the face theFace is inside the
        solid theSolid.
        theMEF - Map Edge/Faces for theSolid
        theTol - value of precision of computation
        theContext- cahed geometrical tools

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :type theMEF: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
        :type theTol: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

    IsInternalFace = staticmethod(IsInternalFace)

    def MakePCurve(*args):
        """
        MakePCurve(TopoDS_Edge theE, TopoDS_Face theF1, TopoDS_Face theF2, IntTools_Curve theCurve, Standard_Boolean const thePC1, Standard_Boolean const thePC2, Handle_IntTools_Context theContext)

        Makes 2d curve of the edge <theE> on the faces <theF1> and <theF2>.<br>
        <theContext> - storage for caching the geometrical tools

        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
        :type thePC1: bool
        :type thePC2: bool
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

    MakePCurve = staticmethod(MakePCurve)

    def IsHole(*args):
        """
        IsHole(TopoDS_Shape theW, TopoDS_Shape theF) -> Standard_Boolean

        Checks if the wire is a hole for the face.

        :type theW: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theF: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

    IsHole = staticmethod(IsHole)

    def IsSplitToReverseWithWarn(*args):
        """
        IsSplitToReverseWithWarn(TopoDS_Shape theSplit, TopoDS_Shape theShape, Handle_IntTools_Context theContext, Handle_Message_Report theReport=0) -> Standard_Boolean

        Add-on for the *IsSplitToReverse()* to check for its errors
        and in case of any add the *BOPAlgo_AlertUnableToOrientTheShape*
        warning to the report.

        :type theSplit: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theReport: OCC.wrapper.Message.Handle_Message_Report
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args)

    IsSplitToReverseWithWarn = staticmethod(IsSplitToReverseWithWarn)

    def IsSplitToReverse(*args):
        """
        IsSplitToReverse(TopoDS_Shape theSplit, TopoDS_Shape theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean
        IsSplitToReverse(TopoDS_Face theSplit, TopoDS_Face theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean
        IsSplitToReverse(TopoDS_Edge theSplit, TopoDS_Edge theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean

        Checks if the tangent vector of the split edge is opposite to
        the tangent vector of the original edge.
        The tangent vectors for both edges are computed in the same point -
        point inside the split edge is projected onto the original edge.
        Returns TRUE if the tangent vectors do not coincide, meaning the necessity
        to revert the orientation of the split edge to match the direction
        of the original edge.

        If requested (<theError> is not null), the method returns the status of the operation:
        - 0 - no error;
        - 1 - degenerated edges are given;
        - 2 - unable to compute the tangent vector for the split edge;
        - 3 - unable to project the point inside the split edge on the original edge;
        - 4 - unable to compute the tangent vector for the original edge;
        In case of any error the method always returns FALSE.

        @param theSplit [in] Split edge
        @param theShape [in] Original edge
        @param theContext [in] Cashed geometrical tools
        @param theError [out] Error Status of the operation

        :type theSplit: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theError: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

    IsSplitToReverse = staticmethod(IsSplitToReverse)

    def Sense(*args):
        """
        Sense(TopoDS_Face theF1, TopoDS_Face theF2, Handle_IntTools_Context theContext) -> Standard_Integer

        Checks if the normals direction of the given faces computed near
        the shared edge coincide.
        Returns the status of operation:
        * 0 - in case of error (shared edge not found or directions are not collinear)
        * 1 - normal directions coincide;
        * -1 - normal directions are opposite.

        :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools_Sense(*args)

    Sense = staticmethod(Sense)

    def MakeConnexityBlock(*args):
        """
        MakeConnexityBlock(NCollection_List_TopoDS_Shape theLS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapAvoid, NCollection_List_TopoDS_Shape theLSCB, Handle_NCollection_BaseAllocator theAllocator)

        For the list of faces theLS build block
        theLSCB in terms of connexity by edges
        theMapAvoid - set of edges to avoid for
        the treatment

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theMapAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theLSCB: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

    MakeConnexityBlock = staticmethod(MakeConnexityBlock)

    def MakeConnexityBlocks(*args):
        """
        MakeConnexityBlocks(TopoDS_Shape theS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, NCollection_List_TopoDS_Shape theLCB)
        MakeConnexityBlocks(TopoDS_Shape theS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, NCollection_List_TopTools_ListOfShape theLCB, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theConnectionMap)
        MakeConnexityBlocks(NCollection_List_TopoDS_Shape theLS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, BOPTools_ListOfConnexityBlock & theLCB)

        Makes connexity blocks of elements of the given type with the given type of the
        connecting elements. The blocks are checked on regularity (multi-connectivity)
        and stored to the list of blocks <theLCB>.

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theConnectionType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theElementType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theLCB: OCC.wrapper.BOPTools.BOPTools_ListOfConnexityBlock

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

    MakeConnexityBlocks = staticmethod(MakeConnexityBlocks)

    def OrientEdgesOnWire(*args):
        """
        OrientEdgesOnWire(TopoDS_Shape theWire)

        Correctly orients edges on the wire

        :type theWire: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPTools.BOPTools_AlgoTools_OrientEdgesOnWire(*args)

    OrientEdgesOnWire = staticmethod(OrientEdgesOnWire)

    def OrientFacesOnShell(*args):
        """
        OrientFacesOnShell(TopoDS_Shape theShell)

        Correctly orients faces on the shell

        :type theShell: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

    OrientFacesOnShell = staticmethod(OrientFacesOnShell)

    def CorrectTolerances(*args):
        """
        CorrectTolerances(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

        Provides valid values of tolerances for the shape <theS>
        <theTolMax> is max value of the tolerance that can be
        accepted for correction.  If real value of the tolerance
        will be greater than  <aTolMax>, the correction does not
        perform.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theTolMax: float
        :type theRunParallel: bool

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

    CorrectTolerances = staticmethod(CorrectTolerances)

    def CorrectCurveOnSurface(*args):
        """
        CorrectCurveOnSurface(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

        Provides valid values of tolerances for the shape <theS>
        in  terms of BRepCheck_InvalidCurveOnSurface.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theTolMax: float
        :type theRunParallel: bool

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

    CorrectCurveOnSurface = staticmethod(CorrectCurveOnSurface)

    def CorrectPointOnCurve(*args):
        """
        CorrectPointOnCurve(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

        Provides valid values of tolerances for the shape <theS>
        in  terms of BRepCheck_InvalidPointOnCurve.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theTolMax: float
        :type theRunParallel: bool

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

    CorrectPointOnCurve = staticmethod(CorrectPointOnCurve)

    def CorrectShapeTolerances(*args):
        """
        CorrectShapeTolerances(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Boolean const theRunParallel)

        Corrects tolerance values of the sub-shapes of the shape <theS> if needed.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theRunParallel: bool

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

    CorrectShapeTolerances = staticmethod(CorrectShapeTolerances)

    def AreFacesSameDomain(*args):
        """
        AreFacesSameDomain(TopoDS_Face theF1, TopoDS_Face theF2, Handle_IntTools_Context theContext, Standard_Real const theFuzz) -> Standard_Boolean

        Checks if the given faces are same-domain, i.e. coincide.

        :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theFuzz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

    AreFacesSameDomain = staticmethod(AreFacesSameDomain)

    def GetEdgeOff(*args):
        """
        GetEdgeOff(TopoDS_Edge theEdge, TopoDS_Face theFace, TopoDS_Edge theEdgeOff) -> Standard_Boolean

        Returns True if the face theFace contains
        the edge theEdge but with opposite orientation.
        If the method  returns True theEdgeOff is the
        edge founded

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdgeOff: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

    GetEdgeOff = staticmethod(GetEdgeOff)

    def GetEdgeOnFace(*args):
        """
        GetEdgeOnFace(TopoDS_Edge theEdge, TopoDS_Face theFace, TopoDS_Edge theEdgeOnF) -> Standard_Boolean

        For the face theFace gets the edge theEdgeOnF
        that is the same as theEdge
        Returns True if such edge exists
        Returns False if there is no such edge

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdgeOnF: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

    GetEdgeOnFace = staticmethod(GetEdgeOnFace)

    def CorrectRange(*args):
        """
        CorrectRange(TopoDS_Edge aE1, TopoDS_Edge aE2, IntTools_Range aSR, IntTools_Range aNewSR)
        CorrectRange(TopoDS_Edge aE, TopoDS_Face aF, IntTools_Range aSR, IntTools_Range aNewSR)

        Correct shrunk range <aSR> taking into account 3D-curve
        resolution and corresponding tolerance values of <aE>, <aF>

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aSR: OCC.wrapper.IntTools.IntTools_Range
        :type aNewSR: OCC.wrapper.IntTools.IntTools_Range

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

    CorrectRange = staticmethod(CorrectRange)

    def IsMicroEdge(*args):
        """
        IsMicroEdge(TopoDS_Edge theEdge, Handle_IntTools_Context theContext, Standard_Boolean const theCheckSplittable) -> Standard_Boolean

        Checks if it is possible to compute shrunk range for the edge <aE>
        Flag <theCheckSplittable> defines whether to take into account 
        the possibility to split the edge or not.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :type theCheckSplittable: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

    IsMicroEdge = staticmethod(IsMicroEdge)

    def IsInvertedSolid(*args):
        """
        IsInvertedSolid(TopoDS_Solid theSolid) -> Standard_Boolean

        Returns true if the solid <theSolid> is inverted

        :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

    IsInvertedSolid = staticmethod(IsInvertedSolid)

    def ComputeTolerance(*args):
        """
        ComputeTolerance(TopoDS_Face theFace, TopoDS_Edge theEdge) -> Standard_Boolean

        Computes the necessary value of the tolerance for the edge

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theMaxDist: float
        :type theMaxPar: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

    ComputeTolerance = staticmethod(ComputeTolerance)

    def MakeContainer(*args):
        """
        MakeContainer(TopAbs_ShapeEnum const theType, TopoDS_Shape theShape)

        Makes empty container of requested type

        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

    MakeContainer = staticmethod(MakeContainer)

    def PointOnEdge(*args):
        """
        PointOnEdge(TopoDS_Edge aEdge, Standard_Real const aPrm, gp_Pnt aP)

        Compute a 3D-point on the edge <aEdge> at parameter <aPrm>

        :type aEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aPrm: float
        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

    PointOnEdge = staticmethod(PointOnEdge)

    def IsBlockInOnFace(*args):
        """
        IsBlockInOnFace(IntTools_Range aShR, TopoDS_Face aF, TopoDS_Edge aE, Handle_IntTools_Context aContext) -> Standard_Boolean

        Returns TRUE if PaveBlock <aPB> lays on the face <aF>, i.e
        the <PB> is IN or ON in 2D of <aF>

        :type aShR: OCC.wrapper.IntTools.IntTools_Range
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aContext: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

    IsBlockInOnFace = staticmethod(IsBlockInOnFace)

    def Dimension(*args):
        """
        Dimension(TopoDS_Shape theS) -> Standard_Integer

        Retutns dimension of the shape <theS>.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

    Dimension = staticmethod(Dimension)

    def IsOpenShell(*args):
        """
        IsOpenShell(TopoDS_Shell theShell) -> Standard_Boolean

        Returns true if the  shell <theShell> is open

        :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

    IsOpenShell = staticmethod(IsOpenShell)

    def __init__(self):
        """
        Provides tools used in Boolean Operations algorithm:
        - Vertices intersection;
        - Vertex construction;
        - Edge construction;
        - Classification algorithms;
        - Making connexity blocks;
        - Shape validation.
        """
        this = _BOPTools.new_BOPTools_AlgoTools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools
BOPTools_AlgoTools_swigregister = _BOPTools.BOPTools_AlgoTools_swigregister
BOPTools_AlgoTools_swigregister(BOPTools_AlgoTools)

def BOPTools_AlgoTools_ComputeVV(*args):
    """
    ComputeVV(TopoDS_Vertex theV, gp_Pnt theP, Standard_Real const theTolP) -> Standard_Integer
    BOPTools_AlgoTools_ComputeVV(TopoDS_Vertex theV1, TopoDS_Vertex theV2, Standard_Real const theFuzz) -> Standard_Integer

    Intersects the given vertices with given fuzzy value.
    Returns the error status:
    - 0 - no error, meaning that the vertices interferes with given tolerance;
    - 1 - the distance between vertices is grater than the sum of their tolerances.

    :type theV1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theV2: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theFuzz: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

def BOPTools_AlgoTools_MakeVertex(*args):
    """
    BOPTools_AlgoTools_MakeVertex(NCollection_List_TopoDS_Shape theLV, TopoDS_Vertex theV)

    Makes the vertex in the middle of given vertices with
    the tolerance covering all tolerance spheres of vertices.

    :type theLV: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

def BOPTools_AlgoTools_MakeNewVertex(*args):
    """
    MakeNewVertex(gp_Pnt aP1, Standard_Real const aTol, TopoDS_Vertex aNewVertex)
    MakeNewVertex(TopoDS_Vertex aV1, TopoDS_Vertex aV2, TopoDS_Vertex aNewVertex)
    MakeNewVertex(TopoDS_Edge aE1, Standard_Real const aP1, TopoDS_Edge aE2, Standard_Real const aP2, TopoDS_Vertex aNewVertex)
    BOPTools_AlgoTools_MakeNewVertex(TopoDS_Edge aE1, Standard_Real const aP1, TopoDS_Face aF2, TopoDS_Vertex aNewVertex)

    Make a vertex in place of intersection between the edge <aE1>
    with parameter <aP1> and the face <aF2>

    :type aE1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aP1: float
    :type aF2: OCC.wrapper.TopoDS.TopoDS_Face
    :type aNewVertex: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

def BOPTools_AlgoTools_UpdateVertex(*args):
    """
    UpdateVertex(IntTools_Curve aIC, Standard_Real const aT, TopoDS_Vertex aV)
    UpdateVertex(TopoDS_Edge aE, Standard_Real const aT, TopoDS_Vertex aV)
    BOPTools_AlgoTools_UpdateVertex(TopoDS_Vertex aVF, TopoDS_Vertex aVN)

    Update the tolerance value for vertex  <aVN>
    taking into account the fact that <aVN> should
    cover tolerance zone of <aVF>

    :type aVF: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type aVN: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

def BOPTools_AlgoTools_MakeEdge(*args):
    """
    BOPTools_AlgoTools_MakeEdge(IntTools_Curve theCurve, TopoDS_Vertex theV1, Standard_Real const theT1, TopoDS_Vertex theV2, Standard_Real const theT2, Standard_Real const theTolR3D, TopoDS_Edge theE)

    Makes the edge based on the given curve with given bounding vertices.

    :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
    :type theV1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theT1: float
    :type theV2: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theT2: float
    :type theTolR3D: float
    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

def BOPTools_AlgoTools_CopyEdge(*args):
    """
    BOPTools_AlgoTools_CopyEdge(TopoDS_Edge theEdge) -> TopoDS_Edge

    Makes a copy of <theEdge> with vertices.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools_CopyEdge(*args)

def BOPTools_AlgoTools_MakeSplitEdge(*args):
    """
    BOPTools_AlgoTools_MakeSplitEdge(TopoDS_Edge aE1, TopoDS_Vertex aV1, Standard_Real const aP1, TopoDS_Vertex aV2, Standard_Real const aP2, TopoDS_Edge aNewEdge)

    Make the edge from base edge <aE1> and two vertices <aV1,aV2>
    at parameters <aP1,aP2>

    :type aE1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aV1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type aP1: float
    :type aV2: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type aP2: float
    :type aNewEdge: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

def BOPTools_AlgoTools_MakeSectEdge(*args):
    """
    BOPTools_AlgoTools_MakeSectEdge(IntTools_Curve aIC, TopoDS_Vertex aV1, Standard_Real const aP1, TopoDS_Vertex aV2, Standard_Real const aP2, TopoDS_Edge aNewEdge)

    Make the edge from 3D-Curve <aIC>  and two vertices <aV1,aV2>
    at parameters <aP1,aP2>

    :type aIC: OCC.wrapper.IntTools.IntTools_Curve
    :type aV1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type aP1: float
    :type aV2: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type aP2: float
    :type aNewEdge: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

def BOPTools_AlgoTools_ComputeState(*args):
    """
    ComputeState(gp_Pnt thePoint, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
    ComputeState(TopoDS_Vertex theVertex, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
    ComputeState(TopoDS_Edge theEdge, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State
    BOPTools_AlgoTools_ComputeState(TopoDS_Face theFace, TopoDS_Solid theSolid, Standard_Real const theTol, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theBounds, Handle_IntTools_Context theContext) -> TopAbs_State

    Computes the 3-D state of the face theFace
    toward solid theSolid.
    theTol - value of precision of computation
    theBounds - set of edges of <theSolid> to avoid
    theContext- cahed geometrical tools
    Returns 3-D state.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :type theTol: float
    :type theBounds: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

def BOPTools_AlgoTools_ComputeStateByOnePoint(*args):
    """
    BOPTools_AlgoTools_ComputeStateByOnePoint(TopoDS_Shape theShape, TopoDS_Solid theSolid, Standard_Real const theTol, Handle_IntTools_Context theContext) -> TopAbs_State

    Computes the 3-D state of the shape theShape
    toward solid theSolid.
    theTol - value of precision of computation
    theContext- cahed geometrical tools
    Returns 3-D state.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :type theTol: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

def BOPTools_AlgoTools_GetFaceOff(*args):
    """
    BOPTools_AlgoTools_GetFaceOff(TopoDS_Edge theEdge, TopoDS_Face theFace, BOPTools_ListOfCoupleOfShape & theLCEF, TopoDS_Face theFaceOff, Handle_IntTools_Context theContext) -> Standard_Boolean

    For the face theFace and its edge theEdge
    finds the face suitable to produce shell.
    theLCEF - set of faces to search. All faces
    from theLCEF must share edge theEdge

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theLCEF: OCC.wrapper.BOPTools.BOPTools_ListOfCoupleOfShape
    :type theFaceOff: OCC.wrapper.TopoDS.TopoDS_Face
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

def BOPTools_AlgoTools_IsInternalFace(*args):
    """
    IsInternalFace(TopoDS_Face theFace, TopoDS_Edge theEdge, TopoDS_Face theFace1, TopoDS_Face theFace2, Handle_IntTools_Context theContext) -> Standard_Integer
    IsInternalFace(TopoDS_Face theFace, TopoDS_Edge theEdge, NCollection_List_TopoDS_Shape theLF, Handle_IntTools_Context theContext) -> Standard_Integer
    BOPTools_AlgoTools_IsInternalFace(TopoDS_Face theFace, TopoDS_Solid theSolid, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theMEF, Standard_Real const theTol, Handle_IntTools_Context theContext) -> Standard_Boolean

    Returns True if the face theFace is inside the
    solid theSolid.
    theMEF - Map Edge/Faces for theSolid
    theTol - value of precision of computation
    theContext- cahed geometrical tools

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :type theMEF: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
    :type theTol: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

def BOPTools_AlgoTools_MakePCurve(*args):
    """
    BOPTools_AlgoTools_MakePCurve(TopoDS_Edge theE, TopoDS_Face theF1, TopoDS_Face theF2, IntTools_Curve theCurve, Standard_Boolean const thePC1, Standard_Boolean const thePC2, Handle_IntTools_Context theContext)

    Makes 2d curve of the edge <theE> on the faces <theF1> and <theF2>.<br>
    <theContext> - storage for caching the geometrical tools

    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
    :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
    :type theCurve: OCC.wrapper.IntTools.IntTools_Curve
    :type thePC1: bool
    :type thePC2: bool
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

def BOPTools_AlgoTools_IsHole(*args):
    """
    BOPTools_AlgoTools_IsHole(TopoDS_Shape theW, TopoDS_Shape theF) -> Standard_Boolean

    Checks if the wire is a hole for the face.

    :type theW: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theF: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

def BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args):
    """
    BOPTools_AlgoTools_IsSplitToReverseWithWarn(TopoDS_Shape theSplit, TopoDS_Shape theShape, Handle_IntTools_Context theContext, Handle_Message_Report theReport=0) -> Standard_Boolean

    Add-on for the *IsSplitToReverse()* to check for its errors
    and in case of any add the *BOPAlgo_AlertUnableToOrientTheShape*
    warning to the report.

    :type theSplit: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theReport: OCC.wrapper.Message.Handle_Message_Report
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args)

def BOPTools_AlgoTools_IsSplitToReverse(*args):
    """
    IsSplitToReverse(TopoDS_Shape theSplit, TopoDS_Shape theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean
    IsSplitToReverse(TopoDS_Face theSplit, TopoDS_Face theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean
    BOPTools_AlgoTools_IsSplitToReverse(TopoDS_Edge theSplit, TopoDS_Edge theShape, Handle_IntTools_Context theContext, Standard_Integer * theError=None) -> Standard_Boolean

    Checks if the tangent vector of the split edge is opposite to
    the tangent vector of the original edge.
    The tangent vectors for both edges are computed in the same point -
    point inside the split edge is projected onto the original edge.
    Returns TRUE if the tangent vectors do not coincide, meaning the necessity
    to revert the orientation of the split edge to match the direction
    of the original edge.

    If requested (<theError> is not null), the method returns the status of the operation:
    - 0 - no error;
    - 1 - degenerated edges are given;
    - 2 - unable to compute the tangent vector for the split edge;
    - 3 - unable to project the point inside the split edge on the original edge;
    - 4 - unable to compute the tangent vector for the original edge;
    In case of any error the method always returns FALSE.

    @param theSplit [in] Split edge
    @param theShape [in] Original edge
    @param theContext [in] Cashed geometrical tools
    @param theError [out] Error Status of the operation

    :type theSplit: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theError: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

def BOPTools_AlgoTools_Sense(*args):
    """
    BOPTools_AlgoTools_Sense(TopoDS_Face theF1, TopoDS_Face theF2, Handle_IntTools_Context theContext) -> Standard_Integer

    Checks if the normals direction of the given faces computed near
    the shared edge coincide.
    Returns the status of operation:
    * 0 - in case of error (shared edge not found or directions are not collinear)
    * 1 - normal directions coincide;
    * -1 - normal directions are opposite.

    :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
    :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools_Sense(*args)

def BOPTools_AlgoTools_MakeConnexityBlock(*args):
    """
    BOPTools_AlgoTools_MakeConnexityBlock(NCollection_List_TopoDS_Shape theLS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapAvoid, NCollection_List_TopoDS_Shape theLSCB, Handle_NCollection_BaseAllocator theAllocator)

    For the list of faces theLS build block
    theLSCB in terms of connexity by edges
    theMapAvoid - set of edges to avoid for
    the treatment

    :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theMapAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theLSCB: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

def BOPTools_AlgoTools_MakeConnexityBlocks(*args):
    """
    MakeConnexityBlocks(TopoDS_Shape theS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, NCollection_List_TopoDS_Shape theLCB)
    MakeConnexityBlocks(TopoDS_Shape theS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, NCollection_List_TopTools_ListOfShape theLCB, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theConnectionMap)
    BOPTools_AlgoTools_MakeConnexityBlocks(NCollection_List_TopoDS_Shape theLS, TopAbs_ShapeEnum const theConnectionType, TopAbs_ShapeEnum const theElementType, BOPTools_ListOfConnexityBlock & theLCB)

    Makes connexity blocks of elements of the given type with the given type of the
    connecting elements. The blocks are checked on regularity (multi-connectivity)
    and stored to the list of blocks <theLCB>.

    :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theConnectionType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type theElementType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type theLCB: OCC.wrapper.BOPTools.BOPTools_ListOfConnexityBlock

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

def BOPTools_AlgoTools_OrientEdgesOnWire(*args):
    """
    BOPTools_AlgoTools_OrientEdgesOnWire(TopoDS_Shape theWire)

    Correctly orients edges on the wire

    :type theWire: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BOPTools.BOPTools_AlgoTools_OrientEdgesOnWire(*args)

def BOPTools_AlgoTools_OrientFacesOnShell(*args):
    """
    BOPTools_AlgoTools_OrientFacesOnShell(TopoDS_Shape theShell)

    Correctly orients faces on the shell

    :type theShell: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

def BOPTools_AlgoTools_CorrectTolerances(*args):
    """
    BOPTools_AlgoTools_CorrectTolerances(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

    Provides valid values of tolerances for the shape <theS>
    <theTolMax> is max value of the tolerance that can be
    accepted for correction.  If real value of the tolerance
    will be greater than  <aTolMax>, the correction does not
    perform.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theTolMax: float
    :type theRunParallel: bool

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

def BOPTools_AlgoTools_CorrectCurveOnSurface(*args):
    """
    BOPTools_AlgoTools_CorrectCurveOnSurface(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

    Provides valid values of tolerances for the shape <theS>
    in  terms of BRepCheck_InvalidCurveOnSurface.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theTolMax: float
    :type theRunParallel: bool

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

def BOPTools_AlgoTools_CorrectPointOnCurve(*args):
    """
    BOPTools_AlgoTools_CorrectPointOnCurve(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Real const theTolMax=0.0001, Standard_Boolean const theRunParallel)

    Provides valid values of tolerances for the shape <theS>
    in  terms of BRepCheck_InvalidPointOnCurve.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theTolMax: float
    :type theRunParallel: bool

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

def BOPTools_AlgoTools_CorrectShapeTolerances(*args):
    """
    BOPTools_AlgoTools_CorrectShapeTolerances(TopoDS_Shape theS, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapToAvoid, Standard_Boolean const theRunParallel)

    Corrects tolerance values of the sub-shapes of the shape <theS> if needed.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMapToAvoid: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theRunParallel: bool

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

def BOPTools_AlgoTools_AreFacesSameDomain(*args):
    """
    BOPTools_AlgoTools_AreFacesSameDomain(TopoDS_Face theF1, TopoDS_Face theF2, Handle_IntTools_Context theContext, Standard_Real const theFuzz) -> Standard_Boolean

    Checks if the given faces are same-domain, i.e. coincide.

    :type theF1: OCC.wrapper.TopoDS.TopoDS_Face
    :type theF2: OCC.wrapper.TopoDS.TopoDS_Face
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theFuzz: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

def BOPTools_AlgoTools_GetEdgeOff(*args):
    """
    BOPTools_AlgoTools_GetEdgeOff(TopoDS_Edge theEdge, TopoDS_Face theFace, TopoDS_Edge theEdgeOff) -> Standard_Boolean

    Returns True if the face theFace contains
    the edge theEdge but with opposite orientation.
    If the method  returns True theEdgeOff is the
    edge founded

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theEdgeOff: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

def BOPTools_AlgoTools_GetEdgeOnFace(*args):
    """
    BOPTools_AlgoTools_GetEdgeOnFace(TopoDS_Edge theEdge, TopoDS_Face theFace, TopoDS_Edge theEdgeOnF) -> Standard_Boolean

    For the face theFace gets the edge theEdgeOnF
    that is the same as theEdge
    Returns True if such edge exists
    Returns False if there is no such edge

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theEdgeOnF: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

def BOPTools_AlgoTools_CorrectRange(*args):
    """
    CorrectRange(TopoDS_Edge aE1, TopoDS_Edge aE2, IntTools_Range aSR, IntTools_Range aNewSR)
    BOPTools_AlgoTools_CorrectRange(TopoDS_Edge aE, TopoDS_Face aF, IntTools_Range aSR, IntTools_Range aNewSR)

    Correct shrunk range <aSR> taking into account 3D-curve
    resolution and corresponding tolerance values of <aE>, <aF>

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aSR: OCC.wrapper.IntTools.IntTools_Range
    :type aNewSR: OCC.wrapper.IntTools.IntTools_Range

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

def BOPTools_AlgoTools_IsMicroEdge(*args):
    """
    BOPTools_AlgoTools_IsMicroEdge(TopoDS_Edge theEdge, Handle_IntTools_Context theContext, Standard_Boolean const theCheckSplittable) -> Standard_Boolean

    Checks if it is possible to compute shrunk range for the edge <aE>
    Flag <theCheckSplittable> defines whether to take into account 
    the possibility to split the edge or not.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :type theCheckSplittable: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

def BOPTools_AlgoTools_IsInvertedSolid(*args):
    """
    BOPTools_AlgoTools_IsInvertedSolid(TopoDS_Solid theSolid) -> Standard_Boolean

    Returns true if the solid <theSolid> is inverted

    :type theSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

def BOPTools_AlgoTools_ComputeTolerance(*args):
    """
    BOPTools_AlgoTools_ComputeTolerance(TopoDS_Face theFace, TopoDS_Edge theEdge) -> Standard_Boolean

    Computes the necessary value of the tolerance for the edge

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theMaxDist: float
    :type theMaxPar: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

def BOPTools_AlgoTools_MakeContainer(*args):
    """
    BOPTools_AlgoTools_MakeContainer(TopAbs_ShapeEnum const theType, TopoDS_Shape theShape)

    Makes empty container of requested type

    :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

def BOPTools_AlgoTools_PointOnEdge(*args):
    """
    BOPTools_AlgoTools_PointOnEdge(TopoDS_Edge aEdge, Standard_Real const aPrm, gp_Pnt aP)

    Compute a 3D-point on the edge <aEdge> at parameter <aPrm>

    :type aEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aPrm: float
    :type aP: OCC.wrapper.gp.gp_Pnt

    """
    return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

def BOPTools_AlgoTools_IsBlockInOnFace(*args):
    """
    BOPTools_AlgoTools_IsBlockInOnFace(IntTools_Range aShR, TopoDS_Face aF, TopoDS_Edge aE, Handle_IntTools_Context aContext) -> Standard_Boolean

    Returns TRUE if PaveBlock <aPB> lays on the face <aF>, i.e
    the <PB> is IN or ON in 2D of <aF>

    :type aShR: OCC.wrapper.IntTools.IntTools_Range
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aContext: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

def BOPTools_AlgoTools_Dimension(*args):
    """
    BOPTools_AlgoTools_Dimension(TopoDS_Shape theS) -> Standard_Integer

    Retutns dimension of the shape <theS>.

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

def BOPTools_AlgoTools_IsOpenShell(*args):
    """
    BOPTools_AlgoTools_IsOpenShell(TopoDS_Shell theShell) -> Standard_Boolean

    Returns true if the  shell <theShell> is open

    :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

class BOPTools_AlgoTools2D(object):
    """
    The class contains handy static functions
    dealing with the topology
    This is the copy of the BOPTools_AlgoTools2D.cdl
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BuildPCurveForEdgeOnFace(*args):
        """
        BuildPCurveForEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, Handle_IntTools_Context theContext)

        Compute P-Curve for the edge <aE> on the face <aF>.<br>
        Raises exception Standard_ConstructionError if projection algorithm fails.<br>
        <theContext> - storage for caching the geometrical tools

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

    BuildPCurveForEdgeOnFace = staticmethod(BuildPCurveForEdgeOnFace)

    def EdgeTangent(*args):
        """
        EdgeTangent(TopoDS_Edge anE, Standard_Real const aT, gp_Vec Tau) -> Standard_Boolean

        Compute tangent for the edge  <aE> [in 3D]  at parameter <aT>

        :type anE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT: float
        :type Tau: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

    EdgeTangent = staticmethod(EdgeTangent)

    def PointOnSurface(*args):
        """
        PointOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Handle_IntTools_Context theContext)

        Compute surface parameters <U,V> of the face <aF>
        for  the point from the edge <aE> at parameter <aT>.<br>
        If <aE> has't pcurve on surface, algorithm tries to get it by
        projection and can
        raise exception Standard_ConstructionError if projection algorithm fails.<br>
        <theContext> - storage for caching the geometrical tools

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aT: float
        :type U: float
        :type V: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

    PointOnSurface = staticmethod(PointOnSurface)

    def CurveOnSurface(*args):
        """
        CurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)
        CurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

        Get P-Curve <aC>  for the edge <aE> on surface <aF> .<br>
        If the P-Curve does not exist, build  it using Make2D().<br>
        [aFirst, aLast] - range of the P-Curve<br>
        [aToler] - reached tolerance<br>
        Raises exception Standard_ConstructionError if algorithm Make2D() fails.<br>
        <theContext> - storage for caching the geometrical tools

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type aFirst: float
        :type aLast: float
        :type aToler: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_CurveOnSurface(*args)

    CurveOnSurface = staticmethod(CurveOnSurface)

    def HasCurveOnSurface(*args):
        """
        HasCurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC) -> Standard_Boolean
        HasCurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF) -> Standard_Boolean

        Returns TRUE if the edge <aE>  has  P-Curve <aC>
        on surface <aF> .
        If the P-Curve does not exist, aC.IsNull()=TRUE.

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

    HasCurveOnSurface = staticmethod(HasCurveOnSurface)

    def AdjustPCurveOnFace(*args):
        """
        AdjustPCurveOnFace(TopoDS_Face theF, Handle_Geom_Curve theC3D, Handle_Geom2d_Curve theC2D, Handle_Geom2d_Curve theC2DA, Handle_IntTools_Context theContext)
        AdjustPCurveOnFace(TopoDS_Face theF, Standard_Real const theFirst, Standard_Real const theLast, Handle_Geom2d_Curve theC2D, Handle_Geom2d_Curve theC2DA, Handle_IntTools_Context theContext)

        Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .<br>
        [aT1,  aT2] - range to adjust<br>
        <theContext> - storage for caching the geometrical tools

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFirst: float
        :type theLast: float
        :type theC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theC2DA: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

    AdjustPCurveOnFace = staticmethod(AdjustPCurveOnFace)

    def AdjustPCurveOnSurf(*args):
        """
        AdjustPCurveOnSurf(BRepAdaptor_Surface aF, Standard_Real const aT1, Standard_Real const aT2, Handle_Geom2d_Curve aC2D, Handle_Geom2d_Curve aC2DA)

        Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .
        [aT1,  aT2] - range to adjust

        :type aF: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type aT1: float
        :type aT2: float
        :type aC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type aC2DA: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args)

    AdjustPCurveOnSurf = staticmethod(AdjustPCurveOnSurf)

    def IntermediatePoint(*args):
        """
        IntermediatePoint(Standard_Real const aFirst, Standard_Real const aLast) -> Standard_Real
        IntermediatePoint(TopoDS_Edge anE) -> Standard_Real

        Compute intermediate value of parameter for the edge <anE>.

        :type anE: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

    IntermediatePoint = staticmethod(IntermediatePoint)

    def Make2D(*args):
        """
        Make2D(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

        Make P-Curve <aC> for the edge <aE> on surface <aF> .<br>
        [aFirst, aLast] - range of the P-Curve<br>
        [aToler] - reached tolerance<br>
        Raises exception Standard_ConstructionError if algorithm fails.<br>
        <theContext> - storage for caching the geometrical tools

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type aFirst: float
        :type aLast: float
        :type aToler: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

    Make2D = staticmethod(Make2D)

    def MakePCurveOnFace(*args):
        """
        MakePCurveOnFace(TopoDS_Face aF, Handle_Geom_Curve C3D, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)
        MakePCurveOnFace(TopoDS_Face aF, Handle_Geom_Curve C3D, Standard_Real const aT1, Standard_Real const aT2, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

        Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> .<br>
        [aT1,  aT2] - range to build<br>
        [aToler] - reached tolerance<br>
        Raises exception Standard_ConstructionError if projection algorithm fails.<br>
        <theContext> - storage for caching the geometrical tools

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type aT1: float
        :type aT2: float
        :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type aToler: float
        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

    MakePCurveOnFace = staticmethod(MakePCurveOnFace)

    def AttachExistingPCurve(*args):
        """
        AttachExistingPCurve(TopoDS_Edge aEold, TopoDS_Edge aEnew, TopoDS_Face aF, Handle_IntTools_Context aCtx) -> Standard_Integer

        Attach P-Curve from the edge <aEold> on surface <aF>
        to the edge <aEnew>
        Returns 0 in case of success

        :type aEold: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aEnew: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_AlgoTools2D_AttachExistingPCurve(*args)

    AttachExistingPCurve = staticmethod(AttachExistingPCurve)

    def IsEdgeIsoline(*args):
        """
        IsEdgeIsoline(TopoDS_Edge theE, TopoDS_Face theF)

        Checks if CurveOnSurface of theE on theF matches with isoline of theF surface.
        Sets corresponding values for isTheUIso and isTheVIso variables.
        ATTENTION!!!
        This method is based on comparation between direction of
        surface (which theF is based on) iso-lines and the direction
        of the edge p-curve (on theF) in middle-point of the p-curve.
        This method should be used carefully
        (e.g. BRep_Tool::IsClosed(...) together) in order to
        avoid false classification some p-curves as isoline (e.g. circle
        on a plane).

        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type isTheUIso: bool
        :type isTheVIso: bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_IsEdgeIsoline(*args)

    IsEdgeIsoline = staticmethod(IsEdgeIsoline)

    def __init__(self):
        """
        The class contains handy static functions
        dealing with the topology
        This is the copy of the BOPTools_AlgoTools2D.cdl
        """
        this = _BOPTools.new_BOPTools_AlgoTools2D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools2D
BOPTools_AlgoTools2D_swigregister = _BOPTools.BOPTools_AlgoTools2D_swigregister
BOPTools_AlgoTools2D_swigregister(BOPTools_AlgoTools2D)

def BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args):
    """
    BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, Handle_IntTools_Context theContext)

    Compute P-Curve for the edge <aE> on the face <aF>.<br>
    Raises exception Standard_ConstructionError if projection algorithm fails.<br>
    <theContext> - storage for caching the geometrical tools

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

def BOPTools_AlgoTools2D_EdgeTangent(*args):
    """
    BOPTools_AlgoTools2D_EdgeTangent(TopoDS_Edge anE, Standard_Real const aT, gp_Vec Tau) -> Standard_Boolean

    Compute tangent for the edge  <aE> [in 3D]  at parameter <aT>

    :type anE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aT: float
    :type Tau: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

def BOPTools_AlgoTools2D_PointOnSurface(*args):
    """
    BOPTools_AlgoTools2D_PointOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aT, Handle_IntTools_Context theContext)

    Compute surface parameters <U,V> of the face <aF>
    for  the point from the edge <aE> at parameter <aT>.<br>
    If <aE> has't pcurve on surface, algorithm tries to get it by
    projection and can
    raise exception Standard_ConstructionError if projection algorithm fails.<br>
    <theContext> - storage for caching the geometrical tools

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aT: float
    :type U: float
    :type V: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

def BOPTools_AlgoTools2D_CurveOnSurface(*args):
    """
    CurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)
    BOPTools_AlgoTools2D_CurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

    Get P-Curve <aC>  for the edge <aE> on surface <aF> .<br>
    If the P-Curve does not exist, build  it using Make2D().<br>
    [aFirst, aLast] - range of the P-Curve<br>
    [aToler] - reached tolerance<br>
    Raises exception Standard_ConstructionError if algorithm Make2D() fails.<br>
    <theContext> - storage for caching the geometrical tools

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type aFirst: float
    :type aLast: float
    :type aToler: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_CurveOnSurface(*args)

def BOPTools_AlgoTools2D_HasCurveOnSurface(*args):
    """
    HasCurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC) -> Standard_Boolean
    BOPTools_AlgoTools2D_HasCurveOnSurface(TopoDS_Edge aE, TopoDS_Face aF) -> Standard_Boolean

    Returns TRUE if the edge <aE>  has  P-Curve <aC>
    on surface <aF> .
    If the P-Curve does not exist, aC.IsNull()=TRUE.

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

def BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args):
    """
    AdjustPCurveOnFace(TopoDS_Face theF, Handle_Geom_Curve theC3D, Handle_Geom2d_Curve theC2D, Handle_Geom2d_Curve theC2DA, Handle_IntTools_Context theContext)
    BOPTools_AlgoTools2D_AdjustPCurveOnFace(TopoDS_Face theF, Standard_Real const theFirst, Standard_Real const theLast, Handle_Geom2d_Curve theC2D, Handle_Geom2d_Curve theC2DA, Handle_IntTools_Context theContext)

    Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .<br>
    [aT1,  aT2] - range to adjust<br>
    <theContext> - storage for caching the geometrical tools

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theFirst: float
    :type theLast: float
    :type theC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theC2DA: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

def BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args):
    """
    BOPTools_AlgoTools2D_AdjustPCurveOnSurf(BRepAdaptor_Surface aF, Standard_Real const aT1, Standard_Real const aT2, Handle_Geom2d_Curve aC2D, Handle_Geom2d_Curve aC2DA)

    Adjust P-Curve <aC2D> (3D-curve <C3D>) on surface <aF> .
    [aT1,  aT2] - range to adjust

    :type aF: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type aT1: float
    :type aT2: float
    :type aC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type aC2DA: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args)

def BOPTools_AlgoTools2D_IntermediatePoint(*args):
    """
    IntermediatePoint(Standard_Real const aFirst, Standard_Real const aLast) -> Standard_Real
    BOPTools_AlgoTools2D_IntermediatePoint(TopoDS_Edge anE) -> Standard_Real

    Compute intermediate value of parameter for the edge <anE>.

    :type anE: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

def BOPTools_AlgoTools2D_Make2D(*args):
    """
    BOPTools_AlgoTools2D_Make2D(TopoDS_Edge aE, TopoDS_Face aF, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

    Make P-Curve <aC> for the edge <aE> on surface <aF> .<br>
    [aFirst, aLast] - range of the P-Curve<br>
    [aToler] - reached tolerance<br>
    Raises exception Standard_ConstructionError if algorithm fails.<br>
    <theContext> - storage for caching the geometrical tools

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type aFirst: float
    :type aLast: float
    :type aToler: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

def BOPTools_AlgoTools2D_MakePCurveOnFace(*args):
    """
    MakePCurveOnFace(TopoDS_Face aF, Handle_Geom_Curve C3D, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)
    BOPTools_AlgoTools2D_MakePCurveOnFace(TopoDS_Face aF, Handle_Geom_Curve C3D, Standard_Real const aT1, Standard_Real const aT2, Handle_Geom2d_Curve aC, Handle_IntTools_Context theContext)

    Make P-Curve <aC> for the 3D-curve <C3D> on surface <aF> .<br>
    [aT1,  aT2] - range to build<br>
    [aToler] - reached tolerance<br>
    Raises exception Standard_ConstructionError if projection algorithm fails.<br>
    <theContext> - storage for caching the geometrical tools

    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
    :type aT1: float
    :type aT2: float
    :type aC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type aToler: float
    :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

    """
    return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

def BOPTools_AlgoTools2D_AttachExistingPCurve(*args):
    """
    BOPTools_AlgoTools2D_AttachExistingPCurve(TopoDS_Edge aEold, TopoDS_Edge aEnew, TopoDS_Face aF, Handle_IntTools_Context aCtx) -> Standard_Integer

    Attach P-Curve from the edge <aEold> on surface <aF>
    to the edge <aEnew>
    Returns 0 in case of success

    :type aEold: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aEnew: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_AlgoTools2D_AttachExistingPCurve(*args)

def BOPTools_AlgoTools2D_IsEdgeIsoline(*args):
    """
    BOPTools_AlgoTools2D_IsEdgeIsoline(TopoDS_Edge theE, TopoDS_Face theF)

    Checks if CurveOnSurface of theE on theF matches with isoline of theF surface.
    Sets corresponding values for isTheUIso and isTheVIso variables.
    ATTENTION!!!
    This method is based on comparation between direction of
    surface (which theF is based on) iso-lines and the direction
    of the edge p-curve (on theF) in middle-point of the p-curve.
    This method should be used carefully
    (e.g. BRep_Tool::IsClosed(...) together) in order to
    avoid false classification some p-curves as isoline (e.g. circle
    on a plane).

    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type isTheUIso: bool
    :type isTheVIso: bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_IsEdgeIsoline(*args)

class BOPTools_BoxSelector_Bnd_Box(object):
    """
    Template Selector for the unbalanced binary tree
    of overlapped bounding boxes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """
        Template Selector for the unbalanced binary tree
        of overlapped bounding boxes.
        """
        this = _BOPTools.new_BOPTools_BoxSelector_Bnd_Box()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reject(self, *args):
        """
        Reject(BOPTools_BoxSelector_Bnd_Box self, Bnd_Box theOther) -> Standard_Boolean

        Checks if the box should be rejected

        :type theOther: const BoxType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_BoxSelector_Bnd_Box_Reject(self, *args)


    def Accept(self, *args):
        """
        Accept(BOPTools_BoxSelector_Bnd_Box self, Standard_Integer const & theIndex) -> Standard_Boolean

        Accepts the index

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_BoxSelector_Bnd_Box_Accept(self, *args)


    def Clear(self, *args):
        """
        Clear(BOPTools_BoxSelector_Bnd_Box self)

        Clears the indices


        """
        return _BOPTools.BOPTools_BoxSelector_Bnd_Box_Clear(self, *args)


    def SetBox(self, *args):
        """
        SetBox(BOPTools_BoxSelector_Bnd_Box self, Bnd_Box theBox)

        Sets the box

        :type theBox: const BoxType &

        """
        return _BOPTools.BOPTools_BoxSelector_Bnd_Box_SetBox(self, *args)


    def Indices(self, *args):
        """
        Returns the list of accepted indices

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BOPTools.BOPTools_BoxSelector_Bnd_Box_Indices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPTools.delete_BOPTools_BoxSelector_Bnd_Box
BOPTools_BoxSelector_Bnd_Box_swigregister = _BOPTools.BOPTools_BoxSelector_Bnd_Box_swigregister
BOPTools_BoxSelector_Bnd_Box_swigregister(BOPTools_BoxSelector_Bnd_Box)


try:
	BOPTools_BoxBndTreeSelector = BOPTools_BoxSelector_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_BOPTools_ConnexityBlock_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPTools.new_NCollection_List_BOPTools_ConnexityBlock_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_List_BOPTools_ConnexityBlock_IteratorHelper

    def __next__(self):
        return _BOPTools.NCollection_List_BOPTools_ConnexityBlock_IteratorHelper___next__(self)
NCollection_List_BOPTools_ConnexityBlock_IteratorHelper_swigregister = _BOPTools.NCollection_List_BOPTools_ConnexityBlock_IteratorHelper_swigregister
NCollection_List_BOPTools_ConnexityBlock_IteratorHelper_swigregister(NCollection_List_BOPTools_ConnexityBlock_IteratorHelper)


try:
	BOPTools_ListOfConnexityBlock = NCollection_List_BOPTools_ConnexityBlock
except NameError:
	pass # does not exist, probably ignored


try:
	BOPTools_BoxBndTree = NCollection_UBTree_Standard_Integer_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class BOPTools_CoupleOfShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BOPTools_CoupleOfShape self) -> BOPTools_CoupleOfShape"""
        this = _BOPTools.new_BOPTools_CoupleOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape1(self, *args):
        """
        SetShape1(BOPTools_CoupleOfShape self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape1(self, *args)


    def Shape1(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPTools.BOPTools_CoupleOfShape_Shape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape2(self, *args):
        """
        SetShape2(BOPTools_CoupleOfShape self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape2(self, *args)


    def Shape2(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPTools.BOPTools_CoupleOfShape_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BOPTools.delete_BOPTools_CoupleOfShape
BOPTools_CoupleOfShape_swigregister = _BOPTools.BOPTools_CoupleOfShape_swigregister
BOPTools_CoupleOfShape_swigregister(BOPTools_CoupleOfShape)

class NCollection_List_BOPTools_CoupleOfShape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPTools.new_NCollection_List_BOPTools_CoupleOfShape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_List_BOPTools_CoupleOfShape_IteratorHelper

    def __next__(self):
        return _BOPTools.NCollection_List_BOPTools_CoupleOfShape_IteratorHelper___next__(self)
NCollection_List_BOPTools_CoupleOfShape_IteratorHelper_swigregister = _BOPTools.NCollection_List_BOPTools_CoupleOfShape_IteratorHelper_swigregister
NCollection_List_BOPTools_CoupleOfShape_IteratorHelper_swigregister(NCollection_List_BOPTools_CoupleOfShape_IteratorHelper)


try:
	BOPTools_ListOfCoupleOfShape = NCollection_List_BOPTools_CoupleOfShape
except NameError:
	pass # does not exist, probably ignored

class BOPTools_Set(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BOPTools_Set self) -> BOPTools_Set
        __init__(BOPTools_Set self, Handle_NCollection_BaseAllocator theAllocator) -> BOPTools_Set

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _BOPTools.new_BOPTools_Set(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(BOPTools_Set self, BOPTools_Set Other) -> BOPTools_Set

        :type Other: OCC.wrapper.BOPTools.BOPTools_Set
        :rtype: OCC.wrapper.BOPTools.BOPTools_Set

        """
        return _BOPTools.BOPTools_Set_Assign(self, *args)


    def assign(self, *args):
        """
        assign(BOPTools_Set self, BOPTools_Set Other) -> BOPTools_Set

        :type Other: OCC.wrapper.BOPTools.BOPTools_Set
        :rtype: OCC.wrapper.BOPTools.BOPTools_Set

        """
        return _BOPTools.BOPTools_Set_assign(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BOPTools.BOPTools_Set_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Add(self, *args):
        """
        Add(BOPTools_Set self, TopoDS_Shape theS, TopAbs_ShapeEnum const theType)

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BOPTools.BOPTools_Set_Add(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(BOPTools_Set self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_Set_NbShapes(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(BOPTools_Set self, BOPTools_Set aOther) -> Standard_Boolean

        :type aOther: OCC.wrapper.BOPTools.BOPTools_Set
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_Set_IsEqual(self, *args)


    def HashCode(self, *args):
        """
        HashCode(BOPTools_Set self, Standard_Integer const Upper) -> Standard_Integer

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_Set_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(BOPTools_Set self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _BOPTools.BOPTools_Set___hash__(self, *args)

    __swig_destroy__ = _BOPTools.delete_BOPTools_Set
BOPTools_Set_swigregister = _BOPTools.BOPTools_Set_swigregister
BOPTools_Set_swigregister(BOPTools_Set)

class BOPTools_SetMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(BOPTools_Set aSet, Standard_Integer const Upper) -> Standard_Integer

        :type aSet: OCC.wrapper.BOPTools.BOPTools_Set
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(BOPTools_Set aSet1, BOPTools_Set aSet2) -> Standard_Boolean

        :type aSet1: OCC.wrapper.BOPTools.BOPTools_Set
        :type aSet2: OCC.wrapper.BOPTools.BOPTools_Set
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _BOPTools.new_BOPTools_SetMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_SetMapHasher
BOPTools_SetMapHasher_swigregister = _BOPTools.BOPTools_SetMapHasher_swigregister
BOPTools_SetMapHasher_swigregister(BOPTools_SetMapHasher)

def BOPTools_SetMapHasher_HashCode(*args):
    """
    BOPTools_SetMapHasher_HashCode(BOPTools_Set aSet, Standard_Integer const Upper) -> Standard_Integer

    :type aSet: OCC.wrapper.BOPTools.BOPTools_Set
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

def BOPTools_SetMapHasher_IsEqual(*args):
    """
    BOPTools_SetMapHasher_IsEqual(BOPTools_Set aSet1, BOPTools_Set aSet2) -> Standard_Boolean

    :type aSet1: OCC.wrapper.BOPTools.BOPTools_Set
    :type aSet2: OCC.wrapper.BOPTools.BOPTools_Set
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)

class NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self) -> NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self) -> NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _BOPTools.new_NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, BOPTools_Set K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, BOPTools_Set K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, BOPTools_Set K) -> Standard_Boolean
        Contains(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theLeft, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theLeft, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theLeft, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theLeft, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher self, NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_Differ(self, *args)


    def __iter__(self):
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher___iter__(self)
    __swig_destroy__ = _BOPTools.delete_NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher
NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_swigregister = _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_swigregister
NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_swigregister(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher)

class NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPTools.new_NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper

    def __next__(self):
        return _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper___next__(self)
NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper_swigregister = _BOPTools.NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper_swigregister
NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper_swigregister(NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher_IteratorHelper)


try:
	BOPTools_MapOfSet = NCollection_Map_BOPTools_Set_BOPTools_SetMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self) -> NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self) -> NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self) -> NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self) -> NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _BOPTools.new_NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher theOther) -> NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher theOther) -> NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1, TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Integer const theIndex, BOPTools_Set theKey1, TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self)

        RemoveLast


        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Integer const theIndex) -> TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1) -> TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, BOPTools_Set theKey1) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_Size(self, *args)


    def __iter__(self):
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher___iter__(self)
    __swig_destroy__ = _BOPTools.delete_NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher
NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_swigregister = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_swigregister
NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_swigregister(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher)

class NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BOPTools.new_NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper

    def __next__(self):
        return _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper_swigregister = _BOPTools.NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher_IteratorHelper)


try:
	BOPTools_IndexedDataMapOfSetShape = NCollection_IndexedDataMap_BOPTools_Set_TopoDS_Shape_BOPTools_SetMapHasher
except NameError:
	pass # does not exist, probably ignored




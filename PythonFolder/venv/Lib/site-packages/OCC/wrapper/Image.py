# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Image')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Image')
    _Image = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Image', [dirname(__file__)])
        except ImportError:
            import _Image
            return _Image
        try:
            _mod = imp.load_module('_Image', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Image = swig_import_helper()
    del swig_import_helper
else:
    import _Image
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Image.delete_SwigPyIterator

    def value(self):
        return _Image.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Image.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Image.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Image.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Image.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Image.SwigPyIterator_copy(self)

    def next(self):
        return _Image.SwigPyIterator_next(self)

    def __next__(self):
        return _Image.SwigPyIterator___next__(self)

    def previous(self):
        return _Image.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Image.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Image.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Image.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Image.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Image.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Image.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Image.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Image.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Image.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Image.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Image.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Image.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Image.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Image.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Image.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Image.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Image.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Image.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Image.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Image.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Image.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Image.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Image.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Image.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Image.ptr_to_number(item)
ptr_to_number = _Image.ptr_to_number

def HashCode(*args):
    return _Image.HashCode(*args)
HashCode = _Image.HashCode

def ptr_equal(a, b):
    return _Image.ptr_equal(a, b)
ptr_equal = _Image.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
Image_Format_UNKNOWN = _Image.Image_Format_UNKNOWN
Image_Format_Gray = _Image.Image_Format_Gray
Image_Format_Alpha = _Image.Image_Format_Alpha
Image_Format_RGB = _Image.Image_Format_RGB
Image_Format_BGR = _Image.Image_Format_BGR
Image_Format_RGB32 = _Image.Image_Format_RGB32
Image_Format_BGR32 = _Image.Image_Format_BGR32
Image_Format_RGBA = _Image.Image_Format_RGBA
Image_Format_BGRA = _Image.Image_Format_BGRA
Image_Format_GrayF = _Image.Image_Format_GrayF
Image_Format_AlphaF = _Image.Image_Format_AlphaF
Image_Format_RGBF = _Image.Image_Format_RGBF
Image_Format_BGRF = _Image.Image_Format_BGRF
Image_Format_RGBAF = _Image.Image_Format_RGBAF
Image_Format_BGRAF = _Image.Image_Format_BGRAF
class Image_VideoRecorder(Standard.Standard_Transient):
    """Video recording tool based on FFmpeg framework."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Image_VideoRecorder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Image_VideoRecorder(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Image.Image_VideoRecorder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Image.Image_VideoRecorder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Image_VideoRecorder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Image_VideoRecorder self) -> Image_VideoRecorder

        Empty constructor.


        """
        this = _Image.new_Image_VideoRecorder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Close(self, *args):
        """
        Close(Image_VideoRecorder self)

        Close the stream - stop recorder.


        """
        return _Image.Image_VideoRecorder_Close(self, *args)


    def Open(self, *args):
        """
        Open(Image_VideoRecorder self, char const * theFileName, Image_VideoParams const & theParams) -> Standard_Boolean

        Open output stream - initialize recorder.
        @param theFileName [in] video filename
        @param theParams   [in] video parameters

        :type theFileName: const char *
        :type theParams: OCC.wrapper.Image.Image_VideoParams
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Image_VideoRecorder_Open(self, *args)


    def ChangeFrame(self, *args):
        """
        ChangeFrame(Image_VideoRecorder self) -> Image_PixMap

        Access RGBA frame, should NOT be re-initialized outside.
        Note that image is expected to have upper-left origin.

        :rtype: OCC.wrapper.Image.Image_PixMap

        """
        return _Image.Image_VideoRecorder_ChangeFrame(self, *args)


    def FrameCount(self, *args):
        """
        FrameCount(Image_VideoRecorder self) -> int64_t

        Return current frame index.

        :rtype: int64_t

        """
        return _Image.Image_VideoRecorder_FrameCount(self, *args)


    def PushFrame(self, *args):
        """
        PushFrame(Image_VideoRecorder self) -> Standard_Boolean

        Push new frame, should be called after Open().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Image_VideoRecorder_PushFrame(self, *args)

    __swig_destroy__ = _Image.delete_Image_VideoRecorder
Image_VideoRecorder_swigregister = _Image.Image_VideoRecorder_swigregister
Image_VideoRecorder_swigregister(Image_VideoRecorder)

def Image_VideoRecorder_get_type_name(*args):
    """
    Image_VideoRecorder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Image.Image_VideoRecorder_get_type_name(*args)

def Image_VideoRecorder_get_type_descriptor(*args):
    """
    Image_VideoRecorder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Image.Image_VideoRecorder_get_type_descriptor(*args)

class Image_PixMap(Standard.Standard_Transient):
    """Class represents packed image plane."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Image_PixMap
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Image_PixMap(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Image.Image_PixMap_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Image.Image_PixMap_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Image_PixMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBigEndianHost(*args):
        """
        IsBigEndianHost() -> bool

        Determine Big-Endian at runtime

        :rtype: bool

        """
        return _Image.Image_PixMap_IsBigEndianHost(*args)

    IsBigEndianHost = staticmethod(IsBigEndianHost)

    def SwapRgbaBgra(*args):
        """
        SwapRgbaBgra(Image_PixMap theImage) -> bool

        Auxiliary method for swapping bytes between RGB and BGR formats.
        This method modifies the image data but does not change pixel format!
        Method will fail if pixel format is not one of the following:
        - Image_Format_RGB32 / Image_Format_BGR32
        - Image_Format_RGBA  / Image_Format_BGRA
        - Image_Format_RGB   / Image_Format_BGR
        - Image_Format_RGBF  / Image_Format_BGRF
        - Image_Format_RGBAF / Image_Format_BGRAF

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Image_PixMap_SwapRgbaBgra(*args)

    SwapRgbaBgra = staticmethod(SwapRgbaBgra)

    def ToBlackWhite(*args):
        """
        ToBlackWhite(Image_PixMap theImage)

        Convert image to Black/White.

        :type theImage: OCC.wrapper.Image.Image_PixMap

        """
        return _Image.Image_PixMap_ToBlackWhite(*args)

    ToBlackWhite = staticmethod(ToBlackWhite)

    def Format(self, *args):
        """
        Format(Image_PixMap self) -> Image_Format

        :rtype: OCC.wrapper.Image.Image_Format

        """
        return _Image.Image_PixMap_Format(self, *args)


    def SetFormat(self, *args):
        """
        SetFormat(Image_PixMap self, Image_Format const thePixelFormat)

        Override pixel format specified by InitXXX() methods.
        Will throw exception if pixel size of new format is not equal to currently initialized format.
        Intended to switch formats indicating different interpretation of the same data
        (e.g. ImgGray and ImgAlpha).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format

        """
        return _Image.Image_PixMap_SetFormat(self, *args)


    def Width(self, *args):
        """
        Width(Image_PixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_Width(self, *args)


    def Height(self, *args):
        """
        Height(Image_PixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_Height(self, *args)


    def SizeX(self, *args):
        """
        SizeX(Image_PixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(Image_PixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_SizeY(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Image_PixMap self) -> Standard_Real

        @return width / height.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Image.Image_PixMap_Ratio(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Image_PixMap self) -> bool

        @return true if data is NULL.

        :rtype: bool

        """
        return _Image.Image_PixMap_IsEmpty(self, *args)


    def __init__(self, *args):
        """
        __init__(Image_PixMap self) -> Image_PixMap

        Empty constructor. Initialize the NULL image plane.


        """
        this = _Image.new_Image_PixMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def PixelColor(self, *args):
        """
        PixelColor(Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY) -> Quantity_ColorRGBA

        Returns the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().
        @param theX column index from left
        @param theY row    index from top
        @return the pixel color

        :type theX: int
        :type theY: int
        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Image_PixMap_PixelColor(self, *args)


    def SetPixelColor(self, *args):
        """
        SetPixelColor(Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_Color theColor)
        SetPixelColor(Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_ColorRGBA theColor)

        Sets the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().

        :type theX: int
        :type theY: int
        :type theColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Image_PixMap_SetPixelColor(self, *args)


    def InitWrapper(self, *args):
        """
        InitWrapper(Image_PixMap self, Image_Format thePixelFormat, Standard_Byte * theDataPtr, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane as wrapper over alien data.
        Data will not be copied! Notice that caller should ensure
        that data pointer will not be released during this wrapper lifetime.
        You may call InitCopy() to perform data copying.

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theDataPtr: int
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Image_PixMap_InitWrapper(self, *args)


    def InitTrash(self, *args):
        """
        InitTrash(Image_PixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane with required dimensions.
        Memory will be left uninitialized (performance trick).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Image_PixMap_InitTrash(self, *args)


    def InitCopy(self, *args):
        """
        InitCopy(Image_PixMap self, Image_PixMap theCopy) -> bool

        Initialize by copying data.
        If you want to copy alien data you should create wrapper using InitWrapper() before.

        :type theCopy: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Image_PixMap_InitCopy(self, *args)


    def InitZero(self, *args):
        """
        InitZero(Image_PixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0, Standard_Byte const theValue=0) -> bool

        Initialize image plane with required dimensions.
        Buffer will be zeroed (black color for most formats).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :type theValue: int
        :rtype: bool

        """
        return _Image.Image_PixMap_InitZero(self, *args)


    def Clear(self, *args):
        """
        Clear(Image_PixMap self)

        Method correctly deallocate internal buffer.


        """
        return _Image.Image_PixMap_Clear(self, *args)


    def IsTopDown(self, *args):
        """
        IsTopDown(Image_PixMap self) -> bool

        Returns TRUE if image data is stored from Top to the Down.
        By default Bottom Up order is used instead
        (topmost scanlines starts from the bottom in memory).
        which is most image frameworks naturally support.

        Notice that access methods within this class automatically
        convert input row-index to apply this flag!
        You should use this flag only if interconnect with alien APIs and buffers.
        @return true if image data is top-down

        :rtype: bool

        """
        return _Image.Image_PixMap_IsTopDown(self, *args)


    def SetTopDown(self, *args):
        """
        SetTopDown(Image_PixMap self, bool const theIsTopDown)

        Setup scanlines order in memory - top-down or bottom-up.
        Drawers should explicitly specify this value if current state IsTopDown() was ignored!
        @param theIsTopDown top-down flag

        :type theIsTopDown: const bool

        """
        return _Image.Image_PixMap_SetTopDown(self, *args)


    def TopDownInc(self, *args):
        """
        TopDownInc(Image_PixMap self) -> Standard_Size

        Returns +1 if scanlines ordered in Top->Down order in memory and -1 otherwise.
        @return scanline increment for Top->Down iteration

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_TopDownInc(self, *args)


    def Data(self, *args):
        """
        Data(Image_PixMap self) -> Standard_Byte const *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMap_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(Image_PixMap self) -> Standard_Byte *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMap_ChangeData(self, *args)


    def Row(self, *args):
        """
        Row(Image_PixMap self, Standard_Size const theRow) -> Standard_Byte const *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMap_Row(self, *args)


    def ChangeRow(self, *args):
        """
        ChangeRow(Image_PixMap self, Standard_Size const theRow) -> Standard_Byte *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMap_ChangeRow(self, *args)


    def SizePixelBytes(*args):
        """
        SizePixelBytes() -> Standard_Size
        SizePixelBytes(Image_Format const thePixelFormat) -> Standard_Size

        @return bytes reserved for one pixel (may include extra bytes for alignment).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_SizePixelBytes(*args)

    SizePixelBytes = staticmethod(SizePixelBytes)

    def SizeRowBytes(self, *args):
        """
        SizeRowBytes(Image_PixMap self) -> Standard_Size

        @return bytes reserved per row.
        Could be larger than needed to store packed row (extra bytes for alignment etc.).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_SizeRowBytes(self, *args)


    def RowExtraBytes(self, *args):
        """
        RowExtraBytes(Image_PixMap self) -> Standard_Size

        @return the extra bytes in the row.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_RowExtraBytes(self, *args)


    def MaxRowAligmentBytes(self, *args):
        """
        MaxRowAligmentBytes(Image_PixMap self) -> Standard_Size

        Compute the maximal row alignment for current row size.
        @return maximal row alignment in bytes (up to 16 bytes).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_MaxRowAligmentBytes(self, *args)


    def SizeBytes(self, *args):
        """
        SizeBytes(Image_PixMap self) -> Standard_Size

        @return buffer size

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMap_SizeBytes(self, *args)

    __swig_destroy__ = _Image.delete_Image_PixMap
Image_PixMap_swigregister = _Image.Image_PixMap_swigregister
Image_PixMap_swigregister(Image_PixMap)

def Image_PixMap_get_type_name(*args):
    """
    Image_PixMap_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Image.Image_PixMap_get_type_name(*args)

def Image_PixMap_get_type_descriptor(*args):
    """
    Image_PixMap_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Image.Image_PixMap_get_type_descriptor(*args)

def Image_PixMap_IsBigEndianHost(*args):
    """
    Image_PixMap_IsBigEndianHost() -> bool

    Determine Big-Endian at runtime

    :rtype: bool

    """
    return _Image.Image_PixMap_IsBigEndianHost(*args)

def Image_PixMap_SwapRgbaBgra(*args):
    """
    Image_PixMap_SwapRgbaBgra(Image_PixMap theImage) -> bool

    Auxiliary method for swapping bytes between RGB and BGR formats.
    This method modifies the image data but does not change pixel format!
    Method will fail if pixel format is not one of the following:
    - Image_Format_RGB32 / Image_Format_BGR32
    - Image_Format_RGBA  / Image_Format_BGRA
    - Image_Format_RGB   / Image_Format_BGR
    - Image_Format_RGBF  / Image_Format_BGRF
    - Image_Format_RGBAF / Image_Format_BGRAF

    :type theImage: OCC.wrapper.Image.Image_PixMap
    :rtype: bool

    """
    return _Image.Image_PixMap_SwapRgbaBgra(*args)

def Image_PixMap_ToBlackWhite(*args):
    """
    Image_PixMap_ToBlackWhite(Image_PixMap theImage)

    Convert image to Black/White.

    :type theImage: OCC.wrapper.Image.Image_PixMap

    """
    return _Image.Image_PixMap_ToBlackWhite(*args)

def Image_PixMap_SizePixelBytes(*args):
    """
    SizePixelBytes() -> Standard_Size
    Image_PixMap_SizePixelBytes(Image_Format const thePixelFormat) -> Standard_Size

    @return bytes reserved for one pixel (may include extra bytes for alignment).

    :type thePixelFormat: OCC.wrapper.Image.Image_Format
    :rtype: OCC.wrapper.Standard.Standard_Size

    """
    return _Image.Image_PixMap_SizePixelBytes(*args)

class Image_AlienPixMap(Image_PixMap):
    """
    Image class that support file reading/writing operations using auxiliary image library.
    Supported image formats:
    - *.bmp - bitmap image, lossless format without compression.
    - *.ppm - PPM (Portable Pixmap Format), lossless format without compression.
    - *.png - PNG (Portable Network Graphics) lossless format with compression.
    - *.jpg, *.jpe, *.jpeg - JPEG/JIFF (Joint Photographic Experts Group) lossy format (compressed with quality losses). YUV color space used (automatically converted from/to RGB).
    - *.tif, *.tiff - TIFF (Tagged Image File Format).
    - *.tga - TGA (Truevision Targa Graphic), lossless format.
    - *.gif - GIF (Graphical Interchange Format), lossy format. Color stored using palette (up to 256 distinct colors).
    - *.exr - OpenEXR high dynamic-range format (supports float pixel formats). 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Image_AlienPixMap
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Image_AlienPixMap(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Image.Image_AlienPixMap_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Image.Image_AlienPixMap_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Image_AlienPixMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(Image_AlienPixMap self) -> Image_AlienPixMap

        Empty constructor.


        """
        this = _Image.new_Image_AlienPixMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Load(self, *args):
        """
        Load(Image_AlienPixMap self, TCollection_AsciiString theFileName) -> bool

        Read image data from file.

        :type theFileName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: bool

        """
        return _Image.Image_AlienPixMap_Load(self, *args)


    def Save(self, *args):
        """
        Save(Image_AlienPixMap self, TCollection_AsciiString theFileName) -> bool

        Write image data to file using file extension to determine compression format.

        :type theFileName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: bool

        """
        return _Image.Image_AlienPixMap_Save(self, *args)


    def InitTrash(self, *args):
        """
        InitTrash(Image_AlienPixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane with required dimensions.
        thePixelFormat - if specified pixel format doesn't supported by image library
        than nearest supported will be used instead!
        theSizeRowBytes - may be ignored by this class and required alignemnt will be used instead!

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Image_AlienPixMap_InitTrash(self, *args)


    def InitCopy(self, *args):
        """
        InitCopy(Image_AlienPixMap self, Image_PixMap theCopy) -> bool

        Initialize by copying data.

        :type theCopy: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Image_AlienPixMap_InitCopy(self, *args)


    def Clear(self, *args):
        """
        Clear(Image_AlienPixMap self)

        Method correctly deallocate internal buffer.


        """
        return _Image.Image_AlienPixMap_Clear(self, *args)


    def AdjustGamma(self, *args):
        """
        AdjustGamma(Image_AlienPixMap self, Standard_Real const theGammaCorr) -> bool

        Performs gamma correction on image.
        theGamma - gamma value to use; a value of 1.0 leaves the image alone

        :type theGammaCorr: float
        :rtype: bool

        """
        return _Image.Image_AlienPixMap_AdjustGamma(self, *args)


    def InitWrapper(self, thePixelFormat, theDataPtr, theSizeX, theSizeY, theSizeRowBytes):
        return _Image.Image_AlienPixMap_InitWrapper(self, thePixelFormat, theDataPtr, theSizeX, theSizeY, theSizeRowBytes)
    __swig_destroy__ = _Image.delete_Image_AlienPixMap
Image_AlienPixMap_swigregister = _Image.Image_AlienPixMap_swigregister
Image_AlienPixMap_swigregister(Image_AlienPixMap)

def Image_AlienPixMap_get_type_name(*args):
    """
    Image_AlienPixMap_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Image.Image_AlienPixMap_get_type_name(*args)

def Image_AlienPixMap_get_type_descriptor(*args):
    """
    Image_AlienPixMap_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Image.Image_AlienPixMap_get_type_descriptor(*args)

class Image_PixMapData(NCollection.NCollection_Buffer):
    """Structure to manage image buffer."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Image_PixMapData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Image_PixMapData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Image_PixMapData self) -> Image_PixMapData

        Empty constructor.


        """
        this = _Image.new_Image_PixMapData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(Image_PixMapData self, Handle_NCollection_BaseAllocator theAlloc, Standard_Size const theSizeBPP, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes, Standard_Byte * theDataPtr)

        Initializer.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :type theSizeBPP: int
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :type theDataPtr: int

        """
        return _Image.Image_PixMapData_Init(self, *args)


    def Row(self, *args):
        """
        Row(Image_PixMapData self, Standard_Size const theRow) -> Standard_Byte const *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMapData_Row(self, *args)


    def ChangeRow(self, *args):
        """
        ChangeRow(Image_PixMapData self, Standard_Size const theRow) -> Standard_Byte *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMapData_ChangeRow(self, *args)


    def Value(self, *args):
        """
        Value(Image_PixMapData self, Standard_Size const theRow, Standard_Size const theCol) -> Standard_Byte const *

        @return data pointer to requested position.

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMapData_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(Image_PixMapData self, Standard_Size const theRow, Standard_Size const theCol) -> Standard_Byte *

        @return data pointer to requested position.

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Image_PixMapData_ChangeValue(self, *args)


    def MaxRowAligmentBytes(self, *args):
        """
        MaxRowAligmentBytes(Image_PixMapData self) -> Standard_Size

        Compute the maximal row alignment for current row size.
        @return maximal row alignment in bytes (up to 16 bytes).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Image_PixMapData_MaxRowAligmentBytes(self, *args)


    def SetTopDown(self, *args):
        """
        SetTopDown(Image_PixMapData self, bool const theIsTopDown)

        Setup scanlines order in memory - top-down or bottom-up.
        Drawers should explicitly specify this value if current state IsTopDown() was ignored!
        @param theIsTopDown top-down flag

        :type theIsTopDown: const bool

        """
        return _Image.Image_PixMapData_SetTopDown(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Image.Image_PixMapData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Image.Image_PixMapData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Image_PixMapData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Image.delete_Image_PixMapData
Image_PixMapData_swigregister = _Image.Image_PixMapData_swigregister
Image_PixMapData_swigregister(Image_PixMapData)

def Image_PixMapData_get_type_name(*args):
    """
    Image_PixMapData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Image.Image_PixMapData_get_type_name(*args)

def Image_PixMapData_get_type_descriptor(*args):
    """
    Image_PixMapData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Image.Image_PixMapData_get_type_descriptor(*args)

class Handle_Image_VideoRecorder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Image_VideoRecorder self)

        Nullify the handle


        """
        return _Image.Handle_Image_VideoRecorder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Image_VideoRecorder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Image.Handle_Image_VideoRecorder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Image_VideoRecorder self, Image_VideoRecorder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Image.Handle_Image_VideoRecorder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Image_VideoRecorder self, Handle_Image_VideoRecorder theHandle) -> Handle_Image_VideoRecorder
        assign(Handle_Image_VideoRecorder self, Image_VideoRecorder thePtr) -> Handle_Image_VideoRecorder
        assign(Handle_Image_VideoRecorder self, Handle_Image_VideoRecorder theHandle) -> Handle_Image_VideoRecorder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Image.Handle_Image_VideoRecorder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Image_VideoRecorder self) -> Image_VideoRecorder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Image.Handle_Image_VideoRecorder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Image_VideoRecorder self) -> Image_VideoRecorder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Image.Handle_Image_VideoRecorder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Image_VideoRecorder self) -> Image_VideoRecorder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Image.Handle_Image_VideoRecorder___ref__(self, *args)


    def __hash__(self):
        return _Image.Handle_Image_VideoRecorder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Image.Handle_Image_VideoRecorder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Image.new_Handle_Image_VideoRecorder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Image.Handle_Image_VideoRecorder_DownCast)
    __swig_destroy__ = _Image.delete_Handle_Image_VideoRecorder

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Image_VideoRecorder self) -> char const *

        :rtype: const char *

        """
        return _Image.Handle_Image_VideoRecorder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_VideoRecorder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_VideoRecorder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Close(self, *args):
        """
        Close(Handle_Image_VideoRecorder self)

        Close the stream - stop recorder.


        """
        return _Image.Handle_Image_VideoRecorder_Close(self, *args)


    def Open(self, *args):
        """
        Open(Handle_Image_VideoRecorder self, char const * theFileName, Image_VideoParams const & theParams) -> Standard_Boolean

        Open output stream - initialize recorder.
        @param theFileName [in] video filename
        @param theParams   [in] video parameters

        :type theFileName: const char *
        :type theParams: OCC.wrapper.Image.Image_VideoParams
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_VideoRecorder_Open(self, *args)


    def ChangeFrame(self, *args):
        """
        ChangeFrame(Handle_Image_VideoRecorder self) -> Image_PixMap

        Access RGBA frame, should NOT be re-initialized outside.
        Note that image is expected to have upper-left origin.

        :rtype: OCC.wrapper.Image.Image_PixMap

        """
        return _Image.Handle_Image_VideoRecorder_ChangeFrame(self, *args)


    def FrameCount(self, *args):
        """
        FrameCount(Handle_Image_VideoRecorder self) -> int64_t

        Return current frame index.

        :rtype: int64_t

        """
        return _Image.Handle_Image_VideoRecorder_FrameCount(self, *args)


    def PushFrame(self, *args):
        """
        PushFrame(Handle_Image_VideoRecorder self) -> Standard_Boolean

        Push new frame, should be called after Open().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_VideoRecorder_PushFrame(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Image_VideoRecorder self)

        Memory deallocator for transient classes


        """
        return _Image.Handle_Image_VideoRecorder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Image_VideoRecorder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Image_VideoRecorder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_VideoRecorder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Image_VideoRecorder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Image_VideoRecorder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_VideoRecorder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Image_VideoRecorder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Image.Handle_Image_VideoRecorder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Image_VideoRecorder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_VideoRecorder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Image_VideoRecorder self)

        Increments the reference counter of this object


        """
        return _Image.Handle_Image_VideoRecorder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Image_VideoRecorder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_VideoRecorder_DecrementRefCounter(self, *args)

Handle_Image_VideoRecorder_swigregister = _Image.Handle_Image_VideoRecorder_swigregister
Handle_Image_VideoRecorder_swigregister(Handle_Image_VideoRecorder)

def Handle_Image_VideoRecorder_DownCast(thing):
    return _Image.Handle_Image_VideoRecorder_DownCast(thing)
Handle_Image_VideoRecorder_DownCast = _Image.Handle_Image_VideoRecorder_DownCast

class Handle_Image_PixMap(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Image_PixMap self)

        Nullify the handle


        """
        return _Image.Handle_Image_PixMap_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Image_PixMap self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Image_PixMap self, Image_PixMap thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Image.Handle_Image_PixMap_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Image_PixMap self, Handle_Image_PixMap theHandle) -> Handle_Image_PixMap
        assign(Handle_Image_PixMap self, Image_PixMap thePtr) -> Handle_Image_PixMap
        assign(Handle_Image_PixMap self, Handle_Image_PixMap theHandle) -> Handle_Image_PixMap

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Image.Handle_Image_PixMap_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Image_PixMap self) -> Image_PixMap

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Image.Handle_Image_PixMap_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Image_PixMap self) -> Image_PixMap

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Image.Handle_Image_PixMap___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Image_PixMap self) -> Image_PixMap

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Image.Handle_Image_PixMap___ref__(self, *args)


    def __hash__(self):
        return _Image.Handle_Image_PixMap___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Image.Handle_Image_PixMap___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Image.new_Handle_Image_PixMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Image.Handle_Image_PixMap_DownCast)
    __swig_destroy__ = _Image.delete_Handle_Image_PixMap

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Image_PixMap self) -> char const *

        :rtype: const char *

        """
        return _Image.Handle_Image_PixMap_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_PixMap_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_PixMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsBigEndianHost(self, *args):
        """
        IsBigEndianHost(Handle_Image_PixMap self) -> bool

        Determine Big-Endian at runtime

        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_IsBigEndianHost(self, *args)


    def SwapRgbaBgra(self, *args):
        """
        SwapRgbaBgra(Handle_Image_PixMap self, Image_PixMap theImage) -> bool

        Auxiliary method for swapping bytes between RGB and BGR formats.
        This method modifies the image data but does not change pixel format!
        Method will fail if pixel format is not one of the following:
        - Image_Format_RGB32 / Image_Format_BGR32
        - Image_Format_RGBA  / Image_Format_BGRA
        - Image_Format_RGB   / Image_Format_BGR
        - Image_Format_RGBF  / Image_Format_BGRF
        - Image_Format_RGBAF / Image_Format_BGRAF

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_SwapRgbaBgra(self, *args)


    def ToBlackWhite(self, *args):
        """
        ToBlackWhite(Handle_Image_PixMap self, Image_PixMap theImage)

        Convert image to Black/White.

        :type theImage: OCC.wrapper.Image.Image_PixMap

        """
        return _Image.Handle_Image_PixMap_ToBlackWhite(self, *args)


    def Format(self, *args):
        """
        Format(Handle_Image_PixMap self) -> Image_Format

        :rtype: OCC.wrapper.Image.Image_Format

        """
        return _Image.Handle_Image_PixMap_Format(self, *args)


    def SetFormat(self, *args):
        """
        SetFormat(Handle_Image_PixMap self, Image_Format const thePixelFormat)

        Override pixel format specified by InitXXX() methods.
        Will throw exception if pixel size of new format is not equal to currently initialized format.
        Intended to switch formats indicating different interpretation of the same data
        (e.g. ImgGray and ImgAlpha).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format

        """
        return _Image.Handle_Image_PixMap_SetFormat(self, *args)


    def Width(self, *args):
        """
        Width(Handle_Image_PixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_Width(self, *args)


    def Height(self, *args):
        """
        Height(Handle_Image_PixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_Height(self, *args)


    def SizeX(self, *args):
        """
        SizeX(Handle_Image_PixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(Handle_Image_PixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_SizeY(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Handle_Image_PixMap self) -> Standard_Real

        @return width / height.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Image.Handle_Image_PixMap_Ratio(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Image_PixMap self) -> bool

        @return true if data is NULL.

        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_IsEmpty(self, *args)


    def PixelColor(self, *args):
        """
        PixelColor(Handle_Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY) -> Quantity_ColorRGBA

        Returns the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().
        @param theX column index from left
        @param theY row    index from top
        @return the pixel color

        :type theX: int
        :type theY: int
        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Handle_Image_PixMap_PixelColor(self, *args)


    def SetPixelColor(self, *args):
        """
        SetPixelColor(Handle_Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_Color theColor)
        SetPixelColor(Handle_Image_PixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_ColorRGBA theColor)

        Sets the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().

        :type theX: int
        :type theY: int
        :type theColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Handle_Image_PixMap_SetPixelColor(self, *args)


    def InitWrapper(self, *args):
        """
        InitWrapper(Handle_Image_PixMap self, Image_Format thePixelFormat, Standard_Byte * theDataPtr, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane as wrapper over alien data.
        Data will not be copied! Notice that caller should ensure
        that data pointer will not be released during this wrapper lifetime.
        You may call InitCopy() to perform data copying.

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theDataPtr: int
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_InitWrapper(self, *args)


    def InitTrash(self, *args):
        """
        InitTrash(Handle_Image_PixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane with required dimensions.
        Memory will be left uninitialized (performance trick).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_InitTrash(self, *args)


    def InitCopy(self, *args):
        """
        InitCopy(Handle_Image_PixMap self, Image_PixMap theCopy) -> bool

        Initialize by copying data.
        If you want to copy alien data you should create wrapper using InitWrapper() before.

        :type theCopy: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_InitCopy(self, *args)


    def InitZero(self, *args):
        """
        InitZero(Handle_Image_PixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0, Standard_Byte const theValue=0) -> bool

        Initialize image plane with required dimensions.
        Buffer will be zeroed (black color for most formats).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :type theValue: int
        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_InitZero(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_Image_PixMap self)

        Method correctly deallocate internal buffer.


        """
        return _Image.Handle_Image_PixMap_Clear(self, *args)


    def IsTopDown(self, *args):
        """
        IsTopDown(Handle_Image_PixMap self) -> bool

        Returns TRUE if image data is stored from Top to the Down.
        By default Bottom Up order is used instead
        (topmost scanlines starts from the bottom in memory).
        which is most image frameworks naturally support.

        Notice that access methods within this class automatically
        convert input row-index to apply this flag!
        You should use this flag only if interconnect with alien APIs and buffers.
        @return true if image data is top-down

        :rtype: bool

        """
        return _Image.Handle_Image_PixMap_IsTopDown(self, *args)


    def SetTopDown(self, *args):
        """
        SetTopDown(Handle_Image_PixMap self, bool const theIsTopDown)

        Setup scanlines order in memory - top-down or bottom-up.
        Drawers should explicitly specify this value if current state IsTopDown() was ignored!
        @param theIsTopDown top-down flag

        :type theIsTopDown: const bool

        """
        return _Image.Handle_Image_PixMap_SetTopDown(self, *args)


    def TopDownInc(self, *args):
        """
        TopDownInc(Handle_Image_PixMap self) -> Standard_Size

        Returns +1 if scanlines ordered in Top->Down order in memory and -1 otherwise.
        @return scanline increment for Top->Down iteration

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_TopDownInc(self, *args)


    def Data(self, *args):
        """
        Data(Handle_Image_PixMap self) -> Standard_Byte const *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMap_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(Handle_Image_PixMap self) -> Standard_Byte *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMap_ChangeData(self, *args)


    def Row(self, *args):
        """
        Row(Handle_Image_PixMap self, Standard_Size const theRow) -> Standard_Byte const *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMap_Row(self, *args)


    def ChangeRow(self, *args):
        """
        ChangeRow(Handle_Image_PixMap self, Standard_Size const theRow) -> Standard_Byte *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMap_ChangeRow(self, *args)


    def SizePixelBytes(self, *args):
        """
        SizePixelBytes(Handle_Image_PixMap self) -> Standard_Size
        SizePixelBytes(Handle_Image_PixMap self, Image_Format const thePixelFormat) -> Standard_Size

        @return bytes reserved for one pixel (may include extra bytes for alignment).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_SizePixelBytes(self, *args)


    def SizeRowBytes(self, *args):
        """
        SizeRowBytes(Handle_Image_PixMap self) -> Standard_Size

        @return bytes reserved per row.
        Could be larger than needed to store packed row (extra bytes for alignment etc.).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_SizeRowBytes(self, *args)


    def RowExtraBytes(self, *args):
        """
        RowExtraBytes(Handle_Image_PixMap self) -> Standard_Size

        @return the extra bytes in the row.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_RowExtraBytes(self, *args)


    def MaxRowAligmentBytes(self, *args):
        """
        MaxRowAligmentBytes(Handle_Image_PixMap self) -> Standard_Size

        Compute the maximal row alignment for current row size.
        @return maximal row alignment in bytes (up to 16 bytes).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_MaxRowAligmentBytes(self, *args)


    def SizeBytes(self, *args):
        """
        SizeBytes(Handle_Image_PixMap self) -> Standard_Size

        @return buffer size

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMap_SizeBytes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Image_PixMap self)

        Memory deallocator for transient classes


        """
        return _Image.Handle_Image_PixMap_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Image_PixMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Image_PixMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_PixMap_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Image_PixMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Image_PixMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_PixMap_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Image_PixMap self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Image.Handle_Image_PixMap_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Image_PixMap self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_PixMap_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Image_PixMap self)

        Increments the reference counter of this object


        """
        return _Image.Handle_Image_PixMap_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Image_PixMap self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_PixMap_DecrementRefCounter(self, *args)

Handle_Image_PixMap_swigregister = _Image.Handle_Image_PixMap_swigregister
Handle_Image_PixMap_swigregister(Handle_Image_PixMap)

def Handle_Image_PixMap_DownCast(thing):
    return _Image.Handle_Image_PixMap_DownCast(thing)
Handle_Image_PixMap_DownCast = _Image.Handle_Image_PixMap_DownCast

class Image_Diff(Standard.Standard_Transient):
    """
    This class compares two images pixel-by-pixel.
    It uses the following methods to ignore the difference between images:
    - Black/White comparison. It makes the images 2-colored before the comparison.
    - Equality with tolerance. Colors of two pixels are considered the same if the
    differnce of their color is less than a tolerance.
    - Border filter. The algorithm ignores alone independent pixels,
    which are different on both images, ignores the "border effect" -
    the difference caused by triangles located at angle about 0 or 90 degrees to the user.

    Border filter ignores a difference in implementation of
    anti-aliasing and other effects on boundary of a shape.
    The triangles of a boundary zone are usually located so that their normals point aside the user
    (about 90 degree between the normal and the direction to the user's eye).
    Deflection of the light for such a triangle depends on implementation of the video driver.
    In order to skip this difference the following algorithm is used:
    a) "Different" pixels are groupped and checked on "one-pixel width line".
    indeed, the pixels may represent not a line, but any curve.
    But the width of this curve should be not more than a pixel.
    This group of pixels become a candidate to be ignored because of boundary effect.
    b) The group of pixels is checked on belonging to a "shape".
    Neighbour pixels are checked from the reference image.
    This test confirms a fact that the group of pixels belongs to a shape and
    represent a boundary of the shape.
    In this case the whole group of pixels is ignored (considered as same).
    Otherwise, the group of pixels may represent a geometrical curve in the viewer 3D
    and should be considered as "different".

    References:
    1. http://pdiff.sourceforge.net/ypg01.pdf
    2. http://pdiff.sourceforge.net/metric.html
    3. http://www.cs.ucf.edu/~sumant/publications/sig99.pdf
    4. http://www.worldscientific.com/worldscibooks/10.1142/2641#t=toc (there is a list of articles and books in PDF format)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Image_Diff
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Image_Diff(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Image_Diff self) -> Image_Diff

        An empty constructor. Init() should be called for initialization.


        """
        this = _Image.new_Image_Diff(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(Image_Diff self, Handle_Image_PixMap theImageRef, Handle_Image_PixMap theImageNew, Standard_Boolean const theToBlackWhite) -> Standard_Boolean
        Init(Image_Diff self, TCollection_AsciiString theImgPathRef, TCollection_AsciiString theImgPathNew, Standard_Boolean const theToBlackWhite) -> Standard_Boolean

        Initialize algorithm by two images (will be loaded from files).
        @return false if images couldn't be opened or their format is unsupported.

        :type theImgPathRef: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theImgPathNew: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theToBlackWhite: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Image_Diff_Init(self, *args)


    def SetColorTolerance(self, *args):
        """
        SetColorTolerance(Image_Diff self, Standard_Real const theTolerance)

        Color tolerance for equality check. Should be within range 0..1:
        Corresponds to a difference between white and black colors (maximum difference).
        By default, the tolerance is equal to 0 thus equality check will return false for any different colors.

        :type theTolerance: float

        """
        return _Image.Image_Diff_SetColorTolerance(self, *args)


    def ColorTolerance(self, *args):
        """
        ColorTolerance(Image_Diff self) -> Standard_Real

        Color tolerance for equality check.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Image.Image_Diff_ColorTolerance(self, *args)


    def SetBorderFilterOn(self, *args):
        """
        SetBorderFilterOn(Image_Diff self, Standard_Boolean const theToIgnore)

        Sets taking into account (ignoring) a "border effect" on comparison of images.
        The border effect is caused by a border of shaded shapes in the viewer 3d.
        Triangles of this area are located at about 0 or 90 degrees to the user.
        Therefore, they deflect light differently according to implementation of a video card driver.
        This flag allows to detect such a "border" area and skip it from comparison of images.
        Filter turned OFF by default.

        :type theToIgnore: bool

        """
        return _Image.Image_Diff_SetBorderFilterOn(self, *args)


    def IsBorderFilterOn(self, *args):
        """
        IsBorderFilterOn(Image_Diff self) -> Standard_Boolean

        Returns a flag of taking into account (ignoring) a border effect in comparison of images.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Image_Diff_IsBorderFilterOn(self, *args)


    def Compare(self, *args):
        """
        Compare(Image_Diff self) -> Standard_Integer

        Compares two images. It returns a number of different pixels (or groups of pixels).
        It returns -1 if algorithm not initialized before.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Image_Diff_Compare(self, *args)


    def SaveDiffImage(self, *args):
        """
        SaveDiffImage(Image_Diff self, Image_PixMap theDiffImage) -> Standard_Boolean
        SaveDiffImage(Image_Diff self, TCollection_AsciiString theDiffPath) -> Standard_Boolean

        Saves a difference between two images as white pixels on black backgroud.

        :type theDiffPath: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Image_Diff_SaveDiffImage(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Image.Image_Diff_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Image.Image_Diff_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Image_Diff_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Image.delete_Image_Diff
Image_Diff_swigregister = _Image.Image_Diff_swigregister
Image_Diff_swigregister(Image_Diff)

def Image_Diff_get_type_name(*args):
    """
    Image_Diff_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Image.Image_Diff_get_type_name(*args)

def Image_Diff_get_type_descriptor(*args):
    """
    Image_Diff_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Image.Image_Diff_get_type_descriptor(*args)

class Handle_Image_Diff(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Image_Diff self)

        Nullify the handle


        """
        return _Image.Handle_Image_Diff_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Image_Diff self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Image.Handle_Image_Diff_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Image_Diff self, Image_Diff thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Image.Handle_Image_Diff_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Image_Diff self, Handle_Image_Diff theHandle) -> Handle_Image_Diff
        assign(Handle_Image_Diff self, Image_Diff thePtr) -> Handle_Image_Diff
        assign(Handle_Image_Diff self, Handle_Image_Diff theHandle) -> Handle_Image_Diff

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Image.Handle_Image_Diff_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Image_Diff self) -> Image_Diff

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Image.Handle_Image_Diff_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Image_Diff self) -> Image_Diff

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Image.Handle_Image_Diff___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Image_Diff self) -> Image_Diff

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Image.Handle_Image_Diff___ref__(self, *args)


    def __hash__(self):
        return _Image.Handle_Image_Diff___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Image.Handle_Image_Diff___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Image.new_Handle_Image_Diff(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Image.Handle_Image_Diff_DownCast)
    __swig_destroy__ = _Image.delete_Handle_Image_Diff

    def Init(self, *args):
        """
        Init(Handle_Image_Diff self, Handle_Image_PixMap theImageRef, Handle_Image_PixMap theImageNew, Standard_Boolean const theToBlackWhite) -> Standard_Boolean
        Init(Handle_Image_Diff self, TCollection_AsciiString theImgPathRef, TCollection_AsciiString theImgPathNew, Standard_Boolean const theToBlackWhite) -> Standard_Boolean

        Initialize algorithm by two images (will be loaded from files).
        @return false if images couldn't be opened or their format is unsupported.

        :type theImgPathRef: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theImgPathNew: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theToBlackWhite: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_Diff_Init(self, *args)


    def SetColorTolerance(self, *args):
        """
        SetColorTolerance(Handle_Image_Diff self, Standard_Real const theTolerance)

        Color tolerance for equality check. Should be within range 0..1:
        Corresponds to a difference between white and black colors (maximum difference).
        By default, the tolerance is equal to 0 thus equality check will return false for any different colors.

        :type theTolerance: float

        """
        return _Image.Handle_Image_Diff_SetColorTolerance(self, *args)


    def ColorTolerance(self, *args):
        """
        ColorTolerance(Handle_Image_Diff self) -> Standard_Real

        Color tolerance for equality check.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Image.Handle_Image_Diff_ColorTolerance(self, *args)


    def SetBorderFilterOn(self, *args):
        """
        SetBorderFilterOn(Handle_Image_Diff self, Standard_Boolean const theToIgnore)

        Sets taking into account (ignoring) a "border effect" on comparison of images.
        The border effect is caused by a border of shaded shapes in the viewer 3d.
        Triangles of this area are located at about 0 or 90 degrees to the user.
        Therefore, they deflect light differently according to implementation of a video card driver.
        This flag allows to detect such a "border" area and skip it from comparison of images.
        Filter turned OFF by default.

        :type theToIgnore: bool

        """
        return _Image.Handle_Image_Diff_SetBorderFilterOn(self, *args)


    def IsBorderFilterOn(self, *args):
        """
        IsBorderFilterOn(Handle_Image_Diff self) -> Standard_Boolean

        Returns a flag of taking into account (ignoring) a border effect in comparison of images.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_Diff_IsBorderFilterOn(self, *args)


    def Compare(self, *args):
        """
        Compare(Handle_Image_Diff self) -> Standard_Integer

        Compares two images. It returns a number of different pixels (or groups of pixels).
        It returns -1 if algorithm not initialized before.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_Diff_Compare(self, *args)


    def SaveDiffImage(self, *args):
        """
        SaveDiffImage(Handle_Image_Diff self, Image_PixMap theDiffImage) -> Standard_Boolean
        SaveDiffImage(Handle_Image_Diff self, TCollection_AsciiString theDiffPath) -> Standard_Boolean

        Saves a difference between two images as white pixels on black backgroud.

        :type theDiffPath: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_Diff_SaveDiffImage(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Image_Diff self) -> char const *

        :rtype: const char *

        """
        return _Image.Handle_Image_Diff_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_Diff_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_Diff_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Image_Diff self)

        Memory deallocator for transient classes


        """
        return _Image.Handle_Image_Diff_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Image_Diff self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Image_Diff self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_Diff_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Image_Diff self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Image_Diff self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_Diff_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Image_Diff self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Image.Handle_Image_Diff_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Image_Diff self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_Diff_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Image_Diff self)

        Increments the reference counter of this object


        """
        return _Image.Handle_Image_Diff_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Image_Diff self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_Diff_DecrementRefCounter(self, *args)

Handle_Image_Diff_swigregister = _Image.Handle_Image_Diff_swigregister
Handle_Image_Diff_swigregister(Handle_Image_Diff)

def Handle_Image_Diff_DownCast(thing):
    return _Image.Handle_Image_Diff_DownCast(thing)
Handle_Image_Diff_DownCast = _Image.Handle_Image_Diff_DownCast

class Handle_Image_PixMapData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Image_PixMapData self)

        Nullify the handle


        """
        return _Image.Handle_Image_PixMapData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Image_PixMapData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Image.Handle_Image_PixMapData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Image_PixMapData self, Image_PixMapData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Image.Handle_Image_PixMapData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Image_PixMapData self, Handle_Image_PixMapData theHandle) -> Handle_Image_PixMapData
        assign(Handle_Image_PixMapData self, Image_PixMapData thePtr) -> Handle_Image_PixMapData
        assign(Handle_Image_PixMapData self, Handle_Image_PixMapData theHandle) -> Handle_Image_PixMapData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Image.Handle_Image_PixMapData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Image_PixMapData self) -> Image_PixMapData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Image.Handle_Image_PixMapData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Image_PixMapData self) -> Image_PixMapData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Image.Handle_Image_PixMapData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Image_PixMapData self) -> Image_PixMapData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Image.Handle_Image_PixMapData___ref__(self, *args)


    def __hash__(self):
        return _Image.Handle_Image_PixMapData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Image.Handle_Image_PixMapData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Image.new_Handle_Image_PixMapData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Image.Handle_Image_PixMapData_DownCast)
    __swig_destroy__ = _Image.delete_Handle_Image_PixMapData

    def Init(self, *args):
        """
        Init(Handle_Image_PixMapData self, Handle_NCollection_BaseAllocator theAlloc, Standard_Size const theSizeBPP, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes, Standard_Byte * theDataPtr)

        Initializer.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :type theSizeBPP: int
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :type theDataPtr: int

        """
        return _Image.Handle_Image_PixMapData_Init(self, *args)


    def Row(self, *args):
        """
        Row(Handle_Image_PixMapData self, Standard_Size const theRow) -> Standard_Byte const *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_Row(self, *args)


    def ChangeRow(self, *args):
        """
        ChangeRow(Handle_Image_PixMapData self, Standard_Size const theRow) -> Standard_Byte *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_ChangeRow(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Image_PixMapData self, Standard_Size const theRow, Standard_Size const theCol) -> Standard_Byte const *

        @return data pointer to requested position.

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_Image_PixMapData self, Standard_Size const theRow, Standard_Size const theCol) -> Standard_Byte *

        @return data pointer to requested position.

        :type theRow: int
        :type theCol: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_ChangeValue(self, *args)


    def MaxRowAligmentBytes(self, *args):
        """
        MaxRowAligmentBytes(Handle_Image_PixMapData self) -> Standard_Size

        Compute the maximal row alignment for current row size.
        @return maximal row alignment in bytes (up to 16 bytes).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMapData_MaxRowAligmentBytes(self, *args)


    def SetTopDown(self, *args):
        """
        SetTopDown(Handle_Image_PixMapData self, bool const theIsTopDown)

        Setup scanlines order in memory - top-down or bottom-up.
        Drawers should explicitly specify this value if current state IsTopDown() was ignored!
        @param theIsTopDown top-down flag

        :type theIsTopDown: const bool

        """
        return _Image.Handle_Image_PixMapData_SetTopDown(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Image_PixMapData self) -> char const *

        :rtype: const char *

        """
        return _Image.Handle_Image_PixMapData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_PixMapData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_PixMapData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Data(self, *args):
        """
        Data(Handle_Image_PixMapData self) -> Standard_Byte const *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(Handle_Image_PixMapData self) -> Standard_Byte *

        @return buffer data

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_PixMapData_ChangeData(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Image_PixMapData self) -> bool

        @return true if buffer is not allocated

        :rtype: bool

        """
        return _Image.Handle_Image_PixMapData_IsEmpty(self, *args)


    def Size(self, *args):
        """
        Size(Handle_Image_PixMapData self) -> Standard_Size

        Return buffer length in bytes.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_PixMapData_Size(self, *args)


    def Allocator(self, *args):
        """
        @return buffer allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _Image.Handle_Image_PixMapData_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAllocator(self, *args):
        """
        SetAllocator(Handle_Image_PixMapData self, Handle_NCollection_BaseAllocator theAlloc)

        Assign new buffer allocator with de-allocation of buffer.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Image.Handle_Image_PixMapData_SetAllocator(self, *args)


    def Allocate(self, *args):
        """
        Allocate(Handle_Image_PixMapData self, Standard_Size const theSize) -> bool

        Allocate the buffer.
        @param theSize buffer length in bytes

        :type theSize: int
        :rtype: bool

        """
        return _Image.Handle_Image_PixMapData_Allocate(self, *args)


    def Free(self, *args):
        """
        Free(Handle_Image_PixMapData self)

        De-allocate buffer.


        """
        return _Image.Handle_Image_PixMapData_Free(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Image_PixMapData self)

        Memory deallocator for transient classes


        """
        return _Image.Handle_Image_PixMapData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Image_PixMapData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Image_PixMapData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_PixMapData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Image_PixMapData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Image_PixMapData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_PixMapData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Image_PixMapData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Image.Handle_Image_PixMapData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Image_PixMapData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_PixMapData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Image_PixMapData self)

        Increments the reference counter of this object


        """
        return _Image.Handle_Image_PixMapData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Image_PixMapData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_PixMapData_DecrementRefCounter(self, *args)

Handle_Image_PixMapData_swigregister = _Image.Handle_Image_PixMapData_swigregister
Handle_Image_PixMapData_swigregister(Handle_Image_PixMapData)

def Handle_Image_PixMapData_DownCast(thing):
    return _Image.Handle_Image_PixMapData_DownCast(thing)
Handle_Image_PixMapData_DownCast = _Image.Handle_Image_PixMapData_DownCast

class Handle_Image_AlienPixMap(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Image_AlienPixMap self)

        Nullify the handle


        """
        return _Image.Handle_Image_AlienPixMap_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Image_AlienPixMap self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Image_AlienPixMap self, Image_AlienPixMap thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Image.Handle_Image_AlienPixMap_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Image_AlienPixMap self, Handle_Image_AlienPixMap theHandle) -> Handle_Image_AlienPixMap
        assign(Handle_Image_AlienPixMap self, Image_AlienPixMap thePtr) -> Handle_Image_AlienPixMap
        assign(Handle_Image_AlienPixMap self, Handle_Image_AlienPixMap theHandle) -> Handle_Image_AlienPixMap

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Image.Handle_Image_AlienPixMap_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Image_AlienPixMap self) -> Image_AlienPixMap

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Image.Handle_Image_AlienPixMap_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Image_AlienPixMap self) -> Image_AlienPixMap

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Image.Handle_Image_AlienPixMap___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Image_AlienPixMap self) -> Image_AlienPixMap

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Image.Handle_Image_AlienPixMap___ref__(self, *args)


    def __hash__(self):
        return _Image.Handle_Image_AlienPixMap___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Image.Handle_Image_AlienPixMap___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Image.new_Handle_Image_AlienPixMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Image.Handle_Image_AlienPixMap_DownCast)
    __swig_destroy__ = _Image.delete_Handle_Image_AlienPixMap

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Image_AlienPixMap self) -> char const *

        :rtype: const char *

        """
        return _Image.Handle_Image_AlienPixMap_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_AlienPixMap_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Image.Handle_Image_AlienPixMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Load(self, *args):
        """
        Load(Handle_Image_AlienPixMap self, TCollection_AsciiString theFileName) -> bool

        Read image data from file.

        :type theFileName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_Load(self, *args)


    def Save(self, *args):
        """
        Save(Handle_Image_AlienPixMap self, TCollection_AsciiString theFileName) -> bool

        Write image data to file using file extension to determine compression format.

        :type theFileName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_Save(self, *args)


    def InitTrash(self, *args):
        """
        InitTrash(Handle_Image_AlienPixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0) -> bool

        Initialize image plane with required dimensions.
        thePixelFormat - if specified pixel format doesn't supported by image library
        than nearest supported will be used instead!
        theSizeRowBytes - may be ignored by this class and required alignemnt will be used instead!

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_InitTrash(self, *args)


    def InitCopy(self, *args):
        """
        InitCopy(Handle_Image_AlienPixMap self, Image_PixMap theCopy) -> bool

        Initialize by copying data.

        :type theCopy: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_InitCopy(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_Image_AlienPixMap self)

        Method correctly deallocate internal buffer.


        """
        return _Image.Handle_Image_AlienPixMap_Clear(self, *args)


    def AdjustGamma(self, *args):
        """
        AdjustGamma(Handle_Image_AlienPixMap self, Standard_Real const theGammaCorr) -> bool

        Performs gamma correction on image.
        theGamma - gamma value to use; a value of 1.0 leaves the image alone

        :type theGammaCorr: float
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_AdjustGamma(self, *args)


    def InitWrapper(self, thePixelFormat, theDataPtr, theSizeX, theSizeY, theSizeRowBytes):
        return _Image.Handle_Image_AlienPixMap_InitWrapper(self, thePixelFormat, theDataPtr, theSizeX, theSizeY, theSizeRowBytes)

    def IsBigEndianHost(self, *args):
        """
        IsBigEndianHost(Handle_Image_AlienPixMap self) -> bool

        Determine Big-Endian at runtime

        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_IsBigEndianHost(self, *args)


    def SwapRgbaBgra(self, *args):
        """
        SwapRgbaBgra(Handle_Image_AlienPixMap self, Image_PixMap theImage) -> bool

        Auxiliary method for swapping bytes between RGB and BGR formats.
        This method modifies the image data but does not change pixel format!
        Method will fail if pixel format is not one of the following:
        - Image_Format_RGB32 / Image_Format_BGR32
        - Image_Format_RGBA  / Image_Format_BGRA
        - Image_Format_RGB   / Image_Format_BGR
        - Image_Format_RGBF  / Image_Format_BGRF
        - Image_Format_RGBAF / Image_Format_BGRAF

        :type theImage: OCC.wrapper.Image.Image_PixMap
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_SwapRgbaBgra(self, *args)


    def ToBlackWhite(self, *args):
        """
        ToBlackWhite(Handle_Image_AlienPixMap self, Image_PixMap theImage)

        Convert image to Black/White.

        :type theImage: OCC.wrapper.Image.Image_PixMap

        """
        return _Image.Handle_Image_AlienPixMap_ToBlackWhite(self, *args)


    def Format(self, *args):
        """
        Format(Handle_Image_AlienPixMap self) -> Image_Format

        :rtype: OCC.wrapper.Image.Image_Format

        """
        return _Image.Handle_Image_AlienPixMap_Format(self, *args)


    def SetFormat(self, *args):
        """
        SetFormat(Handle_Image_AlienPixMap self, Image_Format const thePixelFormat)

        Override pixel format specified by InitXXX() methods.
        Will throw exception if pixel size of new format is not equal to currently initialized format.
        Intended to switch formats indicating different interpretation of the same data
        (e.g. ImgGray and ImgAlpha).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format

        """
        return _Image.Handle_Image_AlienPixMap_SetFormat(self, *args)


    def Width(self, *args):
        """
        Width(Handle_Image_AlienPixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_Width(self, *args)


    def Height(self, *args):
        """
        Height(Handle_Image_AlienPixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_Height(self, *args)


    def SizeX(self, *args):
        """
        SizeX(Handle_Image_AlienPixMap self) -> Standard_Size

        @return image width in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_SizeX(self, *args)


    def SizeY(self, *args):
        """
        SizeY(Handle_Image_AlienPixMap self) -> Standard_Size

        @return image height in pixels

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_SizeY(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Handle_Image_AlienPixMap self) -> Standard_Real

        @return width / height.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Image.Handle_Image_AlienPixMap_Ratio(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Image_AlienPixMap self) -> bool

        @return true if data is NULL.

        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_IsEmpty(self, *args)


    def PixelColor(self, *args):
        """
        PixelColor(Handle_Image_AlienPixMap self, Standard_Integer const theX, Standard_Integer const theY) -> Quantity_ColorRGBA

        Returns the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().
        @param theX column index from left
        @param theY row    index from top
        @return the pixel color

        :type theX: int
        :type theY: int
        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Handle_Image_AlienPixMap_PixelColor(self, *args)


    def SetPixelColor(self, *args):
        """
        SetPixelColor(Handle_Image_AlienPixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_Color theColor)
        SetPixelColor(Handle_Image_AlienPixMap self, Standard_Integer const theX, Standard_Integer const theY, Quantity_ColorRGBA theColor)

        Sets the pixel color. This function is relatively slow.
        Beware that this method takes coordinates in opposite order in contrast to ::Value() and ::ChangeValue().

        :type theX: int
        :type theY: int
        :type theColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _Image.Handle_Image_AlienPixMap_SetPixelColor(self, *args)


    def InitZero(self, *args):
        """
        InitZero(Handle_Image_AlienPixMap self, Image_Format thePixelFormat, Standard_Size const theSizeX, Standard_Size const theSizeY, Standard_Size const theSizeRowBytes=0, Standard_Byte const theValue=0) -> bool

        Initialize image plane with required dimensions.
        Buffer will be zeroed (black color for most formats).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :type theSizeX: int
        :type theSizeY: int
        :type theSizeRowBytes: int
        :type theValue: int
        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_InitZero(self, *args)


    def IsTopDown(self, *args):
        """
        IsTopDown(Handle_Image_AlienPixMap self) -> bool

        Returns TRUE if image data is stored from Top to the Down.
        By default Bottom Up order is used instead
        (topmost scanlines starts from the bottom in memory).
        which is most image frameworks naturally support.

        Notice that access methods within this class automatically
        convert input row-index to apply this flag!
        You should use this flag only if interconnect with alien APIs and buffers.
        @return true if image data is top-down

        :rtype: bool

        """
        return _Image.Handle_Image_AlienPixMap_IsTopDown(self, *args)


    def SetTopDown(self, *args):
        """
        SetTopDown(Handle_Image_AlienPixMap self, bool const theIsTopDown)

        Setup scanlines order in memory - top-down or bottom-up.
        Drawers should explicitly specify this value if current state IsTopDown() was ignored!
        @param theIsTopDown top-down flag

        :type theIsTopDown: const bool

        """
        return _Image.Handle_Image_AlienPixMap_SetTopDown(self, *args)


    def TopDownInc(self, *args):
        """
        TopDownInc(Handle_Image_AlienPixMap self) -> Standard_Size

        Returns +1 if scanlines ordered in Top->Down order in memory and -1 otherwise.
        @return scanline increment for Top->Down iteration

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_TopDownInc(self, *args)


    def Data(self, *args):
        """
        Data(Handle_Image_AlienPixMap self) -> Standard_Byte const *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_AlienPixMap_Data(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(Handle_Image_AlienPixMap self) -> Standard_Byte *

        @return data pointer for low-level operations (copying entire buffer, parsing with extra tools etc.).

        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_AlienPixMap_ChangeData(self, *args)


    def Row(self, *args):
        """
        Row(Handle_Image_AlienPixMap self, Standard_Size const theRow) -> Standard_Byte const *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_AlienPixMap_Row(self, *args)


    def ChangeRow(self, *args):
        """
        ChangeRow(Handle_Image_AlienPixMap self, Standard_Size const theRow) -> Standard_Byte *

        @return data pointer to requested row (first column).

        :type theRow: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _Image.Handle_Image_AlienPixMap_ChangeRow(self, *args)


    def SizePixelBytes(self, *args):
        """
        SizePixelBytes(Handle_Image_AlienPixMap self) -> Standard_Size
        SizePixelBytes(Handle_Image_AlienPixMap self, Image_Format const thePixelFormat) -> Standard_Size

        @return bytes reserved for one pixel (may include extra bytes for alignment).

        :type thePixelFormat: OCC.wrapper.Image.Image_Format
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_SizePixelBytes(self, *args)


    def SizeRowBytes(self, *args):
        """
        SizeRowBytes(Handle_Image_AlienPixMap self) -> Standard_Size

        @return bytes reserved per row.
        Could be larger than needed to store packed row (extra bytes for alignment etc.).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_SizeRowBytes(self, *args)


    def RowExtraBytes(self, *args):
        """
        RowExtraBytes(Handle_Image_AlienPixMap self) -> Standard_Size

        @return the extra bytes in the row.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_RowExtraBytes(self, *args)


    def MaxRowAligmentBytes(self, *args):
        """
        MaxRowAligmentBytes(Handle_Image_AlienPixMap self) -> Standard_Size

        Compute the maximal row alignment for current row size.
        @return maximal row alignment in bytes (up to 16 bytes).

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_MaxRowAligmentBytes(self, *args)


    def SizeBytes(self, *args):
        """
        SizeBytes(Handle_Image_AlienPixMap self) -> Standard_Size

        @return buffer size

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _Image.Handle_Image_AlienPixMap_SizeBytes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Image_AlienPixMap self)

        Memory deallocator for transient classes


        """
        return _Image.Handle_Image_AlienPixMap_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Image_AlienPixMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Image_AlienPixMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_AlienPixMap_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Image_AlienPixMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Image_AlienPixMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Image.Handle_Image_AlienPixMap_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Image_AlienPixMap self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Image.Handle_Image_AlienPixMap_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Image_AlienPixMap self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_AlienPixMap_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Image_AlienPixMap self)

        Increments the reference counter of this object


        """
        return _Image.Handle_Image_AlienPixMap_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Image_AlienPixMap self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Image.Handle_Image_AlienPixMap_DecrementRefCounter(self, *args)

Handle_Image_AlienPixMap_swigregister = _Image.Handle_Image_AlienPixMap_swigregister
Handle_Image_AlienPixMap_swigregister(Handle_Image_AlienPixMap)

def Handle_Image_AlienPixMap_DownCast(thing):
    return _Image.Handle_Image_AlienPixMap_DownCast(thing)
Handle_Image_AlienPixMap_DownCast = _Image.Handle_Image_AlienPixMap_DownCast




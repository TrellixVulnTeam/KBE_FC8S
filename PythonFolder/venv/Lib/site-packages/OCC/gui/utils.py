#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import functools
import os
import sys
from collections import defaultdict
from threading import Lock
from typing import Generator


def is_frozen():
    """Returns whether we are frozen via py2exe.
    This will affect how we find out where we are located."""
    return hasattr(sys, "frozen")


def executable_dir():
    """ This will get us the program's directory,
    even if we are frozen using py2exe"""

    if is_frozen():
        return os.path.dirname(sys.executable)

    return os.path.dirname(__file__)


def get_module_dir_when_frozen(fq_module_name):
    """Get the absolute directory path of th ``fq_module_name``.

    :param str fq_module_name: fully qualified module name
    :return: str
    """
    name_parts = fq_module_name.split('.')

    pkg_path = executable_dir()

    return os.path.join(pkg_path, os.path.join(*name_parts[:-1]))


_CONCURRENCY_LOCKS = defaultdict(Lock)
_CONCURRENTLY_EXECUTED = {}


class ConcurrencyConflict(RuntimeError):
    """Raised when one function is called while another, which cannot run
    concurrently, is still active.
    """


def concurrency_guard(key):
    """Guard the decorated function against running concurrently
    with functions marked with the same `key`.

    The guard will keep on guarding until the generator exits

    This guarantee only exists within the same process space.
    """
    def _concurrency_guard(fn):
        def wrap(*args, **kwargs):  # this is executed every call
            lock = _CONCURRENCY_LOCKS[key]
            close = True
            if lock.acquire(blocking=False):
                try:
                    _CONCURRENTLY_EXECUTED[key] = fn
                    res = fn(*args, **kwargs)
                    if isinstance(res, Generator):
                        # we need to wrap the generator so we can return
                        # now, but keep the context open until the
                        # generator is finished
                        def yield_result():
                            try:
                                yield from res
                            finally:
                                del _CONCURRENTLY_EXECUTED[key]
                                lock.release()
                        close = False  # the generator will close it
                        return yield_result()
                    else:  # normal result -> return
                        return res
                finally:
                    if close:
                        del _CONCURRENTLY_EXECUTED[key]
                        lock.release()
            else:  # there is a concurrent call already
                active_fn = _CONCURRENTLY_EXECUTED.get(key)
                msg = (f"Cannot execute {fn!r}! Another function guarded "
                       f"with the same key ({key}), and thus cannot "
                       f"run concurrently with this one, is already "
                       f"running: {active_fn!r}.")
                raise ConcurrencyConflict(msg)

        wrapper = functools.wraps(fn)(wrap)
        return wrapper

    return _concurrency_guard  # the decorator


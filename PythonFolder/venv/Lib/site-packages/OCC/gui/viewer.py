#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Viewer classes"""

import itertools
import logging
import os
import sys
import time
import warnings
from typing import Set, Union

import wx
from OCC.wrapper.AIS import (
    AIS_DS_Erased, AIS_DS_None, AIS_InteractiveContext, AIS_ListOfInteractive,
    AIS_SOP_NothingSelected, AIS_SOP_OneSelected, AIS_SOP_SeveralSelected,
    AIS_Shaded, AIS_Shape_SelectionMode, AIS_TOAX_Unknown, AIS_TOAX_XAxis,
    AIS_TOAX_YAxis, AIS_TOAX_ZAxis, AIS_TOI_Both, AIS_TOI_IsoU, AIS_TOI_IsoV,
    AIS_WireFrame, Handle_AIS_InteractiveObject, Handle_AIS_Shape)
from OCC.wrapper.Aspect import (
    Aspect_DisplayConnection, Aspect_FM_CENTERED, Aspect_FM_NONE,
    Aspect_FM_STRETCH, Aspect_FM_TILED, Aspect_GDM_Lines, Aspect_GDM_None,
    Aspect_GDM_Points, Aspect_GFM_CORNER1, Aspect_GFM_CORNER2,
    Aspect_GFM_CORNER3, Aspect_GFM_CORNER4, Aspect_GFM_DIAG1, Aspect_GFM_DIAG2,
    Aspect_GFM_HOR, Aspect_GFM_NONE, Aspect_GFM_VER, Aspect_GT_Rectangular,
    Aspect_TOL_SOLID, Aspect_TOTP_RIGHT_LOWER)
from OCC.wrapper.Graphic3d import (
    Graphic3d_AspectFillArea3d, Graphic3d_ClipPlane, V3d_GOURAUD)
from OCC.wrapper.Image import Image_AlienPixMap
from OCC.wrapper.MeshVS import (
    Handle_MeshVS_Mesh, MeshVS_DA_EdgeColor, MeshVS_DA_InteriorColor,
    MeshVS_DA_MarkerColor, MeshVS_DMF_Shading, MeshVS_DMF_Shrink,
    MeshVS_DMF_WireFrame)
from OCC.wrapper.OpenGl import OpenGl_GraphicDriver
from OCC.wrapper.Prs3d import (
    Handle_Prs3d_Drawer, Prs3d_Drawer, Prs3d_IsoAspect,
    Prs3d_TypeOfHighlight_LocalDynamic, Prs3d_TypeOfHighlight_LocalSelected,
    Prs3d_TypeOfHighlight_Selected)
from OCC.wrapper.Quantity import (
    Quantity_Color, Quantity_NOC_BLACK, Quantity_NOC_GRAY75,
    Quantity_NOC_GRAY80, Quantity_NOC_WHITE)
from OCC.wrapper.StdSelect import Handle_StdSelect_BRepOwner
from OCC.wrapper.TColStd import (
    TColStd_ListOfInteger, TColStd_SequenceOfInteger)
from OCC.wrapper.TCollection import (
    TCollection_AsciiString, TCollection_ExtendedString)
from OCC.wrapper.TopAbs import (
    TopAbs_COMPOUND, TopAbs_EDGE, TopAbs_FACE, TopAbs_SHELL, TopAbs_SOLID,
    TopAbs_VERTEX, TopAbs_WIRE)
from OCC.wrapper.V3d import (
    V3d_Viewer, V3d_Xneg, V3d_Xpos, V3d_XposYposZpos, V3d_Yneg,
    V3d_Ypos, V3d_ZBUFFER, V3d_Zneg, V3d_Zpos)
from OCC.wrapper.gp import gp_Dir, gp_Pln, gp_Pnt

from OCC.gui import OCCDeprecationWarning
from OCC.gui.camera import Camera
from OCC.gui.events import (
    create_left_click_background_event, create_left_click_object_event,
    create_right_click_background_event, create_right_click_object_event)
from OCC.gui.interactive_objects import (
    make_ais_coloredshape, make_ais_text_label, make_ais_trihedron)
from OCC.gui.utils import concurrency_guard
from OCC.utils.utilities import QuantityColor_rgb, py_QuantityColor

# TODO (PP): uncomment when vector export is supported again
# from OCC.gui.enums import ext_Graphic3d_ExportFormat

VALID_BITMAP_EXTENSIONS = ["bmp", "png", "gif", "jpg"]
VALID_VECTOR_EXTENSIONS = []
VALID_IMAGE_EXTENSIONS = VALID_BITMAP_EXTENSIONS + VALID_VECTOR_EXTENSIONS

VALID_BITMAP_EXTENSIONS_SET = frozenset(VALID_BITMAP_EXTENSIONS)
VALID_VECTOR_EXTENSIONS_SET = frozenset(VALID_VECTOR_EXTENSIONS)

__all__ = ["ViewerWindow", "Viewer"]

NAME_TO_SEL_MODE = {
    "vertices": AIS_Shape_SelectionMode(TopAbs_VERTEX),
    "edges": AIS_Shape_SelectionMode(TopAbs_EDGE),
    "wires": AIS_Shape_SelectionMode(TopAbs_WIRE),
    "faces": AIS_Shape_SelectionMode(TopAbs_FACE),
    "shells": AIS_Shape_SelectionMode(TopAbs_SHELL),
    "solids": AIS_Shape_SelectionMode(TopAbs_SOLID),
    "compounds": AIS_Shape_SelectionMode(TopAbs_COMPOUND),
    "default": 0,
}
SEL_MODE_TO_NAME = dict(zip(NAME_TO_SEL_MODE.values(),
                            NAME_TO_SEL_MODE.keys()))


# TODO (RvD): user now in charge of not re-displaying the same object.
# /todo consider caching calls to display()
# TODO (RvD): Remove wx.ClientDC and use OCC AIS_RubberBand from 7.0.0.
class Viewer(wx.Panel):
    """Viewer panel for wx-backend. Supports mouse rotation, panning, zooming,
    etc. Background style can be one of 3 modes:

    1. single color mode, e.g. "red" or (255, 0, 0).
        :meth:`set_background_color`.
    2. gradient color mode, e.g. ("red", "blue") or ((255, 0, 0), (0, 0, 255)).
         :meth:`set_background_color_gradient`.
    3. background image mode: specify filename of background image.
        :meth:`set_background_image`.

    .. note:: Once a mode has been set, it not possible to switch between
        modes. Any attempt to switch mode, will be ignored.
    """
    #: the default number of U and V isoparameters displayed
    ISOS = 0, 0
    #: show isolines on planar faces?
    ISOS_ON_PLANE = True
    #: highlight selected objects?
    HIGHLIGHT_SELECTED = False
    #: Show edges of
    DRAW_FACE_BOUNDARIES = True
    #: size of triedron as factor of windows size
    TRIEDRON_SCALE = 0.1
    #: title for V3d_Viewer object
    V3D_VIEWER_TITLE = "viewer"
    #: top color of background gradient
    BG_RGB_COLOR_TOP = 153, 204, 255
    #: bottom color of background gradient
    BG_RGB_COLOR_BOT = 0, 128, 255
    #: latency for drawing rubberband boxes in seconds
    LATENCY = 0.04
    #: adapt to default value for OpenCascade
    DEFAULT_DISPLAY_PRIORITY = 5
    #: Should iso-lines be created on the triangulation?
    ISO_ON_TRIANGULATION = True
    #: Color for selection of the faces for >1D shapes (Default: #FF7900)
    DEFAULT_SELECTION_COLOR = (0xFF, 0x79, 0x00)
    #: Color of the edges on selection (Default: `Quantity_NOC_GRAY80`)
    DEFAULT_SELECTION_EDGE_COLOR = Quantity_NOC_GRAY80
    #: Color of the edges on a highlight. (Default: #EAA864)
    DEFAULT_HIGHLIGHT_COLOR = (0xEA, 0xA8, 0x64)
    #: Color of the edges when highlighting a subshape. (Default: #EAA864)
    DEFAULT_SUBSHAPE_HIGHLIGHT_COLOR = DEFAULT_HIGHLIGHT_COLOR
    #: Color of the faces/edges when selecting a subshape. (Default: #EAA864)
    DEFAULT_SUBSHAPE_SELECTION_COLOR = DEFAULT_SELECTION_COLOR
    #: Presentation mode for trihedrons.
    DEFAULT_TRIHEDRON_DISPLAY_MODE = 'wireframe'

    py_Aspect_GradientFillMethod = {
        None: Aspect_GFM_NONE,
        "horizontal": Aspect_GFM_HOR,
        "vertical": Aspect_GFM_VER,
        "diag1": Aspect_GFM_DIAG1,
        "diag2": Aspect_GFM_DIAG2,
        "corner1": Aspect_GFM_CORNER1,
        "corner2": Aspect_GFM_CORNER2,
        "corner3": Aspect_GFM_CORNER3,
        "corner4": Aspect_GFM_CORNER4}

    py_Aspect_FillMethod = {
        None: Aspect_FM_NONE,
        "centered": Aspect_FM_CENTERED,
        "tiled": Aspect_FM_TILED,
        "stretched": Aspect_FM_STRETCH}

    py_Aspect_GridDrawMode = {
        None: Aspect_GDM_None,
        "lines": Aspect_GDM_Lines,
        "points": Aspect_GDM_Points}

    py_DisplayMode = {
        "wireframe": 0,
        "shaded": 1,
        "quick_hlr": 2,
        "exact_hlr": 3}

    py_DisplayModeMesh = {
        "shrink": MeshVS_DMF_Shrink,
        "shaded": MeshVS_DMF_Shading,
        'wireframe': MeshVS_DMF_WireFrame}

    DisplayMode_py = {
        0: "wireframe",
        1: "shaded",
        2: "quick_hlr",
        3: "exact_hlr"}

    py_AIS_TOAX = {
        None: AIS_TOAX_Unknown,
        "x": AIS_TOAX_XAxis,
        "y": AIS_TOAX_YAxis,
        "z": AIS_TOAX_ZAxis}

    class _UnsetStyle(object):
        __slots__ = ()

    UNSET_STYLE = _UnsetStyle()  # flag used to unset a style

    def __init__(self, parent, logger=None):
        wx.Panel.__init__(self, parent)
        self.logger = logger or logging.getLogger(self.__class__.__name__)
        #: :type: OCC.V3d.Handle_V3d_Viewer
        self._v3d_viewer = None
        #: :type: OCC.V3d.Handle_V3d_View
        self._v3d_view = None
        #: :type: OCC.AIS.Handle_AIS_InteractiveContext
        self._ais_context = None
        #: :type: OCC.PrsMgr.PrsMgr_PresentationManager
        self._prsmgr_presentationmanager = None
        #: :type: ZLayers
        self.zlayers = None
        #: :type: dict
        self._keymap = {}
        #: :type: list[Handle_Graphic3d_ClipPlane]
        self._clipplanes = []
        #: :type: (int, int)
        self._drag_x1_y1 = 0, 0
        #: :type: float
        self._drag_t1 = -1.0
        #: :type: wx.ClientDC
        self._dc = None
        #: :type: (float, float, float, float)
        self._selected_area = None
        #: :type: bool
        self._dragged = False
        #: One of None, 'uniform', 'gradient' or 'image".
        # :type: str
        self._bg_mode = None
        #: Default background color
        self._default_background_color = None
        #: last used path to background image
        self._bg_image = None
        #: :type: bool
        self.triedron = True

        # Colors below are a tuple. The first item is the value the user sets,
        # we need to return this to the user when he asks for it again. The
        # second item is the one for internal use (Quantity_Color)
        # (color, quantity_color)
        self._selection_color = (None, None)
        # (color, quantity_color)
        self._selection_edge_color = (None, None)
        # (color, quantity_color)
        self._highlight_color = (None, None)

        if sys.platform == 'linux':
            top_level_parent = self.TopLevelParent
            was_shown = top_level_parent.IsShown()

            # To force the window being created, so that we can get the handle
            # we show the window
            top_level_parent.Show()
            while not self.GetHandle():
                # although EVT_WINDOW_CREATE notifies the event of the window
                # being created, testing if we can get a Handle seems to be
                # more reliable. Creating multiple frames with the same app
                # does not fire EVT_WINDOW_CREATE again.
                wx.SafeYield()

            # Restore IsShown state to what it was before we changed it
            top_level_parent.Show(was_shown)
            while not top_level_parent.IsShown() == was_shown:
                wx.SafeYield()

        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
        self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
        self.Bind(wx.EVT_MIDDLE_DOWN, self.OnMiddleDown)
        self.Bind(wx.EVT_MOTION, self.OnMotion)
        self.Bind(wx.EVT_MOUSEWHEEL, self.OnWheelScroll)
        self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
        self.Bind(wx.EVT_ENTER_WINDOW, self.on_enter_window)

        self.left_m_down = False
        self.right_m_down = False

        self.init_viewer()
        self.init_layers()
        self.init_lights()
        self.init_background()
        self.init_display_mode()
        self.init_highlighting_defaults()
        self.init_triedron()
        self.init_keymap()
        self.init_dc()

        #: :type: OCC.gui.camera.Camera
        self.camera = Camera(self._v3d_view.Camera())

    def get_window_handle(self):
        hnd = self.GetHandle()
        if not hnd:
            raise RuntimeError("Couldn't get window handle")
        return hnd

    def OnDestroy(self, evt):
        # We need to destroy the view before the window is closed, otherwise
        # it will somehow try to update it when we ask it to close, but that
        # will happen after the window is indeed gone.
        self.remove_all(False)

    # TODO (RvD): Test if OpenGl_View is required or Graphic3d_CView is fine.
    def init_viewer(self):
        # window.SetVirtual(True)
        connection = Aspect_DisplayConnection().handle
        driver = OpenGl_GraphicDriver(connection).handle
        title = TCollection_ExtendedString(self.V3D_VIEWER_TITLE)
        title = title.ToExtString()
        viewer = V3d_Viewer(driver, title).handle
        view = viewer.CreateView()
        hnd = self.get_window_handle()

        if sys.platform == 'linux':
            from OCC.wrapper.Xw import Xw_Window
            window = Xw_Window(connection, hnd).handle
        else:
            from OCC.wrapper.WNT import WNT_Window
            window = WNT_Window(hnd, Quantity_NOC_BLACK).handle

        view.SetWindow(window)

        if not window.IsMapped():
            window.Map()

        self._v3d_view = view
        self._v3d_viewer = viewer
        self.zlayers = ZLayers(viewer)

        self._ais_context = context = AIS_InteractiveContext(viewer).handle

        # we need the default value of DEVIATION for the style resets
        # here nothing has happened yet.
        self._DEFAULT_DEVIATION_COEFFICIENT = context.DeviationCoefficient()

        self._prsmgr_presentationmanager = context.MainPrsMgr()
        self._default_background_color = view.BackgroundColor()

    def init_layers(self):
        """Template to override for different layer setup.

        .. attention:: on overriding, either call this method
            (``super().init_layers()``) or at least ensure that one new
            Z-layer is added to this view via :attr:`zlayers` and a call to
            :meth:`ZLayers.add_layer``. The side-effect garantuees proper
            functioning of OCC's default ``Graphic3d_ZLayerId_Top`` layer (e.g.
            Manipulator object depends on this and would otherwise not highlight
            on hover).
        """
        self.zlayers.add_layer()

    def init_lights(self):
        self._v3d_viewer.SetDefaultLights()
        self._v3d_viewer.SetLightOn()

    def init_background(self):
        self.set_background_color_gradient(self.BG_RGB_COLOR_TOP,
                                           self.BG_RGB_COLOR_BOT)

    def init_display_mode(self):
        context = self._ais_context
        v3d_view = self._v3d_view

        # ---- shading with edges ----
        context.SetDisplayMode(AIS_Shaded, False)
        v3d_view.SetShadingModel(V3d_GOURAUD)
        drawer: Handle_Prs3d_Drawer = context.DefaultDrawer()
        drawer.SetFaceBoundaryDraw(self.DRAW_FACE_BOUNDARIES)

        # ---- isos ----
        self.set_isos(*self.ISOS)
        context.IsoOnPlane(self.ISOS_ON_PLANE)
        context.IsoOnTriangulation(self.ISO_ON_TRIANGULATION)

    def init_highlighting_defaults(self):
        context = self._ais_context

        # ---- selecting ----
        self.selection_color = self.DEFAULT_SELECTION_COLOR
        self.selection_edge_color = self.DEFAULT_SELECTION_EDGE_COLOR
        self.subshape_selection_color = self.DEFAULT_SUBSHAPE_SELECTION_COLOR

        # ---- hilighting ----
        context.SetToHilightSelected(self.HIGHLIGHT_SELECTED)
        self.highlight_color = self.DEFAULT_HIGHLIGHT_COLOR
        self.subshape_highlight_color = self.DEFAULT_SUBSHAPE_HIGHLIGHT_COLOR

    def _update_selection_highlighting(self):
        drawer: Handle_Prs3d_Drawer = self._ais_context.HighlightStyle(
            Prs3d_TypeOfHighlight_Selected)

        drawer.SetDisplayMode(-1)  # Currently active display mode.

        selection_color = self._selection_color[1]
        # fill color:
        if selection_color:
            fill_style = drawer.BasicFillAreaAspect()
            if fill_style.IsNull():
                fill_style = Graphic3d_AspectFillArea3d().handle
                drawer.SetBasicFillAreaAspect(fill_style)

            fill_style.SetInteriorColor(selection_color)

        edge_color = self._selection_edge_color[1]
        if edge_color:
            drawer.SetColor(edge_color)  # edge color

    @property
    def selection_color(self):
        return self._selection_color[0]

    @selection_color.setter
    def selection_color(self, color):
        """Set selection color.

        :param color: color to show on selection, e.g. ``red``, ``(255, 0, 0)``
            or ``Quantity_NOC_RED``.
        :type: str | (float, float, float) | int
        :return:
        """
        q_color = py_QuantityColor(color, str_default=None)
        self._selection_color = (color, q_color)
        self._update_selection_highlighting()

    @property
    def selection_edge_color(self):
        return self._selection_edge_color[0]

    @selection_edge_color.setter
    def selection_edge_color(self, color):
        """Color of the boundary edges.

        :param color: color to show on selection, e.g. ``red``, ``(255, 0, 0)``
            or ``Quantity_NOC_RED``.
        :type: str | (float, float, float) | int
        :return:
        """
        q_color = py_QuantityColor(color, str_default=None)
        self._selection_edge_color = (color, q_color)
        self._update_selection_highlighting()

    @property
    def subshape_selection_color(self):
        return self._subshape_selection_color[0]

    @subshape_selection_color.setter
    def subshape_selection_color(self, color):
        """Set selection color.

        :param color: color to show on selection, e.g. ``red``, ``(255, 0, 0)``
            or ``Quantity_NOC_RED``.
        :type: str | (float, float, float) | int
        :return:
        """
        q_color = py_QuantityColor(color, str_default=None)
        self._subshape_selection_color = (color, q_color)

        # we create a new drawer. This will force the current boundary
        # edge color to remain intact
        drawer = Prs3d_Drawer().handle
        drawer.SetColor(q_color)
        # Set the display mode to whatever is active now. This means that in
        # shaded mode the faces will be highlighted. In wireframe the edges
        # will be highlighted.
        drawer.SetDisplayMode(-1)

        self._ais_context.SetHighlightStyle(
            Prs3d_TypeOfHighlight_LocalSelected, drawer)

    @property
    def highlight_color(self):
        return self._highlight_color[0]

    @highlight_color.setter
    def highlight_color(self, color):
        """Set selection color.

        :param color: color to show on selection, e.g. ``red``, ``(255, 0, 0)``
            or ``Quantity_NOC_RED``.
        :type: str | (float, float, float) | int
        :return:
        """
        q_color = py_QuantityColor(color, str_default=None)
        style = self._ais_context.HighlightStyle()
        style.SetColor(q_color)
        style.SetDisplayMode(0)  # wireframe
        self._highlight_color = (color, q_color)

    @property
    def subshape_highlight_color(self):
        return self._subshape_highlight_color[0]

    @subshape_highlight_color.setter
    def subshape_highlight_color(self, color):
        """Set selection color.

        :param color: color to show on selection, e.g. ``red``, ``(255, 0, 0)``
            or ``Quantity_NOC_RED``.
        :type: str | (float, float, float) | int
        :return:
        """
        q_color = py_QuantityColor(color, str_default=None)
        style = self._ais_context.HighlightStyle(
            Prs3d_TypeOfHighlight_LocalDynamic)
        style.SetColor(q_color)
        style.SetDisplayMode(0)  # wireframe
        self._subshape_highlight_color = (color, q_color)

    def init_triedron(self):
        white = Quantity_Color(Quantity_NOC_WHITE)
        return self._v3d_view.TriedronDisplay(
            Aspect_TOTP_RIGHT_LOWER, white, self.TRIEDRON_SCALE, V3d_ZBUFFER)

    def init_keymap(self):
        # beware: evt.GetKeyCode() capitalizes keys, so pressing 'w' -> 'W'.
        self._keymap = {
            ord('W'): self.OnKeyW,
            ord('S'): self.OnKeyS,
            ord('F'): self.OnKeyF,
            ord('C'): self.OnKeyC,
            ord('Q'): self.OnKeyQ,
            ord('A'): self.OnKeyA,
            # 127 matches DEL button on Win64
            127: self.OnKeyDEL,
            # xxx matches ESC button on Win64
            27: self.onKeyESC
        }

    def init_dc(self):
        self._dc = dc = wx.ClientDC(self)
        # color = wx.Colour(73, 149, 209)  # ParaPy Blue
        color = wx.BLACK
        pen = wx.Pen(color, 1, wx.LONG_DASH)
        dc.SetPen(pen)
        # dc.SetPen(wx.GREY_PEN)
        # dc.SetBackgroundMode(wx.TRANSPARENT)
        # dc.SetBrush(wx.TRANSPARENT_BRUSH)

    # TODO (RvD): Does this take effect one already displayed objects?
    def set_isos(self, u, v):
        if u == v:
            self._ais_context.SetIsoNumber(u, AIS_TOI_Both)
        else:
            self._ais_context.SetIsoNumber(u, AIS_TOI_IsoU)
            self._ais_context.SetIsoNumber(v, AIS_TOI_IsoV)

    def set_display_mode_shaded(self, update=True):
        self._v3d_view.SetComputedMode(False)
        self._ais_context.SetDisplayMode(AIS_Shaded, update)
        self.update_selected()

    def set_display_mode_wireframe(self, update=True):
        self._v3d_view.SetComputedMode(False)
        self._ais_context.SetDisplayMode(AIS_WireFrame, update)
        self.update_selected()

    def set_display_mode_hlr(self):
        self._v3d_view.SetComputedMode(True)
        self.update_selected()

    def activate_grid(self, xorig, yorig, zorig, width, length, xstep, ystep,
                      angle=0, mode="lines"):
        """Activate a rectangular grid. ``xorig`` and ``yorig`` define the
        origin of the grid. ``xstep`` defines the interval between 2
        vertical lines. ``ystep`` defines the interval between 2 horizontal
        lines. ``angle`` defines the rotation angle of the grid. ``width``
        and ``length`` define the dimensions of the grid.

        :param float xorig: X-coordinate of grid
        :param float yorig: Y-coordinate of grid
        :param float zorig: Z-coordinate of grid
        :param float width: width of grid
        :param float length: length of grid
        :param float xstep: interval between 2 vertical lines
        :param float ystep: interval between 2 horizontal lines
        :param float angle: rotation angle of grid
        :param str | None mode: either 'lines', 'points' or None.
        """
        mode = self.py_Aspect_GridDrawMode[mode]
        v3d_viewer = self._v3d_viewer
        v3d_viewer.ActivateGrid(Aspect_GT_Rectangular, mode)
        # for some reason OCC takes half-width and half-length inputs.
        v3d_viewer.SetRectangularGridGraphicValues(width / 2., length / 2.,
                                                   zorig)
        # for some reason, x and y are reversed in OCC.
        v3d_viewer.SetRectangularGridValues(-xorig, -yorig, xstep, ystep,
                                            angle)

    def deactivate_grid(self):
        self._v3d_viewer.DeactivateGrid()

    def reset_background(self, update=True):
        if self._bg_mode == "uniform":
            self._v3d_view.SetBackgroundColor(self._default_background_color)
            if update:
                self.update()
        elif self._bg_mode == "gradient":
            white = Quantity_Color(Quantity_NOC_WHITE)
            black = Quantity_Color(Quantity_NOC_BLACK)
            self._v3d_view.SetBgGradientColors(white, black,
                                               Aspect_GFM_NONE, update)
        elif self._bg_mode == "image":
            self._v3d_view.SetBackgroundImage(
                self._bg_image, Aspect_FM_NONE, update)
            self._bg_image = None
        self._bg_mode = None

    def set_background_color(self, color, update=True):
        """Set uniformly colored background:

        >>> self.set_background_color("white")
        >>> self.set_background_color((255, 255, 255))
        """
        if self._bg_mode == "gradient" or self._bg_mode == "image":
            self.reset_background(False)
        self._v3d_view.SetBackgroundColor(py_QuantityColor(color))
        if update:
            self.update()
        self._bg_mode = "uniform"

    def set_background_color_gradient(self, color1, color2, style="vertical",
                                      update=True):
        """Set background of viewer with gradient from top ``color1`` to
        bottom ``color2``.

        >>> self.set_background_color_gradient("white", "black")
        >>> self.set_background_color_gradient((255, 255, 255), (0, 0, 0))

        :type color1: str | (float, float, float)
        :type color2: str | (float, float, float)
        :param style: valid values are (None, "horizontal", "vertical",
            "diag1", "diag2", "corner1", "corner2", "corner3", "corner4")
        :param bool update: update viewer immediately?
        """
        if self._bg_mode == "image":
            self.reset_background(False)
        style = self.py_Aspect_GradientFillMethod[style]
        self._v3d_view.SetBgGradientColors(py_QuantityColor(color1),
                                           py_QuantityColor(color2),
                                           style, update)
        self._bg_mode = "gradient"

    def set_background_image(self, pathname, style="centered", update=True):
        """Set background image, either .gif, .bmp or .xwd format.

        >>> self.set_background_image("path/to/image.bmp")

        :param str pathname: path to image
        :param style: valid values are (None, "centered", "tiled", "stretched")
        :param bool update: update viewer immediately?
        """
        pathname = os.path.abspath(pathname)
        if not os.path.isfile(pathname):
            raise RuntimeError(
                "Background image '{}' does not exist".format(pathname))
        if self._bg_mode == "gradient":
            self.reset_background(False)
        style = self.py_Aspect_FillMethod[style]
        self._v3d_view.SetBackgroundImage(pathname, style, update)
        self._bg_mode = "image"
        self._bg_image = pathname

    def set_camera(self, camera, update=True):
        """Set the camera of the viewer to ``camera``.

        :param Camera camera: Camera position and settings that should be
            applied to the Viewer.
        :param bool update: Should we update the Viewer?
        """
        prev_aspect = self.camera.aspect_ratio

        # update view
        self.camera.copy_from_camera(camera)

        if prev_aspect != camera.aspect_ratio:
            # If the aspect ratio from the given camerea is different than that
            # of the screen, we need to resize
            self._v3d_view.MustBeResized()

        if update:
            self.update()

    def get_camera(self, copy=True):
        """Return :attr:`camera` or a ``copy`` of it. The latter is useful
        when you do not want the returned camera to change when the current
        view changes, or vice-versa.

        :param bool copy: if set to :py:`True` returns a copy of the camera.
        :rtype: Camera
        """
        if copy:
            camera = Camera()
            camera.copy_from_camera(self.camera)
            return camera
        else:
            return self.camera

    def fit_all(self):
        v3d_view = self._v3d_view
        v3d_view.ZFitAll()
        v3d_view.FitAll()

    def hide(self, obj, update=True, fit=False):
        # don't update twice (fit will also update)
        self._ais_context.Erase(obj, False if fit else update)
        if fit:
            self.fit_all()

    def hide_all(self, update=True):
        self._ais_context.EraseAll(update)

    def hide_selected_objects(self, update=True, fit=False):
        # don't update twice (fit will also update)
        update = False if fit else update
        self._ais_context.EraseSelected(update)
        if fit:
            self.fit_all()

    def update(self):
        """Redraw OCC V3D_View."""
        self._v3d_view.Redraw()

    def move_to(self, x, y):
        """Relays mouse position in pixels ``x`` and ``y`` to the interactive
        context selectors.

        :rtype: int
        :returns: AIS_StatusOfDetection
        """
        return self._ais_context.MoveTo(x, y, self._v3d_view, True)

    def move_to_current_mouse_position(self):
        """Relays current mouse position to the interactive context selectors.

        :rtype: int
        :returns: AIS_StatusOfDetection
        """
        screen_pos = wx.GetMousePosition()
        x, y = self.ScreenToClient(screen_pos)
        return self.move_to(x, y)

    update_selector = move_to_current_mouse_position

    def display(self, obj, update=True, fit=True):
        # prevent updating twice, fit will do this already
        self._ais_context.Display(obj, False if fit else update)
        if fit:
            self.fit_all()
        return obj

    # TODO (TBD): investigate if AIS_Shape can still be used and render edges.
    def display_topods_shape(self, topods_shape, **kwargs):
        # ais_shape = AIS_Shape(topods_shape).handle
        obj = make_ais_coloredshape(topods_shape)
        return self.display(obj, **kwargs)

    def display_text(self, text, pt, top_most=False, height=None, **kwargs):
        obj = make_ais_text_label(text, pt, top_most=top_most, height=height)
        return self.display(obj, **kwargs)

    def display_trihedron(self, pt, vz=(0, 0, 1), vx=(1, 0, 0),
                          size=None, zoom_persistent=False,
                          keep_on_top=False, display_mode=None,
                          **kwargs):
        display_mode = display_mode or \
                            self.DEFAULT_TRIHEDRON_DISPLAY_MODE
        size = size or 1
        obj = make_ais_trihedron(pt, vz=vz, vx=vx, size=size,
                                 zoom_persistent=zoom_persistent,
                                 keep_on_top=keep_on_top,
                                 display_mode=display_mode)
        return self.display(obj, **kwargs)

    def display_all(self, update=True, fit=False):
        # prevent updating twice, fit will do this already
        self._ais_context.DisplayAll(False if fit else update)
        if fit:
            self.fit_all()

    def remove(self, obj, update=True, fit=True):
        # prevent updating twice, fit will do this already
        self._ais_context.Remove(obj, False if fit else update)
        if fit:
            self.fit_all()

    def remove_all(self, update=True):
        self._ais_context.RemoveAll(update)

    def apply_style(self, obj, color=None, transparency=None,
                    display_mode=None, line_thickness=None,
                    deviation_coefficient=None, u_isos=None, v_isos=None,
                    display_priority=None, mesh_vertex_color=None,
                    mesh_edge_color=None, mesh_face_color=None, update=True):
        """Apply display style to ``obj``.

        one can unset values by passing "Viewer.UNSET_STYLE". Although this
        does currently not work for display_priority.

        :param OCC.AIS.AIS_InteractiveObject obj: object to display in viewer
        :param (float, float, float) | str | None color: color of ``obj``
        :param float | None | Viewer._UnsetStyle transparency: between 0.0 (
            opaque) - 1.0 (fully transparent)
        :param str | None display_mode: 'wireframe' -> AIS_WireFrame |
            'shaded' -> AIS_Shaded
        :param int | None | Viewer._UnsetStyle line_thickness: >= 1
        :param float | None | Viewer._UnsetStyle deviation_coefficient: > 0.0
        :param int | Viewer._UnsetStyle u_isos: number of isolines in u-direction
        :param int | Viewer._UnsetStyle v_isos: number of isolines in vdirection
        :param (float, float, float) | str | None mesh_face_color: color of
            mesh faces
        :param (float, float, float) | str | None mesh_edge_color: color of
            mesh edges
        :param (float, float, float) | str | None mesh_vertex_color: color of
            mesh vertices
        :param int | str | None display_priority: display priority of ``obj``
            (default is 5)
        :param bool update: redisplay the object?
        """
        context = self._ais_context
        redisplay = False
        UNSET = Viewer.UNSET_STYLE

        if isinstance(obj, Handle_MeshVS_Mesh):
            # after .SetColor(), redisplay to have color change take effect.
            new_colors = [mesh_face_color, mesh_edge_color, mesh_vertex_color]
            if any(new_colors):
                redisplay = True
                drawer = obj.GetDrawer()
                """:type: OCC.MeshVS.MeshVS_Drawer"""

                color_flags = (MeshVS_DA_InteriorColor,
                               MeshVS_DA_EdgeColor, MeshVS_DA_MarkerColor)

                if UNSET in new_colors:
                    # reset the colors, set the colors again which were None
                    get_color = drawer.GetColor
                    old_colors = (get_color(flag) for flag in color_flags)

                    for old_color, i, new_color in zip(old_colors,
                                                       *enumerate(new_colors)):
                        if new_color is None:
                            # no new value given, so we reset the old value
                            new_colors[i] = old_color
                        elif new_color is UNSET:
                            # we not set these after reset
                            new_colors[i] = None

                    obj.UnsetColor()  # reset all colors to defaults

                set_color = drawer.SetColor
                for flag, color in zip(color_flags, new_colors):
                    if color:
                        set_color(flag, py_QuantityColor(color))

            if display_mode is not None:
                # FIXME (TBD): when using SetDisplayMode(), context.Redisplay()
                # /fixme or context.Update() do not reflect change. Drastic
                # /fixme way for now is to Remove shape entirely.
                was_dislayed = False
                if context.IsDisplayed(obj):
                    context.Remove(obj, False)
                    was_dislayed = True

                if display_mode is UNSET:
                    obj.UnsetDisplayMode()
                else:
                    mode = self.py_DisplayModeMesh[display_mode]
                    obj.SetDisplayMode(mode)

                if was_dislayed:
                    context.Display(obj, False)
                    redisplay = False

        else:  # normal InteractiveObject that is not a mesh
            if color:
                color = py_QuantityColor(color)
                context.SetColor(obj, color, False)

            # FIXME (RvD): Boundary edges in front of non-transparent object,
            # /fixme are hidden. See also:
            # /fixme https://tracker.dev.opencascade.org/view.php?id=27716
            if transparency:  # filters out None and 0.0
                if transparency is UNSET:
                    context.UnsetTransparency(obj, False)
                else:
                    context.SetTransparency(obj, transparency, False)

            if line_thickness is not None:
                if line_thickness is UNSET:
                    context.UnsetWidth(obj, False)
                else:
                    context.SetWidth(obj, line_thickness, False)

            if display_mode is not None:
                if display_mode is UNSET:
                    context.UnsetDisplayMode(obj, False)
                else:
                    mode = self.py_DisplayMode[display_mode]
                    context.SetDisplayMode(obj, mode, False)

            if deviation_coefficient is not None:
                if deviation_coefficient is UNSET:
                    deviation_coefficient = self._DEFAULT_DEVIATION_COEFFICIENT
                elif deviation_coefficient < 1.0e-5:
                    msg = ("a deviation_coefficient of {:} is very small, "
                           "expect delays...")
                    self.logger.warning(msg.format(deviation_coefficient))
                # display_context.SetDeviationAngle(h_AIS_InteractiveObject,
                # deflection, False)
                context.SetDeviationCoefficient(obj, deviation_coefficient,
                                                False)

            if u_isos is not None or v_isos is not None:
                drawer = obj.Attributes()
                """:type: OCC.Prs3d.Handle_Prs3d_Drawer"""

                for num_isos, set_iso in ((u_isos, drawer.SetUIsoAspect),
                                          (v_isos, drawer.SetVIsoAspect)):
                    if num_isos is not None:
                        iso_aspect = self._new_isoaspect(
                            num_lines=0 if num_isos is UNSET else num_isos)
                        set_iso(iso_aspect)
                redisplay = True

        # TODO (TBD): No obvious "UNSET" possible for display priority.
        # /todo Setting a display priority modifies the display priority
        # /todo for all its children.
        if display_priority is not None:
            if display_priority is UNSET:
                msg = ("Unsetting the display priority is currently not "
                       "supported. Nothing will happen.")
                self.logger.warning(msg)
            else:
                context.SetDisplayPriority(obj, display_priority)

        if redisplay:
            self._ais_context.Redisplay(obj, update, False)  # all_modes=False?
        elif update:
            self.update()

    def _new_isoaspect(self, color=Quantity_NOC_GRAY75,
                       line_type=Aspect_TOL_SOLID,
                       line_width=0.5,
                       num_lines=0):
        quantity_color = Quantity_Color(color)
        return Prs3d_IsoAspect(quantity_color, line_type, line_width,
                               num_lines).handle

    def reset_style(self, obj, update=True):
        """Reset style of Handle_AIS_InteractiveObject ``obj``.

        :type obj: OCC.AIS.Handle_AIS_InteractiveObject
        """
        priority = self.DEFAULT_DISPLAY_PRIORITY
        context = self._ais_context
        obj.UnsetAttributes()
        context.SetDisplayPriority(obj, priority)
        context.Redisplay(obj, update, False)  # all_modes=False?

    def get_style(self, obj):
        """Return dict with all kwargs from apply_style():

            {'color': (198, 145, 29),
             'transparency': 0.0,
             'line_thickness': 1,
             'deviation_coefficient': 0.001,
             'display_mode': 'shaded',
             'display_priority': 5,
             'u_isos': 0,
             'v_isos': 0}

        :rtype: dict[str, T]
        """
        dct = {}
        context = self._ais_context
        drawer = obj.Attributes()

        color = Quantity_Color()
        context.Color(obj, color)

        dct['color'] = QuantityColor_rgb(color)
        dct['transparency'] = obj.Transparency()
        dct['line_thickness'] = obj.Width() or 1.0
        # FIXME (PP): AIS_InteractiveObject.DisplayMode missing.
        # dct['display_mode'] = self.DisplayMode_py[obj.DisplayMode()]

        if obj.DynamicType().Name() == "AIS_Shape":
            # downcast to AIS_Shape, otherwise it does not have
            # OwnDeviationCoefficient
            shape_obj = Handle_AIS_Shape(obj)
            assert not shape_obj.IsNull()  # casting should be a success
        else:
            shape_obj = obj

        try:
            meth = shape_obj.OwnDeviationCoefficient
        except AttributeError:
            dct['deviation_coefficient'] = context.DeviationCoefficient()
        else:
            flag, coef, prev_coef = meth()
            if flag:
                dct['deviation_coefficient'] = coef
            else:
                dct['deviation_coefficient'] = context.DeviationCoefficient()

        if obj.HasDisplayMode():
            display_mode = obj.DisplayMode()
        else:
            display_mode = context.DisplayMode()
        dct['display_mode'] = self.DisplayMode_py[display_mode]
        dct['display_priority'] = context.DisplayPriority(obj)
        dct['u_isos'] = drawer.UIsoAspect().Number()
        dct['v_isos'] = drawer.VIsoAspect().Number()

        return dct

    # X+ side
    def view_right(self, fit=True):
        self._set_view(V3d_Xpos, fit=fit)

    # X- side
    def view_left(self, fit=True):
        self._set_view(V3d_Xneg, fit=fit)

    # Y- side
    def view_front(self, fit=True):
        self._set_view(V3d_Yneg, fit=fit)

    # Y+ side
    def view_back(self, fit=True):
        self._set_view(V3d_Ypos, fit=fit)

    # Z+ side
    def view_top(self, fit=True):
        self._set_view(V3d_Zpos, fit=fit)

    # Z- side
    def view_bottom(self, fit=True):
        self._set_view(V3d_Zneg, fit=fit)

    # isometric view
    def view_iso(self, fit=True):
        self._set_view(V3d_XposYposZpos, fit=fit)

    def _set_view(self, v3d_orientation, fit=True):
        self._v3d_view.SetProj(v3d_orientation)
        if fit:
            self.fit_all()

    def remove_clipplanes(self):
        for pln in self._clipplanes:
            self._v3d_view.RemoveClipPlane(pln)

    def add_clipplane(self, point, direction):
        """Example: ``add_clipplane((0, 0, 0), (0, 0, 1))``.

        :type point: (float, float, float)
        :type direction: (float, float, float)
        """
        pln = gp_Pln(gp_Pnt(*point), gp_Dir(*direction))
        pln = Graphic3d_ClipPlane(pln).handle
        self._v3d_view.AddClipPlane(pln)
        self._clipplanes.append(pln)

    def select(self, obj, shift=False, update=True):
        """Select ``obj`` and highlight it in viewer (if displayed).

        :param OCC.AIS.AIS_InteractiveObject obj: object to select
        :param bool shift: If set to `True`, appends `obj` to the
            current selection (unless it was already selected, in which case
            the object is deselected). If set to `False`, `obj` will be
            selected and all previously selected items will be deselected.
        :param bool update: update the viewer?
        """
        context = self._ais_context
        if shift:
            context.AddOrRemoveSelected(obj, update)
        else:
            # we need to clear selected because SetSelected ADDS objects
            # to the selection for this specific overload
            context.ClearSelected(False)
            context.SetSelected(obj, update)

    def update_selected(self, update=True):
        """Syncs the selection-highlighting with the actual state of what is
        selected/unselected in the viewer. Sometimes this can get out of
        sync by adding new items to the selection, or removing the
        highlighting of items.
        """
        self._ais_context.UpdateSelected(update)

    def deselect(self, obj, update=True):
        context = self._ais_context
        if context.IsSelected(obj):
            context.AddOrRemoveSelected(obj, update)

    def select_under_mouse(self, pos, shift=False, update=True):
        """Select object under current mouse position, if any. If ``shift`` is
        True, adds the currently selected to :attr:`selected_objects`. If
        currently selected was already selected, it will be remove from
        :attr:`selected_objects`. If ``update``, viewer will be updated to
        show object as selected.

        :param tuple[float, float] pos: mouse position x, y
        :param bool shift: shift-selection
        :param bool update: update viewer after selection.
        :rtype: AIS_StatusOfPick
        """
        # Forcefully refresh detected. It might be that some things were
        # erased, but we did not move. Then the erased objects
        # are still in detected, causing a bug, for instance with double
        # erases, or ghost-selections.
        x, y = pos
        ais_context = self._ais_context
        self.move_to(x, y)

        if shift:
            return ais_context.ShiftSelect(update)
        else:
            return ais_context.Select(update)

    def select_area(self, x1, y1, x2, y2, shift=False, update=True):
        """Select all object(s) that are fully inside the rectangle bound by
        top-left corner ``(x1, y1)`` and bottom-right corner ``(x2, y2)``. If
        ``shift`` is True, adds the current selection to
        :attr:`selected_objects`. Member inside the current selection that
        were already selected, will be removed from :attr:`selected_objects`.
        If ``update``, viewer will be updated to show objects as selected.

        :param bool shift: shift-selection
        :param bool update: update viewer after selection.
        :rtype: AIS_StatusOfPick
        """
        if shift:
            return self._ais_context.ShiftSelect(x1, y1, x2, y2,
                                                 self._v3d_view, update)
        else:
            return self._ais_context.Select(x1, y1, x2, y2,
                                            self._v3d_view, update)

    def is_selected(self, obj):
        return bool(self._ais_context.IsSelected(obj))

    def select_all(self, update=True):
        context = self._ais_context
        # segfaults...
        # context.DisplayActiveSensitive(self._v3d_view)
        for obj in self.yield_displayed():
            if not context.IsSelected(obj):
                context.AddOrRemoveSelected(obj, False)
        if update:
            self.update()

    def deselect_all(self, update=True):
        self._ais_context.ClearSelected(update)

    @property
    def detected(self):
        """List all detected objects in viewer.

        :rtype: list[OCC.AIS.AIS_InteractiveObject]
        """
        return list(self.yield_detected())

    @property
    def selected(self):
        """List all selected objects in viewer.

        :rtype: list[OCC.AIS.AIS_InteractiveObject]
        """
        return list(self.yield_selected())

    @property
    def nb_selected(self):
        """Number of selected items.

        A faster alternative to `len(viewer.selected)`, although it will still
        loop over all the elements (on C++ side).
        """
        return self._ais_context.NbSelected()

    @property
    def displayed(self):
        """List all displayed objects in viewer.

        :rtype: list[OCC.AIS.AIS_InteractiveObject]
        """
        return list(self.yield_displayed())

    @concurrency_guard("detected")
    def yield_detected(self):
        """Yield currently detected objects in viewer.

        :rtype: collections.Iterable[OCC.AIS.AIS_InteractiveObject]
        """
        context = self._ais_context
        context.InitDetected()  # supports only iteration being active at once
        while context.MoreDetected():
            # DetectedInteractive seems to be broken and only return the
            # topmost detected instance hence the work-around below
            owner = context.DetectedCurrentOwner()
            selectable = owner.Selectable()
            ais = Handle_AIS_InteractiveObject.DownCast(selectable)
            if ais.IsNull():
                # Either the selectable wasn't an interactive object, or
                # the detected entity was Null itself. This shouldn't happen
                # but not 100% sure about that...
                self.logger.debug(f"Cannot downcast detected selectable "
                                  f"to Handle_AIS_InteractiveObject! "
                                  f"owner: {owner!r}, "
                                  f"selectable: {selectable!r}.")
            else:
                yield ais
            context.NextDetected()

    @concurrency_guard("detected")
    def yield_detected_with_owner(self):
        """Generate detected (currently under the cursor) shapes with the
        AIS object that owns them inside the :class:`Viewer`.

        Format::

            (shape, owner)
            (shape, owner)

        If the first element of the tuple is a shape, it is a sub-shape
        of the shape related to the owner (the second element of the tuple).

        When the detected entity does not have a shape, the first element
        of the tuple will be `None`, and one should look at the AIS object
        (the owner).

        :rtype: typing.Generator[typing.Tuple[typing.Union[OCC.wrapper.TopoDS.TopoDS_Shape, None], OCC.wrapper.AIS.Handle_AIS_InteractiveObject]]
        """
        context = self._ais_context
        context.InitDetected()  # supports only iteration being active at once
        while context.MoreDetected():
            select_owner = context.DetectedCurrentOwner()
            shape = self._get_selected_shape(select_owner)
            selectable = select_owner.Selectable()
            ais = Handle_AIS_InteractiveObject.DownCast(selectable)
            if ais.IsNull():
                # Either the selectable wasn't an interactive object, or
                # the detected entity was Null itself. This shouldn't happen
                # but not 100% sure about that...
                self.logger.debug(f"Cannot downcast detected selectable "
                                  f"to Handle_AIS_InteractiveObject! "
                                  f"owner: {select_owner!r}, "
                                  f"selectable: {selectable!r}.")
            else:
                yield shape, ais
            context.NextDetected()

    @property
    def detected_with_owner(self):
        """Return a list of detected (currently under the cursor) shapes with
        the AIS object that owns them inside the :class:`Viewer`.

        Format::

            [(shape, owner), (shape, owner)]

        If the first element of the tuple is a shape, it is a sub-shape
        of the shape related to the owner (the second element of the tuple).

        When the detected entity does not have a shape, the first element
        of the tuple will be `None`, and one should look at the AIS object
        (the owner).

        :rtype: typing.List[typing.Tuple[typing.Union[OCC.wrapper.TopoDS.TopoDS_Shape, None], OCC.wrapper.AIS.Handle_AIS_InteractiveObject]]
        """
        return list(self.yield_detected_with_owner())

    def yield_displayed(self):
        """Yield currently displayed objects in viewer.

        :rtype: collections.Iterable[OCC.AIS.AIS_InteractiveObject]
        """
        lst = AIS_ListOfInteractive()
        self._ais_context.DisplayedObjects(lst)
        for ais in lst:
            # ATTENTION: take another handle to own this reference,
            # AIS_ListOfInteractive will Nullify() original handle on gc
            yield Handle_AIS_InteractiveObject(ais)

    def yield_hidden(self):
        """Yield currently hidden (erased) objects in viewer.

        :rtype: collections.Iterable[OCC.AIS.AIS_InteractiveObject]
        """
        lst = AIS_ListOfInteractive()
        self._ais_context.ErasedObjects(lst)
        for ais in lst:
            # ATTENTION: take another handle to own this reference,
            # AIS_ListOfInteractive will Nullify() original handle on gc
            yield Handle_AIS_InteractiveObject(ais)

    def is_hidden(self, ais: Handle_AIS_InteractiveObject) -> bool:
        """Return `True` if `ais` is `in_viewer` and hidden. """
        return self._ais_context.DisplayStatus(ais) == AIS_DS_Erased

    def in_viewer(self, ais: Handle_AIS_InteractiveObject) -> bool:
        """Return `True` if `ais` is in a way (hidden/displayed/
        temporarily) in the Viewer.
        """
        return self._ais_context.DisplayStatus(ais) != AIS_DS_None

    @concurrency_guard("selected")
    def yield_selected(self):
        """Yield currently selected objects in viewer.

        :rtype: collections.Iterable[OCC.AIS.AIS_InteractiveObject]
        """
        context = self._ais_context
        context.InitSelected()  # supports only iteration being active at once
        while context.MoreSelected():
            yield context.SelectedInteractive()
            context.NextSelected()

    def _get_selected_shape(
            self, select_owner: "OCC.wrapper.SelectMgr.SelectMgr_EntityOwner"):
        brep_owner = Handle_StdSelect_BRepOwner.DownCast(select_owner)
        if brep_owner.IsNull():  # not a BRepOwner, so it does not have a shape
            msg = (f"Could not retrieve the selected shape! "
                   f"Selected owner is not a BRepOwner. selected "
                   f"owner: {select_owner!r}. Object: {self!r}")
            self.logger.warning(msg)
        elif not brep_owner.HasShape():
            msg = (f"Could not retrieve the selected shape! "
                   f"Selected owner does not have a shape: "
                   f"{brep_owner!r}. Object: {self!r}")
            self.logger.warning(msg)
        else:
            return brep_owner.Shape()

        return None

    @concurrency_guard("selected")
    def yield_selected_with_owner(self):
        """Generate a list selected shapes with the AIS object that owns
        them inside the :class:`Viewer`.

        Format::

            (shape, owner)
            (shape, owner)

        If the first element of the tuple is a shape, it is a sub-shape
        of the shape related to the owner (the second element of the tuple).

        When the selected entity does not have a shape, the first element
        of the tuple will be `None`, and one should look at the AIS object
        (the owner).

        :rtype: typing.Generator[typing.Tuple[typing.Union[OCC.wrapper.TopoDS.TopoDS_Shape, None], OCC.wrapper.AIS.Handle_AIS_InteractiveObject]]
        """
        context = self._ais_context
        context.InitSelected()  # supports only iteration being active at once
        while context.MoreSelected():
            select_owner = context.SelectedOwner()
            shape = self._get_selected_shape(select_owner)
            owner = context.SelectedInteractive()
            yield shape, owner
            context.NextSelected()

    @property
    def selected_with_owner(self):
        """Return a list of selected shapes with the AIS object that owns
        them inside the :class:`Viewer`.

        Format::

            [(shape, owner), (shape, owner)]

        If the first element of the tuple is a shape, it is a sub-shape
        of the shape related to the owner (the second element of the tuple).

        When the selected entity does not have a shape, the first element
        of the tuple will be `None`, and one should look at the AIS object
        (the owner).

        :rtype: typing.List[typing.Tuple[typing.Union[OCC.wrapper.TopoDS.TopoDS_Shape, None], OCC.wrapper.AIS.Handle_AIS_InteractiveObject]]
        """
        return list(self.yield_selected_with_owner())

    def is_displayed(self, obj):
        """Returns true if ``obj`` is currently displayed.

        :param OCC.AIS.AIS_InteractiveObject obj: object to test
        :rtype: bool
        """
        return self._ais_context.IsDisplayed(obj)

    def zoom(self, factor):
        """Zoom by ``factor``:

        - Zoom out: 0 < factor < 1.
        - Zoom in: 1 < factor.

        :param float factor: 0 < factor
        """
        self._v3d_view.SetZoom(factor)

    def fit_window(self, x1, y1, x2, y2):
        """Fit window between pixels."""
        self._v3d_view.WindowFit(x1, y1, x2, y2)

    def is_highlighted(self, obj):
        return self._ais_context.IsHilighted(obj)

    def highlight(self, obj, color=None, fill_color=None,
                  display_mode=None, ensure_visible=False, update=True):
        """Highlight ``obj``, optionally with ``color``, in the viewer.

        Return `True` if the object was indeed highlighted, `False` otherwise.

        :param OCC.AIS.AIS_InteractiveObject obj: object to highlight
        :param str|(int, int, int)|int|None color: highlight color
        :param str|(int, int, int)|int|None fill_color: Color the face
            should get (does not work with an edges-only `display_mode`
            like `wireframe`)
        :param str display_mode: How should the object be displayed on
            highlighting? In addition to 'wireframe' and 'shaded', there is
            also a 'default' display mode which defaults to the currently
            active Viewer display_mode. (Default: `None` which implies
            'wireframe')
        :param bool ensure_visible: If set to `True` makes sure that the
            shape is displayed in the viewer.
        :param bool update: update viewer?
        :rtype: bool
        """
        if not self.is_displayed(obj):  # hidden OR not in_viewer
            if ensure_visible:
                self.display(obj, update=False, fit=False)
            else:
                return False  # highlighting non-displayed items segfaults

        if (color is not None or fill_color is not None or
                display_mode is not None):
            style = Prs3d_Drawer().handle
            if color is not None:
                q_color = py_QuantityColor(color, str_default=None)
                style.SetColor(q_color)

            if fill_color is not None:
                fill_style = Graphic3d_AspectFillArea3d().handle
                fill_q_color = py_QuantityColor(fill_color, str_default=None)
                fill_style.SetInteriorColor(fill_q_color)

                style.SetBasicFillAreaAspect(fill_style)

            if display_mode is not None:
                if display_mode == "default":
                    mode = -1
                else:
                    mode = self.py_DisplayMode[display_mode]
                style.SetDisplayMode(mode)

            self._ais_context.HilightWithColor(obj, style, update)
        else:
            self._ais_context.Hilight(obj, update)

        return True

    def unhighlight(self, obj, update=True):
        """Unhighlight a highlighted ``obj`` in the Viewer.

        :param OCC.wrapper.AIS.AIS_InteractiveObject obj: object
            to unhighlight.
        :param bool update: update viewer? (Default: `True`)
        :return: `True` if succesful, `False` otherwise (probably the shape
            was not highlighted).
        :rtype: bool
        """
        restore_hidden = False
        if not (self.in_viewer(obj) and self.is_highlighted(obj)):
            return False

        if self.is_hidden(obj):
            # it does not go well when unhighlighting a hidden shape so,
            # without updating, we show the shape, unhighlight it, and restore
            # the hidden state
            restore_hidden = True
            self.display(obj, update=False, fit=False)

        # if not restoring, we should update after this call
        context = self._ais_context
        context.Unhilight(obj, False)
        # unhighlight might remove 'selected' highlighting, restored by:
        context.UpdateSelected(update and not restore_hidden)

        if restore_hidden:
            # if restoring, we only should update at this point
            self.hide(obj, update=update and restore_hidden, fit=False)
        return True

    # FIXME (TBD): Doesn't work too well, some isolines still show, leaves
    #  objects in wireframe display mode
    # FIXME no black border in shaded mode.
    def unhighlight_all(self, update=True):
        self._v3d_viewer.UnHighlight()
        if update:
            self.update()
        # self._ais_context.UnhilightSelected(update)
        # self._ais_context.UnhilightCurrents(update)

    def enable_highlighting(self):
        warnings.warn("enable_highlighting is deprecated, "
                      "use enable_highlight_selected instead!",
                      OCCDeprecationWarning, stacklevel=2)
        self.enable_highlight_selected()

    def disable_highlighting(self):
        warnings.warn("disable_highlighting is deprecated, "
                      "use disable_highlight_selected instead!",
                      OCCDeprecationWarning, stacklevel=2)
        self.disable_highlight_selected()

    def disable_highlight_selected(self):
        self._ais_context.SetToHilightSelected(False)

    def enable_highlight_selected(self):
        self._ais_context.SetToHilightSelected(True)

    def highlighting_selected_enabled(self):
        return self._ais_context.ToHilightSelected()

    def enable_automatic_highlighting(self):
        """Enable the automatic highlighting feature `AutomaticHilight`."""
        self._ais_context.SetAutomaticHilight(True)

    def disable_automatic_highlighting(self):
        """Disable the automatic highlighting feature `AutomaticHilight`."""
        self._ais_context.SetAutomaticHilight(False)

    def automatic_highlighting_enabled(self):
        """This is, by default, enabled and will make sure that,
        for instance, shapes are highlighted when hovering over them.
        """
        return self._ais_context.AutomaticHilight()

    def toggle_axes(self):
        if self.triedron:
            self._v3d_view.TriedronErase()
        else:
            self.init_triedron()
        self.update()
        self.triedron = not self.triedron

    # TODO (RVD): test again once FreeImage and Gl2PS libraries are present
    # FIXME (TBD): investigate why bitmap images get corrupted
    def save_image(self, filename: str, width: int = None, height: int = None):
        """Dump the full contents of the view at the same scale in the
        file ``filename``. The file name extension must be one of
        'gif', 'bmp', 'jpg', 'png', 'pgf', 'ps', 'emf', 'svg', 'eps', 'tex',
        'pdf'. Returns False when the dump has failed.

        :param filename: full pathname to image file.
        :param width: width of the image in pixels. Defaults to the width of
            the Viewer.
        :param height: height of the image in pixels. Defaults to the height
            of the Viewer.
        :rtype: bool
        """
        filename = os.path.abspath(filename)
        _, ext = os.path.splitext(filename)
        ext = ext[1:].lower()
        if ext in VALID_BITMAP_EXTENSIONS_SET:
            pixmap = Image_AlienPixMap()
            viewer_size = self.Size
            w = width or viewer_size[0]
            h = height or viewer_size[1]

            # Creating an image through ToPixMap seems to have more consistent
            # behaviour on Linux
            success = self._v3d_view.ToPixMap(pixmap, w, h)
            if success:
                ascii_filename = TCollection_AsciiString(filename)
                success = pixmap.Save(ascii_filename)

        # TODO (PP): uncomment when vector export is supported again
        # elif ext in VALID_VECTOR_EXTENSIONS_SET:
        #     format = ext_Graphic3d_ExportFormat[ext]
        # TODO (RvD): Changing to _v3d_view at least gets grey stuff.
        # /todo Maybe it is not rendered using OpenGl? Or another
        # /todo or maybe just something very different...
        # success = self._graphic3d_cview.Export(str(filename), format)
        # success = self._v3d_view.Export(str(filename), format)
        else:
            msg = "File extension '.{}' not supported. Choose one of {}."
            raise RuntimeError(msg.format(ext, VALID_IMAGE_EXTENSIONS))

        if success:
            print("Saved image to:", os.path.abspath(filename))
        else:
            msg = "Saving image failed. Requested location: '{}'."
            self.logger.warning(msg.format(filename))

        return success

    def _conform_selection_mode(self, mode: Union[str, int]) -> int:
        if isinstance(mode, str):
            try:
                return NAME_TO_SEL_MODE[mode]
            except KeyError:
                raise ValueError(f"Unknown selection mode! Supported modes: "
                                 f"{sorted(NAME_TO_SEL_MODE.keys())}. "
                                 f"Object: {self!r}")
        elif isinstance(mode, int):
            return mode
        else:
            raise TypeError(f"Selection mode should be a str or an int! "
                            f"Got: {type(mode)!r}. Object: {self!r}")

    def activate_selection_mode(self, mode: Union[str, int] = "default",
                                obj: "Handle_AIS_InteractiveObject" = None,
                                force=False):
        """Activate a (sub-shape) selection mode for one or all objects
        currently in the viewer. Multiple modes can be activated at the
        same time.

        When calling this method without arguments, it resets the viewer to
        the default setting.

        :param mode: A string ('vertices', 'edges', ...., 'compounds' or
            'default') specifying the mode to be activated. Here
            'default' is the normal 'whole shape' selection mode.
            Alternatively specify an int, which will correspond to how it
            works in opencascade.
        :param obj: Object to activate the selection mode on. When not set,
            it will apply the selection mode on all objects currently
            displayed in the viewer.
        :param force:
        """
        sel_mode = self._conform_selection_mode(mode)
        args = [obj, sel_mode] if obj else [sel_mode]
        self._ais_context.Activate(*args, force)

    def deactivate_selection_mode(self, mode: Union[str, int] = None,
                                  obj: "Handle_AIS_InteractiveObject" = None):
        """Deactivate a (sub-shape) selection mode for one or all objects
        currently in the viewer.

        When calling this method without arguments, it removes all selection
        modes, including the 'default' one, making all objects non-selectable.

        :param mode: A string ('vertices', 'edges', ...., 'compounds' or
            'default') specifying the mode to be deactivated. Here
            'default' is the normal 'whole shape' selection mode.
            Alternatively specify an int, which will correspond to how it
            works in opencascade.
        :param obj: Object to deactivate the selection mode on. When not set,
            it will deactivate the selection mode on all objects currently
            displayed in the viewer.
        """
        args = [obj] if obj else []
        if mode is not None:
            sel_mode = self._conform_selection_mode(mode)
            args.append(sel_mode)
        self._ais_context.Deactivate(*args)

    def get_active_selection_modes(
            self, obj: "Handle_AIS_InteractiveObject") -> Set[str]:
        """Get the selection modes currently active on `obj`.

        .. note:: Currently only returns the modes as the names used
            by activate/ deactivate selection mode. Special modes not covered
            by these names, that would have been specified using integers,
            will appear as `None` in te end-results.
        """
        modes = TColStd_ListOfInteger()
        self._ais_context.ActivatedModes(obj, modes)
        return set(map(SEL_MODE_TO_NAME.get, modes))

    def _mark_area(self, evt):
        x1_, y1_ = self._drag_x1_y1
        x2_, y2_ = evt.GetX(), evt.GetY()
        if x1_ <= x2_:
            x1, x2 = x1_, x2_
        else:
            x1, x2 = x2_, x1_
        if y1_ <= y2_:
            y1, y2 = y1_, y2_
        else:
            y1, y2 = y2_, y1_
        self._selected_area = (x1, y1, x2, y2)

    def _draw_rubberband(self):
        # use latency to not draw rectangle too often
        t2 = time.time()
        t1 = self._drag_t1
        if t2 - t1 < self.LATENCY:
            return
        else:
            self._drag_t1 = t2

        x1, y1, x2, y2 = self._selected_area
        x, y, w, h = x1, y1, x2 - x1, y2 - y1

        # self.dc.Clear()
        self.update()

        self._dc.DrawLineList(((x, y, x + w, y),
                               (x + w, y, x + w, y + h),
                               (x + w, y + h, x, y + h),
                               (x, y + h, x, y)))

        # transparent rectangle not working...
        # rect = wx.Rect(x, y, w, h)
        # self.dc.DrawRectangle(rect)

    # ---- event handlers ----
    def OnKeyW(self, evt):
        self.set_display_mode_wireframe()

    def OnKeyS(self, evt):
        self.set_display_mode_shaded()

    def OnKeyF(self, evt):
        self.fit_all()

    def OnKeyQ(self, evt):
        self.set_display_mode_hlr()

    def OnKeyC(self, evt):
        if evt.ShiftDown():
            self.display_all()
        else:
            self.hide_all()

    def OnKeyA(self, evt):
        if evt.ControlDown():
            self.select_all()

    def OnKeyDEL(self, evt):
        self.hide_selected_objects()

    def onKeyESC(self, evt):
        self.deselect_all()

    def _schedule(self, callback, *args, **kwargs):
        # make sure there's a running Wx app
        app = wx.GetApp() or wx.App()

        wx.CallAfter(callback, *args, **kwargs)

    def OnSize(self, evt):
        self._schedule(self._OnSize)

    def _OnSize(self):
        self._v3d_view.MustBeResized()

    def OnPaint(self, evt):
        self._schedule(self._OnPaint)

    def _OnPaint(self):
        self._v3d_view.Update()

    def OnKeyDown(self, evt):
        code = evt.GetKeyCode()
        try:
            call_me = self._keymap[code]
        except KeyError:
            pass
        else:
            call_me(evt)

    def OnLeftDown(self, evt):
        self.left_m_down = True
        self.leftIsUp = False
        self.SetFocus()
        self._dragged = False
        self._drag_x1_y1 = x, y = evt.GetX(), evt.GetY()
        if evt.ShiftDown():
            self._drag_t1 = time.time()
        else:
            self._v3d_view.StartRotation(x, y)

    def OnLeftUp(self, evt):
        self.left_m_down = False
        shift_down = evt.ShiftDown()

        status = None
        if not self._dragged:  # pure click
            status = self.select_under_mouse(evt.Position, shift=shift_down)
        elif self._selected_area:  # small motions can be filtered out
            # self.dc.Clear()
            x1, y1, x2, y2 = self._selected_area
            status = self.select_area(x1, y1, x2, y2, shift=shift_down)
            self._selected_area = None

        if status is not None:
            evt_pos = evt.GetPosition()
            # 1. pure left-click background
            if status is AIS_SOP_NothingSelected:
                if not self._dragged:  # filter out dragging
                    if not shift_down:  # filter out shift left-click
                        evt = create_left_click_background_event(
                            evt_pos)
                        wx.PostEvent(self, evt)
            else:
                # something was really clicked
                if self._ais_context.HasDetected():
                    # 2. left-clicked something, single object selected
                    if status is AIS_SOP_OneSelected:
                        evt = create_left_click_object_event(
                            evt_pos, self.yield_selected(), False)
                        wx.PostEvent(self, evt)
                    # 3. left-clicked something, multiple objects selected
                    elif status is AIS_SOP_SeveralSelected:
                        evt = create_left_click_object_event(
                            evt_pos, self.yield_selected(), True)
                        wx.PostEvent(self, evt)

    def OnMiddleDown(self, evt):
        self._dragged = False
        self._drag_x1_y1 = evt.GetX(), evt.GetY()

    def OnRightDown(self, evt):
        self.right_m_down = True
        self._dragged = False
        self._drag_x1_y1 = evt.GetX(), evt.GetY()
        if evt.ShiftDown():
            self._drag_t1 = time.time()
        else:
            self._selected_area = None

    def OnRightUp(self, evt):
        self.right_m_down = False
        if not self._dragged:  # pure click
            evt_pos = evt.GetPosition()
            if self._ais_context.HasDetected():  # right-clicked something
                it_detected = self.yield_detected()
                topmost_detected = next(it_detected)  # top-most object
                # 1. right-clicked already selected objects
                if self._ais_context.IsSelected(topmost_detected):
                    # don't select again, see if there were multiple selected
                    it_selected = self.yield_selected()
                    first = next(it_selected)
                    try:
                        second = next(it_selected)
                    except StopIteration:
                        multiple = False
                        it = itertools.chain((first,), it_selected)
                    else:
                        multiple = True
                        it = itertools.chain((first, second), it_selected)
                    evt = create_right_click_object_event(
                        evt_pos, it, multiple)
                    wx.PostEvent(self, evt)
                # 2. right-clicked object that isn't selected yet
                else:
                    # shift is irrelevant
                    status = self.select_under_mouse(evt.Position, shift=False)
                    if status is not AIS_SOP_OneSelected:
                        msg = ("Expected to right-click single object that "
                               "wasn't already selected, didn't happend. "
                               "Contact support@parapy.nl")
                        self.logger.warning(msg)
                    else:
                        evt = create_right_click_object_event(
                            evt_pos, self.yield_selected(), False)
                        wx.PostEvent(self, evt)
            # 3. right-clicked background
            else:
                # force clearing previous selection
                status = self.select_under_mouse(evt.Position, shift=False)
                if status is not AIS_SOP_NothingSelected:
                    msg = ("Expected to right-click background, but something "
                           "was selected instead. Contact support@parapy.nl")
                    self.logger.warning(msg)
                else:
                    evt = create_right_click_background_event(
                        evt_pos)
                    wx.PostEvent(self, evt)

        elif self._selected_area:  # small motions can be filtered out
            # self.dc.Clear()
            x1, y1, x2, y2 = self._selected_area
            self.fit_window(x1, y1, x2, y2)
            self._selected_area = None

    def OnMotion(self, evt):
        if evt.Dragging():
            self._dragged = True
            if evt.LeftIsDown():
                # mode: area zoom
                if evt.ShiftDown():
                    self._mark_area(evt)
                    self._draw_rubberband()
                # mode: rotate
                else:
                    x, y = evt.GetX(), evt.GetY()
                    self._v3d_view.Rotation(x, y)
            elif evt.RightIsDown():
                # mode: area select
                if evt.ShiftDown():
                    self._mark_area(evt)
                    self._draw_rubberband()
                # mode: dynamic zoom
                else:
                    x, y = evt.GetX(), evt.GetY()
                    x_old, y_old = self._drag_x1_y1
                    dy = y_old - y  # positive is 'up'
                    # ATTENTION: OCC does not understand y coordinate, use x
                    self._v3d_view.Zoom(0, 0, dy, 0)
                    self._drag_x1_y1 = y, y
            # mode: pan
            elif evt.MiddleIsDown():
                x, y = evt.GetX(), evt.GetY()
                x_old, y_old = self._drag_x1_y1
                dx = x - x_old
                dy = y_old - y  # negative y
                self._v3d_view.Pan(dx, dy)
                self._drag_x1_y1 = x, y
        else:
            x, y = evt.GetX(), evt.GetY()
            self.move_to(x, y)

    def OnWheelScroll(self, evt):
        delta = evt.GetWheelDelta()
        rotation = evt.GetWheelRotation()
        rate = evt.GetLinesPerAction()
        shift_down = evt.ShiftDown()

        zoom_rate = rate * float(abs(rotation)) / delta

        if zoom_rate <= 0:
            zoom_rate = 0.2

        if shift_down:  # precision zooming
            zoom_rate /= 10.

        zoom_factor = 1. + zoom_rate
        if rotation < 0:  # take reciprocal for zooming out
            zoom_factor = 1. / zoom_factor

        self.zoom(zoom_factor)

    def OnEraseBackground(self, evt):
        pass

    def on_enter_window(self, evt):
        # This is done to make sure that when a pop-up is clicked away
        # with a right-click, no zooming will happen.
        self._drag_x1_y1 = evt.GetX(), evt.GetY()
        evt.Skip()


class ViewerWindow(wx.Frame):
    def __init__(self, show=True, title="ParaPy Graphical User Interface"):
        wx.Frame.__init__(self, None, -1, title)
        self.viewer = Viewer(self)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.viewer, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetAutoLayout(True)
        sizer.Layout()

        # do this after V3D_View has been created...
        self.Show(show)


class ZLayers(object):
    """Object to manage Z-layers in :class:`Viewer`.

    >>> layers = viewer.zlayers
    >>> layers.layer_ids()
    [-5, 0, -2, -3, -4]
    >>> layers.top_most_layer_id()
    -4
    >>> layers.add_layer()
    1
    >>> layers.layer_ids()
    [-5, 0, 1, -2, -3, -4]
    >>> layers.top_most_layer_id()
    -4
    >>> layers.top_most_layer_id(exclude_default_layers=True)
    1
    >>> layers.remove_layer(1)

    .. note:: for developers, default V3d_Viewer layers are (from btm to top):

        * -5: Graphic3d_ZLayerId_BotOSD
        *  0: Graphic3d_ZLayerId_Default
        * -2: Graphic3d_ZLayerId_Top
        * -3: Graphic3d_ZLayerId_Topmost
        * -4: Graphic3d_ZLayerId_TopOSD
    """

    def __init__(self, v3d_viewer):
        self._v3d_viewer = v3d_viewer

    def layer_ids(self, exclude_default_layers=False):
        """Return all Z layer ids in sequence ordered by overlay level from
        lowest layer to highest (foreground). The first layer ID in sequence
        is the default layer that can't be removed. Optionally, you can
        ``exclude_default_layers``, which will only return ids of layers added
        after the Viewer was created. This can be an empty list.

        :rtype: list[int]
        """
        ids = TColStd_SequenceOfInteger()
        self._v3d_viewer.GetAllZLayers(ids)
        if exclude_default_layers:
            # OCC default layers are all <= 0
            return [i for i in ids if i > 0]
        else:
            return list(ids)

    def top_most_layer_id(self, exclude_default_layers=False):
        """Get top-most layer id. Optionally, you can
        ``exclude_default_layers``, which will limit search to only those
        layers added after the Viewer was created. If no layers were added,
        :py:`None` is returned.

        :rtype: int | None
        """
        lst = self.layer_ids(exclude_default_layers=exclude_default_layers)
        if lst:
            return lst[-1]
        else:
            return None

    def add_layer(self):
        """Add a new top-level Z layer and get its ID.

        :rtype: int
        :raises RuntimeError: if layer couldn't be created.
        """
        flag, layer_id = self._v3d_viewer.AddZLayer()
        if not flag:
            raise RuntimeError("Layer couldn't be created")
        return layer_id

    def remove_layer(self, layer_id):
        """Remove Z layer by it's ``layer_id``.

        :param int layer_id:
        :raises RuntimeError: if layer couldn't be removed, by default there
            are always default bottom-level layer(s) that can't be removed.
        """
        flag = self._v3d_viewer.RemoveZLayer(layer_id)
        if not flag:
            raise RuntimeError("Layer couldn't be removed")
        return layer_id


if __name__ == '__main__':
    from OCC.wrapper.BRepPrimAPI import (
        BRepPrimAPI_MakeBox, BRepPrimAPI_MakeSphere)

    app = wx.GetApp() or wx.App(False)
    wx.SafeYield()
    frame = ViewerWindow()
    viewer = frame.viewer

    box = BRepPrimAPI_MakeBox(1, 2, 3)
    sphere = BRepPrimAPI_MakeSphere(1)

    ais_shape1 = viewer.display_topods_shape(box.Shape())
    ais_shape2 = viewer.display_topods_shape(sphere.Shape())
    ais_trihedron1 = viewer.display_trihedron((2, 2, 0), zoom_persistent=True)
    ais_trihedron2 = viewer.display_trihedron((3, 3, 0), zoom_persistent=False)
    ais_text = viewer.display_text("Value: 1.0", (1.5, 1, 0), top_most=True)
    ais_text = viewer.display_text("Value: 2.0", (2.0, 1, 0), top_most=True)
    # viewer.highlight(ais_shape1, "red")

    # viewer.add_clipplane((0, 0, 0.3), (0, 0, 1))
    # viewer.add_clipplane((0, 0, 0.4), (0, 0, -1))

    frame.Maximize()
    frame.Raise()
    app.SetTopWindow(frame)

    app.MainLoop()

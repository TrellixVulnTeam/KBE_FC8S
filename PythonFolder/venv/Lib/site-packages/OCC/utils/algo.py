#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Boolean algorithms. Beware:

When doing booleans on complex B-Spline structures, parallel computation
actually decreases performance.
"""

import io
import warnings

from OCC.wrapper.BOPAlgo import BOPAlgo_MakerVolume
from OCC.wrapper.BRepAlgoAPI import (
    BRepAlgoAPI_Common, BRepAlgoAPI_Cut, BRepAlgoAPI_Fuse)
from OCC.wrapper.GEOMAlgo import GEOMAlgo_Gluer, GEOMAlgo_Splitter
from OCC.wrapper.ShapeUpgrade import ShapeUpgrade_UnifySameDomain
from OCC.utils.top import create_toptools_listofshape
from OCC.utils.utilities import make_TopoDS_Compound


def fuse(shape, tools, parallel=True, fuzzyval=None):
    builder = BRepAlgoAPI_Fuse()
    builder.SetArguments(create_toptools_listofshape([shape]))
    if not hasattr(type(tools), "__iter__"):
        tools = tools,
    builder.SetTools(create_toptools_listofshape(tools))
    if parallel:
        builder.SetRunParallel(True)
    if fuzzyval is not None:
        builder.SetFuzzyValue(fuzzyval)
    builder.Build()
    assert builder.IsDone()
    return builder.Shape()


def subtract(shape, tools, parallel=True, fuzzyval=None):
    builder = BRepAlgoAPI_Cut()
    builder.SetArguments(create_toptools_listofshape([shape]))
    if not hasattr(type(tools), "__iter__"):
        tools = tools,
    builder.SetTools(create_toptools_listofshape(tools))
    if parallel:
        builder.SetRunParallel(True)
    if fuzzyval is not None:
        builder.SetFuzzyValue(fuzzyval)
    builder.Build()
    assert builder.IsDone()
    return builder.Shape()


def common(shape, tools, parallel=True, fuzzyval=None):
    builder = BRepAlgoAPI_Common()
    builder.SetArguments(create_toptools_listofshape([shape]))
    if not hasattr(type(tools), "__iter__"):
        tools = tools,
    builder.SetTools(create_toptools_listofshape(tools))
    if parallel:
        builder.SetRunParallel(True)
    if fuzzyval is not None:
        builder.SetFuzzyValue(fuzzyval)
    builder.Build()
    assert builder.IsDone()
    return builder.Shape()


def volume_maker(arguments, parallel=True, fuzzyval=None, intersect=True):
    """Split shape into solids.

    .. note:: tools can not be infinite planes.

    :param arguments:
    :param parallel:
    :param fuzzyval:
    :param intersect:
    :return:
    """
    builder = BOPAlgo_MakerVolume()
    if parallel:
        builder.SetRunParallel(True)
    if fuzzyval is not None:
        builder.SetFuzzyValue(fuzzyval)
    if not hasattr(type(arguments), "__iter__"):
        arguments = (arguments,)
    builder.SetArguments(create_toptools_listofshape(arguments))
    builder.SetIntersect(intersect)
    builder.Perform()
    # assert not builder.ErrorStatus()
    return builder.Shape()


def unify_same_domain(shape, unify_edges=False, unify_faces=True,
                      concat_bsplines=False):
    """Unifies same domain faces and edges of specified shape.

    :param OCC.TopoDS.TopoDS_Shape shape: shape to unify.
    :param bool unify_edges: unify edges?
    :param bool unify_faces: unify faces?
    :param bool concat_bsplines: concatenate C1 BSpline curves?
    :rtype: OCC.TopoDS.TopoDS_Shape
    """
    builder = ShapeUpgrade_UnifySameDomain(shape, unify_edges, unify_faces,
                                           concat_bsplines)
    builder.Build()
    return builder.Shape()


def glue_solids(solids, check_geometry=True, compute_internal_shapes=False,
         tolerance=1.0e-6, keep_non_solids=False):
    """ Glues ``solids`` together.
    
    :param collections.Sequence[OCC.TopoDS.TopoDS_Shape] solids: the solids to
        be glued together.
    :param bool check_geometry: Check the geometry of the output.
    :param bool compute_internal_shapes: 
    :param bool tolerance: Set the tolerance used for the glueing.
    :param bool keep_non_solids: keep non solids in the result
    :rtype: OCC.GEOMAlgo.GEOMAlgo_Gluer
    """
    builder = GEOMAlgo_Gluer()
    compound = make_TopoDS_Compound(solids)
    builder.SetShape(compound)
    builder.SetCheckGeometry(check_geometry)
    builder.ComputeInternalShapes(compute_internal_shapes)
    builder.SetTolerance(tolerance)
    builder.SetKeepNonSolids(keep_non_solids)
    builder.Perform()

    error_status = builder.ErrorStatus()
    warning_status = builder.WarningStatus()

    if not error_status == 0:
        msg = "GEOMAlgo_Gluer failed with status: {:}"
        raise Exception(msg.format(error_status))
    if not warning_status == 0:
        msg = "GEOMAlgo_Gluer warned with status: {:}"
        warnings.warn(msg.format(warning_status))

    return builder


def split_solid(solid, tools, keep_tools=[], parallel=True):
    """Spilt ``solid`` using ``tools``.
    
    :param OCC.TopoDS.TopoDS_Shape solid: A solid that will be cut by ``tools``
    :param collection.Sequence[OCC.TopoDS.TopoDS_Shape] tools: tools to
        cut ``solid`` with.
    :param collections.Sequence[bool] keep_tools: list booleans, corresponding
        to the list of tools, with keep_tools[i] set to True if tools[i] should
        be kept.
    :param bool parallel: Run this algorithm in parallel
    :rtype: OCC.GEOMAlgo.GEOMAlgo_Splitter
    """
    splitter = GEOMAlgo_Splitter()
    splitter.AddArgument(solid)
    if not keep_tools:
        keep_tools = [False] * len(tools)
    for tool, keep in zip(tools, keep_tools):
        if keep:
            splitter.AddArgument(tool)
        else:
            splitter.AddTool(tool)

    splitter.SetRunParallel(parallel)
    splitter.Perform()

    if splitter.HasErrors():
        s = io.BytesIO()
        splitter.DumpErrors(s)
        s.seek(0)

        msg = "GEOMAlgo_Splitter failed: {}."
        raise RuntimeError(msg.format(s.read().decode('ascii')))

    if splitter.HasWarnings():
        s = io.BytesIO()
        splitter.DumpWarnings(s)
        s.seek(0)

        msg = "GEOMAlgo_Splitter warns: {}."
        warnings.warn(msg.format(s.read().decode('ascii')))

    return splitter

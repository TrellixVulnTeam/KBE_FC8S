#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import io
from numbers import Number

import logging

from OCC.wrapper.Quantity import Quantity_Color
from OCC.wrapper.TCollection import TCollection_ExtendedString
from OCC.wrapper.TDF import TDF_LabelSequence
from OCC.wrapper.TDocStd import Handle_TDocStd_Document
from OCC.wrapper.Interface import (Interface_Static_SetIVal, Interface_Static_SetRVal,
                           Interface_Static_IVal, Interface_Static_RVal,
                           Interface_Static_SetCVal, Interface_Static_CVal)
from OCC.wrapper.TopAbs import TopAbs_COMPOUND
from OCC.wrapper.XCAFApp import XCAFApp_Application_GetApplication
from OCC.wrapper.XCAFDoc import XCAFDoc_DocumentTool, XCAFDoc_ColorGen, \
    XCAFDoc_ColorCurv, XCAFDoc_ColorSurf
from OCC.utils.utilities import rgb_QuantityColor, QuantityColor_rgb
from OCC.utils.top import TopAbs2Class
from OCC.utils.patched.tdf import *
from OCC.utils.patched.tcol import *

__all__ = ["CAFControl_Writer", "CAFControl_Reader", "CAFDoc", "CAFAssembly",
           "CAFDocElement", "CAFShape"]


class CAFDoc(object):
    def __init__(self, settings=[]):
        """ A document constructor that writes shapes to a structured file.

        :param collections.Sequence[collections.Sequence[str, any]] settings:
            some OCC-specific settings for STEPWriter, IGESWriter classes.
            An optional sequence of name-value pairs (str, T). Valid names and
            values are found in the link below. E.g.::

                settings = [("write.step.product.name", "ParaPy STEPWriter"),
                    ("write.step.assembly", 2)]

            http://dev.opencascade.org/doc/overview/html/occt_user_guides__step.html#occt_step_2_3_3
        """
        if not hasattr(self, 'settings') or settings:
            self.settings = settings

        self.app = None
        self.doc = None
        self.shape_tool = None
        self.color_tool = None

    def __enter__(self):
        self.open()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def open(self):
        app = XCAFApp_Application_GetApplication()
        self.app = app
        h_doc = Handle_TDocStd_Document()
        app.NewDocument(TCollection_ExtendedString("MDTV-CAF"), h_doc)

        self.doc = h_doc
        tdf_label = h_doc.Main()
        self.shape_tool = XCAFDoc_DocumentTool().ShapeTool(tdf_label)
        self.color_tool = XCAFDoc_DocumentTool().ColorTool(tdf_label)

    def close(self):
        self.app.Close(self.doc)

    def apply_settings(self, settings):
        """ Applies the settings given in ``settings`` to this writer

        :param collections.Sequence[collections.Sequence[str, any]] settings:
            some OCC-specific settings for STEPWriter, IGESWriter classes.
            An optional sequence of name-value pairs (str, T). Valid names and
            values are found in the link below. E.g.::

                settings = [("write.step.product.name", "ParaPy STEPWriter"),
                    ("write.step.assembly", 2)]

            http://dev.opencascade.org/doc/overview/html/occt_user_guides__step.html#occt_step_2_3_3
        """
        self.settings = settings

    def _apply_settings(self):
        def apply(name, val):
            if isinstance(val, int):
                getter = Interface_Static_IVal
                setter = Interface_Static_SetIVal
            elif isinstance(val, Number):
                getter = Interface_Static_RVal
                setter = Interface_Static_SetRVal
            elif isinstance(val, str):
                getter = Interface_Static_CVal
                setter = Interface_Static_SetCVal
            else:
                raise ValueError("either int, number or str")
            print("original %s: %s" % (name, getter(name)))
            setter(name, val)
            print("new      %s: %s" % (name, getter(name)))

        for name, val in self.settings:
            apply(name, val)

    def resolve_unfound_name(self, shape, mode=1):
        """Tries to resolve a name of an element which can not be found by
        Open Cascade. Returns None if no name can be found

        :param OCC.TopoDS.TopoDS_Shape shape: the currently nameless shape
        :param int mode: The mode for the entity reader
        :rtype: str | None
        """
        return None


class CAFControl_Writer(CAFDoc):

    def __init__(self, settings=[]):
        """ A document constructor that writes shapes to a structured file.

        :param collections.Sequence[collections.Sequence[str, any]] settings:
            some OCC-specific settings for STEPWriter, IGESWriter classes.
            An optional sequence of name-value pairs (str, T). Valid names and
            values are found in the link below. E.g.::

                settings = [("write.step.product.name", "ParaPy STEPWriter"),
                    ("write.step.assembly", 2)]

            http://dev.opencascade.org/doc/overview/html/occt_user_guides__step.html#occt_step_2_3_3
        """
        super(CAFControl_Writer, self).__init__(settings)

        self.writer = self._init_writer()

        self.compounds = {}
        self.shapes = {}

    def add_compound(self, compound, attr_mapping={}):
        """Adds ``compounds`` to be written to the document.
        Duplicate compounds will be removed!

        :param OCC.TopoDS.TopoDS_Compound compound: a compound to be added.
        :param dict[OCC.TopoDS.TopoDS_Shape, dict[str, any]] attr_mapping: A
            mapping of a shape in ``compound`` to a map of attributes.
            Currently only the map only supports a name to a str,
            and a color to a RGB sequence.

            For instance:

                ``attr_mapping`` = {
                    shape : {'name' : 'my_name',
                            'color' : (255, 0, 0)}
                }
        """
        self.compounds[compound] = attr_mapping

    def add_shapes(self, shapes, attr_mapping={}):
        """ Adds some shapes to be written to the document. The shapes can
        be given some attributes. It overwrites shapes that are already present
        in this writer.

        :param collections.Sequence[OCC.TopoDS.TopoDS_Shapes] shapes:
        :param dict[OCC.TopoDS.TopoDS_Shape, dict[str, any]] attr_mapping: A
            mapping of a shape in ``shapes`` to a map of attributes.
            Currently only the map only supports a name to a str,
            and a color to a RGB sequence.

            For instance:

                ``attr_mapping`` = {
                    shape : {'name' : 'my_name',
                            'color' : (255, 0, 0)}
                }
        """
        for shape in shapes:
            try:
                map = attr_mapping[shape]
            except KeyError:
                map = {}

            self.shapes[shape] = map

    def write(self, filename=None):
        """ Write the compounds and shapes in a document to ``filename``

        :param str filename: name of the file to write to
        """
        writer = self.writer
        self._apply_settings()

        writer.SetNameMode(True)
        writer.SetColorMode(True)
        writer.SetLayerMode(True)

        for compound, attr_mapping in self.compounds.items():
            self.tree_fill(compound, attr_mapping)

        shape_tool = self.shape_tool
        for shape, attr_map in self.shapes.items():
            tdf_label = shape_tool.AddShape(shape)

            try:
                self.set_attributes_of_label(tdf_label, attr_map[shape])
            except KeyError:
                pass

        flag = writer.Perform(self.doc, filename) #, STEPControl_AsIs)
        print("Written:", filename)
        if not flag:
        #     # writer.Write(filename)
        #     print "Written:", filename
        # else:
            raise Exception("transfer failed")

    def _init_writer(self):
        raise NotImplementedError()

    def tree_fill(self, compound, attr_mapping={}):
        """Creates a hierarchy in XCAF and adds it to ``shape_tool``. Also
        tries to append names and colors to the shapes inside compound using
        the map ``attr_mapping``.

        :param OCC.TopoDS.TopoDS_Compound compound: A compound containing all
            the shapes that need to be written to the document.
        :param dict[OCC.TopoDS.TopoDS_Shape, dict[str, any]] attr_mapping: A
            mapping of a shape in ``compound`` to a map of attributes. Currently
            only the map only supports a name to a str, and a color to a RGB
            sequence.

            For instance:

                ``attr_mapping`` = {
                    shape : {'name' : 'my_name',
                            'color' : (255, 0, 0)}
                }
        """
        shape_tool = self.shape_tool
        shape_tool.AddShape(compound)

        # now add names and colors to the TDF_labels.
        for shape, attr_map in attr_mapping.items():
            tdf_label = shape_tool.FindShape(shape)
            if tdf_label.IsNull():
                logging.warning("No label found for: {:}".format(shape))
                continue

            self.set_attributes_of_label(tdf_label, attr_map)

    def set_attributes_of_label(self, tdf_label, attr_map):
        """ Adds attributes like a name and color to a tdf_label.

        :param OCC.TDF.TDF_Label tdf_label: a label to which the ``attr_map``
            should be applied.
        :param dict[str, any] attr_map: a map of attributes. Currently
            only the map only supports a name to a str, and a color to a RGB
            sequence.

            For instance:

                ``attr_map`` = {
                    'name' : 'my_name',
                    'color' : (255, 0, 0)
                }
        """
        color_tool = self.color_tool

        try:  # set name, if any
            tdf_label.set_name(attr_map['name'])
        except KeyError:
            pass

        try:  # set color, if any
            color = Quantity_Color(rgb_QuantityColor(attr_map['color']))
            color_tool.SetColor(tdf_label, color, XCAFDoc_ColorGen)
        except KeyError:
            pass


class CAFControl_Reader(CAFDoc):
    """Abstract Base Class for STEPReader and IGESReader"""

    def __init__(self, settings=[]):
        """

        :param collections.Sequence[tuple[str, any]] settings: An optional
            iterable of tuples with name-value pairs. Valid names and values
            are found in the link below. E.g.::

                settings = [("read.precision.mode", 1),
                            ("read.precision.val", 1.0e-3),
                            ("xstep.cascade.unit", "MM")]

            http://dev.opencascade.org/doc/overview/html/occt_user_guides__step.html#occt_step_2_3_3
        """
        super(CAFControl_Reader, self).__init__(settings)
        self.filename = None
        self.reader = self.__readerclass__()

    def read(self, filepath):
        """ Read the CAF document from ``filepath``

        :param str filepath: file to read
        """
        self.filename = filepath
        reader = self.reader
        status = reader.ReadFile(filepath)
        if not status == 1:
            raise Exception("reading failed")

        self._apply_settings()

        reader.SetColorMode(True)
        reader.SetNameMode(True)
        reader.SetLayerMode(True)

        NbRoots = reader.NbRootsForTransfer()
        print("Found {no} top-level assemblies in the STEP file:".format(
            no=NbRoots))
        reader.Transfer(self.doc)

    @property
    def tdf_label_assemblies(self):
        """
        Returns all free shape labels. These are the top-level assemblies of
        the tree.

        :rtype: list[OCC.TDF.TDF_Label]
        """
        result = []
        seq = TDF_LabelSequence()
        self.shape_tool.GetFreeShapes(seq)
        for i in range(seq.Length()):
            result.append(seq.Value(i + 1))
        return result

    @property
    def assemblies(self):
        """
        Sequence of STEP assemblies found in the STEP file.

        :rtype: list[CAFDocElement]
        """
        assemblies = []
        for label in self.tdf_label_assemblies:
            if self.shape_tool.IsAssembly(label):
                assemblies.append(CAFAssembly(label, self))
            else:
                assemblies.append(CAFShape(label, self))
        return assemblies

    def print_tree(self):
        """
        Print the CAF tree to stdout
        """
        assembly_message = "Assembly {}:"
        shape_message = "Shape {} of type {}, color {}"

        def print_tree(stream, elem, level):
            """ Print the stubstree starting at elem to a stream

            :param stream stream: stream where the data is written
            :param CAFDocElement elem:
            :param int level: current level in the tree
            """
            ind = '\t' * level
            if isinstance(elem, CAFAssembly):
                stream.write('{}{}\n'.format(ind, assembly_message.format(
                    elem.name)))
            elif isinstance(elem, CAFShape):
                msg = ind + shape_message.format(elem.name,
                                                 TopAbs2Class[
                                                     elem.shape.ShapeType()],
                                                 elem.color)
                if elem.shape.ShapeType() == TopAbs_COMPOUND:
                    msg += ':'
                stream.write(msg + '\n')
            else:
                raise Exception("Weird type {} in tree!".format(type(elem)))

            for child in elem.children:
                print_tree(stream, child, level + 1)

        tree_report = io.StringIO()
        for assem in self.assemblies:
            print_tree(tree_report, assem, level=0)

        print(tree_report.getvalue())

    # ==============================================================================================
    # Search Utilities
    # ==============================================================================================
    def find_entity_by_label(self, string):
        """
        Returns the first STEP entity where string is part of the name used in
        the STEP file.
        """
        def find_in_tree(elem):
            if string in elem.name:
                return elem
            else:
                for child in elem.children:
                    found = find_in_tree(child)
                    if found:
                        return found
            return None

        for el in self.assemblies:
            found = find_in_tree(el)
            if found:
                return found
        return None

    def find_all_entities_by_label(self, string, **kwargs):
        """
        Returns all STEP entities where string is part of the name used in the
        STEP file.
        """
        def find_in_tree(elem):
            found_elems = []
            if string in elem.name:
                found_elems.append(elem)

            for child in elem.children:
                found_elems += find_in_tree(child)

            return found_elems

        elems = []
        for el in self.assemblies:
            elems += find_in_tree(el)
        return elems

    # def save_doc(self, filename = "doc.txt"):
    #     # bugfix: doesn't work.
    #     self.app.SaveAs(self.doc.GetHandle(), TCollection_ExtendedString(filename), TCollection_ExtendedString())
    #     return True

    @property
    def _EntityProperties(self):
        raise NotImplementedError("implemented in STEP and IGES")

    def get_name(self, shape, mode=1):
        """ Returns the name ``shape``.

        :param OCC.TopoDS.TopoDS_Shape shape:
        :param int mode:
        :rtype: str
        """
        raise NotImplementedError("Is implemented in STEPReader, not in "
                                  "IGESReader")


class CAFDocElement(object):
    """
    Either a Shape or Assembly embedded in a CAF document.
    """

    __slots__ = 'label', 'reader', 'referent'

    def __init__(self, label, reader, referent=None):
        """ Creates an assembly of an XCAF document

        :param OCC.TDF.TDF_Label label: the label of this assembly
        :param CAFControl_Reader reader: the reader object owning this assembly
        :param referent: TDF_Label that referred to this node.
        """
        self.label = label
        self.reader = reader
        self.referent = referent

    @property
    def sub_assemblies(self):
        """ A list of all sub-assemblies of this CAFDocElement

        :rtype: list[CAFAssembly]
        """
        raise NotImplementedError()

    @property
    def sub_shapes(self):
        """ Returns the sub-shapes of this CAFDocElement

        :rtype: list[CAFShape]
        """
        raise NotImplementedError()

    @property
    def children(self):
        """

        :rtype: list[CAFDocElement]
        """
        return self.sub_assemblies + self.sub_shapes

    @property
    def name(self):
        if self.referent:
            return "%s (%s)" % (self.label.get_name(),
                                self.referent.get_name())
        else:
            return self.label.get_name()

    @property
    def info(self):
        stream = io.StringIO('')

        self.label.Dump(stream)
        text = stream.getvalue()
        return text


class CAFAssembly(CAFDocElement):
    """An assembly inside a XCAF document."""

    __slots__ = ()

    def __init__(self, *args, **kwargs):
        super(CAFAssembly, self).__init__(*args, **kwargs)
        if not self.is_assembly:
            raise Exception("CAFAssembly instantiated with non-Assembly label")

    @property
    def is_assembly(self):
        return self.reader.shape_tool.IsAssembly(self.label)

    @property
    def components(self):
        labels = TDF_LabelSequence()
        self.reader.shape_tool.GetComponents(self.label, labels, False)
        return labels.to_list()

    @property
    def sub_assemblies(self):
        """ A list of all sub-assemblies of this assembly

        :rtype: list[CAFAssembly]
        """
        reader = self.reader
        st = reader.shape_tool

        assembly_lst = []
        # We know this is an assembly, so I have components!
        for sublabel in self.components:
            reference = sublabel.get_reference(st)
            if reference:
                if st.IsAssembly(reference):
                    label = reference
                    referent = sublabel
                else:
                    continue

                assembly = CAFAssembly(label=label,
                                       referent=referent,
                                       reader=self.reader)
                assembly_lst.append(assembly)
            else:
                # now test, if sublabels are assemblies or not.
                if st.IsAssembly(sublabel):
                    # sub-assembly, so recurse there
                    assembly = CAFAssembly(label=sublabel,
                                           reader=self.reader)
                    assembly_lst.append(assembly)

        return assembly_lst

    @property
    def sub_shapes(self):
        """ A list of all sub-shapes of this assembly

        :rtype: list[CAFShape]
        """
        reader = self.reader
        st = reader.shape_tool

        shape_lst = []

        # We know this is an assembly, so I have components!
        for sublabel in self.components:
            reference = sublabel.get_reference(st)
            if reference:
                if not st.IsAssembly(reference):
                    cafshape = CAFShape(
                        label=reference,
                        referent=sublabel,
                        reader=self.reader
                    )
                    shape_lst.append(cafshape)
            else:
                if not st.IsAssembly(sublabel):
                    # test if sublabel is a compound.
                    if st.IsSimpleShape(sublabel):
                        cafshape = CAFShape(
                            label=sublabel,
                            reader=self.reader
                        )
                        shape_lst.append(cafshape)

        return shape_lst


class CAFShape(CAFDocElement):
    """
    A TopoDS_Shape in a CAFDoc
    """

    __slots__ = ()

    def __init__(self, *args, **kwargs):
        super(CAFShape, self).__init__(*args, **kwargs)

    @property
    def shape(self):
        """The shape behind this CAF element

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.reader.shape_tool.GetShape(self.label)

    @property
    def sub_assemblies(self):
        return []

    @property
    def sub_shapes(self):
        reader = self.reader
        st = reader.shape_tool

        caf_lst = []

        # if it is a compound, we return the labels of the sub shapes
        if self.shape.ShapeType() == TopAbs_COMPOUND:
            seq = TDF_LabelSequence()
            has_children = st.GetSubShapes(self.label, seq)
            if has_children:
                for sublabel in seq.to_list():
                    cafshape = CAFShape(
                        label=sublabel,
                        reader=self.reader
                    )
                    caf_lst.append(cafshape)
        return caf_lst

    @property
    def color(self):
        """ The color of this shape in RGB

        :return: tuple[int]
        """
        return self.get_color(self.shape)

    def get_color(self, topods_shape):
        """ The color of this shape in RGB

        :return: tuple[int]
        """
        color = Quantity_Color()
        ct = self.reader.color_tool

        ct.GetColor(topods_shape, XCAFDoc_ColorGen, color) or ct.GetColor(
            topods_shape, XCAFDoc_ColorCurv, color) or ct.GetColor(
            topods_shape, XCAFDoc_ColorSurf, color)

        return QuantityColor_rgb(color)

    @property
    def name(self):
        name = super(CAFShape, self).name
        if not name:
            return self.reader.resolve_unfound_name(self.shape)
        else:
            return name

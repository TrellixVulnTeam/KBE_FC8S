#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from OCC.wrapper.MeshVS import (MeshVS_BP_Mesh, MeshVS_DMF_OCCMask, MeshVS_Mesh,
                        MeshVS_MeshPrsBuilder)
from OCC.wrapper.NETGENPlugin import (NETGENPlugin_Hypothesis_2D,
                              NETGENPlugin_NETGEN_2D,
                              NETGENPlugin_NETGEN_2D_ONLY)
from OCC.wrapper.SMESH import SMESH_MeshEditor, SMESH_MeshVSLink, SMESH_SubMeshVSLink
from OCC.wrapper.StdMeshers import (QUAD_STANDARD, StdMeshers_Arithmetic1D,
                            StdMeshers_AutomaticLength,
                            StdMeshers_CompositeSegment_1D,
                            StdMeshers_Deflection1D, StdMeshers_FixedPoints1D,
                            StdMeshers_Hexa_3D,
                            StdMeshers_LayerDistribution,
                            StdMeshers_LengthFromEdges,
                            StdMeshers_LocalLength, StdMeshers_MEFISTO_2D,
                            StdMeshers_MaxElementArea,
                            StdMeshers_MaxLength, StdMeshers_NumberOfLayers,
                            StdMeshers_NumberOfSegments, StdMeshers_Prism_3D,
                            StdMeshers_ProjectionSource1D,
                            StdMeshers_ProjectionSource2D,
                            StdMeshers_Projection_1D,
                            StdMeshers_Projection_1D2D,
                            StdMeshers_Projection_2D, StdMeshers_Propagation,
                            StdMeshers_QuadrangleParams,
                            StdMeshers_Quadrangle_2D,
                            StdMeshers_RadialPrism_3D, StdMeshers_Regular_1D,
                            StdMeshers_SegmentAroundVertex_0D,
                            StdMeshers_SegmentLengthAroundVertex,
                            StdMeshers_StartEndLength,
                            StdMeshers_ViscousLayers,
                            StdMeshers_PropagOfDistribution)
from OCC.wrapper.stdlib import (
    set_SMDS_MeshElementcp_TIDcmp, set_SMDS_MeshNodecp,
    vector_double,
    vector_int)
from OCC.utils import top
from OCC.utils.utilities import distance

__all__ = [""]

_ALGO1D_COMPOSITE = {True: StdMeshers_CompositeSegment_1D,
                     False: StdMeshers_Regular_1D}

_PROP_TYPE = {'distribution': StdMeshers_PropagOfDistribution,
              'hypothesis': StdMeshers_Propagation}


def subshape_ids(elements, mesh):
    """ Return the subshape ids for ``elements`` in a ``mesh``

    :param collections.Sequence[OCC.TopoDS.TopoDS_Shape] elements: list of
        elements that are a part of a ``mesh``.
    :param OCC.SMESH.SMESH_Mesh mesh: the mesh which contains ``elements``.
    :rtype: list[int]
    """
    meshds = mesh.GetMeshDS()
    shape_to_index = meshds.ShapeToIndex
    return [shape_to_index(edge) for edge in elements]


def apply_projection(from_shape, to_shape, id, generator,
                     mesh, hyp, algo, set_source):
    """Applies a projection of ``from_shape`` to ``to_shape``.

    :param OCC.TopoDS.TopoDS_Shape from_shape: The shape that the projection
        goes from.
    :param OCC.TopoDS.TopoDS_Shape  to_shape: The shape that is projected on.
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param type hyp: Hypothesis that sets the source of the
        collection.
    :param type algo: Algorithm to do the projection with.
    :param collections.Callable set_source: a callable that sets the source
        for the hypothesis ``hyp``.
    :return: the last id used these hypotheses
    :rtype: int
    """
    (hyp, hyp2), last_id = add_hypotheses(to_shape, id, mesh, (hyp, algo))
    set_source(hyp, from_shape)

    return last_id


def apply_many_to_many_projection(from_shapes, to_shapes, id, generator,
                                  mesh, hyp, algo, set_source):
    """Applies a projection of ``from_shapes`` to ``to_shapes``.

    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] from_shapes: The
        shapes that the projection goes from.
    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] to_shapes: The
        shapes that are projected on.
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param collections.Callable hyp: Hypothesis that sets the source of the
        collection.
    :param collections.Callable algo: Algorithm to do the projection with.
    :param collections.Callable set_source: a callable that sets the source
        for the hypothesis ``hyp``.
    :return: the last id used these hypotheses
    :rtype: int
    """
    id -= 1  # we are going to add it later
    for source, target in zip(from_shapes, to_shapes):
        # id + 1 since in the last loop, id was set to the last id that was
        # used. We need the id after that.
        id = apply_projection(source, target, id + 1, generator, mesh, hyp,
                              algo, set_source)
    return id


def apply_edge_projection(from_shape, to_shape, id, generator, mesh):
    """Applies a projection of the node distribution on edge ``from_shape`` to
    ``to_shape``.

    Syntactic sugar for :meth:`OCC.utils.mesh.apply_projection`.

    :param OCC.TopoDS.TopoDS_Shape from_shape: The shape that the projection
        goes from.
    :param OCC.TopoDS.TopoDS_Shape  to_shape: The shape that is projected on.
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    return apply_projection(
        from_shape,
        to_shape,
        id,
        generator,
        mesh,
        hyp=StdMeshers_ProjectionSource1D,
        algo=StdMeshers_Projection_1D,
        set_source=StdMeshers_ProjectionSource1D.SetSourceEdge)


def apply_face_projection(from_shape, to_shape, id, generator, mesh,
                          project_edges=True):
    """Applies a projection of ``from_shape`` to ``to_shape`` when a face
    is projected.

    This algorithm works only if all edges of the target face have been meshed
    as 1D Projections of the edges of the source face.
    http://docs.salome-platform.org/salome_6_6_0/gui/SMESH/projection_algos_page.html
    If source_face is a sequence, then shape is also expected to be a list
    with similar length.

    Syntactic sugar for :meth:`OCC.utils.mesh.apply_projection`.

    :param OCC.TopoDS.TopoDS_Shape from_shape: The shape that the projection
        goes from.
    :param OCC.TopoDS.TopoDS_Shape  to_shape: The shape that is projected on.
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param bool project_edges: If you set project_edges = True, this algorithm
        will also map edges. Default: True
        http://docs.salome-platform.org/salome_6_6_0/gui/SMESH/projection_algos_page.html
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    algo = StdMeshers_Projection_1D2D if project_edges \
        else StdMeshers_Projection_2D

    return apply_projection(
        from_shape,
        to_shape,
        id,
        generator,
        mesh,
        hyp=StdMeshers_ProjectionSource2D,
        algo=algo,
        set_source=StdMeshers_ProjectionSource2D.SetSourceFace)


def configure_viscous_faces(hyp, thickness, faces_to_exclude_ids=None,
                            no_layers=2, stretch_factor=1.0):
    """Do the configuration for the viscous_faces mesh.

    :param OCC.StdMeshers.StdMeshers_ViscousLayers hyp: Hypothesis to set
    :param float thickness:
    :param collection.Sequence[int] faces_to_exclude_ids:
        List of face ids in ``mesh`` to exclude in the result.
    :param int no_layers:
    :param stretch_factor:
    """
    if faces_to_exclude_ids:
        ids = vector_int(faces_to_exclude_ids)
        hyp.SetBndShapes(ids, True)

    hyp.SetNumberLayers(no_layers)
    hyp.SetTotalThickness(thickness)
    hyp.SetStretchFactor(stretch_factor)


def apply_netgen_2d(shape, id, generator, mesh):
    """Apply the NETGEN 2D algorithm to ``shape``. This algorithm also takes
    care of the 1D meshing. For that it also
    applies the standard Netgen 2D hypothesis ``NETGENPlugin_Hypothesis_2D``.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    _, last_id = add_hypotheses(shape, id, mesh, (NETGENPlugin_NETGEN_2D,
                                                  NETGENPlugin_Hypothesis_2D))
    return last_id


def apply_netgen_2d_only(shape, id, generator, mesh):
    """Apply the NETGEN 2D ONLY algorithm to ``shape``. For that it also
    applies the standard Netgen 2D hypothesis ``NETGENPlugin_Hypothesis_2D``.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    _, last_id = add_hypotheses(shape, id, mesh, (NETGENPlugin_NETGEN_2D_ONLY,
                                                  NETGENPlugin_Hypothesis_2D))
    return last_id


def apply_segment_length_around_vertex(shape, id, generator, mesh, length):
    (algo, hypo), last_id = add_hypotheses(
        shape, id, mesh, (StdMeshers_SegmentAroundVertex_0D,
                          StdMeshers_SegmentLengthAroundVertex))
    hypo.SetLength(length)
    return last_id


def apply_fixed_number(shape, id, generator, mesh, number, scale_factor=None,
                       expression_function=None, reverse_edges=False,
                       composite=False):
    """Segment the edges in ``shape`` in a fixed number ``number`` of segments.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param int number: the number of segments
    :param float scale_factor:
    :param str expression_function: string containing the expression of the
        function f(t), e.g. "sin(t)"
    :param bool reverse_edges:
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                       (StdMeshers_NumberOfSegments,
                                        _ALGO1D_COMPOSITE[composite]))
    hyp.SetNumberOfSegments(number)

    if scale_factor:
        # print "Distribution type was:", hyp.GetDistrType()
        hyp.SetDistrType(hyp.DT_Scale)
        # print "Distribution type is now:", hyp.GetDistrType()
        hyp.SetScaleFactor(scale_factor)
    elif expression_function:
        hyp.SetDistrType(hyp.DT_ExprFunc)
        hyp.SetExpressionFunction(expression_function)

    if reverse_edges:
        edges = top.edges(shape)
        ids = vector_int(subshape_ids(edges, mesh))
        hyp.SetReversedEdges(ids)
    return last_id


def apply_1d_algo(shape, id, generator, mesh, composite=False):
    """Apply a 1D Salome Algorithm 1D to ``shape``. If composite is
    :py:`False` apply ``StdMeshers_Regular_1D`` otherwise apply a
    :py:`True`, apply ``StdMeshers_CompositeSegment_1D``.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    _, last_id = add_hypotheses(shape, id, mesh,
                                (_ALGO1D_COMPOSITE[composite],))
    return last_id


def apply_fixed_length(shape, id, generator, mesh, length,
                       composite=False):
    """Request a fixed-length mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float length: The fixed length step for the mesh generation.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                       (StdMeshers_LocalLength,
                                        _ALGO1D_COMPOSITE[composite]))
    hyp.SetLength(length)
    return last_id


def apply_max_deflection(shape, id, generator, mesh, deflection,
                         composite=False):
    """Request maximum deflection based 1D hypothesis.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float deflection: the value of deflection (or chord error).
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                       (StdMeshers_Deflection1D,
                                        _ALGO1D_COMPOSITE[composite]))
    hyp.SetDeflection(deflection)
    return last_id


def apply_fixed_start_end_length(shape, id, generator, mesh, start_length,
                                 end_length, reverse_edges=False,
                                 composite=False):
    """Request a fixed start and end length for the segments. Fills up the
    area in-between by segment parts constantly increasing/decreasing with
    length (based on start_length and end_length.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float start_length:
    :param float end_length:
    :param bool reverse_edges: if True, reverse the edges of ``shape``.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                       (StdMeshers_StartEndLength,
                                        _ALGO1D_COMPOSITE[composite]))
    hyp.SetLength(start_length, True)
    hyp.SetLength(end_length, False)

    if reverse_edges:
        edges = top.edges(shape)
        ids = vector_int(subshape_ids(edges, mesh))
        hyp.SetReversedEdges(ids)

    return last_id


def apply_arithmic(shape, id, generator, mesh, start_length,
                   end_length, reverse_edges=False,
                   composite=False):
    """Request an arithmetic mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float start_length:
    :param float end_length:
    :param bool reverse_edges: if True, reverse the edges of ``shape``.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp1, _), last_id = add_hypotheses(shape, id, mesh,
                                        (StdMeshers_Arithmetic1D,
                                         _ALGO1D_COMPOSITE[composite]))
    hyp1.SetLength(start_length, True)
    hyp1.SetLength(end_length, False)

    if reverse_edges:
        edges = top.edges(shape)
        ids = vector_int(subshape_ids(edges, mesh))
        hyp1.SetReversedEdges(ids)
    # if hasattr(reverse_edges, "__iter__"):
    #                 ids2 = [id for id, is_rev in zip(ids, reverse_edges) if is_rev]
    #                 if ids2 > 0:
    #                     hyp.SetReversedEdges(ids2)
    #             else:
    #                 hyp.SetReversedEdges(ids)
    return last_id


def apply_fixed_points(shape, id, generator, mesh, parameters=[],
                       reverse_edges=False, composite=False):
    """Request a mesh based on fixed points defined by ``parameters``.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param collections.Sequence[float] parameters: list of points [0-1] where
        the mesh points should be placed.
    :param bool reverse_edges: if True, reverse the edges of ``shape``.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                       (StdMeshers_FixedPoints1D,
                                        _ALGO1D_COMPOSITE[composite]))
    hyp.SetPoints(vector_double(parameters))

    if reverse_edges:
        edges = top.edges(shape)
        ids = vector_int(subshape_ids(edges, mesh))
        hyp.SetReversedEdges(ids)

    return last_id


def apply_max_length(shape, id, generator, mesh, length=None,
                     composite=False):
    """Request a with a max length between elements.

    If ``length`` is None, S = S0 * f(L/Lmin) where f(x) = 1 + (2/Pi * 7 *
    atan(x/5) )

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float length: Maximum length of mesh elements.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    algo1d = _ALGO1D_COMPOSITE[composite]
    if length is not None:
        (hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                           (StdMeshers_MaxLength, algo1d))
        hyp.SetLength(length)
    else:
        _, last_id = add_hypotheses(shape, id, mesh,
                                    (StdMeshers_AutomaticLength, algo1d))
    return last_id


def apply_propagate_edge(from_shape, to_shape, id, generator, mesh,
                         composite=False):
    """Request the propagation of an edge ``from_shape`` to ``to_shape``.
    This algorithm will propagate the 1D hypothesis of the edges of
    ``from_shape`` to opposite edge(s) (recursively ?).

    .. caution:: Can give unexpected results. There might be a
        propagation in the resulting mesh further than ``to_shape``, if an 1D
        algorithm is applied on these more distant edges (recursively opposite
        to the ``from_shape`` edge(s)).

    :param OCC.TopoDS.TopoDS_Shape from_shape:
    :param OCC.TopoDS.TopoDS_Shape to_shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param bool composite: try to treat the edges in ``shape`` as a composite,
        based on their relative C1 continuity.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    hyp = _ALGO1D_COMPOSITE[composite](id, generator)
    hyp2 = StdMeshers_Propagation(id + 1, generator)
    # THE ORDER MATTERS! Undexpected behavior when, for example, an hypothesis
    # was applied to an edge ``from_shape``, and ``apply_propagate_edge`` is
    # called with ``to_shape`` a face. Turning the order around will result
    # in a not propagated hypothesis (in some cases? At least with a box).
    mesh.AddHypothesis(to_shape, id)
    mesh.AddHypothesis(from_shape, id + 1)

    _append_hypotheses(mesh, (hyp, hyp2))
    return id + 1


def apply_propagate(from_shape, id, generator, mesh, composite=False,
                    prop_type='hypothesis'):
    """Request the propagation of an edge ``from_shape``.
    This algorithm will propagate the either the hypothesis or the
    distribution on the edges of ``from_shape`` to opposite edge(s)
    recursively. Works only for edges on quadrangle faces.

    .. note:: Will apply a ``StdMeshers_Regular_1D`` algo on the whole
        shape to mesh (in which ``shape`` is a sub-shape`` in order to get the
        expected results.

    :param OCC.TopoDS.TopoDS_Shape from_shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param str prop_type: What to propagate, the 'hypothesis' or the
        'distribution'.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    # create 1D algo on the whole shape to mesh
    shape_to_mesh = mesh.GetShapeToMesh()
    algo = StdMeshers_Regular_1D(id, generator)

    prop_hyp = _PROP_TYPE[prop_type]

    # create the propagation
    hypo = prop_hyp(id + 1, generator)
    mesh.AddHypothesis(shape_to_mesh, id)
    mesh.AddHypothesis(from_shape, id + 1)
    _append_hypotheses(mesh, (algo, hypo,))
    return id + 1


def apply_quad(shape, id, generator, mesh, quad_config=QUAD_STANDARD):
    """

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param int quad_config: The way the quad should be configured:
        enumeration:
        0: QUAD_STANDARD
        1: QUAD_TRIANGLE_PREF
        2: QUAD_QUADRANGLE_PREF
        3: QUAD_QUADRANGLE_PREF_REVERSED
        4: QUAD_REDUCED
        5: QUAD_NB_TYPES
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (_, hyp2), last_id = add_hypotheses(shape, id, mesh,
                                        (StdMeshers_Quadrangle_2D,
                                         StdMeshers_QuadrangleParams))
    hyp2.SetQuadType(quad_config)
    return last_id


def apply_mefisto2d(shape, id, generator, mesh, length_from_edges=False,
                    max_area=None):
    """Apply the MEFISTO 2D triangulation algorithm to ``shape``.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param bool length_from_edges: Base the edge length of the mesh-faces on
        the segment lengths on the edges.
    :param float max_area: Set a maximum of the area a face element might have.
    :return: the last id used by the hypotheses.
    :rtype: int

    .. note:: There are known configurations of the algorithm where the result
        does not seem to depend on the settings of ``max_area`` and
        ``length_from_edges``.
    """

    hyps = [StdMeshers_MEFISTO_2D]
    if length_from_edges:
        hyps.append(StdMeshers_LengthFromEdges)

    if max_area is not None:
        hyps.append(StdMeshers_MaxElementArea)
        hyps, last_id = add_hypotheses(shape, id, mesh, hyps)
        hyps[-1].SetMaxArea(max_area)
    else:
        _, last_id = add_hypotheses(shape, id, mesh, hyps)

    return last_id


_CACHED_MESHES = []


def apply_extrusion(shape, id, generator, mesh):
    """A Prism mesh on a prism-like shape (6 faces). It takes two opposing
    faces with (typically) triangular surface meshes that match in topology
    (typically created using a ProjectedFace algorithm), and 4 faces with a
    quadrilateral surface mesh. The standard algorithm will try to
    automatically associate the bottom-top face pair.

    .. note:: Might fail if this algorithm wants to convert a face its mesh
        to triangles, but the to-be-converted face was explicitly meshed in
        another way.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    hyps, last_id = add_hypotheses(shape, id, mesh, (StdMeshers_Prism_3D,))

    # Bug in current wrapper/Salome: gc'ing mesh with StdMeshers_Prism_3D
    # algorithm seems to cause a heap segmentation error.
    _CACHED_MESHES.append(mesh)

    return last_id


def apply_extrusion_viscous(shape, id, generator, mesh, thickness,
                            faces_to_exclude_ids=None, no_layers=2,
                            stretch_factor=1.0):
    """ Request a extrusion viscous mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param float thickness:
    :param collection.Sequence[int] faces_to_exclude_ids: List of face ids
        in ``mesh`` to exclude in the result.
    :param int no_layers:
    :param stretch_factor:
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, ), last_id = add_hypotheses(shape, id, mesh,
                                      (StdMeshers_ViscousLayers,))
    configure_viscous_faces(hyp, thickness, faces_to_exclude_ids,
                            no_layers, stretch_factor)

    ext_hyp_id = apply_extrusion(shape, last_id + 1, generator, mesh)
    return ext_hyp_id


def apply_hexa(shape, id, generator, mesh):
    """ Request a hexa mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    _, last_id = add_hypotheses(shape, id, mesh, (StdMeshers_Hexa_3D,))
    return last_id


def apply_viscous_hexa(shape, id, generator, mesh, thickness,
                       faces_to_exclude_ids=None, no_layers=2,
                       stretch_factor=1.0):
    """Request a hexa mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param OCC.StdMeshers.StdMeshers_ViscousLayers hyp: Hypothesis to set
    :param float thickness:
    :param collection.Sequence[int] faces_to_exclude_ids: List of ids of
        faces in ``mesh`` to exclude in the result.
    :param int no_layers:
    :param stretch_factor:
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp, ), last_id = add_hypotheses(shape, id, mesh,
                                      (StdMeshers_ViscousLayers,))
    configure_viscous_faces(hyp, thickness, faces_to_exclude_ids,
                            no_layers, stretch_factor)
    hexa_hyp_id = apply_hexa(shape, last_id + 1, generator, mesh)

    return hexa_hyp_id


def apply_radial_prism(shape, id, generator, mesh, no_layers):
    """Request a radial prism mesh.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int id: The next id that this study can use
    :param OCC.SMESH.SMEHS_Gen generator: the smesh generator
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param int no_layers: Amount of layers for the radial prism to create
    :return: the last id used by the hypotheses.
    :rtype: int
    """
    (hyp1d, hyp, _), last_id = add_hypotheses(shape, id, mesh,
                                              (StdMeshers_NumberOfLayers,
                                               StdMeshers_LayerDistribution,
                                               StdMeshers_RadialPrism_3D))
    hyp1d.SetNumberOfLayers(no_layers)
    hyp.SetLayerDistribution(hyp1d)

    return last_id


__element_types = frozenset(('nodes', 'edges', 'faces', 'elements'))


def mesh_iterator(element, el_type):
    """Given a mesh ``element``, iterate over its sub-elements of ``el_type``.

    :param OCC.SMDS.SMDS_MeshElement element: the mesh element of which we
        want to iterate over its sub-elements of type ``el_type``.
    :param str el_type: sub type to iterate over, either 'nodes', 'edges',
        'faces' or 'elements'.
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshElement]
    :raises ValueError: if ``el_type`` is not 'nodes', 'edges', 'faces'
        or 'elements'.
    :raises AttributeError: if 'element' does not have an iterator
    """
    if el_type not in __element_types:
        msg = 'el_type must be one of: {}, but got {}.'
        raise ValueError(msg.format(__element_types, el_type))

    # edgeIterator, facesIterator, etc.
    iterator_name = '{}Iterator'.format(el_type)
    try:
        it_getter = getattr(element, iterator_name)
    except AttributeError:
        msg = ('Argument "element" ({}) has no iterator {} for '
               '"el_type" == {}.')
        raise AttributeError(msg.format(element, iterator_name, el_type))

    it = it_getter()
    # finally iterate and yield.
    while it.more():
        yield it.next()


def mesh_nodes(mesh):
    """The nodes in ``mesh``.

    :param OCC.SMESH.SMESH_Mesh mesh:
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshNode]
    """
    mds = mesh.GetMeshDS()
    it = mds.nodesIterator()
    while it.more():
        yield it.next()


def mesh_edges(mesh):
    """The edges in ``mesh``.

    :param OCC.SMESH.SMESH_Mesh mesh:
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshEdge]
    """
    mds = mesh.GetMeshDS()
    it = mds.edgesIterator()
    while it.more():
        yield it.next()


def mesh_faces(mesh):
    """The faces in ``mesh``.

    :param OCC.SMESH.SMESH_Mesh mesh:
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshFace]
    """
    mds = mesh.GetMeshDS()
    it = mds.facesIterator()
    while it.more():
        yield it.next()


def mesh_elements(mesh):
    """The elements in ``mesh``.

    :param OCC.SMESH.SMESH_Mesh mesh:
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshElement]
    """
    mds = mesh.GetMeshDS()
    it = mds.elementsIterator()
    while it.more():
        yield it.next()


def mesh_interactive_object(mesh, dmf=MeshVS_DMF_OCCMask):
    """ Gives back a displayable interactive object of ``mesh``.

    :param OCC.SMESH.SMESH_Mesh mesh: The mesh to display
    :param int dmf: MeshVS_DMF enum type, default: MeshVS_DMF_OCCMask
    :rtype: OCC.MeshVS.MeshVS_Mesh
    """
    aDS = SMESH_MeshVSLink(mesh)
    aMeshVS = MeshVS_Mesh(True)
    aPrsBuilder = MeshVS_MeshPrsBuilder(aMeshVS.handle,
                                        dmf,
                                        aDS.handle,
                                        0,
                                        MeshVS_BP_Mesh)
    aMeshVS.SetDataSource(aDS.handle)
    aMeshVS.AddBuilder(aPrsBuilder.handle, False)
    return aMeshVS.handle


def submesh_elements(submesh):
    """
    Returns a list of mesh 'elements', where the element type depends
    on the dimension of this subgrid. Assumes that all elements
    are of a single type.

    For example <type>:

        Vertex: -> [MeshNode, ...]
        Edge/Wire: -> [MeshEdge, ...]
        Face/Shell: -> [MeshFace, ...]
        Solid/CompSolid: -> [MeshVolume, ...]
        Compound: -> depends on contents of compound, but can be any of the
        above.

    :param OCC.SMESH.SMESH_subMesh submesh: The submesh of which the
        elements are returned.
    :returns: list of MeshEdge|MeshFace|MeshVolume instances.
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshElement]
    """
    smds = submesh.GetSubMeshDS()
    it = smds.GetElements()
    while it.more():
        yield it.next()


def submesh_internal_nodes(submesh):
    """Return *internal* nodes of ``submesh``, boundary nodes not included.

    Excluded:

        - nodes on end vertices of an edge.
        - nodes on edges of a face/shell.

        See :attr:`nodes` if you want the boundary nodes as well.

    :param OCC.SMESH.SMESH_subMesh submesh: nodes in the sub_mesh.
    :rtype: collections.Iterator[OCC.SMDS.SMDS_MeshNode]
    """
    smds = submesh.GetSubMeshDS()
    it = smds.GetNodes()
    while it.more():
        yield it.next()


def mesh_edge_length(edge):
    """The length of mesh-edge ``edge``.

    :param OCC.SMDS.SMDS_MeshEdge edge: edge in a mesh
    :rtype: float
    """
    n1 = edge.GetNode(0)
    n2 = edge.GetNode(1)
    return distance((n1.X(), n1.Y(), n1.Z()),
                    (n2.X(), n2.Y(), n2.Z()))


# TODO, implement. We need the groupbase for this.
# def submesh_nodes(submesh):
#     """The nodes in ``submesh``. Also include the boundary nodes.
#
#     :param OCC.SMESHDS.SMESHDS_SubMesh submesh:
#     :rtype: list[OCC.SMDS.SMDS_MeshNode]
#     """
#     dim = self.dimension
#     if dim == 0:
#         return self.elements
#     elif dim == 1:
#         sub_mesh = self.SMESHDS_SubMesh
#         it_ = sub_mesh.GetElements()
#         it = it_.get()
#         visited = set()
#         nodes = []
#         while it.more():
#             edge = it.next()
#             """:type: OCC.SMDS.SMDS_MeshElement"""
#             node1, node2 = edge.GetNode(0), edge.GetNode(1)
#             id1, id2 = node1.GetID(), node2.GetID()
#             if id1 not in visited:
#                 nodes.append(MeshNode(node1))
#                 visited.add(id1)
#             if id2 not in visited:
#                 nodes.append(MeshNode(node2))
#                 visited.add(id2)
#         return nodes
#     elif dim == 2:
#         visited = set()
#         nodes = []
#         for face in self.elements:
#             for node in face.nodes:
#                 id = node.mesh_id
#                 if id not in visited:
#                     nodes.append(node)
#                     visited.add(id)
#         return nodes
#     else:
#         raise NotImplementedError("Volumetric subgrid not implemented yet.")
#
#
# def submesh_edges(submesh):
#     """The edges in ``submesh``.
#
#     :param OCC.SMESHDS.SMESHDS_SubMesh submesh:
#     :rtype: list[OCC.SMDS.SMDS_MeshEdge]
#     """
#     return [submesh.FindEdge(i) for i in xrange(submesh.NbEdges())]
#
#
# def submesh_faces(submesh):
#     """The edges in ``submesh``.
#
#     :param OCC.SMESHDS.SMESHDS_SubMesh mesh:
#     :rtype: list[OCC.SMDS.SMDS_MeshEdge]
#     """
#     return [submesh.FindFace(i) for i in xrange(submesh.NbFaces())]


def submesh_interactive_object(mesh, submesh, dmf=MeshVS_DMF_OCCMask):
    """ Gives back a displayable interactive object of ``mesh``.

    :param OCC.SMESH.SMESHDS_Mesh mesh: The mesh to which ``submesh`` belongs.
    :param OCC.SMESH.SMESHDS_SubMesh submesh: The submesh to display
    :param int dmf: MeshVS_DMF enum type, default: MeshVS_DMF_OCCMask
    :rtype: OCC.MeshVS.MeshVS_Mesh
    """
    aDS = SMESH_SubMeshVSLink(mesh, submesh, 0, False)
    aMeshVS = MeshVS_Mesh(True)
    aPrsBuilder = MeshVS_MeshPrsBuilder(aMeshVS.handle,
                                        dmf,
                                        aDS.handle,
                                        0,
                                        MeshVS_BP_Mesh)
    aPrsBuilder.this = aPrsBuilder.this[0]  # recommended workaround
    aMeshVS.SetDataSource(aDS.handle)
    aMeshVS.AddBuilder(aPrsBuilder.handle, False)
    # handle_meshvs_mesh = aMeshVS.GetHandle()
    # mesh_drawer = aMeshVS.GetDrawer().GetObject()
    # mesh_drawer.SetColor(MeshVS_DA_EdgeColor,
    #                      Quantity_Color(Quantity_NOC_BLACK))
    # mesh_drawer.SetColor(MeshVS_DA_MarkerColor,
    #                      Quantity_Color(Quantity_NOC_GREEN))
    return aMeshVS.handle


def display_mesh(mesh, blocking=True):
    """Quickly display an already computed mesh.

    :param OCC.SMESH.SMESH_Mesh mesh: Mesh to display.
    :param bool blocking: should the execution hang to wait for the window to
        close?
    """
    import wx
    from OCC.gui.viewer import ViewerWindow

    app = wx.GetApp() or wx.App()
    viewer = ViewerWindow().viewer
    mesh_ais = mesh_interactive_object(mesh)
    viewer.display(mesh_ais, update=False)

    if blocking:
        app.MainLoop()


def _append_hypotheses(mesh, hyps):
    """Appends hypotheses to a mesh to make sure they are not destructed.

    :param any mesh: A mesh object
    :param collections.Sequence(any) hyps: a list of hypotheses
    """
    try:
        mesh._hyps.update(hyps)
    except AttributeError:
        mesh._hyps = set(hyps)


def _remove_hypotheses(mesh, hyps):
    """Appends hypotheses to a mesh to make sure they are not destructed.

    :param any mesh: A mesh object
    :param collections.Sequence(any) hyps: a list of hypotheses
    """
    try:
        mesh._hyps.remove(hyps)
    except AttributeError:
        pass


METHOD = {'laplacian': SMESH_MeshEditor.LAPLACIAN,
          'centroidal': SMESH_MeshEditor.CENTROIDAL}


def smooth_faces(smesh_mesh, nb_iter=3, method='laplacian',
                 aspect_ratio=1.0, in_2d=True):
    """Smooth all mesh faces in smesh_mesh.

    :param OCC.SMESH.SMESH_Mesh smesh_mesh: target mesh
    :param int nb_iter: number of iterations
    :param str method: smoothing algorithm, either 'laplacian' or 'centroidal'
    :param float aspect_ratio: target aspect ratio
    :param bool in_2d:
    """
    elems = set_SMDS_MeshElementcp_TIDcmp()
    for face in mesh_faces(smesh_mesh):
        elems.append(face)

    fixed = set_SMDS_MeshNodecp()
    method = METHOD[method]

    editor = SMESH_MeshEditor(smesh_mesh)
    editor.Smooth(elems, fixed, method, nb_iter, aspect_ratio, in_2d)


def quad_to_tri(smesh_mesh, the13Diag=True):
    """Convert all quad faces inside ``smesh_mesh`` to triangles.

    :param OCC.SMESH.SMESH_Mesh smesh_mesh: target mesh
    :param bool the13Diag:
    """
    elems = set_SMDS_MeshElementcp_TIDcmp()
    for face in mesh_faces(smesh_mesh):
        if face.NbNodes() == 4:
            elems.append(face)

    nb_quads = len(elems)
    nb_faces = smesh_mesh.NbFaces()
    ratio = round(nb_quads / float(nb_faces) * 100, 2)
    print("Found {} quads in {} faces. Ratio: {}%.".format(nb_quads, nb_faces,
                                                           ratio))

    editor = SMESH_MeshEditor(smesh_mesh)

    editor.QuadToTri(elems, the13Diag)


def tri_to_quad(smesh_mesh, criteria, angle):
    """Convert all triangle faces inside ``smesh_mesh`` to quads.

    :param OCC.SMESH.SMESH_Mesh smesh_mesh: target mesh
    :param criteria: no idea
    :param float angle: no idea
    :param bool the13Diag:
    """
    elems = set_SMDS_MeshElementcp_TIDcmp()
    for face in mesh_faces(smesh_mesh):
        if face.NbNodes() == 3:
            elems.append(face)

    nb_trias = len(elems)
    nb_faces = smesh_mesh.NbFaces()
    ratio = round(nb_trias / float(nb_faces) * 100, 2)
    print("Found {} trias in {} faces. Ratio: {}%.".format(nb_trias, nb_faces,
                                                           ratio))

    editor = SMESH_MeshEditor(smesh_mesh)

    editor.TriToQuad(elems, criteria, angle)


def add_hypotheses(shape, hyp_id, mesh, hypotheses):
    """Request maximum deflection based 1D hypothesis.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :param int hyp_id: The next id that this study can use
    :param OCC.SMESH.SMESH_Mesh mesh: instance of the mesh object from ``gen``.
    :param collections.Iterable[type] hypotheses: Salome Hypotheses
    :return: the created hypotheses and the last_id that was used
    :rtype: tuple[list[T], int]
    """
    generator = mesh.GetGen()

    hyps = list()
    for h in hypotheses:
        hyp = h(hyp_id, generator)
        mesh.AddHypothesis(shape, hyp_id)
        hyps.append(hyp)
        hyp_id += 1

    _append_hypotheses(mesh, hyps)

    return hyps, hyp_id - 1

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Some nice Python function to easily explore topology.

Note that all function with trailing '_' are simply working with OpenCascade proxy object, and will
not DownCast any results. While the ones without '_' will either Downcast TopoDS_Shapes or return
ParaPy objects
"""

import sys
import logging
from math import sqrt

from OCC.wrapper import Quantity
from OCC.wrapper.BRepTools import BRepTools_WireExplorer
from OCC.wrapper.Geom import (Handle_Geom_OffsetCurve,
                      Handle_Geom_BSplineCurve,
                      Handle_Geom_BezierCurve,
                      Handle_Geom_TrimmedCurve,
                      Handle_Geom_Circle,
                      Handle_Geom_Ellipse,
                      Handle_Geom_Line,
                      Handle_Geom_Curve,
                      Handle_Geom_BSplineSurface,
                      Handle_Geom_BezierSurface,
                      Handle_Geom_RectangularTrimmedSurface,
                      Handle_Geom_ConicalSurface,
                      Handle_Geom_CylindricalSurface,
                      Handle_Geom_Plane,
                      Handle_Geom_SphericalSurface,
                      Handle_Geom_ToroidalSurface, 
                      Handle_Geom_Surface)
from OCC.wrapper.Quantity import Quantity_TOC_RGB, Quantity_Color, Quantity_NOC_YELLOW, Quantity_Color_Name
from OCC.wrapper.ShapeExtend import ShapeExtend_WireData
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_FACE
from OCC.wrapper.TopExp import TopExp__MapShapes, TopExp__MapShapesAndAncestors
from OCC.wrapper.TopTools import (TopTools_IndexedMapOfShape, TopTools_IndexedDataMapOfShapeListOfShape,
                          TopTools_HSequenceOfShape,
                          TopTools_ListOfShape, TopTools_MapOfShape)
from OCC.wrapper.TopoDS import (TopoDS_Builder, TopoDS_Compound, TopoDS_Iterator,
                        TopoDS_CompSolid)
from OCC.wrapper.gce import (gce_BadEquation, gce_NullVector, gce_NullFocusLength, gce_InvertRadius,
                     gce_BadAngle, gce_InvertAxis, gce_NullRadius, gce_NullAngle, gce_NullAxis,
                     gce_IntersectionError, gce_ColinearPoints, gce_NegativeRadius,
                     gce_ConfusedPoints, gce_Done)
from OCC.utils.top import (downcast_shape, sub_shapes, TopAbs2Class, TobAbs2TopoDS, Name2TopAbs,
                           Level2TopAbs)

GCE_ERROR = {gce_Done: "Construction was successful",
             gce_ConfusedPoints: "Two points are coincident",
             gce_NegativeRadius: "Radius value is negative",
             gce_ColinearPoints: "Three points are collinear",
             gce_IntersectionError: "Intersection cannot be computed",
             gce_NullAxis: "Axis is undefined",
             gce_NullAngle: "Angle value is invalid (usually null)",
             gce_NullRadius: "Radius is null",
             gce_InvertAxis: "Axis value is invalid",
             gce_BadAngle: "Angle value is invalid",
             gce_InvertRadius: ("Radius value is incorrect (usually with "
                                "respect to another radius)"),
             gce_NullFocusLength: "Focal distance is null",
             gce_NullVector: "Vector is null",
             gce_BadEquation: ("Coefficients are incorrect (applies to the "
                               "equation of a geometric object)")}

DYNAMIC_CRV_TYPE_TO_DOWNCAST_FUNCTION = {
    "Geom_BSplineCurve": Handle_Geom_BSplineCurve,
    "Geom_BezierCurve": Handle_Geom_BezierCurve,
    "Geom_TrimmedCurve": Handle_Geom_TrimmedCurve,
    "Geom_Circle": Handle_Geom_Circle,
    "Geom_Ellipse": Handle_Geom_Ellipse,
    "Geom_Line": Handle_Geom_Line,
    "Geom_OffsetCurve": Handle_Geom_OffsetCurve,
    "Geom_Curve": Handle_Geom_Curve}


DYNAMIC_SRF_TYPE_TO_DOWNCAST_FUNCTION = {
    "Geom_BSplineSurface": Handle_Geom_BSplineSurface,
    "Geom_BezierSurface": Handle_Geom_BezierSurface,
    "Geom_RectangularTrimmedSurface": Handle_Geom_RectangularTrimmedSurface,
    "Geom_ConicalSurface": Handle_Geom_ConicalSurface,
    "Geom_CylindricalSurface": Handle_Geom_CylindricalSurface,
    "Geom_Plane": Handle_Geom_Plane,
    "Geom_SphericalSurface": Handle_Geom_SphericalSurface,
    "Geom_ToroidalSurface": Handle_Geom_ToroidalSurface,
    "Geom_Surface": Handle_Geom_Surface}

# default map for finding ancestors
SUB_ANCESTOR_SHAPE_TYPE_MAP = (0,  # compound -> compound
                               0,  # compsolid -> compound
                               1,  # solid -> compsolid
                               2,  # shell -> solid
                               2,  # face -> solid
                               4,  # wire -> face
                               4,  # edge -> face
                               6)  # vertex -> edge

# default map for finding neighbours
ANCESTOR_SUB_SHAPE_TYPE_MAP = (None,  # compound -> N/A
                               None,  # compsolid -> N/A
                               4,     # solid -> face
                               4,     # shell -> face
                               6,     # face -> edge
                               7,     # wire -> vertex
                               7)     # edge -> vertex

TOPABS_NAMES = ("compound", "compsolid", "solid", "shell",
                "face", "wire", "edge", "vertex")


# TODO: convert to C++ utility
def dynamic_transient_type(obj):
    """Dynamic type of transient.

    :type handle: OCC.Standard.Standard_Transient | OCC.Standard.Handle_Standard_Transient
    :rtype: str
    """
    return obj.DynamicType().Name()


def downcast_handle_geom_curve(handle, dynamic_type=None):
    """
    :param OCC.Geom.Handle_Geom_Curve handle: curve handle.
    :param str dynamic_type: dynamic type of curve. If None, function resolves
        this from DynamicType().
    :rtype: OCC.Geom.Handle_Geom_Curve
    """
    if dynamic_type is None:
        dynamic_type = dynamic_transient_type(handle)
    cast = DYNAMIC_CRV_TYPE_TO_DOWNCAST_FUNCTION[dynamic_type]
    handle = cast(handle)
    return handle


def downcast_handle_geom_surface(handle, dynamic_type=None):
    """
    :param OCC.Geom.Handle_Geom_Curve handle: surface handle.
    :param str dynamic_type: dynamic type of surface. If None, function
        resolves this from DynamicType().
    :rtype: OCC.Geom.Handle_Geom_Surface
    """
    if dynamic_type is None:
        dynamic_type = dynamic_transient_type(handle)
    cast = DYNAMIC_SRF_TYPE_TO_DOWNCAST_FUNCTION[dynamic_type]
    handle = cast(handle)
    return handle


# TODO: phase out and use sub_shapes() instead.
def TopoDS_Compound_Iterator(topods_compound):
    """
    :param topods_compound: compound
    :type topods_compound: OCC.TopoDS.TopoDS_Compound
    :rtype: collections.Iterator[TopoDS_Shape]
    """
    it = TopoDS_Iterator(topods_compound)
    while it.More():
        yield it.Value()
        it.Next()


def TopoDS_Shape_Downcast(topods_shape):
    """Downcasts TopoDS_Shape shape to specific type

    :param OCC.TopoDS.TopoDS_Shape topods_shape: shape to downcast
    :rtype: OCC.TopoDS.TopoDS_Shape
    """
    return TobAbs2TopoDS[topods_shape.ShapeType()](topods_shape)


# ------ factories ----
def make_TopTools_HSequenceOfShape(shapes=[]):
    """ Put a list of shapes in a TopTools_HSequenceOfShape

    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] shapes: is
        iterable of TopoDS_Shape
    :rtype: OCC.TopTools.TopTools_HSequenceOfShape
    """
    seq = TopTools_HSequenceOfShape()
    for shape in shapes:
        seq.Append(shape)
    return seq


def make_TopoDS_Compound(topods_shapes):
    """Creates a TopoDS_Compound from a list of shapes

    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] topods_shapes: list
        of shapes
    :rtype: OCC.TopoDS.TopoDS_Compound
    """
    builder = TopoDS_Builder()
    topods_compound = TopoDS_Compound()
    builder.MakeCompound(topods_compound)
    for topods_shape in topods_shapes:
        builder.Add(topods_compound, topods_shape)
    return topods_compound

def make_TopoDS_CompSolid(topods_shapes):
    """Creates a TopoDS_Compound from a list of shapes

    :param list[OCC.TopoDS.TopoDS_Shape] topods_shapes: list of shapes
    :rtype: OCC.TopoDS.TopoDS_CompSolid
    """
    builder = TopoDS_Builder()
    topods_compsolid = TopoDS_CompSolid()
    builder.MakeCompSolid(topods_compsolid)
    for topods_shape in topods_shapes:
        builder.Add(topods_compsolid, topods_shape)
    return topods_compsolid


def TopTools_HSequenceOfShapeGenerator(seq):
    """ Generator of a TopTools_HSequenceOfShape

    :param OCC.TopTools.TopTools_HSequenceOfShape seq:
    :return: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    seq = seq.Sequence()
    for i in range(1, seq.Length()+1):
        yield seq.Value(i)


def unique_shape_generator_(shapes):
    """return unique list of TopoDS_Shape object that filters out duplicates with same geometry,
    location, but differ in orientation (forward, rearward).

    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] shapes:
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    visited = []
    for s in shapes:
        f = s.IsSame
        for v in visited:
            if f(v):
                break # duplicate
        else:
            yield s
            visited.append(s)


def TopTools_ListOfShapeGenerator_(toptools_listofshape):
    """ Yields not-downcast TopoDS_Shape objects

    :param OCC.TopTools.TopTools_ListOfShape toptools_listofshape: an OCC list of shapes
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    for shape in toptools_listofshape:
        shape.__d = toptools_listofshape
        yield shape


def TopTools_ListOfShape2list(toptools_listofshape):
    """ Yields not-downcast TopoDS_Shape objects

    :param OCC.TopTools.TopTools_ListOfShape toptools_listofshape: an OCC list of shapes
    :rtype: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(TopTools_ListOfShapeGenerator_(toptools_listofshape))


def IndexedMapOfShapeGenerator_(map):
    """ Iterator for IndexMapOfShape

    :param OCC.TopTools.TopTools_IndexedMapOfShape map: a TopTools_IndexedMapOfShape.
    :return: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    for i in range(1, map.Extent()+1):
        yield map(i)

# downcasts shapes 
# def IndexedMapOfShapeGenerator(Map, level):
#     """Map is a TopTools_IndexedMapOfShape. This is a generator."""
#     cast = Level2TopoDS[level]
#     for i in xrange(1, Map.Extent()+1):
#         yield cast(Map(i))


def IndexedDataMapOfShapeListOfShapeGenerator_(Map):
    """ generates tuples of TopoDS_Shapes to generators of the shapes inside this TopoDS_Shape

    :param OCC.TopTools.TopTools_IndexedMapOfShape Map: a TopTools_IndexedMapOfShape
    :rtype: collections.Iterator[tuple[OCC.TopoDS.TopoDS_Shape, collections.Iterator[OCC.TopoDS.TopoDS_Shape]]]
    """
    for i in range(1, Map.Extent()+1):
        yield (Map.FindKey(i), TopTools_ListOfShapeGenerator_(Map(i)))

# # downcasts shapes and create parapy objects
# def IndexedDataMapOfShapeListOfShapeGenerator(Map, level1, level2):
#     """Map is a TopTools_IndexedMapOfShape. This is a generator."""
#     cast1 = Level2TopoDS[level1]
#     for i in xrange(1, Map.Extent()+1):
#         yield (cast1(Map.FindKey(i)),
#                TopTools_ListOfShapeGenerator(Map(i), level2))


def SubShapeGenerator_(shape, level):
    """Returns a generator that yields unique TopoDS_Shape objects (subclassed).

    :param OCC.TopoDS.TopoDS_Shape shape: TopoDS_Shape or subclass.
    :param int|str level: TopAbs_ShapeEnum index or named string
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    :raises: KeyError if level not in globals.Level2TopAbs.keys()
    """
    TopAbs_ShapeEnum = Level2TopAbs[level] if isinstance(level, int) else Name2TopAbs[level]
    Map = TopTools_IndexedMapOfShape()
    TopExp__MapShapes(shape, TopAbs_ShapeEnum, Map)
    return IndexedMapOfShapeGenerator_(Map)


class AncestorMap_(object):
    """Utility to iterate over pairs of sub-shapes of ``levell`` and
    ancestor-shapes ``level2`` inside an owning ``shape``. Shape ``shape`` is
    TopoDS_Shape, levels are TopAbs_Enum ranging 0-7. Usage:

    >>> from OCC.wrapper.BRepPrimAPI import BRepPrimAPI_MakeBox
    >>> from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_FACE
    >>> shape = BRepPrimAPI_MakeBox(1, 1, 1).Shape()
    >>> amap = AncestorMap_(shape, TopAbs_EDGE, TopAbs_FACE)
    >>> # either iterate over this map to get sub-shape - ancestors pairs.
    >>> for edge, on_faces in amap:
    ...     print(edge, len(list(on_faces)))  # doctest: +ELLIPSIS
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    <OCC.TopoDS.TopoDS_Shape...> 2
    >>> # or use getitem to access ancestors of a specific shape
    >>> edge = next(sub_shapes(shape, TopAbs_EDGE))
    >>> list(amap[edge])  # doctest: +ELLIPSIS
    [<OCC.TopoDS.TopoDS_Shape...>, <OCC.TopoDS.TopoDS_Shape...>]
    """

    def __init__(self, shape, level1, level2):

        TopAbs_ShapeEnum1 = Level2TopAbs[level1]
        TopAbs_ShapeEnum2 = Level2TopAbs[level2]
        map = TopTools_IndexedDataMapOfShapeListOfShape()
        TopExp__MapShapesAndAncestors(shape, TopAbs_ShapeEnum1, TopAbs_ShapeEnum2, map)
        self.map = map
        self.level1 = TobAbs2TopoDS[TopAbs_ShapeEnum1]
        self.level2 = TobAbs2TopoDS[TopAbs_ShapeEnum2]

    def __getitem__(self, sub_shape):
        """sub_shape is TopoDS_Shape. Returns generator of ancestor shapes::

            (TopoDS_Shape, TopoDS_Shape, ...)"""
        list_of_shape = self.map.FindFromKey(sub_shape)
        return TopTools_ListOfShapeGenerator_(list_of_shape)

    def __iter__(self):
        """Returns a generator::

            (TopoDS_Shape, (TopoDS_Shape, TopoDS_Shape, ...),
             TopoDS_Shape, (...))
        """
        return IndexedDataMapOfShapeListOfShapeGenerator_(self.map)


def resolve_gce_status(builder):
    """Gets the value from builder and returns the handle to it

    :param OCC.GC.GC_Root builder: A builder of which the value is called
    :rtype: OCC.Geom.Handle_Geom_Geometry
    :raises: Exception
    """
    if builder.IsDone():
        return builder.Value()
    else:
        status = builder.Status()
        if status in GCE_ERROR:
            raise Exception("construction failed:", repr(status), ":", GCE_ERROR[status])
        else:
            raise Exception("construction failed: reason unknown")


def iterate_TopTools_ListOfShape(Lsh, downcast=False):
    """Generate shapes from Lsh. Duplicates not checked.

    :param OCC.TopTools.TopTools_ListOfShape Lsh: list of shapes.
    :param bool downcast: downcast child type from specialized TopoDS_Shape?
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    if downcast:
        f = downcast_shape
    else:
        f = lambda s: s

    for val in Lsh:
        yield f(val)


def iterate_TopTools_SequenceOfShape(seq, downcast=False):
    """ Iterate over a sequence of shapes. Has the possibility to downcast

    :param OCC.TopTools.TopTools_SequenceOfShape seq: A SequenceOfShapes to iterate over
    :param bool downcast: True if you want to downcast
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    if downcast:
        f = downcast_shape
    else:
        f = lambda s: s

    for i in range(1, seq.Length()+1):
        yield f(seq.Value(i))


# TODO: make custom c-wrapper
def make_TopTools_ListOfShape(topods_shapes):
    """Creates a TopTools ListOfShape from a list of shapes

    :param collections.Iterable[OCC.TopoDS.TopoDS_Shape] topods_shapes:
        list of shapes
    :rtype: OCC.TopTools.TopTools_ListOfShape
    """
    lst = TopTools_ListOfShape()
    for topods_shape in topods_shapes:
        lst.Append(topods_shape)
    return lst


def ancestors(shape, owner, ancestor_type=None, downcast=False):
    """Yield ancestor shapes of shape ``shape`` with the context of
    ``owner`` shape. Either direct ancestors (:py:`ancestor_type=None`) or of
    a specific kind. Ancestors will be of type TopoDS_Shape. If ``downcast``
    is :py:`True`, they will be downcasted to specific TopoDS class
    (e.g. TopoDS_Edge).

    :param OCC.TopoDS.TopoDS_Shape shape: sub shape.
    :param OCC.TopoDS.TopoDS_Shape owner: owner shape.
    :param int ancestor_type: TopAbs_ShapeEnum or None (direct ancestors).
    :param bool downcast: downcast child type from specialized TopoDS_Shape?
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    if owner.IsPartner(shape):
        return

    owner_shape_type = owner.ShapeType()
    sub_shape_type = shape.ShapeType()
    if ancestor_type is None:
        ancestor_type = SUB_ANCESTOR_SHAPE_TYPE_MAP[sub_shape_type]

    if ancestor_type < owner_shape_type:
        fmt = ("Ancestor shape type '{:}' is of higher "
               "topological level than owner shape type '{:}'.")
        msg = fmt.format(TOPABS_NAMES[ancestor_type],
                         TOPABS_NAMES[owner_shape_type])
        raise RuntimeError(msg)

    if downcast:
        f = downcast_shape
    else:
        f = lambda s: s

    # keys are sub_shapes, values are ancestors
    map_ = TopTools_IndexedDataMapOfShapeListOfShape()
    TopExp__MapShapesAndAncestors(owner, sub_shape_type, ancestor_type, map_)
    Lsh = map_.FindFromKey(shape)

    # TopExp_Map... uses TopExp_Explorer internally -> remove duplicates.
    visited = TopTools_MapOfShape()
    for val in Lsh:
        if not visited.Contains(val):
            val.__d = Lsh
            yield f(val)
            visited.Add(val)


def ancestor_edges(vertex, owner, downcast=False):
    """For a vertex inside an owner, get the edges of the ancestors

    :param OCC.TopoDS.TopoDS_Vertex vertex: the shape who's ancestors we are checking
    :param OCC.TopoDS.TopoDS_Shape owner: a shape this vertex is part of
    :param bool downcast: If True, downcast the Shape to an Edge
    :return: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    return ancestors(vertex, owner, TopAbs_EDGE, downcast=downcast)


def ancestor_faces(vertex_edge_or_wire, owner, downcast=False):
    """For a vertex inside an owner, get the edges of the ancestors

    :param OCC.TopoDS.TopoDS_Shape vertex_edge_or_wire: the shape who's ancestors we are checking
    :param OCC.TopoDS.TopoDS_Shape owner: a shape this vertex, edge or wire is part of
    :param bool downcast: If True, downcast the Shape to an Edge
    :return: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    return ancestors(vertex_edge_or_wire, owner, TopAbs_FACE, downcast=downcast)


def unpack_single_shape_compound(s):
    """If a TopoDS_Compound contains only 1 child shape, this child is
    returned, else TopoDS_Compound is returned.

    :param OCC.TopoDS.TopoDS_Compound s: a compound shape
    :rtype: OCC.TopoDS.TopoDS_Shape
    """
    it = sub_shapes(s)
    try:
        child1 = next(it)
    except StopIteration:
        # no children at all
        return s
    try:
        next(it)
    except StopIteration:
        # only 1 child, return it
        return child1
    else:
        # more children, return compound
        return s


def wire_edge_generator(topods_wire, chained=False):
    """ Generates the edges of a Wire.

    :param OCC.TopoDS.TopoDS_Wire topods_wire: A wire
    :rtype: collections.Iterable[OCC.TopoDS.TopoDS_Edge]
    """
    # should do the same thing as WireExplorer, but saves the result after
    # 'iteration' is done, so the reference to the shape still exists
    it = ShapeExtend_WireData(topods_wire, chained)
    for i in range(1, it.NbEdges() + 1):
        yield it.Edge(i)


def QuantityColor_rgb(color):
    """Converts a Quantity_Color ``color`` to RGB

    :param OCC.Quantity.Quantity_Color color: the color to convert
    :rtype: tuple[int, int, int]
    """
    r, g, b = color.Values(Quantity_TOC_RGB)
    return int(r * 255), int(g * 255), int(b * 255)


def rgb_QuantityColor(color):
    """Converts an RGB value to a  Quantity_Color

    :param collections.Sequence[int, int, int] color: RGB values
    :rtype: OCC.Quantity.Quantity_Color color
    """
    r, g, b = color
    return Quantity_Color(r / 255., g / 255., b / 255., Quantity_TOC_RGB)


# TODO (TBD): change API to default=None and fail if invalid.
def str_Quantity_NameOfColor(name, default="yellow"):
    name = name.upper()
    attr = "Quantity_NOC_" + name
    try:
        return getattr(Quantity, attr)
    except AttributeError:
        if default:
            default_name = default.upper()
            default_attr = "Quantity_NOC_" + default_name
            msg = ("Invalid color: '{}' does not name a valid "
                   "OCC.Quantity.Quantity_NameOfColor. Using default: '{}'.")
            logging.warning(msg.format(name, default_name))
            try:
                return getattr(Quantity, default_attr)
            except AttributeError:
                msg = ("Invalid default color: '{}' does not name a valid "
                       "OCC.Quantity.Quantity_NameOfColor.")
                raise RuntimeError(msg.format(default_name))
        else:
            msg = ("Invalid color: '{}' does not name a valid "
                   "OCC.Quantity.Quantity_NameOfColor.")
            raise RuntimeError(msg.format(name))


def rgb_Quantity_NameOfColor(r, g, b):
    return Quantity_Color_Name(r / 255., g / 255., b / 255.)


def py_Quantity_NameOfColor(spec):
    if isinstance(spec, str):
        return str_Quantity_NameOfColor(spec)
    else:
        return rgb_Quantity_NameOfColor(*spec)


# TODO (TBD): change API str_default, fail if invalid.
def py_QuantityColor(color, str_default="yellow"):
    """Make QuantityColor from str or (r, g, b).

    >>> py_QuantityColor("red")
    >>> py_QuantityColor((255, 0, 0))
    >>> from OCC.wrapper.Quantity import Quantity_NOC_RED
    >>> py_QuantityColor(Quantity_NOC_RED)

    :type color: str | (float, float, float) | int
    :param str_default: if color is *named* (str), this is the default color
        if ``color`` names non-existent color (a warning will show).
    :rtype: Quantity_Color
    """
    if isinstance(color, str):
        aname = str_Quantity_NameOfColor(color, default=str_default)
        return Quantity_Color(aname)
    elif isinstance(color, int):  # enum e.g. Quantity_NOC_RED
        return Quantity_Color(color)
    else:
        return rgb_QuantityColor(color)


def is_handle(obj):
    """Is ``obj`` a Handle instance?

    >>> from OCC.wrapper.Geom import Handle_Geom_BSplineCurve
    >>> is_handle(Handle_Geom_BSplineCurve())
    True
    >>> is_handle(Handle_Geom_BSplineCurve)
    False

    :param T obj: handle instance, e.g. ``<Handle_Geom_Curve ...>``.
    :rtype: bool
    """
    return is_handle_class(type(obj))


def is_handle_class(cls):
    """Is ``cls`` of type Handle?

    >>> from OCC.wrapper.Geom import Handle_Geom_BSplineCurve
    >>> is_handle_class(Handle_Geom_BSplineCurve)
    True
    >>> is_handle_class(Handle_Geom_BSplineCurve())
    False

    :param type cls: Handle class, e.g. Handle_Geom_Curve.
    :rtype: bool
    """
    try:
        return (cls.__name__.startswith("Handle_") and
                cls.__module__.startswith("OCC"))
    except:
        return False


def handle_deref_class(obj):
    """Return the Standard_Transient (-derived) class that specified Handle
    ``obj`` *derefs*. Usage:

    >>> from OCC.wrapper.Geom import Handle_Geom_BSplineCurve
    >>> handle_deref_class(Handle_Geom_BSplineCurve())
    <class 'OCC.Geom.Geom_BSplineCurve'>

    :param T obj: handle instance, e.g. ``<Handle_Geom_Curve ...>``.
    :rtype: type
    :raises RuntimeError: if ``obj`` is not a valid handle instance.
    """
    if not is_handle(obj):
        msg = "Object {} is not a valid Handle instance."
        raise RuntimeError(msg.format(obj))
    else:
        return handle_class_deref_class(type(obj))


def handle_class_deref_class(cls):
    """Return the Standard_Transient (-derived) class that specified Handle
    class ``cls`` *derefs*. Usage:

    >>> from OCC.wrapper.Geom import Handle_Geom_BSplineCurve
    >>> handle_class_deref_class(Handle_Geom_BSplineCurve)
    <class 'OCC.Geom.Geom_BSplineCurve'>

    :param type cls: Handle class, e.g. Handle_Geom_Curve.
    :rtype: type
    :raises RuntimeError: if ``cls`` is not a valid handle.
    """
    if not is_handle_class(cls):
        msg = "{} is not a valid Handle class."
        raise RuntimeError(msg.format(cls))
    else:
        name = cls.__name__
        deref_name = name.lstrip("Handle_")
        name_module = cls.__module__
        module = sys.modules[name_module]
        return getattr(module, deref_name)


def handle_is_instance(obj, class_or_type_or_tuple):
    """Same as built-in isinstance(), but specialized also for handle
    instances / classes. Usage:

    >>> from OCC.wrapper.Geom import (Handle_Geom_Curve, Handle_Geom_Line,
    ...                       Handle_Geom_BSplineCurve)
    >>> handle_is_instance(Handle_Geom_Line(), Handle_Geom_Curve)
    True
    >>> handle_is_instance(Handle_Geom_Line(), Handle_Geom_BSplineCurve)
    False
    >>> handle_is_instance(Handle_Geom_Line(), str)
    False
    >>> handle_is_instance(1, Handle_Geom_Curve)
    False
    >>> handle_is_instance(Handle_Geom_Line(), (Handle_Geom_BSplineCurve,
    ...                                         Handle_Geom_Curve))
    True

    :param T obj: expected instance of a OCCT Handle class.
    :param type | tuple[type] class_or_type_or_tuple: Handle class, e.g.
        Handle_Geom_Curve, or tuple of these.
    :rtype: bool
    """
    if not is_handle(obj):
        return False
    else:
        if isinstance(class_or_type_or_tuple, tuple):
            cls_obj = type(obj)
            for cls in class_or_type_or_tuple:
                if cls_obj is cls:  # most common case, easy exit
                    return True
                elif not is_handle_class(cls):
                    if isinstance(obj, cls):
                        return True
                else:
                    cls1 = handle_deref_class(obj)
                    cls2 = handle_class_deref_class(cls)
                    if issubclass(cls1, cls2):
                        return True
            return False
        else:
            cls = class_or_type_or_tuple
            if isinstance(obj, cls):  # most common case, easy exit
                return True
            elif not is_handle_class(cls):
                return isinstance(obj, cls)
            else:
                cls1 = handle_deref_class(obj)
                cls2 = handle_class_deref_class(cls)
                return issubclass(cls1, cls2)


class InvalidColor(Exception):
    pass


def distance(point1, point2):
    """Calculate the distance between ``point1`` and ``point2``.

    :param collections.Sequence[int | float] point1: first point
    :param collections.Sequence[int | float] point2: second point
    :rtype: float
    """
    assert len(point1) == len(point2)
    total = sum(((t1 - t2) ** 2 for t1, t2 in zip(point1, point2)), 0.)
    return sqrt(total)


def avg(a, b):
    return (a + b) / 2.


if __name__ == '__main__':
    print(py_Quantity_NameOfColor((1, 2, 3)))
    print(py_Quantity_NameOfColor("red"))
    print(py_QuantityColor((1, 2, 3)))
    print(py_QuantityColor("red"))
    print(py_QuantityColor(1))


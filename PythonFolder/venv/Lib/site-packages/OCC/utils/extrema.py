#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from OCC.wrapper.BRepExtrema import (BRepExtrema_DistShapeShape, BRepExtrema_IsVertex,
                             BRepExtrema_IsOnEdge, BRepExtrema_IsInFace)
from OCC.wrapper.Extrema import Extrema_ExtAlgo_Grad, Extrema_ExtAlgo_Tree
from OCC.wrapper.gp import gp_Pnt

_EXTREMA_ALGOS = {'grad': Extrema_ExtAlgo_Grad, 'tree': Extrema_ExtAlgo_Tree}

_res_to_param = {
    BRepExtrema_IsVertex: lambda x, i, shape_num: None,
    BRepExtrema_IsOnEdge:
        lambda x, i, shape_num: getattr(x,
                                        "ParOnEdgeS{}".format(
                                            shape_num))(i),
    BRepExtrema_IsInFace:
        lambda x, i, shape_num: tuple(getattr(x,
                                              "ParOnFaceS{}".format(
                                                  shape_num))(i), )
}


def min_extrema_shape_shape(shape1, shape2, tol=None, algo='grad'):
    """

    :param OCC.TopoDS.TopoDS_Shape shape1:
    :param OCC.TopoDS.TopoDS_Shape shape2:
    :param float tol: Maximum deviation of extrema distances.
    :param str algo:
    :rtype: list[dict[str, float | tuple[float] | OCC.gp.gp_Pnt]]
    """
    measure = _set_up_distshapeshape(shape1, shape2, tol=tol, algo=algo)

    results = []
    for i in range(1, measure.NbSolution() + 1):
        sol = dict()
        pt1 = measure.PointOnShape1(i)
        pt2 = measure.PointOnShape2(i)
        sol['point_s1'] = pt1
        sol['point_s2'] = pt2

        sup_st1 = measure.SupportTypeShape1(i)
        sup_st2 = measure.SupportTypeShape2(i)
        sol['param_s1'] = _res_to_param[sup_st1](measure, i, 1)
        sol['param_s2'] = _res_to_param[sup_st2](measure, i, 2)

        sol['distance'] = measure.Value()
        results.append(sol)
    return results


def min_distance_shape_shape(shape1, shape2, tol=None, algo='grad'):
    """

    :param OCC.TopoDS.TopoDS_Shape shape1:
    :param OCC.TopoDS.TopoDS_Shape shape2:
    :param float tol: Maximum deviation of extrema distances.
    :param str algo:
    :rtype: float
    """
    measure = _set_up_distshapeshape(shape1, shape2, tol=tol, algo=algo)
    return measure.Value()


def _set_up_distshapeshape(shape1, shape2, tol=None, algo='grad'):
    """

    :param OCC.TopoDS.TopoDS_Shape shape1:
    :param OCC.TopoDS.TopoDS_Shape shape2:
    :param float tol: Maximum deviation of extrema distances.
    :param str algo:
    :rtype: OCC.BRepExtrema.BRepExtrema_DistShapeShape
    """
    measure = BRepExtrema_DistShapeShape(shape1, shape2)

    if tol is not None:
        measure.SetDeflection(tol)
    if algo != 'grad':
        ext_algo = _EXTREMA_ALGOS[algo]
        measure.SetAlgo(ext_algo)

    measure.Perform()
    if measure.IsDone():
        return measure
    else:
        raise RuntimeError("Error when calculating minimum distance between"
                           "{} and {}.".format(shape1, shape2))


# TODO (FT): This one will have to go.
def multi_max_cs(curv, surf, samples=10, tol=1e-7):
    """

    :param parapy.geom.Curve curv:
    :param parapy.geom.Surface surf:
    :param int samples:
    :rtype: int
    """
    from OCC.wrapper.Extrema import Extrema_GenExtCS
    from parapy.core import list_of_numbers

    genextcs = Extrema_GenExtCS()
    genextcs.Initialize(surf._Adaptor3d_Surface, 10, 10,
                        surf.u1, surf.u2, surf.v1, surf.v2, tol)
    # pts = list_of_numbers(curv.u1, curv.u2, samples)
    pts = (curv.u1, curv.u2)

    sols = set()
    sol_surf = set()

    # BEGIN NOTHING TO DO WITH THE REST
    from OCC.wrapper.BRepExtrema import BRepExtrema_DistShapeShape
    ss = BRepExtrema_DistShapeShape(curv.TopoDS_Shape,
                                    surf.TopoDS_Shape)

    from OCC.wrapper.GeomAPI import GeomAPI_ExtremaCurveSurface
    ext = GeomAPI_ExtremaCurveSurface(curv.Handle_Geom_Curve,
                                      surf.Handle_Geom_Surface)

    from OCC.wrapper.Extrema import Extrema_GenLocateExtCS
    locext = Extrema_GenLocateExtCS(curv._Adaptor3d_Curve,
                                    surf._Adaptor3d_Surface,
                                    (curv.u2 - curv.u1) / 2. + 0.1,
                                    (surf.u2 - surf.u1) / 2. + 0.1,
                                    (surf.v2 - surf.v1) / 2. + 0.1,
                                    1e-7, 1e-7)
    assert locext.IsDone()
    # END NOTHING TO DO WITH THE REST

    curv_adap = curv._Adaptor3d_Curve
    for i in range(1, len(pts)):
        u_start = pts[i - 1]
        u_end = pts[i]
        genextcs.Perform(curv_adap, 10, u_start, u_end, tol)
        assert genextcs.IsDone()
        for sol_num in range(1, genextcs.NbExt() + 1):
            poc = genextcs.PointOnCurve(sol_num)
            found_pnt = poc.Value()
            sols.add(tuple(found_pnt.Coord()))

            pos = genextcs.PointOnSurface(sol_num)
            found_spnt = pos.Value()
            sol_surf.add(tuple(found_spnt.Coord()))

    return len(sols)


# TODO (FT): This one will stay but needs to be refactored.
def multi_max_loc_cs(curv, surf, c_samples=10, u_samples=5,
                     v_samples=5, tol=1e-7, ext_kind='minmax'):
    """

    :param parapy.geom.Curve curv:
    :param parapy.geom.Surface surf:
    :param int c_samples:
    :param int u_samples:
    :param int v_samples:
    :rtype: int
    """
    from OCC.wrapper.Extrema import Extrema_GenLocateExtCS
    from parapy.core import list_of_numbers

    cu_diff = (curv.u2 - curv.u1) / c_samples
    half_cu_diff = cu_diff / 2.
    pts = list_of_numbers(curv.u1 + half_cu_diff,
                          curv.u2 - half_cu_diff,
                          c_samples)

    u_diff = (surf.u2 - surf.u1) / u_samples
    half_u_diff = u_diff / 2.
    u_pts = list_of_numbers(surf.u1 + half_u_diff,
                            surf.u2 - half_u_diff,
                            u_samples)

    v_diff = (surf.v2 - surf.v1) / v_samples
    half_v_diff = v_diff / 2.
    v_diff = (surf.v2 - surf.v1) / v_samples
    v_pts = list_of_numbers(surf.v1 + half_v_diff,
                            surf.v2 - half_v_diff,
                            v_samples)

    sols = set()
    sol_surf = set()

    from OCC.wrapper.BRepAdaptor import BRepAdaptor_Curve, BRepAdaptor_Surface
    from OCC.utils.top import downcast_shape, edges
    from OCC.wrapper.BRepExtrema import BRepExtrema_ExtCF, BRepExtrema_DistanceSS

    brepext = BRepExtrema_ExtCF(downcast_shape(curv.TopoDS_Shape),
                                downcast_shape(surf.TopoDS_Shape))
    assert brepext.IsDone()
    print(brepext.NbExt())
    bbdist = curv._Bnd_Box.Distance(surf._Bnd_Box)
    for edge in edges(surf.TopoDS_Shape, downcast=True):

        brepss = BRepExtrema_DistanceSS(downcast_shape(curv.TopoDS_Shape),
                                        edge,
                                        curv._Bnd_Box, surf._Bnd_Box,
                                        bbdist * 2, 0.1)
        print(brepss.Seq1Value().Length())
    distances = list()
    curv_adap = curv._Adaptor3d_Curve
    surf_adap = surf._Adaptor3d_Surface

    for u_mid in pts:
        for su in u_pts:
            for sv in v_pts:
                genextcs = Extrema_GenLocateExtCS(curv_adap,
                                       surf_adap,
                                       u_mid,
                                       su, sv,
                                       1e-7, 1e-7)

                if genextcs.IsDone():
                    dist = round(genextcs.SquareDistance(), 7)
                    distances.append(dist)

                    poc = genextcs.PointOnCurve()
                    found_pnt = poc.Value()
                    x, y, z = found_pnt.Coord()
                    sols.add(((round(x, 6),
                              round(y, 6),
                              round(z, 6)),
                              dist))

                    pos = genextcs.PointOnSurface()
                    found_spnt = pos.Value()
                    x, y, z = found_spnt.Coord()
                    sol_surf.add(((round(x, 6),
                                  round(y, 6),
                                  round(z, 6)),
                                  dist))
                else:
                    warnings.warn("GenLocalExt not done, ignoring")

    if ext_kind in ('min', 'minmax'):
        min_sol = min(distances)
    else:
        min_sol = -1  # negative distance should not be in
    if ext_kind in ('max', 'minmax'):
        max_sol = max(distances)
    else:
        max_sol = 1e200  # about infinite


    sols = set(s[0] for s in sols if
                s[1] == min_sol or s[1] == max_sol)
    sol_surf = set(s[0] for s in sol_surf if
               s[1] == min_sol or s[1] == max_sol)

    return len(sols)
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from OCC.wrapper.BRep import BRep_Tool
from OCC.wrapper.BRepMesh import BRepMesh_IncrementalMesh, BRepMesh_OpenWire, \
    BRepMesh_SelfIntersectingWire, BRepMesh_Failure, BRepMesh_ReMesh
from OCC.wrapper.BRepTools import BRepTools__Triangulation, BRepTools__Clean
from OCC.wrapper.TopAbs import TopAbs_FACE
from OCC.wrapper.TopLoc import TopLoc_Location
from OCC.wrapper.TopoDS import TopoDS__Face
from OCC.utils.gp import pnt_to_tup
from OCC.utils.top import faces


def triangulate(shape, deflection=0.01, parallel=True):
    """Add a triangulation to `shape` if there was no triangulation already.
    Assures it meets of to have a given `deflection`, otherwise raises an
    Exception.

    :param OCC.TopoDS.TopoDS_Shape shape: shape to triangulate
    :param float deflection: The deflection the Triangulation should have
    :param bool parallel: set to True if the meshing needs to be done in
        parallel
    """
    if BRepTools__Triangulation(shape, deflection):
        return

    BRepTools__Clean(shape)

    builder = BRepMesh_IncrementalMesh()
    builder.SetParallelDefault(parallel)
    builder.SetShape(shape)
    builder.Perform()

    mesh_status = builder.GetStatusFlags()
    if mesh_status:
        msg = 'error during meshing: {}'
        if mesh_status & BRepMesh_OpenWire:
            raise Exception(msg.format('BRepMesh status: BRepMesh_OpenWire'))
        if mesh_status & BRepMesh_SelfIntersectingWire:
            raise Exception(
                msg.format('BRepMesh: BRepMesh_SelfIntersectingWire'))
        if mesh_status & BRepMesh_Failure:
            raise Exception(msg.format('BRepMesh: BRepMesh_Failure'))
        if mesh_status & BRepMesh_ReMesh:
            raise Exception(msg.format('BRepMesh: BRepMesh_ReMesh'))

    if not BRepTools__Triangulation(shape, deflection):
        raise Exception('Triangulation error: triangulation does not have a '
                        'deflection of {} for each face!'.format(deflection))


def nodes(triangulation):
    """Yield nodes in a `triangulation`.

    :param OCC.Poly.Handle_Poly_Triangulation triangulation:
    :rtype: collections.Iterable[OCC.gp.gp_Pnt]
    """
    ns = triangulation.Nodes()
    for i in range(1, ns.Size() + 1):
        yield ns.Value(i)


def triangles(triangulation):
    """Yield the triangles in `triangulation`.

    :param OCC.Poly.Handle_Poly_Triangulation triangulation:
    :rtype: collections.Iterable[tuple[int]]
    """
    trs = triangulation.Triangles()
    for i in range(1, trs.Size() + 1):
        yield tuple(i-1 for i in trs.Value(i).Get())


def face_triangles(face):
    """ Return the triangles of `face` in the form of a tuple containin nodes
    and a tuple containing triples of indices in the first list that define
    the triangle.

    :param OCC.TopoDS.TopoDS_Face face:
    :rtype: tuple[tuple[tuple[float]], tuple[tuple[int]]]
    """
    face = TopoDS__Face(face)
    loc = TopLoc_Location()

    triangulation = BRep_Tool.Triangulation(face,loc)

    ns = tuple(pnt_to_tup(n) for n in nodes(triangulation))

    trs = tuple(triangles(triangulation))

    return ns, trs


def concatenate(nds, trs):
    """Concatenate the triangles represented by `nodes` and `triangles. Note
    that the following must be in order `len(nodes) == len(trianges)`.

    :param collections.Iterator[collections.Iterator[float]] nds:
    :param: collections.Iterator[collections.Iterator[int]] trs:
    :rtype: tuple[list[tuple[float]], list[tuple[int]]]
    """
    num_nds = len(nds)
    assert num_nds == len(trs)

    pnt2index = dict()
    pnt_lst = list()
    tr_list = list()

    class NonLocal:
        node_ctr = 0

    def update_index(index):
        pnt = ns[index]
        ctr = NonLocal.node_ctr
        try:
            return pnt2index[pnt]
        except KeyError:
            pnt2index[pnt] = ctr
            pnt_lst.append(pnt)
            new_index = ctr
            NonLocal.node_ctr += 1
            return new_index

    for i in range(num_nds):
        ns = nds[i]
        ts = trs[i]
        for triangle in ts:
            new_triangle = list(map(update_index, triangle))
            tr_list.append(new_triangle)

    return pnt_lst, tr_list


def shape_triangles(shape):
    """Return the triangles of `shape`. If `shape` is a TopoDS_Face
    already, the call is similar to `face_triangles`.

    :param OCC.TopoDS.TopoDS_Shape shape:
    :rtype: tuple[tuple[tuple[float]], tuple[tuple[int]]]
    """
    if shape.ShapeType() is TopAbs_FACE:
        return face_triangles(shape)
    else:
        nds = list()
        trs = list()
        res = list(map(face_triangles, faces(shape)))
        for i, (n, t) in enumerate(res):
            nds.append(n)
            trs.append(t)
        return concatenate(nds, trs)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from functools import partial

from OCC.wrapper.Quantity import Quantity_HArray1OfColor
from OCC.wrapper.TColStd import TColStd_HArray1OfBoolean, TColStd_Array1OfInteger, TColStd_Array2OfReal, TColStd_Array1OfReal
from OCC.wrapper.TColgp import (TColgp_Array1OfPnt, TColgp_Array2OfPnt,
                        TColgp_Array1OfVec, TColgp_HArray1OfPnt,
                        TColgp_HArray1OfDir)
from OCC.wrapper.gp import gp_Pnt, gp_Vec

__all__ = ["make_TColgp_Array1OfPnt", "make_TColgp_Array2OfPnt",
           "make_TColgp_Array1OfVec",
           "make_TColStd_HArray1OfBoolean", "make_TColgp_HArray1OfPnt",
           "make_TColStd_Array1OfInteger",
           "make_TColStd_Array1OfReal", "make_TColStd_Array2OfReal",
           "make_TColgp_HArray1OfDir", "make_Quantity_HArray1OfColor"]


# FIXME (FT): return Handles

def make_TColgp_Array1OfPnt(points):
    """
    :param tuple[(float, float, float)] points: ((x, y, z), ...)
    :rtype: TColgp_Array1OfPnt
    """
    arr = TColgp_Array1OfPnt(1, len(points))
    for i, xyz in enumerate(points, 1):
        arr.SetValue(i, gp_Pnt(*xyz))
    return arr


def make_TColgp_Array2OfPnt(points):
    """
    :param tuple[tuple[(float, float, float)]] points: (((x, y, z), ...), ...)
    :rtype: TColgp_Array2OfPnt
    """
    arr = TColgp_Array2OfPnt(1, len(points), 1, len(points[0]))
    for i, pts in enumerate(points, 1):
        for j, xyz in enumerate(pts, 1):
            arr.SetValue(i, j, gp_Pnt(*xyz))
    return arr


def make_TColgp_Array1OfVec(points, skip_false=False):
    """ given a list of Vector instances, returns OCC.TColgp.TColgp_Array1OfVec

    :param collections.Sequence[collections.Sequence[float] | None] points:
    :param bool skip_false: will skip falses (len of arr still len of vectors).
    :rtype: OCC.TColgp.TColgp_Array1OfVec
    """
    arr = TColgp_Array1OfVec(1, len(points))
    for i, xyz in enumerate(points, 1):
        if not skip_false or xyz:
            arr.SetValue(i, gp_Vec(*xyz))
    return arr


def make_TColStd_Array2OfReal(numbers):
    """ Given a 2D sequence of real values, returns a TColStd_Array2OfReal

    :param collections.Sequence[collections.Sequence[float]] numbers: sequence of numbers
    :rtype: OCC.TColStd.TColStd_Array2OfReal
    """
    arr = TColStd_Array2OfReal(1, len(numbers), 1, len(numbers[0]))
    for i, nums in enumerate(numbers, 1):
        for j, num in enumerate(nums, 1):
            arr.SetValue(i, j, num)
    return arr


def make_Array1Of(array_type, items, length=None):
    """Create an Array1Of of type ``array_type`` from ``items``. Optionally
    give an ``length`` which allows ``items`` to be a generator.

    :param type array_type: Class of tpe NCollection_Array1Of...
    :param collections.Sequence[T] | collections.Iterator[T] items: The items
        to store in an object of class ``array_type``.
    :param int | None length: Predefine the length needed to store
        ``items``. If set to :py:`None` it will call :py:`len(items)`.
    :returns: The OCC array of type ``array_type``.
    :rtype: T
    """
    if length is None:
        length = len(items)

    arr = array_type(1, length)
    for i, value in enumerate(items, 1):
        arr.SetValue(i, value)
    return arr


make_TColStd_Array1OfReal = partial(make_Array1Of, TColStd_Array1OfReal)
make_TColStd_Array1OfInteger = partial(make_Array1Of, TColStd_Array1OfInteger)


def make_HArray1Of(harray_type, items, length=None):
    """Create an HArray1Of of type ``harray_type`` from ``items``. Optionally
    give an ``length`` which allows ``items`` to be a generator.

    :param type harray_type: Class of tpe NCollection_HArray1Of...
    :param collections.Sequence[T] | collections.Iterator[T] items: The items
        to store in an object of class ``harray_type``.
    :param int | None length: Predefine the length needed to store
        ``items``. If set to :py:`None` it will call :py:`len(items)`.
    :returns: The OCC array of type ``harray_type``.
    :rtype: T
    """
    if length is None:
        length = len(items)

    arr = harray_type(1, length)
    arr1 = arr.Array1()
    for i, value in enumerate(items, 1):
        arr1.SetValue(i, value)
    return arr


def make_TColgp_HArray1OfPnt(points):
    """ Given a sequence of sequences that are 3 floats long,
    returns a TColgp_HArray1OfPn.

    :param collections.Sequence[collections.Sequence[float]] numbers: sequence of numbers
    :rtype: OCC.TColStd.TColgp_HArray1OfPnt
    """
    arr = TColgp_HArray1OfPnt(1, len(points))
    arr1 = arr.Array1()
    for i, xyz in enumerate(points, 1):
        arr1.SetValue(i, gp_Pnt(*xyz))
    return arr


make_TColgp_HArray1OfDir = partial(make_HArray1Of,
                                   TColgp_HArray1OfDir)
make_TColStd_HArray1OfBoolean = partial(make_HArray1Of,
                                        TColStd_HArray1OfBoolean)
make_Quantity_HArray1OfColor = partial(make_HArray1Of,
                                       Quantity_HArray1OfColor)


def identity(x):
    return x


def make_NCollection_DataMap(map_type, conv_key, conv_value, mapping):
    """Fill a map of type ``map_type`` with an existing dictionary ``mapping``.

    :param T map_type: OCC DataMap type
    :param collections.Callable conv_key: converts the key in ``mapping`` to
        one that is suitable for ``map_type``.
    :param collections.Callable conv_value: converts the value in
        ``mapping`` to one that is suitable for ``map_type``.
    :param mapping: dict
    :return: A filled map of ``map_type``.
    """
    data_map = map_type()
    add_mapping = data_map.Bind

    for k, v in mapping.items():
        key = conv_key(k)
        value = conv_value(v)
        add_mapping(key, value)

    return data_map

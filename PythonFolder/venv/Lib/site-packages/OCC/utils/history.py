#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_VERTEX, TopAbs_SOLID, \
    TopAbs_COMPSOLID, TopAbs_COMPOUND
from OCC.wrapper.TopAbs import TopAbs_FACE
from OCC.utils.top import sub_shapes
from OCC.utils.utilities import TopTools_ListOfShape2list

__all__ = ["SubShapeHistory"]


class SubShapeHistory(object):
    """
    The new SubShapeHistory class is a new part of BRepBuilderAPI_MakeShape
    sub-classes or Topo subclasses in ParaPy. It exploits OCC's Modified,
    Generated and IsDeleted methods, and allows you to link sub-shapes of
    the input shapes to sub-shapes of the resulting BRep topology.
    """

    def __init__(self, builder):
        """ An object to initialize the history of shapes belonging to
        ``owner``.

        :param BRepBuilderAPI_MakeShape | BOPAlgo_Builder builder: the
            builder which created ``owner``
        """
        self.builder = builder

    @property
    def _owner(self):
        return self.builder.Shape()

    @property
    def _builder_sub_shape_map(self):
        """ Generates a map of all sub-shape hashes of _owner to the
        respective sub-shapes in owner

        :return: A map of a topods_shap hash to a sub-shape of the shape in the
            builder
        """
        try:
            return self._bss_map
        except AttributeError:
            bss_map = {}
            for type in (TopAbs_EDGE, TopAbs_FACE, TopAbs_VERTEX,
                         TopAbs_SOLID, TopAbs_COMPOUND, TopAbs_COMPSOLID):
                for shape in sub_shapes(self._owner, type):
                    bss_map[shape.__hash__()] = shape
            self._bss_map = bss_map
            return self._bss_map

    # =========================================================================
    # Methods
    # =========================================================================
    def linked(self, shape, raise_exception=True):
        """
        Main method to find the associated shape in the current topology that
        is linked to the shape provided to this method. Tries various
        methods in order:

        1. SubShapeHistory.reused
        2. SubShapeHistory.modified
        3. SubShapeHistory.generated
        4. SubShapeHistory.is_deleted

        :return: [BRep...]. a list of shapes if linkage 1-to-N.
        :raise Exception: if there is no linkage at all between input shape(
        s) and any of the topological elements in this BRep, raise_exception
        controls whether Exception will be raise or only a warning is printed.
        """
        result = self.reused(shape)
        if not result:
            result = self.modified(shape)
        if not result:
            result = self.generated(shape)
        if not result:
            if self.is_deleted(shape):
                print("WARNING: shape was deleted during B-Rep building " \
                      "step: --> [] returned")
                result = []
            else:
                if raise_exception:
                    raise Exception(
                        "there is not linkage between given sub-shape and "
                        "the newly created topology.\nShape = {}".format(
                            shape))
                else:
                    result = []
        return result

    __call__ = linked

    def reused(self, shape):
        """
        Similar, but more specific than SubShapeHistory.linked. Returns only
        the shape in the new topology if it references the same underlying
        shape as the input shape. Use this method over linked if you want to
        just search for the re-use of topology.

        :param OCC.TopoDS.TopoDS_Shape shape: the shape to test
        :rtype list[OCC.TopoDS.TopoDS_Shape]
        """
        ssmap = self._builder_sub_shape_map
        try:
            return [ssmap[shape.__hash__()]]
        except KeyError:
            return []

    def modified(self, shape):
        """
        Similar, but more specific than SubShapeHistory.linked. Returns only
        the shape in the new topology if it was modified from the input
        shape. Use this method over linked if you want to just search for
        the modification of topology.

        :param OCC.TopoDS.TopoDS_Shape shape: the shape to test
        :rtype list[OCC.TopoDS.TopoDS_Shape]
        """
        mod = self.builder.Modified(shape)

        # now get them from the shape belonging to the builder, since the
        # modified call will discard the results on the next call
        ssmap = self._builder_sub_shape_map
        return [ssmap[s.__hash__()] for s in TopTools_ListOfShape2list(mod)]

    def generated(self, shape):
        """
        Similar, but more specific than SubShapeHistory.linked. Returns only
        the shape in the new topology that was "generated" from the input
        shape. Use this method over linked if you want to just search for
        the generation of topology. TODO: unclear what generation is...

        :param OCC.TopoDS.TopoDS_Shape shape: the shape to test
        :rtype list[OCC.TopoDS.TopoDS_Shape]
        """
        # now get them from the shape belonging to the builder, since the
        # modified call will discard the results on the next call
        ssmap = self._builder_sub_shape_map
        return [ssmap[s.__hash__()] for s in TopTools_ListOfShape2list(
            self.builder.Generated(shape))]

    def is_deleted(self, shape):
        """Tests if a shape has been deleted.

        :param OCC.TopoDS.TopoDS_Shape shape: the shape to test
        :rtype: bool
        """
        return self.builder.IsDeleted(shape)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Utilities on topological objects."""

from OCC.wrapper.BRep import BRep_Tool_Curve, BRep_Tool_Pnt, BRep_Builder, BRep_Tool
from OCC.wrapper.BRepBndLib import BRepBndLib__Add
from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_Copy, BRepBuilderAPI_MakeEdge
from OCC.wrapper.BRepClass import BRepClass_FaceClassifier
from OCC.wrapper.BRepClass3d import (BRepClass3d_SolidClassifier,
                             BRepClass3d_SolidExplorer)
from OCC.wrapper.BRepGProp import (BRepGProp__LinearProperties,
                           BRepGProp__SurfaceProperties,
                           BRepGProp__VolumeProperties)
from OCC.wrapper.Bnd import Bnd_Box
from OCC.wrapper.GProp import GProp_GProps
from OCC.wrapper.IntTools import IntTools_FClass2d
from OCC.wrapper.Precision import Precision__Confusion
from OCC.wrapper.ShapeAnalysis import (ShapeAnalysis_FreeBounds, ShapeAnalysis_Shell,
                               ShapeAnalysis_Surface)
from OCC.wrapper.ShapeExtend import ShapeExtend_Explorer
from OCC.wrapper.ShapeFix import (ShapeFix_Edge, ShapeFix_Face, ShapeFix_Shell,
                          ShapeFix_Solid, ShapeFix_Wire)
from OCC.wrapper.TopAbs import (TopAbs_COMPOUND, TopAbs_COMPSOLID, TopAbs_EDGE,
                        TopAbs_FACE, TopAbs_IN, TopAbs_SHELL, TopAbs_SOLID,
                        TopAbs_VERTEX,
                        TopAbs_WIRE, TopAbs_ON)
from OCC.wrapper.TopExp import (TopExp__FirstVertex, TopExp__LastVertex,
                        TopExp__MapShapes)
from OCC.wrapper.TopTools import TopTools_IndexedMapOfShape, TopTools_ListOfShape
from OCC.wrapper.TopoDS import (TopoDS__CompSolid, TopoDS__Compound, TopoDS__Edge,
                        TopoDS__Face, TopoDS__Shell, TopoDS__Solid,
                        TopoDS__Vertex, TopoDS__Wire, TopoDS_Shell,
                        TopoDS_Wire)
from OCC.wrapper.gp import gp_Pnt, gp_Pnt2d
from OCC.utils.gp import pnt_to_tup

__all__ = ["downcast_shape", "sub_shapes",
           "create_toptools_listofshape", "reverse_edge", "is_inside",
           "free_edges", "bad_edges", "area", "bnd_box", "bounds", "cog",
           "compounds", "compsolids", "dim", "edges", "faces",
           "fix_orientation", "is_inside_out", "mass", "matrix_of_inertia",
           "props", "shape_copy", "shells", "solids", "static_moments",
           "vertices"]

# Indices correspond to TopAbs_ShapeEnum
TOPABS_TO_DOWNCAST = (TopoDS__Compound, TopoDS__CompSolid, TopoDS__Solid,
                      TopoDS__Shell, TopoDS__Face, TopoDS__Wire,
                      TopoDS__Edge, TopoDS__Vertex)

TopAbs2Class = {TopAbs_VERTEX: "VertexClass",
                TopAbs_EDGE: "EdgeClass",
                TopAbs_WIRE: "WireClass",
                TopAbs_FACE: "FaceClass",
                TopAbs_SHELL: "ShellClass",
                TopAbs_SOLID: "SolidClass",
                TopAbs_COMPSOLID: "CompsolidClass",
                TopAbs_COMPOUND: "CompoundClass"}

TobAbs2TopoDS = {TopAbs_VERTEX: TopoDS__Vertex,
                 TopAbs_EDGE: TopoDS__Edge,
                 TopAbs_WIRE: TopoDS__Wire,
                 TopAbs_FACE: TopoDS__Face,
                 TopAbs_SHELL: TopoDS__Shell,
                 TopAbs_SOLID: TopoDS__Solid,
                 TopAbs_COMPSOLID: TopoDS__CompSolid,
                 TopAbs_COMPOUND: TopoDS__Compound}

Name2TopAbs = {"vertex": TopAbs_VERTEX,
               "edge": TopAbs_EDGE,
               "wire": TopAbs_WIRE,
               "face": TopAbs_FACE,
               "shell": TopAbs_SHELL,
               "solid": TopAbs_SOLID,
               "compsolid": TopAbs_COMPSOLID,
               "compound": TopAbs_COMPOUND}

Name2Level = {"vertex": 7,
              "edge": 6,
              "wire": 5,
              "face": 4,
              "shell": 3,
              "solid": 2,
              "compsolid": 1,
              "compound": 0}

Level2Class = {7: "VertexClass",
               6: "EdgeClass",
               5: "WireClass",
               4: "FaceClass",
               3: "ShellClass",
               2: "SolidClass",
               1: "CompsolidClass",
               0: "CompoundClass"}

Level2Attr = {7: "vertices",
              6: "edges",
              5: "wires",
              4: "faces",
              3: "shells",
              2: "solids",
              1: "compsolids",
              0: "compounds"}

Level2Name = {7: "vertex",
              6: "edge",
              5: "wire",
              4: "face",
              3: "shell",
              2: "solid",
              1: "compsolid",
              0: "compound"}

Level2TopAbs = {7: TopAbs_VERTEX,
                6: TopAbs_EDGE,
                5: TopAbs_WIRE,
                4: TopAbs_FACE,
                3: TopAbs_SHELL,
                2: TopAbs_SOLID,
                1: TopAbs_COMPSOLID,
                0: TopAbs_COMPOUND}

Level2TopoDS = {7: TopoDS__Vertex,
                6: TopoDS__Edge,
                5: TopoDS__Wire,
                4: TopoDS__Face,
                3: TopoDS__Shell,
                2: TopoDS__Solid,
                1: TopoDS__CompSolid,
                0: TopoDS__Compound}

DIM2PROPS = {1: BRepGProp__LinearProperties,
             2: BRepGProp__SurfaceProperties,
             3: BRepGProp__VolumeProperties}

SHAPE_DEFAULT_DIM = {
    TopAbs_VERTEX: 0,
    TopAbs_EDGE: 1,
    TopAbs_WIRE: 1,
    TopAbs_FACE: 2,
    TopAbs_SOLID: 3,
    TopAbs_SHELL: 3
}


def downcast_shape(shape, shape_type=None):
    """Downcasts ``shape`` to sub-class based on ShapeType().

    :param TopoDS_Shape shape: shape to downcast
    :rtype: TopoDS_Shape
    :param shape_type: TopAbs_ShapeEnum or None (direct children).
    :type shape_type: int | None
    :returns: sub-class of :class:`TopoDS_Shape`
    """
    if shape_type is None:
        shape_type = shape.ShapeType()
    downcast = TOPABS_TO_DOWNCAST[shape_type](shape)
    downcast.__d = shape
    return downcast


def compound_sub_shapes(comp, recursive=False, downcast=False):
    """Return the direct children of compound ``comp``. If ``recursive`` is
    set to ``True``, it will do this recursively for compound-type children.

    :param OCC.TopoDS.TopoDS_Shape comp: The compound to explore
    :param bool recursive: If True, if a sub-shape of ``comp`` is also a
        compound, it will not return it to the list, instead it will add its
        sub-shapes to the list. This works recursively. Default: ``False``
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    assert comp.ShapeType() == TopAbs_COMPOUND

    expl = ShapeExtend_Explorer()
    h_seq = expl.SeqFromCompound(comp, recursive)
    seq = h_seq.Sequence()

    for shape in seq:
        shape.__d = seq
        if downcast:
            shape = downcast_shape(shape, shape_type=shape.ShapeType())
        yield shape


def sub_shapes(owner, shape_type=None, downcast=False):
    """Yield sub shapes of owning ``owner``. Either
    direct children (:py:`shapetype=None`) or of a specific kind. Sub shapes
    will be of type TopoDS_Shape. If ``downcast`` is :py:`True`, they will be
    downcasted to specific TopoDS class (e.g. TopoDS_Edge).

    :param TopoDS_Shape owner: owner shape.
    :param shape_type: TopAbs_ShapeEnum or None (direct children).
    :type shape_type: int | None
    :param bool downcast: downcast child type from specialized TopoDS_Shape?
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    owner_shape_type = owner.ShapeType()
    if owner_shape_type == TopAbs_VERTEX:
        return

    if shape_type is None:
        if owner_shape_type == TopAbs_COMPOUND:
            for shape in compound_sub_shapes(owner, downcast=downcast):
                yield shape
        else:  # not a compound
            # we know the shape type.
            shape_type = owner_shape_type + 1
            for s in _map_shapes(owner, shape_type, downcast=downcast):
                yield s
            # TODO ( ): Fix for compounds bug: when giving type, it only gives
            # /todo back the compound itself
    else:
        # BUG in OCC: asking compound sub-shapes of a compound, returns top-level
        # compound only
        if (shape_type == TopAbs_COMPOUND and
                    owner_shape_type == TopAbs_COMPOUND):
            for s in _map_all_shapes(owner, downcast=downcast):
                if s.ShapeType() == shape_type:
                    yield s
        else:
            for s in _map_shapes(owner, shape_type, downcast=downcast):
                yield s


def _map_shapes(owner, shape_type, downcast=False):
    """Yield the sub-shapes of ``owner`` that are of a given ``shape_type``.

    :param OCC.TopoDS.TopoDS_Shape owner: The owning shape of which the
        sub_shapes are yielded.
    :param int shape_type: A TopAbs shape type.
    :param bool downcast: Should the result be downcasted to the specialized
        TopoDS type. Default: ``False``.
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    # any child of specified kind.
    map_ = TopTools_IndexedMapOfShape()
    TopExp__MapShapes(owner, shape_type, map_)
    for i in range(1, map_.Extent() + 1):
        s = map_(i)
        if downcast:
            s = downcast_shape(s, shape_type=shape_type)
        yield s


def _map_all_shapes(owner, downcast=False):
    """Yield all the sub-shapes of ``owner``.

    :param OCC.TopoDS.TopoDS_Shape owner: The owning shape of which the
        sub shapes are yielded.
    :param bool downcast: Should the result be downcasted to the specialized
        TopoDS type. Default: ``False``.
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
    """
    # any child of specified kind.
    map_ = TopTools_IndexedMapOfShape()
    TopExp__MapShapes(owner, map_)
    for i in range(1, map_.Extent() + 1):
        s = map_(i)
        if downcast:
            s = downcast_shape(s)
        yield s


def create_toptools_listofshape(topods_shapes):
    """Create TopTools_ListOfShape from iterable of TopoDS_Shape objects.

    :type topods_shapes: collections.Iterable[OCC.TopoDS.TopoDS_Shape]
    :rtype: TopTools_ListOfShape
    """
    lst = TopTools_ListOfShape()
    for s in topods_shapes:
        lst.Append(s)
    return lst


def shape_copy(shape):
    """Returns a copy of ``shape``.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape to be copied
    :rtype: OCC.TopoDS.TopoDS_Shape
    """
    builder = BRepBuilderAPI_Copy()
    builder.Perform(shape)
    return builder.Shape()


def vertices(shape, downcast=True):
    """returns the vertices of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the vertices.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_VERTEX, downcast))


def edges(shape, downcast=True):
    """returns the edges of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the edges.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_EDGE, downcast))


def faces(shape, downcast=True):
    """returns the faces of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the faces.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_FACE, downcast))


def solids(shape, downcast=True):
    """returns the solids of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the solids.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_SOLID, downcast))


def shells(shape, downcast=True):
    """returns the shells of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the shells.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_SHELL, downcast))


def compounds(shape, downcast=True):
    """returns the compounds of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the
        compounds.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_COMPOUND, downcast))


def compsolids(shape, downcast=True):
    """returns the compsolids of a shape.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape that contains the
        compsolids.
    :param bool downcast: if True, downcast the shapes, otherwise
        TopoDS_Shapes are returned.
    :return: list[OCC.TopoDS.TopoDS_Shape]
    """
    return list(sub_shapes(shape, TopAbs_COMPSOLID, downcast))


def dim(shape):
    """Gives back the dimensionality of the shape.

    :param OCC.TopoDS.TopoDS_Shape shape: shape of which we want the default
        dimension.
    :raises: Exception for compounds
    :rtype: int
    """
    shape_type = shape.ShapeType()
    try:
        return SHAPE_DEFAULT_DIM[shape_type]
    except KeyError:
        msg = "Shape type {} has no dimensions! If it is a compound, use " \
              "the sub-shapes"
        raise Exception(msg.format(TopAbs2Class[shape_type]))


def props(shape, dimension):
    """ Retrieves the ``dimension``D properties of ``shape``

    :param OCC.TopoDS.TopoDS_Shape shape: shape we want the properties of
    :param int dimension: the dimension for which we want to retrieve the
        properties.
    :rtype: OCC.GProp.GProp_GProps
    """
    properties = GProp_GProps()
    DIM2PROPS[dimension](shape, properties)
    return properties


def cog(shape):
    """ Returns the center of gravity of a ``shape``. Does not work for
    compounds.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which the cog is
        returned
    :return: tuple[float]
    """
    try:
        default_dim = dim(shape)
    except KeyError:
        msg = "Shape type {} has no Center of Gravity!"
        raise Exception(msg.format(TopAbs2Class[shape.ShapeType()]))

    if default_dim:
        com = props(shape, default_dim).CentreOfMass()
    else:
        com = BRep_Tool_Pnt(shape)
    return pnt_to_tup(com)


def static_moments(shape):
    """Returns the static moments of the shape. Does not work for compounds.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which the static
        moments are returned.
    :rtype: tuple[float]
    """
    default_dim = dim(shape)

    if not default_dim:
        msg = "Shape type {} has no static moments!"
        raise Exception(msg.format(TopAbs2Class[shape.ShapeType()]))

    return props(shape, default_dim).StaticMoments()


def mass(shape):
    """Returns the mass of the shape. Does not work for compounds.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which the cog is
        returned.
    :rtype: float
    """
    default_dim = dim(shape)

    if default_dim < 3:
        msg = "Shape type {} has no mass!"
        raise Exception(msg.format(TopAbs2Class[shape.ShapeType()]))
    return props(shape, default_dim).Mass()


def length(shape, skip_shared=True):
    """Give back the length of the edges on ``shape``. If ``skip_shared``
    is True (default), it will cound edges shared by multiple edges only once.

    Usage:

    >>> from OCC.wrapper.BRepPrimAPI import BRepPrimAPI_MakeBox
    >>> w, l, h = 1, 2, 3
    >>> box = BRepPrimAPI_MakeBox(w, l, h).Shape()
    >>> length(box)  # (w + l + h) * 4
    24.0
    >>> length(box, skip_shared=False)  # (w + l + h) * 4 * 2
    48.0

    :param OCC.TopoDS.TopoDS_Shape shape: Shape to analyze (edge, ..., solid).
    :param bool skip_shared: Count shared edges once?
    :return: float
    """
    gprops = GProp_GProps()
    BRepGProp__LinearProperties(shape, gprops, skip_shared)
    return gprops.Mass()


def area(shape):
    """Returns the mass of the shape. Does not work for compounds.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which the area is
        returned.
    :rtype: float
    """
    default_dim = dim(shape)

    if default_dim < 2:
        msg = "Shape type {} has no area!"
        raise Exception(msg.format(TopAbs2Class[shape.ShapeType()]))
    return props(shape, 2).Mass()


def matrix_of_inertia(shape):
    """The 9 quadratic moments of inertia around center of mass and around
    the global Cartesian system, format::

        [[Ixx, Ixy, Ixz],
         [Ixy, Iyy, Iyz],
         [Ixz, Iyz, Izz]]

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which the matrix is
        returned.
    :return: ((float, float, float), (float, float, float),
        (float, float, float))
    :rtype: tuple[tuple[float]]

    .. note:: the density is assumed to be 1. Hence, the mass used to
        calculate inertia is equal to volume. Feel free to multiple these
        results with a specific density.
    """
    default_dim = dim(shape)
    mat = props(shape, default_dim).MatrixOfInertia()
    return tuple(
        tuple(mat.Value(i, j) for i in range(1, 4)) for j in range(1, 4))


def bnd_box(shape):
    """Returns the bounding box of ``shape``.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which we want the
        bounding box
    :rtype: OCC.Bnd.Bnd_Box
    """
    box = Bnd_Box()
    BRepBndLib__Add(shape, box)
    return box


def bounds(shape):
    """Returns the bounds (of the bounding box) of ``shape``.

    :param OCC.TopoDS.TopoDS_Shape shape: The shape of which we want the
        bounds
    :return: ((x_min, x_max), (y_min, y_max), (z_min, z_max))
    :rtype: tuple[tuple[float]]
    """
    box = bnd_box(shape)
    x_min, y_min, z_min, x_max, y_max, z_max = box.Get()
    return (x_min, x_max), (y_min, y_max), (z_min, z_max)


TOPABS2SHAPEFIX = {
    TopAbs_EDGE: ShapeFix_Edge,
    TopAbs_FACE: ShapeFix_Face,
    TopAbs_SOLID: ShapeFix_Solid,
    TopAbs_WIRE: ShapeFix_Wire,
    TopAbs_SHELL: ShapeFix_Shell
}


def fix_orientation(face):
    """Fixes the orientation of a face.

    :param OCC.TopoDS.TopoDS_Face face: shape to fix the orientation of
    :rtype: OCC.TopoDS.TopoDS_Face
    """

    fixer = ShapeFix_Face(face)
    fixer.FixOrientation()
    return fixer.Face()


def bad_edges(shape):
    """Gives back the bad edges of ``shape``. Shape must be a Shell or a Solid.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape to analyze, Shell or Solid.
    :rtype: list[OCC.TopoDS.TopoDS_Shape]
    """
    sas = ShapeAnalysis_Shell()
    sas.CheckOrientedShells(shape, True)
    return edges(sas.BadEdges())


def free_edges(shape):
    """Gives back the free edges of ``shape``. Shape must be a Shell or a
    Solid.

    :param OCC.TopoDS.TopoDS_Shape shape: the shape to analyze, Shell or Solid.
    :rtype: list[OCC.TopoDS.TopoDS_Shape]
    """
    analyzer = ShapeAnalysis_FreeBounds(shape)
    return edges(analyzer.GetClosedWires()) + edges(analyzer.GetOpenWires())


def is_inside_out(solid):
    """Is ``solid`` turned inside-out? Will return True if inside-out.

    :param OCC.TopoDS.TopoDS_Solid solid: solid which might be inside-out
    :rtype: list[OCC.TopoDS.TopoDS_Shape]
    """
    classifier = BRepClass3d_SolidClassifier(solid)
    classifier.PerformInfinitePoint(Precision__Confusion())
    return classifier.State() == TopAbs_IN


def is_inside(solid, point):
    """Test if point lies inside solid volume. Returns True if point is
    inside. Point ON the surface of the enclosed volume are not inside
    the solid. Be careful with solid that are
    reversed... (is_reversed = True or mass/volume = negative)

    :param OCC.TopoDS.TopoDS_Solid solid: solid in which ``point``might lie
    :param tuple[float] point: A Point inside the solid
    :rtype: bool
    """
    classifier = BRepClass3d_SolidClassifier(solid, gp_Pnt(*point),
                                             Precision__Confusion())
    return classifier.State() == TopAbs_IN


def reverse_edge(edge):
    """Returns a new edge that is the reversed of this edge
    Warning: edge does not lie on any face in the owning topology object
    anymore.
    http://www.opencascade.org/org/forum/thread_3680/?forum=3

    :param OCC.TopoDS.TopoDS_Edge edge: edge to be reversed
    :rtype: OCC.TopoDS.TopoDS_Edge
    """
    v1 = TopExp__FirstVertex(edge, True)
    v2 = TopExp__LastVertex(edge, True)

    crv, u1, u2 = BRep_Tool_Curve(edge)
    u1 = float(crv.ReversedParameter(u1))
    u2 = float(crv.ReversedParameter(u2))
    builder = BRepBuilderAPI_MakeEdge(crv.Reversed(), v2, v1, u2, u1)
    # builder = BRepBuilderAPI_MakeEdge(crv.Reversed(), u2, u1)
    if builder.IsDone():
        return builder.Edge()
    else:
        msg = "Failed to reverse Edge. Parameters u1 {:}, u2 {:}."
        raise RuntimeError(msg.format(u2, u1))


def faces_to_shell(*topods_faces):
    """Convert one or multiple faces into a TopoDS_Shell. Removes duplicate
    faces.

    Use it like::

        faces_to_shell(face1, face2, face3)

        or

        faces_to_shell(face1)

    :param topods_faces: one or multiple TopoDS_Face instances
    :rtype: OCC.TopoDS.TopoDS_Shell
    """
    topods_shell = TopoDS_Shell()
    builder = BRep_Builder()
    builder.MakeShell(topods_shell)

    visited = set()
    for topods_face in topods_faces:
        if topods_face not in visited:
            builder.Add(topods_shell, topods_face)
            visited.add(topods_face)
    return topods_shell


def edges_to_wire(*topods_edges):
    """Convert one or multiple edges into a TopoDS_Wire. Removes duplicate
    edges. Use it like:

    >>> edges_to_wire(edge1)
    >>> edges_to_wire(edge1, edge2, edge3)

    :param topods_edges: one or multiple TopoDS_Edge instances
    :rtype: OCC.TopoDS.TopoDS_Wire
    """
    topods_wire = TopoDS_Wire()
    builder = BRep_Builder()
    builder.MakeWire(topods_wire)

    visited = set()
    for topods_edge in topods_edges:
        if topods_edge not in visited:
            builder.Add(topods_wire, topods_edge)
            visited.add(topods_edge)
    return topods_wire


def is_infinite_face(face, tol=1.0e-7):
    """Tests whether infinite 2d point lies within domain of face.

    :param OCC.TopoDS.TopoDS_Face face:
    :param float tol: initialize algorithm with tolerance
    :rtype: bool
    """
    ints = IntTools_FClass2d(face, tol)
    state = ints.PerformInfinitePoint()
    return state == TopAbs_IN


def point_in_face(face, point, include_edges=False, tol=1.0e-7):
    """Does ``point` lie inside ``face`` with given ``precision``?

    :param OCC.TopoDS.TopoDS_Face face:
    :param OCC.gp.gp_Pnt point: point to test for
    :param bool include_edges: if ``point`` in on one of the edges, does it
        also count as *in*?
    :param float tol: initialize algorithm with tolerance
    :rtype: bool
    """
    srf = BRep_Tool.Surface(face)
    analysis = ShapeAnalysis_Surface(srf)
    gp_pnt2d = analysis.ValueOfUV(point, tol)
    if analysis.Gap() > tol:
        return False
    else:
        u, v = gp_pnt2d.X(), gp_pnt2d.Y()
        return uv_in_face(face, u, v, include_edges=include_edges)

    # BRepClass_FaceClassifier() is not reliable, see also:
    # https://www.opencascade.com/content/picking-and-finding-point-3d
    # ints = BRepClass_FaceClassifier(face, point, tol)
    # state = ints.State()
    #
    # if state == TopAbs_IN:
    #     return True
    # elif include_edges and state == TopAbs_ON:
    #     return True
    # else:
    #     return False


def uv_in_face(face, u, v, include_edges=False, tol=1.0e-7):
    """Do ``u, v`` parameters lie inside ``face``?

    :param OCC.TopoDS.TopoDS_Face face:
    :param float u: u parameter
    :param float v: v parameter
    :param bool include_edges: if u, v in on one of the edges, does it also
        count as *in*?
    :param float tol: initialize algorithm with tolerance
    :rtype: bool
    """
    ints = BRepClass_FaceClassifier(face, gp_Pnt2d(u, v), tol)
    state = ints.State()

    if state == TopAbs_IN:
        return True
    elif include_edges and state == TopAbs_ON:
        return True
    else:
        return False


def find_uv_in_face(face):
    """Find (u, v) parameters inside **bounded** ``topods_face``.

    :param OCC.TopoDS.TopoDS_Face face:
    :rtype: (float, float)
    :raises RuntimeError: if algorithm can't find u, v point inside face. For
        example when topods_face is infinite (not bounded by edges).
    """
    flag, u, v = BRepClass3d_SolidExplorer.FindAPointInTheFace(face)
    if not flag:
        msg = "Failed to find (u,v) point in face"
        raise RuntimeError(msg)

    # TODO (RvD): remove extra check if enough confidence gained in algorithm
    assert uv_in_face(face, u, v, include_edges=False), \
        "uv-point not inside face"

    return u, v


def find_point_in_face(face):
    """Find a point inside **bounded**``topods_face``.

    :param OCC.TopoDS.TopoDS_Face face:
    :rtype: OCC.gp.gp_Pnt
    """
    u, v = find_uv_in_face(face)
    srf = BRep_Tool.Surface(face)
    return srf.Value(u, v)

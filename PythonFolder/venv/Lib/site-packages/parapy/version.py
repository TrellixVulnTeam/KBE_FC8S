#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import warnings
from functools import wraps

# noinspection PyUnresolvedReferences
from setuptools.extern import packaging

__import__('setuptools.extern.packaging.version')  # copied from setuptools

__all__ = ["Version"]


def ensure_other_is_version_else_return_not_implemented(f):
    @wraps(f)
    def wrapper(self, other):
        if isinstance(other, str):
            other = Version(other)
        elif not isinstance(other, Version):
            return NotImplemented
        return f(self, other)
    return wrapper


class Version(object):
    """Derived str that implements custom comparison logic for version number
    comparisons (==, >, <, >=, >=). Version numbering semantics according to
    PEP-440: https://www.python.org/dev/peps/pep-0440/.

    General usage inside a ParaPy application::

        import parapy

        if parapy.__version__ >= "1.3":
            # do something
        else:
            # do something else

        # alternative compare components of the version number
        if parapy.__version__.major == 1 and parapy.__version__.minor == 2:
            # do something

    Some examples:

    >>> v = Version("1.2.3.4")
    >>> v
    <Version('1.2.3.4')>
    >>> v.major, v.minor, v.revision, v.build
    (1, 2, 3, 4)
    >>> # beware, .build can be None depending on components in version number
    >>> Version("1.2.3").build is None
    True

    >>> v == "1.2.3.4", v == "1.2.3", v == "1.2", v == "1"
    (True, False, False, False)
    >>> v > "1.2.3.4", v > "1.2.3", v > "1.2", v > "1"
    (False, True, True, True)
    >>> v >= "1.2.3.4", v >= "1.2.3", v >= "1.2", v >= "1"
    (True, True, True, True)
    >>> v < "1.2.3.4", v < "1.2.3", v < "1.2", v < "1"
    (False, False, False, False)
    >>> v <= "1.2.3.4", v <= "1.2.3", v <= "1.2", v <= "1"
    (True, False, False, False)

    >>> # also works for alpha, beta, post releases and release candidates
    >>> v = Version("1.2.3a1")
    >>> v.is_prerelease
    True
    >>> v < "1.2.3b1", v < "1.2.3rc1", v < "1.2.3"
    (True, True, True)
    >>> v = Version("1.2.3.post1")
    >>> v.is_postrelease
    True
    >>> v > "1.2.3"
    True

    .. note:: pre-release syntax::

        X.YaN   # Alpha release
        X.YbN   # Beta release
        X.YrcN  # Release Candidate
        X.Y     # Final release

    .. note:: post-release syntax::

        X.Y.postN    # Post-release

    .. note:: development release syntax::

        X.Y.devN    # Developmental release
    """

    def __init__(self, version):
        """
        :param str version: version number
        """
        self.version = self.safe_parse(version)

        #: for regular version:
        #:      namedtuple: ["epoch", "release", "dev", "pre", "post", "local"]
        #: for legacy version:
        #:      regular string
        #: :type: packaging.version._Version | str
        self._version = self.version._version

    # noinspection PyMissingConstructor
    @staticmethod
    def safe_parse(version, warn=True):
        """
        Parse the given version string and return either a :class:`Version`
        object or a :class:`LegacyVersion` object depending on if the given
        version is a valid PEP-440 version or a legacy version.

        :param str version: version number
        :param bool warn: warn if version number is not according to PEP-440?
        """
        try:
            return packaging.version.Version(version)
        except packaging.version.InvalidVersion:
            if warn:
                msg = ("Invalid version number {!r}. Falling back to a"
                       "LegacyVersion backend, be careful when doing version "
                       "comparisons")
                warnings.warn(msg.format(version))
            return packaging.version.LegacyVersion(version)

    def __hash__(self):
        return hash(self.version._key)

    @ensure_other_is_version_else_return_not_implemented
    def __eq__(self, other):
        """:type other: str | Version"""
        # __version__ == "1.2.0"
        return self.version == other.version

    @ensure_other_is_version_else_return_not_implemented
    def __ne__(self, other):
        """:type other: str | Version"""
        # __version__ != "1.2.0"
        return self.version != other.version

    @ensure_other_is_version_else_return_not_implemented
    def __gt__(self, other):
        """:type other: str | Version"""
        # __version__ > "1.2.0"
        return self.version > other.version

    @ensure_other_is_version_else_return_not_implemented
    def __ge__(self, other):
        """:type other: str | Version"""
        # __version__ >= "1.2.0"
        return self.version >= other.version

    @ensure_other_is_version_else_return_not_implemented
    def __lt__(self, other):
        """:type other: str | Version"""
        # __version__ < "1.2.0"
        return self.version < other.version

    @ensure_other_is_version_else_return_not_implemented
    def __le__(self, other):
        """:type other: str | Version"""
        # __version__ <= "1.2.0"
        return self.version <= other.version

    def __str__(self):
        return str(self.version)

    def __repr__(self):
        return "<Version({0})>".format(repr(str(self)))

    @property
    def is_legacy(self):
        """Is this Version string based on a legacy version number that doesn't
        adhere to PEP-440?"""
        return isinstance(self.version, packaging.version.LegacyVersion)

    @property
    def major(self):
        """Major part of version number::

            X.2.3.3  # (X marks the spot)

        :raises RuntimeError: if version number is not according to PEP-440.
        :rtype: int
        """
        return self._get_version_part(0)

    @property
    def minor(self):
        """Minor part of version number or None if not present::

            1.X.3.4  # (X marks the spot)

        :raises RuntimeError: if version number is not according to PEP-440.
        :rtype: int | None
        """
        return self._get_version_part(1)

    @property
    def revision(self):
        """Revision part of version number or None if not present::

            1.2.X.4  # (X marks the spot)

        :raises RuntimeError: if version number is not according to PEP-440.
        :rtype: int | None
        """
        return self._get_version_part(2)

    @property
    def build(self):
        """Build part of version number or None if not present::

            1.2.3.X  # (X marks the spot)

        :raises RuntimeError: if version number is not according to PEP-440.
        :rtype: int | None
        """
        return self._get_version_part(3)

    @property
    def local(self):
        return self.version.local

    @property
    def is_prerelease(self):
        return self.version.is_prerelease

    @property
    def is_postrelease(self):
        return self.version.is_postrelease

    def _get_version_part(self, idx):
        if self.is_legacy:
            msg = ("Attribute is not supported for legacy version number {!}, "
                   "comply with PEP-440: "
                   "https://www.python.org/dev/peps/pep-0440/.")
            raise RuntimeError(msg.format(str(self)))
        else:
            try:
                return self._version.release[idx]
            except IndexError:
                return None

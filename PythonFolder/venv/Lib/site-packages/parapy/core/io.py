#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""FileWriter and FileReader"""

import os

from parapy.core import validate as val
from parapy.core.base import Base
from parapy.core.globs import ICN_DIR
from parapy.core.input import Input
from parapy.globs import PKG_DIR


class _IOMixin(Base):

    #: either "file" or "dir"
    #: :type: str
    file_or_dir = Input("file", validator=val.OneOf(["file", "dir"]))

    #: something like 'pictures (*.bmp,*.gif,*.xwd) |*.bmp;*.gif;*.wxd'")
    #: :type: str
    wildcard = Input(None)

    #: filename. If None, you can specify it through GUI or by calling
    #: :attr:`FileReader.read` / :attr:`FileWriter.write` with filename.
    #: :type: str | None
    filename = Input(None)

    _NO_PATHNAME_MSG = ("No pathname given! Please provide a pathname or "
                        "set the filename. Object: {!r}")

    @Input
    def default_directory(self):
        filename = self.filename
        if filename:
            directory = os.path.dirname(os.path.realpath(filename))
            if os.path.exists(directory):
                return directory
        return PKG_DIR

    def resolve_pathname(self, pathname):
        pathname = pathname or self.filename
        if pathname is None:
            raise RuntimeError(self._NO_PATHNAME_MSG.format(self))
        return os.path.abspath(pathname)


class FileReader(_IOMixin):
    """Object to write a file from disk. Has nice visualization in GUI."""

    #: Set to True to be able to select multiple *files*.
    #: .. note:: It does not work for directories (:py:`file_or_dir=="dir"`)
    #: .. note:: the 'read' method will get a list of paths instead of a
    #:      single path.
    #: :type: bool
    multiple = Input(False)

    __icon__ = os.path.join(ICN_DIR, "input.png")

    @multiple.validator
    def multiple(self, value):
        if value and self.file_or_dir == "dir":
            return False, ("multiple cannot be True when "
                           "file_or_dir=='dir'")
        else:
            return True

    @Input
    def default_directory(self):
        if self.multiple:
            return PKG_DIR
        else:
            return super().default_directory

    def read(self, pathname=None):
        """Implement this. path is a directory or file path
        depending on self.file_or_dir.
        """
        raise NotImplementedError("implement in subclass")

    def _check_exists(self, pathname):
        if os.path.exists(pathname):
            return pathname
        else:
            raise FileNotFoundError(f"{self.file_or_dir} {pathname} does "
                                    f"not exist! Object: {self!r}")

    def resolve_pathname(self, pathname):
        if self.multiple:
            pathname = pathname or self.filename
            if pathname is None:
                raise RuntimeError(self._NO_PATHNAME_MSG.format(self))

            paths = []
            for path in map(os.path.abspath, pathname):
                self._check_exists(path)
                paths.append(path)
            return paths
        else:
            pathname = super().resolve_pathname(pathname)
            self._check_exists(pathname)
            return pathname


class FileWriter(_IOMixin):
    """Object to write a file to disk. Has nice visualization in GUI."""

    __icon__ = os.path.join(ICN_DIR, "output.png")

    def write(self, pathname=None):
        """Implement this. path is a directory or file path
        depending on self.file_or_dir.
        """
        raise NotImplementedError("implement in subclass")

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This is description of the code"""

from parapy.core.globs import Undefined
from parapy.core import Sequence


class DynamicType(object):
    """Class for all dynamically typed instances. It expects the ``type``
    keyword, which can be any expression that evaluates to a (Base-derived)
    Class object. If the ``type`` is a list, this class will dispatch to the
    Sequence constructor.

    Args:
        type (basetype|[basetype, ...]): evaluates to a type object or a iterable of Class objects.
        
    Usage example::
        
        @Part
        def my_child(self):
            return DynamicType(type = Box if self.width > 2 else Cylinder,
                               ...)

        @Part
        def my_child(self):
            return DynamicType(type = [Box, Cylinder], # <-- becomes a sequence,
                                ...)"""

    __newargs__ = ["type"]

    def __new__(cls, **kwargs):
        if kwargs.pop("suppress", False):
            return Undefined
        type_ = kwargs.pop("type", Undefined)
        if type_ is Undefined:
            raise TypeError("DynamicType needs a 'type' keyword")
        elif hasattr(type_, "__iter__"):
            return Sequence(type=type_, **kwargs)
        else:
            return type_(**kwargs)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""See ParaPy documentation"""

import operator
import os
import sys
import warnings


from parapy.core.adapter import ValidatorAdapter
from parapy.core.exceptions import (
    ParaPyDeprecationWarning, ValidationError, ValidatorException)
from parapy.core.utilities import is_number as utils_is_number
from parapy.utilities import deprecated

__all__ = ("IsInstance", "AllIsInstance", "LT", "LessThan", "LE",
           "LessThanOrEqualTo", "GT", "GreaterThan", "GE",
           "GreaterThanOrEqualTo", "Range", "Between", "Positive", "Negative",
           "OneOf", "is_string", "is_number", "file_exists", "all_is_string",
           "all_is_number", "is_positive", "is_negative",
           "Optional", "And", "Or", "ValidationError", "Validator",
           # below: deprecated
           "Instance", "InstanceList", "ValidateBase", "Validate",
           "is_list_of_strings", "is_list_of_numbers"
           )


# --- ABSTRACT CLASSES ---
class ValidatorBase(object):
    __slots__ = ('msg',)

    def __init__(self, msg=None):
        """Abstract base class for validators. Typically created to
        validate values bound to an
        :class:`~parapy.core.abstractslot.AbstractSlot`. Prototype::

        slot1 = Input(2, validator=LT(3))

        @Input(validator=OneOf(["small", "large"]))
        def slot2(self):
            return "small"

        Subclasses implement :meth:`call` method, and can optionally override
        :meth:`__repr__` method for pretty printing.

        :param str | None msg: to override the built-in message of
            the validator it is possible to specify the message over here.
            Using the Python built-in format options, you will have access
            to several items:

            - ``value``: the value being validated
            - ``obj``: the object on which the slot lives that is being
                validated.
            - ``slot``: the slot that is validated by this validator
            - ``msg``: the built-in message
            - ``validator``: this validator

        """
        self.msg = msg

    def call(self, value, obj, slot):
        """Subclasses **HAVE** to implement this method.
        Argument ``value`` is the value to which the ``slot`` of owning
        ``obj`` will become bound. This method **should** return a boolean,
        where ``False`` represent failure.

        :rtype: bool
        """
        raise NotImplementedError()

    def __call__(self, value, obj, slot):
        """This method is called by :meth:`AbstractSlot.__get__` and
        :meth:`AbstractSlot.__set__` methods when, respectively, validating
        a value or when a value gets set. If the slot is told to validate it
        will pass on three values: ``value`` is the value to which the slot
        will become bound, ``obj`` is the owning
        :class:`~parapy.core.abstractbase.AbstractBase` instance and
        ``slot`` is the dispatching
        :class:`~parapy.core.abstractslot.AbstractSlot` instance.

        :param value: value to which owning ``slot`` is bound
        :param parapy.core.Base obj: instance whose ``slot`` value is bound
        :param parapy.core.abstractslot.AbstractSlot slot: owning slot
        :rtype: bool
        :raises ValidationError: if validation fails.
        """
        try:
            flag = self.call(value, obj, slot)
        except Exception as e:
            type_, value_, traceback = sys.exc_info()
            err = ValidatorException(value, obj, slot, self, exception=e)
            raise err.with_traceback(traceback)

        msg = None
        if hasattr(flag, "__iter__"):
            nb_args = len(flag)  # will not support generators
            if nb_args == 2:
                flag, msg = flag
            elif nb_args == 1:
                flag, = flag
            else:
                msg = "Validator return type is flag | (flag, msg), not: {!r}."
                raise ValidatorException(value, obj, slot, self, exception=msg)

        if not flag:  # validation failed
            msg = self._compose_msg(value, obj, slot, msg)
            raise ValidationError(value, obj, slot, self, message=msg)

        return True

    def _compose_msg(self, value, obj, slot, msg):
        custom_msg = self.msg
        msg = msg or ""  # empty string is better than 'None'
        if custom_msg:
            return custom_msg.format(value=value, obj=obj, slot=slot,
                                     msg=msg, validator=self)
        else:
            return msg

    def __repr__(self):
        """You can override this method in subclasses for pretty printing
        purposes. Returns a string(str). By default any instance will print
        <Type>.

        :rtype: str
        """
        return "<{name}>".format(name=type(self).__name__)


class Validator(ValidatorBase):
    """Abstract validator with ``key`` and ``None_allowed`` arguments."""
    __slots__ = "key", "None_allowed"

    def __init__(self, key=None, None_allowed=False, **kwargs):
        """
        :param key: a function of one argument that is used to extract value
            from ``value`` used for validation.
        :param bool None_allowed: is None also a valid value?
        """
        super(Validator, self).__init__(**kwargs)
        self.key = key
        if None_allowed:
            msg = "None_allowed has been deprecated, use Optional instead"
            warnings.warn(msg, ParaPyDeprecationWarning, stacklevel=2)
        self.None_allowed = None_allowed

    def __call__(self, value, obj, slot):
        key = self.key
        if key is not None:
            value = key(value)

        # early exit
        if value is None and self.None_allowed:
            return True

        return super(Validator, self).__call__(value, obj, slot)


class NumericComparison(Validator):
    """Abstract base class for validator that do numeric comparisons with
    respect to ``limit``.
    """
    __slots__ = "limit"

    OPERATOR_TO_REPR = {operator.lt: "<",
                        operator.le: "<=",
                        operator.gt: ">",
                        operator.ge: ">="}

    def __init__(self, limit, **kwargs):
        """
        :param limit: limit
        """
        super(NumericComparison, self).__init__(**kwargs)
        self.limit = limit

    @property
    def operator(self):
        raise NotImplementedError()

    def call(self, value, obj, slot):
        return utils_is_number(value) and self.operator(value, self.limit)

    def __repr__(self):
        return "<value {operator} {limit}>".format(
            operator=self.OPERATOR_TO_REPR[self.operator], limit=self.limit)


class NumericComparisonWithZero(NumericComparison):
    """Abstract base class for validator that do numeric comparisons with
    respect to ``0`` (i.e. *zero*).
    """
    __slots__ = "incl_zero"

    def __init__(self, incl_zero=False, **kwargs):
        """
        :param limit: limit
        """
        limit = 0
        super(NumericComparisonWithZero, self).__init__(limit, **kwargs)
        self.incl_zero = incl_zero


# --- CONCRETE CLASSES ---
class AdaptedValidator(ValidatorBase, ValidatorAdapter):
    """Adapts user-defined callable ``fn`` to the validator protocol. Usage:

    >>> def my_validator(value):
    ...    return value == 1
    >>> my_validator(1)
    True
    >>> validator = AdaptedValidator(my_validator)
    >>> # validator has (value, obj, slot) signature
    >>> from parapy.core import Base
    >>> dummy_obj = Base()
    >>> dummy_slot = Base.label
    >>> validator(1, dummy_obj, dummy_slot)
    True
    >>> validator(2, dummy_obj, dummy_slot)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 2.
    ...

    See :class:`ValidatorAdapter` for valid signatures for ``fn``.
    """
    __slots__ = "_fn", "_fn_adapted"

    def __init__(self, fn, _is_method=False, **kwargs):
        super(AdaptedValidator, self).__init__(**kwargs)
        self._fn = fn
        self._fn_adapted = self.wrap(fn, _is_method=_is_method)

    def call(self, value, obj, slot):
        return self._fn_adapted(value, obj, slot)

    def __repr__(self):
        return "<AdaptedValidator {}>".format(repr(self._fn))


class IsInstance(Validator):
    """Validate using ``isinstance``, but also allows 'self' to reference the
    owning class of slot validator. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import IsInstance
    ...
    >>> class Spam(Base):
    ...    a_float = Input(validator=IsInstance(float))
    ...    a_spam = Input(validator=IsInstance("self"))
    ... 
    >>> obj = Spam()
    >>> obj.a_float = 1.0
    >>> obj.a_spam = Spam()
    >>> obj.a_float = "wrong_type"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 'wrong_type'.
    ...
    >>> obj.a_spam = float   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: <type 'float'>.
    ...
    """
    __slots__ = "_typetuple", "_hasself"

    def __init__(self, class_or_type_or_self_or_tuple, **kwargs):
        super(IsInstance, self).__init__(**kwargs)
        self.typetuple = class_or_type_or_self_or_tuple

    @property
    def typetuple(self):
        return self._typetuple

    @typetuple.setter
    def typetuple(self, class_or_type_or_self_or_tuple):
        tuple_ = class_or_type_or_self_or_tuple
        if not isinstance(tuple_, tuple):
            tuple_ = tuple_,

        if not self._is_valid_typetuple(tuple_):
            msg = ("class_or_type_or_self_or_tuple must be a class, type, "
                   "'self' or tuple of these, not: {!r}.")
            raise TypeError(msg.format(class_or_type_or_self_or_tuple))

        self._typetuple = tuple_
        self._hasself = "self" in tuple_  # optimization for call

    def call(self, value, obj, slot):
        tup = self._latebind_typetuple(slot)
        return isinstance(value, tup)

    @staticmethod
    def _is_valid_typetuple(tuple_):
        return all(isinstance(v, type) or v == "self" for v in tuple_)

    def _latebind_typetuple(self, slot):
        """If 'self' in ``class_or_type_or_tuple``, we will late-bind  it here.
        """
        tup = self._typetuple
        if self._hasself:
            tup = tuple(slot._owner if v == "self" else v for v in tup)
        return tup

    def __repr__(self):
        return "<Instance(value, {})>".format(self._typetuple)


class AllIsInstance(IsInstance):
    """Like :class:`Instance`, but for iterables. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import AllIsInstance
    ...
    >>> class Spam(Base):
    ...    floats = Input(validator=AllIsInstance(float))
    ...    spams = Input(validator=AllIsInstance("self"))
    ... 
    >>> obj = Spam()
    >>> obj.floats = [1.0]
    >>> obj.spams = [Spam()]
    >>> obj.floats = ["wrong_type"]   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: ['wrong_type'].
    ...
    >>> obj.spams = [float]   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: [<type 'float'>].
    ...
    """

    def call(self, value, obj, slot):
        if not hasattr(value, "__iter__"):
            return False, "Value isn't iterable"
        tup = self._latebind_typetuple(slot)
        return all((isinstance(val, tup) for val in value))


class LT(NumericComparison):
    """Checks if :math:`value < c`.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import LT
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=LT(2))
    ...    bar = Input(validator=LT(2, key=len))
    ...
    >>> obj = Spam()
    >>> obj.foo = 1
    >>> obj.bar = "a"
    >>> obj.foo = 3   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 3.
    ...
    >>> obj.bar = "abc"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 3.
    ...

    .. note:: There's a synonym called ``LessThan``.
    """
    __slots__ = ()
    operator = operator.lt


LessThan = LT


class LE(LT):
    """Checks if :math:`value <= limit`.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import LE
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=LE(2))
    ...    bar = Input(validator=LE(2, key=len))
    ...
    >>> obj = Spam()
    >>> obj.foo = 2
    >>> obj.bar = "ab"
    >>> obj.foo = 3   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 3.
    ...
    >>> obj.bar = "abc"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 3.
    ...

    .. note:: There's a synonym called ``LessThanOrEqualTo``.
    """
    __slots__ = ()
    operator = operator.le


LessThanOrEqualTo = LE


class GT(NumericComparison):
    """Checks if :math:`value > limit`.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import GT
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=GT(2))
    ...    bar = Input(validator=GT(2, key=len))
    ...
    >>> obj = Spam()
    >>> obj.foo = 3
    >>> obj.bar = "abc"
    >>> obj.foo = 1   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...
    >>> obj.bar = "a"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...

    .. note:: There's a synonym called ``GreaterThan``.
    """
    __slots__ = ()
    operator = operator.gt


GreaterThan = GT


class GE(GT):
    """Checks if :math:`value >= limit`.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import GE
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=GE(2))
    ...    bar = Input(validator=GE(2, key=len))
    ...
    >>> obj = Spam()
    >>> obj.foo = 2
    >>> obj.bar = "ab"
    >>> obj.foo = 1   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...
    >>> obj.bar = "a"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...

    .. note:: There's a synonym called ``GreaterThanOrEqualTo``.
    """
    __slots__ = ()
    operator = operator.ge


GreaterThanOrEqualTo = GE


class Positive(NumericComparisonWithZero):
    """Checks if :math:`value > 0` or :math:`value >= 0` if ``incl_zero``.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import Positive
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=Positive())  # or `is_positive`
    ...    bar = Input(validator=Positive(incl_zero=True))
    ...
    >>> obj = Spam()
    >>> obj.foo = 1
    >>> obj.bar = 0
    >>> obj.foo = 0   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 0.
    ...
    >>> obj.bar = -1   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: -1.
    ...

    .. note:: ``is_positive`` is recommended when :attr:`incl_zero` is False.
    """
    __slots__ = ()

    @property
    def operator(self):
        return operator.ge if self.incl_zero else operator.gt


class Negative(NumericComparisonWithZero):
    """Checks if :math:`value < 0` or :math:`value <= 0` if ``incl_zero``.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import Negative
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=Negative())  # or `is_negative`
    ...    bar = Input(validator=Negative(incl_zero=True))
    ...
    >>> obj = Spam()
    >>> obj.foo = -1
    >>> obj.bar = 0
    >>> obj.foo = 0   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 0.
    ...
    >>> obj.bar = 1   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...

    .. note:: ``is_negative`` is recommended when :attr:`incl_zero` is False.
    """
    __slots__ = ()

    @property
    def operator(self):
        return operator.le if self.incl_zero else operator.lt


class Between(Validator):
    """Checks if :math:`limit1 < value < limit2`.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import Between
    ...
    >>> class Spam(Base):
    ...    foo = Input(validator=Between(1, 3))
    ...
    >>> obj = Spam()
    >>> obj.foo = 2
    >>> obj.foo = 0   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 0.
    ...
    >>> obj.foo = 1   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.
    ...
    """
    __slots__ = "limit1", "limit2"
    operator1 = operator.lt
    operator2 = operator.lt

    def __init__(self, limit1, limit2, **kwargs):
        """

        :param float limit1: lower limit
        :param float limit2: upper limit
        :param kwargs: extra arguments for :class:`Validator`
        """
        super(Between, self).__init__(**kwargs)
        self.limit1 = limit1
        self.limit2 = limit2

    def call(self, value, obj, slot):
        return (utils_is_number(value) and
                self.operator1(self.limit1, value) and
                self.operator2(value, self.limit2))

    def __repr__(self):
        to_repr = NumericComparison.OPERATOR_TO_REPR
        return "<{limit1} {operator1} value {operator2} {limit2}>".format(
            operator1=to_repr[self.operator1],
            operator2=to_repr[self.operator2],
            limit1=self.limit1, limit2=self.limit2)


class Range(Between):
    """Checks if :math:`limit1 <= value <= limit2` By default, operator used
    for comparison is *less than or equal*, but both operator can be toggled
    to :math:`<` with ``incl_min`` and ``incl_max``.

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import Range
    ...
    >>> class Spam(Base):
    ...     # Valid value in interval [1, 5]
    ...     foo = Input(validator=Range(1, 5))
    ...     # Valid value in interval <1, 5]
    ...     bar = Input(validator=Range(1, 5, incl_min=False))
    ...     # Valid value in interval [1, 5>
    ...     qux = Input(validator=Range(1, 5, incl_max=False))
    ...
    >>> obj = Spam()
    >>> # valid values
    >>> obj.foo = 1.0; obj.foo = 3.0; obj.foo = 5.0
    >>> obj.bar = 1.1; obj.bar = 3.0; obj.bar = 5.0
    >>> obj.qux = 1.1; obj.qux = 3.0; obj.qux = 4.9
    >>> # invalid values
    >>> obj.foo = 0.5   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 0.5.
    ...
    >>> obj.bar = 1.0   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 1.0.
    ...
    >>> obj.qux = 5.0   # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValidationError: 5.0.
    ...
    """

    __slots__ = "incl_min", "incl_max"

    def __init__(self, limit1, limit2, incl_min=True, incl_max=True, **kwargs):
        super(Range, self).__init__(limit1, limit2, **kwargs)
        self.incl_min = incl_min
        self.incl_max = incl_max

    @property
    def operator1(self):
        return operator.le if self.incl_min else operator.lt

    @property
    def operator2(self):
        return operator.le if self.incl_max else operator.lt


class OneOf(Validator):
    """Checks if value is in ``options``. Options may be static sequence,
    or callback of the form ``(obj: AbstractBase) -> collections.Iterable``.

    >>> from parapy.core import Base, Input, Attribute
    >>> from parapy.core.validate import OneOf
    ...
    >>> class Spam(Base):
    ...     # static options
    ...     foo = Input(validator=OneOf(("titanium", "aluminium")))
    ...     # via callback
    ...     bar = Input(validator=OneOf(lambda self: self.options))
    ... 
    ...     heavy = Input(False)
    ... 
    ...     @Attribute
    ...     def options(self):
    ...         if self.heavy:
    ...             return "steel", "wood"
    ...         else:
    ...             return "titanium", "aluminium"
    ... 
    >>> obj = Spam()
    >>> # valid values
    >>> obj.foo = "titanium"; obj.foo = "aluminium"
    >>> obj.bar = "titanium"; obj.bar = "aluminium"
    >>> obj.heavy = True
    >>> # invalid values
    >>> obj.foo = "plastic"   # doctest: +ELLIPSIS
    Traceback (most recent call last):
            ...
    ValidationError: 'plastic'.
    ...
    """
    __slots__ = "_options", "_latebound"

    def __init__(self, options, **kwargs):
        """
        :param options: an iterable creating options or callback of the form
            ``(obj: AbstractBase) -> collections.Iterable``.
        :type: collections.Iterable | (parapy.core.base.Base) -> collections.Iterable
        """
        super(OneOf, self).__init__(**kwargs)
        self.options = options

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, value):
        is_callable = callable(value)

        # optimize lookup performance
        if not is_callable and not isinstance(value, set):
            try:
                value = frozenset(value)
            except TypeError:
                pass  # unhashable type

        self._options = value
        self._latebound = is_callable

    def call(self, value, obj, slot):
        options = self.get_options(obj)
        return value in options

    def get_options(self, obj=None):
        if self._latebound:
            if obj is None:
                raise RuntimeError("supply obj")
            else:
                return self.options(obj)
        else:
            return self.options

    def __repr__(self):
        if self._latebound:
            options = "instance-bound"
        else:
            options = self.options
        return "<OneOf: {:}>".format(options)


def adapt(validator):
    if isinstance(validator, ValidatorBase):
        return validator
    else:
        return AdaptedValidator(validator)


class Optional(ValidatorBase):
    """Wrap ``validator`` to also allow None as value. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import is_positive, Optional
    ...
    >>> class Spam(Base):
    ...     foo = Input(validator=Optional(is_positive))
    ...
    >>> obj = Spam()
    >>> # valid options
    >>> obj.foo = 1; obj.foo = None
    >>> # invalid options
    >>> obj.foo = -1  # doctest: +ELLIPSIS
    Traceback (most recent call last):
            ...
    ValidationError: -1.
    ...
    """
    __slots__ = "validator"

    def __init__(self, validator, **kwargs):
        super(Optional, self).__init__(**kwargs)
        self.validator = adapt(validator)

    def __call__(self, value, obj, slot):
        if value is None:
            return True
        try:
            return self.validator(value, obj, slot)
        except ValidationError as e:
            if self.msg:
                msg = self._compose_msg(value, obj, slot, e.message)
                raise ValidationError(value, obj, slot, self, message=msg)
            else:
                raise

    def __repr__(self):
        return "<{name} {validator}>".format(name=type(self).__name__,
                                             validator=self.validator)


class _AndOr(ValidatorBase):
    __slots__ = "validators"

    def __init__(self, *validators, **kwargs):
        super(_AndOr, self).__init__(**kwargs)
        self.validators = list(map(adapt, validators))

    def __repr__(self):
        return "<{name} {validators}>".format(name=type(self).__name__,
                                              validators=self.validators)


class And(_AndOr):
    """Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import is_positive, And, OneOf
    ...
    >>> class Spam(Base):
    ...     foo = Input(validator=And(is_positive, OneOf([-1, 1])))
    ...
    >>> obj = Spam()
    >>> # valid options
    >>> obj.foo = 1
    >>> # invalid options
    >>> obj.foo = -1  # doctest: +ELLIPSIS
    Traceback (most recent call last):
            ...
    ValidationError: -1.
    ...
    """
    def __call__(self, value, obj, slot):
        try:
            return all(val(value, obj, slot) for val in self.validators)
        except ValidationError as e:
            if self.msg:
                msg = self._compose_msg(value, obj, slot, e.message)
                raise ValidationError(value, obj, slot, self, message=msg)
            else:
                raise


class Or(_AndOr):
    """Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.validate import is_positive, Or, OneOf
    ...
    >>> class Spam(Base):
    ...     foo = Input(validator=Or(OneOf([-1, -2]), is_positive))
    ...
    >>> obj = Spam()
    >>> # valid options
    >>> obj.foo = -1; obj.foo = -2; obj.foo = 1
    >>> # invalid options
    >>> obj.foo = 0  # doctest: +ELLIPSIS
    Traceback (most recent call last):
            ...
    ValidationError: 0.
    ...
    """
    def __call__(self, value, obj, slot):
        for val in self.validators:
            try:
                flag = val(value, obj, slot)
            except ValidationError as e:
                flag = False

            if flag:
                return True

        # we only get here if all validators failed
        msg = self._compose_msg(value, obj, slot, "All validators failed")
        raise ValidationError(value, obj, slot, self, message=msg)


# ---- ready-to-use validator functions ----
# TODO (RVD): use parapy.core.utilities.is_string as utils_is_string
def _utils_is_string(value):
    return isinstance(value, str)


@AdaptedValidator
def is_string(value, obj, slot):
    """Validate that ``value`` is str (``basestring`` in Py2). Usage:

    >>> spam = Input(validator=is_string)
    """
    return _utils_is_string(value)


@AdaptedValidator
def is_number(value, obj, slot):  # keep unused args obj, slot!
    """Validate that ``value`` is int, float or long. Usage:

    >>> spam = Input(validator=is_number)
    """
    return utils_is_number(value)


@AdaptedValidator
def all_is_string(value, obj, slot):  # keep unused args obj, slot!
    """Validate that ``value`` is an iterable of strings. True on empty list.
    Usage:

    >>> spam = Input(validator=all_is_string)
    """
    return hasattr(value, "__iter__") and all(map(_utils_is_string, value))


@AdaptedValidator
def all_is_number(value, obj, slot):  # keep unused args obj, slot!
    """Validate that ``value`` is an iterable of numbers. True on empty list.
    Usage:

    >>> spam = Input(validator=all_is_number)
    """
    return hasattr(value, "__iter__") and all(map(utils_is_number, value))


@AdaptedValidator
def file_exists(value, obj, slot):  # keep unused args obj, slot!
    """Validate that pathname ``value`` exists. Usage:

    >>> spam = Input(validator=file_exists)
    """
    return os.path.isfile(value)


#: usage: ``bar = Input(validator=is_positive)``
is_positive = Positive()
#: usage: ``bar = Input(validator=is_negative)``
is_negative = Negative()


# --- deprecated functionality ---
@deprecated(base_is_alias=True)
class Instance(IsInstance):
    pass


@deprecated(base_is_alias=True)
class InstanceList(AllIsInstance):
    pass


@deprecated(replaced_by=all_is_string)
def is_list_of_strings(*args, **kwargs):
    return all_is_string(*args, **kwargs)


@deprecated(replaced_by=all_is_number)
def is_list_of_numbers(*args, **kwargs):
    return all_is_number(*args, **kwargs)


@deprecated(base_is_alias=True)
class ValidateBase(Validator):
    pass


@deprecated(base_is_alias=True)
class Validate(AdaptedValidator):
    pass


if __name__ == '__main__':
    from parapy.core import Base, Attribute

    def assert_raises(callableObj, *args, **kwargs):
        try:
            callableObj(*args, **kwargs)
        except:
            pass
        else:
            assert False, "Exception not raised"

    slot = Attribute()
    slot.__name__ = "dummyslot"
    obj = Base()
    validator = OneOf([1, 2])
    # print validator(3, obj, slot)

    # validator with message
    def my_validator(v):
        return False, "this is wrong"

    validator = AdaptedValidator(my_validator)
    # will raise ValidationError
    assert_raises(validator, 3, obj, slot)

    # failing validator
    def my_validator(v):
        1 / 0

    validator = AdaptedValidator(my_validator)
    print(validator(3, obj, slot))


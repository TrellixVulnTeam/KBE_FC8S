#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This file defines the slot types and the decorators to create them. The
core slot types are Input, Attribute and Part. In addition,
some "semantical" decorators are defined as well.

Each of the slot classes has a corresponding slot decorator, which is simply a rename
from the CamelCase class name convention to the underscored_name decorator name convention.

To use a slot type or decorator with its normal settings, use the decorator syntax::

    slot_name = Input(...[,option=value]*)

    @Input
    def slot_name(self):
        ...

To use the options some slot types have available, use::

    @Input(option=value, ...)
    def slot_name(self):
        ...
"""

import warnings

from parapy.core.globs import Undefined
from parapy.core.exceptions import (MissingRequiredInput,
                                    ParaPyDeprecationWarning)
from parapy.core.abstractslot import AbstractSlot
from parapy.core.dependencies import CHILD_QUEUE


class Input(AbstractSlot):
    """An input slot. It can have a default or derived expression. Without a
    default, it is a required input slot. This slot has a unique mechanism
    to retrieve its value, because it might come from parent / ancestor
    objects (inter-class) instead of intra-class like attributes.
    
    The supported ways to use this descriptor are::
    
        class MyClass(Base):
            
            # Required input slot
            my_slot = Input()
            
            # Alternative: Required input slot
            my_slot = Input(Undefined)
            
            # Required input slot with documentation
            my_slot = Input(doc="The docs.")

            # Alternative: Required input slot with documentation
            my_slot = Input(Undefined, "The docs.")     
            
            # with default
            my_slot = Input(5)
            
            # with default and documentation
            my_slot = Input(5, "The docs")
            
            # Settable slot with function as default value and documentation
            @Input
            def my_slot(self):
                \"\"\"docstring\"\"\"
                return self.width * 2
    """
    
    __slots__ = ["is_required", "defaulting", "fn_proxy"]

    #: enables fast check from basetype. One of
    #: ["abstract", "input", "attribute", "part"]
    #: :type: str
    __ppmembername__ = "input"

    def __init__(self, default=Undefined, doc=None, defaulting=False,
                 settable=True, **kwargs):
        """This method overrides the default behavior inherited from
        :meth:`AbstractSlot.__init__`, to set ``default=Undefined`` and add
        defaulting.

        :param default: the default value for the input, typically a simple
            data type, but there are two other options:

            - Undefined: Means this is a required Input, the default value for
                default :)
            - derived: Means this slot is optional and derived from other
                slots. Parapy expects a "def _get_<name>(self): ..." somewhere
                else.
        :param defaulting: is this a defaulting slot? If yes, it may look-up
            its value from a slot up the ancestor tree. If value is True, the
            slot name to search for is this slot's name. If value is a str,
            that name is used.
        :type defaulting: bool | str
        :param kwargs: see :meth:`AbstractSlot.__init__`.
        """
        AbstractSlot.__init__(self, default, doc=doc, settable=settable,
                              **kwargs)
        self.is_required = default is Undefined and not defaulting
        self.defaulting = defaulting
        # TODO (TBD): explain fn_proxy use somewhere
        self.fn_proxy = None

    def __call__(self, function):
        self.is_required = False
        return super(Input, self).__call__(function)

    def evaluate(self, obj):
        """This method overrides the default behavior inherited from
        :py:meth:`AbstractSlot.evaluate`, because for Input there are two special cases to check:
        
        - the parent object defines a child method that overwrites the method wrapped by this slot
        - this Input slot is 'defaulting', in which case the ancestor tree is traced up for values

        The strategy to find the correct decorator is as follows:
        
        1. check if ``obj.parent``, else --> CONTINUE 5,
        2. check parent's defining Part slot for ``child_rules``,
            a. if present, evaluate in parent context --> RETURN
            b. else --> CONTINUE 3
        3. if this slot is defaulting check all the ancestor tree recursively for similar named
           class attributes, else --> CONTINUE 4
            a. if present, evaluate in ancestor context --> RETURN
            b. else, --> CONTINUE 5
        4. if this slot is required, trace any trickled down slots as a last resort, 
           else --> CONTINUE 5 (which will throw a MissingRequiredSlot error)
           a. if present, evaluated in ancestor context --> RETURN
           b. else, --> CONTINUE 5
        5. evaluate this slot's own function --> RETURN

        Args:
            obj (Base): Base instance"""

        # TODO (TBD): consider overriding AbstractSlot.__get__ and putting
        # /todo this code in there.
        # TODO (TBD): logging

        parent = direct_parent = obj._parent

        if parent:
            # route 1
            name = self.__name__
            # assumes that we were defined in a slot
            parent_fn = obj._slot.child_rules.get(name, None)

            if parent_fn:
                # route 2a
                # FIXME (TBD): remove this, no longer supported.
                if parent_fn.__code__.co_argcount == 2:
                    # function needs to be implicitly called.
                    value = parent_fn(parent, obj)
                else:
                    CHILD_QUEUE.append(obj)
                    try:
                        value = parent_fn(parent)
                    finally:
                        CHILD_QUEUE.pop()

                # if user-specified value is Undefined, it means use
                # your own default
                if value is Undefined:
                    return self.fn(obj)
                else:
                    return value

            key = self.defaulting
            if key:
                # name = Input(defaulting=True) or
                # name = Input(defaulting="other_name")
                if key is True:
                    key = name
                # route 3
                while parent:
                    # slightly faster than try ... except block
                    slot = parent._slots.get(key, None)
                    if slot:
                        # route 3a
                        return slot.__get__(parent)
                    else:
                        parent = parent._parent

            elif self.is_required:  # route 4: trickled down slot last resort
                parent = direct_parent  # reset
                depth = 1
                while parent:
                    # slightly faster than try ... except block
                    slot = parent._trickle_downs.get(name, None)
                    if slot and slot.trickle_down_depth >= depth:
                        # route 4a
                        return slot.__get__(parent)
                    else:
                        parent = parent._parent
                        depth += 1

        # route 5: evaluate your own value
        return self.fn(obj)

    @property
    def default(self):
        """If default value is simple data type (so no callable), this
        attribute will hold that value. Otherwise returns Undefined.
        """
        return self._default

    @default.setter
    def default(self, value):
        if value is Undefined:
            # IMPORTANT: descriptor may not have a name yet.
            # TODO (TBD): location should take user to original definition.
            def missing(obj):
                raise MissingRequiredInput(obj, self.__name__)
            self.fn = missing
        else:
            # FIXME (TBD): get rid of this wrapping stuff
            self.fn = lambda obj: value

        self._default = value
        self.is_derived = False


# TODO (TBD): remove after 1.0.8.
class TInput(Input):
    """Input that shows in Tree. Shorthand for ``Input(in_tree=True)``"""

    __slots__ = []

    def __init__(self, default=Undefined, doc=None, defaulting=False,
                 **kwargs):
        msg = "TInput has been deprecated. Use Input(in_tree=True) instead."
        warnings.warn(msg, ParaPyDeprecationWarning)
        kwargs.pop("in_tree", None)
        Input.__init__(self, default=default, doc=doc, defaulting=defaulting,
                       in_tree=True, **kwargs)

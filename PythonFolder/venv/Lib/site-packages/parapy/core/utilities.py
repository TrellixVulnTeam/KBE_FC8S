#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import collections
import datetime
import decimal
import importlib
import inspect
import itertools
import os
import re
import sys
import types
import typing
import warnings
from functools import reduce
from math import ceil
from numbers import Number
from operator import attrgetter, getitem
from sys import stdout
from time import time

from parapy.core.exceptions import (
    AttributeErrorDescr, ParaPyDeprecationWarning)
from parapy.core.globs import CONFIGURATION, Undefined, X11_COLORS

__all__ = ['all_map', 'any_map', 'by_groups', 'by_pairs', 'by_triples',
           'datetime_string', 'delslot', 'descriptor_getattr', 'drange',
           'duration', 'ensure_iterable', 'ensure_list', 'ensure_tuple',
           'flatten', 'frange', 'full_path', 'get_classes', 'getattrs',
           'getslot', 'groupwise', 'iflatten', 'is_iterable', 'is_number',
           'is_real_number', 'is_string', 'lazy_hasattr', 'list_duplicates',
           'list_of_numbers', 'move_atomic', 'pairwise', 'precedents_tracking',
           'setattrs', 'setslot', 'slotgetter', 'triplewise', 'type_hasattr',
           'is_color', "commonprefix", "parse_refchain", "unparse_refchain",
           "all_equal", "walk_refchain", "relative_refchain",
           "try_issubclass", "apply_to_all", "is_unbound_method"]


def by_groups(iterable, n, fillvalue=Undefined):
    """Collect data into fixed-length chunks or blocks::

        by_groups('ABCDEFG', 3, 'x') --> ABC DEF Gxx
    
    Adapted from https://docs.python.org/2/library/itertools.html#recipes"""
    args = [iter(iterable)] * n
    if fillvalue is Undefined:
        return zip(*args)
    else:
        return itertools.zip_longest(fillvalue=fillvalue, *args)


def by_pairs(iterable, fillvalue=None):
    """s -> (s0,s1), (s2,s3), (s4, s5), ..."""
    return by_groups(iterable, 2, fillvalue)


def by_triples(iterable, fillvalue=None):
    """s -> (s0,s1,s2), (s3,s4,s5), (s6,s7,s8), ..."""
    return by_groups(iterable, 3, fillvalue)


def groupwise(iterable, n):
    """Collect data into fixed-length chunks or blocks::
    
        groupwise('ABCDEFG', 3) --> ABC BCD CDE DEF EFG

    Adapted from https://docs.python.org/2/library/itertools.html#recipes"""
    args = itertools.tee(iterable, n)
    for i in range(1, n):
        it = args[i]
        for _ in range(i):
            next(it, None)
    return zip(*args)


def pairwise(iterable):
    """s -> (s0,s1), (s1,s2), (s2, s3), ..."""
    return groupwise(iterable, 2)


def triplewise(iterable):
    """s -> (s0,s1,s2), (s1,s2,s3), (s2,s3,s4), ..."""
    return groupwise(iterable, 3)


def list_of_numbers(start, end, nb, end_point=Undefined, include_end=True):
    """Return list of ``nb`` numbers evenly spaced over interval
    ``start`` - ``end``. If ``include_end=True`` (default), ``end`` is the last
    member of returned list (and exact). Otherwise, it will be excluded from
    the result.

    >>> list_of_numbers(1, 2, 3)
    [1, 1.5, 2]
    >>> list_of_numbers(1, 2, 3, include_end=False)
    [1, 1.3333333333333333, 1.6666666666666665]

    :param float start: first number of range
    :param float end: last number of range
    :param int nb: length of list.
    :param bool include_end: include ``end``?

    .. caution:: ``end_point`` has been deprecated since 1.2
    """
    if end_point is not Undefined:
        msg = ("list_of_numbers 'end_point' keyword has been deprecated, use "
               "'include_end' instead.")
        warnings.warn(msg, ParaPyDeprecationWarning)
        include_end = end_point
    if nb == 1:
        return [start]
    if include_end:
        step = (end - start) / (nb - 1)
        lst = list(_list_of_numbers_generator(start, step, nb - 1))
        lst.append(end)
        return lst
    else:
        step = (end - start) / nb
        return list(_list_of_numbers_generator(start, step, nb))


def _list_of_numbers_generator(start, step, num):
    yield start
    for x in range(1, num):
        yield start + x * step


def frange(start, stop=None, step=1):
    """frange generates a set of floating point values over the 
    range [start, stop) with step size step::

        frange([start,] stop [, step ])
    
    Excludes the last item typically!!!
    Adapted from: http://code.activestate.com/recipes/66472/"""
    if stop is None:
        for x in range(int(ceil(start))):
            yield x
    else:
        # create a generator expression for the index values
        indices = (i for i in range(0, int((stop - start) / step)))
        # yield results
        for i in indices:
            yield start + step * i


def drange(start, stop=None, step=1, precision=None):
    """drange generates a set of Decimal values over the
    range [start, stop) with step size step::

        drange([start,] stop, [step [,precision]])
        
    The use of decimals (over floats) avoid the roundoff drift introduced by the floating point arithmetic.
    Excludes the last item typically!!!
    """

    if stop is None:
        for x in range(int(ceil(start))):
            yield x
    else:
        # find precision
        if precision is not None:
            decimal.getcontext().prec = precision
        # convert values to decimals
        start = decimal.Decimal(start)
        stop = decimal.Decimal(stop)
        step = decimal.Decimal(step)
        num = ((stop - start) / step).to_integral_value()
        # yield results
        for i in range(0, num + 1):
            yield float(start + step * i)


def full_path(path):
    r"""Function to get a full pathname that also works in interactive python mode in PyDev.
    Problem is interactive console in PyDev loads something like "C:\Program Files (x86)\eclipse"
    as default directory, hence your relative path definition will not work.

    Issue: http://stackoverflow.com/questions/13997877/set-default-directory-of-pydev-interactive-console
    
    Args:
        path (str)
    
    Returns:
        pathname
    
    Calling this inside a file at "C:\temp\my_file.py":
    >>>full_path("input.txt")
    C:\temp\my_file.py\input.txt
    >>>full_path("\output\input.txt")
    C:\temp\my_file.py\output\input.txt"""

    filename = inspect.getframeinfo(inspect.getouterframes(inspect.currentframe())[1][0]).filename
    curpath = os.path.dirname(os.path.abspath(filename))
    return os.path.join(curpath, path)


def is_iterable(obj):
    """Check if iterable and not of type str|unicode.
    
    Returns:
        bool"""
    return isinstance(obj, typing.Iterable) and not isinstance(obj, str)


def is_number(obj):
    """Check if ``obj`` is a number (including complex numbers).

    :param T obj: any object
    :rtype: bool
    """
    return isinstance(obj, Number)


def is_string(obj):
    # TODO (PP): change in case of Py3
    return isinstance(obj, str)


def is_real_number(obj):
    """Check if ``obj`` is a real (in the meaning of not-complex) number.

    :param T obj: any object
    :rtype: bool
    """
    return isinstance(obj, (int, float))


def ensure_iterable(obj, default_type=list):
    """Args:
        obj (anything): potential iterable
        default_type (type): function that can be called to convert default_type([iterable])

    :rtype: typing.Iterable"""
    return obj if is_iterable(obj) else default_type([obj])


def ensure_list(obj):
    """:rtype: list"""
    if is_iterable(obj):
        if isinstance(obj, list):
            return obj
        else:
            return list(obj)
    else:
        return [obj]


def ensure_tuple(obj):
    """:rtype: tuple"""
    if is_iterable(obj):
        if isinstance(obj, tuple):
            return obj
        else:
            return tuple(obj)
    else:
        return (obj,)


def flatten(iterable, return_type=list, is_atomic=is_string):
    """Like :func:`iflatten`, but returns a list (by default). Specify
    ``return_type`` to change return type (e.g. ``tuple``).

    >>> # common case
    >>> seq = [1, [2, (3, 4)], "bar"]
    >>> flatten(seq)
    [1, 2, 3, 4, 'bar']
    >>> flatten(seq, return_type=tuple)
    (1, 2, 3, 4, 'bar')

    >>> # let's treat tuple also as atomic
    >>> def my_is_atomic(obj):
    ...     return is_string(obj) or isinstance(obj, tuple)
    >>> flatten(seq, is_atomic=my_is_atomic)
    [1, 2, (3, 4), 'bar']

    >>> # let's treat strings as iterable taking caution of single characters
    >>> # (also string) to avoid infinite recursion
    >>> def my_is_atomic(obj):
    ...     # Py3: basestring can be simply str
    ...     return isinstance(obj, str) and len(obj) == 1
    >>> flatten(seq, is_atomic=my_is_atomic)
    [1, 2, 3, 4, 'b', 'a', 'r']

    :param typing.Iterable iterable: object to recurse
    :param return_type: callable that takes result of :func:`iflatten``,
        ``list`` by default.
    :param typing.Callable is_atomic: predicate (obj) -> bool.
    """
    return return_type(iflatten(iterable, is_atomic=is_atomic))


def iflatten(iterable, is_atomic=is_string):
    """Flatten a potentially nested ``iterable``. All members that are
    *iterable* (in the broadest possible sense) are recursed over unless
    ``is_atomic(obj) -> True``. By default, strings are seen as atomic
    (:func:`is_string`).

    >>> # common case
    >>> seq = [1, [2, (3, 4)], "bar"]
    >>> list(iflatten(seq))
    [1, 2, 3, 4, 'bar']

    >>> # let's treat tuple also as atomic
    >>> def my_is_atomic(obj):
    ...     return is_string(obj) or isinstance(obj, tuple)
    >>> list(iflatten(seq, is_atomic=my_is_atomic))
    [1, 2, (3, 4), 'bar']

    >>> # let's treat strings as iterable taking caution of single characters
    >>> # (also string) to avoid infinite recursion
    >>> def my_is_atomic(obj):
    ...     # Py3: basestring can be simply str
    ...     return isinstance(obj, str) and len(obj) == 1
    >>> list(iflatten(seq, is_atomic=my_is_atomic))
    [1, 2, 3, 4, 'b', 'a', 'r']

    :param typing.Iterable iterable: object to recurse
    :param typing.Callable is_atomic: predicate (obj) -> bool.
    """
    for obj in iterable:
        if _is_iterable(obj) and not is_atomic(obj):
            for sub in iflatten(obj, is_atomic=is_atomic):
                yield sub
        else:
            yield obj


def _is_iterable(obj):
    """Usage:

    >>> _is_iterable([1, 2, 3])
    True
    >>> _is_iterable("bar")
    True
    >>> _is_iterable(1)
    False
    >>> # cornercase that goes undetected by typing.Iterable
    >>> class Foo(object):
    ...     def __getitem__(self, item):
    ...         return 1
    >>> import collections
    >>> obj = Foo()
    >>> isinstance(obj, typing.Iterable)
    False
    >>> _is_iterable(obj)
    True
    """
    try:
        iter(obj)
    except TypeError:
        return False
    else:
        return True


def isearch(seq, cond):
    """Return an iterator that searches for elements in a possibly nested
    ``seq`` satisfying ``cond``.

    Usage:

    >>> def not_iterable(obj):
    ...     return not hasattr(obj, '__iter__')
    >>> list(isearch([1, [2, 3.1, [4.2], 5]], cond=not_iterable))
    [1, 2, 3.1, 4.2, 5]
    >>> def is_float(obj):
    ...     return isinstance(obj, float)
    >>> list(isearch([1, [2, 3.1, [4.2], 5]], cond=is_float))
    [3.1, 4.2]
    >>> list(isearch(1.1, cond=is_float))
    [1.1]

    :param typing.Iterable[T] seq:
    :param (T) -> bool cond: A callable/function that given a Python Object
        decides if it is an element that is sought.
    :rtype: typing.Iterator[T]
    """
    msg = ("isearch has been deprecated, use 'iflatten' in combination with "
           "itertools.ifilter instead.")
    warnings.warn(msg, ParaPyDeprecationWarning)
    if cond(seq):
        yield seq
    elif hasattr(seq, '__iter__'):
        for value in seq:
            for v in isearch(value, cond):
                yield v


def list_duplicates(sequence):
    """
    Utility to find duplicates in a sequence. Returns a list of elements. An empty list is returned
    when there are not duplicates.
        
    >>> list_duplicates([1, 2, 3])
    []
    >>> list_duplicates([3, 1, 2, 1, 3])
    [1, 3]
    >>> list_duplicates("abacadabra")
    ['a', 'b']"""  
    return [x for x, y in list(collections.Counter(sequence).items()) if y > 1]


def getattrs(sequence, name):
    """List if same attribute values, for a sequence of objects. Name can be "." separated
    reference chain."""
    f = attrgetter(name)
    return [f(obj) for obj in sequence]


def setattrs(sequence, attr, values):
    """List if same attribute values, for a sequence of objects"""
    [setattr(obj, attr, value) for obj, value in zip(sequence, values)]


def type_hasattr(obj, attr):
    """Return if the type of ``obj`` has an attribute that goes by ``attr``.

    :param T obj:
    :param str attr:
    :rtype: bool
    """
    return hasattr(type(obj), attr)


def lazy_hasattr(obj, attr):
    """Checks if ``obj`` has an ``attr``. Will only cause
    evaluation if an attribute ``attr`` is made available through
    ``__getattribute__`` or ``__getattr__``.

    It functions like ``hasattr``, but tries not to evaluate any descriptors.

    .. caution:: Will give a false positive in the case where ``__getattr__``
        'un-inherits' an attribute ``attr``: it is
        present in the class itself, or in a super-class, but
        a custom version of ``__getattr__`` raises AttributeError.

    :param T obj:
    :param str attr:
    :rtype: bool
    """
    if type_hasattr(obj, attr):
        return True  # it is on the class. no instance-evaluation caused
    else:
        # It is not defined in the class, so it is either in the instance
        # dict, or made available through __getattribute__. In
        # the first case AttributeError is legit, in the second case it is
        # impossible to tell, so let's call it legit. This is how hasattr
        # behaves.
        return hasattr(obj, attr)


def descriptor_getattr(obj, attr):
    """Tries to get ``attr`` on ``obj``, will only throw an
    :class:`AttributeError` when ``obj`` does not have ``attr``.
    Other AttributeErrors are re-cast to :class:`AttributeErrorDescr`.

    >>> class Bob(object):
    ...     quz = 4
    ...     @property
    ...     def foo(self):
    ...         raise AttributeError("bar")
    >>> b = Bob()
    >>> descriptor_getattr(b, 'quz')
    4
    >>> try:
    ...     _ = descriptor_getattr(b, 'foo')
    ... except AttributeErrorDescr as e:
    ...     print("b has attribute 'foo'")
    ... except AttributeError:
    ...     print("b does not have attribute 'foo'")
    b has attribute 'foo'
    >>> try:
    ...     _ = descriptor_getattr(b, 'bar')
    ... except AttributeErrorDescr:
    ...     print("b has attribute 'bar'")
    ... except AttributeError:
    ...     print("b does not have attribute 'bar'")
    b does not have attribute 'bar'

    :param T obj:
    :param str name:
    :rtype: bool
    :raise AttributeErrorDescr: if ``obj`` has an attribute ``attr``,
        but evaluation of this attribute raises :class:`AttributeError`.
    """
    try:
        return getattr(obj, attr)
    except AttributeError:
        if type_hasattr(obj, attr):
            value, traceback = sys.exc_info()[1:]
            raise AttributeErrorDescr(value).with_traceback(traceback)
        else:
            raise


class precedents_tracking(object):
    """Wrap your code with a depencies_tracking context object. The context will set 
    ``configuration.precedents_tracking = True`` and run whatever you want. On exit, it will
    reset ``configuration.precedents_tracking`` to its original value. This context is useful if
    you want to ask slots for their precedents, normally not kept track of.
    
    Example::
    
        class MyClass(Base):
            
            a = Input(1)
            
            @Attribute
            def b(self):
                return 2 * self.a
                
    >>> self = MyClass()
    >>> self.get_dependencies_tree('b')
    [<Cache b>]
    
    >>> with precedents_tracking():
            self = MyClass()
            self.get_dependencies_tree('b')
    [<Cache b>, [<Cache a>]]
    """
    
    __slots__ = ['track', 'old_value']
    
    def __init__(self, track=True):
        self.track = track
    
    def __enter__(self):
        self.old_value = CONFIGURATION["precedents_tracking"]
        CONFIGURATION["precedents_tracking"] = self.track

    def __exit__(self, type, value, traceback):
        CONFIGURATION["precedents_tracking"] = self.old_value


class duration(object):
    """Wrap your code with a duration context. This context will evaluate your code and print the
    time elapsed.
    
    Args:
        message (str): string that will prefix the time string output message
        stream (stream): a stream to write to, default ``stdout``.
    
    Example:
    
    >>> with duration("My test took: "):
            for _ in xrange(100000):
                assert 1 + 1 == 2
    My test took: 0.00799989700317s"""
    
    def __init__(self, message="", stream=stdout):
        self.message = message
        self.stream = stream
    
    def __enter__(self):
        self.start = time()
        
    def __exit__(self, type, value, traceback):
        end = time()
        self.stream.write(self.message + str(end - self.start) + 's\n')


class MemoryProfiling():
    """Context manager that keeps track of Python memory consumption

    >>> with MemoryProfiling():
    ...     for _ in range(100):
    ...         1 + 1
    2
    """

    def __init__(self):
        try:
            import psutil
        except ImportError:
            msg = "Module 'psutil' is required for MemoryProfiling to work. " \
                  "Install it first using 'pip install psutil'."
            raise Exception(msg).with_traceback(sys.exc_info()[2])
        self.process = psutil.Process(os.getpid())

    def __enter__(self):
        # save memory usage in MB
        self.mem1 = self.process.memory_info()[0] / float(2 ** 20)
        self.time1 = time()

    def __exit__(self, type, value, traceback):
        # save memory usage in MB
        mem2 = self.process.memory_info()[0] / float(2 ** 20)
        time2 = time()
        print("MemoryProfiling Statistics")
        print("--------------------------")
        print("Mem1:", self.mem1, "MB")
        print("Mem2:", mem2, "MB")
        print("dMem:", mem2 - self.mem1, "MB")
        print("dT:", time2 - self.time1, "s")


class SetterProperty(object):
    """property with a setter only, no getter or __get__"""

    def __init__(self, fset, doc=None):
        self.fset = fset
        self.__doc__ = doc if doc is not None else fset.__doc__

    def __set__(self, obj, value):
        return self.fset(obj, value)


def slotgetter(*attrs):
    """Like Python's attrgetter, this functions returns a callable object that fetches attr from
    its operand. If more than one attribute is requested, returns a tuple of attributes. The
    attribute names can also contain dots and specific for ParaPy can also contain getitem
    statements like "[0]". For example::
    
        class MyClass(Base):
            
            @Part
            def sequence(self):
                return MyClass(quantify = [2,3])
    
    >>> obj = MyClass()
    >>> f = slotgetter("sequence.first.sequence[1,2].color")
    >>> f(obj)
    red
    """
    if len(attrs) == 1:
        attr = attrs[0]

        def g(obj):
            return getslot(obj, attr)
    else:
        def g(obj):
            return tuple(getslot(obj, attr) for attr in attrs)
    return g


def _is_int(s):
    try:
        int(s)
        return True
    except (TypeError, ValueError):
        return False


def getslot(obj, attr, default=Undefined, parse=True):
    """Like Python's builtin ``getattr``, but accepts reference chains with
    "." and "[idx]" tokens.

    >>> from examples.core.aircraft import Aircraft
    >>> aircraft = Aircraft()
    >>> getslot(aircraft, "wing.engines[0].nacelle.volume")
    4.1
    >>> # if parse == False, attr is expected to be a parsed representation.
    >>> getslot(aircraft, ['wing', 'engines', 0, 'nacelle', 'volume'], parse=False)
    4.1

    :param obj: ParaPy instance
    :type obj: :py:class:`~parapy.core.abstact.AbstractBase`
    :param attr: path to slot
    :type attr: str | typing.Sequence
    :param default: default value in case ``attr`` does not exist. Default is
        ``Undefined`` in which case, an AttributeErrorDescr is raised.
    :param bool parse: If False, attr is not parsed, and attr should be an
        iterable of slot tokens.
    :returns: The value of obj.attr.
    """
    tokens = parse_refchain(attr) if parse else attr
    try:
        return reduce(_get_slot, tokens, obj)
    except AttributeErrorDescr:
        if default is not Undefined:
            return default
        else:
            raise


def _get_slot(obj, token):
    if _is_int(token):
        return obj[int(token)]
    elif isinstance(token, str):  # basestring also includes unicode
        try:
            return getattr(obj, token)
        except AttributeError as e:
            if isinstance(obj, dict):
                return obj[token]
            else:
                raise e
    elif isinstance(token, tuple):
        return getitem(obj, token)
    else:
        raise Exception("token %s not valid" % (repr(token),))


def setslot(obj, attr, value, parse=True):
    """Like Python's builtin ``setattr``, but accepts reference chains with
    "." and "[idx]" tokens.

    :param obj: ParaPy instance
    :type obj: :py:class:`~parapy.core.abstact.AbstractBase`
    :param str attr:
    :param value: value to which ``attr`` should be bound
    :param bool parse: If False, attr is not parsed, and attr should be an
        iterable of slot tokens.

    Examples:

    >>> from examples.core.aircraft import Aircraft
    >>> aircraft = Aircraft()
    >>> setslot(aicraft, "wing.engine[0].nacelle.nail[1,2].mass", 3)
    >>> # if parse == False, attr is expected to be a parsed representation.
    >>> setslot(aircraft, ['wing', 'engine', 0, 'nacelle', 'nail', (1, 2), 'mass'], 3, parse=False)
    """
    tokens = parse_refchain(attr) if parse else attr
    if len(tokens) > 1:
        tokens, attr = tokens[0:-1], tokens[-1]
        for token in tokens:
            if _is_int(token):
                obj = obj[int(token)]
            # RvD: basestring covers unicode
            elif isinstance(token, str):
                try:
                    obj = getattr(obj, token)
                except AttributeError as e:
                    if isinstance(obj, dict):
                        obj = obj[token]
                    else:
                        raise e
            elif isinstance(token, tuple):
                obj = getitem(obj, token)
            else:
                raise Exception("token %s not valid" % (repr(token),))
        return setattr(obj, attr, value)
    else:
        attr = tokens[0]
        return setattr(obj, attr, value)


def delslot(obj, attr, parse=True):
    """Like Python's builtin ``delattr``, but accepts reference chains with
    "." and "[idx]" tokens.

    :param obj: ParaPy instance
    :type obj: :py:class:`~parapy.core.abstact.AbstractBase`
    :param str attr:
    :param bool parse: If False, attr is not parsed, and attr should be an
        iterable of slot tokens.

    Examples:

    >>> from examples.core.aircraft import Aircraft
    >>> aircraft = Aircraft()
    >>> delslot(aicraft, "wing.engine[0].nacelle.nail[1,2].mass")
    >>> # if parse == False, attr is expected to be a parsed representation.
    >>> delslot(aircraft, ['wing', 'engine', 0, 'nacelle', 'nail', (1, 2), 'mass'], parse=False)
    """
    tokens = parse_refchain(attr) if parse else attr
    if len(tokens) > 1:
        tokens, attr = tokens[0:-1], tokens[-1]
        for token in tokens:
            if _is_int(token):
                obj = obj[int(token)]
            # RvD: basestring covers unicode
            elif isinstance(token, str):
                try:
                    obj = getattr(obj, token)
                except AttributeError as e:
                    if isinstance(obj, dict):
                        obj = obj[token]
                    else:
                        raise e
            elif isinstance(token, tuple):
                obj = getitem(obj, token)
            else:
                raise Exception("token %s not valid" % (repr(token),))
        return delattr(obj, attr)
    else:
        attr = tokens[0]
        return delattr(obj, attr)


def unparse_refchain(tokens):
    """
    >>> unparse_refchain(['a', 'b', (1, 2), 'c', 1, 2])
    'a.b[1, 2].c[1][2]'
    """
    if not tokens:
        return "."
    s = ""
    for token in tokens:
        if _is_int(token):
            s += "[" + str(token) + "]"
        elif isinstance(token, tuple):
            s += "[" + ", ".join(map(str, token)) + "]"
        else:
            s += "." + token
    s = s.lstrip(".")
    return s


_rx = re.compile(r'([^\.\|\[\|\]]+)')


def parse_refchain(refchain):
    """
    >>> parse_refchain('a.b[1, 2].c[1][2]')
    ['a', 'b', (1, 2), 'c', 1, 2]
    """
    return list(_parse_refchain(refchain))


def _parse_refchain(refchain):
    for s in re.findall(_rx, refchain):
        if "," in s:  # 1, 2
            yield tuple(_parse_refchain_token(s) for s in s.split(","))
        else:
            yield _parse_refchain_token(s)


def _parse_refchain_token(s):
    if _is_int(s):
        return int(s)
    else:
        return s

# ==================================================================================================
# Old parse_refchain version with '[]' balancing check
# ==================================================================================================
# def parse_refchain(attr):
#     """
#     Converts a reference chain into a list of str attribute and integers/tuples of integers.
#     The output of this function is used by slotgetter. Usage:
# 
#     >>> parse_refchain("wing.engine[0].nacelle.nail[1,2].mass")
#     ['wing', 'engine', 0, 'nacelle', 'nail', (1, 2), 'mass']
#     """
# 
#     parts = []
#     part = ''
#     open_mode = False
#     
#     for c in attr:
#         if c == ".":
#             if part: parts.append(part) ; part = ''
#         elif c == "[":
#             assert not open_mode, "[] brackets don't match"
#             parts.append(part) ; part = ''
#             open_mode = True
#         elif c == "]":
#             assert open_mode, "[] brackets don't match"
#             if "," in part:
#                 part = tuple(map(int, part.split(",")))
#                 parts.append(part) ; part = ''
#             else:
#                 part = int(part)
#                 parts.append(part) ; part = ''
#             open_mode = False
#         else:
#             part += c
#     if part: parts.append(part)
#     return parts


def get_rgb_value(color):
    """Return a RGB tuple as tuple with three integers between 0-255. If color
    satisfies Falseness test, (0, 0, 0) (black) is returned:

    >>> get_rgb_value('red')
    (255, 0, 0)
    >>> get_rgb_value(None)
    (0, 0, 0)

    :type color: str | (float, float, float) | None
    :rtype: float, float, float
    """
    if color:
        if isinstance(color, str):
            try:
                r, g, b, _ = X11_COLORS[color.upper()]
                return r, g, b
            except KeyError:
                msg = ("color {} doesn't name a valid X11 key from "
                       "parapy.core.globs.X11_COLORS")
                raise RuntimeError(msg.format(repr(color)))
        elif hasattr(color, "__iter__"):
            if len(color) == 3:
                for obj in color:
                    if not isinstance(obj, int) or obj < 0 or obj > 255:
                        msg = ("color {} is not a valid sequence of 3 ints "
                               "where 0 <= int <= 255.")
                        raise RuntimeError(msg.format(repr(color)))
                return tuple(color)
            else:
                msg = "color {} is not a valid sequence of 3 ints."
                raise RuntimeError(msg.format(repr(color)))
        else:
            msg = "color {} is not a valid str or sequence of 3 ints"
            raise RuntimeError(msg.format(repr(color)))
    else:
        return 0, 0, 0


def _get_module_members(module):
    results = []
    for key in dir(module):
        try:
            value = getattr(module, key)
        except AttributeError:
            continue
        results.append((key, value))
    return results


def get_classes(module_or_name, superclass=None, private_members=False,
                predicate=None, member_order=False):
    """Returns a list of class objects inside module.

    >>> import importlib
    >>> module = importlib.import_module("parapy.geom.occ")
    >>> get_classes(module)  # doctest: +ELLIPSIS
    [<class 'parapy.geom.occ.curve.ApproximatedCurve'>, ...]

    :param module_or_name: The module object to search for classes.
    :type module_or_name: str | Module
    :param type superclass: specifiy to return only subclasses of this class.
    :param bool private_members: Include '_Name' classes? Default is False.
    :param predicate: optional callable to filter classes.
    :param member_order: only 'alphabetical' is supported for now.
    :type member_order: str | None
    :rtype: list
    """
    if isinstance(module_or_name, str):
        module = importlib.import_module(module_or_name)
    else:
        module = module_or_name

    modname = module.__name__

    def keep(cls):
        return (isinstance(cls, type)
                and cls.__module__.startswith(modname)
                and (superclass is None or issubclass(cls, superclass))
                and (private_members or not cls.__name__.startswith("_"))
                and (predicate is None or predicate(cls)))

    members = _get_module_members(module)
    if member_order:
        if member_order == 'alphabetical':
            members = sorted(members)
        else:
            raise NotImplementedError("only alphabetical is supported for now")
    members = [obj for _, obj in members if keep(obj)]
    return members


def get_functions(module_or_name, private_members=False, predicate=None,
                  member_order=False):
    """Returns a list of class objects inside module.

    >>> import importlib
    >>> module = importlib.import_module("parapy.geom.occ")
    >>> get_functions(module)  # doctest: +ELLIPSIS
    [...]

    :param module_or_name: The module object to search for functions.
    :type module_or_name: str | Module
    :param bool private_members: Include '_Name' classes? Default is False.
    :param predicate: optional callable to filter functions.
    :param member_order: only 'alphabetical' is supported for now.
    :type member_order: str | None
    :rtype: list
    """
    if isinstance(module_or_name, str):
        module = importlib.import_module(module_or_name)
    else:
        module = module_or_name

    modname = module.__name__

    def keep(fn):
        return (is_function(fn) and
                fn.__module__.startswith(modname) and
                (private_members or not fn.__name__.startswith("_")) and
                (predicate is None or predicate(fn)))

    members = _get_module_members(module)
    if member_order:
        if member_order == 'alphabetical':
            members = sorted(members)
        else:
            raise NotImplementedError("only alphabetical is supported for now")
    members = [obj for _, obj in members if keep(obj)]
    return members


# def get_last_frame():
#     frame = inspect.currentframe()
#     #: skip call to this function
#     frame = frame.f_back
#     try:
#         while frame:
#             filename = frame.f_code.co_filename
#             frame = frame.f_back
#             filename = frame.f_code.co_filename
#     finally:
#         del frame

def running_IPython():
    try:
        __IPYTHON__
        return True
    except NameError:
        return False


def try_getattr(instance, attr, default=None, warn=True, exc_info=True):
    """Try to getattr, or return default on exception. Warn with traceback.

    >>> import logging
    >>> from parapy.core import Base, Attribute
    >>> class Spam(Base):
    ...     @Attribute
    ...     def egg(self):
    ...         return 1/0
    >>> obj = Spam()
    >>> logging.getLogger().setLevel(logging.ERROR)  # suppress stdout
    >>> try_getattr(obj, "egg")  # returns None
    >>> try_getattr(obj, "egg", default=1)
    1

    :param parapy.core.base.Base instance: instance whose attr is requested
    :param str attr: name of slot to evaluate.
    :param default: default value to return on failure.
    :param bool warn: warn on exception?
    :param bool exc_info: show traceback on warning?
    """

    try:
        return getattr(instance, attr)
    except Exception:
        if warn:
            import logging

            msg = "Caught exception while evaluating '{:} of {:}."
            logging.warning(msg.format(attr, instance), exc_info=exc_info)
        return default


# TODO (TBD): merge with abstractbase.py. Author: RvD.
def raise_conditionally(ExcType, msg, failure, *args):
    if failure == "raise":
        raise ExcType(msg, *args)
    elif failure == "warn":
        warnings.warn(msg)
    elif failure == "ignore":
        pass
    else:
        msg = "Value ``{:}`` is not one of ('raise', 'warn', 'ignore')"
        raise ValueError(msg.format(failure))


def is_function(obj):
    return inspect.isfunction(obj)


def is_method(obj):
    return inspect.ismethod(obj)


def is_unbound_method(obj):
    """Return True if ``obj`` is **close** to what, in Python 2, was called
    an ``unbound_method``.

    Differences with Python 2:

        - Returns ``True`` if the function is declared nested in something
          that is not a local scope definition, and not a class.
        - Returns ``False`` for any function that is patched on a class
        - Always returns ``False`` for lambdas.
        - This function might be fooled when one sets a custom ``__qualname__``
    """
    if is_function(obj):
        if '<lambda>' == obj.__name__:
            # we never treat lambdas as methods
            return False

        obj_qualname = obj.__qualname__
        if '.' in obj_qualname:
            non_local_qname_split = obj_qualname.rsplit('<locals>', 1)

            if len(non_local_qname_split) == 1:
                # It was not, indirectly, defined in a local scope
                non_local_qname = non_local_qname_split[0]
            else:
                # we are only interested in the qualified name
                # after the last local scope. Strip any '.' prefixes
                non_local_qname = non_local_qname_split[1].lstrip('.')

            # FIXME (TBD): inaccurate assumption, might be something like
            #  a function or lambda in something that's not a class
            #  however we assume that it is nested in a class
            return '.' in non_local_qname
    return False


def is_function_or_method(obj):
    return inspect.isfunction(obj) or inspect.ismethod(obj)


def gen_n_times(value, n):
    """Create a generator that yields ``value`` ``n`` times.

    :param T value: A value
    :param int n: amount of times ``value`` will be yielded
    :rtype: typing.Iterator[T]
    """
    msg = "gen_n_times has been deprecated, use 'itertools.repeat' instead."
    warnings.warn(msg, ParaPyDeprecationWarning)
    return itertools.repeat(value, n)


def is_color(obj):
    """Is ``obj`` a color (either from a string or an integer triple?)

    Usage:

    >>> is_color("blue")
    True
    >>> is_color((0, 255, 255))
    True
    >>> is_color(("blue", "grey", "orange"))
    False
    >>> is_color((1, 2, 3, 4))
    False
    >>> is_color((1.1, 2, 3))
    False
    >>> is_color((0, -1, 255))
    False
    >>> is_color((0, 1, 266))
    False

    :param T obj:
    :rtype: bool
    """
    return (isinstance(obj, str) or (hasattr(obj, '__iter__') and
            len(obj) == 3 and (all(isinstance(i, int)
                                   and 0 <= i <= 255 for i in obj))))


def datetime_string():
    """Returns the current datetime string in iso-format, e.g.
    :py:`'2013-10-05T00:15:31'`.

    :rtype: str
    """
    return datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')


def all_map(predicate, *args):
    """Check ``predicate`` is :py:`True` for all elements of the given
    iterables. Relation of ``predicate`` to the iterables in
    ``args`` corresponds to the builtin 'map' functionality.

    Usage:

    >>> from operator import eq
    >>> from parapy.core.utilities import all_map
    >>> all_map(lambda x: isinstance(x, int), [1, 2, 3])
    True
    >>> all_map(lambda x: isinstance(x, int), [1, 2.0, 3])
    False
    >>> # multiple iterators
    >>> a = [1, 2, 3]
    >>> all_map(eq, a, [1, 2, 3])  # equal
    True
    >>> all_map(eq, a, [1, 3, 3])  # second element is different
    False

    :param types.FunctionType predicate: True/False check. The amount of
        arguments needs to correspond to the amount of iterables passed for
        ``args``.
    :param args: One or more iterables.
    :rtype: bool
    """
    return all(map(predicate, *args))


def any_map(predicate, *args):
    """Check ``predicate`` is :py:`True` for any element of the given
    iterables. Relation of ``predicate`` to the iterables in
    ``args`` corresponds to the builtin 'map' functionality.

    Usage:

    >>> from operator import eq
    >>> from parapy.core.utilities import all_map
    >>> def is_int(x):
    ...     return isinstance(x, int)
    >>> any_map(is_int, [1, 2, 3])
    True
    >>> any_map(is_int, [1, 2.0, 3])
    True
    >>> any_map(is_int, [1.0, 2.0, 3.0])
    False
    >>> # multiple iterators
    >>> a = [1, 2, 3]
    >>> any_map(eq, a, [1, 2, 3])  # equal
    True
    >>> any_map(eq, a, [1, 3, 3])  # second element is different
    True
    >>> any_map(eq, a, [4, 5, 6])  # all elements different
    False

    :param types.FunctionType predicate: True/False check. The amount of
        arguments needs to correspond to the amount of iterables passed for
        ``args``.
    :param args: One or more iterables.
    :rtype: bool
    """
    return any(map(predicate, *args))


def apply_to_all(fn, *args):
    """Apply ``fn`` to ``args`` just like ``map``. Unlike map it does not
    collect the return values.

    :param types.FunctionType fn: Funtion. The amount of arguments needs to
        correspond to the amount of iterables passed for ``args``.
    :param args: One or more iterables. Way of using corresponds to the
        builtin 'map' functionality.
    """
    for _ in map(fn, *args):
        pass


def all_equal(iterable):
    """Returns True if all the elements are equal to each other.

    From https://docs.python.org/2/library/itertools.html#recipes
    """
    g = itertools.groupby(iterable)
    return next(g, True) and not next(g, False)


def yield_commonprefix_tokens(paths, parse=False):
    """Like :func:`commonprefix`, yielding subsequent tokens of the
    common prefix

    :rtype: typing.Iterator[int | str]
    """
    if parse:
        paths = map(parse_refchain, paths)

    for elements in zip(*paths):
        if all_equal(elements):
            yield elements[0]
        else:
            break


def commonprefix(paths, parse=False):
    """Return the longest refchain path prefix of all the ``paths``.

    Usage:

    >>> commonprefix([['foo', 1, 2, 3], ['foo', 1]])
    ('foo', 1)
    >>> commonprefix([('foo', 1, 2, 3)])
    ('foo', 1, 2, 3)
    >>> commonprefix(['foo.bar', 'foo'], parse=True)
    ('foo',)
    >>> commonprefix(['foo.bar', 'bar.foo'], parse=True)
    ()

    :param typingIterable[typingIterable[int | str] | str ] paths:
    :param bool parse: parse the ``paths`` to a tuple.
    :rtype: tuple[int | str]
    """
    return tuple(yield_commonprefix_tokens(paths, parse=parse))


def walk_refchain(root, refchain, include_root=False):
    """Walk down the path of ``refchain`` and yield the object at
    that point with the current refchain, as seen from ``root``.

    :param object root: object fro which ``refchain`` is traversed
    :param typingIterable[str | int] refchain: reference chain that
        will be traversed
    :param bool include_root: Should :py:`(root, ())` be included?
    :rtype: typingIterator[object, tuple[str | int]]
    """
    if include_root:
        yield root, ()

    current_refchain = []
    for token in refchain:
        root = _get_slot(root, token)
        current_refchain.append(token)
        yield root, tuple(current_refchain)


def relative_refchain(refchain, start):
    """Get relative version of ``refchain`` as seen from ``start``.

    >>> refchain = ('foo', 'bar')
    >>> relative_refchain(refchain, ('foo',))
    ('bar',)
    >>> relative_refchain(refchain, ('foo', 'bar'))
    ()
    >>> relative_refchain(refchain, ('bar',))  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    RuntimeError: The 'start' refchain 'foo.bar' is not a prefix of ...

    :param typingSequence[str | int] refchain: The 'absolute' reference
        chain.
    :param typingSequence[str | int] start: The point compared to
        which we want to get the  relative reference chain: a prefix of
        ``refchain``.
    :rtype: typingSequence[str | int]
    :raise RuntimeError: if ``start`` is not a prefix of ``refchain``.
    """
    start_len = len(start)
    if start_len > len(refchain) or refchain[:start_len] != start:
        msg = "The 'start' refchain {!r} is not a prefix of 'refchain' {!r}."
        raise RuntimeError(msg.format(unparse_refchain(start),
                                      unparse_refchain(refchain)))
    return refchain[start_len:]


def try_issubclass(value, classinfo):
    """Like built-in issubclass, but not raising type error if ``value`` isn't
    a class, instead returning False.

    >>> try_issubclass(object, object)
    True
    >>> try_issubclass(1, object)
    False
    >>> # compare that to built-in function
    >>> issubclass(1, object)
    Traceback (most recent call last):
        ...
    TypeError: issubclass() arg 1 must be a class
    """
    try:
        return issubclass(value, classinfo)
    except TypeError:
        return False


# adds a move_atomic method, that 'atomically' moves a src file to a dst file
# A pre-condition is that the filesystem is not FAT32, and that src and dst are
# on the same filesystem
if sys.platform == 'win32':
    flags = 1 | 2  # move file && copy allowed
    try:
        import win32api
    except ImportError:
        # we create the move-file through ctypes
        import ctypes

        kernel32 = ctypes.windll.kernel32
        try:  # support for unicode paths, windows 10 only
            _MoveFileEx = kernel32.MoveFileExW
        except AttributeError:  # ascii paths
            _MoveFileEx = kernel32.MoveFileExA
            _MoveFileEx.argtypes = [ctypes.c_char_p, ctypes.c_char_p,
                                    ctypes.c_uint32]
        else:
            _MoveFileEx.argtypes = [ctypes.c_wchar_p, ctypes.c_wchar_p,
                                    ctypes.c_uint32]
        _MoveFileEx.restype = ctypes.c_bool

        def move_atomic(src, dst):
            if not _MoveFileEx(src, dst, flags):
                errno = ctypes.GetLastError()
                raise OSError(errno, os.strerror(errno), src)
    else:
        def move_atomic(src, dst):
            win32api.MoveFileEx(src, dst, flags)
else:
    move_atomic = os.rename  # on linux it is atomic


if __name__ == '__main__':
    seq = [1, (2, (3, 4)), "bar"]
    print(list(iflatten(seq, is_atomic=None)))

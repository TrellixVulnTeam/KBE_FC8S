#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import multiprocessing as mp
import operator
import os
import typing
from functools import reduce
from operator import attrgetter, getitem

from parapy.core.abstractbase import AbstractBase
from parapy.core.attribute import Attribute
from parapy.core.globs import ICN_DIR, RESERVED_SEQUENCE
from parapy.core.input import Input
from parapy.core.meta import basetype
from parapy.core.parser import PartParser
from parapy.core.utilities import iflatten


def Sequence_type_validator(value, obj, slot):
    if isinstance(value, basetype):
        return True
    elif hasattr(value, "__iter__"):
        return all([Sequence_type_validator(subvalue, obj, slot)
                    for subvalue in value])
    else:
        return False


def _quantify_validator(value, obj):
    if isinstance(obj.type, basetype):
        if isinstance(value, int) or (hasattr(value, "__iter__") and
                                      all(isinstance(s, int) for s in value)):
            return True  # it is a single integer, or an iterable of integers
        else:
            msg = ("if you specify type as a single class, quantify "
                   "should be correctly defined as either an integer or a "
                   "list of integers, not: {!r}")
            return False, msg.format(obj)

    return True  # if type is not a single basetype, quantify can be anything


# TODO RvD: make Sequence subclass of Base class. Creator: RvD
class Sequence(AbstractBase):
    """
    Abstract class for all sequence objects. Usage is typically implicit::
    
        class MyClass(Base):
        
            @Part
            def sequence(self, child):
                return Box(quantify=3,
                           width=1,
                           length=child.index + 1,
                           height=child.length * 2)
    
    This is converted into the explicit form (that you can also use) at run-time::
    
        class MyClass(Base):
        
            @Part
            def sequence(self, child):
                return Sequence(type=Box,
                                quantify=3,
                                width=1,
                                length=child.index + 1,
                                height=child.length * 2)
                                
    The sequence object wraps and behaves like a list. You can retrieve individual items using
    standard getitem [idx] notation or other list-supported operations (len, add, etc.).
    
    >>> seq = MyClass().sequence
    <Sequence (1x3) root.sequence at ...>
    >>> seq.first
    <Box root.sequence[0] at ...>
    >>> seq[0]
    <Box root.sequence[0] at ...>    
    >>> seq.last
    <Box root.sequence[2] at ...>
    >>> seq[-1]
    <Box root.sequence[2] at ...>
    >>> seq[0].height
    2
    >>> seq.any.height
    [2, 4, 6]
    >>> seq.sum("height")
    12
    
    The ``quantify`` or ``type`` inputs can result in multi-dimensional
    sequences. For example, to make a 2-dimensional [3x4] sequence of
    boxes with size, use:
    
        class MyClass(Base):
        
            @Part
            def sequence(self, child):
                return Sequence(type=Box,
                                quantify=[3, 4],
                                width=1, length=2, height=child.length * 2)
    
    Or::
        class MyClass(Base):
        
            @Part
            def sequence(self, child):
                return Sequence(type=[[Box] * 4] * 3,
                                width=1, length=2, height=child.length * 2)
    
    >>> seq = MyClass().sequence
    >>> seq.first
    <Box root.sequence[0,0] at ...>
    >>> seq.last
    <Box root.sequence[2,3] at ...>
    """

    __icon__ = os.path.join(ICN_DIR, 'sequence.png')
    __reserved__ = RESERVED_SEQUENCE

    #: None if not defined. Otherwise a (quantify, type, old_list) tuple
    #: type: None | tuple
    _prev_state = None

    #: a type (Base or subclass of Base) or sequence of types
    #: :type: parapy.core.basetype.basetype | collections.Sequence[parapy.core.basetype.basetype]
    type = Input(validator=Sequence_type_validator)

    #: the number of members in this sequence. If :attr:`type` is a sequence,
    #: this value can be None
    #: :type: int | typing.Sequence[int] | None
    quantify = Input(None, validator=_quantify_validator)

    #: if True, this instance will not be shown in the GUI tree.
    #: :type: bool
    hidden = Input(False)

    #: name to display in the tree or repr. If ``None``, *role* (name of @Part
    #: definition) is displayed.
    #: :type: str | None
    label = Input(None)

    #: Either a valid string from parapy.globals.X11_COLORS or a 3-integer
    #: iterable with RGB values. RGB ranges 0-255. For example [255,192,203] is
    #: a list.
    #: :type: str | collections.Sequence[int, int, int]
    color = Input("yellow", defaulting=True)

    #: User-settable dictionary with values that control the appearance of this
    #: node in the GUI tree. Valid options::
    #:
    #:     {"label": str (defaults to label slot),
    #:      "color" : bool | str / tuple (defaults to None),
    #:      "background_color" : bool | str | tuple (defaults to (-1, -1, -1)),
    #:      "icon" : path (defaults to self.__icon__),
    #:      "bold" : bool (defaults to False)}
    #:
    #: color values:
    #:
    #: - None: don't color tree node
    #: - True: take on same color as self.color
    #: - str: named color that will be converted to corresponding RGB tuple
    #: - tuple: RGB color
    #:
    #: :type: dict
    tree_style = Input({})

    @Attribute
    def any(self):
        return AnyProxy(self)

    @Attribute
    def type_list(self):
        """list of base classes. Can be a nested list."""
        type_ = self.type
        if isinstance(type_, basetype):
            quantify = self.quantify
            if isinstance(quantify, int):
                return [type_] * quantify
            elif (hasattr(quantify, "__iter__") and
                  all(isinstance(s, int) for s in quantify)):
                lst = type_
                for quantify in reversed(quantify):
                    lst = [lst] * quantify
                return lst
        else:
            return type_

    @Attribute
    def _list(self):
        """The list with instances that this Sequence object wraps"""
        prev_state = self._prev_state
        if prev_state:
            members = self._diff_update_list(prev_state)
        else:  # first time
            members = self._create_all_members()

        # update state
        self._save_state(members)
        return members

    def _save_state(self, members):
        self._prev_state = self.quantify, self.type, members

    def _diff_update_list(self, prev_state):
        """Return _list, taking a diff with ``prev_state`` into account.

        :param prev_state: snapshot of previous Sequence state
            with keys like 'type', 'quantify' and '_list'
        """
        prev_quantify, prev_type, prev_list = prev_state

        type_ = self.type
        if not isinstance(type_, basetype):
            # no diff implemented when quantifying through type explicitly
            return self._create_all_members()

        quantify = self.quantify
        if hasattr(quantify, '__iter__'):
            # no diff implemented for multi-dimensional Sequences
            return self._create_all_members()

        if type_ is not prev_type or prev_quantify == 0:
            return self._create_all_members()

        if quantify < prev_quantify:
            del prev_list[quantify:]  # remove last members
        else:  # quantify > previous.quantify: create and compose new members
            new_members = make_list(self.type_list[prev_quantify:])
            prev_last = prev_list[-1]
            self._compose_new_members(new_members, prev_last)
            prev_list.extend(new_members)

        return prev_list

    def _compose_new_members(self, objects, previous=None):
        """Note: will only for a 1D Sequence"""
        parent = self._parent
        slot = self._slot
        start = previous.index + 1 if previous else 0

        i_max = len(objects) - 1
        for i, obj in enumerate(objects, start):
            next_ = objects[i + 1] if i < i_max else None
            obj.make_child(parent, slot, [i], previous, next_, self)
            previous = obj

    def _create_all_members(self):
        members = make_list(self.type_list)
        make_children(self, members)
        return members

    @Attribute
    def _data(self):
        type_ = self.type
        if isinstance(type_, basetype):
            # we are a non-jagged, 'complete' matrix
            qtfy = self.quantify
            if hasattr(qtfy, '__iter__'):
                num_items = reduce(operator.mul, self.quantify)
                size = list(qtfy)
            else:
                num_items = qtfy
                size = [qtfy]
            return num_items, len(size), size
        else:
            # we could be a jagged array, we need to walk all the elements
            # to be sure of our num_items, dimensions and sizing
            return _find_iter_len_dim_size(type_)

    @staticmethod
    def _is_not_list(obj):
        return not isinstance(obj, list)

    @Attribute
    def first(self):
        """First item of this Sequence or ``None`` if it is empty"""
        return next(iflatten(self._list, is_atomic=self._is_not_list), None)

    @Attribute
    def last(self):
        """last item of this Sequence or ``None`` if it is empty"""
        lst = self._list

        if isinstance(self.type, basetype):
            qtfy = self.quantify
            if hasattr(qtfy, '__iter__') and all(num > 0 for num in qtfy):
                # we assume that _list and all its sublists are lists
                while isinstance(lst, list) and lst:
                    lst = lst[-1]
                return lst
            elif qtfy != 0:
                return lst[-1]
            else:  # empty list
                return None
        else:
            return _find_last_nested_list(lst)

    @Attribute
    def number_of_items(self):
        """Total number of items in this sequence (flat)"""
        return self._data[0]

    @Attribute
    def dimension(self):
        """Dimension of the sequence. Standard list is dimension 1"""
        return self._data[1]

    @Attribute
    def size(self):
        """Size. 1D list of 4 items --> [4].
        2D list of 3x4 items --> [3,4], etc.
        """
        size = self._data[2]
        if size is None:
            msg = ("Could not calculate the size of the Sequence, it is a "
                   "jagged array: not all the elements of this Sequence have "
                   "the same dimension or size. Object: {!r}")
            raise RuntimeError(msg.format(self))
        else:
            return size

    def sum(self, attr, start=0):
        """Sum all member values corresponding to attribute ``attr``. Usage:

        >>> from parapy.core import *
        ...
        ... class Parent(Base):
        ...     @Part
        ...     def sequence(self):
        ...         return Child(quantify=3,
        ...                      width=child.index + 1)
        ...
        ... class Child(Base):
        ...     width = Input()
        ...
        >>> obj = Parent()
        >>> obj.sequence.sum("width")
        6

        :param str attr: name of attribute to sum.
        :param float start: optional start value.
        :rtype: float
        """
        return start + sum_list(self._list, attr)

    def map(self, attr, processes=1):
        """Use multi-processing to get the values of individual members in
        this sequence.

        :param str attr: name of attribute to get.
        :param int processes: number of Python processes to spawn
        """
        if processes == 1:
            return list(map(attrgetter(attr), self._list))
        else:
            p = mp.Pool(processes)
            result = p.map(getattr_proxy(attr), self._list)
            p.close()
            p.join()
            return result

    def __getitem__(self, idx):
        """customized __getitem__ to allow nested item retrieval like
        ``sequence[1, 2, 3]`` instead of ``sequence[1][2][3]``"""
        if isinstance(idx, tuple):
            return reduce(getitem, idx, self._list)
        else:
            return self._list[idx]

    def __len__(self):
        return len(self._list)
    
    def __iter__(self):
        return iter(self._list)
    
    def __reversed__(self):
        return reversed(self._list)

    def __add__(self, other):
        """Convenience override. Allows addition of sequences and other
        iterable types.
        """
        if isinstance(other, list):
            return list.__add__(self._list, other)
        elif isinstance(other, Sequence):
            return list.__add__(self._list, other._list)
        else:
            return NotImplemented
  
    def __radd__(self, other):
        """Convenience override. Allows addition of sequences and lists"""
        if isinstance(other, list):
            return list.__add__(other, self._list)
        elif isinstance(other, Sequence):
            return list.__add__(other._list, self._list)
        else:
            return NotImplemented

    # TODO RvD: is this one necessary?
    def __contains__(self, item):
        return item in self._list


PartParser.SEQUENCE_TYPE = Sequence
AbstractBase.SEQUENCE_TYPE = Sequence


#==================================================================================================
# Proxies
#==================================================================================================
class AnyProxy(object):
    """
    Object that can be used inside sequence to obtain similar attributes of all sequence items
    in one expression. For example::

        class MyClass(Base):
        
            lengths = Attribute([1,2,3])
        
            @Part
            def boxes(self):
                return Box(quantify=len(self.lengths),
                           map_down="lengths->length")

    >>> boxes = MyClass().boxes
    <Sequence (1x3) root.boxes at ...>
    >>> boxes.any.length
    (1, 2, 3)
    >>> boxes.any(processes=1).length
    (1, 2, 3)
    """
    
    def __getstate__(self):
        return dict((k, getattr(self, k)) for k in ["processes", "sequence", "_reset_after"])
    
    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

    def __init__(self, sequence):
        self.processes = None
        self.sequence = sequence
        self._reset_after = True

    def __getattr__(self, name):
        if self.processes is None:
            return getattr_tup(self.sequence._list, name)
        else:
            p = mp.Pool(processes=self.processes)
            result = p.map(getattr_proxy(name), self.sequence._list)
            p.close()
            p.join()

            if self._reset_after:
                self.processes = None
            return result

#     def __call__(self, *args):
#         f = attrgetter(*args)
#         return _getattr_tup(self.sequence._list, f)

    def __call__(self, processes=None, reset_after=True):
        self.processes = processes
        self._reset_after = reset_after
        return self


class getattr_proxy(object):
    """This class is a proxy around getattr, which can be pickled and, thus, used inside
    multiprocessing environments.
    """
    
    def __init__(self, name):
        self.name = name
    
    def __call__(self, obj):
        return getattr(obj, self.name)


# ---- Utilities ----
def make_list(type_list):
    if isinstance(type_list, basetype):
        return type_list()
    else:
        # for __iter__
        return list(map(make_list, type_list))


def make_children(sequence, objs):
    parent = sequence._parent
    slot = sequence._slot
    _make_children(objs, parent, slot, sequence)
    return objs


def _make_children(obj, parent, slot, sequence, indices=[], previous=None,
                   next=None):
    if isinstance(obj, AbstractBase):
        obj.make_child(parent, slot, indices, previous, next, sequence)
    elif hasattr(obj, '__iter__'):
        for index, subchild in enumerate(obj):
            _make_children(subchild, parent, slot, sequence,
                           indices=indices + [index],
                           previous=None if index == 0 else obj[index - 1],
                           next=None if index == len(obj) - 1 else obj[
                               index + 1])


def sum_list(tup, name):
    f = attrgetter(name)
    return _sum_list(tup, f)


def _sum_list(tup, f):
    if isinstance(tup, list):
        return sum((_sum_list(sub, f) for sub in tup))
    else:
        return f(tup)


def getattr_tup(tup, name):
    f = attrgetter(name)
    return _getattr_tup(tup, f)


def _getattr_tup(tup, f):
    if isinstance(tup, list):
        return [_getattr_tup(sub, f) for sub in tup]
    else:
        return f(tup)


def _find_iter_len_dim_size(it):
    num_items = 0
    my_len = 0
    dim = 0
    found_size = []  # will be set to None when it is a jagged array
    for obj in it:
        if isinstance(obj, typing.Iterable):
            nested_num, nested_dim, nested_size = _find_iter_len_dim_size(obj)
            num_items += nested_num
            dim = max(nested_dim, dim)

            if found_size is not None:
                # so far, we have no reason to believe we are a jagged array
                if not found_size:
                    found_size = nested_size
                elif found_size != nested_size:
                    # we already found a size, but it is not the same
                    # size as the one we found now: jagged array
                    found_size = None
        else:
            num_items += 1

        my_len += 1

    if found_size is None:
        size = None  # jagged array: we do not know
    else:
        size = [my_len] + found_size

    return num_items, dim + 1, size


def _find_last_nested_list(lst):
    for obj in reversed(lst):
        if isinstance(obj, list):
            last = _find_last_nested_list(obj)
            if last is not None:
                return last
        else:
            return obj

    return None

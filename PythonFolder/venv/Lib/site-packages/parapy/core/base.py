#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import warnings
from itertools import filterfalse

from parapy.core.abstract import DrawableParaPyObject
from parapy.core.abstractbase import AbstractBase
from parapy.core.attribute import Attribute
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.globs import ICN_DIR, Undefined
from parapy.core.input import Input
from parapy.core.utilities import get_rgb_value, iflatten


class Base(AbstractBase):
    """The root class of all user-defined classes. You **HAVE** to directly
    or indirectly subclass this class in your class object definitions. Any
    user-defined class typically defines one or multiple slot attributes.
    These slots encapsulate an engineering rule in the form of either a
    simple data value or a more involved Python expression. Slots act as
    class descriptor attributes and their values are demanded as if you were
    asking an instance attribute. Slots have a nice side-effect in that
    there values are cached and slot precedents are tracked at run-time.
    This provides you a straightforward set of tools to build high-level
    parametric product models without worrying about order and procedure.

    The most important slots types are input slots, attribute (computed)
    slots and child slots. The first are modifiable and their values are
    typically either provided by you on instantiation or passed down in the
    composition tree by other instances. Attribute slots are computed
    responses that are typically derived from other slot values. Finally,
    child slots build up a hierarchy product tree. There values typically
    evaluate to a Base instance which has a parent-child relationship. Slot
    values can be passed and interrelated both up and down the composition
    tree, as you like.
    
    Usage example::
    
        class MyBox(Base):
        
            width = Input(2)
            
            @Input
            def length(self):
                return self.width + 1
            
            @Attribute
            def height(self):
                return self.length + 1
            
            @Part
            def my_child(self):
                return MyBox(width = self.width + 1,
                             length = self.length + 1)

    .. note:: the constructor of Base classes is __init__(self, **kwargs). If
        you want to work with *args as well, this can be done by implementing
        ``__initargs__`` in the class definition. The cls.__new__(cls, *args,
        **kwargs) can extend **kwargs with *args

    .. caution:: the use of @property should be done with care. If it raises an
        AttributeError, it will be caught by the ``__getattr__`` method of the
        Base class. It might result in weird error messages which state that
        the property doesn't exist. AbstractSlot, also a data descriptor,
        has solves this in its ``__get__`` method by catching any
        AttributeError and re-raising it as AttributeErrorDescr.
    """

    __slots__ = []

    #: optional icon that will be used for display in the User Interface.
    #: :type: str
    __icon__ = os.path.join(ICN_DIR, 'base.png')

    #: Either a valid string from parapy.globals.X11_COLORS or a 3-integer
    #: iterable with RGB values. RGB ranges 0-255. For example [255,192,203] is
    #: a list.
    #: :type: str | collections.Sequence[int, int, int]
    color = Input("yellow", defaulting=True)

    #: if True, this instance will not be shown in the GUI tree.
    #: :type: bool
    hidden = Input(False)

    #: name to display in the tree or repr. If ``None``, *role* (name of @Part
    #: definition) is displayed.
    #: :type: str | None
    label = Input(None)

    #: User-settable dictionary with values that control the appearance of this
    #: node in the GUI tree. Valid options::
    #:
    #:     {"label": str (defaults to label slot),
    #:      "color" : bool | str / tuple (defaults to None),
    #:      "background_color" : bool | str | tuple (defaults to (-1, -1, -1)),
    #:      "icon" : path (defaults to self.__icon__),
    #:      "bold" : bool (defaults to False)}
    #:
    #: color values:
    #:
    #: - None: don't color tree node
    #: - True: take on same color as self.color
    #: - str: named color that will be converted to corresponding RGB tuple
    #: - tuple: RGB color
    #:
    #: :type: dict
    tree_style = Input({})

    @Attribute(private=True)
    def parts(self):
        """Returns a list of instances. Sequences are lists."""
        msg = ("Base.parts has been deprecated. Use Base.children instead. "
               "Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.children

    @Attribute
    def children(self):
        """List *children* of this object. Hidden children are excluded and
        Sequences are not expanded. For more control, use
        :meth:`get_children()`.

        :rtype: list[parapy.core.abstractbase.AbstractBase]
        """
        return self.get_children()

    def get_children(self, hidden=False, expand=False):
        """Return the ``children`` of this object.

        :param hidden: Set `True` to include hidden children (they could be
            hidden through either the slot not being ``in_tree``
            or ``hidden`` being ``True`` when it is an
            :class:`~parapy.core.abstractbase.AbstractBase`.
            (Default: ``False``)
        :param expand:  Set `True` to expand
            :class:`~parapy.core.sequenece.Sequence`s. (Default: ``False``)
        :rtype: list[parapy.core.abstractbase.AbstractBase | typing.Sequence]
        """
        result = []

        for slot in self._parts.values():
            if hidden:
                is_hidden = _false
            elif not slot.in_tree:
                # don't show hidden items, but this slot is not in the tree
                continue
            else:
                is_hidden = _is_hidden

            child = slot.__get__(self)
            # filter out the Undefined elements
            if child is not Undefined:
                if not is_hidden(child):
                    if expand and hasattr(child, "__iter__"):
                        child_gen = iflatten(child)
                        nested_children = filterfalse(is_hidden, child_gen)
                        result.extend(nested_children)
                    else:
                        result.append(child)
        return result


def _is_hidden(obj):
    # Technically it is hidden when it is a ParaPy object and it is hidden
    return isinstance(obj, AbstractBase) and obj.hidden


def _false(obj):
    return False


class DrawableBase(Base, DrawableParaPyObject):
    """Base class for all Base-derived classes that are also Drawable."""

    def _display_style(self):
        """Used for gui, may contain keys like "color", "u_isos", etc."""
        return {"color": get_rgb_value(self.color)}

    @Input
    def tooltip(self):
        return str(self)

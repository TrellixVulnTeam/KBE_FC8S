#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This file defines the slot types and the decorators to create them. The
core slot types are Input, Attribute and Part. In addition,
some "semantical" decorators are defined as well.

Each of the slot classes has a corresponding slot decorator, which is simply a rename
from the CamelCase class name convention to the underscored_name decorator name convention.

To use a slot type or decorator with its normal settings, use the decorator syntax::

    @Attribute
    def slot_name(self):
        ...

To use the options some slot types have available, use::

    @Attribute(option=value, ...)
    def slot_name(self):
        ...
"""

from parapy.core.globs import derived
from parapy.core.abstractslot import AbstractSlot
#from .logging import logger


class Attribute(AbstractSlot):    
    """A computed slot that encapsulates an essential calculation, typically
    depending on other slot values. An Attribute or computed slot is by
    default not settable like an input slot, but it can be configured as such.
    
    There are two recommended ways to use this descriptor object::
    
        class MyClass(Base):
            
            @Attribute
            def foo(self):
                \"\"\"docstring\"\"\"
                ...
            
            # Settable variant
            @Attribute(settable=True)
            def foo(self):
                \"\"\"docstring\"\"\"
                ...
    
    Basically, the Attribute class is invoked with the decorated class
    method as first argument, viz::
    
        class MyClass(Base):
        
            @Attribute
            def foo(self): <body>
    
    Is equivalent to::

        class MyClass(Base):
        
            def foo(self): <body>
            foo = Attribute(foo)
    
    It's valid to use the non-decorated syntax, in which you call Attribute()
    as a general function. You *HAVE* to specify a first argument of type
    FunctionType|MethodType as first argument. For example::
    
        class MyClass(Base):
    
            # Attribute invoked like a function with a lambda input
            foo = Attribute(lambda self: <body>, <other_options>)"""
    
    __slots__ = []

    #: enables fast check from basetype. One of
    #: ["abstract", "input", "attribute", "part"]
    #: :type: str
    __ppmembername__ = "attribute"

    def __init__(self, fn=derived, doc=None, settable=False, **kwargs):
        """Args:
            fn (callable): see :py:class:`ClassBoundSlot`
            settable(bool): standard False for ComputedSlot
            **kwargs: check extra options in :py:class:`ClassBoundSlot`."""
        
        AbstractSlot.__init__(self, fn, doc=doc, settable=settable, **kwargs)

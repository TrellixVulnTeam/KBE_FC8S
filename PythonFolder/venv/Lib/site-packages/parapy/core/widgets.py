#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from enum import Enum

from parapy.core.utilities import try_issubclass

__all__ = ["PyField", "TextField", "Dropdown", "FilePicker", "ColorPicker",
           "CheckBox", "ObjectPicker", "MultiCheckBox", "Widget",
           "SingleSelection", "Button"]


class Widget(object):
    """Base class for slots widgets in the Property Grid of the GUI."""

    def __init__(self, autocompute: bool = False, read_only: bool = False):
        self.autocompute = autocompute
        self.read_only = read_only


class PyField(Widget):
    """Results in text field in which Python value are shown and can be edited.
    It's the DEFAULT_WIDGET. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.widgets import PyField
    ...
    >>> class MyClass(Base):
    ...     foo = Input(widget=PyField())
    ...     bar = Input(widget=PyField)  # also fine

    This widget uses built-in ``eval`` to convert user-defined string to a
    Python object. You can provide a different ``eval`` keyword to change
    the reader function.

    >>> import ast
    >>> widget = PyField(eval=ast.literal_eval)
    """
    def __init__(self, eval=eval, background_color=None, **kwargs):
        super(PyField, self).__init__(**kwargs)
        self.eval = eval
        self.background_color = background_color


class TextField(Widget):
    """Results in a text field widget in the property grid. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.widgets import Dropdown
    ...
    >>> class MyClass(Base):
    ...     foo = Input(widget=TextField())
    ...     bar = Input(widget=TextField)  # also fine
    """

    def __init__(self, multi_line=False, background_color=None, **kwargs):
        super(TextField, self).__init__(**kwargs)
        self.multi_line = multi_line
        self.background_color = background_color


class FilePicker(Widget):

    def __init__(self, wildcard=None, default_dir=None, title=None,
                 relative_to_dir=None, full_path=True, **kwargs):
        """A widget that allows one to select a file on the FileSystem.
        It will always return the absolute path as a value.

        Usage:

        >>> import os
        >>> from parapy.core import Base, Input
        >>> from parapy.core.widgets import FilePicker
        >>> class Foo(Base):
        ...     bar1 = Input(widget=FilePicker)
        ...     # show file selection relative to current working directory
        ...     bar2 = Input(widget=FilePicker(relative_to_dir=os.getcwd()))
        ...     # only show the filename
        ...     bar3 = Input(__file__, widget=FilePicker(full_path=False))
        ...     # force the file dialog to always open at C:|
        ...     bar4 = Input(__file__, widget=FilePicker(default_dir=r"C:\"))
        ...     # select image dialog
        ...     bar5 = Input(widget=FilePicker(
        ...         title="Select an image",
        ...         wildcard='images (*.bmp,*.gif,*.jpg) |*.bmp;*.gif;*.jpg'))
        ...

        :param str | None wildcard: Wildcard-options used to filter out which
            type of files can be selected. Something like:
            `'images (*.bmp,*.gif,*.jpg) |*.bmp;*.gif;*.jpg'`
        :param str | None default_dir: The initial directory the FilePicker
            should open. Set to None to use the operating system its default
            (usually the previous directory from which a file was opened)
        :param str | None title: Title of the file dialog. If set to
            :py:`None`, defaults to "Choose a file"
        :param str | None relative_to_dir: The widget will display the
            path relative to the provided directory. If set to :py:`None`
            it will display the absolute path. (default: :py:`None`)
        :param bool full_path: If set to False, the drive and directory names
            are hidden (only the selected filename will be shown).
            (default: :py:`True`)
        :param kwargs: see :class:`Widget`.
        """
        self.wildcard = wildcard
        self.default_dir = default_dir
        self.title = title
        self.relative_to_dir = relative_to_dir
        self.full_path = full_path
        super(FilePicker, self).__init__(**kwargs)


class ColorPicker(Widget):
    """Results in color picker widget in property grid. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.widgets import ColorPicker
    ...
    >>> class MyClass(Base):
    ...     foo = Input(widget=ColorPicker())
    ...     bar = Input(widget=ColorPicker)  # also fine
    """
    def __init__(self, system=False, **kwargs):
        super(ColorPicker, self).__init__(**kwargs)
        self.system = system


class CheckBox(Widget):
    """Results in checkbox widget in property grid. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.widgets import CheckBox
    ...
    >>> class MyClass(Base):
    ...     foo = Input(widget=CheckBox())
    ...     bar = Input(widget=CheckBox)  # also fine
    ...     # override the values when the box is checked/unchecked
    ...     quz = Input(widget=CheckBox(checked_value='foo',
    ...                                 unchecked_value='bar'))

    """

    def __init__(self, checked_value=True, unchecked_value=False,
                 autocompute=True, **kwargs):
        """A checkbox with 2 states: checked and unchecked.

        :param object checked_value: value passed to the slot when the checkbox
             is checked (default: True).
        :param object unchecked_value: value passed to the slot when the
            checkbox is unchecked (default: False)
        """
        super(CheckBox, self).__init__(autocompute=autocompute, **kwargs)
        self._checked_value = checked_value
        self._unchecked_value = unchecked_value

    @property
    def checked_value(self):
        return self._checked_value

    @property
    def unchecked_value(self):
        return self._unchecked_value


class ObjectPicker(Widget):
    """Results in object picker widget in property grid. Usage:

    >>> from parapy.core import Base, Input
    >>> from parapy.core.widgets import ObjectPicker
    ...
    ...
    >>> def my_validator(selected):
    ...     return len(selected) == 2, "Select 2 objects"
    ...
    ...
    >>> class MyClass(Base):
    ...     # select one object
    ...     foo1 = Input(widget=ObjectPicker())
    ...     # select multiple objects
    ...     foo2 = Input(widget=ObjectPicker(multiple=True))
    ...     # use popup dialog instead of status bar (if present)
    ...     foo3 = Input(widget=ObjectPicker(popup=True))
    ...     # validate selection (2 objects)
    ...     foo4 = Input(widget=ObjectPicker(
    ...         msg="Select 2 planes.", multiple=True, validator=my_validator))

    :param str | None msg: a *short* info message shown at the start of
        each selection action. A standard :attr:`INSTRUCTION_MSG` sentence is
        appended to this ``msg`` explaining which keys to press for submitting
        or cancelling. Example: :py:`"Select 2 planes."`.
    :param bool multiple: If True, the selection (single / multiple
        objects) is returned in a list. If False and a single object is
        selected, the selected object itself is returned.
    :param callable | None validator: like a regular ``validator`` that can be
        specified for slots (:class:`~parapy.core.abstractslot.AbstractSlot`),
        this callback function can validate user selection. Signature:
        ``(value) -> flag | (flag, msg)``, where ``flag`` is either :py:`True`
        (valid) or :py:`False` (invalid). If invalid, the optional ``msg``
        string is shown in a popup dialog (if not specified, a default message
        is shown) and the user stays in selection mode. And ``value`` is:

        - a single :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`False`.
        - a list of :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`True`.
    :param bool popup: if there's a status bar in the top-level window, it will
        be used to show the initial message to the user unless this value is
        :py:`True` in which case a popup dialog is shown. If there's no status
        bar, there will always be a popup dialog irrespective of this value.
    :param bool ask_confirmation: show confirmation dialog on submit?
    """
    def __init__(self, msg=None, multiple=False, validator=None,
                 popup=False, ask_confirmation=False, **kwargs):
        super(ObjectPicker, self).__init__(**kwargs)
        self.msg = msg
        self.multiple = multiple
        self.validator = validator
        self.popup = popup
        self.ask_confirmation = ask_confirmation


class AbstractMultiValueWidget(Widget):
    """Abstract base class for widgets with multiple values."""

    def __init__(self, values, labels=None, str=str, autocompute=True,
                 read_only=False):
        """
        :param collections.Sequence | Enum values: drop-down values.
        :param Optional[collections.Sequence[str]] labels: optional labels. If
            these are defined when ``values`` is an ``Enum``, the values of
            the ``Enum`` are used, but the provided ``labels`` are used
            instead of the enum's names.
        :param str: predicate used to convert value to label. By default,
            built-in ``str` is used. ``repr`` is a good alternative to
            have more Python-exact labels (string with double quotes for
            example).
        :param kwargs: see :class:`Widget`.
        """
        super(AbstractMultiValueWidget, self).__init__(
            autocompute=autocompute, read_only=read_only)

        is_enum = try_issubclass(values, Enum)
        if labels:
            if not len(values) == len(labels):
                msg = "Length of values and label should match"
                raise ValueError(msg)
        else:
            if is_enum:
                labels = list(values.__members__)
            else:
                labels = list(map(str, values))

        if is_enum:
            # attribute ``values`` should be a Sequence due to use of `index`
            self.values = list(values)
        else:
            self.values = values

        self.labels = labels


class Dropdown(AbstractMultiValueWidget):
    """Results in a drop-down widget in GUI data panel. Usage:

    >>> from enum import Enum
    ...
    ... from parapy.core import Base, Input
    ... from parapy.core.widgets import Dropdown
    ...
    ... VALUES = [2.0, "bar", None]
    ... CUSTOM_LABELS = ["2", "bar", "Nothing"]
    ...
    ... class Color(Enum):
    ...     RED = 1
    ...     GREEN = 2
    ...     BLUE = 3
    ...
    ... class MyClass(Base):
    ...
    ...     foo = Input(2.0, widget=Dropdown(VALUES))
    ...     # show string "bar" with surrounding quotes
    ...     bar = Input(2.0, widget=Dropdown(VALUES, str=repr))
    ...     # custom labels
    ...     qux = Input(2.0, widget=Dropdown(VALUES, CUSTOM_LABELS))
    ...     # enums works as well
    ...     quz = Input(2.0, widget=Dropdown(Color))
    """


class MultiCheckBox(AbstractMultiValueWidget):
    """Results in a widget with multiple checkboxes in GUI data panel. Usage:

    >>> from enum import Enum
    ...
    ... from parapy.core import Base, Input
    ... from parapy.core.widgets import MultiCheckBox
    ...
    ... VALUES = [2.0, "bar", None]
    ... CUSTOM_LABELS = ["2", "bar", "Nothing"]
    ...
    ... class Color(Enum):
    ...     RED = 1
    ...     GREEN = 2
    ...     BLUE = 3
    ...
    ... class MyClass(Base):
    ...
    ...     foo = Input(2.0, widget=MultiCheckBox(VALUES))
    ...     # show string "bar" with surrounding quotes
    ...     bar = Input(2.0, widget=MultiCheckBox(VALUES, str=repr))
    ...     # custom labels
    ...     qux = Input(2.0, widget=MultiCheckBox(VALUES, CUSTOM_LABELS))
    ...     # enums works as well
    ...     quz = Input(2.0, widget=MultiCheckBox(Color))
    """

    def __init__(self, values, labels=None, str=str, autocompute=True,
                 read_only=False, autoexpand=True, separator="; "):
        super(MultiCheckBox, self).__init__(values, labels=labels, str=str,
                                            autocompute=autocompute,
                                            read_only=read_only)
        # For children properties
        self.autoexpand = autoexpand
        self.separator = separator


class SingleSelection(AbstractMultiValueWidget):
    """Results in a widget with multiple checkboxes in GUI data panel,
    of which 1 must be selected at all times. Usage:

    >>> from enum import Enum
    ...
    ... from parapy.core import Base, Input
    ... from parapy.core.widgets import MultiCheckBox
    ...
    ... VALUES = [2.0, "bar", None]
    ... CUSTOM_LABELS = ["2", "bar", "Nothing"]
    ...
    ... class Color(Enum):
    ...     RED = 1
    ...     GREEN = 2
    ...     BLUE = 3
    ...
    ... class MyClass(Base):
    ...
    ...     foo = Input(2.0, widget=SingleSelection(VALUES))
    ...     # show string "bar" with surrounding quotes
    ...     bar = Input(2.0, widget=SingleSelection(VALUES, str=repr))
    ...     # custom labels
    ...     qux = Input(2.0, widget=SingleSelection(VALUES, CUSTOM_LABELS))
    ...     # enums works as well
    ...     quz = Input(2.0, widget=SingleSelection(Color))
    """

    def __init__(self, values, labels=None, str=str, autocompute=True,
                 read_only=False, autoexpand=True):
        super(SingleSelection, self).__init__(values, labels=labels, str=str,
                                              autocompute=autocompute,
                                              read_only=read_only)
        # For children properties
        self.autoexpand = autoexpand


class Button(Widget):
    def __init__(self, onclick, label="Click", **kwargs):
        super(Button, self).__init__(**kwargs)
        self.label = label
        self.onclick = onclick


DEFAULT_WIDGET = PyField()

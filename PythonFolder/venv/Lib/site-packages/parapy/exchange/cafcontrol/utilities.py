#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""utilities"""

import logging

from OCC.wrapper import TCollection_AsciiString
from OCC.wrapper.Quantity import Quantity_Color, Quantity_TOC_RGB
from OCC.wrapper.TCollection import TCollection_ExtendedString
from OCC.wrapper.TDF import TDF_Label
from OCC.wrapper.TDataStd import TDataStd_Name
from OCC.wrapper.TopoDS import TopoDS_Builder, TopoDS_Compound
from OCC.wrapper.XCAFDoc import XCAFDoc_ColorGen

from parapy.core.base import Base
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.utilities import get_rgb_value
from parapy.geom.generic.positioning import AbstractPoint, Vector, Orientation


def QuantityColor2RGB(color):
    r, g, b = color.Values(Quantity_TOC_RGB)
    return (int(r * 255), int(g * 255), int(b * 255))


def RGB2QuantityColor(color):
    return Quantity_Color(color[0] / 255, color[1] / 255, color[2] / 255,
                          Quantity_TOC_RGB)


def safe_children_generator(obj):
    """True children generator for GUI tree. Includes all ``_tree_slots`` and corresponding values.
    Returns an Exception object if something failed, Writer will know what to do.

    Arguments:
        obj (Base)
    """

    for slot_name, slot in sorted(obj._tree_slots.items()):
        try:
            child_obj = slot.__get__(obj)
        except Exception as e:
            logging.warning("Evaluation of tree slot %s.%s failed"
                            " Message: %s" % (obj.refchain, slot_name, e),
                            exc_info=True)
        else:
            if child_obj:  # filters out Undefined and []
                if isinstance(child_obj, Base):
                    try:
                        hidden = obj.hidden
                    except Exception as e:
                        logging.warning("Evaluation of tree slot %s.%s failed"
                                        " Message: %s" % (child_obj.refchain, "hidden", e),
                                        exc_info=True)
                        hidden = True
                    if not hidden:
                        yield slot_name, child_obj 
                # FIXME: filter out AbstractPoint, etc, better
                elif hasattr(child_obj, "__iter__") and not isinstance(obj, (AbstractPoint, Vector, Orientation)):
                    # FIXME: not lazy enough!!!
                    if not len(child_obj) == 0:
                        yield slot_name, child_obj
                else:
                    yield slot_name, child_obj 


def pp_to_xcaf(obj):
    """Takes any ParaPy object and returns a XCAF-appropriate shape or fails.

    :returns: TopoDS_Shape (success) or None (failure or not convertable)
    :rtype: OCC.TopoDS.TopoDS_Shape | None
    """
    if hasattr(obj, "_xcaf_shape"):
        try:
            return obj._xcaf_shape()
        except Exception as e:
            msg = ("Conversion to STEP/IGES shape failed. Object: {}. "
                   "Message: '{}'")
            logging.warning(msg.format(obj, e), exc_info=True)
            return None
    else:
        return None


def TDF_LabelSequence_walker(seq):
    """:type seq: OCC.TDF.TDF_LabelSequence"""
    for i in range(1, seq.Length() + 1):
        yield seq.Value(i)


def tree_fill(instance, shape_tool, color_tool):
    """Creates a hierarchy in XCAF"""

    comp, comp_dict = make_tree_compound(instance)

    shape_tool.AddShape(comp)

    # now add names and colors to the TDF_labels.
    for shape, [name, obj] in comp_dict.items():
        tdf_label = shape_tool.FindShape(shape)
        if tdf_label.IsNull():
            logging.warning("No label found for: {:}".format(obj))
            continue

        set_tdf_label_name(tdf_label, name)

        if isinstance(obj, Base):
            # color
            color = try_base_color(obj)
            if color:
                color_tool.SetColor(tdf_label, color, XCAFDoc_ColorGen)


def node_fill(instances, shape_tool, color_tool):
    """Creates a flat list in XCAF"""

    for obj in instances:
        shape = pp_to_xcaf(obj)
        if shape is not None:
            tdf_label = shape_tool.AddShape(shape)

            if isinstance(obj, Base):

                # name
                name = (try_base_label(obj) or obj.__role__
                        if obj._parent else None)
                if name:
                    set_tdf_label_name(tdf_label, name)

                # color
                color = try_base_color(obj)
                if color:
                    color_tool.SetColor(tdf_label, color, XCAFDoc_ColorGen)


def make_tree_compound(instance):

    builder = TopoDS_Builder()

    def dual_walker(obj, owner_compound, visited, my_name):
        """Args:
            obj (Python)
            owner (TopoDS_Compound)
            visited (dict)
            my_name (str)
        """

        if isinstance(obj, Base):

            # first check my name
            label = try_base_label(obj) or my_name

            # multiple cases possible:
            # 1. YES children and YES own shape -> set compound AND children, return compound
            # 2. YES children and NO  own shape -> set shape
            # 3. NO children  and YES own shape -> return shape AND visited
            # 4. NO children  and NO  own shape -> Void

            children = list(safe_children_generator(obj))  # [[name, obj], [name, obj]]

            if children:  # YES children, so I'm an assembly TopoDS_Compound

                my_compound = TopoDS_Compound()
                builder.MakeCompound(my_compound)

                shape = pp_to_xcaf(obj)
                if shape:
                    builder.Add(my_compound, shape)

                status = [dual_walker(child_object, my_compound, visited, child_name)
                          for child_name, child_object in children]

                if any(status):
                    # YES Children
                    builder.Add(owner_compound, my_compound)
                    if shape:
                        logging.info("assembly and shape!", obj)
                        visited[my_compound] = [label + "_ASSEMBLY", obj]
                        visited[shape] = [label, obj]
                    else:
                        logging.info("assembly without own shape: {:}".format(obj))
                        visited[my_compound] = [label, obj]
                    return True
                elif shape:
                    # NO good children after all... don't use my_compound at all
                    logging.info("shape with failed children: {:}".format(obj))
                    builder.Add(owner_compound, shape)
                    visited[shape] = [label, obj]
                    return True
                else:
                    logging.info("I'm not any good: {:}".format(obj))
                    return False

            else:  # NO children, so I'm a TopoDS_Shape
                shape = pp_to_xcaf(obj)
                if shape:
                    # case 3
                    logging.info("only a shape: {:}".format(obj))
                    builder.Add(owner_compound, shape)
                    visited[shape] = [my_name, obj]
                    return True
                else:
                    logging.info("I'm not any good: {:}".format(obj))
                    return False

        # FIXME (TBD): add easier way to isolate AbstractPoint, Vector,
        # /fixme Orientation out from __iter__.
        elif hasattr(obj, "__iter__") and not \
                isinstance(obj, (AbstractPoint, Vector, Orientation)):
            # sequence or iterable of shapes

            my_compound = TopoDS_Compound()
            builder.MakeCompound(my_compound)

            status = [dual_walker(child_object, my_compound, visited, str(idx))
                      for idx, child_object in enumerate(obj)]

            if any(status):
                # YES Children
                builder.Add(owner_compound, my_compound)
                visited[my_compound] = [my_name, obj]
                return True
            else:
                return False

        else:
            # Point, Position, etc.
            shape = pp_to_xcaf(obj)
            if shape:
                builder.Add(owner_compound, shape)
                visited[shape] = [my_name, obj]
                return True
            else:
                return False

    comp_dict = {}
    top_level_compound = TopoDS_Compound()
    builder.MakeCompound(top_level_compound)
    root_name = try_base_label(instance) or "ROOT"
    dual_walker(instance, top_level_compound, comp_dict, root_name)
    comp_dict[top_level_compound] = [root_name, instance]
    return top_level_compound, comp_dict


def try_base_label(obj):
    try:
        return obj.label
    except Exception as e:
        logging.warning("Exchange: Evaluation of %s.label failed."
                        " Message:%s" % (obj, e),
                        exc_info=True)
        return None


def try_base_color(obj):
    try:
        color = obj.color
    except Exception as e:
        logging.warning("Exchange: Evaluation of %s.color failed."
                        " Message:%s" % (obj, e),
                        exc_info=True)
        return None
    else:
        return RGB2QuantityColor(get_rgb_value(color))


def get_tdf_label_name(label):
    """Get TDataStd_Name attribute value on TDF_Label. Returns None if, label
    has not name attached

    :param OCC.TDF.TDF_Label label:
    :rtype: str | None
    """
    if not label.IsNull():
        # h_a = Handle_TDataStd_Name()
        h_a = TDataStd_Name().handle
        if label.FindAttribute(h_a.ID(), h_a):
            name = TCollection_AsciiString(h_a.Get())
            return name.ToCString()


def set_tdf_label_name(label, name):
    """Set (or update) TDataStd_Name attribute value on TDF_Label

    :param OCC.TDF.TDF_Label label:
    :param str name: name that should be given to the label
    """
    s = TCollection_ExtendedString(name, True)
    h_a = TDataStd_Name().handle
    if label.FindAttribute(h_a.ID(), h_a):
        h_a.Set(s)
    else:
        h_a.Set(s)
        label.AddAttribute(h_a)


def get_tdf_label_reference(label, shape_tool):
    """Tests if TDF_Label is actually referring to another label.

    :param OCC.TDF.TDF_Label label:
    :param OCC.XCAFDoc.Handle_XCAFDoc_ShapeTool shape_tool:
    :rtype: TDF_Label | None
    """
    reference = TDF_Label()
    is_reference = shape_tool.GetReferredShape(label, reference)
    if not is_reference:
        return None
    else:
        return reference

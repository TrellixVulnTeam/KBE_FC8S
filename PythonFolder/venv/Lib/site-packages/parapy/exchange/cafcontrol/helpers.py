#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import io
import warnings

from OCC.wrapper.Interface import Interface_Static
from OCC.wrapper.Quantity import Quantity_Color
from OCC.wrapper.TCollection import TCollection_ExtendedString
from OCC.wrapper.TDF import TDF_LabelSequence
from OCC.wrapper.TDocStd import Handle_TDocStd_Document
from OCC.wrapper.TopAbs import TopAbs_COMPOUND
from OCC.wrapper.XCAFApp import XCAFApp_Application_GetApplication
from OCC.wrapper.XCAFDoc import (
    XCAFDoc_ColorCurv, XCAFDoc_ColorGen, XCAFDoc_ColorSurf,
    XCAFDoc_DocumentTool)
from OCC.wrapper.gp import gp_Trsf
from OCC.utils.top import compound_sub_shapes
from OCC.utils.utilities import QuantityColor_rgb

from parapy.core.globs import DEFAULT_COLOR_RGB
from parapy.exchange.cafcontrol.utilities import (
    TDF_LabelSequence_walker, get_tdf_label_name, get_tdf_label_reference)

DEFAULT_NAME = "--NONAME--"


class XCAFLabel(object):
    """Wraps TDF_Label in XCAF document"""

    __slots__ = ('label', 'root', 'transformation')

    def __init__(self, label, root, trsf):
        """
        :param OCC.TDF.TDF_Label label: the label of this assembly
        :param XCAFRoot root: the root object owning this assembly
        :param OCC.gp.gp_Trsf trsf: transformation needed to put this
            element in the global axis system.
        """
        self.label = label
        self.root = root

        # trsf is the transformation of the parent. Multiply it by our own
        # transformation to get the real transformation needed to position this
        # object in the global axis system.
        if label.IsNull():
            # sometimes shapes are set which do not correspond to labels, for
            # instance when unpacking compounds.
            local_trsf = gp_Trsf()
        else:
            local_trsf = root.shape_tool.GetLocation(label).Transformation()
        self.transformation = trsf.Multiplied(local_trsf)

    def children(self):
        """Yields all STEP assemblies and shapes found in this label.

        :rtype: collections.Iterator[XCAFLabel]
        """
        raise NotImplementedError()

    def name(self):
        return self.tdf_name() or self.entity_name()

    def tdf_name(self):
        return get_tdf_label_name(self.label)

    def compose(self, label):
        root = self.root
        st = root.shape_tool
        trsf = self.transformation
        if st.IsAssembly(label):
            return XCAFAssembly(label, root, trsf)
        elif st.IsReference(label):
            return XCAFReference(label, root, trsf)
        elif st.IsSimpleShape(label):
            return XCAFShape(label, root, trsf)
        else:
            msg = "Convertable label"
            raise RuntimeError(msg)

    def entity_name(self):
        return self.root._entity_name(self.label)

    def id(self):
        return self.root._entity_id(self.label)

    def info(self):
        stream = io.BytesIO('')
        self.label.Dump(stream)
        return stream.getvalue().decode('ascii')

    def print_tree(self):

        def walk(obj, level=0):
            tab = "\t" * level
            type_name = obj.__class__.__name__
            msg = "{}type={} name={} id={}".format(tab, type_name, obj.name(),
                                                   obj.id())
            if isinstance(obj, XCAFShape):
                msg += " color={}".format(obj.color())

            for sublabel in obj.children():
                walk(sublabel, level=level + 1)

        walk(self)


class XCAFRoot(XCAFLabel):

    def __init__(self, default_name=DEFAULT_NAME, settings=None,
                 color_mode=True, name_mode=True, layer_mode=True):
        """
        :param str default_name: default name for label without name
        """
        self.settings = settings or {}
        self.default_name = default_name
        self.color_mode = color_mode
        self.name_mode = name_mode
        self.layer_mode = layer_mode

        #: :type: str
        self.filename = None
        #: :type: OCC.IGESCAFControl.IGESCAFControl_Reader | OCC.STEPCAFControl.STEPCAFControl_Reader
        self.reader = None
        #: :type: OCC.IGESCAFControl.IGESCAFControl_Writer | OCC.STEPCAFControl.STEPCAFControl_Writer
        self.writer = None
        #: :type: OCC.XSControl.XSControl_Reader
        self.xs_control_reader = None
        #: :type: OCC.IGESData.IGESData_IGESModel | OCC.StepData.StepData_StepModel
        self.model = None
        #: :type: OCC.XSControl.XSControl_TransferReader
        self.transfer_reader = None

        self.app = XCAFApp_Application_GetApplication()
        self.doc = doc = Handle_TDocStd_Document()
        self.app.NewDocument(TCollection_ExtendedString("MDTV-CAF"), doc)
        self.tool = XCAFDoc_DocumentTool().handle

        label = self.doc.Main()

        self.shape_tool = self.tool.ShapeTool(label)
        self.color_tool = self.tool.ColorTool(label)

        super(XCAFRoot, self).__init__(label, self, gp_Trsf())

    def read(self, filename):
        """
        :param str filename: file to read
        """
        self.reader = reader = self._init_reader()
        """:type: OCC.IGESCAFControl.IGESCAFControl_Reader | OCC.STEPCAFControl.STEPCAFControl_Reader """
        reader.SetColorMode(self.color_mode)
        reader.SetNameMode(self.name_mode)
        reader.SetLayerMode(self.layer_mode)

        status = reader.ReadFile(filename)
        if status != 1:
            msg = "Reading file failed. File: '{}'."
            raise RuntimeError(msg.format(filename))

        nb = reader.NbRootsForTransfer()
        msg = "Found {} top-level assembl{} in file: '{}'"
        print(msg.format(nb, 'y' if nb == 1 else 'ies', filename))

        with Interface_Static_Manager(self.settings):
            status = reader.Transfer(self.doc)
            if not status:
                msg = "Transfer of read contents failed. File: '{}'."
                raise RuntimeError(msg.format(filename))

            self.model = self._init_interface_model()
            self.xs_control_reader = self._init_xs_control_reader()
            self.transfer_reader = self.xs_control_reader.WS().TransferReader()

        self.filename = filename

    def write(self, filename):
        """
        :param str filename: file to read
        """

        with Interface_Static_Manager(self.settings):
            self.writer = writer = self._init_writer()

            """:type: OCC.IGESCAFControl.IGESCAFControl_Reader | OCC.STEPCAFControl.STEPCAFControl_Reader"""
            writer.SetColorMode(self.color_mode)
            writer.SetNameMode(self.name_mode)
            writer.SetLayerMode(self.layer_mode)

            status = writer.Perform(self.doc, filename)
            if not status:
                msg = "Writing failed. File: '{}'."
                raise RuntimeError(msg.format(filename))

        self.filename = filename

    def close(self):
        self.app.Close(self.doc)

    def children(self):
        """Yields all STEP assemblies and shapes found in this document.

        :rtype: collections.Iterator[XCAFLabel]
        """
        st = self.shape_tool

        seq = TDF_LabelSequence()
        st.GetFreeShapes(seq)

        for label in TDF_LabelSequence_walker(seq):
            yield self.compose(label)

    def _entity_name(self, label):
        """If name could not be found from TDF_Label, alternative name
        will be returned here.

        :param OCC.TDF.TDF_Label label: label object
        :rtype: str
        """
        topods_shape = self.shape_tool.GetShape(label)
        if topods_shape.IsNull():
            return self.default_name
        else:
            return self._entity_name_from_topods_shape(topods_shape)

    def _entity_name_from_topods_shape(self, topods_shape, mode=1):
        handle = self.transfer_reader.EntityFromShapeResult(topods_shape, mode)
        if handle.IsNull():
            return self.default_name
        else:
            return self._handle_name(handle)

    def _entity_id(self, label):
        topods_shape = self.shape_tool.GetShape(label)
        if topods_shape.IsNull():
            return None
        else:
            return self._entity_id_from_topods_shape(topods_shape)

    def _entity_id_from_topods_shape(self, topods_shape, mode=1):
        handle = self.transfer_reader.EntityFromShapeResult(topods_shape, mode)
        if handle.IsNull():
            return None
        return self.model.StringLabel(handle).ToCString()

    def _init_reader(self):
        """:rtype: OCC.IGESCAFControl.IGESCAFControl_Reader |
            OCC.STEPCAFControl.STEPCAFControl_Reader
        """
        raise NotImplementedError()

    def _init_writer(self):
        """:rtype: OCC.IGESCAFControl.IGESCAFControl_Writer |
            OCC.STEPCAFControl.STEPCAFControl_Writer
        """
        raise NotImplementedError()

    # ---- abstract methods ----
    def _init_xs_control_reader(self):
        """:rtype: OCC.XSControl.XSControl_Reader"""
        raise NotImplementedError()

    def _init_interface_model(self):
        """:rtype: OCC.IGESData.IGESData_IGESModel |
            OCC.StepData.StepData_StepModel
        """
        raise NotImplementedError()

    def _handle_name(self, handle):
        """
        :param OCC.Standard.Handle_Standard_Transient handle:
        :rtype: str
        """
        raise NotImplementedError()


class XCAFAssembly(XCAFLabel):
    """An assembly inside a XCAF document."""

    __slots__ = ()

    def __init__(self, label, root, trsf):
        if not root.shape_tool.IsAssembly(label):
            msg = "XCAFAssembly instantiated with non-Assembly label"
            raise RuntimeError(msg)
        super(XCAFAssembly, self).__init__(label, root, trsf)

    def children(self):
        """Sub-assemblies and sub-shapes of this assembly

        :rtype: collections.Iterator[XCAFLabel]
        """
        label, root = self.label, self.root
        st = root.shape_tool

        seq = TDF_LabelSequence()
        has_components = st.GetComponents(label, seq, False)
        if has_components:
            for sublabel in TDF_LabelSequence_walker(seq):
                yield self.compose(sublabel)
        else:
            msg = "Found assembly without components: '{}'."
            warnings.warn(msg.format(self.name()))


class XCAFReference(XCAFLabel):
    """An assembly inside a XCAF document."""

    __slots__ = ("referred",)

    def __init__(self, label, root, trsf):
        st = root.shape_tool
        if not st.IsReference(label):
            msg = "XCAFReference instantiated with non-reference label"
            raise RuntimeError(msg)

        super(XCAFReference, self).__init__(label, root, trsf)

        self.referred = get_tdf_label_reference(label, st)

    def refers_assembly(self):
        return self.root.shape_tool.IsAssembly(self.referred)

    def children(self):
        label, root = self.label, self.root
        st = root.shape_tool

        seq = TDF_LabelSequence()
        has_components = st.GetComponents(label, seq, False)

        if has_components:
            msg = ("XCAFReference '{}' is a reference, but has components on "
                   "itself as well. These will be skipped.")
            warnings.warn(msg.format(self.name()))

        yield self.compose(self.referred)


class XCAFShape(XCAFLabel):
    """A TopoDS_Shape in a CAFDoc."""

    __slots__ = ("topods_shape", "has_children", "_seq")

    def __init__(self, label, root, trsf, topods_shape=None):
        super(XCAFShape, self).__init__(label, root, trsf)

        st = root.shape_tool
        #: :type: OCC.TopoDS.TopoDS_Shape
        topods_shape = topods_shape or st.GetShape(label)
        #: :type: OCC.TopoDS.TopoDS_Shape
        self.topods_shape = topods_shape
        #: :type: bool
        self.has_children = topods_shape.ShapeType() is TopAbs_COMPOUND

    def name(self):
        return self.entity_name()

    def children(self):
        """A list of all sub-shapes of this shape (if compound).

        :rtype: collections.Iterator[XCAFShape]
        """
        if self.has_children:
            root = self.root
            st = root.shape_tool
            # if it is a compound, we return the labels of the sub shapes
            if self.topods_shape.ShapeType() is TopAbs_COMPOUND:
                my_trsf = self.transformation
                for sub_shape in compound_sub_shapes(self.topods_shape):
                    label = st.FindShape(sub_shape)
                    yield XCAFShape(label, root, my_trsf, sub_shape)

    def color(self):
        """The color of this shape in RGB.

        :return: tuple[int]
        """
        ct = self.root.color_tool

        color = Quantity_Color()
        topods_shape = self.topods_shape
        flag = ct.GetColor(topods_shape, XCAFDoc_ColorGen, color)
        if not flag:
            flag = ct.GetColor(topods_shape, XCAFDoc_ColorSurf, color)
        if not flag:
            flag = ct.GetColor(topods_shape, XCAFDoc_ColorCurv, color)

        if flag:
            return QuantityColor_rgb(color)
        else:
            return DEFAULT_COLOR_RGB

    def id(self):
        return self.root._entity_id_from_topods_shape(self.topods_shape)

    def entity_name(self):
        return self.root._entity_name_from_topods_shape(self.topods_shape)


class Interface_Static_Manager(object):
    """Context in which one can set Interface_Static values. Context will
    reset back to original values when exiting. Usage:

    >>> settings = {"write.step.schema": "AP203"}
    >>> with Interface_Static_Manager(settings):
    ...     # do stuff
    """
    def __init__(self, settings, verbose=False):
        self.new_settings = settings
        self.old_settings = {}
        self.verbose = verbose

    def __enter__(self):
        cache = self.old_settings
        verbose = self.verbose
        for name, new in self.new_settings.items():
            old = self.set_value(name, new)
            cache[name] = (old, new)
            if verbose and old != new:
                print(("Updated Interface_Static name '{}'\n"
                       "    Old: {}\n"
                       "    New: {}").format(name, repr(old), repr(new)))

    def __exit__(self, type, value, traceback):
        verbose = self.verbose
        for name, (old, new) in self.old_settings.items():
            self.set_value(name, old)
            if verbose and old != new:
                print(("Reset Interface_Static name '{}'\n"
                       "    Reset: {}").format(name, repr(old)))

    @staticmethod
    def set_value(name, val):
        """Set Interface_Static defined by `name` to value `val`, return
        original value.
        """
        if isinstance(val, int):
            getter = Interface_Static.IVal
            setter = Interface_Static.SetIVal
        elif isinstance(val, float):
            getter = Interface_Static.RVal
            setter = Interface_Static.SetRVal
        elif isinstance(val, str):
            getter = Interface_Static.CVal
            setter = Interface_Static.SetCVal
        else:
            raise ValueError("either int, real or string")

        old = getter(name)
        setter(name, val)
        return old

    @staticmethod
    def get_int(name):
        return Interface_Static.IVal(name)

    @staticmethod
    def get_real(name):
        return Interface_Static.RVal(name)

    get_float = get_real

    @staticmethod
    def get_str(name):
        return Interface_Static.CVal(name)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""CAFControl_Writer base class for STEP and IGES writers."""

import logging
import os

from parapy.core import Input, Attribute, FileWriter, ensure_iterable
from parapy.exchange.cafcontrol.utilities import tree_fill, node_fill
from parapy.exchange.cafcontrol.writer_patch import apply_patch

from parapy.exchange.globs import ICN_DIR

apply_patch()


def identity(v):
    return v


class CAFControl_Writer(FileWriter):
    """Abstract Base Class for STEPReader and IGESReader"""

    __icon__ = os.path.join(ICN_DIR, 'export.png')
    __initargs__ = ["nodes", "filename"]

    file_or_dir = "file"

    #: list of shapes to export
    #: :type: collections.Sequence[parapy.core.abstract.DrawableParaPyObject]
    nodes = Input([])

    #: node and children of each tree are exported.
    #: :type: collections.Sequence[parapy.core.Base]
    trees = Input([])

    #: An optional dict with key-value pairs. Valid names and
    #: values are found in the link below. E.g.::
    #:
    #:     settings = {"read.precision.mode": 1,
    #:                 "read.precision.val": 1.0e-3,
    #:                 "xstep.cascade.unit": "MM"}
    #:
    #: https://www.opencascade.com/doc/occt-7.1.0/overview/html/
    #: occt_user_guides__step.html#occt_step_7
    #:
    #: :type: dict[str, T]
    settings = Input({})

    #: Write colors or not? Default: True.
    #: :type: bool
    color_mode = Input(True)

    #: Write names or not? Default: True.
    #: :type: bool
    name_mode = Input(True)

    #: Write layers or not? Default: True.
    #: :type: bool
    layer_mode = Input(True)

    def _provide_parapy_inputs_to_occ_mapping(self):
        """Maps ParaPy name to OCC key, e.g.
        :py:`{'schema': 'write.step.schema'}`. One may also provide
        a converter function, i.e. a function that can convert the ParaPy
        value to a value that OCC expects. For example, to convert a bool to
        and int, viz.
        :py:`{"brep_mode": ("write.iges.brep.mode", lambda v: 1 if v else 0)}`.

        :rtype: dict[str, str | (str, Callable)]
        """
        raise NotImplementedError()

    def _init_helper(self):
        """:rtype: parapy.exchange.cafcontrol.helpers.XCAFRoot"""
        raise NotImplementedError()

    @Attribute
    def _merged_settings(self):
        """Merges inputs from ``settings`` with some dedicated Input slots.
        Checks for duplicates keys. Returns merged dict with OCC keys mapped
        to values.
        """
        settings = self.settings.copy()
        dct = self._provide_parapy_inputs_to_occ_mapping()
        for slotname, token in dct.items():
            if isinstance(token, str):
                key_occ, converter = token, identity
            else:
                key_occ, converter = token

            value = getattr(self, slotname)
            value_occ_from_slot = converter(value)

            # resolve duplicate definition
            if key_occ in settings:
                value_occ_explicit = settings[key_occ]
                match = value_occ_from_slot == value_occ_explicit
                user_defined = not(value is None or
                                   not self.is_user_defined(slotname))

                if match:
                    if user_defined:
                        msg = ("Found double definition of '{0}', both in "
                               "Input 'settings' and Input '{1}. Use Input "
                               "'{1}' instead.")
                        logging.warning(msg.format(key_occ, slotname))
                    else:
                        msg = ("Found definition of '{0}' in Input 'settings'."
                               " Use Input '{1}' instead.")
                        logging.warning(msg.format(key_occ, slotname))
                else:
                    # not explicitly defined by user, so settings prevails
                    if user_defined:
                        msg = ("Found double definition of '{0}' with "
                               "different values. Value ({1}) was "
                               "assigned in Input 'settings', but value ({2}) "
                               "was given in dedicated Input '{3}'. "
                               "Use Input '{3}' only.")
                        raise RuntimeError(msg.format(
                            key_occ, value_occ_explicit, value_occ_from_slot,
                            slotname))
                    else:
                        msg = ("Found definition of '{0}' in 'settings'. "
                               "Use Input '{1}' instead.")
                        logging.warning(msg.format(key_occ, slotname))

            elif value is not None:
                settings[key_occ] = value_occ_from_slot

        return settings

    @Attribute
    def _xcaf_helper(self):
        helper = self._init_helper()
        trees, nodes = self.trees, self.nodes
        shape_tool, color_tool = helper.shape_tool, helper.color_tool

        if trees:
            trees = ensure_iterable(trees)
            for obj in trees:
                tree_fill(obj, shape_tool, color_tool)
        if nodes:
            nodes = ensure_iterable(nodes)
            node_fill(nodes, shape_tool, color_tool)

        return helper

    def write(self, pathname=None):
        """Invoked from GUI or from within source code.

        :param str pathname: file to read from
        :param XCAFRoot helper: helper object for reading
        """
        filename = self.resolve_pathname(pathname)
        helper = self._xcaf_helper
        helper.write(filename)
        print("written:", filename)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os

from parapy.core import Attribute, Base, Input, ensure_iterable, flatten
from parapy.core.part import PartNoParsing
from parapy.geom.occ.brep import ClonedShape
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.utilities import (
    is_shape_like, make_TopoDS_Compound, topods_shape_getter)
from parapy.mesh.globs import ICN_DIR


#==================================================================================================
# Library of meshing hypotheses and algorithms
#==================================================================================================


class MeshControl(DrawableShape):
    """Abstract base class for all hypotheses"""

    DIMENSION = -1

    shape_to_mesh = Input(defaulting=True)
    shape         = Input(shape_to_mesh,
                          doc=\
                          "the shape to apply the hypothesis to. Could be an edge or face of the"
                          " main geometry, etc, or a list of these. If you want to use global"
                          " hypothesis, no need to specify this, it will default to shape_to_mesh."
                          " Integers are also allowed")
    #indices = Input(None, "If you give a list of integers, we retrieve the sub-shape by index.")

    def _shape_from_identifier(self, identifier, dimension=None):
        if is_shape_like(identifier):
            return identifier
        elif isinstance(identifier, int):
            owner = self.shape_to_mesh
            dimension = dimension or self.DIMENSION
            if dimension == 1:
                return owner.edges[identifier]
            elif dimension == 2:
                return owner.faces[identifier]
            elif dimension == 3:
                return owner.solids[identifier]
            else:
                raise RuntimeError("Each MeshControl should have a DIMENSION in range 1..3")
        else:
            raise ValueError("identifier should be a BRep or integer, not {:}".format(identifier))

    @Attribute
    def shapes(self):
        """List of shapes"""
        shapes = ensure_iterable(self.shape)
        f = self._shape_from_identifier
        return [f(shape) for shape in shapes]

    @Attribute
    def TopoDS_Shape(self):
        """TopoDS_Shape of single shape or TopoDS_Compound if multiple shapes"""
        shapes = self.shapes
        if len(shapes) == 1:
            return shapes[0].TopoDS_Shape
        else:
            # make compound shape
            return make_TopoDS_Compound(map(topods_shape_getter, shapes))


class MeshControl0D(MeshControl):

    DIMENSION = 0


class MeshControl1D(MeshControl):

    DIMENSION = 1


class MeshControl2D(MeshControl):

    DIMENSION = 2


class MeshControl3D(MeshControl):

    DIMENSION = 3


class Controls(Base):
    """Useful mixin for user-defined classes that contain @Part objects with
    MeshControl instances. All instances of type MeshControl can be accessed
    in the :attr:`controls` slot.
    """

    __icon__ = os.path.join(ICN_DIR, 'controls.png')
    __reserved__ = ['controls']

    shape_to_mesh = Input(defaulting=True)
    """The shape to mesh. Slot defaults to value of ``shape_to_mesh`` of any
    tree ancestor.

    :type: parapy.geom.occ.drawable.DrawableShape
    """

    @Attribute
    def controls(self):
        """List of MeshControl objects.

        :rtype: list[parapy.mesh.core.MeshControl]
        """
        children = flatten(self.children)
        children = [obj for obj in children if isinstance(obj, MeshControl)]
        return children


class _Projection(Base):
    """Mixin for projection operations"""

    source_shape = Input(doc=\
                         "Source of the projection or list of sources. You have to specify"
                         " this. As for shape, this can be a single shape/int or list of these")

    @Attribute
    def source_shapes(self):
        """List of shapes"""
        shapes = ensure_iterable(self.source_shape)
        f = self._shape_from_identifier
        return [f(shape) for shape in shapes]

    @Attribute
    def TopoDS_Shape_source(self):
        shapes = self.source_shapes
        if len(shapes) == 1:
            return shapes[0].TopoDS_Shape
        else:
            return make_TopoDS_Compound(shapes)

    @Attribute
    def projection_case(self):
        """Returns one-to-many or many-to-many"""
        L1 = len(self.shapes); L2 = len(self.source_shapes)
        if L1 == 0:
            raise ValueError("Number of shapes can not be zero. Check input.")
        elif L2 == 0:
            raise ValueError("Number of source shapes can not be zero. Check input.")
        elif L1 > 1 and L2 > 1:
            if not L1 == L2:
                raise ValueError("""Number of shapes (%i) and source_shapes (%i) should match for
                many-to-many projection""" % (L1, L2))
            return "many-to-many"
        elif L1 == 1 and L2 > 1:
            raise ValueError("Many-to-one projection (%i -> i%i) is not allowed, check input."\
                              % (L2, L1))
        else:
            return "one-to-many"

    @PartNoParsing(label="source_shape")
    def source_shape_(self):
        return ClonedShape(self.TopoDS_Shape_source, color="GREEN")

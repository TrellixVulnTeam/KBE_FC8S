#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines Base Zone objects"""

import os

from parapy.core import (
    Attribute, Base, Input, Part, child, derived, ensure_iterable, flatten)
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.utilities import (
    is_shape_like, make_TopoDS_Compound,
    topods_shape_getter)
from parapy.mesh.globs import ICN_DIR


class MeshGroup(DrawableShape):
    """Mixin for all group specs"""

    __initargs__ = ("shape", "label")
    DIMENSION = None
    SMESH_Group_ = None

    #: Either single shape/integer or a list of these.
    #: :type: parapy.geom.occ.drawable.DrawableShape | int | collections.Iterable[parapy.geom.occ.drawable.DrawableShape | int]
    shape = Input()

    #: The Shape that is used to find the shapes for this group
    #: when integers are used in :attr:`shape`. You need to provide a
    #: value when this MeshGroup is not a child of an object that specifies
    #: ``shape_to_mesh`` (usually class:`~parapy.mesh.core.groups.Groups`).
    #: :type: parapy.geom.occ.drawable.DrawableShape
    owner = Input(defaulting='shape_to_mesh')

    #: name of this group name
    label = Input(derived)

    @label.getter
    def label(self):
        return str(self.__role__)

    @Attribute
    def shapes(self):
        """List of shapes"""
        shapes = ensure_iterable(self.shape)
        return list(map(self._shape_from_identifier, shapes))

    @Attribute
    def TopoDS_Shape(self):
        shapes = self.shapes
        if len(shapes) == 1:
            return shapes[0].TopoDS_Shape
        else:
            return make_TopoDS_Compound(map(topods_shape_getter, shapes))

    def _shape_from_identifier(self, identifier, dimension=None):
        dimension = dimension or self.DIMENSION
        if is_shape_like(identifier):
            shape = identifier
        elif isinstance(identifier, int):
            owner = self.owner
            if dimension == 0:
                shape = owner.vertices[identifier]
            elif dimension == 1:
                shape = owner.edges[identifier]
            elif dimension == 2:
                shape = owner.faces[identifier]
            elif dimension == 3:
                shape = owner.solids[identifier]
            else:
                msg = "Each MeshControl should have a DIMENSION in range 0..3"
                raise RuntimeError(msg)
        else:
            msg = "identifier should be a BRep or integer, not {:}."
            raise ValueError(msg.format(repr(identifier)))
        
        # check dimension
        if shape.TOPODIM != dimension:
            msg = "Shape dimension {} doesn't match zone dimension {}"
            raise ValueError(msg.format(shape.TOPODIM, dimension))
        else:
            return shape


class VertexGroup(MeshGroup):

    __icon__ = os.path.join(ICN_DIR, 'point.png')
    DIMENSION = 0


class EdgeGroup(MeshGroup):

    __icon__ = os.path.join(ICN_DIR, 'curve.png')
    DIMENSION = 1


class FaceGroup(MeshGroup):

    __icon__ = os.path.join(ICN_DIR, 'surface.png')
    DIMENSION = 2


class SolidGroup(MeshGroup):

    __icon__ = os.path.join(ICN_DIR, 'solid.png')
    DIMENSION = 3


class Groups(Base):
    """Basically mix this into your class and define @Part Group objects. This
    is the required input for parapy.mesh.salome.Mesh class. Usage::
    
        class MyGroups(Groups):
        
            @Part
            def inlet(self):
                return FaceGroup(self.shape_to_mesh.bottom_face)
            
            @Part
            def outlet(self):
                return FaceGroup(self.shape_to_mesh.bottom_face)

            @Part
            def walls(self):
                return FaceGroup(list(set(self.shape_to_mesh.faces) -
                                      set([self.shape_to_mesh.bottom_face,
                                           self.shape_to_mesh.top_face])))
    """

    __icon__ = os.path.join(ICN_DIR, 'zones.png')
    __reserved__ = ['zones']

    #: The shape to mesh
    #: :type: parapy.geom.BRep
    shape_to_mesh = Input(defaulting=True, trickle_down=True)

    @Attribute
    def groups(self):
        """List of Group objects objects"""
        return [obj for obj in flatten(self.children)
                if isinstance(obj, MeshGroup)]


class AllVertices(Groups):
    """associate all topological sub-shapes to their mesh elements"""

    @Part
    def vertices(self):
        return VertexGroup(quantify=len(self.shape_to_mesh.vertices),
                           map_down="shape_to_mesh.vertices->shape",
                           label="vertex" + str(child.index))


class AllEdges(Groups):
    """associate all topological sub-shapes to their mesh elements"""

    @Part
    def edges(self):
        return EdgeGroup(quantify=len(self.shape_to_mesh.edges),
                         map_down="shape_to_mesh.edges->shape",
                         label="edge" + str(child.index))


class AllFaces(Groups):
    """associate all topological sub-shapes to their mesh elements"""

    @Part
    def faces(self):
        return FaceGroup(quantify=len(self.shape_to_mesh.faces),
                         map_down="shape_to_mesh.faces->shape",
                         label="face" + str(child.index))


class AllSolids(Groups):
    """associate all topological sub-shapes to their mesh elements"""

    @Part
    def solids(self):
        return SolidGroup(quantify=len(self.shape_to_mesh),
                          map_down="shape_to_mesh.solids->shape",
                          label="solid" + str(child.index))


class AllZones(AllEdges, AllFaces, AllSolids):
    """associate all topological sub-shapes to their mesh elements"""


class FaceGroups(Groups):
    """Quickly associated name face groups to mesh elements"""

    __initargs__ = ["name_map"]

    #: dict of the form ``{'str': Face_|int, 'str': [Face_|int, .., Face_|int],
    #:                     'str': {'shape': Face_|int, 'color': 'str'}}``.
    #: Example::
    #:
    #:     {'inlet': 0,
    #:      'outlet': {'shape': <Face_ ..>, 'color': "GREEN"},
    #:      'walls': [2,3,4,5]}
    #:
    #: :type: dict[str, T]
    name_map = Input()

    @Attribute
    def _labels(self):
        return list(self.name_map.keys())

    @Attribute
    def _indices(self):
        return [val['shape'] if isinstance(val, dict) else val
                for val in self.name_map.values()]

    @Attribute
    def _colors(self):
        return [val.get('color', self.color) if
                isinstance(val, dict) else self.color
                for val in self.name_map.values()]

    @Part
    def faces(self):
        return FaceGroup(quantify=len(self.name_map),
                         map_down="_indices->shape, "
                                  "_labels->label, "
                                  "_colors->color")


if __name__ == '__main__':
    pass

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

# TODO: understand reverse stuff
# TODO: orientation of edges.
# TODO: bi-cubic? http://web.iitd.ac.in/~hegde/cad/lecture/L18_biparametric.pdf
# TODO: pcurve orientation: http://opencascade.blogspot.nl/2009/02/topology-and-geometry-in-open-cascade_27.html

"""QuadMesh class."""

from operator import itemgetter

from parapy.core import *
from parapy.geom import *


class QuadMesh(GeomBase):
    """Coons algorithm to mesh faces with 4 edges."""

    #: face with 4 edges. Seam edges and degenerated cases are also handled.
    face_in = Input(in_tree=True)
    NPointsU = Input(10)
    NPointsV = Input(10)
    reverse_c0 = Input(False)
    reverse_c1 = Input(False)
    reverse_d0 = Input(False)
    reverse_d1 = Input(False)

    @Input
    def indices(self):
        """4 Edge indices. [u1_index, u2_index, v1_index, v2_index]"""
        edges = self.face_in.edges[:] # copy
        if len(edges) > 4:
            raise Exception("2, 3 or 4 edges please")
        elif len(edges) < 4:
            raise NotImplementedError("not done yet.")

        edge1 = edges.pop(0)
        edge2 = edge1.opposite_edges()[0]
        edges.remove(edge2)
        
        #edge1.neighbours()
        

        edge3 = edges.pop(0)
        edge4 = edge3.opposite_edges()[0]
        edges.remove(edge4)
        
        assert not edges, "something went wrong"

        return [edge1.index, edge2.index, edge3.index, edge4.index]

    @Input
    def edges(self):
        """Order of edges: [uedge1, uedge2, vedge1, vedge2]"""
        f = itemgetter(*self.indices)
        return f(self.face_in.edges)

    #==============================================================================================
    # Visualization
    #==============================================================================================
    @Part
    def EdgeC0(self):
        return Clone(self.edges[0],
                    tree_style={"color": "RED"},
                    color="RED",
                    line_thickness=4)

    @Part
    def EdgeC1(self):
        return Clone(self.edges[1],
                     tree_style={"color": "RED"},
                     color="RED",
                     line_thickness=4)
    @Part
    def EdgeD0(self):
        return Clone(self.edges[2],
                           tree_style={"color": "GREEN"},
                           color="GREEN",
                           line_thickness=4)

    @Part
    def EdgeD1(self):
        return Clone(self.edges[3],
                     tree_style={"color": "GREEN"},
                     color="GREEN",
                     line_thickness=4)

    @Attribute
    def c0(self):
        edge = self.edges[0]
        crv = edge.pcurve(self.face_in)
        return crv.reversed if self.reverse_c0 else crv

    @Attribute
    def c1(self):
        edge = self.edges[1]
        crv = edge.pcurve(self.face_in)
        return crv.reversed if self.reverse_c1 else crv

    @Attribute
    def d0(self):
        edge = self.edges[2]
        crv = edge.pcurve(self.face_in)
        return crv.reversed if self.reverse_d0 else crv

    @Attribute
    def d1(self):
        edge = self.edges[3]
        crv = edge.pcurve(self.face_in)
        return crv.reversed if self.reverse_d1 else crv

    @Attribute(in_tree=True)
    def p_curves(self):
        return [self.c0, self.c1, self.d0, self.d1]

    @Part
    def surface(self):
        return Clone(self.face_in.basis_surface, color="yellow")

    @Attribute
    def pts(self):
        return bi_linear_coons(self.face_in,
                               self.c0, self.c1, self.d0, self.d1,
                               self.NPointsU, self.NPointsV)

    @Part
    def point_cloud(self):
        return PointCloud(self.pts)

    @Part
    def grid(self):
        return Compound([LineSegment(pt1, pt2, color="green") for pts in self.pts for\
                                     pt1, pt2 in pairwise(pts)] +\
                        [LineSegment(pt1, pt2, color="red")  for pts in zip(*self.pts) for\
                                     pt1, pt2 in pairwise(pts)])


#==================================================================================================
# Algorithms
#==================================================================================================

def bi_linear_coons(face, c0, c1, d0, d1, Ns, Nt):
    """returns uv grid"""

    sa = face._Adaptor3d_Surface
    c0a = c0._Adaptor2d_Curve
    c1a = c1._Adaptor2d_Curve
    d0a = d0._Adaptor2d_Curve
    d1a = d1._Adaptor2d_Curve

    # pcurves
    s0_list = list_of_numbers(0, 1, Ns)
    s1_list = list_of_numbers(0, 1, Ns)
    t0_list = list_of_numbers(0, 1, Nt)
    t1_list = list_of_numbers(0, 1, Nt)

    #bounds
    c0u1, c0u2 = c0a.FirstParameter(), c0a.LastParameter()
    c1u1, c1u2 = c1a.FirstParameter(), c1a.LastParameter()
    d0u1, d0u2 = d0a.FirstParameter(), d0a.LastParameter()
    d1u1, d1u2 = d1a.FirstParameter(), d1a.LastParameter()

    # corners
    u00, v00 = c0a.Value(c0u1).Coord()
    u01, v01 = c0a.Value(c0u2).Coord()
    u10, v10 = c1a.Value(c1u1).Coord()
    u11, v11 = c1a.Value(c1u2).Coord()

    uv_arr = []
    for t0, t1 in zip(t0_list, t1_list):
        uv_list = []
        for s0, s1 in zip(s0_list, s1_list):
            # http://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line
            # x1 = s1, y1 = 0
            # x2 = s2, y2 = 1
            # x3 = 0,  y3 = t1
            # x4 = 1,  x4 = t2
            
            # s, t points in domain
            D = (s0 - s1) * (t0 - t1) - 1
            s = (t0 * (s0 - s1) - s0) / D
            t = (s0 * (t0 - t1) - t0) / D

            # boundary uv-points
            c0u, c0v = c0a.Value((1-s)*c0u1+s*c0u2).Coord()
            c1u, c1v = c1a.Value((1-s)*c1u1+s*c1u2).Coord()
            d0u, d0v = d0a.Value((1-t)*d0u1+t*d0u2).Coord()
            d1u, d1v = d1a.Value((1-t)*d1u1+t*d1u2).Coord()

            # u, v points inside the domain
            # Bi-Linear Coons in condensed form: Lc(s,t) + Lb(s,t) - B(s,t)
            u = (1-t)*c0u + t*c1u +\
                (1-s)*d0u + s*d1u -\
                (u00*(1-s)*(1-t) + u01*s*(1-t) + u10*(1-s)*t + u11*s*t)
            v = (1-t)*c0v + t*c1v +\
                (1-s)*d0v + s*d1v -\
                (v00*(1-s)*(1-t) + v01*s*(1-t) + v10*(1-s)*t + v11*s*t)

            uv_list.append(Point(*sa.Value(u, v).Coord()))
        uv_arr.append(uv_list)
    return uv_arr



#     def Lc(s, t):
#         """returns [u, v]"""
#         c0u, c0v = c0a.Value((1-s)*c0u1+s*c0u2).Coord()
#         c1u, c1v = c1a.Value((1-s)*c1u1+s*c1u2).Coord()
#         return [(1-t)*c0u + t*c1u,
#                 (1-t)*c0v + t*c1v]
# 
#     def Ld(s, t):
#         """returns [u, v]"""
#         d0u, d0v = d0a.Value((1-t)*d0u1+t*d0u2).Coord()
#         d1u, d1v = d1a.Value((1-t)*d1u1+t*d1u2).Coord()
#         return [(1-s)*d0u + s*d1u,
#                 (1-s)*d0v + s*d1v]
#    
#     def B(s, t):
#         """returns [u, v]"""
#         return [u00*(1-s)*(1-t) + u01*s*(1-t) + u10*(1-s)*t + u11*s*t,
#                 v00*(1-s)*(1-t) + v01*s*(1-t) + v10*(1-s)*t + v11*s*t]
# 
#     def coons(s, t):
#         lc = Lc(s, t)
#         ld = Ld(s, t)
#         b = B(s, t)
#         return [lc[0] + ld[0] - b[0],
#                 lc[1] + ld[1] - b[1]]
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Classes to dive into grid and sub-grid results. Starting point for:

- Visualization of meshes
- Access to (individual) nodes, edge, faces, volumes
"""

import warnings
from operator import methodcaller

from OCC.utils.mesh import mesh_edges, mesh_faces, mesh_iterator, mesh_nodes
from OCC.utils.utilities import distance
from OCC.wrapper.MeshVS import (
    MeshVS_DMF_OCCMask, MeshVS_Mesh, MeshVS_MeshPrsBuilder)
from OCC.wrapper.SMESH import (
    SMESH_MeshVSLink, SMESH_OctreeNode, SMESH_SubMeshVSLink)
from OCC.wrapper.gp import gp_XYZ
from OCC.wrapper.stdlib import (
    set_SMDS_MeshNodecp_TIDcomp, vector_SMDS_MeshNodecp)

from parapy.core import Attribute, Input
from parapy.core.base import DrawableBase
from parapy.core.globs import DEFAULT_COLOR_RGB
from parapy.core.utilities import get_rgb_value
from parapy.core.validate import OneOf
from parapy.core.widgets import Dropdown
from parapy.geom.occ.curve import LineSegment
from parapy.geom.occ.wire import Polygon
from parapy.mesh.core.grid import MeshNode as MeshNodeBase


class MeshNode(MeshNodeBase):
    """
    Takes a Salome Takes a Salome :class:`OCC.SMDS.SMDS_MeshNode`.
    API: http://docs.salome-platform.org/5/smesh/dev/classSMDS__MeshNode.html
    """

    def __new__(cls, node):
        """
        :type node:OCC.wrapper.SMDS.SMDS_MeshNode
        """
        return MeshNodeBase.__new__(cls, node.X(), node.Y(), node.Z(), None)

    def __init__(self, node):
        super(MeshNode, self).__init__(None, None, None, mesh_id=node.GetID())


class MeshEdge(LineSegment):
    """
    Takes a Salome :class:`OCC.SMDS.SMDS_MeshEdge`.
    API: http://docs.salome-platform.org/5/smesh/dev/classSMDS__MeshEdge.html
    """

    def __init__(self, edge, *args, **kwargs):
        """
        :param edge: SMDS_MeshEdge
        """
        LineSegment.__init__(self, *args, **kwargs)
        self.mesh_id = edge.GetID()
        self.nodes = list(map(MeshNode, _yield_meshedge_nodes(edge)))

    #: The id of this :class:`MeshEdge` in the Mesh.
    #: :type: int
    mesh_id = Attribute(None, settable=True)

    #: The id of this :class:`MeshEdge` in the Mesh.
    #: :type: list[MeshNode, MeshNode]
    nodes = Attribute(None, settable=True)

    @Attribute
    def start(self):
        """The start node of this :class:`MeshEdge`.

        :rtype: MeshNode
        """
        return self.nodes[0]

    @Attribute
    def end(self):
        """The end node of this :class:`MeshEdge`.

        :rtype: MeshNode
        """
        return self.nodes[1]


class MeshFace(Polygon):
    """
    Takes a Salome :class:`OCC.SMDS.SMDS_MeshFace`.
    API: http://docs.salome-platform.org/5/smesh/dev/classSMDS__MeshFace.html
    """

    force_closure = False

    __initargs__ = []

    def __init__(self, face, *args, **kwargs):
        """
        :type face:OCC.wrapper.SMDS.SMDS_MeshFace
        """
        Polygon.__init__(self, *args, **kwargs)

        self.mesh_id = face.GetID()

        self.nodes = list(map(MeshNode, _yield_meshface_nodes(face)))
        # itt = face.edgesIterator()
        # it = itt.get()
        # FIXME (TBD): SMDS_VtkFace.elementsIterator() seems to have
        # /fixme overridden SMDS_MeshFace.elementsIterator()
        # See: http://docs.salome-platform.org/6/tui/SMESH/SMDS__VtkFace_8cxx_source.html
        # for node1, node2 in pairwise(nodes):
        #     edge = (SMESHDS_Mesh.FindEdge(node1, node2) or
        #             SMESHDS_Mesh.FindEdge(node2, node1))
        #     print edge
        # self.edges = [MeshEdge(SMESHDS_Mesh.FindEdge(node1, node2),
        #                        SMESHDS_Mesh)]

    #: id of this face in the mesh.
    #: :type: int
    mesh_id = Attribute(None, settable=True)

    #: The MeshNode elements in this MeshFace.
    #: Typically the corners.
    #: :returns: [MeshNode, ...]
    nodes = Attribute(None, settable=True)

    #: Returns MeshEdge elements in this MeshFace.
    #: Note: shadows Polygon.edges, but that's acceptable
    #: :returns: [MeshEdge, ...]
    #: :rtype: list[MeshEdge]
    #:
    #: ..note:: shadows Polygon.edges, but that's acceptable.
    # edges = Attribute(None, settable=True)
    @property
    def edges(self):
        """Override of MeshFace.points"""
        raise NotImplementedError("still has to be implemented")

    # override of MeshFace.points for visualization
    @Attribute
    def points(self):
        """Override of MeshFace.points. Repeats the first point to make it
        closed."""
        return self.nodes + [self.nodes[0]]


class Grid(DrawableBase):
    """Grid of entire shape_to_mesh. It creates a Handle_MeshVS_Mesh that
    can be visualized in the viewport provides the access point for nodes,
    edges, faces and volumes. If you want lower-level access, e.g. grid
    elements on sub-shapes like an edge or face, work with groups and access
    SubGrid results.
    """

    __initargs__ = ["SMESH_Mesh"]
    DISPLAY_MODES = ["wireframe", "shaded", "shrink"]

    #: SMESH_MESH object on the entire ``shape_to_mesh``.
    #: API:
    #: http://docs.salome-platform.org/latest/tui/SMESH/classSMESH__Mesh.html
    #: :type:OCC.wrapper.SMESH.SMESH_Mesh
    SMESH_Mesh = Input(private=True)

    #: color of grid faces
    #: :type: str | (float, float, float)
    color = Input(DEFAULT_COLOR_RGB, defaulting=True)

    #: color of grid vertices
    #: :type: str | (float, float, float)
    vertex_color = Input("black")

    #: color of grid edges
    #: :type: str | (float, float, float)
    edge_color = Input("black")

    #: Controls display mode in GUI: 'shaded', 'wireframe' or 'shrink'.
    #: :type: str | None
    display_mode = Input("wireframe", defaulting=True,
                         validator=OneOf(DISPLAY_MODES),
                         widget=Dropdown(DISPLAY_MODES))

    @Attribute
    def SMESHDS_Mesh(self):
        """API:
        http://docs.salome-platform.org/5/smesh/dev/classSMESHDS__Mesh.html

        :returns: SMESHDS_Mesh instance
        :rtype:OCC.wrapper.SMESHDS.SMESHDS_Mesh
        """
        return self.SMESH_Mesh.GetMeshDS()

    @Attribute
    def nb_nodes(self):
        """Number of nodes in the mesh.

        :rtype: int
        """
        return self.SMESH_Mesh.NbNodes()

    @Attribute
    def nb_edges(self):
        """Number of edges in the mesh.

        :rtype: int
        """
        return self.SMESH_Mesh.NbEdges()

    @Attribute
    def nb_faces(self):
        """Number of faces in the mesh.

        :rtype: int
        """
        return self.SMESH_Mesh.NbFaces()

    @Attribute
    def nb_volumes(self):
        """Number of volumes in the mesh.

        :rtype: int
        """
        return self.SMESH_Mesh.NbVolumes()

    @Attribute
    def nodes(self):
        """
        All nodes (points) in the entire grid (internal and on the boundaries).
        :returns: list of MeshNode instances. Ordered by ID.
        :rtype: list[MeshNode]
        """
        m = self.SMESH_Mesh
        # SALOME node numbering starts at index 1.
        return sorted((MeshNode(e) for e in mesh_nodes(m)),
                      key=lambda obj: obj.mesh_id)

    def _yield_nodes(self):
        return mesh_nodes(self.SMESH_Mesh)

    @Attribute
    def edges(self):
        """Boundary edges of the grid. Edges are line segment with 2 nodes.
        Only edges on the boundaries of the domain are returned. Internal edges
        can be retrieved through the faces.

        :returns: list of MeshEdge instances. Ordered by ID (default
            in Salome).
        :rtype: list[MeshEdge]
        """
        m = self.SMESH_Mesh
        return [MeshEdge(e) for e in mesh_edges(m)]

    @Attribute
    def faces(self):
        """All faces in the entire grid. Faces consists of N edges (N=3 for
        triangle, N=4 for quadrilateral, etc.).

        :returns: list of MeshFace instances. Ordered by ID (default
            in Salome).
        :rtype: list[MeshFace]
        """
        m = self.SMESH_Mesh
        return [MeshFace(e) for e in mesh_faces(m)]

    @Attribute
    def _oct_tree(self):
        """Helps to speed-up queries to find nodes close to a given point.

        :rtype:OCC.wrapper.SMESH.SMESH_OctreeNode
        """
        sorted_nodes = set_SMDS_MeshNodecp_TIDcomp()

        # TODO (TBD): filling the set at c++ side will give major speedup.
        for _ in map(sorted_nodes.add, self._yield_nodes()):
            pass
        return SMESH_OctreeNode(sorted_nodes)

    def _find_nodes_near(self, pt, radius):
        """Return all the nodes in this Grid that lie within ``tolerance``
        around ``pt``.

        :type pt: collections.Iterable[float, float, float]
        :type radius: float
        :rtype:OCC.wrapper.stdlib.vector_SMDS_MeshNodecp
        """
        found_nodes = vector_SMDS_MeshNodecp()
        self._oct_tree.NodesAround(gp_XYZ(*pt), found_nodes, radius)
        return found_nodes

    def find_nodes_near(self, pt, radius):
        """Return :class:`MeshNode` instances that lie at ``pt`` within
        ``radius``.

        :param collections.Sequence[float, float, float] pt:
        :type radius: float
        :rtype: list[MeshNode]
        """
        return list(map(MeshNode, self._find_nodes_near(pt, radius)))

    def find_node_ids_near(self, pt, radius):
        """Return the node-ids of the :class:`MeshNode` instances that lie
        at ``pt`` within ``radius``.

        :param collections.Sequence[float, float, float] pt:
        :type radius: float
        :rtype: list[int]
        """
        found_nodes = self._find_nodes_near(pt, radius)
        return list(map(methodcaller('GetID'), found_nodes))

    def find_node_at(self, pt, tolerance=1e-7):
        """Return a :class:`MeshNode` that lies at ``pt`` within
        ``tolerance``, or :py:`None` if it cannot find such a MeshNode.

        :param collections.Sequence[float, float, float] pt:
        :param float tolerance: (default: 1e-7).
        :rtype: MeshNode | None
        """
        found_nodes = self._find_nodes_near(pt, tolerance)
        if found_nodes:
            if len(found_nodes) > 1:
                msg = ("Found more than one MeshNode at {} within tolerance, "
                       "the closest will be returned. Consider "
                       "reducing the tolerance. Object: {!r}")
                warnings.warn(msg.format(pt, tolerance, self))

                def dist(obj):
                    return distance((obj.X(), obj.Y(), obj.Z()), pt)

                return MeshNode(sorted(found_nodes, key=dist)[0])
            else:
                return MeshNode(found_nodes[0])
        else:
            return None

    @Attribute
    def _Handle_AIS_InteractiveObject(self):
        """Interactive object of this Grid.

        :rtype:OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        """
        mesh = self.SMESH_Mesh
        aDS = SMESH_MeshVSLink(mesh)
        allow_overlapped = True
        aMeshVS = MeshVS_Mesh(allow_overlapped)
        dmf = MeshVS_DMF_OCCMask
        aPrsBuilder = MeshVS_MeshPrsBuilder(aMeshVS.handle, dmf, aDS.handle)
        aMeshVS.SetDataSource(aDS.handle)
        aMeshVS.AddBuilder(aPrsBuilder.handle, False)
        return aMeshVS.handle

    def _display_style(self):
        """Used for gui, may contain keys "mesh_face_color",
        "mesh_edge_color", "mesh_vertex_color", etc.

        :rtype: dict[str, (float, float, float)]
        """
        return {
            "display_mode": self.display_mode,
            "mesh_face_color": get_rgb_value(self.color),
            "mesh_edge_color": get_rgb_value(self.edge_color),
            "mesh_vertex_color": get_rgb_value(self.vertex_color)}


class SubGrid(Grid):
    """
    Sub-grid of ``TopoDS_Shape``. It creates a shape to visualize in the
    viewport and is the
    access point for nodes, edges, faces and volumes.
    Note Blome's custom SWIG implementation of SMESHDS_SubMesh.elemValue():
    http://permalink.gmane.org/gmane.comp.cad.pythonocc.user/1125
    """

    #: :type:OCC.wrapper.SMESHDS.SMESHDS_GroupBase
    SMESHDS_GroupBase = Input(private=True)

    #: SMESH_subMesh. Sub-shape of shape_to_mesh for which a
    #: sub-grid is created.
    #: :type:OCC.wrapper.SMESH.SMESH_subMesh
    SMESH_subMesh = Input(private=True)

    #: :type:OCC.wrapper.TopoDS.TopoDS_Shape
    TopoDS_Shape = Input(private=True)

    @Attribute(private=True)
    def SMESHDS_SubMesh(self):
        """
        API: http://docs.salome-platform.org/latest/tui/SMESH/classSMESHDS__SubMesh.html
        :returns: SMESHDS_SubMesh instance
        :rtype:OCC.wrapper.SMESHDS.SMESHDS_SubMesh
        """

        return self.SMESH_subMesh.GetSubMeshDS()

    @Input
    def dimension(self):
        """The dimensionality of this SubGrid.

        :rtype: int
        :raises ValueError: If the grouptype of this SubGrid is not supported.
        """
        type_id = self.SMESHDS_GroupBase.GetType()
        if 1 <= type_id <= 4:
            return type_id - 1
        else:
            raise ValueError("type_id {0} not supported".format(type_id))

    @Attribute
    def element_type(self):
        """The type of the elements in this subgrid.

        :returns: either :class:`MeshNode`, :class:`MeshEdge` or
            :class:`MeshFace`.
        :rtype: type
        """
        dim = self.dimension
        if dim == 0:
            return MeshNode
        elif dim == 1:
            return MeshEdge
        elif dim == 2:
            return MeshFace
        elif dim == 3:
            raise NotImplementedError("Volume not yet supported.")

    @Attribute
    def nb_internal_nodes(self):
        """Number of internal nodes on this submesh. Boundary nodes not
        included.

        :rtype: int
        """
        return self.SMESHDS_SubMesh.NbNodes()

    # FIXME (TBD): never iterate over nodes, find faster way. Author: RvD.
    @Attribute
    def nb_nodes(self):
        """Number of nodes on this submesh.

        :rtype: int
        """
        return len(self.nodes)

    # FIXME (TBD): never iterate over edges, find faster way. Author: RvD.
    @Attribute
    def nb_edges(self):
        """Number of edges in the mesh.

        :rtype: int
        """
        if self.dimension == 1:
            return self.nb_elements
        else:
            return len(self.edges)

    # FIXME (TBD): never iterate over faces, find faster way. Author: RvD.
    @Attribute
    def nb_faces(self):
        """Number of faces in the mesh.

        :rtype: int
        """
        if self.dimension == 2:
            return self.nb_elements
        else:
            return len(self.faces)

    @Attribute
    def nb_volumes(self):
        """Number of volumes in the mesh.

        :rtype: int
        """
        raise NotImplementedError()

    @Attribute
    def nb_elements(self):
        """The number of mesh elements in this subgrid.

        :rtype: int
        """
        return self.SMESHDS_SubMesh.NbElements()

    @Attribute
    def elements(self):
        """
        Return a list of mesh 'elements', where the element type depends
        on the dimension of this subgrid. Assumes that all elements
        are of a single type.

        For example <type>:

            Vertex: -> []
            Edge/Wire: -> [MeshEdge, ...]
            Face/Shell: -> [MeshFace, ...]
            Solid/CompSolid: -> [MeshVolume, ...]
            Compound: -> depends on contents of compound, but can be
            any of the above.

        :returns: list of MeshEdge|MeshFace|MeshVolume instances.
        :rtype: list[MeshNode|MeshEdge|MeshFace]
        """
        #: :type:OCC.wrapper.SMESHDS.SMESHDS_SubMesh
        return list(map(self.element_type, self._yield_elements()))

    def _yield_elements(self):
        sub_mesh = self.SMESHDS_SubMesh
        it = sub_mesh.GetElements()
        while it.more():
            yield it.next()

    @Attribute
    def internal_nodes(self):
        """Return the *internal* nodes, boundary nodes not included. Excluded:

        - nodes on end vertices of an edge.
        - nodes on edges of a face/shell.

        See :attr:`nodes` if you want the boundary nodes as well.

        :rtype: list[MeshNode]
        """
        return list(map(MeshNode, self._yield_internal_nodes()))

    def _yield_internal_nodes(self):
        sub_mesh = self.SMESHDS_SubMesh
        it = sub_mesh.GetNodes()
        while it.more():
            yield it.next()

    @Attribute
    def nodes(self):
        """Will also include boundary nodes.

        :rtype: list[MeshNode]
        """
        return list(map(MeshNode, self._yield_nodes()))

    def _yield_nodes(self):
        dim = self.dimension
        if dim == 0:
            for node in self._yield_internal_nodes():
                yield node
        elif dim > 2:
            raise NotImplementedError("Volumetric subgrid not "
                                      "implemented yet.")
        else:  # dim in (1, 2)
            if dim == 1:
                node_generator = _yield_meshedge_nodes
            else:  # dim == 2
                node_generator = _yield_meshface_nodes

            visited = set()
            for elem in self._yield_elements():
                for node in node_generator(elem):
                    node_id = node.GetID()
                    """:type: OCC.wrapper.SMDS.SMDS_MeshElement"""
                    if node_id not in visited:
                        visited.add(node_id)
                        yield node

    @Attribute
    def edges(self):
        """
        All edges in this subgrid. Edges are line segment with 2 nodes.
        Both internal and external edges are returned.

        :returns: list of MeshEdge instances (unordered).
        :rtype: list[MeshEdge]
        """
        dim = self.dimension
        if dim < 1:
            return []
        elif dim == 1:
            return self.elements
        elif dim == 2:
            # subgrid on Face level, collect edges from elements (faces)
            collector = {}
            for face in self.elements:
                for edge in face.edges:
                    collector[edge.mesh_id] = edge
            return list(collector.values())
        else:
            raise NotImplementedError("Volumetric subgrid not "
                                      "implemented yet.")

    @Attribute
    def faces(self):
        """
        All faces in this subgrid.

        :returns: list of MeshFace instances (unordered).
        :rtype: list[MeshFace]
        """
        dim = self.dimension
        if dim < 2:
            return []
        elif dim == 2:
            return self.elements
        else:
            raise NotImplementedError("Volumetric subgrid not "
                                      "implemented yet.")

    @Attribute
    def _Handle_AIS_InteractiveObject(self):
        """Interactive object of this SubGrid.

        :rtype:OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        """
        mesh = self.SMESH_Mesh
        submesh = self.SMESH_subMesh
        aDS = SMESH_SubMeshVSLink(mesh, submesh, 0, False)
        allow_overlapped = True
        aMeshVS = MeshVS_Mesh(allow_overlapped)
        dmf = MeshVS_DMF_OCCMask
        aPrsBuilder = MeshVS_MeshPrsBuilder(aMeshVS.handle, dmf, aDS.handle)
        aMeshVS.SetDataSource(aDS.handle)
        aMeshVS.AddBuilder(aPrsBuilder.handle, False)
        return aMeshVS.handle


def _yield_meshedge_nodes(edge):
    yield edge.GetNode(0)
    yield edge.GetNode(1)


def _yield_meshface_nodes(face):
    for node in mesh_iterator(face, 'nodes'):
        yield node.GetNode(0)


# class SubShapeHelper(Base):
#     """Can be useful to relate sub-shapes to SALOME IDs."""
#
#     sub_colors  = Input(["RED", "GREEN", "BLUE", "YELLOW",
#                          "CYAN", "BLACK", "ORANGE"])
#     shape       = Input()
#     MESHDS_Mesh = Input()
#
#     @Input
#     def _meshds(self):
#         return self.parent._meshds
#
#     @Part
#     def analysis(self):
#         return BrepAnalysis(solid_in  = self.shape,
#                             pass_down = "sub_colors")
#
#     @Part
#     def unique_faces(self, child):
#         return Face(sequence=len(self.shape.faces),
#                     name_for_display = "FACE %s (salome: %s)"\
#                     % (child.index, self.subshape_id(child.TopoDS_Shape)),
#                     color = self.sub_colors[
#                         int(math.fmod(child.index, len(self.sub_colors)))],
#                     TopoDS_Shape=self.shape.faces[child.index].TopoDS_Shape)
#
#     def subshape_id(self, TopoDS_Shape):
#         return self.MESHDS_Mesh.ShapeToIndex(TopoDS_Shape)
#
#     sub_colors = input(["RED", "GREEN", "BLUE", "YELLOW",
#                         "CYAN", "BLACK", "ORANGE"])

# enum MeshVS_DrawerAttribute {
#  MeshVS_DA_InteriorStyle,
# MeshVS_DA_InteriorColor,
# MeshVS_DA_BackInteriorColor,
# MeshVS_DA_EdgeColor,
# MeshVS_DA_EdgeType,
# MeshVS_DA_EdgeWidth,
# MeshVS_DA_HatchStyle,
# MeshVS_DA_FrontMaterial,
# MeshVS_DA_BackMaterial,
# MeshVS_DA_BeamType,
# MeshVS_DA_BeamWidth,
# MeshVS_DA_BeamColor,
# MeshVS_DA_MarkerType,
# MeshVS_DA_MarkerColor,
# MeshVS_DA_MarkerScale,
# MeshVS_DA_TextColor,
# MeshVS_DA_TextHeight,
# MeshVS_DA_TextFont,
# MeshVS_DA_TextExpansionFactor,
# MeshVS_DA_TextSpace,
# MeshVS_DA_TextStyle,
# MeshVS_DA_TextDisplayType,
# MeshVS_DA_TextTexFont,
# MeshVS_DA_VectorColor,
# MeshVS_DA_VectorMaxLength,
# MeshVS_DA_VectorArrowPart,
# MeshVS_DA_IsAllowOverlapped,
# MeshVS_DA_Reflection,
# MeshVS_DA_ColorReflection,
# MeshVS_DA_ShrinkCoeff,
# MeshVS_DA_MaxFaceNodes,
# MeshVS_DA_ComputeTime,
# MeshVS_DA_ComputeSelectionTime,
# MeshVS_DA_DisplayNodes,
# MeshVS_DA_SelectableAuto,
# MeshVS_DA_ShowEdges,
# MeshVS_DA_SmoothShading,
# MeshVS_DA_SupressBackFaces,
# MeshVS_DA_User
# };

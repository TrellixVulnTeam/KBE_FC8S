#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines Triangular 2d and TetraHedral 3d Hypotheses. The latter optionally
with Viscous layers.

Tri, Tetra and TetraViscous have the following quality parameters::

    -fineness          the level of meshing detalization influencing
        growth_rate, nb_seg_per_edge, and nb_seg_per_radius. If you want to
        control those settings yourself, leave fineness at None and specify
        their values instead.
    -growth_rate       how much the linear dimensions of two adjacent cells
        can differ (i.e. 0.3 means 30%).
    -max_size          maximum linear dimensions for mesh cells.
    -nb_seg_per_edge   the minimum number of mesh segments in which edges
        will be split
    -nb_seg_per_radius the minimum number of mesh segments in which radii
        will be split
    -optimize          If True, the algorithm will try to create
        regular (possessing even sides) elements
    -second_order      will create second order nodes on the mesh, which
        will then become quadratic.

TriSimple, TetraSimple and TetraSimpleViscous have the simpler parameters::

    -length_from_edges    2D mesh segments having a length calculated
        as an average edge length for a given wire. Either this or max_area.
    -local_length    Sets required length of segments. Either this
        or nb_seg_per_edge.
    -max_area    expected maximum element area for each 2d element. Either
        this or length_from_edges.
    -nb_seg_per_edge    Number of segments, that will split each edge, with
        equidistant distribution. Either this or local_length.

    # 3d Only:
    -max_volume    expected maximum element volume of each 3d element. Either
        this or length_from_faces.
    -length_from_faces    area of sides of volumic elements will be equal to
        an average area of 2D elements. Either this or max_volume

TODO: get rid of Simple classes and integrate these somehow in the inputs.

# =============================================================================
# SWIG_PROXY CLASS                    # SALOME CLASS
# =============================================================================
# NETGENPlugin_NETGEN_2D,             # NETGEN 1D-2D
# NETGENPlugin_NETGEN_2D_ONLY,        # NETGEN 2D 
# NETGENPlugin_NETGEN_3D,             # NETGEN 3D
# NETGENPlugin_NETGEN_2D3D,           # NETGEN 1D-2D-3D
# NETGENPlugin_Hypothesis_2D,         # NETGEN 2D parameters
# NETGENPlugin_Hypothesis             # NETGEN 3D parameters
# NETGENPlugin_SimpleHypothesis_2D,   # NETGEN 2D simple parameters
# NETGENPlugin_SimpleHypothesis_3D,   # NETGEN 3D simple parameters
"""

import warnings

from OCC.utils.mesh import _append_hypotheses
from OCC.wrapper.NETGENPlugin import (
    NETGENPlugin_Hypothesis, NETGENPlugin_Hypothesis_2D,
    NETGENPlugin_NETGEN_2D, NETGENPlugin_NETGEN_2D3D,
    NETGENPlugin_NETGEN_2D_ONLY, NETGENPlugin_NETGEN_3D,
    NETGENPlugin_SimpleHypothesis_2D, NETGENPlugin_SimpleHypothesis_3D)

from parapy.core import Attribute, Base, Input
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.validate import IsInstance, OneOf, Optional
from parapy.core.widgets import CheckBox, Dropdown
from parapy.mesh.core.controls import MeshControl2D, MeshControl3D
from parapy.mesh.salome.controls import _ViscousLayerMixin


# =============================================================================
# Abstract NETGEN classes
# =============================================================================
class _NETGEN(Base):
    """Abstract base class for NETGEN-based hypotheses and algorithms. One has
    to implement ``_HYPO`` and ``_ALGO``.
    """

    _HYPO = None
    _ALGO = None

    def compute(self, gen, mesh):
        """Compute the netgen-generated mesh.

        :param OCC.SMESH.SMESH_Gen gen:
        :param OCC.SMESH.SMESH_Mesh mesh:
        """
        gen.Compute(mesh, self.TopoDS_Shape, True)

    def _apply(self, ID, generator, mesh):
        """Instantiate ``_HYPO`` and ``_ALGO`` and add them to ``mesh``.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        topo = self.TopoDS_Shape
        hyp = self._HYPO(ID, generator)
        self._set_hypo(hyp)
        hyp2 = self._ALGO(ID + 1, generator)
        mesh.AddHypothesis(topo, ID)
        mesh.AddHypothesis(topo, ID + 1)

        _append_hypotheses(mesh, (hyp, hyp2))

        return ID + 1


class _NETGEN2D(_NETGEN, MeshControl2D):
    """Abstract base class for 2D NBTGEN Hypotheses. One has
    to implement ``_HYPO`` and ``_ALGO``.
    """
    pass


class _NETGEN3D(_NETGEN, MeshControl3D):
    """Base class for 3D NETGEN Hypotheses."""
    _ALGO = NETGENPlugin_NETGEN_3D
    _HYPO = NETGENPlugin_Hypothesis


class _NETGEN3D_Viscous(_NETGEN3D, _ViscousLayerMixin):
    """Base class for 3D NETGEN algorithms that apply a Viscous boundary
    layer."""

    def _apply(self, ID, generator, mesh):
        """Instantiate ``_HYPO``, ``_VHYPO`` and ``_ALGO`` and add them to
        ``mesh``.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        _NETGEN._apply(self, ID, generator, mesh)
        hyp = self._VHYPO(ID+2, generator)
        self._set_vhypo(hyp, mesh)
        mesh.AddHypothesis(self.TopoDS_Shape, ID+2)

        _append_hypotheses(mesh, (hyp,))
        return ID + 2


class _NETGEN_Hypothesis(Base):
    """General Mixin to use with :class:`_NETGEN2D` and :class:`_NETGEN3D`."""
    
    _HYPO = NETGENPlugin_Hypothesis
    FINENESS_OPTIONS = [
        "VeryCoarse",
        "Coarse",
        "Moderate",
        "Fine",
        "VeryFine",
        "UserDefined",
    ]

    #: Minimum linear dimensions for mesh cells. It is ignored if it is more
    #: than :attr:`max_size`.
    #: :type: float | None
    min_size = Input(None)

    #: Maximum linear dimensions for mesh cells.
    #: :type: float | None
    max_size = Input(None)

    #: Ranging from `VeryCoarse` to `VeryFine`, allows to set the level of
    #: mesh detail using the three parameters below. You can select
    #: `UserDefined` to define them manually.
    #: :type: str | None
    fineness = Input("Moderate",
                     validator=Optional(OneOf(FINENESS_OPTIONS)),
                     widget=Dropdown(FINENESS_OPTIONS))

    #: How much the linear dimensions of two adjacent
    #: cells can differ (i.e. 0.3 means 30%).
    #: :type: float | None
    growth_rate = Input(0.3)

    #: Define the minimum number of mesh segments in which edges
    #: will be split. Size of elements computed using this value is trimmed
    #: between :attr:`min_size` and :attr:`max_size` bounds. This parameter is
    #: used only if :attr:`limit_size_by_surface_curvature` is ``True``.
    #: :type: int | None
    nb_seg_per_edge = Input(1)

    #: Define the size of mesh segments and mesh faces in which
    #: curved edges and surfaces will be split. A radius of local curvature
    #: divided by this value gives an element size at a given point. Element
    #: size computed this way is then trimmed between :attr:`min_size` and
    #: :attr:`max_size` bounds. This parameter is used only if
    # :attr:`limit_size_by_surface_curvature` is ``True``.
    #: :type: int | None
    nb_seg_per_radius = Input(2)

    #: Set this to ``True`` or ``False`` to respectively enable/disable
    #: :attr:`chordal_error`.
    #: :type: bool
    enable_chordal_error = Input(False, widget=CheckBox)

    #: Define the maximum distance between the generated 2D element
    #: and the surface. Size of elements computed using this criterion is
    #: trimmed between :attr:`min_size` and :attr:`max_size` bounds.
    chordal_error = Input(-1)

    #: Set to ``True`` to define the size of mesh segments and mesh faces on
    #: curved edges and surfaces by :attr:`nb_seg_per_radius`, and to define
    #: the number of segments on straight edges by :attr:`nb_seg_per_edge`,
    #: (will also take :attr:`growth_rate`
    #: into account.) If set to ``False``, the size of
    #: elements is defined by three parameters only: :attr:`max_size`,
    #: :attr:`min_size` and :attr:`growth_rate`.
    limit_size_by_surface_curvature = Input(True, widget=CheckBox)

    #: Set to ``True`` to try to generate a quadrangle
    #: 2D mesh. Triangle elements are created where quadrangles are not
    #: possible.
    #: :type: bool
    quad_dominant = Input(False, widget=CheckBox)

    #: Set to ``True`` to create second order nodes on the mesh, which
    #: will then become quadratic.
    #: :type: bool | None
    second_order = Input(False, widget=CheckBox)

    #: Set to ``True`` to post-process the initially generated mesh to improve
    #: the quality of the elements. The optimization process is time
    #: consuming compared to creation of the initial mesh.
    #: :type: bool
    optimize = Input(True, widget=CheckBox)

    # --- advanced inputs ----

    #: Weight of triangle size badness with respect to triangle shape badness.
    #: Total triangle badness is evaluated as ``shape_badness + size_weight *
    #: size_mismatch``.
    #: :type: numbers.Number
    element_size_weight = Input(0.2)

    #: If :attr:`optimize`, this controls number of surface optimization steps.
    #: :type: int
    nb_surface_optimization_steps = Input(3)

    #: If :attr:`optimize`, this controls number of volume optimization steps.
    #: :type: int
    nb_volume_optimization_steps = Input(3)

    #: Power of error, used to approximate max error optimization.
    #: :type: int
    worst_element_measure = Input(2)

    #: Set to ``True`` to use the Delaunay approach to construct volume
    #: elements, otherwise use the Advancing front method.
    #: :type: bool
    use_delauney = Input(True, widget=CheckBox)

    #: Check overlapping surfaces during surface meshing.
    #: :type: bool
    check_overlapping = Input(True, widget=CheckBox)

    #: Check the chart boundary
    #: :type: bool
    check_chart_boundary = Input(True, widget=CheckBox)

    #: Set to ``True` to allow merging mesh nodes on vertices and edges
    #: which are geometrically coincident but are topologically different.
    #: :type: bool
    fuse_coincident_nodes = Input(True, widget=CheckBox)

    #: Deprecated, use :attr:`quad_dominant` instead
    #: :type: bool
    allow_quadrangles = Input(False, private=True)

    def _set_hypo(self, hyp: NETGENPlugin_Hypothesis):
        """Configures NETGEN hypothesis ``hyp`` based on the Inputs for this
        class.

        :type hyp: OCC.NETGENPlugin.NETGENPlugin_Hypothesis"""
        if self.is_user_defined("allow_quadrangles"):
            warnings.warn(
                "allow_quadrangles has been deprecated, use "
                "quad_dominant instead", ParaPyDeprecationWarning)
            quad_dominant = self.allow_quadrangles
        else:
            quad_dominant = self.quad_dominant

        fineness = self.fineness
        fineness_salome = getattr(NETGENPlugin_Hypothesis_2D, fineness)

        max_size = self.max_size
        if max_size is not None:
            hyp.SetMaxSize(max_size)

        min_size = self.min_size
        if min_size is not None:
            hyp.SetMinSize(min_size)

        hyp.SetSecondOrder(self.second_order)
        hyp.SetOptimize(self.optimize)
        hyp.SetFineness(fineness_salome)

        if fineness == "UserDefined":
            hyp.SetGrowthRate(self.growth_rate)
            hyp.SetNbSegPerEdge(self.nb_seg_per_edge)
            hyp.SetNbSegPerRadius(self.nb_seg_per_radius)

        hyp.SetChordalError(self.chordal_error)
        hyp.SetChordalErrorEnabled(self.enable_chordal_error)
        hyp.SetSurfaceCurvature(self.limit_size_by_surface_curvature)
        hyp.SetFuseEdges(self.fuse_coincident_nodes)
        hyp.SetUseDelauney(self.use_delauney)
        hyp.SetQuadAllowed(quad_dominant)
        hyp.SetElemSizeWeight(self.element_size_weight)
        hyp.SetWorstElemMeasure(self.worst_element_measure)
        hyp.SetCheckChartBoundary(self.check_chart_boundary)
        hyp.SetCheckOverlapping(self.check_overlapping)
        hyp.SetNbSurfOptSteps(self.nb_surface_optimization_steps)
        hyp.SetNbVolOptSteps(self.nb_volume_optimization_steps)


class _NETGEN_SimpleHypothesis(Base):
    """General Mixin for :class:`_NETGEN2D_SimpleHypothesis` and
    :class:`_NETGEN3D_SimpleHypothesis`."""

    _HYPO = None

    #: Number of segments, that will split each edge, with equidistant
    #: distribution. Either this or local_length.
    #: :type: int | None
    nb_seg_per_edge = Input(1, validator=Optional(IsInstance(int)))

    #: Sets required length of segments. Either this or nb_seg_per_edge.
    #: :type: float | None
    local_length = Input(None)

    #: 2D mesh segments having a length calculated as an average edge length
    #: for a given wire. Either this or max_area.
    #: :type: bool
    length_from_edges = Input(True)

    #: Expected maximum element area for each 2d element.
    #: Either this or length_from_edges.
    #: :type: float | None
    max_area = Input(None)

    #: Set to ``True`` to try to generate a quadrangle
    #: 2D mesh. Triangle elements are created where quadrangles are not
    #: possible.
    #: :type: bool
    quad_dominant = Input(False, widget=CheckBox)

    def _set_hypo(self, hyp):
        """Configures NETGEN simple hypothesis ``hyp`` based on the Inputs for
        this class.

        :type hyp: OCC.NETGENPlugin.NETGENPlugin_SimpleHypothesis_2D |
            OCC.NETGENPlugin.NETGENPlugin_SimpleHypothesis_3D"""
        if self.length_from_edges:
            hyp.LengthFromEdges()
        if self.nb_seg_per_edge is not None:
            hyp.SetNumberOfSegments(self.nb_seg_per_edge)
        if self.local_length is not None:
            if self.nb_seg_per_edge is not None:
                warnings.warn(f"Both nb_seg_per_edge and local_length are"
                              f" set, only one of these should be active "
                              f"by setting the other one to None. "
                              f"Ignoring local_length! Object: {self!r}")
            else:
                hyp.SetLocalLength(self.local_length)
        if self.max_area is not None:
            if self.length_from_edges:
                warnings.warn(f"Both max_area and length_from_edges are set, "
                              f"only one of these should be active at a time. "
                              f"Ignoring max_area! Object: {self!r}")
            else:
                hyp.SetMaxElementArea(self.max_area)
        hyp.SetAllowQuadrangles(self.quad_dominant)


class _NETGEN2D_Hypothesis(_NETGEN2D, _NETGEN_Hypothesis):
    """Abstract base class for NETGEN hypotheses based on a 2D hypothesis.
    One has to implement ``_ALGO`` to work with this class.
    """

    _HYPO = NETGENPlugin_Hypothesis_2D


class _NETGEN3D_Hypothesis(_NETGEN3D, _NETGEN_Hypothesis):
    """Abstract base class for NETGEN hypotheses based on a 3D hypothesis.
    One has to implement ``_ALGO`` to work with this class.
    """

    _HYPO = NETGENPlugin_Hypothesis


class _NETGEN3D_HypothesisViscous(_NETGEN3D_Viscous, _NETGEN3D_Hypothesis):
    """Base class for NETGEN hypotheses based on a 3D hypothesis with
    support for viscous boundary layers.
    """


class _NETGEN2D_SimpleHypothesis(_NETGEN2D, _NETGEN_SimpleHypothesis):
    """Mixin for all 2D NETGEN..._Simple classes. One has to implement
    ``ALGO_`` to work with this class.
    """
    
    _HYPO = NETGENPlugin_SimpleHypothesis_2D


class _NETGEN3D_SimpleHypothesis(_NETGEN3D, _NETGEN_SimpleHypothesis):
    """Mixin for all 3D NETGEN..._Simple classes. One has to implement
    ``ALGO_`` to work with this class.
    """

    _HYPO = NETGENPlugin_SimpleHypothesis_3D

    #: Area of sides of volumic elements will be equal to an average area
    #: of 2D elements. Either this or max_volume
    #: .. note:: this setting does not seem to have much effect.
    #: :type: bool
    length_from_faces = Input(True,
                              """area of sides of volumic elements will be 
                              equal to an average area
                              of 2D elements. Either this or max_volume""")

    #: Expected maximum element volume of each 3d element. Either this or
    #: length_from_faces.
    #: .. note:: this setting does not seem to have much effect.
    #: :type: float | None
    max_volume = Input(None,
                       """expected maximum element volume of each 3d element. 
                       Either this or length_from_faces.""")

    def _set_hypo(self, hyp):
        """Configures NETGEN simple hypothesis ``hyp``.

        :type hyp: OCC.NETGENPlugin.NETGENPlugin_SimpleHypothesis_3D
        """

        _NETGEN_SimpleHypothesis._set_hypo(self, hyp)
        if self.length_from_faces:
            hyp.LengthFromFaces()
        if self.max_volume is not None:
            if self.length_from_faces:
                warnings.warn(f"Both max_volume and length_from_faces are "
                              f"set, only one of these should be active at "
                              f"a time. Ignoring max_volume! "
                              f"Object: {self!r}")
            else:
                hyp.SetMaxElementVolume(self.max_volume)


class _NETGEN3D_SimpleHypothesisViscous(_NETGEN3D_Viscous,
                                        _NETGEN3D_SimpleHypothesis):
    """Base class for simple NETGEN hypotheses based on a 3D hypothesis with
    support for viscous boundary layers.
    """
    pass


# =============================================================================
# Concrete NETGEN classes
# =============================================================================
class Tri(_NETGEN2D_Hypothesis):
    """Create a triangle grid using the NETGEN algorithms.

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> srf = RectangularSurface(1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of srf.
    >>> hyp_1d = FixedNumber(shape=srf, no=nb_segments)
    >>> hyp_2d = Tri(shape=srf)  # only_2d is True
    >>> mesh = Mesh(shape_to_mesh=srf, controls=(hyp_1d, hyp_2d))
    >>> mesh.grid.nb_faces
    36
    >>> # Or without specifying a 1D hypothesis (does not give the same result)
    >>> mesh.controls = hyp_2d
    >>> hyp_2d.only_2d = False  # now NETGEN has to create 1D elements itself
    >>> hyp_2d.nb_seg_per_edge = nb_segments
    >>> mesh.grid.nb_faces
    30
    >>> mesh.grid.nb_edges
    16

    .. note:: Settings that control the mesh, for instance
        :attr:``nb_seg_per_edge`` are sometimes only treated as an `advise`
        for the mesher. It is known that meshes are generated which look
        a lot like the ones requested, but do not meet all restrictions
        that were given in an Input.
    """

    #: If True, takes existing mesh on edges as starting point (default).
    #: You need seperately specify hypotheses for the underlying edges
    #: yourself. If False, you don't need these and this algorithm will
    #: also generate a grid on the underlying edges.
    #: :type: bool
    only_2d = Input(True, widget=CheckBox)

    @Attribute
    def _ALGO(self):
        """The algoritm to create the triangle grid with. Based on
        :attr:`only_2d`.

        :returns: A type that is either
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D_ONLY` or
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D`.
        :rtype: type
        """
        return NETGENPlugin_NETGEN_2D_ONLY if self.only_2d\
            else NETGENPlugin_NETGEN_2D


class TriSimple(_NETGEN2D_SimpleHypothesis):
    """Triangular grid with more simple parameters. Even with the same Inputs.
    this algorithm might produce different results than that of :class:`Tri`.

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> srf = RectangularSurface(1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of srf.
    >>> hyp_1d = FixedNumber(shape=srf, no=nb_segments)
    >>> hyp_2d = TriSimple(shape=srf)  # only_2d is True
    >>> mesh = Mesh(shape_to_mesh=srf, controls=(hyp_1d, hyp_2d))
    >>> mesh.grid.nb_faces
    34
    >>> # Or without specifying a 1D hypothesis (does not give the same result)
    >>> mesh.controls = hyp_2d
    >>> hyp_2d.only_2d = False  # now NETGEN has to create 1D elements itself
    >>> hyp_2d.nb_seg_per_edge = nb_segments
    >>> mesh.grid.nb_faces
    19

    .. note:: Settings that control the mesh, for instance
        :attr:``nb_seg_per_edge`` are sometimes only treated as an `advise`
        for the mesher. It is known that meshes are generated which look
        a lot like the ones requested, but do not meet all restrictions
        that were given in an Input.
    .. note:: It seems that setting :attr:`only_2d` to :py:`True` makes the
        Inputs unresponsive.
    """

    #: If False, requires separate 1D hypotheses on edges (default).
    #: :type: bool
    only_2d = Input(True, widget=CheckBox)

    @Attribute
    def _ALGO(self):
        """The algoritm to create the triangle grid with. Based on
        :attr:`only_2d`.

        :returns: A type that is either
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D_ONLY` or
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D`.
        :rtype: type
        """
        return NETGENPlugin_NETGEN_2D_ONLY if self.only_2d\
            else NETGENPlugin_NETGEN_2D


class Tetra(_NETGEN3D_Hypothesis):
    """A tetrahedral grid generated by the NETGEN mesher.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Tri
    >>> box = Box(1, 1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of the box.
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d = Tri(shape=box)  # only_2d is True
    >>> hyp_3d = Tetra(shape=box)  # only_3d is True
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, hyp_2d, hyp_3d))
    >>> mesh.grid.nb_volumes
    494
    >>> # Generate a mesh without providing any 1D or 2D hypotheses
    >>> # this might generate different results
    >>> mesh.controls = hyp_3d
    >>> hyp_3d.only_3d = False  # It should generate 1D and 2D meshes
    >>> hyp_3d.nb_seg_per_edge = nb_segments
    >>> mesh.grid.nb_volumes
    278
    """

    #: If True, takes existing mesh on faces as starting point (default).
    #: You need seperately specify hypotheses for the underlying faces/edges
    #: yourself. If False, you don't need these and this algorithm will also
    #: generate a grid on the underlying faces/edges.
    #: :type: bool
    only_3d = Input(True, widget=CheckBox)

    @Attribute
    def _ALGO(self):
        """The algoritm to create the triangle grid with. Based on
        :attr:`only_3d`.

        :returns: A type that is either
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_3D` or
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D3D`.
        :rtype: type
        """
        return NETGENPlugin_NETGEN_3D if self.only_3d else\
            NETGENPlugin_NETGEN_2D3D


class TetraSimple(_NETGEN3D_SimpleHypothesis):
    """Tetrahedral grid built using the NETGEN mesher, but with simpler
    parameters.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Tri
    >>> box = Box(1, 1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of the box.
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d = Tri(shape=box)  # only_2d is True
    >>> hyp_3d = TetraSimple(shape=box)  # only_3d is True
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, hyp_2d, hyp_3d))
    >>> mesh.grid.nb_volumes
    494
    >>> # Generate a mesh without providing any 1D or 2D hypotheses
    >>> # this might generate different results
    >>> mesh.controls = hyp_3d
    >>> hyp_3d.only_3d = False  # It should generate 1D and 2D meshes
    >>> hyp_3d.nb_seg_per_edge = nb_segments
    >>> mesh.grid.nb_volumes
    408

    .. note:: This algorithm will, even with the same Inputs,
        not necessarily generate the same results as :class:`Tetra`.

    .. note:: When setting :attr:`only_3d` to :py:`True`, this algorithm seems
        to be unresponsive to settings.
    """

    #: If True, takes existing mesh on faces as starting point (default).
    #: You need seperately specify hypotheses for the underlying faces/edges
    #: yourself. If False, you don't need these and this algorithm will also
    #: generate a grid on the underlying faces/edges.
    #: :type: bool
    only_3d = Input(True, widget=CheckBox)

    @Attribute
    def _ALGO(self):
        """The algoritm to create the triangle grid with. Based on
        :attr:`only_3d`.

        :returns: A type that is either
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_3D` or
            :class:`OCC.NETGENPlugin.NETGENPlugin_NETGEN_2D3D`.
        :rtype: type
        """
        return NETGENPlugin_NETGEN_3D if self.only_3d\
            else NETGENPlugin_NETGEN_2D3D


class TetraViscous(_NETGEN3D_HypothesisViscous):
    """
    Tetrahedral grid with extra viscous layer controls.
    Requires separate 1D/2D hypotheses on edges/faces.

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Tri
    >>> box = Box(1, 1, 1)
    >>> nb_segments = 4
    >>> thickness = 0.05
    >>> # apply a fixed number of segments to each edge of the box.
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d = Tri(shape=box)  # only_2d is True
    >>> hyp_3d = TetraViscous(shape=box, t=thickness)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, hyp_2d, hyp_3d))
    >>> mesh.grid.nb_volumes
    898
    >>> # exclude top and bottom face of having a viscous boundary layer
    >>> hyp_3d.faces_to_exclude = (box.top_face, box.bottom_face)
    >>> mesh.grid.nb_volumes
    809

    .. note:: This algorithm will, even with the same Inputs,
        not necessarily generate the same results as
        :class:`TetraSimpleViscous`.
    """


class TetraSimpleViscous(_NETGEN3D_SimpleHypothesisViscous):
    """
    Tetrahedral grid with simpler parameters and extra viscous layer controls.
    Requires separate 1D/2D hypotheses on edges/faces.

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Tri
    >>> box = Box(1, 1, 1)
    >>> nb_segments = 4
    >>> thickness = 0.05
    >>> # apply a fixed number of segments to each edge of the box.
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d = Tri(shape=box)  # only_2d is True
    >>> hyp_3d = TetraSimpleViscous(shape=box, t=thickness)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, hyp_2d, hyp_3d))
    >>> mesh.grid.nb_volumes
    898
    >>> # exclude top and bottom face of having a viscous boundary layer
    >>> hyp_3d.faces_to_exclude = (box.top_face, box.bottom_face)
    >>> mesh.grid.nb_volumes
    809

    .. note:: This algorithm will, even with the same Inputs,
        not necessarily generate the same results as :class:`TetraViscous`.
    """

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Salome hypotheses"""

import warnings

from OCC.wrapper.StdMeshers import (
    StdMeshers_ProjectionSource1D,
    StdMeshers_ProjectionSource2D,
    StdMeshers_Projection_1D,
    StdMeshers_Projection_1D2D,
    StdMeshers_Projection_2D,
    StdMeshers_ViscousLayers)
from OCC.utils.mesh import (
    apply_arithmic, apply_extrusion, apply_extrusion_viscous,
    apply_fixed_length, apply_fixed_number, apply_fixed_points,
    apply_fixed_start_end_length, apply_hexa, apply_many_to_many_projection,
    apply_max_deflection, apply_max_length, apply_mefisto2d, apply_projection,
    apply_propagate, apply_quad, apply_radial_prism,
    apply_segment_length_around_vertex, apply_viscous_hexa,
    configure_viscous_faces)

from parapy.core import Attribute, Input, ensure_iterable
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.part import PartNoParsing
from parapy.geom.occ.clone import Clone
from parapy.geom.occ.utilities import topods_shape_getter
from parapy.mesh.core.controls import (
    MeshControl, MeshControl0D, MeshControl1D, MeshControl2D, MeshControl3D,
    _Projection as _ProjectionCore)


# =============================================================================
# Abstract classes
# =============================================================================
class SalomeHypotheses(MeshControl):
    """Abstract base class for all Salome Hypothesis objects."""

    def _apply(self, ID, generator, mesh):
        """Abstract method to implement in sub-classes. Called by
        Mesh.apply_hypotheses.

        :param int ID: last hypothesis ID.
        :param OCC.SMESH.SMESH_Gen generator: mesh generator.
        :param OCC.SMESH.SMESH_Mesh mesh: mesh instance.
        :returns: current Salome ID.
        :rtype: int
        """
        raise NotImplementedError()


class SalomeHypothesis0D(MeshControl0D, SalomeHypotheses):
    """
    Abstract base class for all 1D Salome Hypotheses.
    """

    #: Should the input edges be treated as a composite edge? (default: False)
    #: If True, it will try to treat the edges in :attr:`shape` as one edge
    #: during meshing, based on if they are C1 continuous with respect to
    #: each other.
    #: :type: bool
    composite = Input(False)

    pass


class SalomeHypothesis1D(MeshControl1D, SalomeHypotheses):
    """
    Abstract base class for all 1D Salome Hypotheses.
    """

    #: Should the input edges be treated as a composite edge? (default: False)
    #: If True, it will try to treat the edges in :attr:`shape` as one edge
    #: during meshing, based on if they are C1 continuous with respect to
    #: each other.
    #: :type: bool
    composite = Input(False)

    pass


class SalomeControl2D(MeshControl2D, SalomeHypotheses):
    """
    Abstract base class for all 2D Salome Hypotheses.
    """
    pass


class SalomeControl3D(MeshControl3D, SalomeHypotheses):
    """
    Abstract base class for all 3D Salome Hypotheses.
    """
    pass


class _ProjectionSalome(_ProjectionCore):
    """
    Abstract base class for Salome mesh projection hypotheses.
    """
    _HYP = None
    _HYPSETSOURCE = None
    _ALGO = None

    def _apply(self, ID, generator, mesh):
        """Apply the projection to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        set_source_func = self._HYPSETSOURCE.__func__

        if self.projection_case == "many-to-many":
            topods_source_shapes = map(topods_shape_getter,
                                        self.source_shapes)
            topods_shapes = map(topods_shape_getter, self.shapes)
            last_id = apply_many_to_many_projection(topods_source_shapes,
                                                    topods_shapes,
                                                    ID, generator, mesh,
                                                    self._HYP, self._ALGO,
                                                    set_source_func)

        elif self.projection_case == "one-to-many":
            last_id = apply_projection(self.TopoDS_Shape_source,
                                       self.TopoDS_Shape,
                                       ID, generator, mesh, self._HYP,
                                       self._ALGO,
                                       set_source_func)

        else:
            msg = ("should not have happened, projection_case {} is not an "
                   "option,")
            assert False, msg.format(self.projection_case)

        return last_id


# FIXME ( ): get rid of using duplicate faces.
class _ViscousLayerMixin(SalomeControl3D):
    # TODO (TBD): Good description of this abstract class. Author: FT.

    __initargs__ = ["t", "no_layers", "stretch_factor"]

    _VHYPO = StdMeshers_ViscousLayers

    #: List of faces with a viscous layer.
    #: Either define this or faces_to_exclude.Integers are
    #: allowed
    #: :type: collections.Sequence[parapy.geom.Face]|collections.Sequence[int]
    faces_to_include = Input([],
                             """List of faces with a viscous layer.
                             Either define this or faces_to_exclude.Integers are
                             allowed""")

    #: List of faces without a viscous layer. Either define this or
    #: faces_to_include. faces_to_include is empty and this as well,
    #: all faces are understood to have viscous layers. Integers are
    #: allowed
    #: :type: collections.Sequence[parapy.geom.Face]|collections.Sequence[int]
    faces_to_exclude = Input(
        [],
        """List of faces without a viscous layer. Either define this or
        faces_to_include. faces_to_include is empty and this as well,
        all faces are understood to have viscous layers. Integers are
        allowed""")

    #: :type: float
    t = Input(doc="total thickness of the viscous layer")

    #: :type: int
    no_layers = Input(2, "no of viscous layers")

    #: :type: float
    stretch_factor = Input(1.0, "stretching factor in viscous layers")

    @Attribute
    def true_faces_to_exclude(self):
        """The faces to exclude. If :attr:`faces_to_exclude` is set, it will
        return these faces. Otherwise it generates them from :attr:`shape` and
        :attr:`faces_to_include`.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        faces_to_exclude = ensure_iterable(self.faces_to_exclude)
        faces_to_include = ensure_iterable(self.faces_to_include)
        f = lambda identifier: self._shape_from_identifier(identifier,
                                                           dimension=2)
        faces_to_exclude = [f(shape) for shape in faces_to_exclude]
        faces_to_include = [f(shape) for shape in faces_to_include]

        if faces_to_exclude:
            return faces_to_exclude
        elif faces_to_include:
            return list(set(self.shape.faces) - set(faces_to_include))
        else:
            # empty list
            return []

    @Attribute
    def true_faces_to_include(self):
        """The faces that are included in this viscous layer operation.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return list(set(self.shape.faces) - set(self.true_faces_to_exclude))

    # =========================================================================
    # Visualization of inputs
    # =========================================================================
    @PartNoParsing
    def viscous_faces(self):
        """The viscous faces.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return Clone(self.true_faces_to_include, color="GREEN")

    @PartNoParsing
    def non_viscous_faces(self):
        """The non-viscous faces.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return Clone(self.true_faces_to_exclude, color="RED")

    # =========================================================================
    # Methods
    # =========================================================================
    def true_faces_to_exclude_subshapeids(self, mesh):
        """The sub_shape ids of the faces in :attr:`true_faces_to_exclude` in
        ``mesh``.

        :param OCC.SMESH.SMESH_Mesh mesh: Mesh containing the faces listed in
            :attr:`true_faces_to_exclude`
        :rtype: list[int]
        """
        meshds = mesh.GetMeshDS()
        shape_to_index = meshds.ShapeToIndex
        faces_to_exclude = self.true_faces_to_exclude

        return [shape_to_index(face.TopoDS_Shape) for face in faces_to_exclude]

    def _set_vhypo(self, hyp, mesh):
        """Set the Viscous layer hypothesis `hyp` and apply it for ``mesh``.

        :type hyp:  OCC.StdMeshers.StdMeshers_ViscousLayers
        :type mesh: OCC.SMESH.SMESH_Mesh
        :return:
        """
        subshape_ids = self.true_faces_to_exclude_subshapeids(mesh)

        configure_viscous_faces(hyp, self.t,
                                faces_to_exclude_ids=subshape_ids,
                                no_layers=self.no_layers,
                                stretch_factor=self.stretch_factor)


class SegmentLengthAroundVertex(SalomeHypothesis0D):
    """Mesh control that allows to define the local size of the segments in
    the neighborhood of a certain vertex. If we assign to
    :attr:`shape_to_mesh` a geometrical object of higher dimension, it applies
    to all its vertices. This control works in conjunction with other 1D mesh
    control. First, nodes are placed on edges according to a 1D control, and
    then nodes near vertices are modified to assure the segment length
    required by :attr:`length` near the applicable vertex.

    Usage:

    >>> from parapy.geom import Point, LineSegment
    >>> from parapy.mesh.salome import Mesh, FixedLength
    >>> edge = LineSegment(Point(0, 0, 0), Point(10, 0, 0))
    >>> hyp1d = FixedLength(shape=edge, length=1)
    >>> mesh = Mesh(shape_to_mesh=edge, controls=(hyp1d))
    >>> len(mesh.grid.edges)
    10
    >>> # now let's add local controls on the vertices of the edge
    >>> from parapy.mesh.salome import SegmentLengthAroundVertex
    >>> hyp0d = SegmentLengthAroundVertex(shape=edge.vertices, length=0.5)
    >>> mesh = Mesh(shape_to_mesh=edge, controls=(hyp0d, hyp1d))
    >>> len(mesh.grid.edges)
    14
    """

    #: length near vertex or vertices
    length = Input()

    def _apply(self, ID, generator, mesh):
        """Apply the segment length around vertex hypothesis to ``mesh``
        that will be generated by ``generator`` giving it ``ID`` to identify
        it. Returns the last hypothesis ID that was given to a meshing
        hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_segment_length_around_vertex(
            self.TopoDS_Shape, ID, generator, mesh, self.length)
        return last_id


class FixedNumber(SalomeHypothesis1D):
    """
    Place a fixed number of segments on an edge with a certain distribution.
    For now only regular and scaled distributions are coupled.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> box = Box(1, 2, 3)
    >>> nb_segments = 4
    >>> fn = FixedNumber(shape=box, no=nb_segments)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(fn,))
    >>> len(mesh.grid.edges)  # nb_segments * 12
    48
    >>> fn_scaled = FixedNumber(shape=box,
    ...                         no=nb_segments,
    ...                         scale_factor=2.)
    >>> mesh_scaled = Mesh(shape_to_mesh=box, controls=(fn_scaled,))
    >>> len(mesh_scaled.grid.edges)  # nb_segments * 12, scaled distribution
    48
    >>> fn_expression = FixedNumber(shape=box,
    ...                             no=nb_segments,
    ...                             expression_function="cos(t)")
    >>> mesh_expression = Mesh(shape_to_mesh=box, controls=(fn_expression,))
    >>> len(mesh_expression.grid.edges)  # nb_segments * 12, distribution
    ...                                  # by expression
    48

    """

#    Note for self:
#    SetDistrType Enum
#    0. DT_Regular, //!< equidistant distribution
#    1. DT_Scale,   //!< scale distribution
#    2. DT_TabFunc, //!< distribution with density function presented by table
#    3. DT_ExprFunc

    __initargs__ = ["no"]

    #: number of segments.
    #: :type: int
    no = Input()

    #: :type: float
    scale_factor = Input(None)

    #: string containing the expression of the function f(t), e.g. "sin(t)"
    #: :type: str
    expression_function = Input(None)

    #: :type: bool
    reverse_edges = Input(False)

    def _apply(self, ID, generator, mesh):
        """Apply the fixed number hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_fixed_number(self.TopoDS_Shape, ID, generator, mesh,
                                     self.no,
                                     self.scale_factor,
                                     self.expression_function,
                                     self.reverse_edges,
                                     composite=self.composite)
        return last_id


class FixedLength(SalomeHypothesis1D):
    """Applies a fixed length hypothesis to the 1D elements (edges) of a
    ``shape`` that ensures the elements to be of a given ``length``.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedLength, Mesh
    >>> box = Box(1, 2, 3)
    >>> segment_length = 0.1
    >>> hyp = FixedLength(shape=box, length=segment_length)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp,))
    >>> len(mesh.grid.edges)  # ((1 + 2 + 3) * 4) / segment_length
    240

    """

    __initargs__ = ["length", "shape"]

    #: :type: float
    length = Input()

    def _apply(self, ID, generator, mesh):
        """Apply the fixed length hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_fixed_length(self.TopoDS_Shape, ID, generator, mesh,
                                     self.length, composite=self.composite)
        return last_id


class MaxDeflection(SalomeHypothesis1D):
    """Creates 1D mesh on ``shape`` ensuring that the value of deflection (or
    chord error) isn't larger than :attr:`deflection`. Usage:

    >>> from parapy.geom import Circle
    >>> from parapy.mesh.salome import Mesh, MaxDeflection
    >>> edge = Circle(radius=1)
    >>> deflection = 0.1
    >>> hyp = MaxDeflection(shape=edge, deflection=deflection)
    >>> mesh = Mesh(shape_to_mesh=edge, controls=[hyp])
    >>> len(mesh.grid.edges)
    7
    >>> hyp.deflection = 0.01
    >>> len(mesh.grid.edges)
    23
    """

    __initargs__ = ["deflection", "shape"]

    #: :type: float
    deflection = Input()

    def _apply(self, ID, generator, mesh):
        """Apply the fixed length hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_max_deflection(self.TopoDS_Shape, ID, generator, mesh,
                                       self.deflection, composite=self.composite)
        return last_id


class FixedStartEndLength(SalomeHypothesis1D):
    """Applies a hypothesis to the 1D elements (edges) of a
    ``shape`` that ensures the first element to have :attr:`start_length`
    and the last element to have :attr:`end_length`. The length of intermediate
    segments changes with automatically chosen geometric progression.
    The start and end can be swapped by setting :attr:`reverse_edges` to True.

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> from parapy.mesh.salome import FixedLength, Mesh
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> hyp = FixedStartEndLength(shape=crv,
    ...                           start_length=0.1,
    ...                           end_length=0.4)
    >>> mesh = Mesh(shape_to_mesh=crv, controls=(hyp,))
    >>> # Get the length of the segments in the edge-mesh
    ... edge_lengths = [e.length for e in mesh.grid.edges]
    >>> edge_lengths  # doctest: +ELLIPSIS
    [0.1, ..., 0.4]
    >>> sum(edge_lengths) == crv.length
    True
    >>> # reverse the order of the segments
    >>> hyp.reverse_edges = True
    >>> rev_edge_lengths = [e.length for e in mesh.grid.edges]
    >>> rev_edge_lengths # doctest: +ELLIPSIS
    [0.4, ..., 0.099...]
    >>> sum(rev_edge_lengths) == crv.length
    True
    """

    __initargs__ = ["start_length", "end_length", "shape"]

    #: Length of the first segment on an edge.
    #: :type: float
    start_length = Input()

    #: :type: float
    end_length = Input()

    #: To reverse the edge given.
    #: :type: bool
    reverse_edges = Input(False, "to reverse the edge given")

    def _apply(self, ID, generator, mesh):
        """Apply the fixed start-end length hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_fixed_start_end_length(
            self.TopoDS_Shape, ID, generator, mesh,
            self.start_length,
            self.end_length,
            reverse_edges=self.reverse_edges,
            composite=self.composite)

        return last_id


class Arithmic(FixedStartEndLength):
    """Applies a hypothesis to the 1D elements (edges) of a ``shape`` that
    ensures the first element to have :attr:`start_length` and the last
    element to have :attr:`end_length`. The length of intermediate segments
    changes with automatically chosen arithmetic progression
    (``Lk = Lk-1 + d``). The start and end can be swapped by setting
    :attr:`reverse_edges` to True.

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> from parapy.mesh.salome import FixedLength, Mesh
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> hyp = Arithmic(shape=crv,
    ...                start_length=0.1,
    ...                end_length=0.4)
    >>> mesh = Mesh(shape_to_mesh=crv, controls=(hyp,))
    >>> # Get the length of the segments in the edge-mesh
    ... edge_lengths = [e.length for e in mesh.grid.edges]
    >>> edge_lengths  # doctest: +ELLIPSIS
    [0.1, ..., 0.399...]
    >>> sum(edge_lengths) == crv.length
    True
    >>> # reverse the order of the segments
    >>> hyp.reverse_edges = True
    >>> rev_edge_lengths = [e.length for e in mesh.grid.edges]
    >>> rev_edge_lengths # doctest: +ELLIPSIS
    [0.399..., ..., 0.099...]
    >>> sum(rev_edge_lengths) == crv.length
    True

    .. note:: This class is similar to :class:`FixedStartEndLength`,
        however fills up the space in-between the start and end segment
        differently: using :class:`Arithmetic`, the length changes in
        arithmetic progression.
    """

    __initargs__ = ["start_length", "end_length", "shape"]

    def _apply(self, ID, generator, mesh):
        """Apply the fixed start-end length hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_arithmic(self.TopoDS_Shape, ID, generator, mesh,
                                 self.start_length, self.end_length,
                                 reverse_edges=self.reverse_edges,
                                 composite=self.composite)

        return last_id


# TODO: geometric progression
class FixedPoints(SalomeHypothesis1D):
    """Places a mesh on the edge(s of) ``shape`` defined by
    :attr:`parameters`. The :attr:`parameters` define the place [0, 1] on
    the edge where nodes should be put that define mesh its edge-segments.

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> from parapy.mesh.salome import FixedLength, Mesh
    >>> crv = LineSegment(Point(0, 0, 0), Point(2, 0, 0))
    >>> params = (0.1, 0.15, 0.4, 0.9)
    >>> hyp = FixedPoints(shape=crv,
    ...                   parameters=params)
    >>> mesh = Mesh(shape_to_mesh=crv, controls=(hyp,))
    >>> crv.length
    2.0
    >>> edge_lengths = [e.length for e in mesh.grid.edges]
    >>> edge_lengths  # doctest: +ELLIPSIS
    [0.2, 0.099..., 0.5, 1.0, 0.19...]
    >>> # reverse the direction
    ... hyp.reverse_edges = True
    >>> rev_edge_lengths = [e.length for e in mesh.grid.edges]
    >>> rev_edge_lengths  # doctest: +ELLIPSIS
    [0.19..., 1.0, 0.5, 0.10..., 0.19...]
    """
    __initargs__ = ["parameters", "shape"]

    #: list of parameters in the range [0-1] where you want the points,
    #: exclude 0 and 1.
    #: :type: collections.Sequence[float]
    parameters = Input(
        doc="list of parameters [0-1] where you want the points, "
            "exclude 0 and 1.")

    #: Reverse the given edge?
    #: :type: bool
    reverse_edges = Input(False, "to reverse the edge given")

    def plot_parameters(self):
        """Plots :attr:`parameters`. One needs to have ``matplotlib``
        installed in the environment to use this.

        :returns: the differences between two following parameters.
        :return: list[float]
        """
        # noinspection PyUnresolvedReferences
        from matplotlib import pyplot as plt  # @UnresolvedImport

        ids = range(1, len(self.parameters) + 2)
        diffs = [y - x for x, y in
                 zip([0] + self.parameters, self.parameters + [1])]
        plt.plot(ids, [0] + self.parameters, 'rs', ids, diffs, 'gs')
        plt.show()
        return diffs

    @classmethod
    def boundary_layer_parameters(cls, edge, yplus, growth_factor, N_layers, N,
                                  fill_type="growing"):
        """Points for the boundary layer on ``edge``.

        :param parapy.geom.Curve | parapy.geom.Edge edge: edge for which
            the boundary layer parameters should be calculated.
        :param float yplus: Dimensionless wall distance.
        :param float growth_factor: >= 1.0
        :param int N_layers: Should be <= :py:`N-1`.
        :param int N:
        :param str fill_type: Either 'growing' or 'constant'.
        :rtype: list[float]
        :raises ValueError: when one of the arguments has an illegal value.
        """
        uplus = yplus / edge.length
        return cls._boundary_layer_parameters(uplus, growth_factor, N_layers,
                                              N, fill_type)

    @classmethod
    def _boundary_layer_parameters(cls, uplus, growth_factor, N_layers, N,
                                   fill_type="growing"):
        """Points for the boundary layer on ``edge``.

        :param parapy.geom.Curve | parapy.geom.Edge edge: edge for which
            the boundary layer parameters should be calculated.
        :param float uplus: Boundary layer thickness.
        :param float growth_factor: >= 1.0
        :param int N_layers: Should be <= :py:`N-1`.
        :param int N: Number of segments that these parameters divide
        :param str fill_type: Either 'growing' or 'constant'.
        :rtype: list[float]
        :raises ValueError: when one of the arguments has an illegal value.
        """
        # assuming linear parameterization
        if not growth_factor >= 1.0:
            raise ValueError("growth factor should be >= 1")
        # uplus = edge.total_length / yplus
        if not uplus < 1:
            raise ValueError(
                "boundary layer thickness yplus is bigger than edge length")
        if not N_layers <= N - 1:
            raise ValueError("combination of N_layers and total N not valid")
        if not fill_type in ["constant", "growing"]:
            raise ValueError("fill_type is either 'constant' or 'growing'")
        # algorithm should loop through initial layers and test
        # linear continuation.
        parameters = [uplus]
        u = uplus
        d = uplus
        N_remaining = N - 1

        def constant_fill():
            """fills up rest of space with n constant spacing"""
            L_remaining = 1 - u
            d = L_remaining / N_remaining
            for i in range(1, N_remaining):
                parameters.append(u + d * i)

        def growing_fill():
            """fills up rest of space with n constant spacing"""
            u_local = u
            L_remaining = 1 - u_local
            d_min = d * growth_factor
            if L_remaining / d_min < N_remaining:
                print("using constant spacing for remaining elements")
                constant_fill()
            else:
                d_avg = L_remaining / N_remaining
                delta = (d_avg - d_min) * 2
                grad = delta / (N_remaining - 1)
                # print L_remaining, N_remaining, d_min, d_avg, d_min + delta
                for i in range(N_remaining - 1):
                    d_ = d_min + i * grad
                    # print d_
                    u_local += d_
                    parameters.append(u_local)

        for i in range(1, N_layers):
            L_ = 1 - u  # remaining length
            d = d * growth_factor  # next size of element
            # u_ = u + d
            # If constant continuation of the current step d results in fewer
            # elements than still remaining, finish with constant_fill.
            if L_ / d < N_remaining:
                msg = ("boundary layer number {} would grow too big, filling "
                       "rest up with constantly spaced elements.")
                warnings.warn(msg.format(i + 1))
                constant_fill()
                return parameters
            else:
                # proceed with next element
                u += d
                parameters.append(u)
                N_remaining -= 1

        # now, decide for linear spacing or gradually growing from last
        # step size d till end.
        if fill_type == "constant":
            constant_fill()
            return parameters
        else:
            growing_fill()
            return parameters

    @classmethod
    def growing_parameters(cls, edge, yplus, growth_factor):
        """A utility to find the u parameters [0-1] on an
        edge for boundary layer
        patterns. These parameters can be used then as input to the
        FixedPoints class. Note that
        the values 0 and 1 are not included in the list and the number
        of segments is equal to len(parameters) + 1

        :param parapy.geom.Curve | parapy.geom.Edge edge: Edge on which the
            growing parameters shoud be put
        :param float yplus: Dimensionless wall distance.
        :param float growth_factor: Should be >= 1.0
        :rtype: list[float]
        """
        if not growth_factor >= 1.0:
            raise ValueError("growth factor should be >= 1")

        # assuming linear parameterization
        yplus = edge.length / yplus

        def summe(t0, g, N):
            return t0 * (g ** N - 1) / (g - 1)

        def find_N(t0, g):
            N = 1
            while summe(t0, g, N) < 1: N += 1
            return N

        N = find_N(yplus, growth_factor)
        # adjust y_plus
        yplus = 1 / summe(1, growth_factor, N)
        y = yplus
        d = yplus
        parameters = [y]
        for _ in range(N - 2):
            d = d * growth_factor
            y += d
            parameters.append(y)
        return parameters

    def _apply(self, ID, generator, mesh):
        """Apply the fixed points hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_fixed_points(self.TopoDS_Shape, ID, generator, mesh,
                                     parameters=self.parameters,
                                     reverse_edges=self.reverse_edges)

        return last_id


class MaxLength(SalomeHypothesis1D):
    """Set a 1D hypothesis on the edge(s of) :attr:`shape` that ensures
    a maximum length for the mesh segments/edges.

    If :attr:`length` is ``None``, :py:`S = S0 * f(L/Lmin)` where
    :py:`f(x) = 1 + (2/Pi * 7 * atan(x/5) )`

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> from parapy.mesh.salome import FixedLength, Mesh
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> max_length = 0.15
    >>> hyp_1d = MaxLength(shape=crv,
    ...                 length=max_length)
    >>> mesh = Mesh(shape_to_mesh=crv, controls=(hyp_1d,))
    >>> # Get the length of the segments in the edge-mesh
    >>> edge_lengths = [e.length for e in mesh.grid.edges]
    >>> edge_lengths  # doctest: +ELLIPSIS
    [0.14..., ..., 0.14...]
    >>> all(length <= max_length for length in edge_lengths)
    True

    .. note:: The segments their length are smaller or equal than the set
        ``length`` within a certain precision. For instance: the test
        :py:`segment_length <= max_length` might fail, however, the test will
        pass when rounding the ``segment_length`` to a given precision,
        for instance 6 decimals.
    """

    __initargs__ = ["length", "shape"]

    #: :type: float | None
    length = Input(None)

    def _apply(self, ID, generator, mesh):
        """Apply the maximum length hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_max_length(self.TopoDS_Shape, ID, generator, mesh,
                                   length=self.length)
        return last_id


class PropagateEdge(SalomeHypothesis1D, _ProjectionCore):
    """propagate the mesh *hypothesis* of :attr:`source_shape` (
    :class:`parapy.geom.Edge`) to the opposite edges in the shape,
    recursively, that will
    be meshed in this instance (``shape_to_mesh`` in the 
    :class:`parapy.mesh.salome.Mesh` instance).
    
    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> box = Box(1, 1, 1)
    >>> an_edge = box.edges[0]
    >>> nb_segments = 4
    >>> # apply a fixed number of segments on an_edge.
    >>> hyp_1d = FixedNumber(shape=an_edge, no=nb_segments)
    >>> # propagate the FixedNumber hypothesis to all opposite edges
    >>> # there are 3 edges opposite to an_edge in the box, since this happens
    >>> # recursively.
    >>> propagate = PropagateEdge(source_shape=an_edge)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, propagate))
    >>> len(mesh.grid.edges)  # nb_segments * 4
    16
    """

    __initargs__ = ["source_shape", "shape"]

    def _apply(self, ID, generator, mesh):
        """Apply the propagate edge hypothesis to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        if self.is_user_defined('shape'):
            msg = ("Setting `shape` is deprecated, and currently has no "
                   "effect on the result. The propagation will affect the "
                   "whole shape that is set to be meshed. Do not set `shape`. "
                   "Object: {}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)

        last_id = apply_propagate(self.TopoDS_Shape_source,
                                  ID, generator, mesh)

        return last_id


class ProjectedEdge(_ProjectionSalome, SalomeHypothesis1D):
    """Project the resulting 1D mesh segments of :attr:`source_shape` to
    the edge(s of) :attr:`shape`. One can set multiple shapes to project
    on.

    If :attr:`source_shape` is a sequence, then :attr:`shape` is also
    expected to be a list with similar length.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> box = Box(1, 2, 3)
    >>> an_edge, another_edge = box.edges[0], box.edges[1]
    >>> nb_segments = 4
    >>> # apply a fixed number of segments on an_edge.
    >>> hyp_1d = FixedNumber(shape=an_edge, no=nb_segments)
    >>> # A 1 to 1 projection
    >>> project_2d = ProjectedEdge(source_shape=an_edge, shape=another_edge)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, project_2d))
    >>> len(mesh.grid.edges)  # nb_segments * 2
    8
    >>> # A 1-to-many projection, set multiple targets
    >>> project_2d.shape = (another_edge, box.edges[5], box.edges[8])
    >>> len(mesh.grid.edges)  # nb_segments * 4
    16

    .. note:: :class:`ProjectEdge` projects the result of a 1D hypothesis on
        other edges, and not the hypothesis itself.
    """

    # Does not have an effect on the outcome.
    composite = False

    __initargs__ = ["source_shape", "shape"]

    _HYP = StdMeshers_ProjectionSource1D
    _HYPSETSOURCE = StdMeshers_ProjectionSource1D.SetSourceEdge
    _ALGO = StdMeshers_Projection_1D


class ProjectedFace(_ProjectionSalome, SalomeControl2D):
    """This algorithm works only if all edges of the target face have
    been meshed as 1D Projections of the edges of the source face.
    http://docs.salome-platform.org/salome_6_6_0/gui/SMESH/projection_algos_page.html    

    If you set project_edges = True, this algorithm will also map edges.
    http://docs.salome-platform.org/salome_6_6_0/gui/SMESH/projection_algos_page.html

    One can do one-to-one, one-to-many and many-to-many projections. When
    :attr:`source_shape` is a Sequence, :attr:`shape` should be of the same
    length.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Quad, Mesh
    >>> box = Box(1, 1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of box.top_face.
    >>> hyp_1d = FixedNumber(shape=box.top_face, no=nb_segments)
    >>> hyp_2d = Quad(shape=box.top_face)
    >>> # A 1 to 1 projection, note that project_edges is needed since there is
    >>> # no 1D hypothesis on the bottom_face its edges.
    >>> project_2d = ProjectedFace(source_shape=box.top_face,
    ...                            shape=box.bottom_face,
    ...                            project_edges=True)
    >>> mesh = Mesh(shape_to_mesh=box, controls=(hyp_1d, hyp_2d, project_2d))
    >>> mesh.grid.nb_faces  # nb_segments ** 2 * 2
    32
    """

    __initargs__ = ["source_shape", "shape", "project_edges"]

    #: Should the edges be projected?
    #: :type: bool
    project_edges = Input(False, "if you want to also have edge projected")

    _HYP = StdMeshers_ProjectionSource2D
    _HYPSETSOURCE = StdMeshers_ProjectionSource2D.SetSourceFace

    @Attribute
    def _ALGO(self):
        """:rtype: OCC.StdMeshers.StdMeshers_Projection_1D2D | OCC.StdMeshers.StdMeshers_Projection_2D"""
        return StdMeshers_Projection_1D2D if self.project_edges \
            else StdMeshers_Projection_2D


class Quad(SalomeControl2D):
    """A 2D hypothesis that tries to put  a quad-mesh on the face(s of)
    :attr`shape`.

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> from parapy.mesh.salome import FixedNumber, Quad, Mesh
    >>> srf = RectangularSurface(1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of srf.
    >>> hyp_1d = FixedNumber(shape=srf, no=nb_segments)
    >>> hyp_2d = Quad(shape=srf)
    >>> mesh = Mesh(shape_to_mesh=srf, controls=(hyp_1d, hyp_2d))
    >>> mesh.grid.nb_faces  # nb_segments ** 2
    16
    """
    __initargs__ = ["shape"]

    #: enumeration:
    #: 0: QUAD_STANDARD
    #: 1: QUAD_TRIANGLE_PREF
    #: 2: QUAD_QUADRANGLE_PREF
    #: 3: QUAD_QUADRANGLE_PREF_REVERSED
    #: 4: QUAD_REDUCED
    #: 5: QUAD_NB_TYPES
    #: :type: int
    quadrangle_preferences = Input(0)

    # TODO (TBD): Doesn't seem to do anything?. Author: FT.
    #: :type: bool
    triangles_only = Input(False)

    def _apply(self, ID, generator, mesh):
        """Apply the Quad mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_quad(self.TopoDS_Shape, ID, generator, mesh,
                             self.quadrangle_preferences)
        # TODO (TBD): Before, self.hyp1 and self.algo were set. This is no
        # /todo longer the case... Should this be restored?
        return last_id


# TODO (TBD): Do something with this, the Tri class, and NETGEN.
class TriMefisto(SalomeControl2D):
    """Apply a triangle mesh on :attr:`shape`.

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> from parapy.mesh.salome import FixedNumber, Mesh
    >>> srf = RectangularSurface(1, 1)
    >>> nb_segments = 4
    >>> # apply a fixed number of segments to each edge of srf.
    >>> hyp_1d = FixedNumber(shape=srf, no=nb_segments)
    >>> hyp_2d = TriMefisto(shape=srf)
    >>> mesh = Mesh(shape_to_mesh=srf, controls=(hyp_1d, hyp_2d))
    >>> mesh.grid.nb_faces
    80

    .. note:: This algorithm is known to be unresponsive to the
        :attr:`max_area` and :attr:`length_from_edges` settings in some cases,
        for instance in some configurations with cubes.
    """

    #: Use the segment length from the segments on the 1D meshes (which are on
    #: the edges of ``shape``) for the segments (edges) within the 2D mesh.
    #: :type: bool
    length_from_edges = Input(False)

    #: Set limit on the maximum area of the meshed triangles.
    #: :type: float
    max_area = Input(None)

    def _apply(self, ID, generator, mesh):
        """Apply the Quad mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_mefisto2d(self.TopoDS_Shape, ID, generator, mesh,
                                  self.length_from_edges, self.max_area)

        return last_id


class Extrusion(SalomeControl3D):
    """A Prism mesh on a prism-like shape (6 faces). It takes
    two opposing faces with (typically)
    triangular surface meshes that match in topology (typically
    created using a ProjectedFace
    algorithm), and 4 faces with a quadrilateral surface mesh.
    The algorithm will try to
    automatically associate the bottom-top face pair.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Tri, Mesh
    >>> box = Box(1, 2, 3)
    >>> nb_segments = 5
    >>> # apply a fixed number of segments to each edge of the box
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d_quad = Quad(shape=box)
    >>> hyp_2d_tri = Tri(shape=(box.top_face, box.bottom_face))
    >>> hyp_3d = Extrusion(shape=box)
    >>> mesh = Mesh(shape_to_mesh=box,
    ...             controls=(hyp_1d, hyp_2d_tri, hyp_2d_quad, hyp_3d))
    >>> mesh.grid.nb_volumes  # doctest: +ELLIPSIS
    90

    """

    __initargs__ = ["shape"]

    #: DEPRECATED
    #: :type: parapy.geom.occ.face.Face_ | None
    bottom_face = Input(None)

    #: DEPRECATED
    #: :type: parapy.geom.occ.face.Face_ | None
    top_face = Input(None)

    #: DEPRECATED
    #: if you specify bottom and top_face, this can also
    #: be specified...
    #: :type: bool
    tetra = Input(True,
                  "if you specify bottom and top_face, this can also "
                  "be specified...")

    def _apply(self, ID, generator, mesh):
        """Apply the Extrusion mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        if (self.is_user_defined("bottom_face") or self.is_user_defined(
                "top_face") or self.is_user_defined('tetra')):
            msg = ("Setting either one of 'top_face', 'bottom_face' or "
                   "'tetra' is deprecated and no longer needed. Object: {}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)

        last_id = apply_extrusion(self.TopoDS_Shape, ID, generator, mesh)

        return last_id


# TODO (TBD): Investigate if this has value. Seems to do nothing more than
# /todo Extrusion.
class ExtrusionViscous(Extrusion, _ViscousLayerMixin):
    """Creates a prism-like viscous volume mesh in :attr:`shape`.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Tri, Mesh
    >>> box = Box(1, 2, 3)
    >>> nb_segments = 5
    >>> thickness = 0.05
    >>> # apply a fixed number of segments to each edge of the box
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d_quad = Quad(shape=(box))
    >>> hyp_2d_tri = Tri(shape=(box.top_face, box.bottom_face))
    >>> hyp_3d = ExtrusionViscous(shape=box, t=thickness)
    >>> mesh = Mesh(shape_to_mesh=box,
    ...             controls=(hyp_1d, hyp_2d_quad, hyp_2d_tri, hyp_3d))
    >>> mesh.grid.nb_volumes  # doctest: +ELLIPSIS
    90

    .. note:: Seems to be equivalent to :class:`Extrusion`. At least in the
        above example.
    """
    def _apply(self, ID, generator, mesh):
        """Apply the Viscous Extrusion mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        faces_to_exclude_ids = self.true_faces_to_exclude_subshapeids(mesh)

        last_id = apply_extrusion_viscous(
            self.TopoDS_Shape,
            ID,
            generator,
            mesh,
            self.t,  # thickness
            faces_to_exclude_ids=faces_to_exclude_ids,
            no_layers=self.no_layers,
            stretch_factor=self.stretch_factor)
        return last_id


class Hexa(SalomeControl3D):
    """Creates a hexa volume mesh in ``shape``.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Quad
    >>> box = Box(1, 2, 3)
    >>> nb_segments = 5
    >>> # apply a fixed number of segments to each edge of the box
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d_quad = Quad(shape=box)
    >>> hyp_3d = Hexa(shape=box)
    >>> mesh = Mesh(shape_to_mesh=box,
    ...             controls=(hyp_1d, hyp_2d_quad, hyp_3d))
    >>> mesh.grid.nb_volumes  # doctest: +ELLIPSIS
    125
    """

    def _apply(self, ID, generator, mesh):
        """Apply the Hexa mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_hexa(self.TopoDS_Shape, ID, generator, mesh)
        return last_id


class HexaViscous(Hexa, _ViscousLayerMixin):
    """Like :class:`Hexa` but gives options to apply viscous boundary
    layer options.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Quad
    >>> box = Box(1, 2, 3)
    >>> nb_segments = 5
    >>> thickness = 0.05
    >>> no_layers = 4
    >>> # apply a fixed number of segments to each edge of the box
    >>> hyp_1d = FixedNumber(shape=box, no=nb_segments)
    >>> hyp_2d_quad = Quad(shape=box)
    >>> hyp_3d = HexaViscous(shape=box, t=thickness, no_layers=no_layers)
    >>> mesh = Mesh(shape_to_mesh=box,
    ...             controls=(hyp_1d, hyp_2d_quad, hyp_3d))
    >>> mesh.grid.nb_volumes
    725
    >>> # exclude top and bottom face of having a viscous boundary layer
    >>> hyp_3d.faces_to_exclude = (box.top_face, box.bottom_face)
    >>> mesh.grid.nb_volumes
    525

    """
    def _apply(self, ID, generator, mesh):
        """Apply the Viscous Hexa mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        faces_to_exclude_ids = self.true_faces_to_exclude_subshapeids(mesh)

        last_id = apply_viscous_hexa(
            self.TopoDS_Shape,
            ID,
            generator,
            mesh,
            self.t,  # thickness
            faces_to_exclude_ids=faces_to_exclude_ids,
            no_layers=self.no_layers,
            stretch_factor=self.stretch_factor)

        return last_id


class RadialPrism(SalomeControl3D):
    """Creates a Radial prism mesh between two shells in :attr:`shape`. The
    opposite faces of the shells must have similar meshes for the
    algorithm to succeed. One can use :class:`ProjectedFace` to achieve this.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedNumber, Mesh, Quad, ProjectedFace
    >>> outer_box = Box(3, 3, 3, centered=True)
    >>> inner_box = Box(2, 2, 2, centered=True)
    >>> hollow_box = outer_box - inner_box
    >>> nb_segments = 4
    >>> no_layers = 4
    >>> # outer/inner faces of the hollow_box are original faces of the
    >>> # outer_box/inner_box. Obtain these using BRep.partner()
    >>> outer_faces = [hollow_box.partner(f) for f in outer_box.faces]
    >>> inner_faces = [hollow_box.partner(f) for f in inner_box.faces]
    >>> # apply a fixed number on one of the shells
    >>> hyp_1d_outer = FixedNumber(shape=outer_faces, no=nb_segments)
    >>> hyp_2d_outer = Quad(shape=outer_faces)
    >>> # now project the mesh of the outer faces onto the inner faces
    >>> hyp_2d_inner = ProjectedFace(source_shape=outer_faces,
    ...                              shape=inner_faces,
    ...                              project_edges=True)
    >>> hyp_3d = RadialPrism(shape=hollow_box, no_layers=no_layers)
    >>> mesh = Mesh(shape_to_mesh=hollow_box,
    ...             controls=(hyp_1d_outer, hyp_2d_outer, hyp_2d_inner, hyp_3d))
    >>> mesh.grid.nb_faces  # should equal 12 faces * 4 segments * 4 segments
    192
    >>> mesh.grid.nb_volumes  # should equal 6 faces * 4 segments * 4 segments * 4 layers
    384
    """

    #: The amount of layers the algorithm creates between the two shells.
    #: :type: int
    no_layers = Input(5)

    def _apply(self, ID, generator, mesh):
        """Apply the Radial Prism mesher to ``mesh`` that will be
        generated by ``generator`` giving it
        ``ID`` to identify it. Returns the last hypothesis ID that was given
        to a meshing hypothesis/algorithm.

        :param int ID: identifier for first hypothesis/algorithm
        :type generator: OCC.SMESH.SMESH_Gen
        :type mesh: OCC.SMESH.SMESH_Mesh
        :returns: last hypothesis/algorithm ID that was used
        :rtype: int
        """
        last_id = apply_radial_prism(self.TopoDS_Shape, ID, generator, mesh,
                                     self.no_layers)

        return last_id

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""
A set of operations used to improve the quality of a given mesh.
"""
from OCC.wrapper.SMESH import SMESH_MeshEditor, SMESH_Mesh, SMESH_subMesh
from OCC.wrapper.stdlib import set_SMDS_MeshElementcp_TIDcmp, set_SMDS_MeshNodecp
from OCC.utils.mesh import mesh_faces

from parapy.core import Base, Input
from parapy.core.validate import OneOf


class MeshRefinement(Base):
    """
    Abstract base class for all mesh refinement operations. One has to at least
    implement :meth:`_target_elements()` and :meth:`refine()`
    and set a dimension.

    The mesh refinements are used after the mesh itself has been created.
    """

    #: The target of this meshing operation. Should be either the meshed
    #: shape itself, or a group (or sequence : of groups) defined in the Mesh
    #: on which this refinement is applied.
    #: :type: parapy.geom.BRep | parapy.mesh.core.group.MeshGroup | collections.Iterable[parapy.geom.BRep | parapy.mesh.core.group.MeshGroup]
    target_groups = Input()

    dimension = None

    @classmethod
    def _target_elements(cls, submeshes):
        """Gather the mesh-elements which this
        mesh-refinement targets within ``submeshes``.

        :type submeshes: collections.Iterable[OCC.SMESH.SMESH_subMesh|OCC.SMESH.SMESH_Mesh]
        :rtype: OCC.stdlib.set_SMDS_MeshElementcp_TIDcmp
        """
        raise NotImplementedError("Method '_target_elements' is not "
                                  "implemented. Are "
                                  "you calling this on an abstract class?")

    def refine(self, editor, elems):
        """Execute the mesh refinement using ``editor`` on ``elems``.

        :type editor: OCC.SMESH.SMESH_MeshEditor
        :type elems: OCC.stdlib.set_SMDS_MeshElementcp_TIDcmp
        """
        raise NotImplementedError("Method 'refine' is not implemented. Are "
                                  "you calling this on an abstract class?")

    def _apply_refinement(self, mesh, submeshes):
        """
        Method that applies the mesh refinement.

        :type submeshes: collections.Iterable[OCC.SMESH.SMESH_subMesh]
        :type mesh: OCC.SMESH.SMESH_Mesh
        """
        editor = SMESH_MeshEditor(mesh)
        elems = self._target_elements(submeshes)
        self.refine(editor, elems)


# noinspection PyAbstractClass
class MeshRefinement1D(MeshRefinement):
    """
    Abstract base class for 1D mesh refinements. One has to at least
    implement :meth:`_target_elements()` and :meth:`refine()`
    """
    dimension = 1


# noinspection PyAbstractClass
class MeshRefinement2D(MeshRefinement):
    """
    Abstract base class for 2D mesh refinements. One has to at least
    implement :meth:`refine()`
    """
    dimension = 2

    @classmethod
    def _target_elements(cls, submeshes):
        """Class utility to gather the mesh-elements which this
        mesh-refinement targets. In this case the 2D elements.

        :type submeshes: tuple[OCC.SMESH.SMESH_subMesh | OCC.SMESH.SMESH_Mesh]
        :rtype: OCC.stdlib.set_SMDS_MeshElementcp_TIDcmp
        """
        elems = set_SMDS_MeshElementcp_TIDcmp()
        for submesh in submeshes:
            if isinstance(submesh, SMESH_Mesh):
                for face in mesh_faces(submesh):
                    elems.append(face)
            elif isinstance(submesh, SMESH_subMesh):
                it = submesh.GetSubMeshDS().GetElements()
                while it.more():
                    elems.append(it.next())
            else:
                msg = "Parameter 'submesh' of unsupported submesh type '{}'."
                raise ValueError(msg.format(type(submesh)))

        return elems


# noinspection PyAbstractClass
class MeshRefinement3D(MeshRefinement):
    """
    Abstract base class for 3D mesh refinements. One has to at least
    implement :meth:`_target_elements()` and :meth:`refine()`
    """
    dimension = 3


class Smoothing(MeshRefinement2D):
    """
    Applies a smoothing algorithm to the resulting mesh.

    >>> from parapy.geom import Box
    >>> from parapy.mesh.salome import FixedLength, Tri, Mesh
    >>> shape = Box(1, 1, 1)
    >>> group = shape.front_face
    >>> hyp_1d = FixedLength(shape=shape, length=0.2)
    >>> hyp_2d = Tri(shape=shape)
    >>> refinement2d = Smoothing(target_groups=group)
    >>> mesh = Mesh(shape_to_mesh=shape,
    ...             controls=[hyp_1d, hyp_2d],
    ...             groups=group,
    ...             refinements=refinement2d)
    >>> mesh.grid  # doctest: +ELLIPSIS
    <Grid ...>

    """

    #: Number of iterations this smoothing refinement is applied.
    #: :type: int
    iterations = Input(3)

    #: Name of the algorithm used for the smoothing. Either 'laplacian' or
    #: 'centroidal'.
    #: :type: str
    algorithm = Input('laplacian', validator=OneOf({'laplacian',
                                                    'centroidal'}))

    #: The target aspect ration of the mesh elements.
    #: :type: float
    aspect_ratio = Input(1.0)

    #: Should the smoothing respect the underlying surface?
    #: :type: bool
    in_2d = Input(True)

    __SMOOTHING_ALGO = {'laplacian': SMESH_MeshEditor.LAPLACIAN,
                        'centroidal': SMESH_MeshEditor.CENTROIDAL}

    def refine(self, editor, elems):
        """Apply the smoothing refinement on ``submesh``.

        :type editor: OCC.SMESH.SMESH_MeshEditor
        :type elems: OCC.stdlib.set_SMDS_MeshElementcp_TIDcmp
        """
        # nodes which were changed
        fixed = set_SMDS_MeshNodecp()
        algo = self.__SMOOTHING_ALGO[self.algorithm]
        editor.Smooth(elems, fixed, algo, self.iterations,
                      self.aspect_ratio, self.in_2d)

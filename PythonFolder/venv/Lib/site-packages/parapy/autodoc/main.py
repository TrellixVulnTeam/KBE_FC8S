#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import re
from types import MethodType

from six import itervalues

from sphinx.ext.autodoc import (AutoDirective, AttributeDocumenter, ALL,
                                ClassDocumenter as SphinxClassDocumenter,
                                MethodDocumenter as SphinxMethodDocumenter)

from parapy.autodoc.utils import trim_string, get_class_defining_attr
from parapy.core import Input, Base, Attribute, Part, Sequence
from parapy.core.abstractslot import AbstractSlot
from parapy.core.globs import Undefined
from parapy.autodoc.documenters import (SlotDocumenter as _SlotDocumenter,
                                        MethodDocumenter as _MethodDocumenter)

RE_TYPE_PATTERN = re.compile("^\s*:r?type\s*:")
HTML_CLASS_PARAPY = "ppclass"
MEMBER_TYPES = (AbstractSlot, MethodType, staticmethod, classmethod)
BASE_TYPES = (Base, Sequence)


class PPMixin(object):
    """
    Mixin for ParaPy Documenter classes
    """
    def add_raw(self, domain):
        sourcename = self.get_sourcename()
        directive = "raw"
        self.add_line('.. %s:: %s' % (directive, domain), sourcename)
        self.add_line('', sourcename)

    def add_rst_classes(self, classes):
        if classes:
            directive = "rst-class"
            sourcename = self.get_sourcename()
            self.add_line('.. %s:: %s' % (directive, " ".join(classes)),
                          sourcename)
            self.add_line('', sourcename)

    def add_default_value(self, value, width=None):
        s_val = repr(value)
        if width is not None:
            s_val = trim_string(s_val, limit=width)

        self.add_raw(domain="html")

        sourcename = self.get_sourcename()
        tmplt = "\t<meta class=\"default\" value=\"{:}\">"
        self.add_line('%s' % tmplt.format(s_val).expandtabs(), sourcename)
        self.add_line('', sourcename)

    def _set_options(self):
        ppdocumenter = self.ppdocumenter

        if ppdocumenter.inherited and not ppdocumenter.index_inherited:
            self.options.noindex = True


class ClassDocumenter(SphinxClassDocumenter, PPMixin):

    def import_object(self):
        flag = super(ClassDocumenter, self).import_object()
        if not flag or not issubclass(self.object, BASE_TYPES):
            attrs = ["filter_members", "add_directive_header",
                     "document_members", "import_object"]
            for attr in attrs:
                self.__reset_method(attr)

        return flag

    def __reset_method(self, attr):
        setattr(self, attr, getattr(super(ClassDocumenter, self), attr))

    def filter_members(self, members, want_all):
        result = super(ClassDocumenter, self).filter_members(members, want_all)

        private_members = self.options.private_members

        ret = []
        for membername, member, isattr in result:
            if isinstance(member, MEMBER_TYPES):
                if isinstance(member, AbstractSlot):
                    if not private_members and member._private:
                        continue
                ret.append((membername, member, isattr))
        return ret

    def add_directive_header(self, sig):
        self.add_rst_classes([HTML_CLASS_PARAPY])
        super(ClassDocumenter, self).add_directive_header(sig)

    def document_members(self, all_members=False):
        # type: (bool) -> None
        """Generate reST for member documentation.

        If *all_members* is True, do all members, else those given by
        *self.options.members*.
        """
        if self.doc_as_attr:
            return

        # set current namespace for finding members
        self.env.temp_data['autodoc:module'] = self.modname
        if self.objpath:
            self.env.temp_data['autodoc:class'] = self.objpath[0]

        want_all = all_members or self.options.inherited_members or \
            self.options.members is ALL
        # find out which members are documentable
        members_check_module, members = self.get_object_members(want_all)

        # remove members given by exclude-members
        if self.options.exclude_members:
            members = [(membername, member) for (membername, member) in members
                       if membername not in self.options.exclude_members]

        # document non-skipped members
        memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
        for (mname, member, isattr) in self.filter_members(members, want_all):
            classes = [cls for cls in itervalues(AutoDirective._registry)
                       if cls.can_document_member(member, mname, isattr, self)]
            if not classes:
                # don't know how to document this member
                continue
            # prefer the documenter with the highest priority
            classes.sort(key=lambda cls: cls.priority)
            # give explicitly separated module name, so that members
            # of inner classes can be documented
            full_mname = self.modname + '::' + \
                '.'.join(self.objpath + [mname])
            documenter = classes[-1](self.directive, full_mname, self.indent)
            documenter._ppmember = member
            memberdocumenters.append((documenter, isattr))

        member_order = self.options.member_order or \
            self.env.config.autodoc_member_order

        if member_order == 'groupwise':
            # sort by group; relies on stable sort to keep items in the
            # same group sorted alphabetically
            memberdocumenters.sort(key=lambda e: e[0].member_order)

        elif member_order == 'bysource' and self.analyzer:
            # sort by source order, by virtue of the module analyzer
            tagorder = self.analyzer.tagorder

            def keyfunc(entry):
                # type: (Tuple[Documenter, bool]) -> int
                fullname = entry[0].name.split('::')[1]
                return tagorder.get(fullname, len(tagorder))
            memberdocumenters.sort(key=keyfunc)

        required_inputs = []
        optional_inputs = []
        attributes = []
        parts = []
        methods = []
        others = []

        names = ["Required Inputs", "Optional Inputs", "Attributes", "Parts",
                 "Methods", "Others"]
        all = [required_inputs, optional_inputs, attributes, parts,
               methods, others]

        for documenter, isattr in memberdocumenters:
            obj = documenter._ppmember
            if isinstance(obj, Input):
                if obj.is_required:
                    lst = required_inputs
                else:
                    lst = optional_inputs
            elif isinstance(obj, Attribute):
                lst = attributes
            elif isinstance(obj, Part):
                lst = parts
            elif isinstance(obj, (MethodType, staticmethod, classmethod)):
                lst = methods
            else:
                lst = others
            lst.append((documenter, isattr))

        sourcename = self.get_sourcename()

        for (name, category) in zip(names, all):
            if category:
                self.add_raw(domain="html")

                tmplt = "\t<h2 class='category'>{}</h2>"
                self.add_line('%s' % tmplt.format(name).expandtabs(),
                              sourcename)
                self.add_line('', sourcename)
                # self.add_line()
                for documenter, isattr in category:
                    documenter.generate(
                        all_members=True, real_modname=self.real_modname,
                        check_module=members_check_module and not isattr)

        # reset current objects
        self.env.temp_data['autodoc:module'] = None
        self.env.temp_data['autodoc:class'] = None


class SlotDocumenter(AttributeDocumenter, PPMixin):
    priority = 90
    _ppdocumenter = None

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        return isinstance(member, AbstractSlot)

    @property
    def ppdocumenter(self):
        if not self._ppdocumenter:
            slot = self.object
            owner = slot._owner
            key = self.object_name
            cls = self.parent
            self._ppdocumenter = _SlotDocumenter(key, slot, cls, owner)
            self._set_options()

        return self._ppdocumenter

    def get_real_modname(self):
        # type: () -> str
        # slot object is leading in getting the module where it is documented
        return self.get_attr(self.object or self.parent , '__module__', None) \
            or self.modname

    def generate(self, **kwargs):
        # we need to 'real_modname' to none, because by default it is set
        # wrongly by the class documenter for inherited slots
        if 'real_modname' in kwargs:
            kwargs['real_modname'] = None

        super(SlotDocumenter, self).generate(**kwargs)

    def add_content(self, more_content, no_docstring=False):
        # if we inherited a slot, the slot its documentation is in a
        # different module and class than this object its 'logical' parent.
        # Therefore, the default attribute documentation lookup fails,
        # because it looks in <self.parent>.<slotname> instead of
        # <defining_class>.<slotname> (find_attr_docs saves the
        # documentation under the key <defining_class>.<slotname>). If we
        # are inherited, we will look up the attribute documentation in the
        # correct spot.
        sourcename = self.get_sourcename()

        slot_name_path = self.object.__fullname__.split('.')
        if self.ppdocumenter.inherited and self.objpath != slot_name_path:
            if self.analyzer:
                attr_docs = self.analyzer.find_attr_docs()
                if slot_name_path:
                    key = ('.'.join(slot_name_path[:-1]), slot_name_path[-1])
                    if key in attr_docs:
                        no_docstring = True
                        docstrings = [attr_docs[key]]
                        for i, line in enumerate(self.process_doc(docstrings)):
                            self.add_line(line, sourcename, i)

        super(SlotDocumenter, self).add_content(more_content, no_docstring)

    def add_directive_header(self, sig):
        self.add_rst_classes(self.ppdocumenter.html_classes)
        super(SlotDocumenter, self).add_directive_header(sig)


class InputDocumenter(SlotDocumenter):
    priority = 99

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        return isinstance(member, Input)

    def process_doc(self, docstrings):
        for docstringlines in docstrings:
            for i, line in enumerate(docstringlines[::-1]):
                if RE_TYPE_PATTERN.match(line):
                    try:
                        prevline = docstringlines[-1 - i - 1]
                    except IndexError:
                        break
                    else:
                        if prevline.strip():
                            docstringlines.insert(-1 - i, '')
        return super(InputDocumenter, self).process_doc(docstrings)

    def add_directive_header(self, sig):
        doc = self.ppdocumenter
        default_value = doc.default_value
        if default_value is not Undefined:
            self.add_default_value(default_value,
                                   width=doc.default_value_limit)

        super(InputDocumenter, self).add_directive_header(sig)


class MethodDocumenter(SphinxMethodDocumenter, PPMixin):
    priority = 90
    _ppdocumenter = None

    @classmethod
    def can_document_member(cls, member, membername, isattr, parent):
        flag = super(MethodDocumenter, cls).can_document_member(
            member, membername, isattr, parent)
        if flag:
            return issubclass(parent.object, BASE_TYPES)

    @property
    def ppdocumenter(self):
        if not self._ppdocumenter:
            method = self.object
            key = self.object_name
            cls = self.parent
            owner = get_class_defining_attr(cls, key)
            self._ppdocumenter = _MethodDocumenter(key, method, cls, owner)
            self._set_options()

        return self._ppdocumenter

    def add_directive_header(self, sig):
        self.add_rst_classes(self.ppdocumenter.html_classes)
        super(MethodDocumenter, self).add_directive_header(sig)


def py_role_fn(*args, **kwargs):
    from docutils.parsers.rst.roles import code_role
    return code_role(*args,
                     options={"language": "py",
                              "classes": ["highlight"]},
                     **kwargs)

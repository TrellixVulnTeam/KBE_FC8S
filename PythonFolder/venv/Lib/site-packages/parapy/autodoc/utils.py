#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
import warnings
from collections import OrderedDict, defaultdict

import os
import re
import datetime
from itertools import groupby
from operator import attrgetter
from types import FunctionType

from parapy.core.globs import Undefined, required, derived
from parapy.core.meta import basetype

DSCORE_REGEX = re.compile("^__[a-zA-Z][a-zA-Z0-9_]*[a-zA-Z0-9]__$")


def get_relative_path(basepath, targetpath):
    """Get relative path from  ``basepath`` to ``targetpath``.

    :param str basepath: base for relative path calculation.
    :param str targetpath: target path.
    :rtype: str
    """
    common_prefix = os.path.commonprefix([basepath, targetpath])
    path = os.path.relpath(targetpath, common_prefix)
    return path


def get_class_defining_attr(cls, attr):
    """Get (ancestor) class defining attr. Usage:

    >>> class Spam(object):
    ...     foo = 1
    >>> class Eggs(Spam):
    ...     bar = 2
    >>> get_class_defining_attr(Eggs, "bar")
    <class 'utils.Eggs'>
    >>> get_class_defining_attr(Eggs, "foo")
    <class 'utils.Spam'>

    :param type cls: Base class that exposes ``attr`` (through inheritance)
    :param str attr: Attribute
    :return: Class defining ``attr`` or None (if ``attr`` isn't owned by
        anyone).
    :rtype: type | None
    """
    for base in cls.__mro__:
        if attr in base.__dict__:
            return base
    return None


def is_attr_in_ancestors(cls, attr):
    """
    :param type cls: Base class that exposes ``attr`` (through inheritance)
    :param str attr: Attribute
    :return: Class defining ``attr`` or None (if ``attr`` isn't owned by
        anyone).
    :rtype: bool
    """
    for base in cls.__mro__:
        if base is not cls and attr in base.__dict__:
            return True
    return False


def is_attr_special(attr):
    """
    >>> is_attr_special("_spam")
    False
    >>> is_attr_special("__eggs__")
    True
    """
    return DSCORE_REGEX.match(attr)


def is_attr_private(attr, include_special=False):
    """
    >>> is_attr_private("_spam")
    True
    >>> is_attr_private("__eggs__")
    True
    >>> is_attr_private("__eggs__", include_special=False)
    False
    """
    global DSCORE_REGEX
    return attr.startswith("_") and (include_special or not DSCORE_REGEX.match(attr))


def rstheader(text, token="=", overline=False):
    """Return rst header string. Usage:

    >>> print(rstheader("My Header", token="*", overline=True))
    *********
    My Header
    *********
    <BLANKLINE>
    <BLANKLINE>

    :param str text: header of string
    :param str token: underliner characters. Default is ``"="``.
    :rtype: str
    """
    line = token * len(text)
    if overline:
        return "%s\n%s\n%s\n\n" % (line, text, line)
    return "%s\n%s\n\n" % (text, line)


def trim_string(string, limit, suffix=""):
    """Limit length of string to ``limit``.

    >>> string = "lorum ipsum lodet"
    >>> trim_string(string, 80)
    'lorum ipsum lodet'
    >>> trim_string(string, 11)
    'lorum ipsum'
    >>> trim_string(string, 11, suffix="...")
    'lorum ip...'

    :param str string: string that needs trimming if too long.
    :param int limit: maximum length of string.
    :param str suffix: suffix like "...".
    :rtype: str
    """
    if len(string) > limit:
        i = limit - len(suffix)
        if i < 0:
            # limit suffix
            return suffix[0:i]
        else:
            return string[0:i] + suffix
    else:
        return string


def required_inputs(cls):
    return {k: v for k, v in cls._inputs.items() if v.is_required}


def sorted_input_slots(cls):
    """Sort all Input slots against MRO and then CREATION_COUNTER:

    >>> from parapy.geom import BSplineCurve
    >>> sorted_input_slots(BSplineCurve) # doctest: +ELLIPSIS
    [<Input BSplineCurve.knots ...>, ...]

    :param parapy.core.meta.basetype cls: ParaPy class
    :rtype: list[parapy.core.input.Input]
    """

    # group inputs by their owning class
    dct = defaultdict(list)
    for slot in cls._inputs.values():
        dct[slot._owner].append(slot)

    lst = []
    for base in cls.__mro__:
        if base in dct:
            inner_list = dct.pop(base)
            inner_list.sort(key=attrgetter("_creation_counter"))
            lst.extend(inner_list)
    assert not dct
    return lst


class Argument(object):
    def __init__(self, name, private, type=Undefined):
        self.name = name
        self._private = private
        self.type = type

    def __repr__(self):
        return "{}['{}']".format(self.__class__.__name__, self.name)

    def is_private(self):
        return self._private or is_attr_private(self.name)


class PositionalArgument(Argument):
    category = "positional"


class KeywordArgument(Argument):
    category = "keyword"

    def __init__(self, name, private, default):
        super(KeywordArgument, self).__init__(name, private)
        self.default = default


def slot_default(slot):
    if slot.is_required:
        return required
    if slot.is_derived:
        return derived
    else:
        return slot.default


def check_constructor_args(args):
    found_keywords = False
    for arg in args:
        if found_keywords and isinstance(arg, PositionalArgument):
            return False, "found positional arguments after keyword arguments"
        elif isinstance(arg, KeywordArgument):
            found_keywords = True
    return True, ""


def constructor_arguments(cls, skip=None, private=True):
    """Return standard Python __init__ signature for ``cls``.

    >>> from parapy.geom import BSplineCurve
    >>> constructor_arguments(BSplineCurve) # doctest: +ELLIPSIS
    [PositionalArgument['control_points'], KeywordArgument['weights'], ...]

    :param parapy.core.meta.basetype cls: ParaPy class
    :rtype: list[Argument]
    """
    slots = sorted_input_slots(cls)
    if skip:
        slots = [slot for slot in slots if slot not in skip]

    lst = []

    # first pop all __initargs__
    initargs = getattr(cls, "__initargs__", None)
    if initargs:
        if '__initargs__' not in cls.__dict__:
            logging.warning("Doublecheck class {} inheritance __initargs__".format(cls))
        for k in cls.__initargs__:
            slot = getattr(cls, k)
            try:
                slots.remove(slot)
            except Exception as e:
                print(cls, slot)
                raise
            if slot.is_required:
                arg = KeywordArgument(k, slot.private, slot_default(slot))
                # arg = PositionalArgument(k, slot.private)
            else:
                arg = KeywordArgument(k, slot.private, slot_default(slot))
            lst.append(arg)

    # then take out all is_required stuff
    for slot in slots[:]:  # copy, because we remove keys from original
        if slot.is_required:
            try:
                slots.remove(slot)
            except Exception as e:
                # print cls, slot
                raise
            arg = KeywordArgument(slot.__name__, slot.private,
                                  slot_default(slot))
            lst.append(arg)

    # remaining slots are all optional keyword arguments
    for slot in slots[:]:
        try:
            slots.remove(slot)
        except Exception as e:
            # print cls, slot
            raise
        arg = KeywordArgument(slot.__name__, slot.private, slot_default(slot))
        lst.append(arg)

    assert not slots, slots

    if not private:
        lst = [arg for arg in lst if not arg.is_private()]

    return lst


def get_constructor_signature_html(cls, keywords_only=False, fmt="text"):
    """Return concrete __init__ signature for cls.

    :param cls: class to generate rst file for.
    :type cls: parapy.core.meta.basetype
    :param bool keywords_only: only keyword-based signature?
    :param str fmt: output format. Valid options: :py:`"text"` or :py:`"html"`.
    :rtype: str
    """
    posargs = cls.__initargs__

    # required positional arguments
    reqposargs = [k for k in posargs if getattr(cls, k).is_required]
    # optional positional arguments
    optposargs = [k for k in posargs if not getattr(cls, k).is_required]
    # required keyword arguments
    reqkeyargs = [k for k in required_inputs(cls).keys() if k not in posargs]

    if fmt == "text":
        if keywords_only:
            args = ", ".join("{:}=<val>".format(k) for k in reqposargs + reqkeyargs)
            if optposargs:
                if args:
                    args += "[, " if args else "["
                args += ", ".join("{:}=<val>".format(k) for k in optposargs)
                args += "]"
        else:
            args = ", ".join(reqposargs)
            if optposargs:
                if args:
                    args += "[, " if args else "["
                args += ", ".join(optposargs)
                args += "]"
            if reqkeyargs:
                if args:
                    args += ", "
                args += ", ".join("{:}=<val>".format(k) for k in reqkeyargs)

        if args:
            return cls.__name__ + "(" + args + ", **kwargs" + ")"
        else:
            return cls.__name__ + "(**kwargs)"

    elif fmt == "html":
        fmt_posreq = '<em class="arg positional req">{:}</em>'
        fmt_posopt = '<em class="arg positional opt">{:}</em>'
        fmt_keyreq = '<em class="arg keyword req">{:}=&lt;val&gt;</em>'
        fmt_keyopt = '<em class="arg keyword opt">{:}=&lt;val&gt;</em>'
        fmt_kwargs = '<em class="arg keyword opt">**kwargs</em>'

        if keywords_only:
            args = [fmt_keyreq.format(k) for k in reqposargs + reqkeyargs]
            args.extend([fmt_keyopt.format(k) for k in optposargs])

        else:
            args = [fmt_posreq.format(k) for k in reqposargs]
            args.extend([fmt_posopt.format(k) for k in optposargs])
            args.extend([fmt_keyopt.format(k) for k in reqkeyargs])

        args.append(fmt_kwargs)

        string = '<code class="descname">{:}</code>'.format(cls.__name__)
        string += '<span class="sig-paren">(</span>'
        string += ", ".join(args)
        string += '<span class="sig-paren">)</span>'
        return string


def datetime_string():
    """Returns the current datetime string in iso-format, e.g.
    :py:`'2013-10-05T00:15:31'`.

    :rtype: str
    """
    return datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')


def append_autodoc_directive_flags(s, flags, number_of_tabs):
    """Options is a sequence of flags.

    :param str s: autodoc directive str (with newline character)
    :param collections.Sequence flags: list of flag elements. Each flag is
        either ``str`` or ``Sequence[str, value]``.
    :param int number_of_tabs: number of tabs in front of each flag line.
    :rtype: str"""
    head = "\t" * number_of_tabs
    for option in flags:
        if isinstance(option, str):
            s += head + "{:}\n".format(option)
        else:
            s += head + "{:} {:}\n".format(*option)
    return s


def get_examples_string(examples):
    """ Get string with html header and references to related examples.

    :param lst examples: list of examples to add
    :param indent: number of tabs used for :examples: option
    :rtype: str: string to write to stream
    """

    header = """.. raw:: html

    <div class="hwrap1">
        <div class="hwrap2">
            <h2>Related Examples<a class="headerlink" href="#related-examples"
            title="Permalink to this headline">¶</a></h2>
        </div>
    </div>
    \n"""

    ref = '* :ref:`{}`'
    refs = [ref.format(example) for example in examples]
    examples_str = '\n'.join(refs)

    return header + examples_str + '\n'


def sort_members_by_mro(cls, member_order='alphabetical'):
    members = OrderedDict()
    visited = {}
    mro = list(cls.__mro__)
    for base in mro:
        localmembers = base.__dict__
        newmembers = {k: v for k, v in localmembers.items() if
                      k not in visited}
        if member_order == 'alphabetical':
            newmembers = OrderedDict(sorted(newmembers.items()))
        else:
            raise NotImplementedError()
        members.update(newmembers)
        visited.update(localmembers)
    return members


def yield_mro_sorted_slots(cls, member_order='bysource', _attr="_slots"):
    """Sorted slots dict first over MRO and then creation order. Yields
    ``(cls, list[(key, AbstractSlot)])``.

    :param type cls: class instance.
    :rtype: (basetype, list[AbstractSlot])
    """
    dict_ = getattr(cls, _attr)
    if member_order == "bysource":
        lst = sorted(iter(dict_.items()), key=lambda it: it[1]._creation_counter)
    elif member_order == "alphabetical":
        lst = sorted(dict_.items())
    else:
        raise ValueError("member_order should be 'bysource' or 'alphabetical'")
    mro = [(cls, cls.__dict__, []) for cls in cls.__mro__ if isinstance(cls, basetype)]
    for key_slot in lst:
        key = key_slot[0]
        flag = False
        for _, classdict, pocket in mro:
            if key in classdict:
                flag = True
                break
        if flag:
            pocket.append(key_slot)
        else:
            msg = "Slot key '{:}' owned by `{:}` not found in MRO."
            raise RuntimeError(msg.format(key, cls))
    for cls, _, pocket in mro:
        if pocket:
            yield cls, pocket


def yield_mro_sorted_methods(cls, member_order="alphabetical"):
    """Sorted slots dict first over MRO and then creation order.  Yields
    ``(cls, list[Method])``.

    :rtype: (basetype, list[(str, Method)])
    """
    if member_order != "alphabetical":
        raise ValueError("member_order should be 'alphabetical'")

    visited = set()
    mro = list(cls.__mro__)
    for base in mro:
        lst = []
        for k, v in sorted(base.__dict__.items()):
            if k not in visited:
                if isinstance(v, (FunctionType, staticmethod, classmethod)):
                    lst.append((k, v))
                visited.add(k)
        yield base, lst


if __name__ == '__main__':
    from parapy.geom import BSplineCurve
    # for cls, lst in yield_mro_sorted_slots(BSplineCurve, "bysource"):
    #     print cls, lst
    # for cls, lst in yield_mro_sorted_slots(BSplineCurve, "alphabetical"):
    #     print cls, lst
    # for cls, lst in yield_mro_sorted_methods(BSplineCurve, "alphabetical"):
    #     print cls, lst

    args = constructor_arguments(BSplineCurve)
    for arg in args:
        print(arg)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import importlib
import logging
import os
import sys
from pkgutil import iter_modules
from types import FunctionType

from parapy.autodoc.globs import (TMPLT_CON, TMPLT_DEF, TMPLT_GRP, TMPLT_INH)
from parapy.autodoc.utils import (
    append_autodoc_directive_flags, datetime_string,
    get_constructor_signature_html, get_relative_path, is_attr_in_ancestors,
    is_attr_private, is_attr_special, rstheader, trim_string,
    get_examples_string, yield_mro_sorted_methods, yield_mro_sorted_slots)
from parapy.core import Attribute, Input, Part
from parapy.core.abstractslot import AbstractSlot
from parapy.core.base import Base
from parapy.core.globs import Undefined, derived
from parapy.core.utilities import get_classes, get_functions


def get_module_by_name(qualname):
    module = importlib.import_module(qualname)
    return module


def get_module_member_by_name(qualname):
    module_name, attr = qualname.rsplit(".", 1)
    module = get_module_by_name(module_name)
    member = getattr(module, attr)
    return member


class Documenter(object):
    @staticmethod
    def write_divider(stream=sys.stdout):
        stream.write("--------------\n\n")

    @staticmethod
    def write_header(title, token="=", overline=False, stream=sys.stdout):
        s = rstheader(title, token=token, overline=overline)
        stream.write(s)

    def write(self, *args, **kwargs):
        raise NotImplementedError()


class BaseMemberDocumenter(Documenter):
    """Class for documenting member objects ``obj`` of an ``cls`` class that
    derives from :class:`~parapy.core.base.Base`.
    """

    #: Sphinx ``.. auto::`` directive
    directive = "autoattribute"

    #: category to which this member belongs.
    category = "Miscellaneous"

    def __init__(self, name, obj, cls, owner, index_inherited=False):
        """
        :param str name: name of the member object in ``cls`` namespace.
        :param obj: the member object itself.
        :param type cls: sub-class owning member named by ``name``.
        :param type owner: (ancestor) class owning member explicitly.
        :param bool index_inherited: should a Sphinx index entry be created
            for inherited members? Default is :py:`False`.
        """
        #: part of ``.. autoattribute / automethod:: <name>``
        #: in case of inheritance, the name should should be fully
        #: qualified, including the package, module and class names.
        #: :type: str
        self.name = name

        #: .. autoattribute / automethod:: <name>
        #: in case of inheritance, the name should should be fully qualified,
        #: including the package, module and class names.
        #: :type: str
        self.qualname = name

        #: class member instance
        self.obj = obj

        #: class owning member.
        #: :type: type
        self.cls = cls

        #: should we index inherited attributes and treat as owned?
        self.index_inherited = index_inherited

        #: (ancestor) class owning this member
        self.owner = owner

        #: is this member private?
        self.private = is_attr_private(name)

        #: is this member special?:
        self.special = is_attr_special(name)

        #: is this member inherited?
        self.inherited = False

        #: does this member override an ancestor member?
        self.overridden = False

        if self.cls is not self.owner:
            self.inherited = True
            self.qualname = "{:}.{:}.{:}".format(
                owner.__module__, owner.__name__, name)
        elif is_attr_in_ancestors(cls, name):
            self.overridden = True

    @property
    def html_classes(self):
        """Extra html classes to add to the SPhinx HTML output.

        :rtype: list
        """
        lst = []
        if self.overridden:
            lst.append("overridden")
        if self.inherited and not self.overridden:
            lst.append("inherited")
        if self.private:
            lst.append("private")
        if self.special:
            lst.append("special")
        return lst

    @property
    def options(self):
        lst = []
        if self.inherited and not self.index_inherited:
            lst.append(":noindex:")
        return lst

    def write(self, stream=sys.stdout):
        """Write ..auto.. directive to stream."""

        html_classes = self.html_classes
        if html_classes:
            fmt = "\t.. rst-class:: {:}\n\n"
            s_html_class = " ".join(html_classes)
            s = fmt.format(s_html_class)
            stream.write(s)

        s = "\t.. {:}:: {:}\n".format(self.directive, self.qualname)
        s = append_autodoc_directive_flags(s, self.options, indent=2)
        stream.write(s)

        stream.write("\n")


class SlotDocumenter(BaseMemberDocumenter):
    """Documenter of Slot instances ``obj`` inside an ``cls`` class that
    derives from :class:`~parapy.core.base.Base`.
    """

    directive = "autoattribute"

    def __init__(self, name, obj, cls, owner, default_value_limit=None,
                 **kwargs):
        """
        :param str name: name of the member object in ``cls`` namespace.
        :param obj: the member object itself.
        :type obj: AbstractSlot
        :param type cls: class owning member named by ``name``.
        :param default_value_limit: limit for length of default value repr.
        :type default_value_limit: int | None
        :param kwargs: see :class:`BaseMemberDocumenter`.
        """

        # FIXME: overcomes bug in Sphinx that prints class name 'Face_' as '_'
        if owner.__name__ == cls.__name__ + "_":
            owner = cls

        super(SlotDocumenter, self).__init__(name, obj, cls, owner, **kwargs)

        #: is this member private?
        self.private = obj.private

        self.default_value = Undefined
        self.default_value_limit = default_value_limit
        self.specific_html_classes = ["slot"]

        if isinstance(obj, Input):
            self.specific_html_classes.append("input")
            if obj.is_required:
                self.category = "Required Inputs"
                self.specific_html_classes.append("required")
            else:
                self.category = "Optional Inputs"
                if isinstance(obj._default, (FunctionType, property)):
                    self.default_value = derived
                else:
                    self.default_value = obj._default

        elif isinstance(obj, Attribute):
            self.category = "Attributes"

        elif isinstance(obj, Part):
            self.category = "Parts"
            self.specific_html_classes.append("part")

        else:
            msg = "AbstractSlot '{:}' is not one of Input, Attribute or " \
                  "Part, but: {:}".format(name, obj)
            raise NotImplementedError(msg)

    @property
    def html_classes(self):
        regular_html_classes = super(SlotDocumenter, self).html_classes
        specific_html_classes = self.specific_html_classes
        return regular_html_classes + specific_html_classes

    def write(self, stream=sys.stdout):

        if self.default_value is not Undefined:
            fmt = TMPLT_DEF
            s_val = repr(self.default_value)
            limit = self.default_value_limit
            if limit is not None:
                s_val = trim_string(s_val, limit=limit)
            s = fmt.format(s_val)
            stream.write(s)

        super(SlotDocumenter, self).write(stream)


class MethodDocumenter(BaseMemberDocumenter):
    """Documenter of Method instances ``obj`` inside an ``cls`` class that
    derives from :class:`~parapy.core.base.Base`.
    """

    #: Sphinx ``.. auto::`` directive
    directive = "automethod"

    #: category to which this member belongs (static for now).
    category = "Methods"


class ClassDocumenter(Documenter):
    """
    :param type cls: class to generate rst file for.
    :param bool inherited_members: include inherited class members?
    :param bool private_members: include private class members?
    :param bool special_members: include members named like __special__?
    :param bool undoc_members: if False, members without docstrings will be
        left out.
    :param bool index_inherited_members: treat inherited slots as your own
        and index them?
    :param bool inheritance_diagram: add class inheritance diagram?
    :param bool show_inheritance: show bases?
    :param str member_order: order of members is either 'alphabetical' or
        'bysource'. For now, only 'alphabetical' is supported.
    :param bool current_module: write ``.. current_module::`` directive?

    >>> class Foo(object):
    ...     #: some a
    ...     #:
    ...     #: :type: int
    ...     bar = 1
    ... 
    ...     def qux(self):
    ...         '''some docstring.
    ... 
    ...         :rtype: str
    ...         '''
    ...         return "hello world"
    >>> doc = ClassDocumenter(Foo)
    >>> doc.write()

    The output looks like:

    .. code-block:: rest

        Class :py:class:`~__main__.Foo`
        ----------------------------------------

        .. autoclass:: Foo
            :members:
            :member-order: alphabetical
    """

    def __init__(self, cls,
                 inherited_members=False, private_members=False,
                 special_members=False, undoc_members=False,
                 index_inherited_members=False, inheritance_diagram=False,
                 show_inheritance=False, member_order='bysource',
                 current_module=False, preamble=False,
                 examples=None):

        if isinstance(cls, str):
            cls = get_module_member_by_name(cls)

        self.cls = cls
        self.inherited_members = inherited_members
        self.private_members = private_members
        self.special_members = special_members
        self.undoc_members = undoc_members
        self.index_inherited_members = index_inherited_members
        self.inheritance_diagram = inheritance_diagram
        self.show_inheritance = show_inheritance
        self.member_order = member_order
        self.current_module = current_module
        self.preamble = preamble
        self.examples = examples or []

        #: full name (including packages) of module
        #: :type: str
        self.module_qualname = cls.__module__

        #: full name (including packages) of cls
        #: :type: str
        self.cls_qualname = "{:}.{:}".format(cls.__module__, cls.__name__)

        #: short sentence describing this class.
        #: :type: str
        self.synopsis = ""
        if hasattr(cls, "__dict__"):
            synopsis = cls.__dict__.get("__synopsis__", "")
            if synopsis:
                self.synopsis = synopsis.rstrip()

    @property
    def options(self):
        lst = [":members:", [":member-order:", self.member_order]]
        if self.show_inheritance:
            lst.append(":show-inheritance:")
        if self.private_members:
            lst.append(":private-members:")
        if self.special_members:
            lst.append(":special-members:")
        if self.inherited_members:
            lst.append(":inherited-members:")
        if self.undoc_members:
            lst.append(":undoc-members:")
        return lst

    @staticmethod
    def write_preamble(stream=sys.stdout):
        fmt = (".. generated by ParaPy autodoc at {:}\n"
               ".. include:: /substitutions.txt"
               "\n"
               "\n")
        s = fmt.format(datetime_string())
        stream.write(s)

    def write(self, stream=sys.stdout):
        """Write content to ``stream``.

        :param types.BufferType stream: stream to write to."""

        if self.preamble:
            self.write_preamble(stream)

        if self.current_module:
            fmt = ".. py:module:: {0}\n.. py:currentmodule:: {0}\n\n"
            s = fmt.format(self.module_qualname)
            stream.write(s)

        fmt = "Class :py:class:`~{:}`"
        s = fmt.format(self.cls_qualname)
        if self.synopsis:
            tail = self.synopsis.rstrip(".")
            s += " --- {:}".format(tail)
        self.write_header(s, token="-", stream=stream)

        if self.examples:
            s = get_examples_string(self.examples)
            stream.write(s)
            stream.write("\n")

        if self.inheritance_diagram:
            fmt = TMPLT_INH
            s = fmt.format(self.cls_qualname)
            stream.write(s)

        fmt = ".. autoclass:: {:}\n"
        s = fmt.format(self.cls.__name__)
        s = append_autodoc_directive_flags(s, self.options, number_of_tabs=1)
        stream.write(s)

        stream.write("\n")

    def write_base(self, stream=sys.stdout):
        pass


class BaseDocumenter(ClassDocumenter):
    """
    :param parapy.core.base.basetype cls: class to generate rst file for.
    :param str member_order: only :py:`'groupwise'` is supported.
    :param bool undoc_members: only :py:`True` is supported.
    :param bool constructor: add constructor section?
    :param default_value_limit: limit for length of default value repr.
    :type default_value_limit: int | None

    >>> from parapy.core import Base
    >>> doc = BaseDocumenter(Base)
    >>> doc.write()

    The output looks like:

    .. code-block:: rest

        Class :py:class:`~parapy.core.base.Base`
        ----------------------------------------

        .. autoclass:: Base

            .. raw:: html

                <h2 class='category'>Optional Inputs</h2>

            .. raw:: html

                <meta class="default" value="None">

            .. rst-class:: slot input

            .. autoattribute:: color

            .. more
    """

    MEMBER_CATEGORIES = ("Required Inputs", "Optional Inputs", "Attributes",
                         "Parts", "Methods", "Miscellaneous")

    def __init__(self, cls, inherited_members=False, private_members=True,
                 special_members=False, undoc_members=True,
                 index_inherited_members=False, inheritance_diagram=False,
                 show_inheritance=False, member_order='groupwise',
                 current_module=False, constructor=False,
                 default_value_limit=None, preamble=True):
        super(BaseDocumenter, self).__init__(cls, inherited_members,
                                             private_members, special_members,
                                             undoc_members,
                                             index_inherited_members,
                                             inheritance_diagram,
                                             show_inheritance, member_order,
                                             current_module,
                                             preamble=preamble)

        if member_order != 'groupwise':
            raise NotImplementedError("Only 'groupwise' is implemented")

        if not undoc_members:
            raise NotImplementedError("Not supported for BaseDocumenter yet.")

        self.constructor = constructor
        self.default_value_limit = default_value_limit

    @property
    def options(self):
        lst = []
        if self.show_inheritance:
            lst.append(":show-inheritance:")
        return lst

    def get_members_by_group(self):
        cls = self.cls
        idx = self.index_inherited_members
        lim = self.default_value_limit
        inh = self.inherited_members
        prv = self.private_members
        spc = self.special_members

        #: :type: dict[str, list[BaseMemberDocumenter]]
        members_by_group = {}

        def keep(member):
            if member.category == "Required Inputs":
                return True
            elif (member.category == "Methods"
                  and member.name.startswith("_get_")):
                return False
            else:
                return ((inh or not member.inherited) and
                        (prv or not member.private) and
                        (spc or not member.special))

        for owner, lst in yield_mro_sorted_slots(cls, member_order='bysource'):
            if not issubclass(owner, Base):
                continue
            for key, slot in lst:
                member = SlotDocumenter(key, slot, cls, owner,
                                        index_inherited=idx,
                                        default_value_limit=lim)
                if keep(member):
                    members_by_group.setdefault(member.category, []).append(
                        member)

        for owner, lst in yield_mro_sorted_methods(cls,
                                                   member_order='alphabetical'):
            if not issubclass(owner, Base):
                continue
            for key, method in lst:
                member = MethodDocumenter(key, method, cls, owner,
                                          index_inherited=idx)
                if keep(member):
                    members_by_group.setdefault(member.category, []).append(
                        member)

        return members_by_group

    def write(self, stream=sys.stdout):
        members_by_group = self.get_members_by_group()

        super(BaseDocumenter, self).write(stream)

        if self.constructor:
            cls = self.cls
            sig1 = get_constructor_signature_html(
                cls, keywords_only=False, fmt="html")
            sig2 = get_constructor_signature_html(
                cls, keywords_only=True, fmt="html")
            string = TMPLT_CON.format("Constructor", sig1, sig2)
            stream.write(string)

        for category in self.MEMBER_CATEGORIES:
            members = members_by_group.get(category, None)
            if members:

                # <h2>Name</h2>
                s = TMPLT_GRP.format(category)
                stream.write(s)

                for member in members:
                    member.write(stream)


class FunctionDocumenter(Documenter):
    def __init__(self, fn):
        if isinstance(fn, str):
            fn = get_module_member_by_name(fn)
        self.fn = fn
        self.qualname = "{:}.{:}".format(fn.__module__, fn.__name__)

    def write(self, stream=sys.stdout):
        string = ".. autofunction:: {:}\n".format(self.qualname)
        stream.write(string)


class ModuleDocumenterBase(Documenter):
    IS_PKG = False

    def __init__(self, module, private_module_members=False,
                 module_member_order='alphabetical', basepath=None, **kwargs):
        """
        :param module: module name (str) or module instance
        :type module: str | Module
        """
        if isinstance(module, str):
            module = get_module_by_name(module)
        self.module = module
        self.module_qualname = module.__name__
        self.module_path = path = module.__file__
        self.private_module_members = private_module_members
        self.module_member_order = module_member_order
        self.basepath = basepath

        if path.endswith("pyc"):
            self.module_path = path[:-1]

        if basepath is not None:
            self.module_path = get_relative_path(basepath, self.module_path)

        self.class_documenter_kwargs = kwargs

        #: short sentence describing this class.
        #: :type: str
        self.synopsis = ""
        if getattr(module, "__synopsis__", False):
            self.synopsis = module.__synopsis__.rstrip()

        self.module_docstring = module.__doc__

    @property
    def has_content(self):
        return bool(self.module_docstring)

    @staticmethod
    def write_preamble(stream=sys.stdout):
        fmt = (".. generated by ParaPy autodoc at {:}\n"
               ".. include:: /substitutions.txt"
               "\n"
               "\n")
        s = fmt.format(datetime_string())
        stream.write(s)

    # author, source, etc.
    def write_metadata(self, stream=sys.stdout):
        module = self.module
        module_qualname = self.module_qualname
        module_path = self.module_path

        if self.IS_PKG:
            typename = "Package"
        else:
            typename = "Module"

        string = "{:} :mod:`~{:}`".format(typename, module_qualname)
        if self.synopsis:
            tail = self.synopsis.rstrip(".")
            string += " --- {:}".format(tail)
        self.write_header(string, token="*", overline=True, stream=stream)

        string = ".. module:: {:}\n"
        string = string.format(module_qualname)

        if self.synopsis:
            tail = self.synopsis
            if not self.synopsis[-1] == ".":
                tail += "."
            string += "\t:synopsis: {:}\n".format(tail)

        stream.write(string)
        # string = ".. py:currentmodule:: {:}\n\n".format(module.__name__)
        # stream.write(string)

        if hasattr(module, "__author__"):
            string = ".. moduleauthor:: {:}\n".format(module.__author__)
            stream.write(string)
            string = ".. sectionauthor:: {:}\n".format(module.__author__)
            stream.write(string)

        stream.write("\n")

        string = "**Qualified module:** :py:mod:`{:}`\n\n".format(
            module_qualname)
        stream.write(string)
        string = "**Source code:** ``{:}``\n\n".format(module_path)
        stream.write(string)

    def write_automodule(self, stream=sys.stdout):
        module_qualname = self.module_qualname
        if self.module_docstring:
            string = ".. automodule:: {:}\n\t:noindex:\n\n"
            string = string.format(module_qualname)
            stream.write(string)

    def write(self, stream=sys.stdout):
        self.write_preamble(stream)
        self.write_metadata(stream)
        self.write_divider(stream)
        self.write_automodule(stream)


class ModuleDocumenter(ModuleDocumenterBase):
    """Writes .rst output for entire module.

    >>> # import a module object (not a class or function!)
    >>> from parapy.core import base
    >>> ModuleDocumenter(base).write()
    """

    def __init__(self, module, private_module_members=False,
                 module_member_order='alphabetical', basepath=None, **kwargs):
        super(ModuleDocumenter, self).__init__(
            module, private_module_members, module_member_order,
            basepath, **kwargs)
        self.classes = get_classes(self.module,
                                   private_members=private_module_members,
                                   member_order=module_member_order)
        self.functions = get_functions(self.module,
                                       private_members=private_module_members,
                                       member_order=module_member_order)

    def has_content(self):
        return bool(super(ModuleDocumenter, self).has_content or
                    self.classes or self.functions)

    def write(self, stream=sys.stdout):

        super(ModuleDocumenter, self).write(stream)

        classes = self.classes
        docclass_kwargs = self.class_documenter_kwargs
        if classes:
            self.write_header("Classes", token="=", stream=stream)
            for cls in classes:
                if issubclass(cls, Base):
                    docclass = BaseDocumenter
                else:
                    docclass = ClassDocumenter
                doc = docclass(cls, preamble=False, **docclass_kwargs)
                doc.write(stream)

        functions = self.functions
        if functions:
            self.write_header("Functions", token="=", stream=stream)
            for fn in functions:
                doc = FunctionDocumenter(fn)
                doc.write(stream)


class PackageDocumenter(ModuleDocumenterBase):
    """
    :param bool recurse: Recurse over sub-packages, etc.
    :param str failure: what to do on failure of module import. Options:
        ['raise', 'warn', 'ignore']
    :param int tocdepth: maximum depth for the generated table of contents
        file.
    """

    IS_PKG = True
    LOGGER = None
    LOGHEADER = "##################\nParaPy autodoc log\n##################"
    LOGCOUNTER = 0
    LOGFILE = None

    def __init__(self, module, private_module_members=False,
                 module_member_order='alphabetical', basepath=None,
                 recurse=True,
                 tocdepth=1,
                 full=True,
                 project=None,
                 author=None,
                 version=None,
                 release=None,
                 **kwargs):

        super(PackageDocumenter, self).__init__(module, private_module_members,
                                                module_member_order, basepath,
                                                **kwargs)
        self.recurse = recurse
        self.tocdepth = tocdepth
        self.full = full
        self.project = project
        self.author = author
        self.version = version
        self.release = release

    @staticmethod
    def init_file_logger(outputdir):
        if PackageDocumenter.LOGGER is None:
            logname = 'parapy_autopackage'
            logfile = "autodoc.log"
            logpath = os.path.join(outputdir, logfile)
            logger = logging.getLogger(logname)
            logger.setLevel(logging.DEBUG)
            fh = logging.FileHandler(logpath, mode='w')
            fh.setLevel(logging.DEBUG)
            logger.addHandler(fh)
            logger.propagate = False
            logger.info(PackageDocumenter.LOGHEADER)
            PackageDocumenter.LOGPATH = logpath
            PackageDocumenter.LOGGER = logger

    def log_error_message(self, module_qualname):
        logger = self.LOGGER
        if logger is None:
            raise RuntimeError("first call ``init_file_logger()``")
        msg = "\nERROR while loading module '{:}'."
        msg = msg.format(module_qualname)
        logger.error(msg, exc_info=True)
        PackageDocumenter.LOGCOUNTER += 1

    def load_module(self, qualname):
        try:
            mod = importlib.import_module(qualname)
            return mod
        except ImportError:
            self.log_error_message(qualname)
            return None

    def make_subpackage(self, module):
        return PackageDocumenter(module, recurse=self.recurse,
                                 basepath=self.basepath)

    def make_submodule(self, module):
        return ModuleDocumenter(module, basepath=self.basepath)

    def write_submodules(self, outputdir):
        pkg = self.module
        recurse = self.recurse
        modwalker = iter_modules(pkg.__path__, pkg.__name__ + ".")
        members = []
        for _, mod_qualname, ispkg in modwalker:
            module = self.load_module(mod_qualname)
            if module is not None:
                if ispkg and recurse:
                    doc = self.make_subpackage(module)
                    has_members = doc.write_package(outputdir)
                    if has_members:
                        members.append((mod_qualname, ispkg))
                else:
                    doc = self.make_submodule(module)
                    if doc.has_content:
                        filename = mod_qualname + ".rst"
                        fullpath = os.path.join(outputdir, filename)
                        with open(fullpath, 'w') as f:
                            doc.write(f)
                        members.append((mod_qualname, ispkg))
        return members

    def write_toc(self, members, stream=sys.stdout):
        self.write_header("Package modules", stream=stream)
        s = ".. toctree::\n\t:maxdepth: {:}\n\n".format(self.tocdepth)
        stream.write(s)
        for mod_qualname, ispkg in members:
            filename = mod_qualname + ".rst"
            string = "\t{:}\n".format(filename)
            stream.write(string)

    def write_package(self, outputdir):
        pkg = self.module
        members = self.write_submodules(outputdir)
        if members:
            filename = pkg.__name__ + ".rst"
            fullpath = os.path.join(outputdir, filename)
            with open(fullpath, 'w') as f:
                super(PackageDocumenter, self).write(stream=f)
                self.write_toc(members, stream=f)
        return bool(members)

    def write(self, outputdir):
        self.init_file_logger(outputdir)
        self.write_package(outputdir)
        cnt = PackageDocumenter.LOGCOUNTER
        if cnt:
            logpath = PackageDocumenter.LOGPATH
            msg = "{:} error{:} while generating API. See '{:}'."
            print(msg.format(cnt, 's' if cnt > 1 else '', logpath))


#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Function to extra results from various Nastran output formats."""

import os
import re
import warnings

from parapy.core import by_groups

__all__ = ["read_pch"]

RE_HEADER = re.compile(r'^\$TITLE\s*=\s*(.+)\s[0-9]+\n'
                       r'\$SUBTITLE\s*=\s*(.+)\s[0-9]+\n'
                       r'\$LABEL\s*=\s*(.+)\s[0-9]+\n'
                       r'\$(.+)\s[0-9]+\n'
                       r'\$REAL OUTPUT\s+[0-9]+\n'
                       r'\$SUBCASE\sID\s*=\s*(.+)\s[0-9]+')

RE_ELEMENT_TYPE = re.compile(r'\$ELEMENT TYPE\s*=\s*(\d+)\s+')


def read_pch(filename):
    """Read data from .pch file. Returned format::

        # subcase: {str: value}
        {1: {"title": "MSC.NASTRAN JOB CREATED ON 29-APR-16 AT 09:11:02",
             "subtitle": "MYLOADCASE",
             "label": "MYANALYSISLABEL",
             "DISPLACEMENTS":
                 # node: [t1, t2, t3, r1, r2, r3]
                 {1: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                  # -more nodes-
                  },
             "SPCF":
                 # node: [f1, f2, f3, m1, m2, m3]
                 {1: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                  # -more nodes-
                  },
             "ELEMENT STRESSES":
                 {"nodes":
                      # node: [sxx, sxy, ..., szz]
                      {1: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                       # -more nodes-
                       },
                  "faces":
                      # face: {node: [sxx, sxy, ..., szz], ...}
                      {1:
                           # node: [sxx, sxy, ..., szz]
                           {1: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                                0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                            # -more nodes-
                            },
                       # -more faces-
                       },
                  }
             },
         # -more subcases-
         }

    For example, to retrieve the element stress sxx of subcase id 1, on node 1:

    >>> result[1]["ELEMENT STRESSES"]["nodes"][1][0]

    :param str filename: full path to .pch file.
    :rtype: dict
    """
    filename = os.path.abspath(filename)
    if not os.path.exists(filename):
        msg = "Punch file not found at '{}'"
        raise RuntimeError(msg.format(filename))

    result = {}

    with open(filename) as f:
        line = next(f)
        while True:
            title, subtitle, label, category, subcase_id = read_header(line, f)
            if subcase_id not in result:
                result[subcase_id] = {"title": title,
                                      "subtitle": subtitle,
                                      "label": label}

            if category == "DISPLACEMENTS":
                results, line = read_displacements(f)
            elif category == "SPCF":
                results, line = read_spcf(f)
            elif category == "ELEMENT STRESSES":
                results, line = read_stresses(f)
            else:
                msg = "category '{}' not supported yet"
                warnings.warn(msg.format(category))
                results = {}
                line = read_unknown_data(f)

            if category in result[subcase_id]:
                msg = ("Found second section of category '{:}' of "
                       "subcase_id {:}. Not anticipated (yet).")
                raise RuntimeError(msg.format(category, subcase_id))
            else:
                result[subcase_id][category] = results

            if line is None:
                break

    return result


def read_header(line, f):
    """Read $-prefixed section.

    :param str line: first line
    :param f: stream to file
    :rtype: (str, str, str, str, int)
    :returns: title, subtitle, label, category, subcase_id
    """
    s = line + "".join(next(f) for _ in range(5))
    m = RE_HEADER.search(s)
    if not m:
        raise RuntimeError("parser error", s)
    title, subtitle, label, category, subcase_id = [s.strip() for s in m.groups()]
    subcase_id = int(subcase_id)
    return title, subtitle, label, category, subcase_id


def read_displacements(f):
    results = {}
    node = None
    for line in f:
        if line.startswith("$"):
            return results, line
        else:
            tokens = line.split()
            first_token = tokens[0]
            if first_token == "-CONT-":
                results[node].extend(list(map(float, tokens[1:4])))
            else:
                node = int(first_token)
                results[node] = list(map(float, tokens[2:5]))

    return results, None


def read_spcf(f):
    results = {}
    node = None
    for line in f:
        if line.startswith("$"):
            return results, line
        else:
            tokens = line.split()
            first_token = tokens[0]
            if first_token == "-CONT-":
                results[node].extend(list(map(float, tokens[1:4])))
            else:
                node = int(first_token)
                results[node] = list(map(float, tokens[2:5]))

    return results, None


def read_stresses(f):
    s = next(f)
    m = RE_ELEMENT_TYPE.search(s)
    if not m:
        raise RuntimeError("parser error", s)
    element_type = int(m.group(1))  # TODO: use this somehow

    result = {}
    faces = result["faces"] = {}
    nodes = result["nodes"] = {}
    face = -1
    lst = []

    def flush():
        if lst:
            faceres = faces[face] = []
            for dat in by_groups(lst, 17):
                node, stresses = int(dat[0]), list(map(float, dat[1:]))
                if node not in nodes:
                    nodes[node] = stresses
                faceres.append((node, stresses))
            lst[:] = []

    for line in f:
        if line.startswith("$"):
            flush()
            return result, line
        else:
            tokens = line.split()
            first_token = tokens[0]
            if first_token == "-CONT-":
                lst.extend(tokens[1:-1])
            else:
                flush()
                face = int(first_token)
                lst.extend(tokens[2:-1])

    return result, None


def read_unknown_data(f):
    for line in f:
        if line.startswith("$"):
            return line
    return None

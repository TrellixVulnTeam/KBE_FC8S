#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Function to extra results from .bdf output format. Currently supported
cards (see :attr`~parapy.cae.nastran.bdf.CARDS`)::

    ["CQUAD4", "CTRIA3", "GRID", "CORD2C"]

Usage:

>>> read_bdf("path/to/file.bdf")
{"coords": {0: ()}, "faces": {1, ()}, "nodes": {1: ()}
>>> obj = BDFReader("path/to/file.bdf")
>>> obj.data
{"coords": {0: ()}, "faces": {1, ()}, "nodes": {1: ()}
>>> obj = BDFWriter(properties=[], filename="path/to/file.bdf")
>>> obj.write()
"""

import os

from parapy.cae.nastran.primitives import CBarGroup, Frame
from parapy.cae.nastran.templates import TMPLT8
from parapy.cae.nastran.utilities import datetime_string, pos2ABC
from parapy.core import Attribute, FileReader, FileWriter, Input, Part, child
from parapy.geom import Compound, Orientation, Point, Polygon, Position, Vector

__all__ = ["read_bdf", "BDFReader", "BDFWriter"]


#: currently supported NASTRAN cards
CARDS = ["CQUAD4", "CTRIA3", "GRID", "CORD2R"]


# TODO: add support for free field formatting (use of , as separator)
def read_bdf(filename):
    """Read data from .bdf file. Returned format::

        # TODO

    :arg str filename: full path to .bdf file.
    :rtype: dict

    .. note:: free field formatting not supported
    """
    filename = os.path.abspath(filename)
    if not os.path.exists(filename):
        msg = "BDF file not found at '{}'"
        raise RuntimeError(msg.format(filename))

    result = {}
    cords = result["coords"] = {0: (0, 0, 0, 0, 0, 1.0, 1.0, 0, 0)}
    faces = result["faces"] = {}
    nodes = result["nodes"] = {}

    with open(filename) as f:
        line = f.readline()
        while True:
            prefix, parts, line = read_card(line, f)
            if prefix is None:
                pass
            elif prefix == "CQUAD4":
                EID, node_ids = int(parts[1]), list(map(int, parts[3:7]))
                faces[EID] = node_ids
            elif prefix == "CTRIA3":
                EID, node_ids = int(parts[1]), list(map(int, parts[3:6]))
                faces[EID] = node_ids
            elif prefix == "GRID":
                ID, CP, coordinates = int(parts[1]), parts[2].strip(), list(map(float, parts[3:6]))
                CP = int(CP) if CP else 0
                nodes[ID] = CP, coordinates
            elif prefix == "CORD2R":
                CID, coordinates = int(parts[1]), list(map(float, parts[3:9]))
                coordinates.extend(list(map(float, parts[11:14])))
                cords[CID] = coordinates

            if not line:  # eof
                break

    return result


def startswith_multiple(s, prefixes):
    for prefix in prefixes:
        if s.startswith(prefix):
            return True, prefix
    return False, None


def read_card(line, f):
    """Returns prefix, parts or None, None.

    :param f: stream to bdf file.

    .. note:: free field formatting not supported
    """
    match, prefix = match_line(line)
    if match:
        line = assure80(line.rstrip("\n"))
        if line[len(prefix)] == "*":
            # large field format
            nextline = f.readline()
            lines = [line + assure80(nextline.rstrip("\n"))]
            nextline = f.readline()
            while nextline.startswith(" "):
                line = assure80(nextline.rstrip("\n"))
                nextline = f.readline()
                lines.append(line + assure80(nextline.rstrip("\n")))
                nextline = f.readline()
            parts = []
            for line in lines:
                gen = (line[i:i + w] for i, w in (
                (0, 8), (8, 16), (24, 16), (40, 16), (56, 16),
                (88, 16), (104, 16), (120, 16), (136, 16), (152, 8)))
                parts.extend(gen)
        else:
            # small field format
            lines = [assure80(line)]
            nextline = f.readline()
            while nextline.startswith(" "):
                lines.append(assure80(nextline.rstrip("\n")))
                nextline = f.readline()
            parts = []
            for line in lines:
                gen = (line[i:i + 8] for i in
                       (0, 8, 16, 24, 32, 40, 48, 56, 64, 72))
                parts.extend(gen)

        return prefix, parts, nextline
    else:
        return None, None, f.readline()


def assure80(s, fillchar=" "):
    """Adds whitespace to string ``s`` to assure 80-character width.

    >>> s = 'GRID     60241          12.774  -1.808  -6.771'
    >>> assure80(s)
    'GRID     60241          12.774  -1.808  -6.771                                  '

    :type s: str
    :type fillchar: str
    :rtype str
    """
    l = len(s)
    if l < 80:
        return s + fillchar*(80-l)
    else:
        return s


_COOKIE = CARDS[0]
_TOKENS = CARDS[1:]


def match_line(line):
    # use COOKIE to speed up startswith test
    global _COOKIE, _TOKENS
    if line.startswith(_COOKIE):
        return True, _COOKIE
    else:
        match, prefix = startswith_multiple(line, _TOKENS)
        if match:
            # toggle COOKIE
            _TOKENS.remove(prefix)
            _TOKENS.append(_COOKIE)
            _COOKIE = prefix
            return True, prefix
        else:
            return False, None


class BDFReader(FileReader):

    file_or_dir = "file"
    wildcard = "bdf file (*.bdf,*.BDF)|*.bdf;*.BDF"

    v_dim = Input(1)

    @Attribute
    def data(self):
        """Shape read from .brep file, returned as a (derived) instance of
        :class:`~parapy.geom.occ.brep.Brep`.

        :rtype: parapy.geom.BRep
        """
        filename = self.resolve_pathname(None)
        data = read_bdf(filename)
        print("Read:", filename)
        return data

    def read(self, pathname=None):
        old_filename = self.filename

        new_filename = self.resolve_pathname(pathname)
        if new_filename == old_filename:
            print(f"Skipped re-reading file: {old_filename}")
        else:
            self.filename = new_filename
        try:
            return self.data
        except Exception:
            # when it fails, restore the old filename
            self.filename = old_filename
            raise

    @Attribute
    def position_dict(self):
        dct = {}
        for CID, data in self.data["coords"].items():
            x1, y1, z1, x2, y2, z2, x3, y3, z3 = data
            pt1 = Point(x1, y1, z1)
            pt2 = Point(x2, y2, z2)
            pt3 = Point(x3, y3, z3)
            vz = Point.vector_to(pt1, pt2).normalize
            vx = Point.vector_to(pt1, pt3).normalize
            # vx is not necessarily perpendicular to vz
            vy = Vector.cross(vz, vx)
            orient = Orientation(y=vy, z=vz)
            pos = Position(pt1, orient)
            dct[CID] = pos
        return dct

    @Attribute
    def positions(self):
        return list(self.position_dict.values())

    @Attribute
    def point_dict(self):
        dct = {}
        position_dict = self.position_dict
        for ID, (CP, xyz) in self.data["nodes"].items():
            if CP:
                pos = position_dict[CP]
                point = Position.get_point(pos, *xyz)
            else:
                point = Point(*xyz)
            dct[ID] = point
        return dct

    @Attribute
    def polygon_dict(self):
        face_dict = {}
        point_dict = self.point_dict
        for EID, nodes in self.data["faces"].items():
            points = tuple(point_dict[ID] for ID in nodes)
            face_dict[EID] = Polygon(points=points)
        return face_dict

    @Part
    def frames(self):
        return Frame(quantify=len(self.positions),
                     position=self.positions[child.index],
                     pass_down="v_dim")

    @Part
    def faces(self):
        return Compound(list(self.polygon_dict.values()))


class BDFWriter(FileWriter):
    """Writes .bdf file from:

    - :attr:`properties`: 2d (shell) properties with mesh faces, material
        and thickness.
    - :attr:`rbars`: rigid bar elements
    - :attr:`cbars`: rigid bar elements
    - etc.

    Usage:

    >>> obj = BDFWriter(properties=[], filename="path/to/file.bdf")
    >>> obj.write()
    """


    #: override of FileWriter.file_or_dir
    file_or_dir = "file"

    #: override of FileWriter.wildcard
    wildcard = "BDF files (*.bdf,*.BDF) |*.bdf;*.BDF"

    mesh = Input()
    #: sequence of Property instances
    #: :type: list[parapy.cae.nastran.primitives.Property2D]
    properties = Input([])
    #: extra user nodes. List of MeshNode (!) objects.
    #: These MeshNodes should not have a mesh_id yet,
    #: they will be assigned one by this writer.
    #: :type: list[parapy.mesh.core.MeshNode]
    nodes = Input([])
    #: iterable of RBar instances
    #: :type: list[parapy.cae.nastran.primitives.RBar]
    rbars = Input([])
    #: iterable of CBar instances.
    #: :type: list[parapy.cae.nastran.primitives.CBar]
    cbars = Input([])
    #: iterable of LoadCase instances
    #: :type: list[parapy.cae.nastran.primitives.LoadCase]
    load_cases = Input([])
    #: integer > 0 (NASTRAN reals must contain a decimal point)
    #: :type: int
    decimals = Input(2)

    materials = Input([])

    def write(self, pathname=None):
        path = pathname or self.filename
        if not os.path.dirname(path) and self.default_directory:
            path = os.path.join(self.default_directory, path)
        filename = os.path.abspath(path)

        properties = self.properties
        load_cases = self.load_cases
        materials = self.materials
        nodes = self.mesh.grid.nodes
        udf_nodes = self.nodes
        faces = self.mesh.grid.faces
        rbars = self.rbars
        cbars = self.cbars

        tmplt = TMPLT8(self.decimals)

        OXY = (0, 0, 0, 0, 0, 1, 1, 0, 0)
        coords = [OXY]  # list with tuple objects with 9 numeric values (A1-C3)
        nodes_with_coords = {}

        def position2CID(position):
            abc = pos2ABC(position)
            try:
                return coords.index(abc)
            except ValueError:
                coords.append(abc)
                return len(coords)-1

        def add_node_with_coord(mesh_node, CID):
            if mesh_node in nodes_with_coords:
                assert nodes_with_coords[mesh_node] == CID, \
                    "multiple coordinate systems assigned to node {}".format(mesh_node.mesh_id)
            else:
                nodes_with_coords[mesh_node] = CID

        with open(filename, 'w') as f:

            f.write(tmplt.HEADER.format(datetime=datetime_string()))

            # SUBCASE specs
            for i, load_case in enumerate(load_cases):

                displacements = load_case.displacements
                forces = load_case.forces
                assert displacements or forces, "empty load case found"

                SUBCASEID = i+1
                if displacements:
                    SPCID = SUBCASEID * 2
                    SPC_string = tmplt.SUBCASESPC.format(SPCID=SPCID)
                else:
                    SPC_string = "   $ no displacements"
                if forces:
                    LOADID = SUBCASEID * 2
                    LOAD_string = tmplt.SUBCASELOAD.format(LOADID=LOADID)
                else:
                    LOAD_string = "   $ no loads"
                f.write(tmplt.SUBCASE.format(name=load_case.name,
                                             ID=SUBCASEID,
                                             SPC_string=SPC_string,
                                             LOAD_string=LOAD_string))

            # start bulk
            f.write(tmplt.BEGINBULK)

            # TODO: implement properties
            f.write("$\n$ 1 PROPERTY DEFINITION\n$\n")
            for prop in properties:
                T = prop.thickness
                f.write(tmplt.PSHELL.format(PID=1, MID1=1, MID2=1, MID3=1))

            last_node_id = 0
            for node in nodes:
                mesh_id = node.mesh_id
                if mesh_id > last_node_id:
                    last_node_id = mesh_id

            if udf_nodes:
                for node in udf_nodes:
                    # assert node.mesh_id is None, "expected mesh_id is not None for UDF nodes."
                    last_node_id += 1
                    node.mesh_id = last_node_id

            nb_rbars = len(rbars)
            if rbars:
                f.write("$\n$ {:d} RIGID BARS\n$\n".format(nb_rbars))
            for i, rbar in enumerate(rbars):
                EID = i+1
                f.write(tmplt.RBAR.format(EID=EID,
                                          GA=rbar.dependent_node.mesh_id,
                                          GB=rbar.independent_node.mesh_id,
                                          CNA=123456,
                                          CNB=123456))

            materials = dict((mat, i) for i, mat in enumerate(materials))
            if materials:
                f.write("$\n$ {:d} MATERIAL DEFINITION\n$\n".format(len(materials)))
            for mat, MID in materials.items():
                f.write(tmplt.MAT.format(MID=MID, E=mat.E, G=mat.G, NU=mat.NU, RHO=mat.RHO))

            cbars = list(cbar_yielder(cbars))

            # first collect all unique PBAR elements from CBARs.
            pbars = set()
            for cbar in cbars:
                pbars.add(cbar.pbar)
            pbars = dict((pbar, i) for i, pbar in enumerate(pbars))

            if pbars:
                f.write("$\n$ {:d} Simple Beam Cross-Section Property\n$\n".format(len(pbars)))
            for pbar, PID in pbars.items():
                f.write(tmplt.PBARL.format(
                    PID=PID, MID=1, #materials[pbar.material],
                    TYPE="BAR", DIM1=pbar.width, DIM2=pbar.length))

            if cbars:
                f.write("$\n$ {:d} Simple Beam Elements\n$\n".format(len(cbars)))

            for i, cbar in enumerate(cbars):
                EID = i+1
                PID = pbars[cbar.pbar]
                X1, X2, X3 = cbar.orientation_vector
                W1A, W2A, W3A = cbar.offset1
                W1B, W2B, W3B = cbar.offset2
                f.write(tmplt.CBAR.format(EID=EID, PID=PID,
                                          GA=cbar.mesh_node1.mesh_id,
                                          GB=cbar.mesh_node2.mesh_id,
                                          X1=X1, X2=X2, X3=X3,
                                          W1A=W1A, W2A=W2A, W3A=W3A,
                                          W1B=W1B, W2B=W2B, W3B=W3B))

            # sort faces over mesh_id
            faces = sorted(faces, key=lambda obj: obj.mesh_id)
            nb_faces = len(faces)
            face_ID1 = faces[0].mesh_id
            # get unique first element
            face_ID_offset = last_node_id - face_ID1 + 1
            f.write("$\n$ {:d} SKIN PANELS ARE MODELED WITH CQUADS\n$\n".format(nb_faces))

            for face in faces:
                # Element identification number.
                EID = face.mesh_id+face_ID_offset
                # Property identification number
                # TODO: implement
                PID = 1
                face_nodes = face.nodes
                if len(face_nodes)==4:
                    T1 = T2 = T3 = T4 = 1
                    f.write(tmplt.CQUAD4.
                            format(EID=EID, PID=PID,
                                   G1=face_nodes[0].mesh_id,
                                   G2=face_nodes[1].mesh_id,
                                   G3=face_nodes[2].mesh_id,
                                   G4=face_nodes[3].mesh_id,
                                   THETA=0.0, ZOFFS=0.0,
                                   TFLAG=0, T1=T1, T2=T2, T3=T3, T4=T4))
                elif len(face_nodes)==3:
                    T1 = T2 = T3 = 1
                    f.write(tmplt.CTRIA3.
                            format(EID=EID, PID=PID,
                                   G1=face_nodes[0].mesh_id,
                                   G2=face_nodes[1].mesh_id,
                                   G3=face_nodes[2].mesh_id,
                                   THETA=0.0, ZOFFS=0.0,
                                   TFLAG=0, T1=T1, T2=T2, T3=T3))

                else:
                    raise NotImplementedError("only tri/quad elements are currently supported")

            # write loads and forces
            force_count = 0
            spc1_count = 0
            for i, load_case in enumerate(load_cases):

                LOADID = SPCID = (i+1)*2

                # collect all force SPC1 per load(case) in here
                SPC1IDs = []
                SPC1DATA = []
                for displacement in load_case.displacements:
                    SPCDDATA = []
                    mesh_node = displacement.mesh_nodes[0]
                    Gi = mesh_node.mesh_id
                    assert Gi, "MeshNode has no mesh_id assigned."

                    CID = position2CID(displacement.position)
                    add_node_with_coord(mesh_node, CID)

                    spc1_count += 1
                    SPC1ID = spc1_count
                    data = displacement._data
                    # SPC1 component numbers
                    C = ""
                    for j in range(6):
                        Ci = j+1
                        disp = data[j]
                        if disp is not None:
                            # DOF is constrained, add to Component numbers.
                            C+=str(Ci)
                            if disp != 0:
                                # forced displacement / rotation, add to SPCDDATA
                                SPCDDATA.append(dict(SID=SPCID, Gi=Gi, Ci=Ci, Di=disp))

                    assert C, "displacement constraint has only None values."
                    SPC1IDs.append(SPC1ID)
                    SPC1DATA.append(dict(SID=SPC1ID, C=C, Gi_list=[Gi], SPCDs=SPCDDATA))
                    spc1_count += 1

                # collect all force SIDs per load(case) in here
                FORCEIDs = []
                FORCEDATA = []
                for force in load_case.forces:
                    FORCEID = force_count*2+1
                    FORCEIDs.append(FORCEID)

                    mesh_node = force.mesh_nodes[0]
                    Gi = mesh_node.mesh_id
                    assert Gi, "MeshNode has no mesh_id assigned."

                    F1, F2, F3, F = force.F1, force.F2, force.F3, force.F
                    N1, N2, N3 = F1 / F, F2 / F, F3 / F
                    CID = position2CID(force.position)
                    add_node_with_coord(mesh_node, CID)

                    FORCEDATA.append(dict(SID=FORCEID, G=Gi, CID=CID,
                                          F=force.F, N1=N1, N2=N2, N3=N3))
                    force_count+=1

                SiLi_list = []
                for FORCEID in FORCEIDs:
                    scale_factor = 1
                    SiLi_list.extend([scale_factor, FORCEID])

                f.write("$ Loads for Load Case : {:}\n".format(load_case.name))
                if load_case.displacements:
                    f.write(tmplt.SPCADD(SID=SPCID, Si_list=SPC1IDs))
                if load_case.forces:
                    f.write(tmplt.LOAD(SID=LOADID, S=1, SiLi_list=SiLi_list))

                if FORCEDATA:
                    for i, DATA in enumerate(FORCEDATA):
                        load_set_name = "{0}_Force{1}".format(load_case.name, i+1)
                        f.write("$ Nodal Forces of Load Set : {:}\n".format(load_set_name))
                        f.write(tmplt.FORCE.format(**DATA))

                if SPC1DATA:
                    for i, DATA in enumerate(SPC1DATA):
                        load_set_name = "{0}_Displacement{1}".format(load_case.name, i+1)
                        SPCDs = DATA.pop("SPCDs")
                        f.write("$ Displacement Constraints of Load Set : {:}\n".format(load_set_name))
                        f.write(tmplt.SPC1(**DATA))
                        if SPCDs:
                            f.write("$ Enforced Displacements for Load Set : {:}\n".format(load_set_name))
                            for SPCD in SPCDs:
                                f.write(tmplt.SPCD(**SPCD))

            f.write("$\n$ {:d} GRID POINTS DESCRIBE THE GEOMETRY\n$\n".format(len(nodes)))
            for node in nodes:
                if node in nodes_with_coords:
                    f.write(tmplt.GRID_w_CD16.format(EID=node.mesh_id, x=node.x, y=node.y, z=node.z,
                                                   CD=nodes_with_coords[node]))
                else:
                    f.write(tmplt.GRID16.format(EID=node.mesh_id, x=node.x, y=node.y, z=node.z))

            if udf_nodes:
                f.write("$\n$ {:d} USER-DEFINED GRID POINTS\n$\n".format(len(udf_nodes)))
                for node in udf_nodes:
                    if node in nodes_with_coords:
                        f.write(tmplt.GRID_w_CD16.format(EID=node.mesh_id, x=node.x, y=node.y, z=node.z,
                                                       CD=nodes_with_coords[node]))
                    else:
                        f.write(tmplt.GRID16.format(EID=node.mesh_id, x=node.x, y=node.y, z=node.z))

            coords.pop(0)
            if coords:
                f.write("$ Referenced coordinate systems\n")
                for CID, coord in enumerate(coords):
                    f.write(tmplt.CORD2R16(CID+1, 0, coord))

#             force_tmplt =\
# """
# $ Loads for Load Case : _HINGE_LINE_OPTIMISATION.SC1
# LOAD     2       0.     1.       1      1.       3
# $ Nodal Forces of Load Set : actuator1
# FORCE    1       {id1:<8d}0      1000.12 1.       0.      0.
# $ Nodal Forces of Load Set : actuator2
# FORCE    3       {id2:<8d}0      1000.12 1.       0.      0.
# """
#             f.write(force_tmplt.format(id1=last_node_id-1, id2=last_node_id))

            # f.write("\n##############\n# NODAL FORCES\n##############\n")
            # for nodal_force in self.nodal_forces:
            #     f.write("{:} {:>15.6e} {:>15.6e}\n".format(nodal_force.mesh_node.id,
            #                                                nodal_force.Fx,
            #                                                nodal_force.Fy))
            #
            # f.write("\n###########\n# PRESSURES\n###########\n")
            # for pressure in self.pressures:
            #     f.write("{:} {:>15.6e}\n".format(pressure.mesh_face.id,
            #                                      pressure.load))

            # CLOSE DATA
            f.write(tmplt.ENDDATA)

        print("Written:", filename)


def cbar_yielder(cbars):
    for cbar in cbars:
        if isinstance(cbar, CBarGroup):
            for cbar in cbar.cbars:
                yield cbar
        else:
            yield cbar


if __name__ == '__main__':
    from parapy.cae.nastran.globs import NASTRAN_DOC
    filename = os.path.join(NASTRAN_DOC, "seug", "chapter7", "Freedom",
                            "setree", "seset-setree.bdf")
    # print read_bdf(filename)["coords"]

    # filename = "D:\\recvandijk\\My Documents\\BitBucket\\ParaPylot\\data\\test_job_101.bdf"
    from parapy.gui import display
    obj = BDFReader(filename=filename)
    display(obj)

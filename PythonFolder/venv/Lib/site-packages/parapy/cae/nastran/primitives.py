#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Primitives to build NASTRAN models"""

import math

from parapy.cae.nastran.utilities import Arrow, SequenceOfCones
from parapy.core import Attribute, Base, Input, Part, child, derived, val
from parapy.geom.generic.geom_base import GeomBase
from parapy.geom.generic.positioning import (
    Orientation, Point, Position, Vector)
from parapy.geom.occ.compound import Compound
from parapy.geom.occ.curve import LineSegment
from parapy.geom.occ.wire import Rectangle
from parapy.mesh.core import MeshNode


class NastranBase(Base):
    pass


class Material(NastranBase):
    pass


class Metal(Material):

    E = Input()
    NU = Input()
    G = Input(derived)
    RHO = Input()

    @G.getter
    def G(self):
        return self.E / (2 * (1 + self.NU))


Aluminium = Metal(E=30e6, G=10e6, NU=0.33, RHO=2100)


class LoadCase(Base):
    __initargs__ = ["forces", "displacements", "pressure_loads"]

    #: sequence of Force objects
    #: :type: list[Force]
    forces = Input([], in_tree=True)

    #: sequence of Displacement objects
    #: :type: list[Displacement]
    displacements = Input([], in_tree=True)

    #: iterable of PressureLoad objects
    pressure_loads = Input([], in_tree=True)


class PressureLoad():

    mesh_faces = Input()
    loads = Input()


class PBar(Base):
    pass


class PBarlBAR(PBar):
    """PBARL 'BAR'-type cross-section"""

    __initargs__ = ["width", "length", "material"]

    #: number
    width = Input()
    #: length
    length = Input()
    #: Material
    material = Input()


class CBar(LineSegment):
    """Nastran's CBAR Card.
    See: http://www.aero.polimi.it/~lanz/bacheca/downloads/cost/aa10_11/MD_Nastran_Elements_2.pdf"""

    __initargs__ = ["mesh_node1", "mesh_node2", "orientation_vector", "pbar"]

    #: MeshNode
    mesh_node1 = Input()

    #: MeshNode
    mesh_node2 = Input()

    #: Vector. Y-direction of cross-section.
    orientation_vector = Input()

    #: :type: PBar
    pbar = Input()

    #: Displacement of cross-section relative to mesh_node1.
    #: :type: Vector
    offset1 = Input(Vector(0, 0, 0))

    #: Displacement of cross-section relative to mesh_node2.
    #: :type: Vector
    offset2 = Input(Vector(0, 0, 0))

    @Attribute
    def start(self):
        return self.mesh_node1

    @Attribute
    def end(self):
        return self.mesh_node2

    @Part
    def profile1(self):
        return Rectangle(suppress=not isinstance(self.pbar, PBarlBAR),
                         width=self.pbar.width,
                         length=self.pbar.length,
                         position=Position(self.start,
                                      Orientation(y=self.orientation_vector,
                                                  z=Point.vector_to(self.start, self.end)))
                         +self.offset1)

    @Part
    def profile2(self):
        return Rectangle(suppress=not isinstance(self.pbar, PBarlBAR),
                         width=self.pbar.width,
                         length=self.pbar.length,
                         position=Position(self.end,
                                      Orientation(y=self.orientation_vector,
                                                  z=Point.vector_to(self.start, self.end)))
                         +self.offset2)


class CBarGroup(Base):
    __initargs__ = ["mesh_nodes", "orientation_vector"]

    #: MeshNode
    mesh_nodes = Input()
    #: Vector. Y-direction of cross-section.
    orientation_vector = Input()
    #: Vector. Displacement of cross-section relative to mesh_node1.
    offset1 = Input(Vector(0, 0, 0))
    #: Vector. Displacement of cross-section relative to mesh_node2.
    offset2 = Input(Vector(0, 0, 0))

    @Part
    def cbars(self):
        return CBar(quantify=len(self.mesh_nodes - 1),
                    mesh_node1=self.mesh_nodes[child.index],
                    mesh_node2=self.mesh_nodes[child.index + 1],
                    pass_down="orientation_vector, offset1, offset2")


class RBar(LineSegment):
    """Rigid Bar element"""

    __initargs__ = ["independent_node", "dependent_node"]

    #: MeshNode
    independent_node = Input()
    #: MeshNode
    dependent_node = Input()

    @Attribute
    def start(self):
        return self.independent_node

    @Attribute
    def end(self):
        return self.dependent_node


class Force(GeomBase):
    """position input is used for orientation!!!"""

    __initargs__ = ["mesh_nodes", "F1", "F2", "F3", "M1", "M2", "M3"]

    #: MeshNode instance
    #: :type: list[MeshNode]
    mesh_nodes = Input()
    #: Force in x-direction.
    #: :type: float
    F1 = Input(0)
    #: Force in y-direction.
    #: :type: float
    F2 = Input(0)
    #: Force in z-direction.
    #: :type: float
    F3 = Input(0)
    #: Moment around x axis.
    #: :type: float
    M1 = Input(0)
    #: Moment around y axis.
    #: :type: float
    M2 = Input(0)
    #: Moment around z axis.
    #: :type: float
    M3 = Input(0)
    #: :type: str
    name = Input(None)
    #: visual height of a single arrow head (not base).
    #: :type: float
    visual_length = Input(1)
    #: Vector to offset arrow point a bit for visualisation.
    #: Intented for use in case this arrow overlaps with
    #: another display entity.
    #: :type: float | None
    visual_offset = Input(None)
    #: pointing away from :attr:`point` or pointing towards it?
    #: :type: bool
    outward = Input(False)
    #: color for visualisation
    #: :type: str
    color = Input("red")

    @Attribute
    def F(self):
        """Resultant force"""
        F1, F2, F3 = self.F1, self.F2, self.F3
        return math.sqrt(F1 ** 2 + F2 ** 2 + F3 ** 2)

    @Attribute
    def M(self):
        """Resultant moment"""
        M1, M2, M3 = self.M1, self.M2, self.M3
        return math.sqrt(M1 ** 2 + M2 ** 2 + M3 ** 2)

    @Attribute
    def _data(self):
        return [self.F1, self.F2, self.F3, self.M1, self.M2, self.M3]

    @Attribute
    def _visual_objects(self):
        """
        :rtype: list[Arrow]
        """
        nodes = self.mesh_nodes
        if isinstance(nodes, MeshNode):
            nodes = [nodes]
        F1, F2, F3, M1, M2, M3 = self._data
        F = self.F
        M = self.M
        l = self.visual_length
        vx, vy, vz = self.position.orientation

        lst = []

        if F:
            vF = (F1/F * vx + F2/F * vy + F3/F * vz).normalize
            for node in nodes:
                pt = Point(*node[0:3])
                arrow = Arrow(pt, vF, l, outward=self.outward)
                lst.append(arrow)

        if M:
            vM = (M1 / M * vx + M2 / M * vy + M3 / M * vz).normalize
            for node in nodes:
                pt = Point(*node[0:3])
                arrow = Arrow(pt, vM, l, number_of_heads=2, outward=self.outward)
                lst.append(arrow)

        return lst

    @Part
    def visual(self):
        return Compound(self._visual_objects)


class Displacement(GeomBase):
    """Position input is used for orientation!!!
    Nodal only.
    """

    __initargs__ = ["mesh_nodes", "T1", "T2", "T3", "R1", "R2", "R3"]

    #: list of MeshNode
    #: :type: list[MeshNode]
    mesh_nodes = Input()

    #: Translation component x axis. None means free.
    #: :type: float | None
    T1 = Input(None)

    #: Translation component y axis. None means free.
    #: :type: float | None
    T2 = Input(None)

    #: Translation component z axis. None means free.
    #: :type: float | None
    T3 = Input(None)

    #: Rotation component x axis. None means free.
    #: :type: float | None
    R1 = Input(None)

    #: Rotation component y axis. None means free.
    #: :type: float | None
    R2 = Input(None)

    #: Rotation component z axis. None means free.
    #: :type: float | None
    R3 = Input(None)

    #: number >= 0. Scale factor for this force.
    scale_factor = Input(1.0, validator=val.Positive(True))

    #: :type: str | None
    name = Input(None)

    #: visual height of a single arrow head.
    #: :type: float
    visual_length = Input(1)

    #: Vector to offset all arrow point a bit for visualisation.
    #: Intented for use in case this arrow overlaps with
    #: another display entity.
    #: :type: Vector | None
    visual_offset = Input(None)

    #: color for visualisation
    color = Input((133, 255, 255))

    @Attribute
    def _data(self):
        return [self.T1, self.T2, self.T3, self.R1, self.R2, self.R3]

    @Attribute
    def _visual_objects(self):
        """
        :rtype: list[Arrow]
        """
        nodes = self.mesh_nodes
        if isinstance(nodes, MeshNode):
            nodes = [nodes]
        T1, T2, T3, R1, R2, R3 = self._data
        l = self.visual_length
        vx, vy, vz = self.position.orientation

        lst = []

        def add_arrow(t, r, pt, v):
            if t is not None or r is not None:
                n = 3
                pt -= v * (n * l)
                arrow = SequenceOfCones(pt, v, l, number_of_heads=n)
                lst.append(arrow)

        for node in nodes:
            pt = Point(*node[0:3])
            add_arrow(T1, R1, pt, vx)
            add_arrow(T2, R3, pt, vy)
            add_arrow(T3, R2, pt, vz)

        return lst

    @Part
    def visual(self):
        return Compound(self._visual_objects)


class SimpleSupport(Displacement):

    __initargs__ = ["mesh_nodes", "R1", "R2", "R3"]

    #: Translation component x axis. None means free.
    #: :type: float | None
    T1 = Attribute(0)

    #: Translation component y axis. None means free.
    #: :type: float | None
    T2 = Attribute(0)

    #: Translation component z axis. None means free.
    #: :type: float | None
    T3 = Attribute(0)


class Clamp(SimpleSupport):
    __initargs__ = ["mesh_nodes"]

    #: Rotation component x axis. None means free.
    #: :type: float | None
    R1 = Attribute(0)

    #: Rotation component y axis. None means free.
    #: :type: float | None
    R2 = Attribute(0)

    #: Rotation component z axis. None means free.
    #: :type: float | None
    R3 = Attribute(0)


class Property2D(Base):
    pass


class Shell2D(Property2D):
    """Thin shell property region in 2D"""

    __initargs__ = ["material", "thickness", "mesh_faces"]

    #: :type: Material
    material = Input()

    #: :type: float
    thickness = Input()

    #: :type: list[MeshFace]
    mesh_faces = Input()


class Frame(Base):

    #: :type: parapy.geom.Position
    position = Input()

    #: visual length of arrow head
    #: :type: float
    v_dim = Input(1)

    @Attribute
    def a1_c3(self):
        pos = self.position
        pt1, vz, vx = pos.location, pos.Vz, pos.Vx
        a1, a2, a3 = pt1
        b1, b2, b3 = pt1 + vz
        c1, c2, c3 = pt1 + vx
        return a1, a2, a3, b1, b2, b3, c1, c2, c3

    @Part
    def arrows(self):
        return Arrow(quantify=3,
                     point=self.position.location,
                     direction=self.position.orientation[child.index],
                     head_length=self.v_dim,
                     color=["red", "green", "blue"][child.index])


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom.generic.positioning import XOY

    f = Force([Point(1, 2, 3)], 1001, 0, 2001)
    d = Displacement([Point(3, 4, 5)], 0, None, 1.0, None, 0, 2.0)
    o = Frame(position=XOY)
    display([f, d, o])

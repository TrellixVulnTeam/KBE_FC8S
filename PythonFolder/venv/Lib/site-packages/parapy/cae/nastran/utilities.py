#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Some utilities for this package."""

# TODO: remove translate
# TODO: move this to core of ParaPy

import datetime

from parapy.core import Input, Attribute, derived
from parapy.geom.generic.positioning import Vector, Orientation, Position
from parapy.geom.generic.functions import translate
from parapy.geom.occ.primitives import Cylinder, Cone
from parapy.geom.occ.compound import Compound


def orthogonal_vector(vector, tol=1.0e-8):
    """
    Given one vector, return a random normalized, orthogonal vector.
    See http://math.stackexchange.com/questions/133177/finding-a-unit-vector-perpendicular-to-another-vector
    """
    m = None
    xm = None
    for idx, value in enumerate(vector):
        if abs(value) >= tol:
            m = idx
            xm = value
            break
    if m is None:
        raise ValueError("zero-vector supplied")

    n = 1 if m==0 else 2 if m==1 else 0
    xn = vector[n]
    y = [0, 0, 0]
    y[n] = xm
    y[m] = -xn
    return Vector(*y).normalize


def datetime_string():
    """
    Returns the current datetime string in iso-format, e.g. 2013-10-05T00:15:31
    :return: str
    """
    return datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')


def pos2ABC(position):
    """
    :param position: Position.
    :return: tuple. 9 values corresponding to CORD2R A1-C3.
    """
    A1, A2, A3 = position.location
    # point translated unit-distance in z direction
    B1, B2, B3 = translate(position, z=1)
    # point translated unit-distance in x-direction.
    C1, C2, C3 = translate(position, x=1)
    return A1, A2, A3, B1, B2, B3, C1, C2, C3


class Arrow(Compound):
    """Visual arrow"""

    __initargs__ = ["point", "direction", "head_length", "base_length"]

    #: base point of Arrow
    #: :type: Point
    point = Input()

    #: direction of arrow
    #: :type: Vector
    direction = Input()

    #: height of individual height cone
    #: :type: float
    head_length = Input(1)

    #: length of arrow base
    #: :type: float
    base_length = Input(derived)

    #: number of heads
    #: :type: int
    number_of_heads = Input(1)

    #: radius of cone base
    #: :type: float
    head_radius = Input(derived)

    #: radius of cone base
    #: :type: float
    base_radius = Input(derived)

    #: pointing away from :attr:`point` or pointing towards it?
    #: :type: bool
    outward = Input(True)

    @base_length.getter
    def base_length(self):
        return self.head_length * 3

    @head_radius.getter
    def head_radius(self):
        return 0.5 * self.head_length

    @base_radius.getter
    def base_radius(self):
        return 0.2 * self.head_radius

    @Attribute
    def built_from(self):
        pt = self.point
        v = self.direction.normalize
        n = self.number_of_heads
        lh = self.head_length
        lbase = self.base_length
        rbase = self.base_radius
        rhead = self.head_radius

        l = lbase + n * lh
        if not self.outward:
            pt -= v * l

        lst = []

        w = orthogonal_vector(v)
        pos = Position(pt, Orientation(x=w, z=v))

        cyl = Cylinder(radius=rbase, height=lbase, position=pos)
        lst.append(cyl)

        for i in range(n):
            pos_ = translate(pos, 'z', lbase + i * lh)
            cone = Cone(radius1=rhead, radius2=0, height=lh, position=pos_)
            lst.append(cone)

        return lst


class SequenceOfCones(Compound):

    __initargs__ = ["point", "direction", "cone_length", "number_of_heads"]

    #: base point of Arrow
    #: :type: Point
    point = Input()

    #: direction of arrow
    #: :type: Vector
    direction = Input()

    #: height of a single cone
    #: :type: float
    cone_length = Input(1)

    #: radius of cone base
    #: :type: float
    cone_radius = Input(derived)

    #: number of heads
    #: :type: int
    number_of_heads = Input(1)

    #: pointing away from :attr:`point` or pointing towards it?
    #: :type: bool
    outward = Input(True)

    @cone_radius.getter
    def cone_radius(self):
        return 0.5 * self.cone_length

    @Attribute
    def built_from(self):
        pt = self.point
        v = self.direction.normalize
        lcone = self.cone_length
        r = self.cone_radius
        n = self.number_of_heads

        l = lcone * n
        w = orthogonal_vector(v)

        if not self.outward:
            pt -= v * l

        pos = Position(pt, Orientation(x=w, z=v))

        lst = []
        for i in range(n):
            pos_ = translate(pos, 'z', i * lcone)
            cone = Cone(radius1=r, radius2=0, height=lcone, position=pos_)
            lst.append(cone)

        return lst


if __name__ == '__main__':

    # TODO: move some orthogonal_vector code to tests

    x = Vector(1,0,0)
    y = orthogonal_vector(x)
    print(y, x.dot(y))

    x = Vector(0,1,0)
    y = orthogonal_vector(x)
    print(y, x.dot(y))

    x = Vector(0,0,1)
    y = orthogonal_vector(x)
    print(y, x.dot(y))

    x = Vector(1,2,3)
    y = orthogonal_vector(x)
    print(y, x.dot(y))

    print(datetime_string())

    from parapy.geom.generic.positioning import Point
    from parapy.gui import display

    arrow = Arrow(Point(0,0,0), Vector(1, 0, 0), 1)
    seq_of_cones = SequenceOfCones(Point(0, 0, 0), Vector(1, 0, 0), 1, 3)
    display((arrow, seq_of_cones))

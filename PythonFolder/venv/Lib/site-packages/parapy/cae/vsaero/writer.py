#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines VSAERO writer

(i) BASIC INPUT
General information, onset flow, reference conditions, special options

(ii) OPTIONAL INPUT
Override default values, unusual input

(iii) PATCH GEOMETRY
Description of configuration surface in components, patches, sections,
basic points, etc., for panel generation

(iv) WAKE INPUT
Wake grid planes, type of wake, wake separation line, wake line geometry

(v) ON-BODY STREAMLINE INPUT
Location of starting point for each surface streamline

(vi) OFF-BODY VELOCITY SCAN
Locations of points in the flow at which velocities and pressures are desired

(vii) OFF-BODY STREAMLINE INPUT
Location of starting point and required upstream/downstream distances for
each off-body streamline
"""

import os
import sys
import warnings

from parapy.cae.vsaero import globs
from parapy.cae.vsaero.cards import CARD6_format, CARD7_format, CARDS
from parapy.cae.vsaero.writer_utils import datetime_string, get_settings
from parapy.core import Attribute, FileWriter, Input
from parapy.geom import Vector


class VSAEROWriter(FileWriter):
    """Object to write ``.IN`` for VSAERO analysis.

    >>> writer = VSAEROWriter(filename="test.IN")
    >>> writer.write()

    or:

    >>> writer = VSAEROWriter()
    >>> writer.write("test.IN")
    """

    #: override of FileWriter.file_or_dir
    file_or_dir = "file"
    #: override of FileWriter.wildcard
    wildcard = "VSAERO files (*.IN) |*.IN"

    #: :type: str
    header = Input(globs.HEADER)
    #: :type: str
    description = Input("")
    #: :type: collections.Sequence[parapy.cae.vsaero.primitives.Component]
    components = Input()
    #: :type: parapy.cae.vsaero.WakeAssembly
    wake_assembly = Input()
    #: :type: collections.Sequence[parapy.cae.vsaero.Streamline]
    streamlines = Input([])
    #: Starts streamlines on all Upper Shedding Panels and Lower-Shedding
    #: Panels of Type-1 Wakes.
    #: :type: bool
    automatic_streamlines = Input(True)
    #: :type: collections.Sequence[parapy.cae.vsaero.PanelNormalRotation]
    panel_normal_rotations = Input([])
    #: VSAERO settings for Cards. Each key has format: ``"CARD_{ID}_{NAME}"``.
    #: For example, ``RMINF`` on ``CARD`` 6 would be ``"CARD_6_RMINF"``.
    #: Required keys are:
    #:
    #: - CARD_6_RMINF
    #: - CARD_6_RNB
    #: - CARD_7_CBAR
    #: - CARD_7_SREF
    #: - CARD_7_SSPAN
    #: - CARD_7_RMPX
    #: - CARD_7_RMPY
    #: - CARD_7_RMPZ
    #:
    #: :type: dict[str, T]
    settings = Input()
    #: default settings for cards, value defaults to globs.SETTINGS
    #: :type: dict
    default_settings = Input(globs.SETTINGS)

    @Attribute
    def full_settings(self):
        default_settings = self.default_settings.copy()
        user_settings = self.settings
        default_settings.update(user_settings)
        return default_settings

    def write(self, pathname=None):
        """Implement this. path is a directory or file path depending on
        self.file_or_dir."""
        path = pathname or self.filename
        if not os.path.dirname(path) and self.default_directory:
            path = os.path.join(self.default_directory, path)
        filename = os.path.abspath(str(path))
        with open(filename, 'w') as f:
            self.write_main(f)
        print("Written:", filename)

    def write_main(self, f=sys.stdout):
        # Assign patch numbers to the patches of the components
        self.assign_patch_numbers()

        # merge default and user-defined settings
        self.write_header(f=f)
        self.write_basic_input(f=f)                 # (i)
        self.write_optional_input(f=f)              # (ii)
        self.write_patch_geometry(f=f)              # (ii)
        self.write_wake_input(f=f)                  # (iv)
        self.write_on_body_streamlines(f=f)         # (v)
        self.write_off_body_velocity_scans(f=f)     # (vi)
        self.write_off_body_streamlines(f=f)        # (vii)
        self.write_footer(f=f)

    def assign_patch_numbers(self):
        kwpch = 1
        for component in self.components:
            for patch in component.patches:
                patch.KWPCH = kwpch
                kwpch += 1

    def write_header(self, f=sys.stdout):
        date = datetime_string()
        desc = self.description
        s = self.header.format(datetime=date, metadata=desc)
        f.write(s)

    def write_footer(self, f=sys.stdout):
        f.write("END-OF-FILE\n")

    def write_basic_input(self, f=sys.stdout):
        self.write_divider("PART I: BASIC INPUT", f=f)
        self.write_card_2(f=f)
        self.write_card_3(f=f)
        self.write_card_4(f=f)
        self.write_card_5(f=f)
        self.write_card_6(f=f)
        self.write_card_7(f=f)
        self.write_card_8(f=f)

    def write_optional_input(self, f=sys.stdout):
        self.write_divider("PART II OPTIONAL INPUT", f=f)
        self.write_matrix_solver_namelist(f=f)
        self.write_boundary_layer_control(f=f)

    def write_patch_geometry(self, f=sys.stdout):
        self.write_divider("PART III: PATCH GEOMETRY", f=f)
        self.write_components(f=f)
        self.write_patches(f=f)

    def write_components(self, f=sys.stdout):
        settings = self.full_settings
        self.write_divider("Components", f=f)
        f.write("CARD 9A: COMPONENT DATA LABEL\n")
        f.write(CARDS.CARD9A)
        for KOMP, component in enumerate(self.components, 1):
            component.write(KOMP, settings, f)
        f.write("CARD 9F: COMPONENT END LABEL\n")
        f.write(CARDS.CARD9F)

    def write_patches(self, f=sys.stdout):
        # kwpch = 1
        self.write_divider("Patches", f=f)
        for KOMP, component in enumerate(self.components, 1):
            for patch in component.patches:
                patch.write(patch.KWPCH, KOMP, f=f)
                # patch.write(kwpch, KOMP, f=f)
                # patch.KWPCH = kwpch
                # kwpch += 1

        # closing CARD 10
        f.write("CARD 10: PATCH CARD\n")
        N, IDENT, MAKE, KLASS = 1, 0, 0, 0
        PNAME = "END OF PATCHES"
        s = CARDS.CARD10.format(N, IDENT, MAKE, KOMP, KLASS, PNAME)
        f.write(s)

    def write_wake_input(self, f=sys.stdout):
        self.write_divider("PART IV: WAKE INPUT", f=f)
        self.wake_assembly.write(f=f)

    def write_on_body_streamlines(self, f=sys.stdout):
        self.write_divider("PART V: ON-BODY STREAMLINE INPUT", f=f)
        if self.automatic_streamlines:
            self.write_automatic_streamlines(f=f)
        self.write_streamlines(f=f)
        f.write("CARD 26: LAST CARD OF STREAMLINE INPUT\n")
        f.write(CARDS.CARD26.format("", 0, 0, 0, 0, 0))

    def write_off_body_velocity_scans(self, f=sys.stdout):
        self.write_divider("PART VI: OFF-BODY VELOCITY SCAN", f=f)

    def write_off_body_streamlines(self, f=sys.stdout):
        self.write_divider("PART VII: OFF-BODY STREAMLINE INPUT", f=f)
        self.write_scan_box(f=f)
        f.write("CARD 35: OFF-BODY STREAMLINE\n")
        f.write(CARDS.CARD35.format(0, 0, 0, 0, 0, 0, 0, 0))

    def write_automatic_streamlines(self, f=sys.stdout):
        f.write("CARD 25G: AUTOMATIC STREAMLINES\n")
        f.write(CARDS.CARD25G)
        f.write(CARDS.CARD25H)

    def write_streamlines(self, f=sys.stdout):
        for streamline in self.streamlines:
            streamline.write(f=f)

    def write_scan_box(self, f=sys.stdout):
        f.write("CARD 27: SCAN BOX\n")
        f.write(CARDS.CARD27.format(0, 0, 0, 0, 0, 0))

    def write_divider(self, description="", f=sys.stdout):
        l = 0
        if description:
            l = len(description)
            if l > 79:
                description = description[:76] + "..."
                msg = "Description trimmed to 79 characters: {}"
                warnings.warn(msg.format(repr(description)))
        s = "C" + (79 - l) * "-" + description + "\n"
        f.write(s)

    def write_card_2(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('IPRI', 'IPRLEV', 'IPRESS', 'MSTOP', 'MSTART', 'MCASE',
                'IPLOT')
        values = get_settings(settings, 2, keys)
        values = ["" if v is None else v for v in values]
        values.insert(5, "")
        f.write("CARD 2: CONTROL CARD\n")
        f.write(CARDS.CARD2.format(*values))

    def write_card_3(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('MODE', 'NPNMAX', 'IBWI', 'NSUB')
        values = get_settings(settings, 3, keys)
        values = ["" if v is None else v for v in values]
        values.insert(2, "")
        values.insert(3, "")
        f.write("CARD 3: MODE CARD\n")
        f.write(CARDS.CARD3.format(*values))

    def write_card_4(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('NWIT', 'NVPI', 'IBLTYP', 'KASMAX', 'NHEXMX', 'ITKMX')
        values = get_settings(settings, 4, keys)
        values = ["" if v is None else v for v in values]
        f.write("CARD 4: NUMBER OF ITERATIONS\n")
        f.write(CARDS.CARD4.format(*values))

    def write_card_5(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('RSYM', 'RGPR', 'RNF', 'RFF', 'RCORE')
        values = get_settings(settings, 5, keys)
        values = ["" if v is None else v for v in values]
        values.extend(("", "", ""))
        f.write("CARD 5: SYMMETRY CARD\n")
        f.write(CARDS.CARD5.format(*values))

    def write_card_6(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('ALDEG', 'YAWDEG', 'RMINF', 'RNB', 'RMACH', 'COMPOP')
        values = get_settings(settings, 6, keys)
        f.write("CARD 6: ONSET CONDITIONS\n")
        f.write(CARD6_format(*values))

        [card_3_mode] = get_settings(settings, 3, ["MODE"])
        if int(card_3_mode) == 31:
            keys = ('OMEGAX', 'OMEGAY', 'OMEGAZ')
            OMEGAX, OMEGAY, OMEGAZ = get_settings(settings, 6, keys)
            f.write("CARD 6A: QUASI-STEADY ROTATION OPTION.\n")

            # might not be necessary in future VSAERO releases (current: v7.4)
            if globs.CARD_6_VELOCITY_VECTOR:
                # Determine the global axis velocity vector that results in
                # zero velocity around the moment reference point.
                keys = ('CBAR', 'SREF', 'SSPAN', 'RMPX', 'RMPY', 'RMPZ')
                CBAR, SREF, SSPAN, RMPX, RMPY, RMPZ = get_settings(settings,
                                                                   7, keys)
                OMEGA = Vector(OMEGAX/SSPAN, OMEGAY*(2/CBAR), OMEGAZ/SSPAN)
                RMP = Vector(RMPX, RMPY, RMPZ)
                vx, vy, vz = RMP.cross(OMEGA)
                f.write(CARDS.CARD6A.format(OMEGAX, OMEGAY, OMEGAZ,
                                            vx, vy, vz))
            else:
                f.write("CARD 6A: QUASI-STEADY ROTATION OPTION.\n")
                f.write(CARDS.CARD6A.format(OMEGAX, OMEGAY, OMEGAZ))

    def write_card_7(self, f=sys.stdout):
        keys = ('CBAR', 'SREF', 'SSPAN', 'RMPX', 'RMPY', 'RMPZ')
        values = get_settings(self.full_settings, 7, keys)
        f.write("CARD 7: REFERENCE GEOMETRY\n")
        f.write(CARD7_format(*values))

    def write_card_8(self, f=sys.stdout):
        settings = self.full_settings
        rotations = self.panel_normal_rotations
        norot = len(rotations)

        # write card 8
        keys = ("NORSET", "NPASUM", "JETPAN", "NBCHGE", "NCZONE", "NKPR",
                "NOROT", "NTMSEP", "JETEX", "NSWEP")
        values = get_settings(settings, 8, keys)
        norot_setting = values[6]
        if norot_setting is None:
            norot_setting = 0

        if norot != norot_setting:
            msg = ("NOROT value in settings does not correspond to number of "
                   "panel_normal_rotations. Provide correct 'CARD_8_NOROT' "
                   "value in settings input.")
            warnings.warn(msg.format(norot, norot_setting))

        values[6] = norot
        values = ["" if v is None else v for v in values]
        values.insert(1, "")
        values.insert(5, "")
        values.insert(6, "")
        values.insert(9, "")
        f.write("CARD 8: SPECIAL OPTIONS\n")
        f.write(CARDS.CARD8.format(*values))

        # CARD SET 8K: Panel Normal Rotations
        for rotation in rotations:
            rotation.write(f=f)

    def write_matrix_solver_namelist(self, f=sys.stdout):
        settings = self.full_settings
        keys = ('MATSOL', 'ITGSMX', 'SOLRES', 'RHSRES')
        values = get_settings(settings, "SOL2", keys)
        values = ["" if v is None else v for v in values]

        f.write("CARD SOL1: SOLVER DATA LABEL\n")
        f.write(CARDS.CARD_SOL1)
        f.write("CARD SOL2: SOLVER PARAMETERS\n")
        f.write(CARDS.CARD_SOL2.format(*values))
        f.write("CARD SOL3: SOLVER END LABEL\n")
        f.write(CARDS.CARD_SOL3)

    def write_boundary_layer_control(self, f=sys.stdout):
        # Boundary layer control
        settings = self.full_settings
        keys = ("BLWIT",)
        (blwit,) = get_settings(settings, "BLAYER", keys)
        f.write(CARDS.BLAYER1)
        f.write(CARDS.BLAYER2.format(blwit))
        f.write(CARDS.BLAYER3)

if __name__ == '__main__':
    from parapy.cae.vsaero.primitives import (Component, StructuredPatch,
                                              UnstructuredPatch)

    section1 = (0, 0, 0), (1, 0, 0), (2, 0, 0)
    section2 = (0, 1, 0), (1, 1, 0), (2, 1, 0)
    section3 = (0, 2, 0), (1, 2, 0), (2, 2, 0)
    patch1 = StructuredPatch(label="MyStructuredPatch",
                             sections=[section1, section2, section3])

    pts = [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0)]
    tri1 = [1, 2, 3]
    tri2 = [2, 4, 3]
    patch2 = UnstructuredPatch(label="MyUnstructuredPatch",
                               points=pts,
                               indices=[tri1, tri2])

    component = Component(label="MyComponent",
                          patches=[patch1, patch2])
    writer = VSAEROWriter(filename="test.IN",
                          components=[component])
    writer.write_main()

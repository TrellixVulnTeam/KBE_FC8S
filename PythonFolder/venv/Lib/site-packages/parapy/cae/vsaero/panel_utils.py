#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""General utilities for this VSAERO package."""

import warnings

from parapy.core import by_groups
from parapy.geom import Point, Vector

__all__ = ["quads_to_sections", "trias_to_nodes_indices"]


def quads_to_sections(faces, point, direction, test="next", tolang=45.):
    """Convert a list of MeshFace elements ``faces`` into sections of
    Points, of the form ``[[pt11, pt12, ...], [pt21, ...], ...]``.
    Typically, this function is used to convert a Salome mesh
    :attr:`~parapy.mesh.salome.grid.Grid.faces` attribute to
    :attr:`~parapy.cae.vsaero.StructuredPatch.sections`, input of
    :class:`~parapy.cae.vsaero.StructuredPatch`. A distance test between the
    center of all 4 corner faces in the grid and ``point`` is used to
    resolve the starting face. The angle between ``direction`` and the
    principle direction from the starting to its *immediate neighbours*
    :py`test="next"`, is used to resolve the column direction.  If you want
    the angle test between the corner face and the last face in respective
    row/column directions, specifiy :py`test="last"`. A RuntimeError is
    raised when the angle between ``direction`` and any of the 2 principle
    directions of the grid is larger than ``tolang``. By default, angles
    larger than 45 degrees are considered ambiguous. If you want to skip
    this angle test, specify :py:`tolang=None`.

    :param faces: result from Subgrid.faces.
    :type faces: collections.Sequence[parapy.mesh.salome.MeshFace]
    :param point: reference point used by this function to determine the
        closest starting corner point. Reference point does not have to lie
        exactly on a corner node.
    :type point: Point
    :param direction: reference vector to indicate direction of panel column.
        The direction is checked between the corner face and its **immediate**
        neighbour in any of the 2 principle directions. If you want the
        direction test between corner face and last face in the row- or
        column, set
    :type direction: Vector
    :param str test: by default, direction test is done between corner face
        and immediate neighbour ("next") in both principle directions of the
        grid. If you want the direction test between the corner faces and the
        *last* face in the respective row or column, specify "last".
    :param tolang: angular tolerance in degrees. If the angle between any of
        the 2 principle panel directions and the reference *direction* is
        greater than this tolerance (default 45 degrees), a RuntimeError is
        raised. Specify None to skip this check.
    :type tolang: float | None
    :rtype: list[list[parapy.mesh.salome.MeshFace]]
    :returns: ``[[pt11, pt12, ...], [pt21, ...], ...]``
    :raises RuntimeError: if the reference *point* or *direction* leads to
        ambiguity in choosing direction of panels.
    """
    arr = quads_to_ordered_array(faces, point, direction,
                                 test=test, tolang=tolang)
    dim1, dim2 = len(arr), len(arr[0])

    if dim1 == 1:
        if dim2 == 1:
            i1, i2, i3, i4 = _quad_indices_1x1(arr[0][0], point, direction,
                                               tolang=tolang)
        else:  # 1-dimensional column in prefered direction
            i1, i2, i3, i4 = _quad_indices_1xN(arr[0][0], arr[0][1], point)

    elif dim2 == 1:  # 1-dimensional row in prefered direction
        i1, i2, i3, i4 = _quad_indices_Nx1(arr[0][0], arr[1][0], point,
                                           direction, tolang=tolang)

    else:  # 2-dimensional
        i1, i2, i3, i4 = _quad_indices_NxN(arr[0][0], arr[0][1], arr[1][0])

    def walk_row1(row):
        for face in row:
            yield face.nodes[i1]
        yield face.nodes[i2]

    def walk_row2(row):
        for face in row:
            yield face.nodes[i3]
        yield face.nodes[i4]

    def walk():
        for row in arr:
            yield tuple(walk_row1(row))
        yield tuple(walk_row2(row))

    return tuple(walk())


def trias_to_nodes_indices(faces):
    """Convert a list of triangular MeshFace instances into a list of MeshNode
    instances and a list of mesh_ids per triangle ``(id1, id2, id3)``.

    :rtype: (list[parapy.mesh.salome.grid.MeshNode], list[(int, int, int)])
    """
    newid = 1
    visited = {}
    nodes = []
    ids = []
    for face in faces:
        n1, n2, n3 = face.nodes
        id1, id2, id3 = n1.mesh_id, n2.mesh_id, n3.mesh_id
        if id1 in visited:
            id1 = visited[id1]
        else:
            nodes.append(n1)
            visited[id1] = newid
            id1 = newid
            newid += 1
        if id2 in visited:
            id2 = visited[id2]
        else:
            nodes.append(n2)
            visited[id2] = newid
            id2 = newid
            newid += 1
        if id3 in visited:
            id3 = visited[id3]
        else:
            nodes.append(n3)
            visited[id3] = newid
            id3 = newid
            newid += 1
        ids.append((id1, id2, id3))
    return nodes, ids


def quads_to_array(faces):
    """Convert a list of quadrilateral MeshFace elements *faces* that
    represent an 2-dimensional structured array of faces into an array.

    :param faces: result from Subgrid.faces.
    :type faces: collections.Sequence[parapy.mesh.salome.MeshFace]
    :rtype faces: tuple[tuple[parapy.mesh.salome.MeshFace]]
    """
    f1, tail = faces[0], faces[1:]
    if not tail:
        return [[f1]]
    f2, tail = faces[1], faces[2:]
    if not tail:
        return [[f1, f2]]

    nodes1, nodes2 = f1.nodes, f2.nodes
    i11, i12, i13, i14 = (node.mesh_id for node in nodes1)
    i21, i22, i23, i24 = (node.mesh_id for node in nodes2)
    e12, e23, e34, e41 = (i11, i12), (i12, i13), (i13, i14), (i14, i11)
    e21, e32, e43, e14 = (i22, i21), (i23, i22), (i24, i23), (i21, i24)

    # matching btm -> top
    if e12 == e43:
        (j1, j2), (k1, k2) = (0, 1), (3, 2)
    # matching rgt -> lft
    elif e23 == e14:
        (j1, j2), (k1, k2) = (1, 2), (0, 3)
    # matching top -> btm
    elif e34 == e21:
        (j1, j2), (k1, k2) = (2, 3), (1, 0)
    # matching lft -> rgt
    elif e41 == e32:
        (j1, j2), (k1, k2) = (3, 0), (2, 1)
    else:
        msg = "No connectivity found between faces"
        raise RuntimeError(msg)

    count = 2
    e = nodes2[j1].mesh_id, nodes2[j2].mesh_id
    for face in tail:
        nodes = face.nodes
        e_ = nodes[k1].mesh_id, nodes[k2].mesh_id
        if e == e_:
            count += 1
            e = nodes[j1].mesh_id, nodes[j2].mesh_id
        else:
            break

    return tuple(by_groups(faces, count))


def quads_to_ordered_array(faces, point, direction, test="next", tolang=45.):
    """See :func:`quads_to_sections` for argument descriptions."""
    arr = quads_to_array(faces)
    dim1, dim2 = len(arr), len(arr[0])

    if test not in {"next", "last"}:
        msg = "test is either 'next' or 'last', not {}."
        raise RuntimeError(msg.format(repr(test)))

    if dim1 == 1:
        if dim2 == 1:
            # 1 x 1 array, return as is.
            return arr
        else:  # actually 1-dimensional

            # +----------------------------------+
            # |      |      |      |      |      |
            # |  f1  |      |      |      |  f2  |
            # +----------------------------------+
            #
            #    +---------->

            def check_angles(a, v):
                if tolang is not None:
                    limit = tolang + 90
                    if (a - limit) > 1.0e-7:  # filter out rounding issues.
                        msg = ("reference vector {:} is pointing more than "
                               "{:} degrees away from principal panel "
                               "direction {:}. Please choose a different "
                               "vector, another reference point, or skip this "
                               "test entirely with tolang=None.")
                        raise RuntimeError(msg.format(repr(direction), limit,
                                                      repr(v)))

            row = arr[0]
            f1, f2 = row[0], row[-1]
            s1, s2 = dist_to_face(f1, point), dist_to_face(f2, point)

            if round(s1, 7) == round(s2, 7):
                msg = ("Reference point {:} is ambiguous. First and last quad "
                       "are both at a minimum distance of {:}. Please choose "
                       "another reference point.")
                raise RuntimeError(msg.format(point, s1))

            if s1 < s2:
                if test == "next":
                    f1_ = row[1]
                else:  # "last"
                    f1_ = row[-1]
                v = unit_vector_between_faces(f1, f1_)
                angle = Vector.angle(direction, v, deg=True)
                check_angles(angle, v)
                if angle > 45:
                    return transpose(arr)
                else:
                    return arr
            else:
                if test == "next":
                    f2_ = row[-2]
                else:  # "last"
                    f2_ = row[0]
                v = unit_vector_between_faces(f2, f2_)
                angle = Vector.angle(direction, v, deg=True)
                check_angles(angle, v)
                if angle > 45:
                    return [[obj] for obj in reversed(row)]
                else:
                    return [tuple(reversed(row))]

    else:  # truly 2-dimensional

        #     +----------------------------------+
        #     |      |      |      |      |      |
        #     |  f2  |      |      |      |  f4  |
        #     +----------------------------------+
        # ^   |      |      |      |      |      |
        # |   |      |      |      |      |      |
        # |   +----------------------------------+
        # |   |      |      |      |      |      |
        # |   |      |      |      |      |      |
        # |   +----------------------------------+
        # +   |      |      |      |      |      |
        #     |  f1  |      |      |      |  f3  |
        #     +----------------------------------+
        #
        #        +---------->

        def get_angles(a, b, c, d):
            v1 = unit_vector_between_faces(a, b)
            v2 = unit_vector_between_faces(c, d)
            a1 = Vector.angle(direction, v1, deg=True)
            a2 = Vector.angle(direction, v2, deg=True)
            check_angles(a1, a2, v1, v2)
            return a1, a2

        def check_angles(a1, a2, v1, v2):
            if tolang is not None:
                # filter out rounding issues.
                if (a1 - tolang) > 1.0e-7 and (a2 - tolang) > 1.0e-7:
                    msg = ("Reference vector {:} is pointing more than "
                           "45 degrees away from both principal panel "
                           "directions {:} and {:}. Please choose a different "
                           "vector, another reference point, or skip this "
                           "test entirely with tolang=None.")
                    raise RuntimeError(msg.format(repr(direction),
                                                  repr(v1), repr(v2)))

        ftup = f1, f2, f3, f4 = arr[0][0], arr[0][-1], arr[-1][0], arr[-1][-1]
        stup = s1, s2, s3, s4 = tuple(round(dist_to_face(f, point), 7)
                                      for f in (f1, f2, f3, f4))
        smin = min(stup)
        imin = [i for i in range(4) if stup[i] == smin]
        n = len(imin)

        if n == 1:
            if s1 == smin:
                if test == "next":
                    fv, fw = arr[0][1], arr[1][0]
                else:  # "last"
                    fv, fw = arr[0][-1], arr[-1][0]
                a1, a2 = get_angles(f1, fv, f1, fw)
                if a1 <= a2:
                    return arr
                else:
                    return transpose(arr)

            elif s2 == smin:
                if test == "next":
                    fv, fw = arr[0][-2], arr[1][-1]
                else:  # "last"
                    fv, fw = arr[0][0], arr[-1][-1]
                a1, a2 = get_angles(f2, fv, f2, fw)
                if a1 <= a2:
                    return [tuple(reversed(row)) for row in arr]
                else:
                    return list(reversed(transpose(arr)))

            elif s3 == smin:
                if test == "next":
                    fv, fw = arr[-1][1], arr[-2][0]
                else:  # "last"
                    fv, fw = arr[-1][-1], arr[0][0]
                a1, a2 = get_angles(f3, fv, f3, fw)
                if a1 <= a2:
                    return list(reversed(arr))
                else:
                    return [tuple(reversed(row)) for row in transpose(arr)]

            else:  # s4 == smin:
                if test == "next":
                    fv, fw = arr[-1][-2], arr[-2][-1]
                else:  # "last"
                    fv, fw = arr[-1][0], arr[0][-1]
                a1, a2 = get_angles(f4, fv, f4, fw)
                if a1 <= a2:
                    return [tuple(reversed(row)) for row in reversed(arr)]
                else:
                    return list(reversed(transpose(reversed(arr))))

        # check for cylindrical topology
        elif n == 2:
            i1, i2 = imin
            f1p, f2p = ftup[i1], ftup[i2]
            if are_faces_touching(f1p, f2p):
                if i1 == 0 and i2 == 1:
                    f1p_next, f2p_next = arr[0][1], arr[0][-2]
                    a1, a2 = get_angles(f1p, f1p_next, f2p, f2p_next)
                    if a1 <= a2:
                        return arr
                    else:
                        return [tuple(reversed(row)) for row in arr]
                elif i1 == 0 and i2 == 2:
                    f1p_next, f2p_next = arr[1][0], arr[-2][0]
                    a1, a2 = get_angles(f1p, f1p_next, f2p, f2p_next)
                    if a1 <= a2:
                        return transpose(arr)
                    else:
                        return [tuple(reversed(row)) for row in transpose(arr)]
                elif i1 == 1 and i2 == 3:
                    f1p_next, f2p_next = arr[1][-1], arr[-2][-1]
                    a1, a2 = get_angles(f1p, f1p_next, f2p, f2p_next)
                    if a1 <= a2:
                        return transpose(reversed(arr))
                    else:
                        return list(reversed(transpose(reversed(arr))))
                elif i1 == 2 and i2 == 3:
                    f1p_next, f2p_next = arr[-1][1], arr[-1][-2]
                    a1, a2 = get_angles(f1p, f1p_next, f2p, f2p_next)
                    if a1 <= a2:
                        return list(reversed(arr))
                    else:
                        return [tuple(reversed(row)) for row in reversed(arr)]
                else:
                    assert False, "Not expected, consult ParaPy support team."

        msg = ("Reference point {} is ambiguous. Found {} corner quads "
               "at minimum distance {}. Please choose another point.")
        raise RuntimeError(msg.format(point, n, smin))

def dist_to_face(face, point):
    return Point.distance(quad_center(face), point)
    # return min(Point.distance(point, node) for node in face.nodes)


def quad_center(face):
    (x1, y1, z1), (x2, y2, z2), (x3, y3, z3), (x4, y4, z4) = face.nodes
    x = (x1 + x2 + x3 + x4) / 4.
    y = (y1 + y2 + y3 + y4) / 4.
    z = (z1 + z2 + z3 + z4) / 4.
    return Point(x, y, z)


def unit_vector_between_faces(face1, face2):
    p1, p2 = quad_center(face1), quad_center(face2)
    return Point.vector_to(p1, p2).normalize


def are_faces_touching(face1, face2):
    s = set(n.mesh_id for n in face1.nodes)
    for n in face2.nodes:
        if n.mesh_id in s:
            return True
    return False


def transpose(array):
    """
    >>> transpose([[1, 2], [3, 4]])
    [(1, 3), (2, 4)]
    """
    return list(zip(*array))


def _quad_indices_1x1(face, point, direction, tolang=45.):
    nodes = face.nodes
    dists = [Point.distance(point, node) for node in nodes]
    smin = min(dists)
    n = [round(d, 7) for d in dists].count(round(smin, 7))

    if n > 1:
        msg = ("Reference point {:} is ambiguous. Found {:} corner nodes "
               "at minimum distance {:}. Please choose another point.")
        raise RuntimeError(msg.format(point, n, smin))

    def check_angles(a1, a2, v1, v2):
        if tolang is not None:
            # filter out rounding issues.
            if (a1 - tolang) > 1.0e-7 and (a2 - tolang) > 1.0e-7:
                msg = ("reference vector {:} is pointing more than "
                       "45 degrees away from both principle quad "
                       "directions {:} and {:}. Please choose a different "
                       "vector, another reference point, or skip this "
                       "test entirely with tolang=None.")
                raise RuntimeError(msg.format(repr(direction),
                                              repr(v1), repr(v2)))

    i = dists.index(smin)
    i_next, i_prev = i - 3, i - 1
    n, n1, n2 = nodes[i], nodes[i_next], nodes[i_prev]
    v1, v2 = Point.vector_to(n, n1), Point.vector_to(n, n2)
    a1 = Vector.angle(direction, v1, deg=True)
    a2 = Vector.angle(direction, v2, deg=True)
    check_angles(a1, a2, v1, v2)
    if a1 <= a2:
        return i, i - 3, i - 1, i - 2
    else:
        return i, i - 1, i - 3, i - 2


# 1 column of N rows.
def _quad_indices_1xN(f1, f2, point):
    nodes1 = f1.nodes
    nodes2 = f2.nodes
    ids1 = [n.mesh_id for n in nodes1]
    ids2 = set(n.mesh_id for n in nodes2)
    match1, match2 = (i for i in ids1 if i not in ids2)
    idx1, idx2 = ids1.index(match1), ids1.index(match2)

    assert (idx1 == 0 and idx2 == 1) or (idx1 == 1 and idx2 == 2) or \
           (idx1 == 2 and idx2 == 3) or (idx1 == 0 and idx2 == 3)
    if idx1 == 0 and idx2 == 3:
        idx3, idx4 = 1, 2
    else:
        idx3, idx4 = idx1 - 1, idx1 - 2

    node1, node2 = nodes1[idx1], nodes1[idx2]
    s1, s2 = Point.distance(point, node1), Point.distance(point, node2)

    if round(s1, 7) == round(s2, 7):
        msg = ("Reference point {:} is ambiguous. First and last quad "
               "are both at a minimum distance of {:}. Please choose "
               "another reference point.")
        raise RuntimeError(msg.format(point, s1))

    if s1 < s2:
        return idx1, idx3, idx2, idx4
    else:
        return idx2, idx4, idx1, idx3


# 1 row, N columns
# TODO RvD: check angle with direction vector?
def _quad_indices_Nx1(f1, f2, point, direction, tolang=45.):
    nodes1 = f1.nodes
    nodes2 = f2.nodes
    ids1 = [n.mesh_id for n in nodes1]
    ids2 = set(n.mesh_id for n in nodes2)
    match1, match2 = (i for i in ids1 if i not in ids2)
    idx1, idx2 = ids1.index(match1), ids1.index(match2)

    assert (idx1 == 0 and idx2 == 1) or (idx1 == 1 and idx2 == 2) or \
           (idx1 == 2 and idx2 == 3) or (idx1 == 0 and idx2 == 3)
    if idx1 == 0 and idx2 == 3:
        idx3, idx4 = 1, 2
    else:
        idx3, idx4 = idx1 - 1, idx1 - 2

    node1, node2 = nodes1[idx1], nodes1[idx2]

    # let's test with direction vector
    if tolang is not None:

        def verify_distance(n1, n2):
            s1, s2 = Point.distance(point, n1), Point.distance(point, n2)
            if round(s1, 7) == round(s2, 7):
                msg = ("Reference point {:} is ambiguous. Both free nodes of "
                       "start panel, are at a minimum distance of {:}. Please "
                       "choose another reference point.")
                warnings.warn(msg.format(point, s1))
            elif s1 > s2:
                msg = ("Reference direction {:} and reference "
                       "point {:} are conflicting. Reference direction would "
                       "lead to node {:} as start point, while reference "
                       "point prefers node {:}. Choose a reference point that "
                       "matches with your preferred direction.")
                warnings.warn(msg.format(direction, point, n1, n2))

        v = Point.vector_to(node1, node2)
        a = Vector.angle(direction, v, deg=True)

        if (a - tolang) <= 1.0e-7:
            verify_distance(node1, node2)
            return idx1, idx2, idx3, idx4
        elif (a - tolang - 90) >= -1.0e-7:
            verify_distance(node2, node1)
            return idx2, idx1, idx4, idx3
        else:
            msg = ("Reference vector {:} is pointing more than 45 degrees "
                   "away from both principal panel directions {:} and {:}. "
                   "Start point will be resolved from closest point test. To "
                   "suppress this warning, please choose a different vector, "
                   "or skip this test entirely with tolang=None.")
            warnings.warn(msg.format(repr(direction), repr(v), repr(-v)))

    # point test
    s1, s2 = Point.distance(point, node1), Point.distance(point, node2)
    if round(s1, 7) == round(s2, 7):
        msg = ("Reference point {:} is ambiguous. First and last quad "
               "are both at a minimum distance of {:}. Please choose "
               "another reference point.")
        raise RuntimeError(msg.format(point, s1))

    if s1 < s2:
        return idx1, idx2, idx3, idx4
    else:
        return idx2, idx1, idx4, idx3


# N rows, N columns
# TODO: check for quality w.r.t. direction, point?
def _quad_indices_NxN(f, f1, f2):
    nodes, nodes1, nodes2 = f.nodes, f1.nodes, f2.nodes
    lst = [n.mesh_id for n in nodes]
    ids = set(lst)
    ids1 = set(n.mesh_id for n in nodes1)
    ids2 = set(n.mesh_id for n in nodes2)

    s_id1 = ids - ids1 - ids2
    id1 = s_id1.pop()
    assert not s_id1
    s_id2 = ids & ids1 - ids2
    id2 = s_id2.pop()
    assert not s_id2
    s_id3 = ids & ids2 - ids1
    id3 = s_id3.pop()
    assert not s_id3
    s_id4 = ids & ids1 & ids2
    id4 = s_id4.pop()
    assert not s_id4
    return tuple(lst.index(i) for i in (id1, id2, id3, id4))


if __name__ == '__main__':
    from parapy.geom import RectangularFace
    from parapy.mesh.salome import FixedLength, Quad, Mesh
    from parapy.gui import display

    w, l, s = 2, 1, 0.2
    face = RectangularFace(w, l, centered=False)
    ctrl1 = FixedLength(shape=face, length=s)
    ctrl2 = Quad(shape=face)
    mesh = Mesh(shape_to_mesh=face, controls=[ctrl1, ctrl2])

    point = Point(2, l, 0)
    direction = Vector(0, -1, 0)
    faces = mesh.grid.faces
    sections = quads_to_sections(faces, point, direction)

    display((face, mesh, sections))

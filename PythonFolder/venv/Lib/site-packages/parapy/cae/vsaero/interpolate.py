#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.


def interpolate_sections(pts1, pts2, n, surface=None, precision=1.0e-3):
    """Return ``n`` interpolated sections between opposing ``pts1`` and
    ``pts2``. Optionally provide ``surface`` for uv-interpolation.

    >>> from math import pi
    >>> from parapy.geom import Sphere
    >>> srf = Sphere(1).lateral_face.basis_surface
    >>> lst1 = [srf.point(u * 0.1 * pi, 0) for u in range(10)]
    >>> lst2 = [srf.point(u * 0.1 * pi, 0.25 * pi) for u in range(10)]
    >>> arr1 = interpolate_sections(lst1, lst2, n=5)
    >>> # to follow the surface
    >>> arr2 = interpolate_sections(lst1, lst2, n=5, surface=srf)

    :param pts1: first sequence of Points.
    :type pts1: collections.Sequence[parapy.geom.Point]
    :param pts2: opposing sequence of Points.
    :type pts2: collections.Sequence[parapy.geom.Point]
    :param int n: number of sections in result.
    :param surface: optional surface for uv-interpolation.
    :type surface: None | parapy.geom.occ.surface.Surface
    :param float precision: precision for projecting points on surface.
    :rtype: list[list[Point]]
    """
    if n < 2:
        msg = "n should be at least 2, not {}."
        raise RuntimeError(msg.format(n))
    elif n == 2:
        return [list(pts1), list(pts2)]
    else:
        arr = [[] for _ in range(n)]
        lst1 = arr[0]
        lst2 = arr[-1]
        step = 1 / (n - 1)
        if surface:
            uvs1 = [surface.parameter(pt, precision) for pt in pts1]
            uvs2 = [surface.parameter(pt, precision) for pt in pts2]
            for (u1, v1), pt1, (u2, v2), pt2 in zip(uvs1, pts1, uvs2, pts2):
                lst1.append(pt1)
                for j in range(1, n - 1):
                    frac = j * step
                    u = u1 + (u2 - u1) * frac
                    v = v1 + (v2 - v1) * frac
                    pt = surface.point(u, v)
                    arr[j].append(pt)
                lst2.append(pt2)
        else:
            for pt1, pt2 in zip(pts1, pts2):
                lst1.append(pt1)
                for j in range(1, n - 1):
                    frac = j * step
                    pt = pt1.interpolate(pt2, frac=frac)
                    arr[j].append(pt)
                lst2.append(pt2)
        return arr


def interpolate_polar_sections(points, center, n, surface=None, precision=1.0e-3):
    """Return ``n`` interpolated sections on a circular face from the
    circumferential ``points`` towards the ``center``. Optionally provide
    ``surface`` for uv-interpolation.

    :param points: circumferential sequence of Points.
    :type points: collections.Sequence[parapy.geom.Point]
    :param center: center point
    :param int n: number of sections in result.
    :param surface: optional surface for uv-interpolation.
    :type surface: None | parapy.geom.occ.surface.Surface
    :param float precision: precision for projecting points on surface.
    :rtype: list[list[Point]]
    """
    if n < 2:
        msg = "n should be at least 2, not {}."
        raise RuntimeError(msg.format(n))
    elif n == 2:
        lst2 = [center] * len(points)
        return [list(points), lst2]
    else:
        arr = [[] for _ in range(n - 1)]
        lst1 = arr[0]
        lst2 = [center] * len(points)
        arr.append(lst2)
        step = 1 / (n - 1)
        if surface:
            uvs1 = [surface.parameter(pt, precision) for pt in points]
            u2, v2 = surface.parameter(center, precision)
            for (u1, v1), pt1 in zip(uvs1, points):
                lst1.append(pt1)
                for j in range(1, n - 1):
                    frac = j * step
                    u = u1 + (u2 - u1) * frac
                    v = v1 + (v2 - v1) * frac
                    pt = surface.point(u, v)
                    arr[j].append(pt)
        else:
            for pt1 in points:
                lst1.append(pt1)
                for j in range(1, n - 1):
                    frac = j * step
                    pt = pt1.interpolate(center, frac=frac)
                    arr[j].append(pt)
        return arr


if __name__ == '__main__':
    import math
    from parapy.geom import Point, Sphere
    from parapy.gui import display

    srf = Sphere(1).lateral_face.basis_surface
    lst1 = [srf.point(u * 0.1 * math.pi, 0) for u in range(10)]
    lst2 = [srf.point(u * 0.1 * math.pi, 0.25 * math.pi) for u in range(10)]
    arr1 = interpolate_sections(lst1, lst2, n=5)
    arr2 = interpolate_sections(lst1, lst2, n=5, surface=srf)

    lst1 = [srf.point(u * 0.2 * math.pi, 0) for u in range(10)]
    center = Point(0, 0, 1)
    arr3 = interpolate_polar_sections(lst1, center, n=5)
    arr4 = interpolate_polar_sections(lst1, center, n=5, surface=srf)

    display((srf, arr1, arr2, arr3, arr4))


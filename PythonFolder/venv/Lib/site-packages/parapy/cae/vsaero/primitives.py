#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import sys
import itertools

from parapy.core import (Base, Input, Attribute, Part, pairwise, child,
                         list_of_numbers, derived)
from parapy.geom import (Vector, Plane, Point, FittedCurve, Vertex, Wire,
                         TranslatedShape, RuledShell)
from parapy.mesh.core.udf import full_cosine, cosine
from parapy.cae.vsaero.cards import (CARDS, CARD_UNSTR2_format,
                                     CARD13D_format, CARD20D_format,
                                     CARD24B_format)
from parapy.cae.vsaero.panel_utils import transpose
from parapy.cae.vsaero.writer_utils import get_settings, fmt_real
from parapy.cae.vsaero.polygons import PanelPolygon, PanelFace
from parapy.cae.vsaero import globs


# TODO RvD: __icon__
class VSAEROBase(Base):
    """Abstract base class for all VSAERO primitives."""
    __icon__ = os.path.join(globs.ICN_DIR, "vsaero.png")


# TODO RvD: __icon__
class Component(VSAEROBase):
    #: Name for this component.
    #: :type: str
    label = Input("")

    #: Sequence of Patch instances belonging to this Component.
    #: :type: collections.Sequence[Patch]
    patches = Input(in_tree=True)

    def write(self, KOMP=1, settings=globs.SETTINGS, f=sys.stdout):
        label = self.label
        if label:
            name = "{:} (KOMP: {:d})".format(label, KOMP)
        else:
            name = "KOMP: {:d}".format(label, KOMP)
        keys = ("CTX", "CTY", "CTZ", "SCAL", "THET", "ADROT", "ROTAX", "IPAR")
        values = get_settings(settings, "9B", keys)
        f.write("CARD 9B: COMPONENT CARD\n")
        # TODO RvD: check length of label
        f.write("{:<80}\n".format(name[0:80]))
        # f.write(("{:>10}" * 7 + "{:>5}" + "\n").format(*keys))
        f.write(CARDS.CARD9B.format(*values))


# TODO RvD: __icon__
class Patch(VSAEROBase):
    #: Value for PNAME.
    #: :type: str
    label = Input("")

    #: Type of Patch.
    #: :type: int
    IDENT = Input()

    #: Assigns an ASSEMBLY number to this patch--these can be in any order.
    #: Panels on different ASSEMBLIES are not allowed to be neighbors.
    #: :type: int
    KLASS = Input(0)

    @Attribute(settable=True)
    def KWPCH(self):
        """KWPCH should not be set by user. It will be set by the VSAEROWriter
        as all patches are collected there and assigned there respective ID.
        """
        msg = ("Patch instance {} has no KWPCH assigned yet. Run "
               "VSAEROWriter first to have one assigned to this patch.")
        raise RuntimeError(msg.format(self))

    # abstract method
    def write(self, patch_number, KOMP, f=sys.stdout):
        raise NotImplementedError()


# TODO RvD: __icon__
class StructuredPatch(Patch):
    """A structured patch consists of a sequence of Points (:attr:`sections`).
    Use :attr:`force_summary` to control whether the output file contains a
    force summary including sectional Cl, Cd, Cm, etc.

    .. note:: only thick surfaces (IDENT = 1 or 2) are implemented. Subclass
        this class for other types of surfaces. Tip patches are also not
        supported.
    """

    __initargs__ = ("sections",)

    #: sequence of sequence of points (x, y, z)
    #: :type: collections.Sequence[collections.Sequence[(float, float, float)]]
    sections = Input()

    #: Type of Patch. Only thick surfaces (IDENT = 1 or 2) are implemented.
    #: If 1 (default), the output file contains a force summary with
    #: sectional Cl, Cd, Cm, etc. Set to 2, to suppress output.
    #: :type: int
    IDENT = Input(1)

    @Attribute
    def points_per_panel(self):
        """Array of 4 points (pt1, pt2, pt3, pt4) per quad panel.

        :rtype: list[list[(Point, Point, Point, Point)]]
        """
        return [[(pt1, pt2, pt3, pt4) for (pt1, pt2), (pt4, pt3)
                 in zip(pairwise(s1), pairwise(s2))]
                for s1, s2 in pairwise(self.sections)]

    @Attribute
    def points_per_side(self):
        """List of border Points per side (order 1-4). Along the principle
        direction of that side.

        :rtype: (list[Point], list[Point], list[Point], list[Point])
        """
        sections = self.sections
        return (sections[0],
                [pts[-1] for pts in sections],
                list(reversed(sections[-1])),
                list(reversed([pts[0] for pts in sections])))

    @Attribute
    def singularity_flag_per_side(self):
        def check(pts):
            curr = pts[0]
            for pt in pts[1:]:
                if pt != curr:
                    return False
                else:
                    curr = pt
            return True

        return list(map(check, self.points_per_side))

    @Part
    def panels(self):
        return PanelPolygon(
            quantify=(len(self.sections) - 1, len(self.sections[0]) - 1),
            points=self.points_per_panel[child.index[0]][child.index[1]])

    @Part
    def side1(self):
        return PanelPolygon(suppress=self.singularity_flag_per_side[0],
                            points=self.points_per_side[0],
                            force_closure=False,
                            color="RED")

    @Part
    def side2(self):
        return PanelPolygon(suppress=self.singularity_flag_per_side[1],
                            points=self.points_per_side[1],
                            force_closure=False,
                            color="GREEN")

    @Part
    def side3(self):
        return PanelPolygon(suppress=self.singularity_flag_per_side[2],
                            points=self.points_per_side[2],
                            force_closure=False,
                            color="BLUE")

    @Part
    def side4(self):
        return PanelPolygon(suppress=self.singularity_flag_per_side[3],
                            points=self.points_per_side[3],
                            force_closure=False,
                            color="ORANGE")

    def write(self, patch_number, KOMP, f=sys.stdout):
        label = self.label
        if label:
            PNAME = label + " (PATCH: {:d})".format(patch_number)
        else:
            PNAME = "PATCH: {:d}".format(patch_number)
        sections = self.sections
        N, IDENT, MAKE, KLASS = "", self.IDENT, 0, self.KLASS

        if not (IDENT == 1 or IDENT == 2):
            msg = ("Only IDENT 1 or 2 are implemented, not {:}. Subclass "
                   "StructuredPatch to implement this custom patch type.")
            raise NotImplementedError(msg.format(IDENT))

        s = CARDS.CARD10.format(N, IDENT, MAKE, KOMP, KLASS, PNAME)
        f.write("Card 10: PATCH CARD\n")
        f.write(s)

        last_column = len(sections)
        for i, points in enumerate(sections, 1):
            STX, STY, STZ, SCALE, ALF, THETA = 0.0, 0.0, 0.0, 1.0, 0.0, 0.0
            INMODE = 4  # (x, y, z) inputs
            NPS, INTS = 0, 0
            if i == last_column:
                NODES = 3
            else:
                NODES = 0
            f.write("Card 11: SECTION CARD\n")
            f.write(CARDS.CARD11.format(STX, STY, STZ, SCALE, ALF, THETA,
                                        INMODE, NODES, NPS, INTS))
            f.write("Card 13D: BASIC POINTS\n")
            for pt in points:
                f.write(CARD13D_format(*pt, width=10))  # is a function call
            f.write("CARD 14: CHORDWISE NODE CARD\n")
            NODEC, NPC, INTC, MOVE = 3, 0, 3, 0
            f.write(CARDS.CARD14.format(NODEC, NPC, INTC, MOVE))


# TODO RvD: __icon__
class UnstructuredPatch(Patch):
    """An unstructured patch consists of triangular panels with no required
    order. You define triangles with two types of inputs:

    1. :attr:`points`: flat sequence of all corner points.
    2: :attr:`indices`: for each triangles, three integers that refer to the
        points (start index = 1).

    By default, the patch is assumed to be a *thick* surface (i.e. wetted on
    one side). For a *thin* surface (i.e. wetted on both sides), specificy
    :attr:`IDENT` = 11. Example:

    >>> from parapy.geom import Point
    >>> pts = [Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0), Point(1, 1, 1)]
    >>> tri1 = [1, 2, 3]
    >>> tri2 = [2, 4, 3]
    >>> indices = [tri1, tri2]
    >>> patch = UnstructuredPatch(label="MyPatch",
    ...                           points=pts,
    ...                           indices=indices)
    """

    #: Sequence of corner points. :attr:`indices` refer to these points with
    #: start index 1.
    #: :type: collections.Sequence[(float, float, float), (float, float, float), (float, float, float)]
    points = Input()

    #: Each triangle is defined by 3 indices refering to the :attr:`points`.
    #: :type: collections.Sequence[int, int, int]
    indices = Input()

    #: Type of Patch. Default is Unstructured thick surface (10).
    #: :type: int
    IDENT = Input(10)

    @Attribute
    def points_per_panel(self):
        """List of 3 points (pt1, pt2, pt3) per triangle.

        :rtype: list[(Point, Point, Point)]
        """
        pts, indices = self.points, self.indices
        return [(pts[i - 1], pts[j - 1], pts[k - 1]) for i, j, k in indices]

    @Part
    def panels(self):
        return PanelPolygon(quantify=len(self.indices),
                            points=self.points_per_panel[child.index])

    def write(self, patch_number, KOMP, f=sys.stdout):
        label, points, indices = self.label, self.points, self.indices
        if label:
            PNAME = label + " (PATCH: {:d})".format(patch_number)
        else:
            PNAME = "(PATCH: {:d})".format(patch_number)
        N, IDENT, MAKE, KLASS = "", self.IDENT, 0, self.KLASS
        f.write("Card 10: PATCH CARD\n")
        f.write(CARDS.CARD10.format(N, IDENT, MAKE, KOMP, KLASS, PNAME))

        NORM = 0  # Surface Normals: None

        if NORM == 1 or NORM == 2:
            msg = "NORM 1 or 2 not supported yet. Implement CARD UNSTR4."
            raise NotImplementedError(msg)

        f.write("CARD UNSTR1: UNSTRUCTURED PATCH PARAMETERS\n")
        NCPT = len(points)
        NTRI = len(indices)
        f.write(CARDS.CARD_UNSTR1.format(NCPT, NTRI, NORM))
        f.write("CARD UNSTR2: COORDINATES OF CORNER POINTS\n")
        for x, y, z in points:
            f.write(
                CARD_UNSTR2_format(x, y, z, width=16))  # is a function call
        f.write("CARD UNSTR3: CORNER POINT INDICES\n")
        for a, b, c in indices:
            f.write(CARDS.CARD_UNSTR3.format(a, b, c))
        if NORM == 1 or NORM == 2:
            # CARD UNSTR4 (if NORM=1 or NORM=2)
            pass


# TODO RvD: __icon__
class TipPatch(StructuredPatch):
    """Not implemented yet."""
    pass


# TODO: work with kwside like in SPC?
class PanelNormalRotation(VSAEROBase):
    """Class encapsulating information to rotate panels normals. Used in a
    trailing edge movable research project. It is useful to rotate panels
    without actually changing the geometry. See CARD SET 8K.
    """

    #: :type: StructuredPatch
    patch = Input()
    #: Rotation angle in **degrees*.
    #: :type: float
    angle = Input()
    #: Vector of rotation. Default 0, 1, 0 in Global Coordinate System.
    #: :type: Vector
    vector = Input(Vector(0, 1, 0))
    #: index of first row (starting at 0)
    #: :type: int
    row1 = Input(0)
    #: index of last row (starting at 0), default -1 (last)
    #: :type: int
    row2 = Input(-1)
    #: index of first column (starting at 0)
    #: :type: int
    col1 = Input(0)
    #: index of last column (starting at 0), default -1 (last)
    #: :type: int
    col2 = Input(-1)
    #: color for direct, numeric station.
    #: :type: str
    panel_color = Input("GREEN")

    @Attribute
    def nrot_values(self):
        arr = self.patch.sections
        row1, row2, col1, col2 = self.row1, self.row2, self.col1, self.col2
        if row1 == -1:
            nrotrf = len(arr[0])
        else:
            nrotrf = row1 + 1
        if row2 == -1:
            nrotrl = len(arr[0])
        else:
            nrotrl = row2 + 1
        if col1 == -1:
            nrotcf = len(arr[0])
        else:
            nrotcf = col1 + 1
        if col2 == -1:
            nrotcl = len(arr[0])
        else:
            nrotcl = col2 + 1
        return nrotrf, nrotrl, nrotcf, nrotcl

    @Attribute
    def points_per_panel(self):
        arr = self.patch.points_per_panel
        row1, row2, col1, col2 = self.row1, self.row2, self.col1, self.col2
        if row1 == -1:
            row1 = len(arr[0]) - 1
        if row2 == -1:
            row2 = len(arr[0]) - 1
        if col1 == -1:
            col1 = len(arr) - 1
        if col2 == -1:
            col2 = len(arr) - 1
        return [lst[row1:row2 + 1] for lst in arr[col1:col2 + 1]]

    @Part
    def panels(self):
        return PanelFace(quantify=(len(self.points_per_panel) - 1,
                                   len(self.points_per_panel[
                                           0]) - 1),
                         points=self.points_per_panel
                         [child.index[0]][child.index[1]],
                         color=self.panel_color)

    def write(self, f=sys.stdout):
        kwpch = self.patch.KWPCH
        nrotrf, nrotrl, nrotcf, nrotcl = self.nrot_values
        delta = self.angle
        hx, hy, hz = self.vector
        f.write("CARD 8K: PANEL NORMAL ROTATIONS\n")
        f.write(CARDS.CARD8K.format(kwpch, nrotrf, nrotrl, nrotcf, nrotcl,
                                    delta, hx, hy, hz))

    def write_shedding_panel_specification(self, KWPCH, NODEWS=0,
                                           f=sys.stdout):
        KWSIDE, KWLINE = self.KWSIDE, self.KWLINE
        KWPAN1, KWPAN2 = self.KWPAN1, self.KWPAN2
        INPUT, IFLXL = self.INPUT, self.IFLXL
        DTHET, XFLEX = self.DTHET, self.XFLEX
        f.write("CARD 20: SHEDDING PANEL SPECIFICATION\n")
        f.write(CARDS.CARD20.format(KWPCH, KWSIDE, KWLINE, KWPAN1, KWPAN2,
                                    INPUT, NODEWS, "", IFLXL, DTHET, XFLEX))


# TODO RvD: describe mark
# TODO RvD: __icon__
class XInterval(VSAEROBase):
    """An XInterval defines (:attr:`spaces` - 1) interpolated x-stations
    between two numerically defined stations with a given :attr:`distribution`.
    For 4 new stations (or 5 spaces) with a full-cosine distribution:

    >>> XInterval(spaces=5, distribution=0, mark=0)
    """

    __initargs__ = ("spaces", "distribution", "mark")

    #: n spaces interpolated between previous and next x-station.
    #: :type: int
    spaces = Input()

    #: interpolation type (NPC of CARD 18, see VSAERO manual).
    #:
    #: 0. Full cosine spacing: smaller spacing near both nodes than in middle
    #: 1. Half-cosine spacing: smaller spacing near preceding station
    #: 2. Half-cosine spacing: smaller spacing near next station
    #: 3. Equal spaces between nodes
    #: 4. Prop/fan spacing; :attr:`spaces` is the number of grid planes per
    #:     revolution, and has a default of 24.
    #:
    #: :type: int
    distribution = Input(3)

    #: Check MARK of CARD 18, see VSAERO manual.
    #: :type: int
    mark = Input(0)


# TODO RvD: __icon__
class NInterval(VSAEROBase):
    """An NInterval defines (:attr:`spaces` - 1) interpolated wake line nodes
    placed within a set of points in order to generate additional points along
    a curved line with :attr:`continuous` (True) or discontinuous (False)
    slope onto the next region. An NInterval typically follows a set of
    at least 2 user-defined Points. For continuous 4 nodes (or 5 spaces) with a
    full-cosine distribution:

    >>> NInterval(continuous=True, spaces=5, distribution=0)
    """
    __initargs__ = ("continuous", "spaces", "distribution")

    #: Optional intermediate node placed within a set of points in order to
    #: generate additional points along a curved line with continuous (True)
    #: or discontinuous (False) slope onto the next region
    #: :type: bool
    continuous = Input()

    #: n spaces interpolated between previous and next wake line points.
    #: :type: int
    spaces = Input()

    #: distribution type (NPC of CARD 22, see VSAERO manual).
    #:
    #: 0. Full cosine spacing: smaller spaces near both nodes than the middle
    #: 1. Half-cosine spacing: smaller spaces near the preceding node
    #: 2. Half-cosine spacing: smaller spaces near this node
    #: 3. Equal spaces between nodes (default)
    #:
    #: :type: int
    distribution = Input(3)


class WakeAssembly(VSAEROBase):
    """A WakeAssembly consists of several :class:`Wake` instances
    :attr:`wakes` and a sequence of wake grid planes :attr:`x_stations` common
    to all wakes.

    >>> wake1 = Wake(label="left wake")
    >>> wake2 = Wake(label="right wake")
    >>> lst = [[32.6091, 37.1280, 39.4951, 41.7979, 43.9407, 45.7562, 47.0230],
    ...        XInterval(5, 1, 1),
    ...        75.0000,
    ...        XInterval(2, 3),
    ...        500.0000]
    >>> assy = WakeAssembly(x_stations=lst,
    ...                     wakes=[wake1, wake2])
    """

    #: :type: collections.Sequence[Wake]
    wakes = Input(in_tree=True)

    #: x-stations of all wake grid planes. A valid x-station specification is:
    #:
    #: 1. a float, e.g. ``13.75``.
    #: 2. a sequence of floats, e.g. ``[13.75, 14.25, 14.75]``.
    #: 3. a :class:`XInterval` instance.
    #:
    #: .. note:: The last wake grid plane should be approximately 10 wingspans
    #:     or 100 chords, whichever is less, downstream of the wing TE.
    #:
    #: :type: collections.Sequence[float | collections.Sequence[float] | XInterval]
    x_stations = Input()

    #: normal vector of grid planes for visualization. Default: global x-axis.
    #: :type: Vector
    x_normal = Input(Vector(1, 0, 0))

    #: dimension of grid Plane instance for visualization.
    #: :type: float
    x_dim = Input(1)

    #: color for direct, numeric station.
    #: :type: str
    x_color = Input("GREEN")

    #: color for interpolated stations, as result of :class:`XInterval` specs.
    #: :type: str
    x_color_interval = Input("RED")

    @Part
    def grid_planes(self):
        return Plane(quantify=len(self._x_floats),
                     reference=Point(self._x_floats[child.index][0], 0, 0),
                     normal=self.x_normal,
                     v_dim=self.x_dim,
                     color=(self.x_color if self._x_floats[child.index][1]
                            else self.x_color_interval))

    @Attribute
    def x_floats(self):
        """Convert :attr:`x_stations` to a list of floats.

        :rtype: list[float]
        """
        return [x for x, _ in self._x_floats]

    @Attribute
    def _x_floats(self):
        """Convert :attr:`x_stations` to a list of (float, bool) pairs. Float
        is the x-value of the station, bool is True for explicit/numeric
        stations, True for interpolated stations (derived from XInterval
        specs).

        :rtype: list[(float, bool)]
        """
        xlst = []
        prev = None
        it = iter(self.x_stations)

        while True:
            try:
                x = next(it)
            except StopIteration:
                break

            if isinstance(x, (float, int)):
                xlst.append((x, True))
                prev = x

            elif (hasattr(x, "__iter__") and x and  # checks empty sequence
                  all(isinstance(y, (float, int)) for y in x)):
                for x_ in x:
                    xlst.append((x_, True))
                prev = x[-1]

            elif isinstance(x, XInterval):
                if prev is None:
                    msg = ("The first x_station can not be an XInterval, "
                           "but should be of type float.")
                    raise RuntimeError(msg)
                elif isinstance(prev, XInterval):
                    msg = "An XInterval can not follow another XInterval."
                    raise RuntimeError(msg)

                try:
                    xn = next(it)
                except StopIteration:
                    msg = ("The last x_station can not be an XInterval, "
                           "but should be a (sequence of) float.")
                    raise RuntimeError(msg)
                else:
                    if isinstance(xn, (float, int)):
                        pass
                    elif (hasattr(xn, "__iter__") and xn and
                              all(isinstance(y, (float, int)) for y in xn)):
                        if len(xn) > 1:
                            it = itertools.chain([xn[1:]], it)
                        xn = xn[0]
                    elif isinstance(xn, XInterval):
                        msg = ("An XInterval can not be directly followed by "
                               "another XInterval.")
                        raise RuntimeError(msg)
                    else:
                        msg = ("a valid x_station is either a (sequence of) "
                               "float or XInterval, not {:}.")
                        raise RuntimeError(msg.format(repr(xn)))

                    npc, intc, mark = x.spaces, x.distribution, x.mark or ""

                    # Full cosine spacing: smaller spacing near both nodes
                    # than in middle
                    if intc == 0:
                        xlst_int = full_cosine(npc, L1=prev, L2=xn)
                    # Half-cosine spacing: smaller spacing near preceding
                    # station
                    elif intc == 1:
                        xlst_int = cosine(npc, L1=prev, L2=xn)
                    # Half-cosine spacing: smaller spacing near next station
                    elif intc == 2:
                        xlst_int = cosine(npc, theta1=90, theta2=180,
                                          L1=prev, L2=xn)
                    # Equal spaces between nodes
                    elif intc == 3:
                        xlst_int = list_of_numbers(prev, xn, npc + 1)
                    # Prop/fan spacing; npc is the number of grid planes per
                    # revolution, and has a default of 24.
                    elif intc == 4:
                        msg = "intc == 4 is not supported yet."
                        raise NotImplementedError(msg)
                    else:
                        msg = "intc in range [0-4], not {:}"
                        raise RuntimeError(msg.format(repr(intc)))
                    for x_ in xlst_int[1:-1]:
                        xlst.append((x_, False))
                    xlst.append((xn, True))
            else:
                msg = ("a valid x_station is either a (sequence of) float or "
                       "XInterval, not {:}.")
                raise RuntimeError(msg.format(repr(x)))
        return xlst

    def write(self, f=sys.stdout):
        self.write_grid_planes(f=f)

        # wake is type Wake and composes multiple WakePatch objects
        for wake_number, wake in enumerate(self.wakes):
            wake.write(wake_number + 1, f=f)

        # Closing CARD 19
        f.write("CARD19 END\n")
        identw, iflexw, ncomp, wname = 0, 0, 0, "END OF WAKE"
        f.write(CARDS.CARD19.format(identw, iflexw, ncomp, wname))

    def write_grid_planes(self, f=sys.stdout):

        xlst = []
        prev = None
        flush = True
        it = iter(self.x_stations)

        while True:
            try:
                x = next(it)
            except StopIteration:
                break

            if isinstance(x, (float, int)):
                xlst.append(x)
                prev = x

            elif (hasattr(x, "__iter__") and x and  # checks empty sequence
                  all(isinstance(y, (float, int)) for y in x)):
                xlst.extend(x)
                prev = x[-1]

            elif isinstance(x, XInterval):
                if prev is None:
                    msg = ("The first x_station can not be an XInterval, "
                           "but should be a (sequence of) float.")
                    raise RuntimeError(msg)
                elif isinstance(prev, XInterval):
                    msg = "An XInterval can not follow another XInterval."
                    raise RuntimeError(msg)

                try:
                    xn = next(it)
                except StopIteration:
                    msg = ("The last x_station can not be an XInterval, "
                           "but should be a (sequence of) float.")
                    raise RuntimeError(msg)
                else:
                    if isinstance(xn, (float, int)):
                        pass
                    elif (hasattr(xn, "__iter__") and xn and
                              all(isinstance(y, (float, int)) for y in xn)):
                        if len(xn) > 1:
                            it = itertools.chain([xn[1:]], it)
                        xn = xn[0]
                    elif isinstance(xn, XInterval):
                        msg = ("An XInterval can not be directly followed by "
                               "another XInterval.")
                        raise RuntimeError(msg)
                    else:
                        msg = ("a valid x_station is either a (sequence of) "
                               "float or XInterval, not {:}.")
                        raise RuntimeError(msg.format(repr(xn)))

                f.write("CARD 17: WAKE GRID PLANE\n")
                for xf in xlst:
                    f.write(fmt_real(xf) + "\n")
                if len(xlst) > 1:
                    f.write("CARD 18: GRID PLANE NODE CARD\n")
                    NODE, NPC, INTC, MARK = 2, 0, 0, ""
                    f.write(CARDS.CARD18.format(NODE, NPC, INTC, MARK))
                    f.write("CARD 17: WAKE GRID PLANE\n")
                f.write(fmt_real(xn) + "\n")

                # peek one ahead
                try:
                    peek = next(it)
                except StopIteration:
                    NODE = 3
                    flush = False  # end
                else:
                    NODE = 2
                    it = itertools.chain([peek], it)  # restore iterator

                NPC, INTC, MARK = x.spaces, x.distribution, x.mark or ""
                f.write("CARD 18: GRID PLANE NODE CARD\n")
                f.write(CARDS.CARD18.format(NODE, NPC, INTC, MARK))

                xlst[:] = []

            else:
                msg = ("a valid x_station is either a (sequence of) float or "
                       "XInterval, not {:}.")
                raise RuntimeError(msg.format(repr(x)))

        if flush:
            f.write("CARD 17: WAKE GRID PLANE\n")
            for xf in xlst:
                f.write(fmt_real(xf) + "\n")
            f.write("CARD 18: GRID PLANE NODE CARD\n")
            NODE, NPC, INTC, MARK = 3, 0, 0, ""
            f.write(CARDS.CARD18.format(NODE, NPC, INTC, MARK))


# TODO RvD: __icon__
class Wake(VSAEROBase):
    """Wake attached to a StructuredPatch."""

    #: Name for this Wake. Corresponds to WNAME of CARD 19, see VSAERO manual.
    #: :type: str
    label = Input("")
    #: iterable of Wake Shedding Panel Specifications.
    #: :type: collections.Sequence[SPC]
    specs = Input(in_tree=True)
    #: Type of wake, see Fig. 3.41 in VSAERO manual. Defaults to 1 (Equal
    #: total pressure (open separation) wake).
    #: .. note:: for now only 1 is supported.
    #: :type: int
    IDENTW = Input(1)
    #: Wake flexibility. Default 0 means entirely flexible, >0 means rigid up
    #: to wake grid plane :attr:`IFLEXW`.
    #: :type: int
    IFLEXW = Input(0)
    #: Component transformation to be applied to wake. Default is 0
    #: (No transformation).
    #: :type: int
    NCOMP = Input(0)
    #: Tangential velocity on the inside of the wake. Used for closed wakes
    #: (:attr:``IDENTW` = 4 through 8). See CARD 23 in VSAERO Manual.
    #: :type: float
    VIN = Input(0)
    #: Tangential velocity on the outside of the wake. Used for closed wakes
    #: (:attr:``IDENTW` = 4 through 8). See CARD 23 in VSAERO Manual.
    #: :type: float
    VOUT = Input(1)
    #: color of wakesheet
    #: :type: str | (float, float, float)
    sheet_color = Input("purple")

    @Attribute
    def wake_lines(self):
        specs = self.specs
        wires = []
        for spec in specs:
            wires.append(spec.wire)
            wires.extend((s.wires[0] for s in spec.wire_offsets[:-1]))
        wires.append(specs[-1].wire_offsets[-1].wires[0])
        return wires

    @Part
    def wake_sheet(self):
        return RuledShell(profiles=self.wake_lines,
                          color=self.sheet_color)

    # wake_number comes from WakeAssembly
    def write(self, wake_number=1, f=sys.stdout):
        label = self.label
        identw = self.IDENTW
        iflexw = self.IFLEXW
        ncomp = self.NCOMP

        if label:
            WNAME = label + " (WAKE: {:d})".format(wake_number)
        else:
            WNAME = "(WAKE: {:d})".format(wake_number)

        # First CARD 19
        f.write("CARD 19: WAKE CARD\n")
        f.write(CARDS.CARD19.format(identw, iflexw, ncomp, WNAME))

        # CARD20-22
        specs = self.specs
        for spec in specs:
            spec.write(f=f)

        last_spec = specs[-1]
        if last_spec.NODEWS != 3:
            # finish with closing CARD 20
            NODEWS = 3
            KWPCH = ""
            KWSIDE, KWLINE = "", ""
            KWPAN1, KWPAN2 = "", ""
            INPUT, IFLXL = 0, 0
            DTHET, XFLEX = "", ""
            f.write("CARD 20: SHEDDING PANEL SPECIFICATION\n")
            f.write(CARDS.CARD20.format(
                KWPCH, KWSIDE, KWLINE, KWPAN1, KWPAN2, INPUT, NODEWS, "",
                IFLXL, DTHET, XFLEX))

        # close with CARD 23 for closed separation wake.
        if identw in {4, 6, 7, 8}:
            if identw == 6:
                msg = ("IDENTW = 6 requires CARD 23A, not implemented yet. "
                       "Contact ParaPy suppor team.")
                raise NotImplementedError(msg)
            VIN, VOUT = self.VIN, self.VOUT
            f.write("CARD 23: JET WAKE VELOCITIES\n")
            f.write(CARDS.CARD23.format(VIN, VOUT))


class PropellorWake(Wake):
    """Not implemented yet"""

    #: Propeller wake
    #: :type: int
    IDENTW = Attribute(5)

    def __init__(self, *args, **kwargs):
        raise NotImplementedError("PropellorWake isn't implemented yet.")
        super(PropellorWake, self).__init__(*args, **kwargs)


# TODO RvD: __icon__
class SPC(VSAEROBase):
    """Wake shedding panel specification. Usage:

    >>> arr = []
    ... for i in range(0, 10):
    ...     lst = []
    ...     for j in range(5, -1, -1):
    ...         lst.append(Point(i, j, 0))
    ...     arr.append(lst)
    ... 
    >>> p = StructuredPatch(label="MyStructuredPatch", sections=arr)
    >>> s1 = SPC(patch=p, KWSIDE=2, KWLINE=2, KWPAN1=1, KWPAN2=2, nodes=[])
    >>> s2 = SPC(patch=p, KWSIDE=1, KWLINE=3, KWPAN1=3, KWPAN2=4, nodes=[])
    >>> s3 = SPC(patch=p, KWSIDE=2, KWLINE=4, KWPAN1=3, KWPAN2=5, nodes=[])
    >>> s4 = SPC(patch=p, KWSIDE=1, KWLINE=6, KWPAN1=5, KWPAN2=5, nodes=[])
    >>> s5 = SPC(patch=p, KWSIDE=2, KWLINE=5, KWPAN1=6, KWPAN2=9, nodes=[])
    >>> s6 = SPC(patch=p, KWSIDE=3, KWLINE=9, KWPAN1=1, KWPAN2=4, nodes=[])
    >>> s7 = SPC(patch=p, KWSIDE=4, KWLINE=2, KWPAN1=1, KWPAN2=3, nodes=[])
    """
    #: Patch to which wake is attached.
    #: :type: Patch
    patch = Input()
    #: Wake line nodes, either a (sequence of) Point or an :class:`NInterval`.
    #: :type: collections.Sequence[Point | collections.Sequence[Point] | NInterval]
    nodes = Input()
    #: Python index of first panel in the wake-shedding panel string. Default
    #: is 0, i.e. the first panel in the corresponding row/column. This input
    #: will define the value of :attr:`KWPAN1`, but is not the same! If you'd
    #: like to stay closer to VSAERO lingo, specify :attr:`KWPAN1` directly.
    #: :type: int
    idx1 = Input(0)
    #: Python index of last panel in the wake-shedding panel string. Default
    #: is -1, i.e. the last panel in the corresponding row/column. This input
    #: will define the value of :attr:`KWPAN2`, but is not the same! If you'd
    #: like to stay closer to VSAERO lingo, specify :attr:`KWPAN1` directly.
    #: :type: int
    idx2 = Input(-1)
    #: See CARD 20 in VSAERO manual. Default defined by :attr:`idx1`.
    #: :type: int
    KWPAN1 = Input(derived)
    #: See CARD 20 in VSAERO manual. Default defined by :attr:`idx1`.
    #: :type: int
    KWPAN2 = Input(derived)
    #: Patch side parallel to the direction of the string [1-4].
    #: :type: int
    KWSIDE = Input()
    #: If 0, Separation is from the patch edge.
    #: :type: int
    KWLINE = Input(0)
    #: :type: int
    INPUT = Input(4)
    #: 0 if first or intermediate spc on wake. 3 to complete a wake.
    #: if you don't specify a closing 3 input, the :class:`Wake` class will
    #: close the wake automatically for you. You typically use 3 for a
    #: wing-fuselag stitching line.
    #: :type: int
    NODEWS = Input(0)
    #: See CARD 20 in VSAERO manual.
    #: :type: int
    IFLXL = Input(0)
    #: See CARD 20 in VSAERO manual.
    #: :type: int
    DTHET = Input(0)
    #: See CARD 20 in VSAERO manual.
    #: :type: float
    XFLEX = Input(0)

    #: FittedCurve.max_degree for fitting wake lines through nodes.
    #: :type: int
    max_degree = Input(3)
    #: color for direct, numeric station.
    #: :type: str
    point_color = Input("GREEN")
    #: color for interpolated stations, as result of :class:`NInterval` specs.
    #: :type: str
    point_color_interval = Input("RED")
    #: color for direct, numeric station.
    #: :type: str
    panel_color = Input("GREEN")

    @Attribute
    def points(self):
        """Converts :attr:`nodes` into a list of Points for the entire
        wakeline.

        :rtype: list[Point]
        """
        return [pt for pt, _ in self._points]

    @Attribute
    def points_per_section(self):
        """Converts :attr:`nodes` into lists of Points per continuous wake
        line section with a bool stating whether it was a direct user input or
        interpolated Point. Consecutive sections connect discontinuously.

        :rtype: list[list[Point]]
        """
        return [[pt for pt, _ in points]
                    for points in self._points_per_section]

    @Attribute
    def _points(self):
        """Converts :attr:`nodes` into a list of Points for the entire
        wakeline with a bool stating whether it was a direct user input or
        interpolated Point.

        :rtype: list[(Point, bool)]
        """
        lst = []
        first = True
        for section in self._points_per_section:
            if first:
                lst.extend(section)
            else:
                lst.extend(section[1:])
            first = False
        return lst

    @Attribute
    def _points_per_section(self):
        """Converts :attr:`nodes` into lists of Points per continuous wake
        line section with a bool stating whether it was a direct user input or
        interpolated Point. Consecutive sections connect discontinuously.

        :rtype: list[list[(Point, bool)]]
        """
        sections = []
        section = []
        prev = None
        stack = list(self.nodes)

        while stack:
            node = stack.pop(0)

            if isinstance(node, Point):
                section.append((node, True))
                prev = node

            elif (hasattr(node, "__iter__") and node and  # empty sequence
                      all(isinstance(y, Point) for y in node)):
                for node_ in node:
                    section.append((node_, True))
                prev = node[-1]

            elif isinstance(node, NInterval):
                if prev is None:
                    msg = ("The first wake line node can not be an NInterval, "
                           "but should be a (sequence of) Point.")
                    raise RuntimeError(msg)
                elif isinstance(prev, NInterval):
                    msg = "An NInterval can not follow another NInterval."
                    raise RuntimeError(msg)

                cont, npc, intc = node.continuous, node.spaces, node.distribution

                if npc > 0 and len(section) < 2:
                    msg = ("An NInterval with 1 or more spaces should "
                           "follow after a section of at least two "
                           "Points, only 1 Point found.")
                    raise RuntimeError(msg)

                if npc > 0:
                    # interpolate between last two points
                    (pt1, _), (pt2, _) = section[-2:]

                    # Full cosine spacing: smaller spaces near both nodes
                    if intc == 0:
                        fracs = full_cosine(npc)
                    # Half-cosine spacing: smaller spaces near preceding node
                    elif intc == 1:
                        fracs = cosine(npc)
                    # Half-cosine spacing: smaller spaces near this node
                    elif intc == 2:
                        fracs = cosine(npc, theta1=90, theta2=180)
                    # Equal spaces between nodes
                    elif intc == 3:
                        fracs = list_of_numbers(0, 1, npc + 1)
                    else:
                        msg = "intc in range [0-3], not {:}"
                        raise RuntimeError(msg.format(repr(intc)))
                    nodes_int = [Point.interpolate(pt1, pt2, f)
                                 for f in fracs[1:-1]]
                    for node_ in nodes_int:
                        section.insert(-1, (node_, False))
                if not cont:
                    # start a new section
                    sections.append(section)
                    section = section[-1:]

                prev = node

            else:
                msg = ("a valid wake line node is either a (sequence of) "
                       "Point or NInterval, not {:}.")
                raise RuntimeError(msg.format(repr(node)))

        # if isinstance(prev, NInterval):
        #     msg = ("The last wake line node can not be an NInterval, "
        #            "but should be a (sequence of) Point.")
        #     raise RuntimeError(msg)

        sections.append(section)
        return sections

    @Attribute
    def points_per_panel_fullspan(self):
        """Return corner points of entire string of panels in the
        wake-shedding *string*. Not bounded by KWPAN.

        :rtype: list[list[(Point, Point, Point, Point)]]
        """
        panels = self.patch.points_per_panel
        side, line = self.KWSIDE, self.KWLINE
        if line != 0:
            line -= 1
        elif side == 2 or side == 3:
            line = -1
        if side == 1:
            return panels[line]
        elif side == 2:
            return transpose(panels)[line]
        elif side == 3:
            return list(reversed(panels[line]))
        elif side == 4:
            return list(reversed(transpose(panels)[line]))
        else:
            msg = "KWSIDE not in range [1-4], but {}"
            raise RuntimeError(msg.format(repr(side)))

    @KWPAN1.getter
    def KWPAN1(self):
        """Return KWPAN1 value for .IN file.

        :rtype: int
        """
        idx = self.idx1
        n = len(self.points_per_panel_fullspan)
        if idx >= 0:
            kwpan = idx + 1
            if kwpan > n:
                msg = ("First panel index KWPAN1 ({}) is larger than total "
                       "number of panels in row/column ({}).")
                raise RuntimeError(msg.format(kwpan, n))
        else:  # negative index
            kwpan = n + idx + 1
            if kwpan <= 0:
                msg = ("First panel index idx1 ({}) value is too negative, "
                       "number of panels in row/column ({}).")
                raise RuntimeError(msg.format(idx, n))
        return kwpan

    @KWPAN2.getter
    def KWPAN2(self):
        """Return KWPAN2 value for .IN file.

        :rtype: int
        """
        idx = self.idx2
        n = len(self.points_per_panel_fullspan)
        if idx >= 0:
            kwpan = idx + 1
            if kwpan > n:
                msg = ("Last panel index KWPAN2 ({}) is larger than total "
                       "number of panels in row/column ({}).")
                raise RuntimeError(msg.format(kwpan, n))
        else:  # negative index
            kwpan = n + idx + 1
            if kwpan <= 0:
                msg = ("Last panel index idx2 ({}) value is too negative, "
                       "number of panels in row/column ({}).")
                raise RuntimeError(msg.format(idx, n))
        return kwpan

    @Attribute
    def points_per_panel(self):
        """Return corner points of all wake-shedding panels.

        :rtype: list[list[(Point, Point, Point, Point)]]
        """
        if self.NODEWS == 3:  # closing wake-line (e.g. stitching line)
            return []
        else:
            panels = self.points_per_panel_fullspan
            kwpan1, kwpan2 = self.KWPAN1, self.KWPAN2
            if kwpan1 == 0:
                if kwpan2 != 0:
                    msg = "KWPAN1 can only equal 0, if KWPAN2 is 0."
                    raise RuntimeError(msg)
                i1 = 0
            else:
                i1 = kwpan1 - 1
            if kwpan2 == 0:
                i2 = len(panels)
            else:
                i2 = kwpan2
            return panels[i1:i2]

    @Attribute
    def shedding_points(self):
        """Returns all 3D points from which a wake is shed.

        :rtype: list[Point]
        """
        if self.NODEWS == 3:  # closing wake-line (e.g. stitching line)
            return self.points[0:1]
        else:
            arr = self.points_per_panel
            side = self.KWSIDE
            idx1 = side - 1
            idx2 = 0 if side == 4 else idx1 + 1
            lst = [pts[idx2] for pts in arr]
            lst.insert(0, arr[0][idx1])
            return lst

    @Part
    def panels(self):
        return PanelFace(quantify=len(self.points_per_panel),
                         points=self.points_per_panel[child.index],
                         color=self.panel_color)

    @Part
    def vertices(self):
        return Vertex(quantify=len(self._points),
                      point=self._points[child.index][0],
                      color=(self.point_color if self._points[child.index][1]
                             else self.point_color_interval))

    @Part
    def sections(self):
        return FittedCurve(quantify=len(self.points_per_section),
                           suppress=not self.points,
                           pass_down="max_degree",
                           points=self.points_per_section[child.index])

    @Part
    def wire(self):
        return Wire(curves_in=self.sections,
                    suppress=not self.points)

    @Part
    def wire_offsets(self):
        return TranslatedShape(quantify=len(self.shedding_points) - 1,
                               suppress=not self.points,
                               shape_in=self.wire,
                               displacement=(
                               self.shedding_points[child.index + 1] -
                               self.shedding_points[0]))

    # last comes from Wake instance
    def write(self, f=sys.stdout):
        KWPCH = self.patch.KWPCH
        self.write_shedding_panel_specification(KWPCH, f=f)
        self.write_wake_line_points(f=f)

    def write_shedding_panel_specification(self, KWPCH, f=sys.stdout):
        NODEWS = self.NODEWS
        if NODEWS == 3:
            # most input are not active on this card
            KWPCH = ""
            KWSIDE, KWLINE = "", ""
            KWPAN1, KWPAN2 = "", ""
        else:
            KWSIDE, KWLINE = self.KWSIDE, self.KWLINE
            KWPAN1, KWPAN2 = self.KWPAN1, self.KWPAN2
        INPUT, IFLXL = self.INPUT, self.IFLXL
        DTHET, XFLEX = self.DTHET, self.XFLEX

        f.write("CARD 20: SHEDDING PANEL SPECIFICATION\n")
        f.write(CARDS.CARD20.format(
            KWPCH, KWSIDE, KWLINE, KWPAN1, KWPAN2, INPUT, NODEWS, "",
            IFLXL, DTHET, XFLEX))

    def write_wake_line_points(self, f=sys.stdout):
        section = []
        point_mode = False
        interval_mode = False
        closed = False
        stack = list(self.nodes)
        while stack:
            node = stack.pop(0)

            if isinstance(node, Point):
                if not point_mode:
                    f.write("CARD 21D: STREAMWISE WAKE LINE POINTS\n")
                f.write(CARD20D_format(*node))
                section.append(node)
                point_mode, interval_mode = True, False

            elif (hasattr(node, "__iter__") and node and  # checks empty seq
                      all(isinstance(y, Point) for y in node)):
                if not point_mode:
                    f.write("CARD 21D: STREAMWISE WAKE LINE POINTS\n")
                for node_ in node:
                    f.write(CARD20D_format(*node_))
                    section.append(node_)
                point_mode, interval_mode = True, False

            elif isinstance(node, NInterval):
                if point_mode:
                    f.write("CARD 22: WAKE LINE NODE CARD\n")
                    nodewc = 1 if node.continuous else 2
                    if not stack:
                        nodewc = 3
                        closed = True
                    npc = node.spaces
                    intc = node.distribution
                    if npc > 0 and len(section) < 2:
                        msg = ("An NInterval with 1 or more spaces should "
                               "follow after a section of at least two "
                               "Points, only 1 Point found.")
                        raise RuntimeError(msg)
                    f.write(CARDS.CARD22.format(nodewc, npc, intc))
                    if nodewc == 2:
                        section[:-1] = []
                    point_mode, interval_mode = False, True

                elif interval_mode:
                    msg = "An NInterval can not follow another NInterval."
                    raise RuntimeError(msg)

                else:
                    msg = ("The first wake line node can not be an NInterval, "
                           "but should be a (sequence of) Point.")
                    raise RuntimeError(msg)

            else:
                msg = ("a valid wake line node is either a (sequence of) "
                       "Point or NInterval, not {:}.")
                raise RuntimeError(msg.format(repr(node)))

        # if interval_mode and not closed:
        #     msg = ("The last wake line node can not be an NInterval, "
        #            "but should be a (sequence of) Point.")
        #     raise RuntimeError(msg)

        if not closed:
            # CARD 22 to close wake line
            nodewc, npc, intc = 3, 0, 0
            f.write("CARD 22: WAKE LINE NODE CARD\n")
            f.write(CARDS.CARD22.format(nodewc, npc, intc))


# TODO RvD: __icon__
class Streamline(VSAEROBase):
    pass


# TODO RvD: __icon__
class StreamlineStationCut(Streamline):
    """Streamlines will be created for all panels cut by x-station."""

    #: x-coordinate of plane
    #: :type: float
    x_station = Input()
    #: Station cut option. Every panel cut by X=F will have a streamline.
    #: :type: int
    KP = Input(-1)
    #: side of panel (1-4), 0: VSAERO selects.
    #: :type: int
    NS = Input(0)
    #: station cut option.
    KPCH = Input(0)
    #: Boundary Layer Analysis Option
    #: :type: int
    ISLRST = Input(0)
    #: Shape factor for turbulent boundary layer starts
    #: :type: float
    HTURB = Input(0.0)
    #: Reynolds number based on momentum thickness for non-stagnation boundary
    #: layer starts
    #: :type: float
    RTHETA = Input(0.0)
    #: Trace upstream and downstream
    #: :type: float
    XSTRT = Input(0.0)

    #: normal vector of grid planes for visualization. Default: global x-axis.
    #: :type: Vector
    x_normal = Input(Vector(1, 0, 0))
    #: dimension of grid Plane instance for visualization.
    #: :type: float
    x_dim = Input(1)
    #: color for direct, numeric station.
    #: :type: str
    x_color = Input("GREEN")

    @Part
    def plane(self):
        return Plane(reference=Point(self.x_station, 0, 0),
                     normal=self.x_normal,
                     v_dim=self.x_dim,
                     color=self.x_color)

    def write(self, f=sys.stdout):
        f.write("CARD 24B: STREAMLINE STARTING POINTS (Station Cut Option)\n")
        f.write(CARD24B_format(self.x_station, self.KP, self.NS, self.KPCH,
                               self.ISLRST, self.HTURB, self.RTHETA, self.XSTRT))
        # f.write(CARDS.CARD24B.format(self.x_station, self.KP, self.NS,
        #                              self.KPCH, "", "", "", "", self.ISLRST,
        #                              self.HTURB, self.RTHETA, self.XSTRT))


if __name__ == '__main__':
    section1 = Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0)
    section2 = Point(0, 1, 0), Point(1, 1, 0), Point(2, 1, 0)
    section3 = Point(0, 2, 0), Point(1, 2, 0), Point(2, 2, 0)
    patch1 = StructuredPatch(label="MyStructuredPatch",
                             sections=[section1, section2, section3])
    patch1.write(KOMP=1, patch_number=1)

    pts = [Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0), Point(1, 1, 0)]
    tri1 = [1, 2, 3]
    tri2 = [2, 4, 3]
    patch2 = UnstructuredPatch(label="MyUnstructuredPatch",
                               points=pts,
                               indices=[tri1, tri2])
    patch2.write(KOMP=1, patch_number=2)
    component = Component(label="MyComponent",
                          patches=[patch1, patch2])
    component.write(KOMP=1)

    wake1 = Wake(label="left wake")
    wake2 = Wake(label="right wake")
    assy = WakeAssembly(x_stations=[32.6091,
                                    37.1280,
                                    39.4951,
                                    41.7979,
                                    43.9407,
                                    45.7562,
                                    47.0230,
                                    XInterval(5, 1, 1),
                                    75.0000,
                                    XInterval(2, 3),
                                    500.0000
                                    ],
                        wakes=[wake1, wake2])

    assy.write_grid_planes()

    assy = WakeAssembly(x_stations=[32.6091,
                                    37.1280,
                                    39.4951,
                                    41.7979,
                                    43.9407,
                                    45.7562,
                                    47.0230,
                                    XInterval(5, 1, 1),
                                    75.0000,
                                    XInterval(2, 3),
                                    500.0000
                                    ],
                        wakes=[wake1, wake2])

    assy.write_grid_planes()

    nodes = [[Point(0, 0, 0), Point(1, 2, 0)],
             NInterval(continuous=False, spaces=10, distribution=1),
             Point(7, 0, 0)]
    spec = SPC(patch=patch1, KWSIDE=4, nodes=nodes)
    spec.write_shedding_panel_specification(1)
    spec.write_wake_line_points()

    wake = Wake(label="My Wake", shedding_panel_specifications=[spec])
    patch1.KWPCH = 1
    wake.write()

    from parapy.gui import display

    display((component, assy, wake))


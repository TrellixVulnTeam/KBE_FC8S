#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""The GeomBase class adds a position (location and orientation) to objects and
an compositional inheritance mechanism, i.e. position objects are inherited by
children unless overridden in Part specs.
"""

import os
import warnings

from parapy.core import Attribute, Base, HiddenPart, Input, Part, getattrs
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.generic.functions import translate
from parapy.geom.generic.positioning import Point, Position, XOY, XY
from parapy.geom.generic.utilities import key_to_axis, key_to_dim
from parapy.geom.globs import ICN_DIR
from parapy.utilities import deprecated


class GeomBase(Base):
    """Base class for all geometry primitives. Inherit this class instead of
    Base for ease of positioning, etc. GeomBase adds a position (i.e. a
    location and an orientation) to objects and an imaginary reference box.
    The slots :attr:`position`, :attr:`location` and :attr:`orientation` are
    ``defaulting``, viz. their value are *inherited* from the parent object
    (if any), unless you specify a different value, for example through
    relative or absolute positioning statements.
    
    You can use GeomBase objects for relative positioning of other objects.
    For example:

    >>> from parapy.geom import Box, GeomBase, translate, rotate90
    ...
    >>> class MyClass(GeomBase):
    ... 
    ...     @Part
    ...     def child1(self):
    ...         return Box(position=translate(self.position, x=2))
    ... 
    ...     @Part
    ...     def child2(self):
    ...         return Box(position=rotate90(
    ...                        translate(self.child1.position, x=2), 'x'))
    ... 
    >>> obj = MyClass()
    >>> obj.location
    Point(0, 0, 0)
    >>> obj.orientation
    Orientation(x=Vector(1, 0, 0), y=Vector(0, 1, 0), z=Vector(0, 0, 1))
    >>> obj.child1.location
    Point(2, 0, 0)
    >>> obj.child1.orientation
    Orientation(x=Vector(1, 0, 0), y=Vector(0, 1, 0), z=Vector(0, 0, 1))
    >>> obj.child2.location
    Point(4.0, 0.0, 0.0)
    >>> obj.child2.orientation  # doctest: +SKIP
    Orientation(x=Vector(1, 0, 0), y=Vector(0, 0, 1), z=Vector(0, -1, 0))
    >>> obj.child2.orientation.y  # doctest: +SKIP
    Vector(0, 0, 1)
    """

    __icon__ = os.path.join(ICN_DIR, 'geom_base.png')

    #: The position or placement of this object, which consists of a location
    #: and an orientation in space. The returned :class:`Position` instance
    #: has useful methods for relative positioning of other objects, e.g.
    #: translate (__call__), rotate, align, reflect (mirror), etc. For
    #: absolute positioning you specify your own :class:`Position instance.
    #:
    #: :type: parapy.geom.Position
    position = Input(XOY, defaulting=True)

    @Attribute
    def location(self):
        """The location this object.
        
        :rtype: Point
        """
        return self.position.location

    @Attribute
    def orientation(self):
        """The orientation of this object.
        
        :rtype: Orientation"""
        return self.position.orientation
    
    @Attribute
    def center(self):
        """The center point of this object. This may differ from the location,
        which is used for positioning

        :rtype: Point
        """
        return self.location

    @Attribute
    def _bbox_bounds(self):
        """Bounds of the bounding box. Defaults to :attr:location` point, but
        is overridden in several (geometry) subclasses.

        :rtype: tuple[float, float, float, float, float, float]
        :returns: (x1, y1, z1, x2, y2, z2)
        """
        x, y, z = self.location
        return x, y, z, x, y, z

    @Attribute
    def _local_bbox_bounds(self):
        """Bounds of the axis-aligned minimum bounding box.

        :rtype: tuple[float, float, float, float, float, float]
        :returns: (x1, y1, z1, x2, y2, z2)
        """
        # See http://cs.smith.edu/~orourke/Papers/MinVolBox.pdf
        # Or http://sarielhp.org/p/98/bbox.pdf
        raise RuntimeError("Not implemented yet")

    @Attribute
    def _oriented_bbox_bounds_and_orientation(self):
        """Bounds of an oriented, tight-fitting bounding box.

        :rtype: tuple[tuple[float, float, float, float, float, float], parapy.geom.Orientation]
        :returns: (x1, y1, z1, x2, y2, z2), <orientation of bbox>
        """
        raise RuntimeError("Not implemented yet")

    @HiddenPart
    def bbox(self):
        """A BBox object that is a bounding box around an object, defined in
        the global reference frame (XOY). Answers useful methods like center,
        face_center, intersection, etc.

        .. note:: When creating a bounding box for shapes, and
            :attr:``mesh_deflection`` is set to ``None`` it will
            not use the points of the triangulation as an input for
            the algorithm.

        :rtype: BBox
        """
        return BBox(bounds=self._bbox_bounds)

    @HiddenPart
    def local_bbox(self):
        """A BBox object that is a axis-aligned minimum bounding box around an
        object, defined in the **local** reference frame. Answers useful
        methods like center, face_center, intersection, etc.

        :rtype: BBox
        """
        return BBox(bounds=self._local_bbox_bounds,
                    orientation=self.orientation)

    @HiddenPart
    def oriented_bbox(self):
        """A tight-fitting oriented BBox. Unlike :attr:`local_bbox` it is
        not guaranteed to be oriented in the same way as :attr:`position`.

        .. note:: In the common case, computing a bounding box for shapes, its
            orientation is calculated based on points. The primary source
            for the points is the triangulation, this means that decreasing
            the :attr:`mesh_deflection` might lead to a tighter bounding box.

        .. note:: When creating a bounding box for shapes, and
            :attr:``mesh_deflection`` is set to ``None`` it will
            not use the points of the triangulation as an input for
            the algorithm.

        :rtype: BBox
        """
        return BBox(bounds=self._oriented_bbox_bounds_and_orientation[0],
                    orientation=self._oriented_bbox_bounds_and_orientation[1])


# no subclass of GeomBase to prevent recursive tree on GeomBase.bbox
class BBox(Base):
    """An AABB or axis-aligned-bounding-box object is the minimum bounding
    box around an object in the global reference frame (OXYZ). It answers
    some useful methods as :attr:`center`, :attr:`min_dimension`,
    :meth:`face_center`, etc. It can also be used for a quick intersection test
    :meth:`intersect`.
    """

    __initargs__ = ["bounds"]

    #: list of six numbers: [xmin, ymin, zmin, xmax, ymax, zmax]
    #: :type: typing.Sequence[float, float, float, float, float, float]
    bounds = Input()
    #: can be overridden for local orientation
    orientation = Input(XY)

    @Attribute
    def corners(self):
        """List of two Points.

        >>> BBox((0, 0, 0, 2, 2, 2)).corners
        [Point(0, 0, 0), Point(2, 2, 2)]

        :rtype: list[Point, Point]
        """
        xmin, ymin, zmin, xmax, ymax, zmax = self.bounds
        return [Point(xmin, ymin, zmin), Point(xmax, ymax, zmax)]

    @Attribute
    def center(self):
        """Center :class:`Point` of BBox.

        >>> BBox((0, 0, 0, 2, 2, 2)).center
        Point(1.0, 1.0, 1.0)
        """
        return Point.midpoint(*self.corners)

    location = center

    @Attribute
    def direction_vector(self):
        """normalized direction vector between :attr`corners`.

        >>> BBox((0, 0, 0, 2, 2, 2)).direction_vector
        Vector(0.57735026919, 0.57735026919, 0.57735026919)
        """
        return Point.vector_to(*self.corners).normalize

    @Attribute
    def diagonal(self):
        """Diagonal distance between corners.

        >>> BBox((0, 0, 0, 2, 2, 2)).diagonal
        3.4641016151377544
        """
        return Point.distance(*self.corners)

    @Attribute
    def width(self):
        """The width of the BBox in local :attr:`orientation`.

        >>> BBox((0, 0, 0, 2, 2, 2)).width
        2
        """
        orientation = self.orientation
        if orientation is XY:
            bounds = self.bounds
            return bounds[3] - bounds[0]
        else:
            return (self.direction_vector * orientation.x) * self.diagonal

    @Attribute
    def length(self):
        """The length of the BBox in local :attr:`orientation`.

        >>> BBox((0, 0, 0, 2, 2, 2)).length
        2
        """
        orientation = self.orientation
        if orientation is XY:
            bounds = self.bounds
            return bounds[4] - bounds[1]
        else:
            return (self.direction_vector * self.orientation.y) * self.diagonal

    @Attribute
    def height(self):
        """The height of the BBox in local :attr:`orientation`.

        >>> BBox((0, 0, 0, 2, 2, 2)).height
        2
        """
        orientation = self.orientation
        if orientation is XY:
            bounds = self.bounds
            return bounds[5] - bounds[2]
        else:
            return (self.direction_vector * self.orientation.z) * self.diagonal

    @Attribute
    def points(self):
        """List of 8 corner Points, starting at bottom-left-front (1) and
        ordered as follows::

               8+--------+7
               /|       /|
              / |      / |
            5+--------+6 |
             | 4+-----|--+3   z   y
             | /      | /     ^ /
             |/       |/      |/
            1+--------+2      +----> x

        >>> BBox((0, 0, 0, 2, 2, 2)).points  # doctest: +NORMALIZE_WHITESPACE
        [Point(0, 0, 0), Point(2, 0, 0), Point(2, 2, 0), Point(0, 2, 0),
         Point(0, 0, 2), Point(2, 0, 2), Point(2, 2, 2), Point(0, 2, 2)]
        """
        w, l, h = self.width, self.length, self.height
        pos = Position(self.corners[0], self.orientation)
        points = pos.polygon('x', w, 'y', l, 'x', -w,
                             ('y', 'z'), (-l, h),
                             'x', w, 'y', l, 'x', -w)
        return getattrs(points, "location")

    @Attribute
    def vertices(self):
        msg = ("BBox.vertices has been deprecated, use "
               "BBox.points instead. Object: {!r}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.points

    @Attribute
    def position(self):
        """Position located at midpoint of corners in aligned with
        :attr:`orientation` (global XY, unless this is local_bbox).

        >>> BBox((0, 0, 0, 2, 2, 2)).position
        Position(Point(1.0, 1.0, 1.0))

        :rtype: Position
        """
        return Position(self.center, self.orientation)

    @Attribute
    def min_dimension(self):
        """
        >>> BBox((0, 0, 0, 1, 2, 3)).min_dimension
        1
        """
        return min(self.width, self.length, self.height)

    @Attribute
    def max_dimension(self):
        """
        >>> BBox((0, 0, 0, 1, 2, 3)).max_dimension
        3
        """
        return max(self.width, self.length, self.height)

    @Attribute
    def volume(self):
        """
        >>> BBox((0, 0, 0, 2, 2, 2)).volume
        8
        """
        return self.width * self.length * self.height

    def vertex(self, key1, key2, key3):
        """BBox position at named vertex.

        >>> bbox = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox.vertex('bottom', 'front', 'left')  # ('x-', 'y-', 'z-')
        Position(Point(0.0, 0.0, 0.0))
        >>> bbox.vertex('top', 'back', 'right')  # ('x+', 'y+', 'z+')
        Position(Point(2.0, 2.0, 2.0))

        :param str key1: named direction
        :param str key2: named direction
        :param str key3: named direction
        :rtype: Position
        """
        return _get_logical_position(
            self.position, self.width, self.length, self.height,
            key1, key2, key3)
    
    def edge_center(self, key1, key2):
        """BBox position at named edge center

        >>> bbox = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox.edge_center('bottom', 'front')  # ('x-', 'y-')
        Position(Point(1.0, 0.0, 0.0))
        >>> bbox.edge_center('top', 'rear')  # ('x+', 'y+')
        Position(Point(1.0, 2.0, 2.0))

        :param str key1: named direction
        :param str key2: named direction
        :rtype: Position
        """
        return _get_logical_position(
            self.position, self.width, self.length, self.height, key1, key2)

    def face_center(self, key):
        """BBox position at named face center

        >>> BBox((0, 0, 0, 2, 2, 2)).face_center('top')  # ('z+')
        Position(Point(1.0, 1.0, 2.0))

        :param str key: named direction
        :rtype: Position
        """
        return _get_logical_position(
            self.position, self.width, self.length, self.height, key)

    def inside(self, point, include_border=False):
        """Checks if ``point`` is inside this BBox.

        .. note:: Convenience notation: ``point inside bbox``.

        >>> from parapy.geom import Point
        >>> bbox = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox.inside(Point(1, 1, 1))
        True
        >>> bbox.inside(Point(2, 0, 1))
        False
        >>> bbox.inside(Point(2, 0, 1), include_border=True)
        True
        >>> # alternative notation
        >>> Point(1, 1, 1) in bbox
        True

        :param Point | Position point: point to test
        :param bool include_border: is point on border inside?
        """
        if self.orientation is not XY:
            msg = ("Operation 'inside' is only implemented for BBoxes that "
                   "are XY oriented. Object: {!r}")
            raise NotImplementedError(msg.format(self))

        # To check if a point is inside an AABB we just need to check if all
        # its values (x,y and z) are greater than the AABB’s min values and
        # less than the AABB’s max values.
        x, y, z = point
        x1, y1, z1, x2, y2, z2 = self.bounds
        if include_border:
            return x1 <= x <= x2 and y1 <= y <= y2 and z1 <= z <= z2
        else:
            return x1 < x < x2 and y1 < y < y2 and z1 < z < z2

    def intersect(self, other):
        """Checks if two BBoxs are intersecting.

        >>> bbox1 = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox2 = BBox((1, 1, 1, 3, 3, 3))
        >>> bbox1.intersect(bbox2)
        True
        >>> bbox2 = BBox((3, 3, 3, 5, 5, 5))
        >>> bbox1.intersect(bbox2)
        False
        
        :param BBox other:
        :rtype: bool
        """
        if self.orientation is not XY:
            msg = ("Operation 'intersect' is only implemented for BBoxes that "
                   "are XY oriented. Object: {!r}")
            raise NotImplementedError(msg.format(self))

        elif other.orientation is not XY:
            msg = ("Operation 'intersect' is only implemented for BBoxes that "
                   "are XY oriented and 'other' {!r} has a "
                   "different orientation. Object: {!r}")
            raise NotImplementedError(msg.format(other, self))

        # we just need to check that the first AABB’s max point is greater
        # than the second one’s min point and that the first one’s min point
        # is less than the second one’s max point.
        x1, y1, z1, x2, y2, z2 = self.bounds
        x1_, y1_, z1_, x2_, y2_, z2_ = other.bounds
        return (x2 > x1_ and x1 < x2_ and
                y2 > y1_ and y1 < y2_ and
                z2 > z1_ and z1 < z2_)
    
    def union(self, *other):
        """Return a new :class:`BBox` that is enlarged to unite this BBox and
        (one or multiple) ``other`` BBox's.

        >>> bbox1 = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox2 = BBox((1, 1, 1, 3, 3, 3))
        >>> bbox = bbox1.union(bbox2)
        >>> bbox.bounds
        (0, 0, 0, 3, 3, 3)
        >>> bbox3 = BBox((2, 2, 2, 4, 4, 4))
        >>> bbox = bbox1.union(bbox2, bbox3)
        >>> bbox.bounds
        (0, 0, 0, 4, 4, 4)
        >>> # alternative notation
        >>> bbox = bbox1 | bbox2 | bbox3
        >>> bbox.bounds
        (0, 0, 0, 4, 4, 4)

        .. note:: Convenience notation: ``bbox1 + bbox2``.

        :param BBox other: one or multiple :class:`BBox` to add.
        :rtype BBox
        """
        if self.orientation is not XY:
            msg = ("Operation 'union' is only implemented for BBoxes that "
                   "are XY oriented. Object: {!r}")
            raise NotImplementedError(msg.format(self))

        x1, y1, z1, x2, y2, z2 = self.bounds
        for bbox in other:
            if bbox.orientation is not XY:
                msg = ("Operation 'union' is only implemented for BBoxes that "
                       "are XY oriented and argument {!r} has a different "
                       "orientation. Object: {!r}")
                raise NotImplementedError(msg.format(bbox, self))

            x1_, y1_, z1_, x2_, y2_, z2_ = bbox.bounds
            if x1_ < x1:
                x1 = x1_
            if y1_ < y1:
                y1 = y1_
            if z1_ < z1:
                z1 = z1_
            if x2_ > x2:
                x2 = x2_
            if y2_ > y2:
                y2 = y2_
            if z2_ > z2:
                z2 = z2_
        return BBox((x1, y1, z1, x2, y2, z2))

    @deprecated(replaced_by="BBox.union")
    def add(self, *others):
        return self.union(*others)

    def common(self, other):
        """Return a new :class:`BBox` that represents the common part between
        this and ``other`` or :py:`None` if not intersecting.

        >>> bbox1 = BBox((0, 0, 0, 2, 2, 2))
        >>> bbox2 = BBox((1, 1, 1, 3, 3, 3))
        >>> bbox = bbox1.common(bbox2)
        >>> bbox.bounds
        (1, 1, 1, 2, 2, 2)
        >>> # alternative notation
        >>> bbox = bbox1 & bbox2
        >>> bbox.bounds
        (1, 1, 1, 2, 2, 2)

        .. note:: Convenience notation: ``bbox1 & bbox2``.

        :rtype BBox | None
        """
        if self.orientation is not XY:
            msg = ("Operation 'common' is only implemented for BBoxes that "
                   "are XY oriented. Object: {!r}")
            raise NotImplementedError(msg.format(self))

        if other.orientation is not XY:
            msg = ("Operation 'common' is only implemented for BBoxes that "
                   "are XY oriented and 'other' {!r} has a "
                   "different orientation. Object: {!r}")
            raise NotImplementedError(msg.format(other, self))

        if self.intersect(other):
            # quick test to see who's intersecting who
            x1, y1, z1, x2, y2, z2 = self.bounds
            x1_, y1_, z1_, x2_, y2_, z2_ = other.bounds
            if x1_ < x2 < x2_:
                # I'm inside other's
                return BBox((x1_, y1_, z1_, x2, y2, z2))
            else:
                # other 2's is inside me
                return BBox((x1, y1, z1, x2_, y2_, z2_))
        else:
            return None

    def __contains__(self, point):
        return self.inside(point)

    def __add__(self, other):  # override of +
        if isinstance(other, BBox):
            # deprecation in here, because we don't want to show warnings in
            # the NotImplemented case.
            msg = ("BBox + BBox notation has been deprecated, use "
                   "BBox | BBox instead. Object: {!r}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning,
                          stacklevel=2)
            return self.union(other)
        else:
            return NotImplemented

    def __or__(self, other):  # override of |=
        if isinstance(other, BBox):
            return self.union(other)
        else:
            return NotImplemented

    def __and__(self, other_BBox):  # override of &
        if isinstance(other_BBox, BBox):
            return self.common(other_BBox)
        else:
            return NotImplemented

    # Monkey-patch in Box class
    @Part(parse=False)
    def box(self):
        raise RuntimeError("should be monkey-patched by Box")

    box.bind_child_rule(transparency=lambda self: 0.8)
    box.bind_child_rule(centered=lambda self: True)
    box.bind_child_rule(width=lambda self: self.width)
    box.bind_child_rule(length=lambda self: self.length)
    box.bind_child_rule(height=lambda self: self.height)
    box.bind_child_rule(position=lambda self: self.position)


def _get_logical_position(pos, width, length, height, *keys):
    """Find the logical position defined by the number of direction ``keys``:

    >>> from parapy.geom import XOY
    >>> _get_logical_position(XOY, 1, 1, 1, 'x', 'y', 'z')
    Position(Point(0.5, 0.5, 0.5))
    >>> _get_logical_position(XOY, 1, 1, 1, 'x', 'bogus', 'z')  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    KeyError: "'bogus' is not a valid direction key. ...
    >>> _get_logical_position(XOY, 1, 1, 1, 'x', 'x', 'z')  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    ValueError: Did not receive orthogonal direction keys. ...
    >>> _get_logical_position(XOY, 1, 1, 1, 'x', 'x', 'z', 'w')  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    TypeError: can only take between 1 and 3 keyword arguments, ....

    - 1 key: returns a face-centered position object
    - 2 keys: returns an edge-centered position object
    - 3 keys: returns a vertex-bound position object.
    
    :param Position pos: the position to translate from
    :param float width: dimension corresponding to pos-local 'x' axis
    :param float length: dimension corresponding to pos-local 'y' axis
    :param float  height: dimension corresponding to pos-local 'z' axis
    :param str keys: between 1 and 3 orthogonal (named) direction keywords.
    :rtype: Position
    :raises TypeError: if not 1 <= len(keys) <= 3.
    :raises ValueError: if keys are not orthogonal
    :raises KeyError: if any of keys is not a valid direction keyword
    """
    if not 1 <= len(keys) <= 3:
        msg = "can only take between 1 and 3 keyword arguments, not: {!r}."
        raise TypeError(msg.format(keys))
    unique_keys = ['x', 'y', 'z']
    dims = {'width': width, 'length': length, 'height': height}
    kwargs = {}
    for key in keys:
        ax = key_to_axis(key)
        if ax in unique_keys: 
            unique_keys.remove(ax)
        else:
            msg = ("Did not receive orthogonal direction keys. Keyword {!r} "
                   "is a second reference to the {!r} axis. Keys: {!r}.")
            raise ValueError(msg.format(key, ax, keys))
        kwargs[key] = 0.5 * dims[key_to_dim(key)]
    return translate(pos, **kwargs)


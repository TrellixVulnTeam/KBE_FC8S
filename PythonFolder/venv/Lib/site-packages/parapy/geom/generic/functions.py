#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Functions to translate, rotate, etc."""

import math

_HALFPI = 0.5 * math.pi


def translate(abstract_point, *args, **kwargs):
    """Returns a new :py:class:`Point` or :py:class:`Position` object by
    translating a given ``abstract_point`` along a (named) ``direction``
    over ``distance``. Named vectors like 'x', 'y' or 'front' are inpreted
    in the **applicable** reference frame, which depends on the
    ``abstract_point`` argument type. For ``Point`` objects, the **global**
    reference system applies (OXY). So, 'x' or 'right' would correspond to
    ``OXY.Vx`` or ``Vector(1, 0, 0)``. For ``Position`` objects,
    the **local** coordinate system applies, viz. the local orientation of
    the ``Position`` object defines the direction. So, 'x' or 'right' would
    correspond to ``abstract_point.Vx``. In this case, you would like to
    force a translation in the global x direction, input ``OXY.Vx`` or
    ``Vector(1, 0, 0)``.

    Note that if you want translate something by just adding one vector to a
    Point or Position object, you can use the notation: ``pt + V``.

    If you want to **fix/anchor** a coordinate (i.e. not translate), use one
    of capitalized string inputs: 'X', 'Y' or 'Z'.

    :param abstract_point: either a Point or Position object
    :param args: direction and distance pairs
    :param kwargs: direction and distance pairs
    :returns: :py:class:`Point` or :py:class:`Position` depending on
        ``abstract_point`` type

    :type abstract_point: :py:class:`Point` | :py:class:`Position`
    :type direction: str | Vector
    :type distance: numbers.Number
    :rtype: :py:class:`Point` | :py:class:`Position`

    >>> from parapy.geom.generic.positioning import *
    >>> # Usage with Point object as input:
    >>> pt = Point(1, 1, 1)
    >>> # basic usage
    >>> translate(pt, Vector(1,0,0), 2)
    Point(3, 1, 1)
    >>> # named direction
    >>> translate(pt, 'x', 2)
    Point(3, 1, 1)
    >>> # opposite named direction
    >>> translate(pt, '-x', 2)
    Point(-1, 1, 1)
    >>> # multiple translations at once
    >>> translate(pt, 'x', 2, 'y', 3, '-z', 4)
    Point(3, 4, -3)
    >>> # fix X coordinate at 2 instead of moving over a distance of 2.
    >>> translate(pt, 'X', 2, 'y', 3, '-z', 4)
    Point(2, 4, -3)

    >>> # Usage with Position object as input:
    >>> pos = Position(Point(1, 1, 1), XY)
    >>> translate(pos, Vector(1,0,0), 2)
    Position(3, 1, 1)
    >>> # named direction depends on local orientation.
    >>> translate(pos, 'x', 2)
    Position(3, 1, 1)
    >>> # new position object by rotating 90 degrees
    >>> pos_oriented = pos.rotate_quarter('z')
    >>> translate(pos_oriented, 'x', 2)
    Position(1, 3, 1)
    """

    # this function is a simple proxy to the applicable methods.
    return abstract_point.translate(*args, **kwargs)


def rotate(abstract_point, rotation_axis, angle, ref=None, deg=False):
    """Returns a new Point or Position object by rotating a given Point or
    Position around a (named) ``rotation_axis`` over ``angle``. By default,
    a Point input will be translated around the ``ORIGIN``, while a Position
    object is rotated around it's own location (pure rotation,
    no translation). If you want to specify a different reference Point for
    rotation, specify a ``ref`` argument. By default, the ``angle`` should
    be given in radians, but if you want to work with degrees, specify
    ``deg=True``.

    Named rotation axis inputs like 'x', 'y' or 'front' are inpreted in the
    **applicable** reference frame, which depends on the ``abstract_point``
    argument type. For ``Point`` objects, the **global** reference system
    applies (OXY). So, 'x' or 'right' would correspond to ``OXY.Vx`` or
    ``Vector(1, 0, 0)``. For ``Position`` objects, the **local** coordinate
    system applies, viz. the local orientation of the ``Position`` object
    defines the direction. So, 'x' or 'right' would correspond to
    ``abstract_point.Vx``. In this case, you would like to force a
    translation in the global x direction, input ``OXY.Vx`` or ``Vector(1,
    0, 0)``.

    :param abstract_point: either a Point or Position object
    :param rotation_axis: direction to translate over. Named or Vector
    :param angle: angle to rotate over
    :param ref: Optional reference point for rotation
    :param bool deg: is the angle given in degrees? Default is False.
    :returns: Point or Position depending on ``abstract_point`` type

    :type abstract_point: :py:class:`Point`|:py:class:`Position`
    :type rotation_axis: Vector|str
    :type angle: numbers.Number
    :type ref: :py:class:`Point`|:py:class:`Position`
    :type deg: int
    :rtype: :py:class:`Point`|:py:class:`Position`

    >>> from parapy.geom.generic.positioning import *
    >>> # Usage with Point object as input:
    >>> pt = Point(1, 0, 0)
    >>> # quarter circle rotation around specified Vector.
    >>> rotate(pt, Vector(0, 0, 1), 0.5*math.pi)
    Point(0, 1, 0)
    >>> # using a named axis of rotation and degrees
    >>> rotate(pt, 'z', 90, deg=True)
    Point(0, 1, 0)
    >>> # opposite named direction
    >>> rotate(pt, '-z', 90, deg=True)
    Point(0, -1, 0)
    >>> # specified reference point != ORIGIN
    >>> rotate(pt, Vector(0, 0, 1), 0.5*math.pi, ref=Point(-1, 0, 0))
    Point(-1, 2, 0)

    >>> # Usage with Position object as input:
    >>> pos = Position(Point(1, 0, 0), XY)
    >>> # By default rotation of a Position is around itself.
    >>> # Thus, orientation changes, but location remains unchanged.
    >>> pos2 = rotate(pos, Vector(0, 0, 1), 0.5*math.pi)
    >>> pos2.location
    Point(1, 0, 0)
    >>> pos2.Vx, pos2.Vy
    (Vector(0, 1, 0), Vector(-1, 0, 0))
    >>> # with a different reference point, location does change
    >>> pos3 = rotate(pos, Vector(0, 0, 1), 0.5*math.pi, ref=Point(-1, 0, 0))
    >>> pos3.location
    Point(-1, 2, 0)
    >>> pos3.Vx, pos3.Vy
    (Vector(0, 1, 0), Vector(-1, 0, 0))
    """

    # this function is a simple proxy to the applicable methods.
    if ref:
        return abstract_point.rotate_around(ref, rotation_axis, angle, deg=deg)
    else:
        return abstract_point.rotate(rotation_axis, angle, deg=deg)


def rotate90(abstract_point, rotation_axis, ref=None):
    """Returns a new Point or Position object by rotating a given Point or
    Position around a (named) ``rotation_axis`` over **90 degrees**. Refer
    to :py:func:`rotate` for more details.

    :param abstract_point: either a Point or Position object
    :param rotation_axis: direction to translate over. Named or Vector
    :param ref: Optional reference point for rotation
    :returns: Point or Position depending on ``abstract_point`` type

    :type abstract_point: :py:class:`Point`|:py:class:`Position`
    :type rotation_axis: Vector|str
    :type ref: :py:class:`Point`|:py:class:`Position`
    :rtype: :py:class:`Point`|:py:class:`Position`

    >>> from parapy.geom.generic.positioning import *
    >>> # Usage with Point object as input:
    >>> pt = Point(1, 0, 0)
    >>> # quarter circle rotation around specified Vector.
    >>> rotate90(pt, Vector(0, 0, 1))
    Point(0, 1, 0)
    >>> # using a named axis of rotation and degrees
    >>> rotate90(pt, 'z')
    Point(0, 1, 0)
    >>> # opposite named direction
    >>> rotate90(pt, '-z')
    Point(0, -1, 0)
    >>> # specified reference point != ORIGIN
    >>> rotate90(pt, Vector(0, 0, 1), ref=Point(-1, 0, 0))
    Point(-1, 2, 0)

    >>> # Usage with Position object as input:
    >>> pos = Position(Point(1, 0, 0), XY)
    >>> # By default rotation of a Position is around itself.
    >>> # Thus, orientation changes, but location remains unchanged.
    >>> pos2 = rotate90(pos, Vector(0, 0, 1))
    >>> pos2.location
    Point(1, 0, 0)
    >>> pos2.Vx, pos2.Vy
    (Vector(0, 1, 0), Vector(-1, 0, 0))
    >>> # with a different reference point, location does change
    >>> pos3 = rotate90(pos, Vector(0, 0, 1), ref=Point(-1, 0, 0))
    >>> pos3.location
    Point(-1, 2, 0)
    >>> pos3.Vx, pos3.Vy
    (Vector(0, 1, 0), Vector(-1, 0, 0))
    """
    # this function is a simple proxy to the applicable methods.
    global _HALFPI
    if ref:
        return abstract_point.rotate_around(ref, rotation_axis, _HALFPI)
    else:
        return abstract_point.rotate(rotation_axis, _HALFPI)


if __name__ == '__main__':
    import math
    from parapy.geom.generic.positioning import Point, Vector, Position, XY

    ###########################################################################
    # Translate API
    ###########################################################################

    # Usage with Point object as input:
    pt = Point(1, 1, 1)
    # basic usage
    print(translate(pt, Vector(1, 0, 0), 2))
    # named direction
    print(translate(pt, 'x', 2))
    # opposite named direction
    print(translate(pt, '-x', 2))
    # multiple translations at once
    print(translate(pt, 'x', 2, 'y', 3, '-z', 4))
    # fix X coordinate at 2 instead of moving over a distance of 2.
    print(translate(pt, 'X', 2, 'y', 3, '-z', 4))

    # Usage with Position object as input:
    pos = Position(Point(1, 1, 1), XY)
    print(translate(pos, Vector(1, 0, 0), 2))
    # named direction depends on local orientation.
    print(translate(pos, 'x', 2))
    # new position object by rotating 90 degrees
    pos_oriented = rotate90(pos, 'z')
    print(translate(pos_oriented, 'x', 2))


    ###########################################################################
    # Rotate API
    ###########################################################################

    # Usage with Point object as input:
    pt = Point(1, 0, 0)
    # quarter circle rotation around specified Vector.
    print(rotate(pt, Vector(0, 0, 1), 0.5 * math.pi))
    # using a named axis of rotation and degrees
    print(rotate(pt, 'z', 90, deg=True))
    # opposite named direction
    print(rotate(pt, '-z', 90, deg=True))
    # specified reference point != ORIGIN
    print(rotate(pt, Vector(0, 0, 1), 0.5 * math.pi, ref=Point(-1, 0, 0)))

    # Usage with Position object as input:
    pos = Position(Point(1, 0, 0), XY)
    # By default rotation of a Position is around itself.
    # Thus, orientation changes, but location remains unchanged.
    pos2 = rotate(pos, Vector(0, 0, 1), 0.5 * math.pi)
    print(pos2.location)
    print(pos2.Vx, pos2.Vy)
    # with a different reference point, location does change
    pos3 = rotate(pos, Vector(0, 0, 1), 0.5 * math.pi, ref=Point(-1, 0, 0))
    print(pos3.location)
    print(pos3.Vx, pos3.Vy)

    ###########################################################################
    # rotate90 API
    ###########################################################################
    # Returns a new Point or Position object by rotating a given Point or
    # Position around a (named) ``rotation_axis`` over **90 degrees**. Refer
    # to :py:func:`rotate` for more details.
    #
    # :param abstract_point: either a Point or Position object
    # :param rotation_axis: direction to translate over. Named or Vector
    # :param ref: Optional reference point for rotation
    # :returns: Point or Position depending on ``abstract_point`` type
    #
    # :type abstract_point: :py:class:`Point`|:py:class:`Position`
    # :type rotation_axis: Vector|str
    # :type ref: :py:class:`Point`|:py:class:`Position`
    # :rtype :py:class:`Point`|:py:class:`Position`
    #
    # >>> from parapy.geom.generic.positioning import *
    # >>> # Usage with Point object as input:
    # >>> pt = Point(1, 0, 0)
    # >>> # quarter circle rotation around specified Vector.
    # >>> rotate90(pt, Vector(0, 0, 1))
    # Point(0, 1, 0)
    # >>> # using a named axis of rotation and degrees
    # >>> rotate90(pt, 'z')
    # Point(0, 1, 0)
    # >>> # opposite named direction
    # >>> rotate90(pt, '-z')
    # Point(0, -1, 0)
    # >>> # specified reference point != ORIGIN
    # >>> rotate90(pt, Vector(0, 0, 1), ref=Point(-1, 0, 0))
    # Point(-1, 2, 0)
    #
    # >>> # Usage with Position object as input:
    # >>> pos = Position(Point(1, 0, 0), XY)
    # >>> # By default rotation of a Position is around itself.
    # >>> # Thus, orientation changes, but location remains unchanged.
    # >>> pos2 = rotate90(pos, Vector(0, 0, 1))
    # >>> pos2.location
    # Point(1, 0, 0)
    # >>> pos2.Vx, pos2.Vy
    # (Vector(0, 1, 0), Vector(-1, 0, 0))
    # >>> # with a different reference point, location does change
    # >>> pos3 = rotate90(pos, Vector(0, 0, 1), ref=Point(-1, 0, 0))
    # >>> pos3.location
    # Point(-1, 2, 0)
    # >>> pos3.Vx, pos3.Vy
    # (Vector(0, 1, 0), Vector(-1, 0, 0))

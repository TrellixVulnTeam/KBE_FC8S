#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

# TODO (TBD): optimize code for performance!!! Main concern is overhead in type
# /todo checking, argument extraction, etc.
# TODO (TBD): consider using numpy for speed / flexibility?
# TODO (TBD): or turn this into a C-extension for speed?
# FIXME (TBD): fix -0 cases?

"""The :class:`Point`, :class:`Vector`, :class:`Orientation`,
:class:`Axis` and :class:`Position` classes are used for positioning /
orienting objects in space. All methods that you would typically expect from
these classes are implemented, viz. you can translate, rotate or align
objects as you wish. All classes are implemented as immutable types, to make
sure that you don't do any mutable type changes that would otherwise go
unnoticed by the dependency tracking and caching framework. As such,
these classes are not extremely high-performant when it concerns bulk
computation. If you need heavy-duty matrix calculations, or linear algebra
in general, considering 3rd-party packages like ``numpy`` that have been
optimized for such purposes. Just transform the results back into |ParaPy|
types if you want to use them again for positioning or visualization. Some
globals are defined:

- XY: global orientation system::

        Orientation(x=Vector(1, 0, 0), y=Vector(0, 1, 0), z=Vector(0, 0, 1))

- OXY: global coordinate system::

        Position(Point(0, 0, 0),
                 Orientation(x=Vector(1, 0, 0),
                             y=Vector(0, 1, 0),
                             z=Vector(0, 0, 1)))
"""

import math
import os
import warnings
from collections import namedtuple
from numbers import Number
from typing import Iterable

from parapy.core.abstract import DrawableParaPyObject, ParaPyObject
from parapy.core.snapshot import serialize_instance
from parapy.core.utilities import by_pairs
from parapy.geom.generic.globs import KEY_MAIN_KEY
from parapy.geom.generic.utilities import (
    _invert_3x3_matrix, _matrix_times_matrix, _matrix_times_vector,
    _vector_times_matrix, is_almost_equal_mat, is_almost_equal_vec,
    key_to_main_key, key_to_perp_key, key_to_vector_key, key_to_vector_tuple,
    vector_angle)
from parapy.geom.globs import CONFIGURATION, ICN_DIR

_Tuple3D = namedtuple('_Tuple3D', ['x', 'y', 'z'])

__all__ = ['Axis', 'ISO', 'OISO_LOW', 'ORIGIN', 'OXY', 'Orientation', 'Point',
           'Position', 'V0', 'VX', 'VY', 'VZ', 'Vector', 'XOY', 'XY', 'YOZ',
           'YZ', 'ZOX', 'ZX', 'centroid', 'orthogonal_vector']


class Tuple3D(_Tuple3D, ParaPyObject):
    """A 3-dimensional coordinate.

    x - the x-coordinate
    y - the y-coordinate
    z - the z-coordinate

    Usage:
    >>> tup = Tuple3D(1, 2, 3)
    >>> tup.x, tup.y, tup.z
    (1, 2, 3)
    >>> list(tup)
    [1, 2, 3]
    >>> tup[0], tup[1], tup[2]
    (1, 2, 3)
    >>> # x, y and z coordinates all default to 0
    >>> tup = Tuple3D()
    >>> tup.x, tup.y, tup.z
    (0, 0, 0)
    >>> pt = Tuple3D(1, 2)
    >>> pt.x, pt.y, pt.z
    (1, 2, 0)
    """
    __initargs__ = ['x', 'y', 'z']
    __newargs__ = __initargs__
    _tree_attrs = __initargs__

    def __init__(self, x=0, y=0, z=0):
        """
        :param float x: the x-coordinate
        :param float y: the y-coordinate
        :param float z: the z-coordinate
        """
        super(Tuple3D, self).__init__(x, y, z)

    def __eq__(self, other):
        return self.is_almost_equal(other)

    def __hash__(self):
        return super(Tuple3D, self).__hash__()

    def __pos__(self):
        return self

    def __neg__(self):
        return self.__class__(-self[0], -self[1], -self[2])

    def __invert__(self):
        return self.__class__(self[2], self[1], self[0])

    def __abs__(self):
        return self.__class__(abs(self[0]), abs(self[1]), abs(self[2]))

    def __str__(self):
        return '%s(%s, %s, %s)' % (
            self.__class__.__name__, self[0], self[1], self[2])

    def __repr__(self):
        return '%s(%s, %s, %s)' % (
            self.__class__.__name__, self[0], self[1], self[2])

    def __getitem__(self, y):
        """Return individual member of slice of this tuple.

        :param y: index or slice
        :type y: int | slice
        :rtype: tuple[float] | float
        """
        return super(Tuple3D, self).__getitem__(y)

    @property
    def reverse(self):
        """Negates this vector. The vector has the same magnitude as before,
        but its direction is now opposite. This is equal to simply stating
        ``-self.``

        :rtype: Tuple3D
        """
        return -self

    def is_almost_equal(self, other, tol=None):
        """Test is other tuple is equal with tolerance ``tol``, defaults to
        CONFIGURATION["tolerance"].

        :param Tuple3D other: other tuple to compare to.
        :param float|None tol: optional tolerance for comparison
        :rtype: bool
        """
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return (isinstance(other, Tuple3D) and
                is_almost_equal_vec(self, other, tol))

    def replace(self, x=None, y=None, z=None):
        """Get a copy of this object. One can override any of its items.

        :param numbers.Number | None x:
        :param numbers.Number | None y:
        :param numbers.Number | None z:
        """
        cls = type(self)
        x = self.x if x is None else x
        y = self.y if y is None else y
        z = self.z if z is None else z
        return cls(x, y, z)


# __init__ was there only to force type hinting in IDE
del Tuple3D.__init__
del Tuple3D.__getitem__
Tuple3D.__new__.__defaults__ = (0, 0, 0)


class AbstractPoint(Tuple3D, DrawableParaPyObject):
    """The abstract base class for Point, Axis and Position. Throughout ParaPy these three are
    handled in the same way and can be the input for any method that expects a *Point*. Usage:

    >>> point = AbstractPoint(x=1, y=1, z=1)
    """

    __icon__ = os.path.join(ICN_DIR, 'point.png')
    color = "black"

    @classmethod
    def ensure_vector(cls, vector, normalize=True):
        """Ensures that ``vector`` is a proper Vector instance. Specified
        ``vector`` can be:

        1. a Vector instance --> returned as is
        2. a string naming a direction --> returns associated principle Vector
        3. an iterable of three numbers --> converted to Vector.

        :rtype: Vector
        :raises TypeError: when it couldn't convert
        """
        if isinstance(vector, str):
            return Vector(*key_to_vector_tuple(vector))
        elif isinstance(vector, Vector):
            return vector
        elif hasattr(vector, "__iter__") and len(vector) == 3:
            return Vector(*vector)
        else:
            msg = "Don't know how to convert {} into a Vector."
            raise TypeError(msg.format(repr(vector)))


class Point(AbstractPoint):
    """Basic 3d point class, is a tuple and thus immutable.

    :param float x: Default 0.0.
    :param float y: Default 0.0.
    :param float z: Default 0.0.

    Usage:

    >>> from parapy.geom import Point
    >>> Point(1, 2, 3)
    Point(1, 2, 3)
    >>> Point()
    Point(0, 0, 0)
    >>> Point(1, 2)
    Point(1, 2, 0)

    Note that :meth:`~Point.__call__` maps to :meth:`~Point.translate`. So,
    calling a Point object is the same as invoking `meth:`~Point.translate` on
    it:

    >>> pt = Point()
    >>> pt.translate(x=2)
    Point(2,0,0)
    >>> pt(x=2)
    Point(2,0,0)   
    """

    #: (vector) if you want to a Vector representation from Point
    vector = property(lambda self: Vector(*self))

    @classmethod
    def grid(cls, x, y, z):
        """Utility to make a grid of points quickly

        :param x: number or iterable of numbers
        :param y: number or iterable of numbers
        :param z: number or iterable of numbers

        :type x: Iterable | numbers.Number
        :type y: Iterable | numbers.Number
        :type z: Iterable | numbers.Number

        :return: array of Point objects. Depending on inputs, the array
            can be 1D (list), 2D or 3D.
        :rtype: list

        >>> # Vary x and z, keep y constant.
        >>> Point.grid([1, 2, 3], 4, [5, 6])
        [[Point(1, 4, 5), Point(2, 4, 5), Point(3, 4, 5)],
         [Point(1, 4, 6), Point(2, 4, 6), Point(3, 4, 6)]]
        """
        if hasattr(x, '__iter__'):
            if hasattr(y, '__iter__'):
                if hasattr(z, '__iter__'):
                    return [[[cls(_x, _y, _z) for _x in x] for _y in y] for _z in z]
                else:
                    return [[cls(_x, _y, z) for _x in x] for _y in y]
            elif hasattr(z, '__iter__'):
                return [[cls(_x, y, _z) for _x in x] for _z in z]
            else:
                return [cls(_x, y, z) for _x in x]
        else:
            if hasattr(y, '__iter__'):
                if hasattr(z, '__iter__'):
                    return [[cls(x, _y, _z) for _y in y] for _z in z]
                else:
                    return [cls(x, _y, z) for _y in y]
            else:
                if hasattr(z, '__iter__'):
                    return [cls(x, y, _z) for _z in z]
                else:
                    return [cls(x, y, z)]

    def __add__(self, other):
        """Adds the specified Vector to this Point and returns a **Point**

        Remark: ``Vector + Point == Point + Vector``
        Remark: ``Point + Point`` is prohibited.

        :param other: other Point
        :type other: :class:`Vector`
        :rtype: :class:`Point` | NotImplemented

        >>> pt1 = Point(1, 2, 3)
        >>> v2 = Vector(0, 1, 2)
        >>> pt1 + v2
        Point(1, 3, 5)
        """
        if isinstance(other, Vector):
            return Point(self[0] + other[0], self[1] + other[1],
                         self[2] + other[2])
        else:
            return NotImplemented

    __radd__ = __add__

    def __sub__(self, other):
        """Two subtractions modes:
        
        1. Point - Vector: subtracts the specified Vector from this Point and
            returns the resulting **Point**.
        2. Point - Point: subtract the specified Point from this Point and
            returns the difference as a **Vector** (same as vector_from).
        
        .. note:: ``(Vector - Point)`` is prohibited.

        :param other: other Point or Vector
        :type other: :class:`Vector` | :class:`Point`
        :rtype: :class:`Point` | :class:`Vector` | NotImplemented

        >>> pt1 = Point(1, 2, 3)
        >>> pt2 = Point(0, 1, 2)
        >>> v2 = Vector(0, 1, 2)
        >>> pt1 - pt2
        Vector(1, 1, 1)
        >>> pt1 - v2
        Point(1, 1, 1)
        """
        if isinstance(other, Vector):
            return Point(self[0] - other[0], self[1] - other[1], self[2] - other[2])
        if isinstance(other, AbstractPoint):
            return Vector(self[0] - other[0], self[1] - other[1], self[2] - other[2])
        else:
            return NotImplemented

    def __rsub__(self, other):
        """We implement this to prohibit Vector - Point."""
        if isinstance(other, AbstractPoint):
            return other - self
        else:
            return NotImplemented

    def __rmul__(self, other):
        """Only Orientation * Point is allowed"""
        if isinstance(other, Orientation):
            return Point(*_matrix_times_vector(other, self))
        else:
            return NotImplemented

    def distance(self, other):
        """Distance to other point.

        >>> Point(0, 0, 0).distance(Point(1, 0, 0))
        1.0

        :param AbstractPoint other: other Point
        :rtype: float
        """
        if isinstance(other, AbstractPoint):
            return (self - other).length
        else:
            raise NotImplementedError("other should be an AbstractPoint, not: %s" % type(other))

    @property
    def distance_origin(self):
        """Distance from ``ORIGIN``

        >>> Point(1, 0, 0).distance_origin()
        1.0

        :rtype: float
        """
        return math.sqrt(self[0] ** 2 + self[1] ** 2 + self[2] ** 2)

    def vector_to(self, other, normalize=False):
        """Returns the vector from ``self`` to ``other``. Note that this is
        similar to ``other - self``.

        :param other: other Point
        :type other: :class:`Point` | :class:`Position`
        :param bool normalize: return a normalized vector?
        :rtype: :class:`Vector`
        :raises: NotImplementedError
        """
        if isinstance(other, AbstractPoint):
            v = other - self
            if normalize:
                v = v.normalize
            return v
        else:
            raise NotImplementedError("other_point should be an AbstractPoint, not: %s" % type(other))

    def vector_from(self, other, normalize=False):
        """Returns the vector from ``other`` to ``self``. Note that this is
        similar to ``other - self``.

        :param other: other Point
        :type other: :class:`Point` | :class:`Position`
        :param bool normalize: return a normalized vector?
        :rtype: :class:`Vector`
        :raises: NotImplementedError
        """
        if isinstance(other, AbstractPoint):
            v = self - other
            if normalize:
                v = v.normalize
            return v
        else:
            raise NotImplementedError("other should be an AbstractPoint, not: %s" % type(other))

    def midpoint(self, other):
        """Return a Point that is halfway between this Point and ``other``.

        :param Point | Axis | Position other: other Point / Axis / Position

        >>> ORIGIN.midpoint(Point(2, 4, 6))
        Point(1.0, 2.0, 3.0)
        """
        if isinstance(other, AbstractPoint):
            return self + 0.5 * (other - self)
        else:
            msg = ("other should be of type Point|Axis|Position|, not: {}. "
                   "Object: {}.")
            raise RuntimeError(msg.format(type(other), self))

    def interpolate(self, other, frac=0.5):
        """Return an interpolated Point that is at fraction ``frac`` from self.

        :param Point | Axis | Position other: other Point / Axis / Position
        :param numbers.Number frac: Between [0-1] for interpolation. Outside
            this range for extrapolation. Default is 0.5.
        :rtype: Point

        >>> pt1 = Point(1,2,3)
        >>> pt2 = Point(4,5,6)
        >>> pt1.interpolate(pt2)
        Point(2.5, 3.5, 4.5)
        >>> pt1.interpolate(pt2, frac=2/3.)
        Point(3.0, 4.0, 5.0)
        """
        if isinstance(other, AbstractPoint):
            return self + (other - self) * frac
        else:
            msg = ("other should be of type Point|Axis|Position|, not: {}. "
                   "Object: {}.")
            raise RuntimeError(msg.format(type(other), self))

    def translate(self, *args, **kwargs):
        """Translate point along a (named) vector over distance. Named vectors like 'x', 'y',
        'front' are inpreted in a global reference frame. So, 'x' corresponds to Vector(1,0,0).
        Note that if you want to just add a vector to a point, use notation: pt + V.
        All translations are relative to the point itself. If you want to fix a coordinate, use
        one of capitalized inputs: 'X', 'Y', 'Z'.

        :param args: sequence of (named) vector - number pairs
        :param kwargs: dictionary of named vector - number pairs.
            Format ``{str : number, ...}``.
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Point`

        >>> pt = Point(1,1,1)
        >>> pt.translate(Vector(1,0,0), 2)
        Point(3, 1, 1)
        >>> pt.translate('x', 2)
        Point(3, 1, 1)
        >>> pt.translate(x=2)
        Point(3, 1, 1)
        >>> pt.translate(X=2)
        Point(2, 1, 1)
        >>> pt.translate(Vector(1,0,0), 2, 'y', 3, z_ = 4)
        Point(3, 4, -3)
        >>> pt.translate('X', 2, 'y', 3, z_ = 4)
        Point(2, 4, -3)
        """
        # assert len(args) % 2 == 0, "*args tuple should of even length (vector, angle, ...)\nNot: %s" % (args)
        # args = args + tuple(a for b in kwargs.iteritems() for a in b)

        pt = list(self)

        if args:
            args = iter(args)
            for v, d in zip(args, args):
                if v == 'X':
                    pt[0] = d
                elif v == 'Y':
                    pt[1] = d
                elif v == 'Z':
                    pt[2] = d
                else:
                    v = Vector.ensure_vector(v)
                    pt[0] += v[0] * d
                    pt[1] += v[1] * d
                    pt[2] += v[2] * d

        for v, d in kwargs.items():
            if v == 'X':
                pt[0] = d
            elif v == 'Y':
                pt[1] = d
            elif v == 'Z':
                pt[2] = d
            else:
                v = Vector.ensure_vector(v)
                pt[0] += v[0] * d
                pt[1] += v[1] * d
                pt[2] += v[2] * d

        return Point(*pt)

    __call__ = translate

    def rotate(self, *args, **kwargs):
        """Rotates point around Point(0,0,0). See rotate_around for more details.

        :param args: tuple of vector and number pairs
        :param kwargs: dict of vector and number pairs. One argument can
            be deg=True to specify rotation in degrees. Format:
            ``{Vector|str : number, ..., deg=<bool>}``
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Point`
        """
        return self.rotate_around(ORIGIN, *args, **kwargs)

    def rotate90(self, vector, *more_vectors):
        """Rotates point for a quarter (90 degrees) around Point(0,0,0).
        See rotate_quarter_around for more details.

        :param vector: Vector to rotate around
        :param more_vectors: more vectors for subsequent rotations
        :type vector: :class:`Vector` | str
        :type more_vectors: :class:`Vector` | str
        :rtype: :class:`Point`
        """
        return self.rotate90_around(ORIGIN, vector, *more_vectors)

    # deprecated
    rotate_quarter = rotate90

    def rotate_around(self, ref, *args, **kwargs):
        """Rotates point around reference `ref`. Each next argument is a (named) vector followed
        by a angle (radians). You can follow this with more rotation vectors and angles, these
        are interpolated as rotation in **sequence** (one after the other).

        :param ref: reference point for rotation
        :param args: tuple of vector and number pairs
        :param kwargs: dict of vector and number pairs. One argument can
            be deg=True to specify rotation in degrees. Format:
            ``{Vector|str : number, ..., deg=<bool>}``
        :type ref: :class:`Point` | :class:`Position`
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Point`

        >>> pt = Point()
        """
        assert isinstance(ref, AbstractPoint)
        if not len(args) % 2 == 0:
            raise Exception("*args tuple should of even length (vector, angle, ...)"
                            " Not: '%s'" % args)
        deg = kwargs.pop('deg', False)
        args = args + tuple(a for b in kwargs.items() for a in b)
        pt = self
        for v, angle in by_pairs(args):
            v = Vector.ensure_vector(v)
            v1 = pt - ref  # a vector
            v2 = v1.rotate(v, angle, deg=deg)
            pt = ref + v2
        return pt

    def rotate90_around(self, ref, vector, *more_vectors):
        """Rotates point for a quarter circle (90 degrees) around reference point. Like
        Point.rotate_around, but you don't specify angles.

        :param ref: reference point for rotation
        :param vector: Vector to rotate around
        :param other_vectors: more vectors for subsequent rotations
        :type ref: :class:`Point` | :class:`Position`
        :type vector: :class:`Vector` | str
        :type other_vectors: :class:`Vector` | str
        :rtype: :class:`Point`

        >>> pt = Point()

        """
        assert isinstance(ref, AbstractPoint)
        vectors = (vector,) + more_vectors
        pt = self
        for v in vectors:
            v = Vector.ensure_vector(v)
            v1 = pt - ref  # a vector
            v2 = v1.rotate_quarter(v)
            pt = ref + v2
        return pt

    # deprecated
    rotate_quater_around = rotate90

    def distance_to_plane(self, reference, normal=None, signed=False):
        """Distance between this point and the plane defined by ``reference``
        and ``normal``, with given ``tolerance``. Various plane definitions are
        possible:

        1. point and vector: ``reference`` should be a :class:`Point` and
            ``normal`` a :class:`Vector`.
        2. axis: ``reference`` should be a :class:`Axis`. ``normal``
            can be left empty, axis vector is taken as normal.
        3. axis system: ``reference`` should be a :class:`Position`. ``normal``
            can be left empty, z-axis is taken as normal.
        4. *planar* surface: ``reference`` should be a
            :class:`~parapy.geom.Surface` instance. ``normal`` can be left
            empty, :meth:`~parapy.geom.Surface.point` is used to get a point
            on the (basis) surface and
            :attr:`~parapy.geom.Surface.plane_normal` is taken as normal.

        >>> from parapy.geom import (Point, Vector, Axis, Orientation,
        ...                          Position, Plane, RectangularSurface)
        >>> pt = Point(0, 0, 1)
        >>> # case 1: plane defined by Point and Vector
        >>> pt.distance_to_plane(Point(0, 0, 0), Vector(0, 0, 1))  # doctest: +ELLIPSIS
        1...
        >>> # case 2: plane defined by Axis
        >>> ref = Axis(Point(0, 0, 0), Vector(0, 0, 1))
        >>> pt.distance_to_plane(ref)  # doctest: +ELLIPSIS
        1...
        >>> # case 3: plane defined by Position
        >>> ref = Position(Point(0, 0, 0), Orientation(Vector(1, 0, 0),
        ...                                            Vector(0, 1, 0)))
        >>> pt.distance_to_plane(ref)  # doctest: +ELLIPSIS
        1...
        >>> # case 4a: surface defined by Plane
        >>> ref = Plane(Point(0, 0, 0), Vector(0, 0, 1))
        >>> pt.distance_to_plane(ref)  # doctest: +ELLIPSIS
        1...
        >>> # case 4b: another planar surface
        >>> ref = RectangularSurface(2, 1)
        >>> pt.distance_to_plane(ref)  # doctest: +ELLIPSIS
        1...

        :param reference: a Point, Axis, Position or Plane
        :type reference: Point | Axis | Position | parapy.geom.Plane
        :param normal: plane normal. No need to specify, if ``reference`` is
            Axis, Position or Plane
        :type normal: Vector | None
        :param signed: When False the distance is always >= 0;
            When True the distance will be negative when this point
            lies in the halfspace opposite to were the plane's normal
            points to.
        :type signed: bool
        :rtype: float
        :raises RuntimeError: if specified ``reference`` surface isn't planar.
        """
        if isinstance(reference, Point):
            location = reference
            if normal is None:
                msg = "If reference is Point, specify normal."
                raise RuntimeError(msg)
        elif isinstance(reference, Axis):
            location = reference.location
            if normal is None:
                normal_ = reference.vector.normalized
        elif isinstance(reference, Position):
            location = reference.location
            if normal is None:
                normal_ = reference.orientation.z
        # TODO (TBD): get rid of duck-typing. Author: RvD.
        elif hasattr(type(reference), "plane_normal"):
            location = reference.point(0, 0)
            if normal is None:
                normal_ = reference.plane_normal
        else:
            msg = ("reference type is either Point, Axis, Position or Plane, "
                   "not: {}")
            raise ValueError(msg.format(reference))

        if normal is not None:
            normal_ = normal.normalized

        v = self - location
        distance = Vector.dot(v, normal_)
        if not signed:
            distance = abs(distance)
        return distance

    def in_plane(self, reference, normal=None, tolerance=1.0e-7):
        """Does this point lie inside the plane defined by ``reference`` and
        ``normal``, with given ``tolerance``? Various plane definitions are
        possible:

        1. point and vector: ``reference`` should be a :class:`Point` and
            ``normal`` a :class:`Vector`.
        2. axis: ``reference`` should be a :class:`Axis`. ``normal``
            can be left empty, axis vector is taken as normal.
        3. axis system: ``reference`` should be a :class:`Position`. ``normal``
            can be left empty, z-axis is taken as normal.
        4. *planar* surface: ``reference`` should be a
            :class:`~parapy.geom.Surface` instance. ``normal`` can be left
            empty, :meth:`~parapy.geom.Surface.point` is used to get a point
            on the (basis) surface and
            :attr:`~parapy.geom.Surface.plane_normal` is taken as normal.

        >>> from parapy.geom import (Point, Vector, Axis, Orientation,
        ...                          Position, Plane, RectangularSurface)
        >>> pt = Point(1, 0, 0)
        >>> # case 1: plane defined by Point and Vector
        >>> pt.in_plane(Point(0, 0, 0), Vector(0, 0, 1))
        True
        >>> # numeric tolerances apply
        >>> pt_tol = Point(1, 0, 1.0e-3)
        >>> pt_tol.in_plane(Point(0, 0, 0), Vector(0, 0, 1))
        False
        >>> pt_tol.in_plane(Point(0, 0, 0), Vector(0, 0, 1), tolerance=2.0e-3)
        True
        >>> # case 2: plane defined by Axis
        >>> ref = Axis(Point(0, 0, 0), Vector(0, 0, 1))
        >>> pt.in_plane(ref)
        True
        >>> # case 3: plane defined by Position
        >>> ref = Position(Point(0, 0, 0), Orientation(Vector(1, 0, 0),
        ...                                            Vector(0, 1, 0)))
        >>> pt.in_plane(ref)
        True
        >>> # case 4a: surface defined by Plane
        >>> ref = Plane(Point(0, 0, 0), Vector(0, 0, 1))
        >>> pt.in_plane(ref)
        True
        >>> # case 4b: another planar surface
        >>> ref = RectangularSurface(2, 1)
        >>> pt.in_plane(ref)
        True

        :param reference: a Point, Axis, Position or Plane
        :type reference: Point | Axis | Position | parapy.geom.Plane
        :param normal: plane normal. No need to specify, if ``reference`` is
            Axis, Position or Plane
        :type normal: Vector | None
        :param float tolerance: numeric tolerance for determining if this
            point lies in plane.
        :rtype: bool
        :raises RuntimeError: if specified ``reference`` surface isn't planar.
        """
        d = self.distance_to_plane(reference, normal=normal)
        return d < tolerance

    def project(self, ref, axis1=None, axis2=None, relative=False):
        """Project this Point onto a line or plane located at ``ref``.
        Reference ``ref`` can be of type Point, Axis, Position. If ``ref`` is
        of type :class:`Point`, you need to additionally specify:

        - ``axis1`` for projection onto a line

        Optionally, you can also specify:

        - ``axis2`` for projection onto a plane

        If ``ref`` is of type :class:`Axis`, the default behavior is line
        projection where ``axis1 = Axis.vector``. However ``axis2`` can
        still be specified for plane projection.

        If ``ref`` is of type :class`Position`, the default behavior is Plane
        projection where ``axis1 = Position.Vx`` and ``axis2 = Position.Vy``.

        You can always override ``axis1`` and ``axis2`` by specifying them
        though, in which case only the location of Axis/Position are used.

        By default, returned coordinates are in the globals axis system. If
        you want the coordinates in the new *axis system* as defined by
        the combination of ``ref`` and the axes, set ``relative`` to True.
        For line projection, the x-coordinate will be set (y and z are zero).
        For plane projection, x- and y-coordinates will be defined (z is zero).

        >>> # line projection
        >>> ORIGIN.project(Point(1, 1, 1),
        ...                axis1=Vector(1, 1, 0))
        Point(0.0, 0.0, 1.0)
        >>> ORIGIN.project(Point(1, 1, 1),
        ...                axis1=Vector(1, 1, 0),
        ...                relative=True)  # doctest: +ELLIPSIS
        Point(-1.4142..., 0.0, 0.0)
        >>> # plane projection
        >>> ORIGIN.project(Point(1, 1, 1),
        ...                axis1=Vector(1, 0, 0),
        ...                axis2=Vector(0, 1, 0))
        Point(0.0, 0.0, 1.0)
        >>> ORIGIN.project(Point(1, 1, 1),
        ...                axis1=Vector(1, 0, 0),
        ...                axis2=Vector(0, 1, 0),
        ...                relative=True)
        Point(-1.0, -1.0, 0.0)

        :param Point | Axis | Position ref: reference location for projection
        :param Vector | None axis1: vector for line reflection
        :param Vector | None axis2: second vector for plane reflection
        :param bool relative: return Point in coordinates relative to ``ref``
            system.
        :rtype: Point
        """
        if not isinstance(ref, AbstractPoint):
            msg = ("Your ref is not of type Point, Axis or Position, but {}. "
                   "Object: {}.")
            raise ValueError(msg.format(type(ref), self))

        if axis1 is not None:
            axis1 = Vector.ensure_vector(axis1).normalized
        if axis2 is not None:
            axis2 = Vector.ensure_vector(axis2).normalized

        if isinstance(ref, Point) and axis1 is None:
            msg = ("Your reference is a Point, so please specify axis1 "
                   "(and optionally axis2). Object: {}.")
            raise RuntimeError(msg.format(self))
        if isinstance(ref, Axis) and axis1 is None:
            axis1 = axis1 or ref.vector
        elif isinstance(ref, Position):
            axis1 = axis1 or ref.Vx
            axis2 = axis2 or ref.Vy

        if axis2 is None:
            # line projection
            v = self - ref  # vector from ref to me
            if relative:
                x = v.dot(axis1)  # magnitude in axis1 direction
                return Point(x, 0.0, 0.0)
            else:
                v1 = v.project(axis1)  # component in axis1 direction
                return self - v + v1
        else:
            # plane projection
            if relative:
                v = self - ref
                x = v.dot(axis1)
                y = v.dot(axis2)
                return Point(x, y, 0.0)
            else:
                n = axis1.cross(axis2)  # plane normal
                v = ref - self
                vn = v.project(n)
                return self + vn

    def reflect(self, ref, axis1=None, axis2=None):
        """Reflect this Point into another point, a line or plane located
        at ``ref``. Reference ``ref`` can be of type Point, Axis, Position.
        If ``ref`` is of type :class:`Point`, you can additionally specify:

        - ``axis1`` for reflection into a line
        - ``axis2`` for reflection into a plane

        If ``ref`` is of type :class:`Axis`, the default behavior is line
        reflection where ``axis1 = Axis.vector``. However ``axis2`` can
        still be specified for plane reflection.

        If ``ref`` is of type :class`Position`, the default behavior is Plane
        reflection where ``axis1 = Position.Vx`` and ``axis2 = Position.Vy``.

        You can always override ``axis1`` and ``axis2`` by specifying them
        though, in which case only the location of Axis/Position are used.

        >>> # point reflection
        >>> ORIGIN.reflect(Point(1, 1, 1))
        Point(2, 2, 2)
        >>> # line reflection
        >>> ORIGIN.reflect(Point(1, 1, 1), axis1=Vector(1, 0, 0))
        Point(0.0, 2.0, 2.0)
        >>> # plane reflection
        >>> ORIGIN.reflect(Point(1, 1, 1), axis1=Vector(1, 0, 0), axis2=Vector(0, 1, 0))
        Point(0.0, 0.0, 2.0)

        :param Point | Axis | Position ref: reference location for reflection
        :param Vector | str | None axis1: vector for line reflection
        :param Vector | str | None axis2: second vector for plane reflection
        :rtype: Point
        """
        if not isinstance(ref, AbstractPoint):
            msg = ("Your ref is not of type Point, Axis or Position, but {}. "
                   "Object: {}.")
            raise ValueError(msg.format(type(ref), self))

        if axis1 is not None:
            axis1 = Vector.ensure_vector(axis1).normalized
        if axis2 is not None:
            axis2 = Vector.ensure_vector(axis2).normalized

        if isinstance(ref, Axis) and axis1 is None:
            axis1 = ref.vector
        elif isinstance(ref, Position):
            if axis1 is None:
                axis1 = ref.Vx
            if axis2 is None:
                axis2 = ref.Vy

        if axis1 is None and axis2 is None:
            # point reflection
            v = ref - self
            return self + 2 * v
        elif axis2 is None:
            # line reflection
            v1 = ref - self
            v2 = -v1.project(axis1)
            return self + 2 * (v1 + v2)
        else:
            # plane reflection
            n = axis1.cross(axis2)
            v = ref - self
            vn = v.project(n)
            return self + 2 * vn

    mirror = reflect

    def expressed_in(self, pos, from_pos=None):
        """Return this ``Point`` expressed relative to ``pos``. Use
        ``from_pos`` when this ``Point`` is not defined relative to the
        global coordinate system (``XOY``).

        :param Position pos: position relative to which this ``Point`` should
            be expressed.
        :param Position from_pos: position relative to this ``Point`` is
            currently expressed. (default: ``XOY``).
        :rtype: Point
        """
        from_pos = from_pos or XOY
        to_mat = pos.orientation.mat
        from_mat = from_pos.orientation.mat
        inverse_to_mat = _invert_3x3_matrix(to_mat)

        vec = self.vector + from_pos.location.vector
        vec = Vector(*_matrix_times_vector(from_mat, vec))
        vec = vec - pos.location.vector
        pnt = Point(*_matrix_times_vector(inverse_to_mat, vec))
        return pnt

    def polygon(self, *args):
        """Create a polygon of Position instances.

        :param args: sequence of (named) vector - number pairs
        :type args: :class:`Vector` | str | numbers.Number
        :returns: [Point, ...]
        :rtype: list
  
        >>> foo = Point()
        >>> foo.polygon('x', 2, ('x', 'y'), (5, 1), 'y', 10)
        [Point(0, 0, 0), Point(2, 0, 0), Point(7, 1, 0), Point(7, 11, 0)]"""

        assert len(args) % 2 == 0, "supply even number of args: ['key', value]*"

        pos = self
        result = [self]
        for k, v in by_pairs(args):
            if hasattr(v, '__iter__'):
                pos = pos(*[j for i in zip(k, v) for j in i])
                result.append(pos)
            else:
                pos = pos(k, v)
                result.append(pos)
        return result


ORIGIN = Point()


class Vector(Tuple3D):
    """
    The basic Vector class. It's a subclass of tuple, to make it immutable.
    """

    point = property(lambda self: Point(*self))

    @classmethod
    def ensure_vector(cls, vector, normalize=True):
        """Ensures that ``vector`` is a proper Vector instance. Specified ``vector`` can be:
        1. a Vector instance --> returned as is
        2. a string naming a direction --> returns associated principle Vector
        3. an iterable of length three --> converted to Vector. 
        
        :rtype: :class:`Vector`
        :raises: WrongArguments
            
        >>> Vector.ensure_vector(Vector(1, 0, 0))
        Vector(1, 0, 0)
        >>> Vector.ensure_vector((1, 0, 0))
        Vector(1, 0, 0)
        >>> Vector.ensure_vector([1, 0, 0])
        Vector(1, 0, 0)
        >>> Vector.ensure_vector('x')
        Vector(1, 0, 0)
        >>> Vector.ensure_vector('front')
        Vector(0, -1, 0)
        >>> Vector.ensure_vector(False)
        Traceback (most recent call last):
            ...
        TypeError: Don't know how to convert False into a Vector instance.
        """
        if isinstance(vector, str):
            return cls(*key_to_vector_tuple(vector))
        elif isinstance(vector, cls):
            return vector
        elif hasattr(vector, "__iter__") and len(vector) == 3:
            return cls(*vector)
        else:
            msg = "Don't know how to convert {!r} into a Vector instance."
            raise TypeError(msg.format(vector))

    def __add__(self, other):
        """Adds the specified Vector to this Vector and returns a **Vector**

        >>> v1 = Vector(1, 2, 3)
        >>> v2 = Vector(0, 1, 2)
        >>> v1 + v2
        Vector(1, 3, 5)

        .. note:: Vector + Point is allowed, but implemented in Point.__radd__

        :param other: other Vector
        :type other: :class:`Vector`
        :rtype: :class:`Vector` | NotImplemented
        """
        if isinstance(other, Vector):
            return Vector(self[0] + other[0], self[1] + other[1], self[2] + other[2])
        else:
            return NotImplemented

    def __sub__(self, other):
        """New vector that is the subtraction 2 vectors: ``self - other``.

        >>> pt1 = Point(1, 2, 3)
        >>> pt2 = Point(0, 1, 2)
        >>> v2 = Vector(0, 1, 2)
        >>> pt1 - pt2
        Vector(1, 1, 1)
        >>> pt1 - v2
        Point(1, 1, 1)

        :param other: other Vector
        :type other: :class:`Vector`
        :rtype: :class:`Vector` | NotImplemented
        """
        if isinstance(other, Vector):
            u1, v1, w1 = self
            u2, v2, w2 = other
            return Vector(u1 - u2, v1 - v2, w1 - w2)
        else:
            return NotImplemented

    def __mul__(self, other):
        """Multiplication has five modes:

        1. Vector * number: Multiplies the specified scalar by the specified
            vector and returns the resulting Vector.
        2. Vector * Vector: Calculates the dot product of the two specified
            vectors and returns the result as a number.
        3. Vector * Orientation: Transforms the coordinate space of the
            specified vector using the specified Orientation matrix.
        
        And in Vector.__rmul__:

        4. number * Vector: Multiplies the specified scalar by the specified
            vector and returns the resulting Vector.
        5. Orientation * Vector:

        :param other: other number, vector or orientation
        :type other: number.Number | :class:`Vector` | :class:`Orientation`
        :rtype: :class:`Vector` | number.Number | NotImplemented
            
        >>> v1 = Vector(1, 0, 0)
        >>> v2 = Vector(0, 1, 0)
        >>> s = 2
        >>> O = Orientation().rotate_quarter('y')
        >>> v1 * s
        Vector(2, 0, 0)
        >>> v1 * v2  # dot product
        0
        >>> v1 * O
        Vector(-1.0, 0.0, 0.0)
        """
        if isinstance(other, Number):
            u, v, w = self
            return Vector(other * u, other * v, other * w)
        elif isinstance(other, Vector):
            return self.dot(other)
        elif isinstance(other, Orientation):
            return Vector(*_vector_times_matrix(self, other.mat))
        else:
            return NotImplemented

    def __rmul__(self, other):
        if isinstance(other, Number):
            u, v, w = self
            return Vector(other * u, other * v, other * w)
        elif isinstance(other, Vector):
            return self.dot(other)
        elif isinstance(other, Orientation):
            return Vector(*_matrix_times_vector(other.mat, self))
        else:
            return NotImplemented

    def __div__(self, other):
        if isinstance(other, Number):
            u, v, w = self
            return self.__class__(u / other, v / other, w / other)
        return NotImplemented

    __truediv__ = __div__

    @property
    def length(self):
        """Gets the length of this vector.

        :rtype: float
        """
        u, v, w = self
        return math.sqrt(u ** 2 + v ** 2 + w ** 2)

    # TODO: use synonyms?
    magnitude = norm = length

    @property
    def length_squared(self):
        """Gets the square of the length of this vector.

        :rtype: float
        """
        u, v, w = self
        return u ** 2 + v ** 2 + w ** 2

    # TODO: use synonyms?
    # magnitude_squared = norm_squared = length_squared

    @property
    def normalize(self):
        """returns normalized vector.

        >>> from parapy.geom import Vector
        >>> Vector(1, 1, 0).normalized
        Vector(0.707106781187, 0.707106781187, 0.0)

        :rtype: Vector
        """
        u, v, w = self
        mag = math.sqrt(u ** 2 + v ** 2 + w ** 2)
        return Vector(u / mag, v / mag, w / mag)

    normalized = normalize

    def cross(self, other_vector):
        """Return a new vector that is the cross product of both vectors.

        >>> Vector(1.0, 0.0, 0.0).cross(Vector(0.0, 1.0, 0.0))
        Vector(0.0, 0.0, 1.0)

        :param other_vector: other vector
        :type other_vector: :class:`Vector`
        :rtype: :class:`Vector`
        """
        u1, v1, w1 = self
        u2, v2, w2 = other_vector

        x = v1 * w2 - w1 * v2
        y = w1 * u2 - u1 * w2
        z = u1 * v2 - v1 * u2

        # return Vector(x, y, z)
        return Vector(x + 0, y + 0, z + 0)  # removes -0 case

    # synonym
    cross_product = cross

    def dot(self, other_vector):
        """Dot product of two vectors.

        >>> Vector(1.0, 0.0, 0.0).dot(Vector(1.0, 1.0, 0.0))
        1.0
        >>> Vector(1.0, 0.0, 0.0).dot(Vector(0.0, 1.0, 0.0))
        0.0

        :rtype: float
        """
        u1, v1, w1 = self
        u2, v2, w2 = other_vector
        return u1 * u2 + v1 * v2 + w1 * w2

    def project(self, other_vector):
        """Project this vector on ``other_vector``.

        >>> Vector(1, 0, 1).project(Vector(1, 0, 0))
        Vector(1.0, 0.0, 0.0)
        >>> # projecting orthogonal vectors, gives zero vector back
        >>> Vector(0, 1, 0).project(Vector(1, 0, 0))
        Vector(0.0, 0.0, 0.0)

        :param other_vector: other vector
        :type other_vector: :class:`Vector`
        :rtype: :class:`Vector`
        """
        return (self * other_vector) / other_vector.length_squared * other_vector

    def project_on_plane(self, plane_normal):
        """Project this vector on plane with given ``plane_normal``.

        >>> Vector(1, 0, 1).project_on_plane(Vector(0, 0, 1))
        Vector(1.0, 0.0, 0.0)

        :param plane_normal: Vector.
        :type plane_normal: :class:`Vector`
        :rtype: Vector
        """
        return self - self.project(plane_normal)

    # synonym
    dot_product = dot

    def is_parallel(self, other_vector, tol=None):
        """Is this vector parallel to ``other_vector`` within tolerance
        ``tol``?

        Usage:

        >>> from parapy.geom import Vector
        ...
        >>> Vector(1, 0, 0).is_parallel(Vector(1, 0, 0))
        True
        >>> Vector(1, 0, 0).is_parallel(Vector(2, 0, 0))
        True
        >>> Vector(1, 0, 0).is_parallel(Vector(-2, 0, 0))
        True
        >>> Vector(1, 0, 0).is_parallel(Vector(1, 0.01, 0))
        False
        >>> # To control when considered parallel, specify the tolerance.
        >>> Vector(1, 0, 0).is_parallel(Vector(1, 0.01, 0), tol=0.1)
        True

        :param Vector other_vector:
        :param float | None tol: Optional tolerance for parallellity. If
            None (default), value in CONFIGURATION["tolerance"] is used.
        :rtype: bool
        """
        v = self.cross(other_vector)
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return v.is_zero_tol(tol=tol)

    def is_orthogonal(self, other_vector, tol=None):
        """Is this vector orthogonal to other_vector?

        :param other_vector: other vector
        :type other_vector: :class:`Vector`
        :param tol: Tolerance for orthogality
        :type tol: float | None
        :rtype: bool
        """
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return abs(self.normalize * other_vector.normalize) <= tol

    def in_plane_orthogonal(self, other_vector, normalize=False, tol=None):
        """Return a vector that is orthogonal to this vector and in the plane
        spanned by this vector and ``other_vector``. Set ``normalized`` to
        :py:`True` to force the result to be normalized. To control
        parallelity, specify :py:`tol`.

        Usage:

        >>> from parapy.geom import Vector
        ...
        >>> vector = Vector(1, 0, 0)
        >>> vector.in_plane_orthogonal(Vector(1, 1, 0))
        Vector(0, 1, 0)
        >>> vector.in_plane_orthogonal(Vector(1, 2, 0))
        Vector(0, 2, 0)
        >>> vector.in_plane_orthogonal(Vector(1, 2, 0), normalize=True)
        Vector(0.0, 1.0, 0.0)
        >>> vector.in_plane_orthogonal(Vector(1, 0.01, 0)) # almost parallel
        Vector(0.0, 0.01, 0.0)
        >>> # To control when considered parallel, specify the tolerance.
        >>> vector.in_plane_orthogonal(Vector(1, 0.01, 0), tol=0.1)  # doctest: +ELLIPSIS
        Traceback (most recent call last):
            ...
        ValueError: Couldn't define a plane because vectors are parallel...

        :param parapy.geom.Vector other_vector: A vector not parallel to
            this vector.
        :param bool normalize: Return a normalized vector?
        :param float|None tol: Optional tolerance for parallelity. If None
            (default), value in CONFIGURATION["tolerance"] is used.
        :rtype: parapy.geom.Vector
        :raises ValueError: When this vector and ``other_vector`` are parallel.
        """
        cross_vector = self.cross(other_vector)
        if cross_vector.is_zero_tol(tol=tol):
            msg = ("Couldn't define a plane because vectors are parallel "
                   "within parallelity tolerance. Use other vectors or "
                   "decrease tolerance.")
            raise ValueError(msg)

        other_vector = cross_vector.cross(self)
        if normalize:
            other_vector = other_vector.normalized
        return other_vector

    def angle(self, other_vector, deg=False):
        """Smallest angle between the two vectors. By default, angle is in
        radians. For degrees, set :py:`deg=True`.

        >>> v1 = Vector(1, 0, 0)
        >>> v2 = Vector(1, 1, 0)
        >>> v1.angle(v2, deg=True)
        45.00000000000001

        :param Vector other_vector: other vector
        :param bool deg: :py:`True` for degrees.
        :returns: angle
        :rtype: float
        """
        angle = vector_angle(self, other_vector)
        return math.degrees(angle) if deg else angle

    def angle_and_axis(self, other_vector, deg=False):
        """Smallest angle between the two vectors and normalized rotation vector. By default, 
        angle is in radians. For degrees, set :py:`deg=True`.
        
        >>> v1 = Vector(1, 0, 0)
        >>> v2 = Vector(1, 1, 0)
        >>> v1.angle_and_axis(v2, deg=True)
        (45.00000000000001, Vector(0.0, 0.0, 1.0))

        :param Vector other_vector: other vector
        :param bool deg: :py:`True` for degrees.
        :returns: angle, rotation vector
        :rtype: (float, Vector)
        """
        v1 = self.normalize
        v2 = other_vector.normalize
        angle = vector_angle(v1, v2, inputs_normalized=True)
        w = v1.cross(v2).normalize
        return math.degrees(angle) if deg else angle, w

    # synonym
    angle_between = angle

    @property
    def is_zero(self):
        return self.is_zero_tol()

    def is_zero_tol(self, tol=None):
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return abs(self[0]) <= tol and abs(self[1]) <= tol and abs(self[2]) <= tol

    def interpolate(self, other_vector, frac=0.5):
        """Return new :class:`Vector` interpolated between this and
        ``other_vector``.

        :param Vector other_vector: other vector
        :param float frac: fraction for interpolation.
        :rtype: Vector
        """
        if isinstance(other_vector, Vector):
            return self + (other_vector - self) * frac
        else:
            raise NotImplementedError("other_vector should be a Vector, not: %s" % type(other_vector))

    def rotate(self, *args, **kwargs):
        """Similar signature as :meth:`Point.rotate`

        :rtype: :class:`Vector`
        """
        assert len(args) % 2 == 0, "*args tuple should of even length (vector, angle, ...)\nNot: %s" % (args)
        # pop deg from kwargs
        deg = kwargs.pop('deg', False)
        args = args + tuple(a for b in kwargs.items() for a in b)

        vector = self
        for v, angle in by_pairs(args):
            v = Vector.ensure_vector(v)
            vector = Orientation.R(v, angle, deg) * vector
        return vector

    def rotate90(self, vector, *other_vectors):
        """Similar signature as :meth:`Point.rotate90`.

        :rtype: :class:`Vector`
        """
        vectors = (vector,) + other_vectors
        angle = 0.5 * math.pi
        vector = self
        for v in vectors:
            v = Vector.ensure_vector(v)
            vector = Orientation.R(v, angle) * vector
        return vector

    # deprecated
    rotate_quarter = rotate90

    def reflect(self, axis1=None, axis2=None):
        """Performs the reflection of a Vector with respect to
        
        - ``axis1`` for reflection in a line. Additionally,
        - ``axis2`` for reflection in a plane
        
        If axis1 and axis2 are None, the vector is simply reversed.

        :param Vector | str | None axis1: vector for line reflection
        :param Vector | str | None axis2: second vector for plane reflection
        :rtype: Vector
        """
        if axis1 is not None:
            axis1 = Vector.ensure_vector(axis1).normalized
        if axis2 is not None:
            axis2 = Vector.ensure_vector(axis2).normalized

        if axis1 is None and axis2 is None:
            # point reflection
            return -self
        elif axis2 is None:
            # line reflection
            v = self.project(axis1)
            return -self + 2 * v
        else:
            # plane reflection
            n = axis1.cross(axis2)
            v = self.project(n)
            return self - 2 * v

    mirror = reflect


class Orientation(namedtuple('Orientation', 'x y z'), ParaPyObject):
    """3D Orientation class.

    To instantiate a new Orientation object, typically you specify two orthogonal vectors.
    The third component is automatically computed. So, if you specify x and y, z will be the 
    cross product. Likewise, if you specify x and z, y is computed, or is you specify y and z,
    x is computed.
    Warning: in case you specify all three axes, no checking is done for orthogonality.
    If you specify no axes at all, you'll get the identity matrix.
    
    The specified vectors are seen as column vectors. The internal representation of an Orientation
    object for computational purposes is a [3x3] matrix, accessible through ``Orientation.mat``,
    It's relations to the vectors is::
    
        ((x[0], y[0], z[0]),
         (x[1], y[1], z[1]),
         (x[2], y[2], z[2])))
    
    >>> O = Orientation()
    Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))
    >>> O = Orientation(x=Vector(-1,0,0), y=Vector(0,-1,0)
    Orientation(x=Vector(-1,0,0),y=Vector(0,-1,0),z=Vector(0,0,-1))
    >>> O = Orientation(mat=  )
    """

    __initargs__ = ['x', 'y', 'z', 'mat']
    __newargs__ = __initargs__
    _tree_attrs = ['x', 'right', 'Vx',
                   'y', 'rear', 'Vy',
                   'z', 'up', 'top', 'Vz',
                   'x_', 'left', 'Vx_',
                   'y_', 'front', 'Vy_',
                   'z_', 'down', 'bottom', 'Vz_']

    # convenience property for Position
    orientation = property(lambda self: self)

    @classmethod
    def R(cls, vector, angle, deg=False):
        """Makes a 3x3 rotation matrix.

        Returns:
            Orientation
        """
        vector = Vector.ensure_vector(vector)
        angle = angle if deg is False else math.radians(angle)
        u = vector.normalize
        ux = u[0]
        uy = u[1]
        uz = u[2]
        cosa = math.cos(angle)
        cosat = 1 - cosa
        sina = math.sin(angle)
        R = (((cosa + ux * ux * cosat, ux * uy * cosat - uz * sina, ux * uz * cosat + uy * sina),
              (uy * ux * cosat + uz * sina, cosa + uy * uy * cosat, uy * uz * cosat - ux * sina),
              (uz * ux * cosat - uy * sina, uz * uy * cosat + ux * sina, cosa + uz * uz * cosat)))
        return Orientation(mat=R)

    def ensure_vector(self, vector, normalize=True):
        """Ensures that ``vector`` is a proper **normalize** Vector instance. Specified ``vector`` can be:
        1. a Vector instance --> returned normalize version
        2. a string naming a direction --> returns associated principle Vector **in current Orientation**
        3. an iterable of length three --> converted to Vector. 

        Returns:
            Vector
        
        Raises:
            WrongArguments
            
        Examples:
        >>> O = Orientation().rotate_quarter('z')
        >>> Vector.ensure_vector(Vector(1,0,0))
        Vector(1,0,0)
        >>> Vector.ensure_vector((1,0,0))
        Vector(1,0,0)
        >>> Vector.ensure_vector([1,0,0])
        Vector(1,0,0)
        >>> Vector.ensure_vector('x')
        Vector(0,1,0)
        >>> Vector.ensure_vector('front')
        Vector(1,0,0)
        >>> Vector.ensure_vector(False)
        Traceback (most recent call last):
            ...
        TypeError: Don't know how to convert False into a Vector instance.
        """
        if isinstance(vector, str):
            try:
                # optimization: don't call key_to_main_key
                return getattr(self, KEY_MAIN_KEY[vector])
            except KeyError:
                # will raise better error
                key_to_main_key(vector)
        elif isinstance(vector, Vector):
            return vector.normalize if normalize else vector
        else:
            try:
                return Vector(*vector).normalize if normalize else Vector(*vector)
            except:
                raise TypeError("Don't know how to convert %s into a Vector instance." % vector)

    def __new__(cls, x=None, y=None, z=None, mat=None):
        """mat is alternative way instantiating"""
        x = x if x is None else Vector.ensure_vector(x).normalize
        y = y if y is None else Vector.ensure_vector(y).normalize
        z = z if z is None else Vector.ensure_vector(z).normalize

        # how many axes are specified?
        spec = len([V for V in [x, y, z] if V is not None])
        if spec == 0:
            if mat is None:
                return super(Orientation, cls).__new__(cls, Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1))
            else:
                # transpose of matrix
                return super(Orientation, cls).__new__(cls, *[Vector(*args) for args in zip(*mat)])
        elif spec == 1:
            raise Exception(
                "You need to specify either 0, 2, or 3 vectors, not 1, because it's ambigous\nYour Inputs: x=%s, y=%s, z=%s" % (
                x, y, z))
        elif spec == 2:
            if x and y:
                if not x.is_orthogonal(y): raise Exception(
                    "x and y vectors are not orthogonal!\nYour Inputs: x=%s, y=%s, z=%s" % (x, y, z))
                z = x.cross(y)
            elif x and z:
                if not x.is_orthogonal(z): raise Exception(
                    "x and z vectors are not orthogonal!\nYour Inputs: x=%s, y=%s, z=%s" % (x, y, z))
                y = z.cross(x)
            else:
                if not y.is_orthogonal(z): raise Exception(
                    "y and z vectors are not orthogonal!\nYour Inputs: x=%s, y=%s, z=%s" % (x, y, z))
                x = y.cross(z)

        return super(Orientation, cls).__new__(cls, x, y, z)

    def __init__(self, x=None, y=None, z=None, mat=None):
        # x, y, and z are now all known
        if mat:
            self.mat = mat
        else:
            self.mat = list(zip(*(self[0], self[1], self[2])))

    #     def __str__(self):
    #         return 'Orientation(x=%s,y=%s,z=%s)' % (self.x, self.y, self.z)
    #
    #     def __repr__(self):
    #         # FIXME: display works confusing. We show row vectors, maybe column vectors?
    #         return 'Orientation(\n            x=%s,\n            y=%s,\n            z=%s)' % (self.x, self.y, self.z)

    def __neg__(self):
        return self.__class__(x=-self[0], y=-self[1])

    def __mul__(self, other):
        """
        Returns result of multiplying 2 Orientations.
        Example:
        A = Orientation()
        R = Orientation.R('x', 30, 'degrees')
        B = A * R
        
        Multiplication with constant is not supported (doesn't make sense)
        """
        if isinstance(other, Orientation):
            # only makes sence for Rotation matrices, to respect orthogonality of Orientation objects.
            return Orientation(mat=_matrix_times_matrix(self.mat, other.mat))
        elif isinstance(other, Vector):
            return Vector(*_matrix_times_vector(self.mat, other))
        else:
            return NotImplemented

    def __rmul__(self, other):
        if isinstance(other, Orientation):
            # only makes sence for Rotation matrices, to respect orthogonality of Orientation objects.
            return Orientation(mat=_matrix_times_matrix(self.mat, other.mat))
        elif isinstance(other, Vector):
            return Vector(*_vector_times_matrix(other, self.mat))
        else:
            return NotImplemented

    def __eq__(self, other):
        return self.is_almost_equal(other)

    def __hash__(self):
        return super(Orientation, self).__hash__()

    def is_almost_equal(self, other, tol=None):
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return (isinstance(other, Orientation) and
                is_almost_equal_mat(self, other, tol))

    @property
    def transpose(self):
        """Returns transpose of me"""
        return Orientation(*zip(*self.mat))

    def align(self, v, w, warn=True):
        """Rotate this Orientation instance such that one of the (principle)
        axes ``v`` gets aligned with a new vector ``w``.

        :param v: (named) (principle) axis e.g. 'x', 'top', etc.
        :type v: str | Vector
        :param w: new vector with which ``v`` should be aligned.
        :type w: str | Vector
        :param bool warn: warn if vectors are parallel and, thus, alignment
            becomes ambiguous?
        :raises UserWarning: if vectors are parallel and ``warn==True``
        :raises Exception: if direction keyword is invalid
        :rtype: Orientation

        Usage:
        >>> O = Orientation()
        Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))
        >>> O.align('x', Vector(0,1,0))
        Orientation(x=Vector(0,1,0),y=Vector(-1,0,0),z=Vector(0,0,1))
        >>> O.align('x', 'y')
        Orientation(x=Vector(0,1,0),y=Vector(-1,0,0),z=Vector(0,0,1))
        """
        # assert isinstance(v, str)
        v_norm = self.ensure_vector(v).normalize
        w_norm = self.ensure_vector(w).normalize
        angle = Vector.angle(v_norm, w_norm)
        rotation_vector = Vector.cross(v_norm, w_norm)
        if rotation_vector.is_zero:
            if isinstance(v, str):
                # principle axis, so use common perpendicular axis
                rotation_vector = key_to_perp_key(v)
            else:
                # use arbitrary orthogonal vector
                rotation_vector = orthogonal_vector(v_norm)
            if warn:
                msg = ("alignment is ambiguous, because vectors are {:} and "
                       "{:} are parallel. Using (arbitrary) vector {:} as "
                       "rotation vector.")
                warnings.warn(msg.format(v_norm, w_norm, rotation_vector))

        return self.rotate(rotation_vector, angle)

    @property
    def x_reverse(self):
        """Returns a new Orientation instance where X is now in opposite direction by rotation over 'z'"""
        return Orientation(x=-self[0], z=self[2])

    @property
    def y_reverse(self):
        """Returns a new Orientation instance whereY is now in opposite direction by rotation over 'x'"""
        return Orientation(y=-self[1], x=self[0])

    @property
    def z_reverse(self):
        """Returns a new Orientation instance where Z is now in opposite direction by rotation over 'y'"""
        return Orientation(z=-self[2], y=self[1])

    @property
    def trace(self):
        """the sum of the elements on the main diagonal
        
        Returns:
            number
        """
        mat = self.mat
        return mat[0][0] + mat[1][1] + mat[2][2]

    def rotation_angle(self, other):
        R = other * self.transpose
        return math.acos((R.trace - 1.0) / 2.0)

    def rotation_axis(self, other):
        raise NotImplementedError()

    def interpolate(self, other_orientation, frac=0.5):
        if isinstance(other_orientation, Orientation):
            return Orientation(self[0].interpolate(other_orientation.x, frac),
                               self[1].interpolate(other_orientation.y, frac),
                               self[2].interpolate(other_orientation.z, frac))
        else:
            raise NotImplementedError("other_orientation should be a Point, not: %s" % type(other_orientation))

    def rotate(self, *args, **kwargs):
        """Rotates an Orientation matrix, similar signature as Point.rotate

        Returns:
            Orientation
        """
        assert len(args) % 2 == 0, "*args tuple should of even length (vector, angle, ...)\nNot: %s" % (args)
        # pop deg from kwargs
        deg = kwargs.pop('deg', False)
        args = args + tuple(a for b in kwargs.items() for a in b)

        orient = self
        for v, angle in by_pairs(args):
            v = self.ensure_vector(v)
            orient = Orientation.R(v, angle, deg=deg) * orient
        return orient

    def rotate_quarter(self, vector, *more_vectors):
        """Rotates an Orientation matrix, similar signature as Point.rotate

        Returns:
            Orientation
        """
        args = (vector,) + more_vectors
        orient = self
        for v in args:
            v = self.ensure_vector(v)
            orient = Orientation.R(v, 0.5 * math.pi) * orient
        return orient

    # ==============================================================================================
    # Other direction keys
    # ==============================================================================================
    x_ = property(lambda self: -self[0])
    y_ = property(lambda self: -self[1])
    z_ = property(lambda self: -self[2])
    right = Vx = property(lambda self: self[0])
    rear = Vy = property(lambda self: self[1])
    top = up = Vz = property(lambda self: self[2])
    left = Vx_ = x_
    front = Vy_ = y_
    bottom = down = Vz_ = z_


# main direction 'Z'
XY = Orientation()


class Axis(AbstractPoint):
    """At the moment only useful for visualization of a vector with an origin in the OCCViewer.
    Obtain these instances through Position.x_axis, Position.y_axis, Position.z_axis
    """

    __initargs__ = ['location', 'vector']
    __newargs__ = ['location', 'vector']
    _tree_attrs = ["location", "vector", "x", "y", "z", "V"]

    def __new__(cls, location, vector):
        return super(AbstractPoint, cls).__new__(cls, *location)

    def __init__(self, location, vector):
        self.location = location
        self.vector = vector
        super(Axis, self).__init__()

    V = property(lambda self: self.vector)


#     def __repr__(self):
#         return "Axis(%s,%s,%s, V=%s)" % (self.x, self.y, self.z, self.vector)


class Position(AbstractPoint):
    """The position of something in space. It has both a location and an
    orientation. For most things in ParaPy, you can use position inputs
    where points are expected, because Position inherits from and, as such,
    behaves like a Point, it just adds an orientation.

    >>> # initialization
    >>> Position()
    Position(location    = Point(0,0,0),
             orientation = Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1)))
    >>> Position(Point(1, 2, 3))
    Position(location    = Point(1,2,3),
             orientation = Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1)))
    >>> Position(Point(1, 2, 3), Orientation(x='y', y='x')
    Position(location    = Point(0,0,0),
             orientation = Orientation(x=Vector(1,0,0),y=Vector(0,0.866025,-0.5),z=Vector(0,0.5,0.866025)))
    >>> # transformations
    >>> pos = Position()
    >>> pos.translate('x', 2)
    Position(Point(2,0,0), ...)
    >>> pos.reflect('x')
    TODO
    """

    __icon__ = os.path.join(ICN_DIR, 'axes.png')

    __initargs__ = ['location', 'orientation', '_check']
    __newargs__ = __initargs__

    _tree_attrs = Orientation._tree_attrs + ["location", "orientation",
                                             'x_axis', 'y_axis', 'z_axis',
                                             'distance_origin']

    def __new__(cls, location=ORIGIN, orientation=XY, _check=True):
        return Tuple3D.__new__(cls, *location)

    def __init__(self, location=ORIGIN, orientation=XY, _check=True):
        """
        :param AbstractPoint location: Default is ``ORIGIN``.
        :param Orientation orientation: Default is ``XY``
        :param bool _check: set to False to skip type checks.
        """
        if _check:
            if not isinstance(location, AbstractPoint) and \
                    isinstance(orientation, Orientation):
                msg = ("Position signature is (Point-like, Orientation), "
                       "not ({:}, {:}).")
                raise RuntimeError(msg.format(repr(location), repr(orientation)))

        if not isinstance(location, Point):
            location = Point(*location)

        # :type: Point
        self.location = location
        #: :type: Orientation
        self.orientation = orientation

    def __reduce__(self):
        """Enables pickling of the position object"""
        return Position, (self.location, self.orientation)

    def ensure_vector(self, vector, normalize=True):
        """Ensures that ``vector`` is a Vector instance or convert it into a
        Vector, optionally ``normalize`` as well. Specified ``vector`` can be:

        1. a Vector instance --> returned normalize version
        2. a string naming a direction --> returns associated principle Vector
            **in current .orientation**
        3. an iterable of three numbers --> converted to Vector

        >>> XOY.ensure_vector(Vector(1, 0, 0))
        Vector(1.0, 0.0, 0.0)
        >>> XOY.ensure_vector((1, 0, 0))
        Vector(1.0, 0.0, 0.0)
        >>> XOY.ensure_vector([1, 0, 0])
        Vector(1.0, 0.0, 0.0)
        >>> XOY.ensure_vector('x')
        Vector(1, 0, 0)
        >>> XOY.ensure_vector('front')
        Vector(0, -1, 0)
        >>> XOY.ensure_vector(False)
        Traceback (most recent call last):
            ...
        TypeError: Don't know how to convert False into a Vector instance.

        :param vector: anything that should represent a vector
        :param bool normalize: return a normalized vector?
        :rtype: Vector
        :raises TypeError: if ``vector`` couldn't be converted
        """
        if isinstance(vector, str):
            return getattr(self, key_to_vector_key(vector))
        elif isinstance(vector, Vector):
            return vector.normalize if normalize else vector
        elif hasattr(vector, "__iter__") and len(vector) == 3:
            return Vector(*vector).normalize if normalize else Vector(*vector)
        else:
            msg = "Don't know how to convert {:} into a Vector instance."
            raise TypeError(msg.format(vector))

    def distance(self, other):
        """:rtype: float"""
        assert isinstance(other, AbstractPoint)
        return self.location.distance(other)

    @property
    def distance_origin(self):
        """Distance from ``ORIGIN``.

        :rtype: float
        """
        return self.location.distance_origin

    def interpolate(self, other, frac=0.5):
        """Same as :meth:`Point.interpolate`, but returns Position object.
        Moreover, if ``other`` is of Position, also orientation will be
        interpolated.

        :param Point | Axis | Position other: other Point / Axis / Position
        :param numbers.Number frac: Between [0-1] for interpolation. Outside
            this range for extrapolation. Default is 0.5.
        :rtype: Position

        >>> pos = XOY.interpolate(Point(2, 4, 6))
        >>> pos.location
        Point(1.0, 2.0, 3.0)
        >>> pos = XOY.interpolate(Point(2, 4, 6), frac=0.75)
        >>> pos.location
        Point(1.5, 3.0, 4.5)
        >>> other_pos = XOY.translate(x=2, y=4, z=6).rotate90('z')
        >>> pos = XOY.interpolate(other_pos)
        >>> pos.location, pos.Vx, pos.Vy
        (Point(1.0, 2.0, 3.0), Vector(0.707106781187, 0.707106781187, 0.0), Vector(-0.707106781187, 0.707106781187, 0.0))
        """
        if isinstance(other, Position):
            return Position(self.location.interpolate(other.location, frac),
                            self.orientation.interpolate(other.orientation,
                                                         frac))
        elif isinstance(other, (Point, Axis)):
            return Position(self.location.interpolate(other, frac),
                            self.orientation)
        elif isinstance(other, Orientation):
            return Position(self.location,
                            self.orientation.interpolate(other, frac))
        else:
            msg = "other should be Position | Point | Orientation.\nNot: {}."
            raise Exception(msg.format(repr(other)))

    def vector_to(self, other):
        return self.location.vector_to(other)

    vector_to.__doc__ = Point.vector_to.__doc__

    def vector_from(self, other):
        return self.location.vector_from(other)

    vector_from.__doc__ = Point.vector_from.__doc__

    def get_point(self, x=0, y=0, z=0):
        """Get a 3d point relative to plane location and orientation."""
        pt = self.location
        vx, vy, vz = self.orientation
        return pt + x * vx + y * vy + z * vz

    def translate_to(self, other):
        """
        Returns a new Position instance by fixing the location of this Position to ``other.location``
        Orientation remains unchanged.

        :param other: other point-like object
        :type other: :class:`Point` | :class:`Position`
        """
        assert isinstance(other, AbstractPoint)
        return Position(other, self.orientation)

    def rotate_to(self, other):
        """
        Rotate the position to the orientation of the given position.
        Location remains unchanged.

        :param other: other Orientation
        :type other: :class:`Orientation`
        """
        assert isinstance(other, (Orientation, Position))
        return Position(self, other.orientation)

    def __neg__(self):
        return self.__class__(-self.location, -self.orientation)

    def __add__(self, other):
        if isinstance(other, Vector):
            return Position(self.location + other, self.orientation)
        else:
            return NotImplemented

    __radd__ = __add__

    def __sub__(self, other):
        """Two subtractions modes:
        
        1. Position - Vector: subtracts the specified Vector from this Position and returns the resulting **Position**.
        2. Position - Point: subtract the specified Point from this Position and returns the difference as a **Vector** (same as vector_from).
        
        .. note:: Vector - Point is prohibited.

        :rtype: :class:`Point` | :class:`Vector`

        >>> pt1 = Point(1,2,3)
        >>> pt2 = Point(0,1,2)
        >>> v2 = Vector(0,1,2)
        >>> pt1 - pt2
        Vector(1,1,1)
        >>> pt1 - v2
        Point(1,1,1)   
        """
        if isinstance(other, Vector):
            return Position(self.location - other, self.orientation)
        if isinstance(other, AbstractPoint):
            return Vector(self.x - other.x, self.y - other.y, self.z - other.z)
        else:
            return NotImplemented

    def __mul__(self, other):
        if isinstance(other, Orientation):
            # only makes sence for Rotation matrices, to respect orthogonality of Orientation objects.
            return Position(self.location, self.orientation * other)
        else:
            return NotImplemented

    def __rmul__(self, other):
        if isinstance(other, Orientation):
            # only makes sence for Rotation matrices, to respect orthogonality of Orientation objects.
            return Position(self.location, other * self.orientation)
        else:
            return NotImplemented

    def is_almost_equal(self, other, tol=None):
        tol = CONFIGURATION["tolerance"] if tol is None else abs(tol)
        return isinstance(other, Position) \
               and is_almost_equal_vec(self.location, other.location, tol) \
               and is_almost_equal_mat(self.orientation, other.orientation, tol)

    def __eq__(self, other):
        return self.is_almost_equal(other)

    def __hash__(self):
        return super(Position, self).__hash__()

    def translate(self, *args, **kwargs):
        """Translate Position along a (named) vector over distance. Named vectors like 'x', 'y',
        'front' are inpreted in the orientation of this Position instance. So, 'x' corresponds to
        self.Vx. Note that if you want to just add a vector to a Position, use notation: pt + V.
        All translations are relative to the Position itself. If you want to fix a coordinate, use
        one of capitalized inputs: 'X', 'Y', 'Z'.
        
        :param args: sequence of (named) vector - number pairs
        :param kwargs: dictionary of named vector - number pairs.
            Format ``{str : number, ...}``.
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Position`

        >>> pos = Position(Point(1,1,1))
        >>> pos.translate(Vector(1,0,0), 2)
        Position(location=(3,1,1), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        >>> pos.translate('x', 2)
        Position(location=(3,1,1), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        >>> pos.translate(x=2)
        Position(location=(3,1,1), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        >>> pos.translate(X=2)
        Position(location=(2,1,1), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        >>> pos.translate(Vector(1,0,0), 2, 'y', 3, z_ = 4)
        Position(location=(3,4,-3), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        >>> pos.translate('X', 2, 'y', 3, z_ = 4)
        Position(location=(2,4,-3), orientation=Orientation(x=Vector(1,0,0),y=Vector(0,1,0),z=Vector(0,0,1))) 
        """
        # assert not len(args) % 2, "Position.translate: *args input should be of even length"
        # " (vector|str, angle, ...). Not: %s" % (args,)
        # args = args + tuple(a for b in kwargs.iteritems() for a in b)

        pt = list(self)
        orient = self.orientation
        f = orient.ensure_vector

        if args:
            args = iter(args)
            for v, d in zip(args, args):
                if v == 'X':
                    pt[0] = d
                elif v == 'Y':
                    pt[1] = d
                elif v == 'Z':
                    pt[2] = d
                else:
                    v = f(v)
                    pt[0] += v[0] * d;
                    pt[1] += v[1] * d;
                    pt[2] += v[2] * d

        for v, d in kwargs.items():
            if v == 'X':
                pt[0] = d
            elif v == 'Y':
                pt[1] = d
            elif v == 'Z':
                pt[2] = d
            else:
                v = f(v)
                pt[0] += v[0] * d;
                pt[1] += v[1] * d;
                pt[2] += v[2] * d

        return Position(Point(*pt), orient, _check=False)

    __call__ = translate

    def rotate(self, *args, **kwargs):
        """Rotates point around Point(0,0,0). See rotate_around for more details.

        :param args: tuple of vector and number pairs
        :param kwargs: dict of vector and number pairs. One argument can
            be deg=True to specify rotation in degrees. Format:
            ``{Vector|str : number, ..., deg=<bool>}``
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Position`
        """
        return self.rotate_around(self.location, *args, **kwargs)

    def rotate90(self, vector, *other_vectors):
        """Rotates point for a quarter (90 degrees) around Point(0,0,0). See rotate_quarter_around
        for more details.

        :param vector: Vector to rotate around
        :param more_vectors: more vectors for subsequent rotations
        :type vector: :class:`Vector` | str
        :type more_vectors: :class:`Vector` | str
        :rtype: :class:`Position`
        """
        return self.rotate_quarter_around(self.location, vector, *other_vectors)

    # deprecated
    rotate_quarter = rotate90

    def rotate_around(self, ref, *args, **kwargs):
        """Rotates position around reference_point. Each next argument is a (named) vector followed
        by a angle (radians). You can follow this with more rotation vectors and angles, these
        are interpolated as rotation in **sequence** (one after the other).

        :param ref: reference point for rotation
        :param args: tuple of vector and number pairs
        :param kwargs: dict of vector and number pairs. One argument can
            be deg=True to specify rotation in degrees. Format:
            ``{Vector|str : number, ..., deg=<bool>}``
        :type ref: :class:`Point` | :class:`Position`
        :type args: :class:`Vector` | str | numbers.Number
        :rtype: :class:`Position`

        >>> pt = Point()
        """
        assert isinstance(ref, AbstractPoint)
        assert len(args) % 2 == 0, "*args tuple should of even length (vector, angle, ...)\nNot: %s" % (args)
        deg = kwargs.pop('deg', False)
        args = args + tuple(a for b in kwargs.items() for a in b)
        pos = self
        for v, angle in by_pairs(args):
            v = pos.ensure_vector(v)
            pt = pos.location
            orient = pos.orientation
            v1 = pt - ref
            v2 = v1.rotate(v, angle, deg=deg)
            pt = ref + v2
            orient = orient.rotate(v, angle, deg=deg)
            pos = Position(pt, orient)
        return pos

    def rotate90_around(self, ref, vector, *more_vectors):
        """Rotates point for a quarter circle (90 degrees) around reference_point. Like
        Point.rotate_around, but you don't specify angles.

        :param ref: reference point for rotation
        :param vector: Vector to rotate around
        :param other_vectors: more vectors for subsequent rotations
        :type ref: :class:`Point` | :class:`Position`
        :type vector: :class:`Vector` | str
        :type more_vectors: sequence of :class:`Vector` | str
        :rtype: :class:`Position`

        >>> pt = Point()
        """
        assert isinstance(ref, AbstractPoint)
        vectors = (vector,) + more_vectors
        pos = self
        for v in vectors:
            v = pos.ensure_vector(v)
            pt = pos.location
            orient = pos.orientation
            v1 = pt - ref  # a vector
            v2 = v1.rotate_quarter(v)
            pt = ref + v2
            orient = orient.rotate_quarter(v)
            pos = Position(pt, orient)
        return pos

    # deprecated
    rotate_quarter_around = rotate90_around

    def align(self, vector_old, vector_new, warn=True):
        """Create a rotated Position instance, by aligning some old vector
        ``vector_orig`` with a new vector ``vector_new``.

        >>> pos = XOY.align(Vector(1, 0, 0), Vector(0, 1, 0))
        >>> pos.Vx, pos.Vy  # doctest: +SKIP
        Vector(0, 1, 0), Vector(-1, 0, 0)

        :param Vector vector_old: old vector
        :param Vector vector_new: new vector
        :param bool warn: warn if vectors are parallel and, thus, alignment
            becomes ambiguous?
        :rtype: Position
        """
        return Position(self.location,
                        self.orientation.align(vector_old, vector_new, warn))

    def project(self, ref, axis1=None, axis2=None):
        """Projects this Position onto a line or plane located at ``ref``.
        Reference ``ref`` can be of type Point, Axis, Position. If ``ref`` is
        of type :class:`Point`, you need to additionally specify:
        
        - ``axis1`` for projection onto a line
        
        Optionally, you can also specify:
        
        - ``axis2`` for projection onto a plane
        
        If ``ref`` is of type :class:`Axis`, the default behavior is line
        projection where ``axis1 = Axis.vector``. However ``axis2`` can
        still be specified for plane projection.

        If ``ref`` is of type :class`Position`, the default behavior is Plane
        projection where ``axis1 = Position.Vx`` and ``axis2 = Position.Vy``.

        You can always override ``axis1`` and ``axis2`` by specifying them
        though, in which case only the location of Axis/Position are used.

        >>> # line projection
        >>> pos = XOY.project(Point(1, 1, 1), axis1=Vector(1, 1, 0))
        >>> pos.location
        Point(0.0, 0.0, 1.0)
        >>> # plane projection
        >>> pos = XOY.project(Point(1, 1, 1), axis1=Vector(1, 0, 0), axis2=Vector(0, 1, 0))
        >>> pos.location
        Point(0.0, 0.0, 1.0)

        :param Point | Axis | Position ref: reference location for projection
        :param Vector | None axis1: vector for line reflection
        :param Vector | None axis2: second vector for plane reflection
        :rtype: Position
        """
        location = Point.project(self.location, ref, axis1=axis1, axis2=axis2)
        return Position(location, self.orientation)

    def reflect(self, ref, axis1=None, axis2=None):
        """Reflect this Position into another point, a line or plane located
        at ``ref``. Reference ``ref`` can be of type Point, Axis, Position.
        If ``ref`` is of type :class:`Point`, you can additionally specify:

        - ``axis1`` for reflection into a line
        - ``axis2`` for reflection into a plane

        If ``ref`` is of type :class:`Axis`, the default behavior is line
        reflection where ``axis1 = Axis.vector``. However ``axis2`` can
        still be specified for plane reflection.

        If ``ref`` is of type :class`Position`, the default behavior is Plane
        reflection where ``axis1 = Position.Vx`` and ``axis2 = Position.Vy``.

        You can always override ``axis1`` and ``axis2`` by specifying them
        though, in which case only the location of Axis/Position are used.

        Orientation:

        - point reflection: Vx and Vy are reversed.
            Vz remains constant (to stay right-handed)
        - line reflection: Vx and Vy are transformed accordingly.
            Vz = Vx x Vy (cross product).
        - plane reflection: Vx and Vy are transformed accordingly.
            Vz = Vx x Vy (cross product).

        >>> # point reflection
        >>> pos = XOY.reflect(Point(1, 1, 1))
        >>> pos.location, pos.Vx, pos.Vy
        (Point(2, 2, 2), Vector(-1.0, 0.0, 0.0), Vector(0.0, -1.0, 0.0))
        >>> # line reflection
        >>> pos = XOY.reflect(Point(1, 1, 1), axis1=Vector(1, 0, 0))
        >>> pos.location, pos.Vx, pos.Vy
        (Point(0.0, 2.0, 2.0), Vector(1.0, 0.0, 0.0), Vector(0.0, -1.0, 0.0))
        >>> # plane reflection
        >>> pos = XOY.reflect(Point(1, 1, 1), axis1=Vector(1, 0, 0), axis2=Vector(0, 1, 0))
        >>> pos.location, pos.Vx, pos.Vy
        (Point(0.0, 0.0, 2.0), Vector(1.0, 0.0, 0.0), Vector(0.0, 1.0, 0.0))

        :param Point | Axis | Position ref: reference location for reflection
        :param Vector | str | None axis1: vector for line reflection
        :param Vector | str | None axis2: second vector for plane reflection
        :rtype: Position
        """
        if not isinstance(ref, AbstractPoint):
            msg = ("Your ref is not of type Point, Axis or Position, but {}. "
                   "Object: {}.")
            raise ValueError(msg.format(type(ref), self))

        if axis1 is not None:
            axis1 = Vector.ensure_vector(axis1).normalized
        if axis2 is not None:
            axis2 = Vector.ensure_vector(axis2).normalized

        if isinstance(ref, Axis) and axis1 is None:
            axis1 = ref.vector
            ref = ref.location
        elif isinstance(ref, Position):
            if axis1 is None:
                axis1 = ref.Vx
            if axis2 is None:
                axis2 = ref.Vy
            ref = ref.location

        location = self.location
        vx, vy, vz = self.orientation

        if axis1 is None and axis2 is None:
            # point reflection
            return Position(location.reflect(ref),
                            Orientation(-vx, -vy, vz))
        elif axis2 is None:
            # line reflection
            return Position(location.reflect(ref, axis1),
                            Orientation(vx.reflect(axis1),
                                        vy.reflect(axis1)))

        else:
            # plane reflection
            return Position(location.reflect(ref, axis1, axis2),
                            Orientation(vx.reflect(axis1, axis2),
                                        vy.reflect(axis1, axis2)))

    mirror = reflect

    @property
    def x_reverse(self):
        """Returns a new Position instance where Vx is now in opposite
        direction. 'Vz' constant."""
        return self.rotate_to(Orientation(x=-self.Vx, z=self.Vz))

    @property
    def y_reverse(self):
        """Returns a new Position instance where Vy is now in opposite
        direction. 'Vx' constant."""
        return self.rotate_to(Orientation(y=-self.Vy, x=self.Vx))

    @property
    def z_reverse(self):
        """Returns a new Position instance where Vz is now in opposite
        direction. 'Vy' constant."""
        return self.rotate_to(Orientation(z=-self.Vz, y=self.Vy))

    def midpoint(self, other):
        """Return a Point that is halfway between this Position and ``other``.
        Use :meth:`interpolate` if you want a Position instance, where also
        orientation is interpolated.

        :param Point | Axis | Position other: other Point / Axis / Position

        >>> XOY.midpoint(Point(2, 4, 6))
        Point(1.0, 2.0, 3.0)
        """
        if isinstance(other, AbstractPoint):
            return self.location + 0.5 * (other - self)
        else:
            msg = ("other should be of type Point|Axis|Position|, not: {}. "
                   "Object: {}.")
            raise RuntimeError(msg.format(type(other), self))

    def get_relative_point(self, point, from_pos=None):
        """Return ``point`` expressed relative to this ``Position``.  Use
        ``from_pos`` when ``point`` is not defined relative to the
        global coordinate system (``XOY``).

        :param Point point: ``Point`` expressed relative to ``from_pos``.
        :param Position from_pos: position in which ``point`` is
            currently expressed. (default: ``XOY``).
        :rtype: Point
        """
        from_basis = from_pos or XOY
        return point.expressed_in(self, from_basis)

    def polygon(self, *args):
        """Create a polygon of Position instances.

        Returns:
            [Position, ...]
  
        >>> foo = Position()
        >>> foo.polygon('x', 2, ('x', 'y'), (5, 1), 'y', 10)
        [Position(0,0,0), Position(2,0,0), Position(7,1,0), Position(7,11,0)]"""

        assert len(args) % 2 == 0, "supply even number of args: ['key', value]*"

        pos = self
        result = [self]
        for k, v in by_pairs(args):
            if hasattr(v, '__iter__'):
                pos = pos(*[j for i in zip(k, v) for j in i])
                result.append(pos)
            else:
                pos = pos(k, v)
                result.append(pos)
        return result

    @property
    def point(self):
        """Get location of this axis system.

        :rtype: Point
        """
        return self.location

    @property
    def Vx(self):
        return self.orientation.x

    @property
    def Vy(self):
        return self.orientation.y

    @property
    def Vz(self):
        return self.orientation.z

    # ==========================================================================
    # Copy from Point and Orientation class
    # ==========================================================================
    x_ = Vx_ = property(lambda self: self.orientation.x_)
    y_ = Vy_ = property(lambda self: self.orientation.y_)
    V = Vz
    z_ = Vz_ = property(lambda self: self.orientation.z_)
    right = Vx
    left = Vx_
    back = rear = Vy
    front = Vy_
    top = up = Vz
    bottom = down = Vz_

    x_axis = property(lambda self: Axis(self.location, self.Vx))
    y_axis = property(lambda self: Axis(self.location, self.Vy))
    z_axis = property(lambda self: Axis(self.location, self.Vz))

    def __repr__(self):
        return '%s(Point(%s, %s, %s))' % (self.__class__.__name__, self[0], self[1], self[2])

    def replace(self, location=None, orientation=None):
        """Get a copy of this object. One can override any of its items.

        :param Point | None location:
        :param Orientation | None orientation:
        """
        cls = type(self)
        location = self.location if location is None else location
        orientation = self.orientation if orientation is None else orientation
        return cls(location, orientation)


# claims name here as first-class citizen for (static) docs / type hinting
def centroid(points: Iterable[Tuple3D]) -> Point:
    """Calculate the centroid of ``points``:

    >>> points = [Point(1, 2, 3), Point(3, 4, 5)]
    >>> centroid(points)
    Point(2.0, 3.0, 4.0)

    :param points: an iterable of points
    :returns a Point representing the centroid of these points
    """
    x, y, z = zip(*points)
    length = len(x)
    return Point(sum(x) / length, sum(y) / length, sum(z) / length)


_centroid_vanilla = centroid  # for testing purposes


try:
    import numpy as np
except ImportError:
    pass
else:
    # for testing purposes
    def _centroid_np(points: Iterable[Tuple3D]) -> Point:
        """Calculate the centroid of ``points``:

        >>> points = [Point(1, 2, 3), Point(3, 4, 5)]
        >>> centroid(points)
        Point(2.0, 3.0, 4.0)
        """
        return Point(*np.average(points, axis=0))

    centroid = _centroid_np


def orthogonal_vector(vector, normalize=False):
    """Given one vector, return a random orthogonal vector. Use
    :py:`normalized=True` to force the result to be normalized.

    >>> orthogonal_vector(Vector(1.0, 0.0, 0.0))
    Vector(0.0, 0.0, 1.0)
    >>> orthogonal_vector(Vector(0.0, 1.0, 0.0))
    Vector(0.0, 0.0, 1.0)
    >>> orthogonal_vector(Vector(0.0, 0.0, 1.0))
    Vector(1.0, 0.0, 0.0)
    >>> orthogonal_vector(Vector(1.0, 1.0, 0.0))
    Vector(1.0, -1.0, 0.0)
    >>> orthogonal_vector(Vector(1.0, 1.0, 0.0), normalize=True)
    Vector(0.707106781187, -0.707106781187, 0.0)

    :param parapy.geom.Vector vector:
    :param bool normalize: return a normalized vector?
    :rtype: parapy.geom.Vector
    """
    x, y, z = _orthogonal_vector(*vector)
    if normalize:
        mag = math.sqrt(x ** 2 + y ** 2 + z ** 2)
        x, y, z = x / mag, y / mag, z / mag
    return Vector(x, y, z)


def _orthogonal_vector(x, y, z):
    """Given one vector, return a random normalized, orthogonal vector.

    >>> _orthogonal_vector(1.0, 0.0, 0.0)
    (0.0, 0.0, 1.0)
    >>> _orthogonal_vector(0.0, 1.0, 0.0)
    (0.0, 0.0, 1.0)
    >>> _orthogonal_vector(0.0, 0.0, 1.0)
    (1.0, 0.0, 0.0)
    >>> _orthogonal_vector(1.0, 1.0, 0.0)
    (1.0, -1.0, 0.0)

    :param float x: x-component
    :param float y: y-component
    :param float z: z-component
    :rtype: tuple[float, float, float]
    """
    # See http://math.stackexchange.com/questions/133177/finding-a-unit-vector-perpendicular-to-another-vector
    xabs = abs(x)
    yabs = abs(y)
    zabs = abs(z)
    # + 0 is added to several components to not add -0's to the result
    if yabs <= xabs and yabs <= zabs:
        if xabs > zabs:
            return -z + 0, 0., x
        else:
            return z, 0., -x + 0
    elif xabs <= yabs and xabs <= zabs:
        if yabs > zabs:
            return 0., -z + 0, y
        else:
            return 0., z, -y + 0
    else:
        if xabs > yabs:
            return -y + 0, x, 0.
        else:
            return y, -x + 0, 0.


# --------- serialization functions for snapshot feature ---------
# Signature:
#       object to serialize, outer hook (for unpacked objects), snapshot_root


def _serialize_tuple_3D(obj, outer_hook, snapshot_root):
    return serialize_instance(obj, args=obj)


def _serialize_orientation(obj, outer_hook, snapshot_root):
    vectors = list(map(outer_hook, obj))
    return serialize_instance(obj, args=vectors)


def _serialize_position(obj, outer_hook, snapshot_root):
    arg1 = outer_hook(obj.location)
    arg2 = outer_hook(obj.orientation)
    return serialize_instance(obj, args=(arg1, arg2))


# --------- global values ----------

#: (Vector) Returns zero vector Vector(0, 0, 0)
V0 = Vector(0, 0, 0)

#: (Vector) Returns a unit vector Vector(1, 0, 0)
VX = Vector(1, 0, 0)

#: (Vector) Returns a unit vector Vector(0, 1, 0)
VY = Vector(0, 1, 0)

#: (Vector) Returns a unit vector Vector(0, 0, 1)
VZ = Vector(0, 0, 1)

#: (Orientation) main direction 'Y'
ZX = Orientation(Vector(0, 0, 1), Vector(1, 0, 0))

#: (Orientation)main direcion 'X'
YZ = Orientation(Vector(0, 1, 0), Vector(0, 0, 1))

#: (Position) main direction 'Z'
OXY = XOY = Position()

#: (Position) main direction 'Y'
ZOX = Position(ORIGIN, ZX)

#: (Position) main direcion 'X'
YOZ = Position(ORIGIN, YZ)

#: (Position) iso-perspective
ISO = XOY.rotate(z=45, deg=True).rotate(x=35.264, deg=True)

#: (Position) iso-perspective lower
OISO_LOW = XOY.rotate(z=45, deg=True).rotate(x=75, deg=True)

_NAME_TO_POS = {
    'top': XOY,
    'front': ZOX,
    'left': YOZ,
    'iso': ISO
}


def name_to_pos(name):
    """converts view named by ``name`` to a Position instance

    :param str name: one of: top, front, left, iso
    :rtype: parapy.geom.Position
    """
    try:
        return _NAME_TO_POS[name]
    except KeyError:
        raise ValueError("view named %s is not one of 'top', 'front', "
                         "'left' or 'iso'." % (name,))

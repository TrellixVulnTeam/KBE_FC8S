#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

# TODO: optimize code for performance!!! Main concern is overhead in type checking, argument extraction, etc.
# TODO: consider using numpy for speed / flexibility?
# TODO: or turn this into a C-extension for speed?
# FIXME: fix -0 cases?

"""Tools for generating lists of positions for patterns"""

import math
from numbers import Real

from .positioning import AbstractPoint, Position


def linear_positions(start, N, L, dir='x', ref=None):
    """
    :param start (Position): position that will be translated in the given direction
    :param N (int): amount of objects to create
    :param L (float): total length of the linear sequence
    :param dir (Vector | str): vector equivalent, relative to the start position
    :param ref (Position): Position for interpreting the direction. By default the start position.
    >>> from parapy.geom import OXY
    >>> obj = linear_positions(OXY, 10, 5)
    @todo: direction would me more intuitive if relative to the parent orientation, but is now relative to start 
        position, because parent is not available in a computed slot.
    """
    if not isinstance(start, Position):
        raise TypeError("start must be of type Position, received: %s" % (start,))
    if not isinstance(N, int) or N < 0:
        raise TypeError("N must be a positive integer, received: %s" % (N,))
    if not isinstance(L, Real):
        raise TypeError("L must be number, received: %s" % (L,))
    if ref is None:
        ref = start
    elif not isinstance(ref, Position):
        raise TypeError("ref must be of type Position, received: %s" % (ref,))

    pt = start
    orient = start.orientation
    step = L / (N - 1)
    dir = ref.ensure_vector(dir).normalize
    Vstep = dir * step
    
    return [Position(pt + Vstep * i, orient) for i in range(N)]


def radial_positions(start, center, N, angle=2*math.pi, normal='z', ref=None, deg=False):
    """
    center is center of rotation, angle is rotation angle. Last position is *NOT* repeated.
    See linear_positions for other inputs.
    >>> from parapy.geom import Point, Position
    >>> obj = radial_positions(Position(Point(1,0,0)), Point(0,0,0), 10)
    """
    if not isinstance(start, Position):
        raise TypeError("start must be of type Position, received: %s" % (start,))
    if not isinstance(center, AbstractPoint):
        raise TypeError("start must be of type AbstractPoint, received: %s" % (center,))    
    if not isinstance(N, int) or N < 0:
        raise TypeError("N must be a positive integer, received: %s" % (N,))
    if not isinstance(angle, Real):
        raise TypeError("angle must be number, received: %s" % (angle,))
    if ref is None:
        ref = start
    elif not isinstance(ref, Position):
        raise TypeError("ref must be of type Position, received: %s" % (ref,))

    step = angle / N
    normal = ref.ensure_vector(normal).normalize

    return [start.rotate_around(center, normal, step*i, deg=deg) for i in range(N)]


def spiral_positions(start, center, N, H, angle=2*math.pi, normal='z', ref=None, deg=False):
    """center is center of rotation, angle is rotation angle. Last position is *NOT* repeated.
    See linear_positions for other inputs.
    >>> from math import pi
    >>> from parapy.geom import Point
    >>> obj = spiral_positions(Position(Point(1,0,0)), Point(0,0,0), 50, 5, angle=10*pi)
    """
    if not isinstance(start, Position):
        raise TypeError("start must be of type Position, received: %s" % (start,))
    if not isinstance(center, AbstractPoint):
        raise TypeError("start must be of type AbstractPoint, received: %s" % (center,))    
    if not isinstance(N, int) or N < 0:
        raise TypeError("N must be a positive integer, received: %s" % (N,))
    if not isinstance(H, Real):
        raise TypeError("H must be number, received: %s" % (H,))    
    if not isinstance(angle, Real):
        raise TypeError("angle must be number, received: %s" % (angle,))
    if ref is None:
        ref = start
    elif not isinstance(ref, Position):
        raise TypeError("ref must be of type Position, received: %s" % (ref,))

    step = angle / N
    Hstep = H / (N - 1)
    normal = ref.ensure_vector(normal).normalize

    return [start.rotate_around(center, normal, step*i, deg=deg)(normal, Hstep*i) for i in range(N)]


def matrix_positions(start, N1, N2, L1, L2, dir1='x', dir2='y', ref=None):
    """See linear_positions
    >>> obj = matrix_positions(OXY, 10, 5, 5, 5)
    """
    if not isinstance(start, Position):
        raise TypeError("start must be of type Position, received: %s" % (start,))
    if not isinstance(N1, int) or N1 < 0:
        raise TypeError("N1 must be a positive integer, received: %s" % (N1,))
    if not isinstance(N2, int) or N2 < 0:
        raise TypeError("N2 must be a positive integer, received: %s" % (N2,))
    if not isinstance(L1, Real):
        raise TypeError("L1 must be number, received: %s" % (L1,))
    if not isinstance(L2, Real):
        raise TypeError("L1 must be number, received: %s" % (L2,))  
    if ref is None:
        ref = start
    elif not isinstance(ref, Position):
        raise TypeError("ref must be of type Position, received: %s" % (ref,))

    pt = start
    orient = start.orientation
    step1 = L1 / (N1 - 1)
    step2 = L2 / (N2 - 1)
    dir1 = ref.ensure_vector(dir1).normalize
    dir2 = ref.ensure_vector(dir2).normalize
    Vstep1 = dir1 * step1
    Vstep2 = dir2 * step2
    return [[Position(pt + Vstep1 * i + Vstep2 * j, orient) for i in range(N1)] for j in range(N2)]            


def positions_along_function(function, N, u1=0, u2=1):
    """function should accept one parameter, typically varying from 0..1 and return a Position
    :param function:
    :param int N: Total amount of Positions to create
    :param float u1: Start parameter of the curve.
    :param float u2: End parameter of the curve.
    >>> from parapy.geom import  Position, Point
    >>> fn = lambda u: Position(Point((u*5)**2, 0, (u*2)))
    >>> obj = positions_along_function(fn, 20)
    """
    if not isinstance(N, int) or N < 0:
        raise TypeError("N must be a positive integer, received: %s" % (N,))
    step = (u2 - u1) / (N - 1)
    return [function(u1 + i * step) for i in range(N)]


def positions_along_curve(curve, N, u1=None, u2=None, bi_normal=None):
    """
    Determines N equally distributed positions along curve.
    :param curve:
    :type crv: parapy.geom.occ.curve.Curve
    :param int N: Total amount of Positions to create
    :param float u1: Start parameter of the curve.
    :param float u2: End parameter of the curve.
    :param bi_normal:
    >>> from parapy.geom import Point, BSplineCurve,
    >>> control_points = [Point(1, 2, 3), Point(2, 4, 3), Point(10, 2, 3), Point(15, 5, 3), Point(20, -3, 3)]
    >>> curve = BSplineCurve(control_points=control_points,degree=2)
    >>> obj = positions_along_curve(curve, 7, u1=None, u2=None, bi_normal=None)
    """
    if not isinstance(N, int) or N < 0:
        raise TypeError("N must be a positive integer, received: %s" % (N,))

    if bi_normal is None:
        bi_normal = curve.plane_normal
    if u1 is None:
        u1 = curve.u1
    if u2 is None:
        u2 = curve.u2

    du = (u2 - u1) / (N-1)
    return [curve.get_position(u1 + i * du, bi_normal) for i in range(N)]

# def matrix_positions(start_position, quantity, distances, directions=('right', 'rear', 'up'), limits=None, reference_position=None):
#     """
#     @param start_position (Position): position that will be translated in the given direction
#     @param quantity (int | (int)): 
#         If an int: 
#             Total amount of positions to create. limits must be provided, and must be a tuple of ints that gives 
#             the max amount elements in each direction. The limit for the last direction may be omitted.
#         If a tuple of ints:
#             Amount of positions to create in each direction. The length of the tuple must be equal to the directions 
#             tuple. Limits must not be provided. 
#     @param distances (float): total length of the sequence in each direction. Elements are distributed along the 
#         length. For this, the limit in each direction is used, or if not given, the quantity or quantities. 
#     @param directions ((Vector | str)): A tuple of vector equivalents, relative to the start position. By default, 
#         along the x, y and z axis. The length of the tuple must at least be as long as distances. The directions
#         will be normalize.
#     @param limits ((int)|int): a tuple of ints that gives the max amount elements in each direction. The limit for 
#         the last direction may be omitted. If only for one direction the limit is provided, it may be provided as 
#         int, instead of (int,)
#     @param reference_position (Position): Position for interpreting the directions. By default the start position.
#             
#     @todo: direction would me more intuitive if relative to the parent orientation, but is now relative to start 
#         position, because parent is not available in a computed slot.
#     
#     Example usage:
#     
#         matrix_positions(self.position, (2, 3), (1.5, 3.2))
#             -> Create a 2D matrix of 6 elements: 2 elements along the x axis, with a total length 
#                 of 1.5, and 3 elements along the y axis, with total length of 3.2.
#         
#         matrix_positions(self.position, 18, (0.4, 0.8), limits=(5,))
#             -> Create a 2D matrix of 18 elements on a grid of 5 elements along the x-axis, and as much  
#                 elements along the y-axis as necessary. The last row will only have 3 elements in y-direction.
#                 
#         matrix_positions(self.position, (4, 3, 2), (4.0, 3.0, 2.0))
#             -> Create a 3D matrix, of 24 elements, with a spacing of 1, along the three axes.
#             
#         matrix_positions(self.position, (2, 2), (1.0, 1.5), directions=((0, 1, 0), (-1, 1, 1)))
#             -> Create a 2D matrix of 4 elements, with side lengths 1.0 and 1.5, along the two given directions
#                 (not orthogonal to each other)
#         
#     @todo: check the convenience of the interface with real-life examples.
#     """
#     
#     # CHECK AND NORMALIZE ARGUMENTS
#     
#     if not isinstance(start_position, GenericPosition):
#         raise TypeError("start_position must be a Position, got " + repr(start_position))
#     
#     # Distances is the most important argument: the length of it dictates whether this is a 1D, 2D or 3D matrix.
#     try:
#         distances = [float(distance) for distance in distances]
#     except ValueError:
#         raise TypeError("Distances must be a sequence of numbers")
#     dim = len(distances)
#     
#     if type(quantity) is int:
#         if quantity < 0:
#             raise TypeError("quantity must be a positive integer, got " + repr(quantity))
#         if limits is None:
#             raise TypeError("Limits must be provided for each direction, if a total quantity is given.")
#         if type(limits) is int:
#             limits = [limits]
#         else:
#             limits = list(limits)
#             if not all([type(limit) is int and limit >= 2 for limit in limits]):
#                 raise TypeError("Limits must be a sequence of integers, all 2 or larger")
#         if len(limits) == dim - 1:
#             # Add last limit
#             total_limit = multiply_numbers(limits)
#             # The last limit must be large enough to accommodate quantity, and at least 
#             # be 2 (otherwise step size could result in ZeroDivisionError
#             last_limit = max(int(math.ceil(quantity / total_limit)), 2)
#             limits.append(last_limit)
#         else:
#             if not len(limits) == dim:
#                 raise TypeError("If quantity is given as int, limits must be provided for each direction, except the last")
#             if multiply_numbers(limits) < quantity:
#                 raise TypeError("The given limits are too small for the required quantity: " + 
#                                      "%s only fits %s elements, but %s are needed" % (limits,
#                                                                                       multiply_numbers(limits),
#                                                                                       quantity))
#     else:
#         if len(quantity) != dim:
#             raise TypeError("If quantities is not an int, it must be a sequence with the same length as distances")
#         if limits is not None:
#             raise TypeError("If quantities are given, no limits may be provided")
#         limits = list(quantity)
#         quantity = multiply_numbers(limits)
#         
#     if len(directions) < dim:
#         raise TypeError("Not enough direction vectors provided")
#     
#     if reference_position is None:
#         reference_position = start_position
#     elif not isinstance(reference_position, GenericPosition):
#         raise TypeError("reference_position must be a Position, got " + repr(reference_position))
#         
#     directions = [reference_position.orientation.ensure_vector(direction) for direction in directions[:dim]]
#     
#     # BUILD POSITION SEQENCE
#     
#     distance_steps = [distance / float(limit - 1) for distance, limit in zip(distances, limits)] 
#     vectors = [direction.normalize * distance_step for direction, distance_step in zip(directions, distance_steps)]
#         
#     return _matrix_positions(start_position, quantity, limits, vectors)
# 
# def multiply_numbers(sequence):
#     return reduce(lambda a, b: a * b, sequence[1:], sequence[0])
# 
# def _matrix_positions(start_position, quantity, limits, vectors):
#     """
#     Create Positions in a matrix.
#     
#     @param start_position (Position): Position to translate
#     @param quantity (int): Total amount of Positions to create
#     @param limits (tuple(int)): Maximum amount of positions for each direction
#     @param vectors (tuple(Vector)): Step translation vector for each direction.
#     @return positions ([Position]): The translated positions.
#     """
#     assert quantity <= multiply_numbers(limits)
#     assert isinstance(limits, list)
#     assert len(limits) == len(vectors)
#     
#     Position = start_position.__class__
#     start_center = start_position.center
#     start_orientation = start_position.orientation
#     
#     if len(limits) == 1:
#         vector = vectors[0]
#         return [Position(start_center + vector * index, start_orientation)
#                 for index in xrange(quantity)]
#     else:
#         positions = []
#         # Note: could be done with list.pop(-1) too, but then we also need to copy the list
#         limits, limit = limits[:-1], limits[-1]
#         vectors, vector = vectors[:-1], vectors[-1]
#         max_row_length = multiply_numbers(limits)
#         for index in xrange(limit):
#             row_start_position = Position(start_center + vector * index, start_orientation)
#             row_length = min(max_row_length, quantity - len(positions))
#             if row_length == 0:
#                 break
#             positions.extend(_matrix_positions(row_start_position, row_length, limits, vectors))
#         return positions
#         
# 
# def radial_positions(center_position, start_position, quantity, vector='up', angle=None):
#     """
#     @param center_position (Position): center position for the rotation
#     @param start_position (Position): position that will be translated and rotated around the given 
#         center position
#     @param rotation_vector (Vector|str): vector that indicates the rotation plane and direction, 
#         relative to the center position orientation. By default, the xy-plane (z axis)
#     @param angle (float): angle over which to rotate. Can be negative. By default 360 degrees.
#     
#     Note: No reference_position argument like linear and matrix positions: center_position is used.
#         Would it be useful to add it?
#     """
#     if not isinstance(center_position, GenericPosition):
#         raise TypeError("center_position must be a Position, got " + repr(center_position))
#     if not isinstance(start_position, GenericPosition):
#         raise TypeError("start_position must be a Position, got " + repr(start_position))
#     if not isinstance(quantity, numbers.Integral) or quantity < 0:
#         raise TypeError("quantity must be a positive integer, got " + repr(quantity))
#     if angle is not None:
#         if not (isinstance(angle, numbers.Real) and angle < 2 * math.pi):
#             raise TypeError("If given, angle must be a number smaller than 2 * pi. Got " + repr(angle))
#         
#     Position = start_position.__class__
#     center_center = center_position.center
#     center_orientation = center_position.orientation
#     start_orientation = start_position.orientation
#     
#     location_vector = center_center.vector_to(start_position.center)
#     rotation_vector = center_orientation.ensure_vector(vector)
#     angle_step = math.pi * 2 / quantity if angle is None else angle / (quantity - 1)
#     
#     positions = []
#     for index in xrange(quantity):
#         angle = angle_step * index
#         center = center_center + location_vector.rotate(rotation_vector, angle)
#         orientation = start_orientation.rotate(rotation_vector, angle)
#         positions.append(Position(center, orientation))
#         
#     return positions
# 
# 
# def helix_positions(center_position, start_position, quantity, distance, vector='up', angle=math.pi*2):
#     """
#     @param center_position (Position): center position for the rotation
#     @param start_position (Position): position that will be translated and rotated around the 
#         given center position and along the translation vector
#     @param quantity (int): amount of Positions to create
#     @param distance (float): length of the center line of the helix
#     @param vector (Vector|str): vector that indicates the translation direction and rotation plane, 
#         relative to the center position orientation.
#     @param angle (float): angle over which to rotate. To rotate in the opposite direction than vector,
#         use negative angles. By default 360 degrees.
#     """
#     raise NotImplementedError
# 
# 
# def spiral_positions(center_position, end_position, quantity, vector, factor=1):
#     raise NotImplementedError
# 
# 
# def positions_along_curve(start_position, quantity, curve, align_z=False):
#     """
#     @param start_position (Position): position that will be translated and possible rotated
#     @param quantity (int): amount of Positions to create
#     @param curve (Curve): curve to follow. The curve will be translated to the start_position
#     @param align_z (bool): Align the z-axis of the generated positions to be tangent to the curve. 
#         The xy-plane will then be perpendicular to the curve, but the orientation of the x and y 
#         axis will be arbitrary.
#     
#     @todo can we / should we give a meaningful direction of the x and y axis?
#     """
#     raise NotImplementedError

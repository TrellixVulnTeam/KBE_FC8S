#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

# TODO (TBD): use of BRepFeat_Gluer, LocOpe_FindEdges
# /todo http://opencascade.blogspot.nl/2009/02/continued.html
import os
import warnings
from numbers import Number

from OCC.wrapper.BRepFeat import BRepFeat_Gluer, BRepFeat_SplitShape
from OCC.wrapper.GEOMAlgo import GEOMAlgo_Gluer, GEOMAlgo_Splitter
from OCC.wrapper.LocOpe import LocOpe_FindEdges
from OCC.wrapper.TopAbs import (
    TopAbs_COMPOUND, TopAbs_EDGE, TopAbs_FACE, TopAbs_SHELL, TopAbs_SOLID,
    TopAbs_WIRE)
from OCC.utils.top import edges_to_wire, faces_to_shell, sub_shapes
from OCC.utils.utilities import make_TopoDS_Compound

from parapy.core import Attribute, Base, Input, Part, ensure_iterable
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.generic.positioning import AbstractPoint, Point
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.compound import Compound, Compound_
from parapy.geom.occ.curve import Curve
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import Surface
from parapy.geom.occ.transform import ModifiedShape
from parapy.geom.occ.utilities import (
    SubShapeGenerator_, TopoDS_Shape_Downcast,
    extract_shape_algo_errors_warnings,
    topods_shape_getter)
from parapy.geom.occ.vertex import Vertex, Vertex_
from parapy.geom.occ.wire import Wire_


class GluedSolids(Compound_):
    """Can glue various :attr:`solids_in` on their common faces, resulting in
    a *compound* of multiple solids in which internal faces are shared. You
    can access individual solids from :attr:`solids`. Usage:

    >>> from parapy.geom import translate, Box, GluedSolids
    >>> box1 = Box(1, 1, 1)
    >>> box2 = Box(1, 1, 1, position=translate(box1.position, x=1))
    >>> glue = GluedSolids(solids_in=[box1, box2])
    >>> len(glue.solids)
    2
    >>> len(glue.faces)
    11
    """

    __icon__ = os.path.join(ICN_DIR, 'fuse.png')
    __initargs__ = ["solids_in"]

    #: List of solids that are glued
    #: :type: collections.Sequence[parapy.geom.Solid]
    solids_in = Input()

    #: tolerance
    #: :type: float
    tolerance = Input(1.0e-6)

    #: keep non-solids?
    #: :type: bool
    keep_non_solids = Input(False)

    #: computer internal shapes?
    #: :type: bool
    compute_internal_shapes = Input(False)

    #: check geometry?
    #: :type: bool
    check_geometry = Input(True)

    BUILDERKEY = "Result"

    @Attribute
    def builder(self):
        """Builder object creating this :class:`GluedSolids`.

        :rtype: OCC.GEOMAlgo.GEOMAlgo_Gluer
        """
        builder = GEOMAlgo_Gluer()
        topods_compound = make_TopoDS_Compound(
            map(topods_shape_getter, self.solids_in))
        builder.SetCheckGeometry(self.check_geometry)
        builder.ComputeInternalShapes(self.compute_internal_shapes)
        builder.SetTolerance(self.tolerance)
        builder.SetKeepNonSolids(self.keep_non_solids)
        builder.SetShape(topods_compound)
        builder.Perform()

        error_status = builder.ErrorStatus()
        warning_status = builder.WarningStatus()
        if not error_status == 0:
            msg = ("GEOMAlgo_Gluer failed with status: {}. Check solids_in. "
                   "Object: {}.")
            raise RuntimeError(msg.format(error_status, self))
        if not warning_status == 0:
            if warning_status == 1:
                msg = ("No faces were glued. Check solids_in. Object: {}.")
                warnings.warn(msg.format(self))
            else:
                msg = ("GEOMAlgo_Gluer warned with status: {}. Check solids_in. "
                       "Object: {}.")
                warnings.warn(msg.format(warning_status, self))

        return builder


# TODO (TBD): should we also wrap Partition_Spliter?
class PartitionedSolid(Compound_):
    """Creates a partioned topology from multiple intersecting solids.
    The shape itself is a multi-manifold. The :attr:`solids` slots contains a
    list of individuals solids. Make sure your tools don't intersect each
    other.

    Usage:

    >>> from parapy.geom import Box, Cylinder, PartitionedSolid
    >>> box = Box(3, 3, 3, centered=True)
    >>> cyl = Cylinder(radius=1, height=4, centered=True)
    >>> obj = PartitionedSolid(solid_in=box, tool=cyl)
    >>> len(obj.solids)
    2
    >>> len(obj.faces)
    9

    If you want to keep the tool object(s), use :attr:`keep_tool`:

    >>> obj = PartitionedSolid(solid_in=box, tool=cyl, keep_tool=True)
    >>> len(obj.solids)
    4
    >>> len(obj.faces)
    13
    """

    __initargs__ = ["solid_in", "tool"]

    #: the thing to cut
    #: :type: parapy.geom.occ.solid.Solid_
    solid_in = Input()

    #: the thing or things to partition with
    #: :type: parapy.geom.BRep | collections.Sequence[parapy.geom.BRep]
    tool = Input()

    #: boolean or sequence of booleans (one for each tool) to control whether
    #: the tool(s) themselves should be kept.
    #: :type: bool | collections.Sequence[bool]
    keep_tool = Input(False)

    #: **DEPRECATED**
    #: :type: bool
    compute_internal_shapes = Input(True)

    #: color of the partitioned solids
    #: :type: collections.Sequence[str]
    colors = Input(["RED", "GREEN", "BLUE", "YELLOW", "CYAN", "ORANGE"])

    #: If True, parallel processing is enabled.
    #: :type: bool
    parallel = Input(True)

    #: Additional tolerance that can be specified to allow this boolean
    #: operation to robustly handle cases of touching and near-coincident
    #: entities of the argument shapes.
    #: :type: float | None
    fuzzy_value = Input(None)

    #: In non-destructive mode the argument shapes are not modified. Instead
    #: a copy of a sub-shape is created in the result if it is needed to be
    #: updated.
    #: :type: bool
    non_destructive = Input(True)

    BUILDERKEY = "Shape"  # self.builder.Shape()

    @Attribute
    def _keep_tools(self):
        """Tools to keep in the result.

        :rtype: collections.Sequence[parapy.geom.Solid]
        :raises ValueError: If :attr:`keep_tool` is iterable, but the length
            of :attr:`keep_tool` is not equal to the length of :attr:`tool`
        """
        keep_tools = ensure_iterable(self.keep_tool)
        tools = ensure_iterable(self.tool)
        L1 = len(keep_tools)
        L2 = len(tools)
        if L1 == 1:
            return keep_tools * L2
        else:
            if not len(keep_tools) == len(tools):
                msg = ("If you provide keep_tools as iterable, its length of "
                       "should match the length of tools. {:} != {:}.")
                raise ValueError(msg.format(L1, L2))
            return keep_tools

    @Attribute
    def builder(self):
        """The builder object creating this :class:`PartitionedSolid`.

        :rtype: OCC.GEOMAlgo.GEOMAlgo_Splitter
        :raises Exception: if something went wrong during the construction
            of the partitioned solid.
        """
        if self.is_user_defined("compute_internal_shapes"):
            msg = ("PartionedSolid.compute_internal_shapes has been "
                   "deprecated. Do not specify its value. Object: {}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)

        builder = GEOMAlgo_Splitter()

        if self.parallel:
            builder.SetRunParallel(True)
        if self.fuzzy_value is not None:
            builder.SetFuzzyValue(self.fuzzy_value)
        if self.non_destructive:
            builder.SetNonDestructive(True)

        builder.AddArgument(self.solid_in.TopoDS_Shape)
        tools = ensure_iterable(self.tool)
        keep_tools = self._keep_tools
        for tool, keep in zip(tools, keep_tools):
            if keep:
                builder.AddArgument(tool.TopoDS_Shape)
            else:
                builder.AddTool(tool.TopoDS_Shape)

        builder.Perform()
        self._check_builder(builder)
        return builder

    def _check_builder(self, builder):
        """Checks GEOMAlgo_Splitter object ``builder`` for any error or
        warning messages.

        :type builder: OCC.GEOMAlgo.GEOMAlgo_Splitter
        :raises RuntimeError: if ErrorStatus() is not 0.
        """
        msg_fail = ("GEOMAlgo_Splitter failed: {{}}. Check solid_in "
                    "and/or tool. Object: {}.").format(self)
        msg_warn = ("GEOMAlgo_Splitter warns: {{}}. Check solid_in "
                    "and/or tool. Object: {}.").format(self)
        extract_shape_algo_errors_warnings(builder, msg_fail=msg_fail, msg_warn=msg_warn)

    @Part(parse=False, trickle_down=False)
    def solids(self):
        """Partioned solids.

        :rtype: list[parapy.geom.Solid]
        """
        solids = list(self._sub_shape_generator("solid"))
        colors = self.colors
        n = len(colors)
        for i, solid in enumerate(solids):
            solid.color = colors[i % n]
        return solids


class SplitMixin(Base):
    """Abstract mixin class for concrete Split subclasses.

    .. caution:: SLOW if distance between tools are really small!!!
    """

    __initargs__ = ("built_from", "tool")
    __icon__ = os.path.join(ICN_DIR, 'split.png')

    #: Shape to split.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: (sequence of) geometric *tools* to split this object with.
    #: :type: Curve | Surface | collections.Sequence[Curve | Surface]
    tool = Input()

    #: Used to displaying various faces.
    #: :type: collections.Sequence[str | tuple[float, float, float]]
    colors = Input(["RED", "GREEN", "BLUE", "YELLOW",
                    "CYAN", "BLACK", "ORANGE"])

    #: **DEPRECATED**
    #: :type: bool
    compute_internal_shapes = Input(True)

    #: If True, parallel processing is enabled.
    #: :type: bool
    parallel = Input(True)

    #: Additional tolerance that can be specified to allow this boolean
    #: operation to robustly handle cases of touching and near-coincident
    #: entities of the argument shapes.
    #: :type: float | None
    fuzzy_value = Input(None)

    #: In non-destructive mode the argument shapes are not modified. Instead
    #: a copy of a sub-shape is created in the result if it is needed to be
    #: updated.
    #: :type: bool
    non_destructive = Input(True)

    @Attribute
    def builder(self):
        """The builder object creating this split.

        :rtype: OCC.GEOMAlgo.GEOMAlgo_Splitter
        """
        builder = self._init_builder()

        argument, tools = self._argument_and_tools()
        builder.AddArgument(argument)
        for tool in tools:
            builder.AddTool(tool)

        builder.Perform()
        self._check_builder(builder)
        return builder

    @Attribute
    def TopoDS_Shape(self):
        """Underlying shape that represents the result of the split operation.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    def _init_builder(self):
        """Creates a GEOMAlgo_Splitter object.

        :rtype: OCC.GEOMAlgo.GEOMAlgo_Splitter
        """
        if self.is_user_defined("compute_internal_shapes"):
            msg = ("{}.compute_internal_shapes has been "
                   "deprecated. Do not specify its value. Object: {}.")
            warnings.warn(msg.format(type(self).__name__, self),
                          ParaPyDeprecationWarning)

        builder = GEOMAlgo_Splitter()

        if self.parallel:
            builder.SetRunParallel(True)
        if self.fuzzy_value is not None:
            builder.SetFuzzyValue(self.fuzzy_value)
        if self.non_destructive:
            builder.SetNonDestructive(True)

        return builder

    def _check_builder(self, builder):
        """Checks GEOMAlgo_Splitter object ``builder`` for any error or
        warning messages.

        :type builder: OCC.GEOMAlgo.GEOMAlgo_Splitter
        :raises RuntimeError: if ErrorStatus() is not 0.
        """
        msg_fail = ("GEOMAlgo_Splitter failed: {{}}. Check solid_in "
                    "and/or tool. Object: {}.").format(self)
        msg_warn = ("GEOMAlgo_Splitter warns: {{}}. Check solid_in "
                    "and/or tool. Object: {}.")
        extract_shape_algo_errors_warnings(builder, msg_fail=msg_fail, msg_warn=msg_warn)

    def _argument_and_tools(self):
        """Returns arguments TopoDS_Shape and list of tool TopoDS_Shapes for
        builder.

        :rtype: (OCC.TopoDS.TopoDS_Shape, list[OCC.TopoDS.TopoDS_Shape])
        """
        raise NotImplementedError()


class SplitEdge(SplitMixin, Wire_):
    """Split an edge with tools to make a wire consisting of multiple edges.

    Usage:

    >>> from parapy.geom import Point, LineSegment, Plane, SplitEdge
    >>> crv = LineSegment(Point(0, 0, 0), Point(0, 0, 1))
    >>> # first split using curve parameter
    >>> tool1 = 0.2
    >>> # second split using a Point
    >>> tool2 = Point(0, 0, 0.4)
    >>> # third split using another Curve
    >>> tool3 = LineSegment(Point(-1, 0, 0.6), Point(1, 0, 0.6))
    >>> # fourth split using a Surface
    >>> tool4 = Plane(Point(0, 0, 0.8))
    >>> obj = SplitEdge(built_from=crv, tool=[tool1, tool2, tool3, tool4])
    >>> len(obj.edges)
    5
    >>> obj.dynamic_shape_type
    <class 'parapy.geom.occ.wire.Wire_'>
    >>> obj.length
    1.0
    """

    __initargs__ = ("built_from", "tool")
    __icon__ = os.path.join(ICN_DIR, 'split.png')

    #: Curve, edge or Wire to split
    #: :type: parapy.geom.Curve
    built_from = Input()

    #: single parameter or point, or list of these. Only specify internal
    #: values, where you want a split. Don't include limits of the curve_in.
    #: :type: float|AbstractPoint|Curve|Surface|collections.Sequence[float|AbstractPoint|Curve|Surface]
    tool = Input()

    def _argument_and_tools(self):
        curve = self.built_from
        tool = self.tool

        arg_shape = curve.TopoDS_Shape
        st = arg_shape.ShapeType()
        if st == TopAbs_EDGE:
            arg_shape = edges_to_wire(arg_shape)
        elif st != TopAbs_WIRE:
            msg = ("Input built_from is not a valid edge or wire, but of "
                   "type: {}. Object: {}.")
            raise RuntimeError(msg.format(st, curve))

        if not hasattr(type(tool), "__iter__") or \
                isinstance(tool, AbstractPoint):
            tools = [tool]
        else:
            tools = tool

        tool_shapes = []
        for tool in tools:
            if isinstance(tool, Number):
                topods_shape = Vertex(point=curve.point(tool)).TopoDS_Shape
            elif isinstance(tool, AbstractPoint):
                topods_shape = Vertex(point=Point(*tool)).TopoDS_Shape
            elif isinstance(tool, (Vertex_, Curve, Surface)):
                topods_shape = tool.TopoDS_Shape
            else:
                msg = "Tool is either number, point, curve or surface, not {}."
                raise RuntimeError(msg.format(repr(tool)))
            tool_shapes.append(topods_shape)
        return arg_shape, tool_shapes

    @Attribute
    def TopoDS_Shape(self):
        """Underlying shape that represents the result of the split operation.

        :rtype: OCC.TopoDS.TopoDS_Wire
        """
        shape = self.builder.Shape()
        st = shape.ShapeType()
        if st == TopAbs_WIRE:
            return shape
        elif st == TopAbs_COMPOUND:
            children = list(sub_shapes(shape))
            nb_children = len(children)
            if nb_children == 1:
                child, = children
                st_child = child.ShapeType()
                if st_child == TopAbs_WIRE:
                    return child
                else:
                    msg = ("Result is not a wire, but shape with type: {}. "
                           "Object: {}")
                    raise RuntimeError(msg.format(st_child, self))
            else:
                msg = ("Result is not a single wire. Found {} results. "
                       "Object: {}.")
                raise RuntimeError(msg.format(nb_children, self))

    @Part(parse=False, trickle_down=False)
    def edges(self):
        """Edges resulting from this split operation.

        :rtype: collections.Sequence[parapy.geom.Edge]
        """
        edges = list(self._sub_shape_generator("edge"))
        colors = self.colors
        n = len(colors)
        for i, edge in enumerate(edges):
            color = colors[i % n]
            edge.color = color
        return edges

    # TODO (TBD): remove this hackish fix. Author: RvD.
    history = BRep.history


class SplitSurface(SplitMixin, Shell_):
    """Split surface (Surface, Face or Shell) with curve. Be careful: SLOW if
    distance between tools is really small! Usage:

    >>> from parapy.geom import SplitSurface, LineSegment, Box
    >>> face = Box(1, 1, 1).top_face
    >>> edge = face.edges[0]
    >>> pt1 = edge.midpoint
    >>> pt2 = edge.opposite_edge.midpoint
    >>> tool = LineSegment(start=pt1, end=pt2)
    >>> split = SplitSurface(built_from=face, tool=tool)
    >>> len(split.faces)
    2
    >>> split.dynamic_shape_type
    <class 'parapy.geom.occ.shell.Shell_'>
    >>> split.area
    1.0
    """

    def _argument_and_tools(self):
        built_from = self.built_from
        tool = self.tool

        arg_shape = built_from.TopoDS_Shape
        st = arg_shape.ShapeType()
        if st == TopAbs_FACE:
            arg_shape = faces_to_shell(arg_shape)
        elif st != TopAbs_SHELL:
            msg = ("Input built_from is not a valid face or shell, but of "
                   "type: {}. Object: {}.")
            raise RuntimeError(msg.format(st, built_from))

        tool_shapes = list(map(topods_shape_getter, ensure_iterable(tool)))

        return arg_shape, tool_shapes

    @Attribute
    def TopoDS_Shape(self):
        """Underlying shape that represents the result of the split operation.

        :rtype: OCC.TopoDS.TopoDS_Wire
        """
        shape = self.builder.Shape()
        st = shape.ShapeType()
        if st == TopAbs_SHELL:
            return shape
        elif st == TopAbs_COMPOUND:
            children = list(sub_shapes(shape))
            nb_children = len(children)
            if nb_children == 1:
                child, = children
                st_child = child.ShapeType()
                if st_child == TopAbs_SHELL:
                    return child
                else:
                    msg = ("Result is not a shell, but shape with type: {}. "
                           "Object: {}")
                    raise RuntimeError(msg.format(st_child, self))
            else:
                msg = ("Result is not a single shell. Found {} results. "
                       "Object: {}.")
                raise RuntimeError(msg.format(nb_children, self))

    @Part(parse=False, trickle_down=False)
    def faces(self):
        """Faces resulting from this split operation.

        :rtype: collections.Sequence[parapy.geom.Face]
        """
        faces = list(self._sub_shape_generator("face"))
        colors = self.colors
        n = len(colors)
        for i, face in enumerate(faces):
            face.color = colors[i % n]
        return faces


class SplitSolid(SplitMixin, Solid_):
    """Split solids with a surface. Usage:

    >>> from parapy.geom import Plane, Box, SplitSolid
    >>> box = Box(1, 1, 1, centered=True)
    >>> plane = Plane()
    >>> split = SplitSolid(built_from=box, tool=plane)
    >>> len(split.solids)
    2
    >>> split.solids[0].volume, split.solids[1].volume  # doctest: +ELLIPSIS
    (0.4999..., 0.4999...)
    """
    def _argument_and_tools(self):
        built_from = self.built_from
        tool = self.tool

        arg_shape = built_from.TopoDS_Shape
        st = arg_shape.ShapeType()
        if st != TopAbs_SOLID:
            msg = ("Input built_from is not a valid solid, but of "
                   "type: {}. Object: {}.")
            raise RuntimeError(msg.format(st, built_from))

        tool_shapes = list(map(topods_shape_getter, ensure_iterable(tool)))

        return arg_shape, tool_shapes

    @Part(parse=False, trickle_down=False)
    def solids(self):
        """Solids resulting from this split operation.

        :rtype: collections.Sequence[parapy.geom.Solid]
        """
        solids = list(self._sub_shape_generator("solid"))
        colors = self.colors
        n = len(colors)
        for i, solid in enumerate(solids):
            solid.color = colors[i % n]
        return solids


# TODO (TBD): implement modified(). Author: RvD.
class LocalSplitMixin(SplitMixin):

    __initargs__ = ["built_from", "tool", "domain"]

    #: Face or iterable of Face.
    #: :type: parapy.geom.Face | collections.Sequence[parapy.geom.Face]
    domain = Input()

    #: If vertices aren't affected in the split operation, set to False
    #: :type: bool
    check_vertices = Input(True)

    #: show intermediate steps
    #: :type: bool
    show_all_steps = Input(False)

    @Attribute
    def faces_to_keep(self):
        """Faces that are kept in the results (which are not in
        :attr:`domain`). No split operation will be performed on these faces.

        :rtype: list[parapy.geom.Face]
        """
        v = set(map(topods_shape_getter, ensure_iterable(self.domain)))
        return [f for f in self.built_from.faces if f.TopoDS_Shape not in v]

    @Part
    def shape_to_split(self):
        """Shape that will split. It is the same shape as :attr:`built_from`,
        but with :attr:`faces_to_keep` removed.

        :rtype: parapy.geom.BRep
        """
        return ModifiedShape(self.built_from,
                             remove=self.faces_to_keep,
                             hidden=not self.show_all_steps)

    @Part
    def split(self):
        """The split surface. It is a local split on the faces in
        :attr:`domain`.

        :rtype: parapy.geom.SplitSurface
        """
        return SplitSurface(built_from=self.shape_to_split.shape,
                            pass_down="tool",
                            hidden=not self.show_all_steps)

    @Part
    def merge(self):
        """The result of the local split operation, again merged with
        the :attr:`faces_to_keep`.

        :rtype: parapy.geom.occ.transform.ModifiedShape
        """
        return ModifiedShape(self.built_from,
                             replace=self.replace,
                             hidden=not self.show_all_steps)

    @Attribute
    def replace(self):
        """The modified faces that were modified by the split operation.

        :rtype: list[parapy.geom.Face]
        """
        lst = []
        s = self.shape_to_split.shape
        f_mod = self.split.modified
        # RvD 2016-07-10: also replacing vertices, if required.
        if self.check_vertices:
            subshapes = s.vertices + s.edges + s.faces
        else:
            subshapes = s.edges + s.faces
        for old in subshapes:
            shapes = f_mod(old)
            if shapes:
                if len(shapes) == 1:
                    new = shapes[0]
                else:
                    new = Compound(shapes)
                lst.append((old, new))
        return lst

    @Attribute
    def builder(self):
        """:rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape"""
        return self.merge.builder

    @Attribute
    def TopoDS_Shape(self):
        """The underlying shape representing the split operation its
        result.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.merge.shape.TopoDS_Shape

    def modified(self, shape):
        raise NotImplementedError

    def is_deleted(self, shape):
        return False

    def history(self, shape, failure='raise'):
        """Return the shape(s) that resulted from ``shape`` by this split
        operation.

        :param parapy.geom.BRep shape: Shape to show the history of.
        :param str failure: One of 'raise', 'warn', 'ignore'
        :rtype: parapy.geom.BRep | collections.Sequence[parapy.geom.BRep]
        """
        old_topods_shape = shape.TopoDS_Shape

        def reshape_step(s):
            """Returns list of new shapes after Reshaping step"""
            new_topods_shape = self.builder.Value(s.TopoDS_Shape)
            if new_topods_shape.IsNull():
                msg = ("shape {:} was deleted during reshape: --> [] returned")
                warnings.warn(msg.format(s))
                return []
            elif new_topods_shape.ShapeType() == 0:
                new_shapes = SubShapeGenerator_(
                    new_topods_shape, old_topods_shape.ShapeType())
                return self._TopoDS2Shapes(new_shapes,
                                           old_topods_shape.ShapeType(),
                                           failure=failure)
            else:
                return [self._TopoDS2Shape(new_topods_shape,
                                           new_topods_shape.ShapeType(),
                                           failure=failure)]

        split_shapes = self.split.history(shape)
        if split_shapes:  # there is a history with the split tool
            result = []
            for split_shape in split_shapes:
                result.extend(reshape_step(split_shape))

            return result
        else:
            # no history with split, we were probably one of the 'faces to
            # keep'
            return reshape_step(shape)


# FIXME (TBD): history methods.
class LocalSplitSurface(LocalSplitMixin, Shell_):
    """Only apply split on part of the shell. Only history() can be
    called.

    >>> from parapy.geom import Plane, Box, LocalSplitSurface
    >>> box = Box(1, 1, 1, centered=True)
    >>> surface = box.outer_shell
    >>> tool = Plane()
    >>> domain = box.right_face
    >>> split = LocalSplitSurface(surface, tool, domain)
    >>> len(split.faces)
    7
    """


# FIXME (TBD): history methods.
class LocalSplitSolid(LocalSplitMixin, Solid_):
    """Only apply split on part of the solid. Only history() can be
    called.

    >>> from parapy.geom import Plane, Box, LocalSplitSolid
    >>> box = Box(1, 1, 1, centered=True)
    >>> tool = Plane()
    >>> domain = box.right_face
    >>> split = LocalSplitSolid(box, tool, domain)
    >>> len(split.faces)
    7
    """


# Pure OpenCascade counterparts
class GluedSolidsOCC(Solid_):
    """Make a new solid by glueing :attr:`solid1` and :attr:`solid2` at their
    touching faces :attr:`face1` and :attr:`face2`. Completely removes
    internal faces and edges. This class is an, be it
    rather limited, alternative to de-facto :class:`GluedSolids` class. Usage:

    >>> from parapy.geom import translate, Box
    >>> from parapy.geom.occ.salome import GluedSolidsOCC
    >>> box1 = Box(1, 1, 1)
    >>> box2 = Box(1, 1, 1, position=translate(box1.position, x=1))
    >>> glue = GluedSolidsOCC(solid1=box1, solid2=box2,
    ...                       face1=box1.right_face, face2=box2.left_face)
    >>> len(glue.faces)
    6

    .. caution:: only specify faces that are touching. If faces aren't
        touching, they will become topologically glued, which may lead to
        unexpected results.
    """
    __initargs__ = ["solid1", "solid2", "face1", "face2"]
    #: :type: parapy.geom.occ.solid.Solid_
    solid1 = Input()
    #: :type: parapy.geom.occ.solid.Solid_
    solid2 = Input()
    #: :type: parapy.geom.occ.face.Face_
    face1 = Input()
    #: :type: parapy.geom.occ.face.Face_
    face2 = Input()
    #tolerance = Input(1.0e-6)
    BUILDERKEY = "Shape"

    @Attribute
    def builder(self):
        """The builder object creating this glued solid.

        :rtype: OCC.BRepFeat.BRepFeat_Gluer
        :raises Exception: when something went wrong during the construction
            of the glued solid.
        """
        builder = BRepFeat_Gluer(self.solid1.TopoDS_Shape,
                                 self.solid2.TopoDS_Shape)
        builder.Bind(self.face1.TopoDS_Face, self.face2.TopoDS_Face)
        edge_iterator = LocOpe_FindEdges(self.face1.TopoDS_Face,
                                         self.face2.TopoDS_Face)
        edge_iterator.InitIterator()
        while edge_iterator.More():
            builder.Bind(edge_iterator.EdgeFrom(), edge_iterator.EdgeTo())
            edge_iterator.Next()
        builder.Build()
        if builder.IsDone():
            return builder
        else:
            raise Exception("glueing failed")


class SplitFaceOCC(Shell_):
    """(Limited) alternative to :class:``SplitFace`, but without the need for
    Salome algorithms. Usage:

    >>> from parapy.geom import LineSegment, Box
    >>> from parapy.geom.occ.salome import SplitFaceOCC
    >>> face = Box(1, 1, 1).top_face
    >>> edge = face.edges[0]
    >>> pt1 = edge.midpoint
    >>> pt2 = edge.opposite_edge.midpoint
    >>> tool = LineSegment(start=pt1, end=pt2)
    >>> split = SplitFaceOCC(face_in=face, tool=tool)
    >>> len(split.faces)
    2

    .. caution:: Self-intersecting tool topologies should be prevented!!!
        Ensure this yourself on input side.
    """

    __initargs__ = ["face_in", "tool"]
    BUILDERKEY = "Shape"

    #: :type: parapy.geom.Face
    face_in = Input()

    #: for example a curve, edge, wire or list of them
    #: :type: parapy.geom.Curve | collections.Sequence[parapy.geom.Curve]
    tool = Input()

    #: color for split sub-shapes
    #: :type: collections.Sequence[str | tuple[float, float, float]]
    colors = Input(["RED", "GREEN", "BLUE", "YELLOW",
                    "CYAN", "BLACK", "ORANGE"])

    @Attribute
    def builder(self):
        """The builder object creating this split face.

        :rtype: OCC.BRepFeat.BRepFeat_SplitShape
        :raises Exception: when something went wrong during the construction
            of the split face.
        """
        tool = ensure_iterable(self.tool)
        topods_face = self.face_in.TopoDS_Face
        builder = BRepFeat_SplitShape(topods_face)
        for t in tool:
            builder.Add(TopoDS_Shape_Downcast(t.TopoDS_Shape), topods_face)
        builder.Build()
        if builder.IsDone():
            return builder
        else:
            raise Exception("BRepFeat_SplitShape failed")

    @Part(parse=False, trickle_down=False)
    def faces(self):
        """The faces of this split face.

        :rtype: list[parapy.geom.Face]
        """
        faces = list(self._sub_shape_generator("face"))
        colors = self.colors
        n = len(colors)
        for i, face in enumerate(faces):
            face.color = colors[i % n]
        return faces


if __name__ == '__main__':
    from parapy.gui import display

    from parapy.geom import Box, Plane

    box = Box(1, 2, 3)
    pln = Plane(Point(0, 0, 1.5))
    split1 = SplitSurface(box, pln)
    split2 = LocalSplitSurface(box, pln, domain=box.right_face)
    print(split2.history(box.right_face))
    # display((split1, split2))

    from parapy.geom import Box, Plane, LocalSplitSurface, translate
    box = Box(1, 2, 3)
    tool = Plane(reference=translate(box.position, z=1.5))
    domain = box.right_face
    split = LocalSplitSurface(box.outer_shell, tool, domain)
    display(split)

    from parapy.geom import Box, Plane, LocalSplitSolid, translate
    box = Box(1, 2, 3)
    tool = Plane(reference=translate(box.position, z=1.5))
    domain = box.right_face
    split = LocalSplitSolid(box, tool, domain)
    display(split)

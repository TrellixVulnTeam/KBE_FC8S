#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from OCC.wrapper.BRepBndLib import BRepBndLib__Add, BRepBndLib__AddOBB
from OCC.wrapper.BRepMesh import BRepMesh_IncrementalMesh
from OCC.wrapper.Bnd import Bnd_Box, Bnd_OBB

from parapy.core import Attribute, Input
from parapy.core.base import DrawableBase
from parapy.core.utilities import get_rgb_value
from parapy.core.validate import OneOf, Optional, Range, is_positive
from parapy.geom import Orientation, Point, Vector, translate
from parapy.geom.generic.geom_base import GeomBase


class DrawableShape(GeomBase, DrawableBase):
    """Abstract class. DrawableBase classes can be drawn in the ParaPy user
    interface. Subclasses need to implement _drawable_TopoDS_Shape.
    """

    #: Value 0.0 is opaque, 1.0 is fully transparent.
    #: :type: float | None
    transparency = Input(None, defaulting=True,
                         validator=Optional(Range(0.0, 1.0)))

    #: Thickness of lines in wireframe mode.
    #: :type: int | None
    line_thickness = Input(None, defaulting=True,
                           validator=Optional(is_positive))

    #: Controls display mode in GUI. Valid options: 'shaded' or 'wireframe'.
    #: :type: str | None
    display_mode = Input(None, defaulting=True,
                         validator=Optional(OneOf(["shaded", "wireframe"])))

    #: number of isolines (u and v). Only useful for 2d/3d objects.
    #: :type: int | (int, int) | None
    isos = Input(None)

    #: Sometimes the bounding box derived from pure geometry can be way too
    #: large. In such cases we recommend to derive the bounding box from a
    #: discretized mesh instead, by setting this flag True. You can also alter
    #: the mesh_deflection to achieve the desired accuracy. Typical values are
    #: between 1.0e-2 and 1.0e-5. Smaller values are not recommended.
    #: :type: float | None
    mesh_deflection = Input(None, defaulting=True)

    @property
    def TopoDS_Shape(self):
        """:rtype: OCC.TopoDS.TopoDS_Shape"""
        raise RuntimeError("please implement TopoDS_Shape")

    @Attribute
    def _drawable_TopoDS_Shape(self):
        """:rtype: OCC.TopoDS.TopoDS_Shape"""
        return self.TopoDS_Shape

    def _display_style(self):
        """Used for gui, may contain keys like "color", "u_isos", etc."""
        isos = self.isos
        if isos and hasattr(isos, "__iter__"):
            u_isos, v_isos = isos
        else:
            u_isos = v_isos = isos

        return {"color": get_rgb_value(self.color),
                "transparency": self.transparency,
                "display_mode": self.display_mode,
                "line_thickness": self.line_thickness,
                "deviation_coefficient": self.mesh_deflection,
                "u_isos": u_isos,
                "v_isos": v_isos}

    def _apply_mesh(self, deflection):
        """Applies a mesh to a shape. Returns nothing."""
        BRepMesh_IncrementalMesh(self.TopoDS_Shape, deflection)

    # ---------------- bbox -------------------
    @Attribute
    def _Bnd_Box(self):
        """ The OCC bounding box of this BRep

        :rtype: OCC.Bnd.Bnd_Box
        """
        box = Bnd_Box()
        if self.mesh_deflection:
            self._apply_mesh(self.mesh_deflection)
            use_triangulation = True
        else:
            use_triangulation = False

        BRepBndLib__Add(self.TopoDS_Shape, box, use_triangulation)
        return box

    @Attribute
    def _bbox_bounds(self):
        return tuple(self._Bnd_Box.Get())

    @Attribute
    def _Bnd_OBB(self):
        """The OCC oriented bounding box of this BRep.

        :rtype: OCC.Bnd.Bnd_OBB
        """
        box = Bnd_OBB()

        if self.mesh_deflection:
            # The Bnd_OBB is tighter if it uses the triangulation for it
            # a smaller mesh_deflection will improve the quality of the OBB
            self._apply_mesh(self.mesh_deflection)
            use_triangulation = True
        else:
            use_triangulation = False

        BRepBndLib__AddOBB(self.TopoDS_Shape, box, use_triangulation,
                           True, True)
        return box

    @Attribute
    def _oriented_bbox_bounds_and_orientation(self):
        bnd_obb = self._Bnd_OBB

        # extract orientation
        Vx = Vector(*bnd_obb.XDirection().Coord())
        Vy = Vector(*bnd_obb.YDirection().Coord())
        orientation = Orientation(x=Vx, y=Vy)

        # calculate bounds in terms of the ParaPy BBox
        Vz = orientation.Vz
        center = Point(*bnd_obb.Center().Coord())
        half_x_size = bnd_obb.XHSize()
        half_y_size = bnd_obb.YHSize()
        half_z_size = bnd_obb.ZHSize()

        min_pt = translate(center,
                           Vx, -half_x_size,
                           Vy, -half_y_size,
                           Vz, -half_z_size)
        max_pt = translate(center,
                           Vx, half_x_size,
                           Vy, half_y_size,
                           Vz, half_z_size)

        bounds = (min_pt[0], min_pt[1], min_pt[2],
                  max_pt[0], max_pt[1], max_pt[2])
        return bounds, orientation

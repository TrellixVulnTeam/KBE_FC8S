#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import warnings
from functools import partial

from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_MakeFace
from OCC.wrapper.BRepFilletAPI import (
    BRepFilletAPI_MakeChamfer, BRepFilletAPI_MakeFillet,
    BRepFilletAPI_MakeFillet2d)
from OCC.wrapper.BRepTools import BRepTools__OuterWire
from OCC.wrapper.ChFi2d import (
    ChFi2d_BothEdgesDegenerated, ChFi2d_ComputationError,
    ChFi2d_ConnexionError, ChFi2d_FirstEdgeDegenerated,
    ChFi2d_InitialisationError, ChFi2d_IsDone, ChFi2d_LastEdgeDegenerated,
    ChFi2d_NoFace, ChFi2d_NotAuthorized, ChFi2d_NotPlanar,
    ChFi2d_ParametersError, ChFi2d_Ready, ChFi2d_TangencyError)
from OCC.wrapper.ChFiDS import (
    ChFiDS_Error, ChFiDS_Ok, ChFiDS_StartsolFailure, ChFiDS_TwistedSurface,
    ChFiDS_WalkingFailure)
from OCC.wrapper.GeomAbs import GeomAbs_C0, GeomAbs_C1, GeomAbs_C2
from OCC.wrapper.TopoDS import TopoDS__Face

from parapy.core import Attribute, Input
from parapy.core.utilities import raise_conditionally
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRepBuilderWithFix
from parapy.geom.occ.edge import Edge, Edge_
from parapy.geom.occ.face import Face_
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.utilities import (
    TOPABS_NAMES, ancestor_edges, ancestor_faces, unpack_single_shape_compound)
from parapy.geom.occ.vertex import Vertex
from parapy.geom.occ.wire import Wire_

# TODO: add more descriptive stuff from here
# http://www.opencascade.com/doc/occt-6.9.1/refman/html/class_b_rep_fillet_a_p_i___make_fillet2d.html
ChFi2d_ConstructionError = {
    ChFi2d_NotPlanar: "ChFi2d_NotPlanar",
    ChFi2d_NoFace: "ChFi2d_NoFace",
    ChFi2d_InitialisationError: "ChFi2d_InitialisationError",
    ChFi2d_ParametersError: ("ChFi2d_ParametersError: distance or "
                             "angle is less than or equal to zero"),
    ChFi2d_Ready: "ChFi2d_Ready",
    ChFi2d_IsDone: "ChFi2d_IsDone",
    ChFi2d_ComputationError:( "ChFi2d_ComputationError: the parameters of "
                              "the chamfer are too large to build a chamfer "
                              "between the two adjacent edges"),
    ChFi2d_ConnexionError: "ChFi2d_ConnexionError",
    ChFi2d_TangencyError: "ChFi2d_TangencyError",
    ChFi2d_FirstEdgeDegenerated: "ChFi2d_FirstEdgeDegenerated",
    ChFi2d_LastEdgeDegenerated: "ChFi2d_LastEdgeDegenerated",
    ChFi2d_BothEdgesDegenerated: "ChFi2d_BothEdgesDegenerated",
    ChFi2d_NotAuthorized: "ChFi2d_NotAuthorized"}

ChFiDS_ErrorStatus = {
    ChFiDS_Ok: "the computation is Ok",
    ChFiDS_StartsolFailure: ("the computation can't start, perhaps the "
                             "radius is too big"),
    ChFiDS_TwistedSurface: ("the computation failed because of a "
                            "twisted surface"),
    ChFiDS_WalkingFailure: "there is a problem in the walking",
    ChFiDS_Error: "other error different from above"}


class FreeVertexFilletedError(RuntimeError):
    pass


class Chamfered2d(BRepBuilderWithFix):
    """
    Abstract base class for chamfer operations on 2 dimensional shapes. One
    at least has to implement :meth:`build`.
    """

    __initargs__ = ["built_from", "distance", "vertex_table"]

    #: Shape to chamfer.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: Global distance spec for chamfer.
    #: :type: float
    distance = Input(None)

    @Input
    def vertex_table(self):
        """Sequence of (Spec1, ...), where ``Spec`` can take four values:

        1. ``V: Vertex``
        Extremities on both connecting edges are at distance
        :attr:`distance` from ``V``.

        2. ``(V: Vertex, D: float)``
        Extremities on both connecting edges are at distance ``D`` from ``V``.

        3. ``(V: Vertex, e: Edge, D1: float, D2: float)``
        Extremity on ``E`` at distance ``D1`` from ``V``. Extremity
        on other edge at ``D2`` from ``V``.

        4. ``(V: Vertex, E: Edge, dist1: float, Ang: float, "angle")``
        chamfer makes an angle ``An``g with ``E`` and one of
        its extremities is on ``E`` at distance D from ``V``.

        Defaults to ``(V1, V2, ..., Vn)``.

        :rtype: collections.Sequence[Vertex, tuple[Vertex | float | str]]
        """
        return self.built_from.vertices

    @Attribute
    def chamfered_edges(self):
        """Chamfered edges. Same order as vertex_table entries.

        :rtype: tuple[parapy.geom.Edge]
        """
        edges = self.builder.ChamferEdges()
        """:type: OCC.TopTools.TopTools_SequenceOfShape"""
        return self._TopTools_SequenceOfShape2Shapes(edges, shape_type='edge')


class Filleted2d(BRepBuilderWithFix):
    """
    Abstract base class for fillet operations on 2 dimensional shapes. One
    at least has to implement :meth:`build`.
    """

    __initargs__ = ["built_from", "radius", "vertex_table"]

    #: Shape to fillet.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: Global radius spec for fillet.
    #: :type: float
    radius = Input(None)

    @Input
    def vertex_table(self):
        """Sequence of (Spec1, ...), where ``Spec`` can take two values:

        1. ``V: Vertex``
        Extremities on both connecting edges are at distance
        :attr:`radius` from ``V``.

        2. ``(V: Vertex, R: float)``
        fillet with radius ``R`` at vertex ``V``.

        Defaults to ``(V1, V2, ..., Vn)``.

        :rtype: collections.Sequence[Vertex | tuple[Vertex, float]]
        """
        return self.built_from.vertices

    @Attribute
    def filleted_edges(self):
        """Filleted edges. Same order as vertex_table entries.

        :rtype: tuple[parapy.geom.Edge]
        """
        edges = self.builder.FilletEdges()
        """:type: OCC.TopTools.TopTools_SequenceOfShape"""
        return self._TopTools_SequenceOfShape2Shapes(edges, shape_type='edge')


class Chamfered3d(BRepBuilderWithFix):
    """
    Abstract base class for chamfer operations on (closed) shells. One at least
    has to implement :meth:`_validate_topods_shape`.
    """

    __icon__ = os.path.join(ICN_DIR, 'chamferedshape.png')
    __initargs__ = ["built_from", "distance", "edge_table"]

    #: Shape to chamfer.
    #: :type: parapy.geom.occ.brep.BRep
    built_from = Input()

    #: Global distance spec for chamfers. If ``None``, specify distance value
    #: in :attr:`edge_table` entries.
    #: :type: float
    distance = Input(None)

    #: sometimes the shape isn't build correctly, but does return some results,
    #: standard behavior is then to raise an exception. You can this into a
    #: warning ('warn') or ignore it completely ('ignore').
    #: :type: str
    on_invalid = Input('raise')

    @Input
    def edge_table(self):
        """Sequence of (Spec1, ...), where ``Spec`` can take four values:

        1. ``E: Edge``
        Extremities on both connecting faces are at distance :attr:`distance`
        from ``E``.

        2. ``(E: Edge, D: float)``
        Extremities on both connecting face are at distance ``D`` from ``E``.

        3. ``(E: Edge, F: Face, D1: float, D2: float)``
        Extremity on ``F`` at distance ``D1`` from ``E``. Extremity on other
        face at ``D2`` from ``E``.

        4. ``(E: Edge, F: Face, dist1: float, Ang: float, "angle")``
        chamfer makes an angle ``Ang`` with ``F`` and one of its extremities
        is on ``F`` at distance D from ``E``.

        Defaults to ``(E1, E2, ..., En)``.

        :rtype: collections.Sequence[Edge | tuple[Edge | float]]
        """
        return self.built_from.edges

    def build(self):
        """Build the Chamfered3d shape from the edges.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeChamfer
        :raises Exception: if the building process failed
        :raises ValueError: if one of the edge_table entries is not valid.
        :raises RuntimeError: if one of the edges is floating/free or is
            connected to more than two faces.
        """
        topods_shape = self.built_from.TopoDS_Shape
        table = self.edge_table

        def get_ancestor_faces(edge, topods_edge):
            faces = tuple(ancestor_faces(topods_edge, topods_shape,
                                         downcast=True))
            number_of_faces = len(faces)
            if number_of_faces == 2:
                return faces
            elif number_of_faces == 0:
                msg = ("Edge {:} is floating, i.e. does not lie on "
                       "any face.")
            elif number_of_faces == 1:
                msg = "Edge {:} is free, i.e. lies on one face only."
            else:
                msg = ("Edge {:} is on more than 2 faces. "
                       "Multi-connexity is not supported.")
            msg = msg.format(edge)
            raise RuntimeError(msg)

        # hack to evaluate distance only once and when required.
        cache = []
        builder = BRepFilletAPI_MakeChamfer(topods_shape)

        for entry in table:
            if hasattr(entry, "__iter__"):
                N = len(entry)
                if N == 1:
                    edge = entry[0]
                    E = edge.TopoDS_Edge
                    Dis = (cache or
                           not cache.append(self.distance)) and cache[0]
                    F, _ = get_ancestor_faces(edge, E)
                    builder.Add(Dis, E, F)
                elif N == 2:
                    edge, Dis = entry
                    E = edge.TopoDS_Edge
                    F, _ = get_ancestor_faces(edge, E)
                    builder.Add(Dis, E, F)
                elif N == 4:
                    edge, face, Dis1, Dis2 = entry
                    E = edge.TopoDS_Edge
                    F = face.TopoDS_Face
                    builder.Add(Dis1, Dis2, E, F)
                elif N == 5:
                    edge, face, Dis, Angle, token = entry
                    if not token == "angle":
                        fmt = ("fifth element of chamfer spec should be "
                               "'angle', not '{:}'." )
                        msg = fmt.format(token)
                        raise ValueError(msg)
                    E = edge.TopoDS_Edge
                    F = face.TopoDS_Face
                    builder.AddDA(Dis, Angle, E, F)
                else:
                    fmt = "Table entry '{:}' is not a valid spec."
                    msg = fmt.format(entry)
                    raise ValueError(msg)
            else:
                edge = entry
                E = edge.TopoDS_Edge
                Dis = (cache or not cache.append(self.distance)) and cache[0]
                F, _ = get_ancestor_faces(edge, E)
                builder.Add(Dis, E, F)

        builder.Build()

        if builder.IsDone():
            return builder
        else:
            msg = "BRepFilletAPI_MakeChamfer.Build() failed."
            raise Exception(msg)

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """The underlying Open Cascade BRep shape built by :meth:`build`.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = super(Chamfered3d, self).TopoDS_Shape
        return self._validate_topods_shape(topods_shape)

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.
        Should return the validated shape if everything went well.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        raise NotImplementedError()


class Filleted3d(BRepBuilderWithFix):
    """Abstract base class for fillet operations on (closed) shells. One at
    least has to implement :meth:`_validate_topods_shape`.

    .. caution:: the algorithm has two limitations:

        - the end point of the contour is the point of intersection of 4 or
            more edges of the shape, or
        - the intersection of the fillet with a face which limits the contour
            is not fully contained in this face.
    """

    __icon__ = os.path.join(ICN_DIR, 'filletedshape.png')
    __initargs__ = ["built_from", "radius", "edge_table"]

    #: Shape to chamfer / fillet.
    #: :type: parapy.geom.BRep
    built_from = Input()

    #: Global radius spec for fillet.
    #: :type: float
    radius = Input(None)

    #: C-continuity. 0 = C0, 1 = C1, 2 = C2. C2-continuity can be useful on
    #: certain fillet inputs, see example_chfi.
    #: :type: int
    continuity = Input(1)

    #: :type: bool
    on_invalid = Input('raise')

    # TODO (TBD): Explain Tang, Tesp, etc.. Author: FT.
    # /todo - Tang: the G1 tolerance between fillet and support faces
    #: (Tang, Tesp, T2d, TApp3d, TolApp2d, Fleche).
    #: The defaults are: (1.0e-2, 1.e-4, 1.e-5, 1.e-4, 1.e-5, 1.e-3)
    #:
    #: :type: tuple[float, float, float, float, float, float]
    params = Input(None)

    @Input
    def edge_table(self):
        """Sequence of (Spec1, ...), where ``Spec`` can take two values:

        1. ``E: Edge``
        Extremities on both connecting faces are at distance
        :attr:`radius` from ``E``.

        2. ``(V: Edge, R: float)``
        fillet with radius ``R`` at vertex ``V``.

        Defaults to ``(E1, E2, ..., En)``.

        :rtype: collections.Sequence[Edge | tuple[Edge, float]]
        """
        return self.built_from.edges

    def build(self):
        """Build the Filleted3d shape from the edges.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeFillet
        :raises Exception: when a construction error occurs.
        """
        # from OCC.wrapper.ChFi3d import ChFi3d_QuasiAngular, ChFi3d_Polynomial
        topods_shape = self.built_from.TopoDS_Shape
        table = self.edge_table
        continuity = self.continuity
        params = self.params
        continuity_ = (GeomAbs_C0, GeomAbs_C1, GeomAbs_C2)[continuity]

        builder = BRepFilletAPI_MakeFillet(topods_shape)  #, ChFi3d_Polynomial)
        if params:
            Tang, Tesp, T2d, TApp3d, TolApp2d, Fleche = params
            builder.SetParams(Tang, Tesp, T2d, TApp3d, TolApp2d, Fleche)

        # the default of self.params has Tang == 1.0e-2, so self.params should
        # have been set.
        if continuity != 1:
            if params:
                Tang = params[0]
            else:
                Tang = 1.0e-2
            builder.SetContinuity(continuity_, Tang)

        cache = []
        for entry in table:
            if hasattr(entry, "__iter__"):
                edge, R = entry
            else:
                edge = entry
                R = (cache or not cache.append(self.radius)) and cache[0]
            E = edge.TopoDS_Edge
            builder.Add(R, E)

        builder.Build()

        if not builder.IsDone():
            nb_faulty_contours = builder.NbFaultyContours()
            nb_faulty_vertices = builder.NbFaultyVertices()
            lines = ["BRepFilletAPI_MakeFillet.Build() failed.",
                     "Nb of faulty contours: {}".format(nb_faulty_contours),
                     "Nb of faulty vertices: {}".format(nb_faulty_vertices),
                     ]
            for i in range(1, nb_faulty_contours + 1):
                ic = builder.FaultyContour(i)
                error = builder.StripeStatus(ic)
                status = ChFiDS_ErrorStatus[error]
                fmt = "OCC Construction Error contour {:}: '{:}'."
                msg = fmt.format(ic, status)
                lines.append(msg)

            msg = "\n".join(lines)

            raise_conditionally(RuntimeError, msg, self.on_invalid)

        return builder

    @Attribute
    def contours(self):
        """Returns all contours. If the build step failed, you can set
        :attr:`on_invalid` to 'ignore' or 'warn' and still visualize this slot.

        :rtype: list[list[parapy.geom.Edge]]
        """
        builder = self.builder
        nb_contours = builder.NbContours()
        arr = []
        for ic in range(1, nb_contours + 1):
            nb_edges = builder.NbEdges(ic)
            lst = []
            for j in range(1, nb_edges + 1):
                topods_edge = builder.Edge(ic, j)
                lst.append(Edge_(TopoDS_Shape=topods_edge))
            arr.append(lst)
        return arr

    @Attribute
    def faulty_contours(self):
        """Returns all faulty contours. You need to set :attr:`on_invalid` to
        'ignore' or 'warn'.
        
        :rtype: list[list[parapy.geom.Edge]]
        """
        builder = self.builder
        nb_faulty_contours = builder.NbFaultyContours()
        arr = []
        for i in range(1, nb_faulty_contours + 1):
            ic = builder.FaultyContour(i)
            nb_edges = builder.NbEdges(ic)
            lst = []
            for j in range(1, nb_edges + 1):
                topods_edge = builder.Edge(ic, j)
                lst.append(Edge_(TopoDS_Shape=topods_edge))
            arr.append(lst)
        return arr

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """The underlying Open Cascade BRep shape built by :meth:`build`.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = super(Filleted3d, self).TopoDS_Shape
        return self._validate_topods_shape(topods_shape)

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.
        Should return the validated shape if everything went well.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        raise NotImplementedError()


class ChamferedWire(Chamfered2d, Wire_):
    """Use to chamfer vertices of a **PLANAR, CLOSED** wire
    :attr:`built_from`. For uniform, symmetric chamfer on all vertices,
    provide the :attr:`distance` value:

    >>> from parapy.geom import Rectangle, ChamferedWire
    >>> wire = Rectangle(width=2, length=1)
    >>> obj = ChamferedWire(built_from=wire, distance=0.1)

    For control on vertex level, use the :attr:`vertex_table` input. Their are
    four ways to apply chamfers to vertices:

    >>> import math
    >>> v1, v2, v3, v4 = wire.vertices
    >>> table = (# symmetric chamfer with offset ``distance``
    ...          v1,
    ...          # symmetric chamfer with distance 0.2
    ...          (v2, 0.2),
    ...          # assymetric chamfer
    ...          (v3, v3.on_edges[0], 0.2, 0.3),
    ...          # chamfer with angle
    ...          (v4, v3.on_edges[0], 0.3, math.radians(45), "angle"))
    >>> obj = ChamferedWire(built_from=wire, distance=0.1, vertex_table=table)

    See `Open CASCADE <http://opencascade.sourcearchive.com/documentation/
    6.3.0.dfsg.1/classBRepFilletAPI__MakeFillet2d.html>`_.
    """

    __icon__ = os.path.join(ICN_DIR, 'chamferedwire.png')

    def build(self):
        """Build the ChamferedWire shape from the edges.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeFillet2d
        :raises Exception: If error occurred during construction.
        :raises RuntimeError: If given vertices are floating, free or lie on
            more than two edges. Alternatively if there is an error in the
            :attr:`vertex_table`.
        """
        topods_wire = self.built_from.TopoDS_Wire
        face_builder = BRepBuilderAPI_MakeFace(topods_wire, True)
        topods_face = face_builder.Face()
        table = self.vertex_table

        def get_ancestor_edges(vertex, topods_vertex):
            edges = tuple(ancestor_edges(topods_vertex, topods_face,
                                         downcast=True))
            number_of_edges = len(edges)
            if number_of_edges == 2:
                return edges
            elif number_of_edges == 0:
                msg = ("Vertex {:} is floating, i.e. does not lie on "
                       "any edge.")
            elif number_of_edges == 1:
                msg = "Vertex {:} is free, i.e. lies on one edge only."
            else:
                msg = ("Vertex {:} is on more than 2 edges. "
                       "Multi-connexity is not supported.")
            msg = msg.format(vertex)
            raise RuntimeError(msg)

        # hack to evaluate distance only once and when required.
        cache = []
        builder = BRepFilletAPI_MakeFillet2d(topods_face)

        for entry in table:
            if hasattr(entry, "__iter__"):
                N = len(entry)
                if N == 1:
                    vertex = entry[0]
                    V = vertex.TopoDS_Vertex
                    D12 = (cache or
                           not cache.append(self.distance)) and cache[0]
                    E1, E2 = get_ancestor_edges(vertex, V)
                    args = E1, E2, D12, D12
                elif N == 2:
                    vertex, D12 = entry
                    V = vertex.TopoDS_Vertex
                    E1, E2 = get_ancestor_edges(vertex, V)
                    args = E1, E2, D12, D12
                elif N == 4:
                    vertex, edge, D1, D2 = entry
                    V = vertex.TopoDS_Vertex
                    E1 = edge.TopoDS_Edge
                    edges = set(get_ancestor_edges(vertex, V))
                    try:
                        edges.remove(E1)
                    except KeyError:
                        fmt = ("Provided edge '{:}' is no ancestor of vertex "
                               "'{:}'.")
                        msg = fmt.format(edge, vertex)
                        raise RuntimeError(msg)
                    E2 = edges.pop()
                    args = E1, E2, D1, D2
                elif N == 5:
                    vertex, edge, D, Ang, token = entry
                    if not token == "angle":
                        fmt = ("fifth element of chamfer spec should be "
                               "'angle', not '{:}'." )
                        msg = fmt.format(token)
                        raise ValueError(msg)
                    E = edge.TopoDS_Edge
                    V = vertex.TopoDS_Vertex
                    args = E, V, D, Ang
                else:
                    fmt = "Table entry '{:}' is not a valid spec."
                    msg = fmt.format(entry)
                    raise ValueError(msg)
            else:
                vertex = entry
                V = vertex.TopoDS_Vertex
                D12 = (cache or not cache.append(self.distance)) and cache[0]
                E1, E2 = get_ancestor_edges(vertex, V)
                args = E1, E2, D12, D12

            builder.AddChamfer(*args)

        builder.Build()

        if builder.IsDone():
            return builder
        else:
            status = ChFi2d_ConstructionError[builder.Status()]
            fmt = ("BRepFilletAPI_MakeFillet2d.Build() failed.\n"
                   "OCC Construction Error: {:}.")
            msg = fmt.format(status)
            raise Exception(msg)

    @Attribute
    def TopoDS_Shape(self):
        """The shape built by :meth:`build`.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = self.builder.Shape()
        topods_face = TopoDS__Face(topods_shape)
        return BRepTools__OuterWire(topods_face)


class ChamferedFace(Chamfered2d, Face_):
    """Use to chamfer vertices of a **PLANAR** face :attr:`built_from`.
    For uniform, symmetric chamfer on all vertices, provide the
    :attr:`distance` value:

    >>> from parapy.geom import RectangularFace, ChamferedFace
    >>> face = RectangularFace(width=2, length=1)
    >>> obj = ChamferedFace(built_from=face, distance=0.1)

    For control on vertex level, use the :attr:`vertex_table` input. There are
    four ways to apply chamfers to vertices:

    >>> import math
    >>> v1, v2, v3, v4 = face.vertices
    >>> table = (# symmetric chamfer with offset ``distance``
    ...          v1,
    ...          # symmetric chamfer with distance 0.2
    ...          (v2, 0.2),
    ...          # assymetric chamfer
    ...          (v3, v3.on_edges[0], 0.2, 0.3),
    ...          # chamfer with angle
    ...          (v4, v3.on_edges[0], 0.3, math.radians(45), "angle"))
    >>> obj = ChamferedWire(built_from=face, distance=0.1, vertex_table=table)

    See `Open CASCADE Documentation <http://opencascade.sourcearchive.com/
    documentation/6.3.0.dfsg.1/classBRepFilletAPI__MakeFillet2d.html>`_.
    """

    __icon__ = os.path.join(ICN_DIR, 'chamferedface.png')

    def build(self):
        """Build the ChamferedWire shape from the vertices.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeFillet2d
        :raises Exception: If error occurred during construction.
        :raises RuntimeError: If given vertices are floating, free or lie on
            more than two edges. Alternatively if there is an error in the
            :attr:`vertex_table`.
        """
        topods_face = TopoDS__Face(self.built_from.TopoDS_Shape)
        table = self.vertex_table

        def get_ancestor_edges(vertex, topods_vertex):
            edges = tuple(ancestor_edges(topods_vertex, topods_face,
                                         downcast=True))
            number_of_edges = len(edges)
            if number_of_edges == 2:
                return edges
            elif number_of_edges == 0:
                msg = ("Vertex {:} is floating, i.e. does not lie on "
                       "any edge.")
            elif number_of_edges == 1:
                msg = "Vertex {:} is free, i.e. lies on one edge only."
            else:
                msg = ("Vertex {:} is on more than 2 edges. "
                       "Multi-connexity is not supported.")
            msg = msg.format(vertex)
            raise RuntimeError(msg)

        # hack to evaluate distance only once and when required.
        cache = []
        builder = BRepFilletAPI_MakeFillet2d(topods_face)

        for entry in table:
            if hasattr(entry, "__iter__"):
                N = len(entry)
                if N == 1:
                    vertex = entry[0]
                    V = vertex.TopoDS_Vertex
                    D12 = (cache or
                           not cache.append(self.distance)) and cache[0]
                    E1, E2 = get_ancestor_edges(vertex, V)
                    args = E1, E2, D12, D12
                elif N == 2:
                    vertex, D12 = entry
                    V = vertex.TopoDS_Vertex
                    E1, E2 = get_ancestor_edges(vertex, V)
                    args = E1, E2, D12, D12
                elif N == 4:
                    vertex, edge, D1, D2 = entry
                    V = vertex.TopoDS_Vertex
                    E1 = edge.TopoDS_Edge
                    edges = set(get_ancestor_edges(vertex, V))
                    try:
                        edges.remove(E1)
                    except KeyError:
                        fmt = ("Provided edge '{:}' is no ancestor of vertex "
                               "'{:}'.")
                        msg = fmt.format(edge, vertex)
                        raise RuntimeError(msg)
                    E2 = edges.pop()
                    args = E1, E2, D1, D2
                elif N == 5:
                    vertex, edge, D, Ang, token = entry
                    if not token == "angle":
                        fmt = ("fifth element of chamfer spec should be "
                               "'angle', not '{:}'." )
                        msg = fmt.format(token)
                        raise ValueError(msg)
                    E = edge.TopoDS_Edge
                    V = vertex.TopoDS_Vertex
                    args = E, V, D, Ang
                else:
                    fmt = "Table entry '{:}' is not a valid spec."
                    msg = fmt.format(entry)
                    raise ValueError(msg)
            else:
                vertex = entry
                V = vertex.TopoDS_Vertex
                D12 = (cache or not cache.append(self.distance)) and cache[0]
                E1, E2 = get_ancestor_edges(vertex, V)
                args = E1, E2, D12, D12

            builder.AddChamfer(*args)

        builder.Build()

        if builder.IsDone():
            return builder
        else:
            status = ChFi2d_ConstructionError[builder.Status()]
            fmt = ("BRepFilletAPI_MakeFillet2d.Build() failed.\n"
                   "OCC Construction Error: {:}.")
            msg = fmt.format(status)
            raise Exception(msg)


class ChamferedShell(Chamfered3d, Shell_):
    """Chamfer one or multiple edges of a :attr:`built_from` shell. By default,
    chamfer is applied to all edges symmetrically with specified
    :attr:`distance` value. To chamfer only certain edges or vary distance /
    angle, provide an :attr:`edge_table` value of the form
    ``(<Spec> ... <Spec>)```, where ``<Spec>`` is either of the form
    ``Edge``, ``(Edge, Dis)``, ``(Edge, Face, Dis1, Dis2)`` or
    ``(Edge, Face, Dis, Angle, "angle")``. Thus, a valid edge_table would be
    ``(E1, (E2, 0.1), (E3, F1, 0.1, 0.2), (E4, F2, 0.1 0.5*pi, "angle")``. To
    get the face generated from an edge or vertex, use
    ``self.generated(edge_or_vertex) -> (Face,)``.For uniform, symmetric
    chamfer on all vertices, provide the :attr:`distance` value:

    >>> from parapy.geom import ChamferedShell, Box
    >>> solid = Box(3, 2, 1)
    >>> shell = solid.outer_shell
    >>> obj = ChamferedShell(shell, distance=0.1)

    For custom chamfer on the 4 edges of the top face:

    >>> from math import pi
    >>> f = solid.top_face
    >>> e1, e2, e3, e4 = f.edges
    >>> edge_table = (
    ...     # symmetrical offset obj.distance
    ...     e1,
    ...     # symmetrical offset 0.2
    ...     (e2, 0.2),
    ...     # 0.2 offset on F, 0.3 on other
    ...     (e3, f, 0.2, 0.3),
    ...     # 0.2 offset on F, angle 45 degrees
    ...     (e4, f, 0.2, 0.25 * pi, "angle"))
    >>> obj = ChamferedShell(shell, distance=0.1, edge_table=edge_table)
    """

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :raises RuntimeError: if the output was different from being a single
            shell shape.
        :raises ValueError: if Input :attr:`on_invalid` was not one of 'raise',
            'warn', 'ignore'.
        """
        st = topods_shape.ShapeType()
        if st == 0:
            topods_shape = unpack_single_shape_compound(topods_shape)
            st = topods_shape.ShapeType()
        if st == 3:
            return topods_shape
        else:
            on_invalid = self.on_invalid
            if on_invalid == 'ignore':
                return topods_shape
            else:
                msg = ("Chamfering did not create a single shell, but a "
                       "{}. To inspect the faulty shape, put on_valid = "
                       "'warn' or 'ignore'.")
                shape_type = TOPABS_NAMES[st]
                if on_invalid == 'raise':
                    raise RuntimeError(msg.format(shape_type))
                elif on_invalid == 'warn':
                    warnings.warn(msg.format(shape_type))
                else:
                    msg = ("on_invalid value {} not 'raise', 'ignore' or "
                           "'warn'.")
                    raise ValueError(msg.format(on_invalid))


class ChamferedSolid(Chamfered3d, Solid_):
    """Chamfer one or multiple edges of a :attr:`built_from` solid. By
    default, chamfer is applied to all edges symmetrically with specified
    :attr:`distance` value. To chamfer only certain edges or vary distance /
    angle, provide a :attr:`edge_table` value of the form ``(<Spec> ...
    <Spec>)``. ``<Spec>`` is either of the form ``Edge``, ``(Edge, Dis)``,
    ``(Edge, Face, Dis1, Dis2)`` or ``(Edge, Face, Dis, Angle, "angle")``.
    Thus, a valid edge_table would be ``(E1, (E2, 0.1), (E3, F1, 0.1, 0.2),
    (E4, F2, 0.1 0.5*pi, "angle")``. To get the face generated from an edge
    or vertex, use ``shape.generated(edge_or_vertex) -> (Face,)``. For
    uniform, symmetric chamfer on all vertices, provide the :attr:`distance`
    value:

    >>> from parapy.geom import ChamferedSolid, Box
    >>> solid = Box(3, 2, 1)
    >>> obj = ChamferedSolid(solid, distance=0.1)

    For custom chamfer on the 4 edges of the top face:

    >>> from math import pi
    >>> f = solid.top_face
    >>> e1, e2, e3, e4 = f.edges
    >>> edge_table = (
    ...     # symmetrical offset obj.distance
    ...     e1,
    ...     # symmetrical offset 0.2
    ...     (e2, 0.2),
    ...     # 0.2 offset on F, 0.3 on other
    ...     (e3, f, 0.2, 0.3),
    ...     # 0.2 offset on F, angle 45 degrees
    ...     (e4, f, 0.2, 0.25 * pi, "angle"))
    >>> obj = ChamferedSolid(solid, distance=0.1, edge_table=edge_table)
    """

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :raises RuntimeError: if the output was different from being a single
            shell shape.
        :raises ValueError: if Input :attr:`on_invalid` was not one of 'raise',
            'warn', 'ignore'.
        """
        st = topods_shape.ShapeType()
        if st == 0:
            topods_shape = unpack_single_shape_compound(topods_shape)
            st = topods_shape.ShapeType()
        if st == 2:
            return topods_shape
        else:
            on_invalid = self.on_invalid
            if on_invalid == 'ignore':
                return topods_shape
            else:
                msg = ("chamfering did not create a single solid, but a "
                       "{}. If your input shape isn't solid, consider "
                       "a different filleting operation. To inspect the "
                       "faulty shape, put on_valid = 'warn' or 'ignore'")
                shape_type = TOPABS_NAMES[st]
                if on_invalid == 'raise':
                    raise RuntimeError(msg.format(shape_type))
                elif on_invalid == 'warn':
                    warnings.warn(msg.format(shape_type))
                else:
                    msg = ("on_invalid value {} not 'raise', 'ignore' or "
                           "'warn'.")
                    raise ValueError(msg.format(on_invalid))


class FilletedWire(Filleted2d, Wire_):
    """Use to fillet vertices of a **PLANAR** wire. For uniform fillet
    radii on all vertices, provide the :attr:`radius` value:

    >>> from parapy.geom import Rectangle, FilletedWire
    >>> wire = Rectangle(width=2, length=1)
    >>> obj = FilletedWire(built_from=wire, radius=0.1)

    For control on vertex level, use the :attr:`vertex_table` input. Their are
    two ways to apply fillet to vertices:

    >>> v1, v2, v3, v4 = wire.vertices
    >>> table = (v1, v2, (v3, 0.2), (v4, 0.2))
    >>> obj = FilletedWire(wire, radius=0.1, vertex_table=table)

    .. note:: When applying a FilletedWire operation to open wires, only
        Vertices which are not free can be filleted. Make sure to not specify
        free Vertices in the vertex_table.

    See `Open CASCADE <http://opencascade.sourcearchive.com/documentation/
    6.3.0.dfsg.1/classBRepFilletAPI__MakeFillet2d.html>`_.
    """

    __icon__ = os.path.join(ICN_DIR, 'filletedwire.png')

    @Input
    def vertex_table(self):
        wire = self.built_from
        if wire.is_closed:
            return wire.vertices
        else:  # remove the free edges, because we cannot fillet them
            return tuple(filter(lambda obj: not obj.is_free, wire.vertices))

    def build(self):
        """Build the FilletedWire shape from the vertices.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeFillet2d
        :raises Exception: If error occurred during construction.
        """
        built_from = self.built_from
        topods_wire = built_from.TopoDS_Wire
        face_builder = BRepBuilderAPI_MakeFace(topods_wire, True)
        topods_face = face_builder.Face()
        table = self.vertex_table

        # hack to evaluate radius only once and when required.
        cache = []
        builder = BRepFilletAPI_MakeFillet2d(topods_face)
        built_from_partner = partial(built_from.partner, shape_type='vertex')

        for entry in table:
            if hasattr(entry, "__iter__"):
                vertex, R = entry
            else:
                vertex = entry
                R = (cache or not cache.append(self.radius)) and cache[0]

            # we need the local vertex in 'built_from', otherwise we might
            # wrongly conclude that local_vertex is free
            built_from_vertex = built_from_partner(vertex)
            if built_from_vertex.is_free:
                msg = ("Cannot apply a fillet to a free Vertex! Please make "
                       "sure the vertex_table does not contain free Vertices. "
                       "Object: {}")
                raise FreeVertexFilletedError(msg.format(self))

            V = vertex.TopoDS_Vertex
            builder.AddFillet(V, R)

        builder.Build()

        if builder.IsDone():
            return builder
        else:
            status = ChFi2d_ConstructionError[builder.Status()]
            fmt = ("BRepFilletAPI_MakeFillet2d.Build() failed.\n"
                   "OCC Construction Error: {:}.")
            msg = fmt.format(status)
            raise Exception(msg)

    @Attribute
    def TopoDS_Shape(self):
        """The shape built by :meth:`build`.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = self.builder.Shape()
        topods_face = TopoDS__Face(topods_shape)
        return BRepTools__OuterWire(topods_face)


class FilletedFace(Filleted2d, Face_):
    """Use to fillet vertices of a **PLANAR** face. For uniform fillet
    radii on all vertices, provide the :attr:`radius` value:

    >>> from parapy.geom import RectangularFace, FilletedFace
    >>> face = RectangularFace(width=2, length=1)
    >>> obj = FilletedFace(built_from=face, radius=0.1)

    For control on vertex level, use the :attr:`vertex_table` input. Their are
    two ways to apply fillet to vertices:

    >>> v1, v2, v3, v4 = face.vertices
    >>> table = (v1, v2, (v3, 0.2), (v4, 0.2))
    >>> obj = FilletedFace(face, radius=0.1, vertex_table=table)

    See `Open CASCADE
    Documentation <http://opencascade.sourcearchive.com/documentation/6.3.0
    .dfsg.1/classBRepFilletAPI__MakeFillet2d.html>`_.
    """

    __icon__ = os.path.join(ICN_DIR, 'filletedface.png')

    def build(self):
        """Build the FilletedFace shape from the vertices.

        :rtype: OCC.BRepFilletAPI.BRepFilletAPI_MakeFillet2d
        :raises Exception: If error occurred during construction.
        """
        topods_face = TopoDS__Face(self.built_from.TopoDS_Shape)
        table = self.vertex_table

        # hack to evaluate radius only once and when required.
        cache = []
        builder = BRepFilletAPI_MakeFillet2d(topods_face)

        for entry in table:
            if hasattr(entry, "__iter__"):
                vertex, R = entry
            else:
                vertex = entry
                R = (cache or not cache.append(self.radius)) and cache[0]
            V = vertex.TopoDS_Vertex
            builder.AddFillet(V, R)

        builder.Build()

        if builder.IsDone():
            return builder
        else:
            status = ChFi2d_ConstructionError[builder.Status()]
            fmt = ("BRepFilletAPI_MakeFillet2d.Build() failed.\n"
                   "OCC Construction Error: {:}.")
            msg = fmt.format(status)
            raise Exception(msg)


class FilletedShell(Filleted3d, Shell_):
    """Fillet one or multiple edges of a :attr:`built_from` shell. By default,
    filleting is applied to all edges with specified :attr:`radius` value. To
    fillet only certain edges or vary radius, provide a :attr:`edge_table`
    value of the form ``(<Spec> ... <Spec>)```. ``<Spec>`` is either an Edge or
    sequence (Edge, radius). Thus, a valid spec would be ``(E1, (E2, 0.1))``.
    To get the face generated from an edge or vertex, use
    ``shape.generated(edge_or_vertex) -> (Face,)``. For uniform fillet
    radii on all edges, provide the :attr:`radius` value:

    >>> from parapy.geom import Box, FilletedShell
    >>> solid = Box(3, 2, 1)
    >>> shell = solid.outer_shell
    >>> obj = FilletedShell(shell, radius=0.1)

    For non-uniform filletting of the top edges:

    >>> e1, e2, e3, e4 = solid.top_face.edges
    >>> table = (e1, e2, (e3, 0.2), (e4, 0.2))
    >>> obj = FilletedShell(shell, radius=0.1, edge_table=table)

    .. caution:: the algorithm has two limitations:

        - the end point of the contour is the point of intersection of 4 or
            more edges of the shape, or
        - the intersection of the fillet with a face which limits the contour
            is not fully contained in this face.
    """

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :raises RuntimeError: if the output was different from being a single
            shell shape.
        :raises ValueError: if Input :attr:`on_invalid` was not one of 'raise',
            'warn', 'ignore'.
        """
        if topods_shape.ShapeType() == 0:
            topods_shape = unpack_single_shape_compound(topods_shape)
        if topods_shape.ShapeType() == 3:
            return topods_shape
        else:
            on_invalid = self.on_invalid
            if on_invalid == 'ignore':
                return topods_shape
            else:
                msg = ("Filleting did not create a single shell, but a "
                       "{}. If your input shape isn't a shell, consider "
                       "a different filleting operation. To inspect the "
                       "faulty shape, put on_valid = 'warn' or 'ignore'")
                shape_type = TOPABS_NAMES[topods_shape.ShapeType()]
                if on_invalid == 'raise':
                    raise RuntimeError(msg.format(shape_type))
                elif on_invalid == 'warn':
                    warnings.warn(msg.format(shape_type))
                else:
                    msg = ("on_invalid value {} not 'raise', 'ignore' or "
                           "'warn'.")
                    raise ValueError(msg.format(on_invalid))


class FilletedSolid(Filleted3d, Solid_):
    """Fillet one or multiple edges of a :attr:`built_from` solid. By default,
    filleting is applied to all edges with specified :attr:`radius` value. To
    fillet only certain edges or vary radius, provide a :attr:`edge_table`
    value of the form ``(<Spec> ... <Spec>)```. ``<Spec>`` is either an Edge or
    sequence of (Edge, radius). Thus, a valid spec would be
    ``(E1, (E2, 0.1))``. To get the face generated from an edge or vertex,
    use ``shape.generated(edge_or_vertex) -> (Face,)``. For uniform fillet
    radii on all edges, provide the :attr:`radius` value:

    >>> from parapy.geom import Box, FilletedSolid
    >>> solid = Box(3, 2, 1)
    >>> obj = FilletedSolid(solid, radius=0.1)

    For non-uniform filletting of the top edges:

    >>> e1, e2, e3, e4 = solid.top_face.edges
    >>> table = (e1, e2, (e3, 0.2), (e4, 0.2))
    >>> obj = FilletedSolid(solid, radius=0.1, edge_table=table)

    .. caution:: the algorithm has two limitations:

    - the end point of the contour is the point of intersection of 4 or
        more edges of the shape, or
    - the intersection of the fillet with a face which limits the contour
        is not fully contained in this face.
    """

    def _validate_topods_shape(self, topods_shape):
        """Validates if ``topods_shape`` is a valid output for this operation.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :raises RuntimeError: if the output was different from being a single
            solid shape.
        :raises ValueError: if Input :attr:`on_invalid` was not one of 'raise',
            'warn', 'ignore'.
        """
        if topods_shape.ShapeType() == 0:
            topods_shape = unpack_single_shape_compound(topods_shape)
        if topods_shape.ShapeType() == 2:
            return topods_shape
        else:
            on_invalid = self.on_invalid
            if on_invalid == 'ignore':
                return topods_shape
            else:
                msg = ("Filleting did not create a single solid, but a "
                       "{}. If your input shape isn't solid, consider "
                       "a different filleting operation. To inspect the "
                       "faulty shape, put on_valid = 'warn' or 'ignore'")
                shape_type = TOPABS_NAMES[topods_shape.ShapeType()]
                if on_invalid == 'raise':
                    raise RuntimeError(msg.format(shape_type))
                elif on_invalid == 'warn':
                    warnings.warn(msg.format(shape_type))
                else:
                    msg = ("on_invalid value {} not 'raise', 'ignore' or "
                           "'warn'.")
                    raise ValueError(msg.format(on_invalid))


if __name__ == '__main__':
    pass

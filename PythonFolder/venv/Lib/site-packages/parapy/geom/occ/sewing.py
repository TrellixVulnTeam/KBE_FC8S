#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import warnings

from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeSolid, BRepBuilderAPI_Sewing)
from OCC.wrapper.BRepClass3d import BRepClass3d_SolidClassifier
from OCC.wrapper.ShapeFix import ShapeFix_Shape, ShapeFix_ShapeTolerance
from OCC.wrapper.ShapeUpgrade import ShapeUpgrade_ShellSewing
from OCC.wrapper.TopAbs import TopAbs_COMPOUND, TopAbs_IN, TopAbs_SHELL, TopAbs_SOLID
from OCC.wrapper.TopoDS import TopoDS__Shell

from parapy.core import Attribute, Input, ensure_iterable
from parapy.core.utilities import _is_iterable
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.face import PlanarFace
from parapy.geom.occ.shell import Shell_, face_to_shell
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import Surface
from parapy.geom.occ.utilities import unpack_single_shape_compound
from parapy.geom.occ.wire import Wire


# TODO: make C++ utility
def is_solid_reversed(topods_shape, tolerance=1.0e-7):
    """Is the given solid ``topods_shape`` reversed or *inside-out*, viz. are
    all face normals pointing outwards?

    :param topods_shape: OCC.TopoDS.TopoDS_Shape
    :type tolerance: float
    :rtype: bool
    """
    classifier = BRepClass3d_SolidClassifier(topods_shape)
    classifier.PerformInfinitePoint(tolerance)
    return classifier.State() == TopAbs_IN


class SewBase(BRep):
    """Abstract mixin class for SewnShell and SewnSolid defining common
    slots and methods.
    """

    __icon__ = os.path.join(ICN_DIR, 'fuse.png')
    __initargs__ = ["built_from"]

    #: list of surfaces, faces and/or shells
    #: :type: list[Face|Shell]
    built_from = Input()

    #: tolerance for coincident points / edges.
    #: :type: float
    tolerance = Input(1.0e-6)

    #: cut free edges?
    #: :type: bool
    cut_free_edges = Input(False)

    #: Sometimes a two-step sewing operation (first manifold, then non-
    #: manifold) gives better results for complex shapes. See
    #: http://www.opencascade.org/occt/overview/compocc7/sewing/sewing9/.
    #: :type: bool
    two_steps = Input(False)

    #: Try to fix the stitched shell after sewing?
    #: :type: bool
    try_fix = Input(False)

    #: Default behavior is to fail when the result of sewing did not render a
    #: single solid unless set to False. This can be useful to visually
    #: inspect the faulty shape inside the GUI.
    #: :type: bool
    fail_on_invalid = Input(True)

    @Attribute(private=True)
    def builder(self):
        return self.build()

    def modified(self, shape):
        if self.two_steps:
            raise NotImplementedError("not implemented for two_step sewing.")
        else:
            S = shape.TopoDS_Shape
            topods_shape = self.builder.ModifiedSubShape(S)
            return [self._TopoDS2Shape(topods_shape)]

    def history(self, shape):
        """Main method to find the associated shape in the current topology
        that is linked to the shape provided to this method. Tries various
        methods in order:

        1. SubShapeHistory.modified
        2. SubShapeHistory.generated
        3. SubShapeHistory.partner
        4. SubShapeHistory.is_deleted

        :type shape: BRep
        :rtype list[BRep] | None
        :raises NotImplementedError: in case of :attr:`two_steps` True.
        """
        if self.two_steps:
            raise NotImplementedError("not implemented for two_step sewing.")
        else:
            return super(SewBase, self).history(shape)

    def dump(self):
        self.builder.Dump()

    def validate_built_from_not_empty(self):
        if _is_iterable(self.built_from) and not self.built_from:
            msg = ("Cannot sew an empty sequence. Pass a list of surfaces, "
                   "faces and/or shells. Object: {!r}")
            return False, msg.format(self)
        return True, ""


class SewnShell(SewBase, Shell_):
    """Create a sewn shell from a set of (sur)faces / shells. Usage:

    >>> from parapy.geom import SewnShell, RectangularFace
    >>> #Let's align two rectangular faces next to each other
    >>> face1 = RectangularFace(1, 1).translated('x', 0.5)
    >>> face2 = RectangularFace(1, 1).translated('x', -0.5)
    >>> obj = SewnShell([face1, face2])

    .. note:: the order of your input can matter. Try to give order such that
        sequential attempts to sew is possible. For example, if you try to sew
        6 faces of a box, do not start with top and bottom faces, because
        these can't be sewn. Instead, give top, than side faces and then
        bottom.
    """

    #: Set True if you work with non-manifold topologies, typically this is
    #: True for shells.
    #: :type: bool
    non_manifold = Input(True)

    # TODO (FT): This _only_1_surf solution should be changed, make build()
    # /todo give a consistent result: duck-type shell result as a Builder?.
    @Attribute
    def _only_1_surf(self):
        """Returns two booleans:

        (<is there one surface>, <is self.built_from a list>)

        :rtype: tuple[bool, bool]
        """
        s = self.built_from
        if isinstance(s, Surface):
            return True, False
        elif hasattr(type(s), "__iter__") and \
                        len(s) == 1 and isinstance(s[0], Surface):
            return True, True
        else:
            return False, False

    def build(self):
        """If there is only one surface, it returns a shell. Otherwise it will
        return the builder.

        :rtype: parapy.geom.occ.shell.Shell_ | OCC.BRepBuilderAPI.BRepBuilderAPI_Sewing
        """
        s = self.built_from
        only_surf, is_list = self._only_1_surf
        if only_surf:
            surf = s[0] if is_list else s
            return face_to_shell(surf)
            # return BRepBuilderAPI_MakeShell(surf.Handle_Geom_Surface)
        else:
            is_valid, msg = self.validate_built_from_not_empty()
            if not is_valid:
                raise ValueError(msg)

            two_steps = self.two_steps
            # from: http://www.opencascade.org/occt/overview/compocc7/sewing/sewing9/
            # first For complicated topology it is desirable to apply manifold sewing first,
            # and then apply non manifold sewing should be called with a minimum possible working
            # tolerance.
            non_manifold = False if two_steps else self.non_manifold
            builder = BRepBuilderAPI_Sewing(self.tolerance, True, True, self.cut_free_edges, non_manifold)
            for face in ensure_iterable(self.built_from):
                builder.Add(face.TopoDS_Shape)
            builder.Perform()

            if two_steps:
                non_manifold = self.non_manifold
                builder2 = BRepBuilderAPI_Sewing(self.tolerance, True, True, False, non_manifold)
                builder2.Add(builder.SewedShape())
                builder2.Perform()
                builder = builder2

            return builder

    def modified(self, shape):
        only_surf, _ = self._only_1_surf
        if only_surf:
            return self.faces[0]  # there is exactly one
        else:
            return super(SewnShell, self).modified(shape)

    def is_deleted(self, shape):
        return False

    @Attribute(private=True)
    def TopoDS_Shape(self):
        only_surf, _ = self._only_1_surf
        builder = self.builder
        if only_surf:
            shape = builder.TopoDS_Shape
        else:
            shape = builder.SewedShape()

        if self.try_fix:
            builder = ShapeUpgrade_ShellSewing()
            shape = builder.ApplySewing(shape, self.tolerance)

        if self.fail_on_invalid:
            if shape.ShapeType() != TopAbs_SHELL:
                raise Exception("couldn't make a shell from input geometry")

        return shape


class Shell(SewnShell):
    def __init__(self, *args, **kwargs):
        warnings.warn("Use of Shell is deprecated. Use SewnShell instead.")
        super(Shell, self).__init__(*args, **kwargs)


# TODO RvD: deprecated, but maintained for backwards compatibility. Remove eventually.
from parapy.geom.occ import shell
shell.Shell = Shell


class SewnSolid(SewBase, Solid_):
    """This operation stitches adjacent faces and/or shells :attr:`built_from`
    that are touching at their edges to create a single solid. If connecting
    edges are not *congruent* (perfectly overlapping) but form t-junctions,
    you may consider putting :attr:`cut_free_edges` to True. For complex
    topologies the stitching operation may fail. In this case, consider using
    :attr:`two_steps` and/or :attr:`try_fix` for better results. If the
    algorithm still fails to create a single solid, but you do want to inspect
    the faulty shape in the GUI, put :attr:`fail_on_invalid` to False.

    Usage:

    >>> from parapy.geom import SewnSolid, Box
    >>> box = Box(1, 1, 1)
    >>> faces = box.faces
    >>> obj = SewnSolid(faces)
    """

    #: sometimes solid is reversed (inside-out) after sewing
    #: if True, solid will be reversed automatically if this happened.
    #: :type: bool
    check_orientation = Input(True)

    # enables override
    def get_shapes_to_sew(self):
        return ensure_iterable(self.built_from)

    def build(self):
        # For complicated shapes it is desirable to apply manifold sewing first
        # and then apply non-manifold sewing with a minimum possible working
        # tolerance. See:
        # http://www.opencascade.org/occt/overview/compocc7/sewing/sewing9/
        is_valid, msg = self.validate_built_from_not_empty()
        if not is_valid:
            raise ValueError(msg)

        two_steps = self.two_steps
        tol = self.tolerance
        cut = self.cut_free_edges
        non_manifold = two_steps
        builder = BRepBuilderAPI_Sewing(tol, True, True, cut, non_manifold)
        for shape in self.get_shapes_to_sew():
            S = shape.TopoDS_Shape
            builder.Add(S)
        builder.Perform()

        if two_steps:
            tol = 1.0e-6  # minimal possible working tolerance
            non_manifold = False
            builder2 = BRepBuilderAPI_Sewing(tol, True, True, True, non_manifold)
            builder2.Add(builder.SewedShape())
            builder2.Perform()
            builder=builder2

        if self.fail_on_invalid:
            NbFreeEdges = builder.NbFreeEdges()
            if NbFreeEdges > 0:
                msg = ("BRepBuilderAPI_Sewing did not return a closed shell. "
                       "The resulting shape has {:} free edges. Adapt input "
                       "geometry or play with tolerance.")
                raise Exception(msg.format(NbFreeEdges))
        return builder

    @Attribute(private=True)
    def TopoDS_Shape(self):
        topods_shape = self.builder.SewedShape()

        if self.try_fix:
            #builder = ShapeUpgrade_ShellSewing()
            #shape = builder.ApplySewing(shape, self.tolerance)
            fixer = ShapeFix_Shape(topods_shape)
            fixer.Perform()
            topods_shape = fixer.Shape()
            fixer = ShapeFix_ShapeTolerance()
            tolerance = self.tolerance
            fixer.SetTolerance(topods_shape, tolerance)

        st = topods_shape.ShapeType()
        if st == TopAbs_COMPOUND:
            topods_shape = unpack_single_shape_compound(topods_shape)
            st = topods_shape.ShapeType()

        if st == TopAbs_SOLID:
            return topods_shape
        elif st == TopAbs_SHELL:
            # upgrade to solid
            builder = BRepBuilderAPI_MakeSolid(TopoDS__Shell(topods_shape))
            if not builder.IsDone():
                raise Exception("MakeSolid failed")
            topods_shape = builder.Solid()
        else:
            if self.fail_on_invalid:
                raise Exception("sewing result is not a single shell...")
            else:
                warnings.warn("sewing result is not a single shell...")
                return topods_shape

        if self.check_orientation and is_solid_reversed(topods_shape):
            topods_shape = topods_shape.Reversed()
        return topods_shape


class CloseSurface(SewnSolid):
    """Tries to close off an open face/shell with new planar faces built
    from its free edges to create a solid. If a list of faces/shells is
    provided, they will first be sewn into a Shell using the default
    settings. In this case the free edges of the sewn Shell are used.

    Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1,1,1)
    >>> faces = box.front_face, box.left_face, box.rear_face, box.right_face
    >>> len(faces)
    4
    >>> obj = CloseSurface(built_from=faces)
    >>> len(obj.faces)
    6

    .. note:: This algorithm does not generate new edges to create planar
        closing surfaces. So, for example, closing any 3 faces of a Box will
        fail because the free edges do not form a closed planar wire.
    """

    #: An open face/shell (or list of these) to be closed off with extra faces
    #: to form a watertight solid. If a list of faces/shells is provided, they
    #: will first be sewn into a Shell with default settings.
    #: :type: Face|Shell | list[Face|Shell]
    built_from = Input()

    @Attribute
    def open_shell(self):
        """The shell, possibly built from :attr:`built_from`, that will be
        closed.

        :rtype: parapy.geom.occ.shell.Shell_
        """
        s = self.built_from
        if not hasattr(s, "__iter__") and s.TOPOLEVEL == 3:
            return s
        else:
            return SewnShell(s)

    @Attribute
    def wires_to_close(self):
        """Wires built from the connecting free-edges.

        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        # strategy: find all free edges, turn them into wires. Close the wires with faces.
        # sew all faces into a closed shell.
        s = self.open_shell
        return Wire(s.free_edges, ordered=False).wires

    @Attribute
    def _closing_faces(self):
        """Before sewing.

        :rtype: list[parapy.geom.PlanarFace]
        """
        return [PlanarFace(wire) for wire in self.wires_to_close]

    @Attribute
    def closing_faces(self):
        """After sewing.

        :rtype: list[parapy.geom.occ.face.Face_ | parapy.geom.occ.shell.Shell_]
        """
        return [self.partner(f) for f in self._closing_faces]

    def get_shapes_to_sew(self):
        """Faces that will be sewn together in the result.

        :rtype: list[parapy.geom.occ.face.Face_ | parapy.geom.occ.shell.Shell_]
        """
        return [self.open_shell] + self._closing_faces


if __name__ == '__main__':
    from parapy.gui import display

    # SewnShell example
    from parapy.geom import SewnShell, Box
    faces = Box(1, 1, 1).faces[0:3]
    obj = SewnShell(faces)
    display(obj)

    # SewnSolid example
    from parapy.geom import SewnSolid, Box
    faces = Box(1, 1, 1).faces
    obj = SewnSolid(faces)
    display(obj)

    # CloseSurface example
    from parapy.geom import CloseSurface, Cylinder
    face = Cylinder(1, 2).lateral_face
    obj = CloseSurface(face)
    display(obj)

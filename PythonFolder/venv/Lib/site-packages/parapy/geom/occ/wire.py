#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Description of the code."""

import math
import os
import warnings

from OCC.wrapper.Approx import Approx_Curve3d
from OCC.wrapper.BRepAdaptor import BRepAdaptor_CompCurve, BRepAdaptor_HCompCurve
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_DisconnectedWire, BRepBuilderAPI_EmptyWire,
    BRepBuilderAPI_MakePolygon, BRepBuilderAPI_MakeWire,
    BRepBuilderAPI_NonManifoldWire, BRepBuilderAPI_WireDone)
from OCC.wrapper.BRepExtrema import (
    BRepExtrema_DistShapeShape, BRepExtrema_IsInFace,
    BRepExtrema_IsOnEdge)
from OCC.wrapper.BRepLib import BRepLib_FindSurface
from OCC.wrapper.Geom import Handle_Geom_Plane
from OCC.wrapper.GeomAbs import (
    GeomAbs_C0, GeomAbs_C1, GeomAbs_C2, GeomAbs_C3,
    GeomAbs_CN)
from OCC.wrapper.ShapeAlgo import ShapeAlgo_AlgoContainer
from OCC.wrapper.ShapeAnalysis import (
    ShapeAnalysis_FreeBounds_ConnectEdgesToWires, ShapeAnalysis_Wire)
from OCC.wrapper.ShapeFix import ShapeFix_Wire
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_REVERSED, TopAbs_WIRE
from OCC.wrapper.TopoDS import TopoDS_Wire
from OCC.wrapper.gp import gp_Pnt
from OCC.utils.top import downcast_shape
from OCC.utils.wire import (
    first_last_vertex, yield_ordered_edges, yield_ordered_vertices)

from parapy.core import Attribute, Base, Input, pairwise, val
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.part import PrivatePartNoParsing
from parapy.geom import Vector, translate
from parapy.geom.generic import OXY, Point
from parapy.geom.generic.positioning import AbstractPoint
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.curve import BSplineCurve_, Curve, TrimmedCurve
from parapy.geom.occ.utilities import (
    SubShapeGenerator_, TopTools_HSequenceOfShapeGenerator,
    TopTools_HSequenceOfShape_factory)

# ---- Globals for this module ----
_WireError = {BRepBuilderAPI_WireDone:
              "we're fine...",
              BRepBuilderAPI_EmptyWire:
              "BRepBuilderAPI_EmptyWire: no curves_in?",
              BRepBuilderAPI_DisconnectedWire:
              "BRepBuilderAPI_DisconnectedWire: curves_in don't form a "
              "closed loop. Consider using Wires?",
              BRepBuilderAPI_NonManifoldWire:
              "BRepBuilderAPI_NonManifoldWire: curves_in form a strange "
              "non-manifold topology. Consider using Wires?"}


# ---- Utilities for this module ----
def _curve_edge_generator(curves):
    """for curve return edge, for edge return edge, for wire, return edges

    :type curves: collections.Iterable[parapy.geom.Curve|parapy.geom.Edge|Wire]
    :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Edge]
    """
    for curve in curves:
        level = curve.TOPOLEVEL
        # a wire
        if level == 5:
            for edge in curve.edges:
                yield downcast_shape(edge.TopoDS_Shape, TopAbs_EDGE)
        # and edge or curve
        elif level == 6:
            yield downcast_shape(curve.TopoDS_Shape, TopAbs_EDGE)
        else:
            raise ValueError("Object {:} is not "
                             "Curve|Edge|Wire.".format(curve))


class MultiEdgedWire(Exception):
    def __init__(self, wire):
        msg = ("Wire consist of multiple edges. Work with individual edges or "
               "compose wire into a single curve using ``curve`` attribute or "
               "``compose()`` method. Instance: ``{:}``.")
        msg.format(wire)
        super(MultiEdgedWire, self).__init__(msg)


# ---- Classes ----
class Wire_(BRep, Curve):
    """TopoDS_Wire wrapper. Abstract class, not meant for direct 
    construction.
    """

    __icon__ = os.path.join(ICN_DIR, 'polyline.png')

    TOPODIM = 1
    TOPOLEVEL = 5  # 7: Vertex, 6: Edge, 5: Wire, 4: Face,
                   #  3: Shell, 2: Solid, 1: CompSolid, 0: Compound
    BUILDERKEY = "Wire"  # self.builder.Wire_()

    # =========================================================================
    # Representations
    # =========================================================================
    @Attribute(private=True)
    def TopoDS_Wire(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Wire
        """
        return downcast_shape(self.TopoDS_Shape, TopAbs_WIRE)

    # =========================================================================
    # Topological aspect
    # =========================================================================
    @Attribute
    def reversed(self):
        """
        :rtype: Wire
        """
        return Wire([edge.reversed for edge in reversed(self.edges)])

    @Attribute
    def _Adaptor3d_Curve(self):
        """Root class for 3D curves on which geometric algorithms work.

        :rtype: OCC.BRepAdaptor.BRepAdaptor_CompCurve
        """
        return BRepAdaptor_CompCurve(self.TopoDS_Wire)  # ,False

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """
        :raises: :class:`MultiEdgedWire` if the wire contains multiple edges
        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        # TODO: not v0 backwards compatible.
        edges = self.edges
        if len(edges) > 1:
            raise MultiEdgedWire(self)
        else:
            return edges[0].Handle_Geom_Curve

    @Attribute(private=True)
    def TopoDS_Edge(self):
        """
        :raises: :class:`MultiEdgedWire` if the wire contains multiple edges
        :rtype: OCC.TopoDS.TopoDS_Edge
        """
        edges = self.edges
        if len(edges) > 1:
            raise MultiEdgedWire(self)
        else:
            return edges[0].TopoDS_Edge

    # TODO: default GeomAbs_C2 continuity?
    def compose(self, tolerance=1e-7, continuity=2, max_segments=1000,
                max_degree=8):
        """If this wire consists of multiple edges, you
        this method to approximate a single
        BSplineCurve through these edges with certain tolerance and continuity.
        Continuity is C0, C1, C2, C3 or CN (4).

        :type tolerance: float
        :type continuity: int
        :type max_segments: int
        :type max_degree: int
        :rtype: parapy.geom.occ.curve.BSplineCurve_
        """
        adaptor = self._Adaptor3d_Curve
        if continuity == 0:
            order = GeomAbs_C0
        elif continuity == 1:
            order = GeomAbs_C1
        elif continuity == 2:
            order = GeomAbs_C2
        elif continuity == 3:
            order = GeomAbs_C3
        else:
            order = GeomAbs_CN
        h_adaptor = BRepAdaptor_HCompCurve(adaptor).handle
        approx = Approx_Curve3d(h_adaptor, tolerance, order,
                                max_segments, max_degree)
        if approx.IsDone() and approx.HasResult():
            handle_geom_curve = approx.Curve()
            return BSplineCurve_(Handle_Geom_Curve=handle_geom_curve)
        else:
            msg = "Conversion of wire to Handle_Geom_Curve failed."
            raise Exception(msg)

    @Attribute
    def curve(self):
        """Return one curve for this wire. If wire composes multiple edges,
        it will be composed into one curve with C2 continuity. This may
        require approximiation. See :meth:`compose` for more options.

        :rtype: parapy.geom.Curve
        """
        edges = self.edges
        if len(edges) > 1:
            # always a BSplineCurve_
            return self.compose()
        else:
            return edges[0].curve

    # ---- Topology ----
    @PrivatePartNoParsing  # don't trickle down
    def vertices(self):
        """
        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return list(self._sub_shape_generator("vertex"))

    @Attribute
    def ordered_vertices(self):
        """Yield vertices by walking over the connected edges of a wire. If
        last vertex equals first (closed wire), it's not part of the
        result. See :meth:`yield_ordered_vertices` for more options.

        >>> from parapy.geom import Box
        >>> wire = Rectangle(1, 1)
        >>> wire.ordered_vertices  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        [<Vertex_ root.vertices[0] ...>, <Vertex_ root.vertices[1] ...>,
         <Vertex_ root.vertices[2] ...>, <Vertex_ root.vertices[3] ...>]

        .. note:: for an explanation of the order,
            see :meth:`yield_ordered_vertices`.

        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        :raises RuntimeError: if invalid wire for ordering (see note)
        """
        vertices_ordered = list(self.yield_ordered_vertices(
            repeat_first_if_closed=False))
        vertices_all = self.vertices

        if set(vertices_all).difference(vertices_ordered):
            msg = ("Invalid wire for ordering of vertices. Wire probably "
                   "contains defects like loops, wrong orientation of edges "
                   "(two edges go in to shared vertex or go out from shared "
                   "vertex), branching of edges or the presence of edges with "
                   "INTERNAL or EXTERNAL orientation. Fix the wire or "
                   "consider using yield_ordered_vertices() to yield a subset "
                   "of vertices. Object: {!r}.")
            raise RuntimeError(msg.format(self))

        return vertices_ordered

    @Attribute
    def _first_last_vertex(self):
        """
        :rtype: (parapy.geom.occ.vertex.Vertex_ | None, parapy.geom.occ.vertex.Vertex_ | None)

        .. caution:: in the event wire has a special topology (e.g.
            non-manifold), individual vertices may be None.
        """
        v1, v2 = first_last_vertex(self.TopoDS_Wire)  # can be .NullShapes
        return tuple(self._safe_TopoDS2Vertices(v1, v2))

    @Attribute
    def first_vertex(self):
        """First Vertex on Wire.

        :rtype: parapy.geom.occ.vertex.Vertex_ | None

        .. caution:: in the event wire has a special topology (e.g.
            non-manifold), Vertex can be None.
        """
        return self._first_last_vertex[0]

    @Attribute
    def last_vertex(self):
        """Last Vertex on Wire.

        :rtype: parapy.geom.occ.vertex.Vertex_ | None

        .. caution:: in the event wire has a special topology (e.g.
            non-manifold), Vertex can be None.
        """
        return self._first_last_vertex[1]

    @Attribute
    def ordered_edges(self):
        """Yield edges by walking over the connected edges of a wire.

        >>> from parapy.geom import Box
        >>> wire = Rectangle(1, 1)
        >>> list(wire.ordered_edges)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        [<Edge_ root.edges[0] ...>, <Edge_ root.edges[1] ...>,
         <Edge_ root.edges[2] ...>, <Edge_ root.edges[3] ...>]

        .. note:: for an explanation of the order,
            see :meth:`yield_ordered_edges`.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        :raises RuntimeError: if invalid wire for ordering (see note)
        """
        edges_ordered = list(self.yield_ordered_edges())
        edges_all = self.edges

        if set(edges_all).difference(edges_ordered):
            msg = ("Invalid wire for ordering of edges. Wire probably "
                   "contains defects like loops, wrong orientation of edges "
                   "(two edges go in to shared vertex or go out from shared "
                   "vertex), branching of edges or the presence of edges with "
                   "INTERNAL or EXTERNAL orientation. Fix the wire or "
                   "consider using yield_ordered_edges() to yield a subset "
                   "of edges. Object: {!r}.")
            raise RuntimeError(msg.format(self))

        return edges_ordered

    @PrivatePartNoParsing  # don't trickle down
    def edges(self):
        """
        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        return list(self._sub_shape_generator("edge"))

    @Attribute
    def history(self):
        # TODO (TBD): implement. Author: FT.
        # http://www.opencascade.org/org/forum/thread_18526/?forum=3
        raise Exception("History for Wire_ creation is not working yet. "
                        "Unfortunately the BRepBuilderAPI_MakeWire does not "
                        "implement Modified(), Generated(), etc. We need to "
                        "find a work-around that looks at vertex pairs")

    def extrema(self, other, deflection=None):
        """List all extrema between this curve and ``other`` Point, Curve or
        Surface. An extrema minimizes or maximizes the distance between a
        point on this curve and a point (on the other Curve or Surface). An
        extrema is a dict of the form::

            [{"point": Point,
              "other_point": Point,
              "distance": float,
              "support": Vertex | Edge,
              "other_support": Vertex | Edge | Face,
              "u": float,            # only if "support" is Edge type
              "other_u": float,      # only if other is Curve
              "other_uv": float      # only if other is Surface
              },
             # next extremum ...
             ]

        Where:

        - "point": point on this curve
        - "other_point": point on ``other``
        - "support": object on which extremum was found
        - "other_support": other object on which extremum was found
        - "u": parameter on corresponding "support" edge.
        - "distance": distance between curve and ``other`` at this extremum
        - "other_u": parameter on ``other`` Curve (**optional**!)
        - "other_uv": parameters on ``other`` Surface (**optional**!)

        :type other: Point | Curve | Surface
        :param deflection: *Parameter theDeflection is used to specify a
            maximum deviation of extreme distances from the minimum one.*
        :type deflection: None | float
        :rtype: list[dict[str, parapy.geom.BRep | parapy.geom.Point | float]]
        :raises RuntimeError: if ``other`` is not of type Point, Curve or
            Surface.
        """
        ext = BRepExtrema_DistShapeShape()
        ext.LoadS1(self.TopoDS_Shape)
        ext.LoadS2(other.TopoDS_Shape)
        if deflection is not None:
            ext.SetDeflection(deflection)
        ext.Perform()
        if not ext.IsDone():
            warnings.warn("extreme() failed, return [].")
        result = []
        for i in range(1, ext.NbSolution()+1):
            pt1 = Point(*ext.PointOnShape1(i).Coord())
            pt2 = Point(*ext.PointOnShape2(i).Coord())
            dist = Point.distance(pt1, pt2)
            topods1 = ext.SupportOnShape1(i)
            topods2 = ext.SupportOnShape2(i)
            t1 = ext.SupportTypeShape1(i)
            t2 = ext.SupportTypeShape2(i)
            s1 = self._TopoDS2Shape(topods1)
            if hasattr(other, "_TopoDS2Shape"):
                s2 = other._TopoDS2Shape(topods2)
            else:
                s2 = other
            dct = {"point": pt1, "other_point": pt2, "distance": dist,
                   "support": s1, "other_support": s2}
            if t1 is BRepExtrema_IsOnEdge:
                u = ext.ParOnEdgeS1(i)
                dct["u"] = u
            # elif t1 is BRepExtrema_IsInFace:
            #     other_uv = ext.ParOnFaceS2(i)
            #     dct["other_uv"] = other_uv
            if t2 is BRepExtrema_IsOnEdge:
                other_u = ext.ParOnEdgeS2(i)
                dct["other_u"] = other_u
            elif t2 is BRepExtrema_IsInFace:
                other_uv = ext.ParOnFaceS2(i)
                dct["other_uv"] = other_uv
            result.append(dct)
        return result

    def intersections(self, other, tolerance=1.0e-7):
        """Like :meth:`Curve.intersections`, but adds 'support': Edge
        key-value pair to resulting dicts.

        :rtype: list[dict[str, parapy.geom.BRep |  parapy.geom.Point | float]]
        """
        result = []
        for edge in self.edges:
            lst = edge.intersections(other, tolerance)
            for item in lst:
                item["support"] = edge
            result.extend(lst)
        return result

    @Attribute
    def _ShapeAnalysis_Wire(self):
        """
        :rtype: OCC.ShapeAnalysis.ShapeAnalysis_Wire
        """
        analysis = ShapeAnalysis_Wire()
        analysis.Load(self.TopoDS_Wire)
        analysis.Perform()
        return analysis

    def _check_closed(self, precision=0.0):
        """
        :type precision: float
        :rtype: bool
        """
        warnings.warn('Wire_._check_closed() is deprecated, use is_connected, '
                      'is_degenerated and is_lacking instead',
                      ParaPyDeprecationWarning)
        return not self._ShapeAnalysis_Wire.CheckClosed(precision)

    @Attribute
    def is_lacking(self):
        """True if at least one edge in the wire is lacking.

        See for explanation:
        https://www.opencascade.com/doc/occt-7.0.0/refman/html/class_shape_analysis___wire.html#ae08df46af333785afafb50c5ede6617e

        :rtype: bool
        """
        # Calls to CheckLacking for each edge Returns: True if at least one
        # lacking edge was detected.
        return self._ShapeAnalysis_Wire.CheckLacking()

    @Attribute
    def is_degenerated(self):
        """True if there is an edge in this wire which was incorrectly
        degenerated.

        :rtype: bool
        """
        # Returns True if at least one incorrect degenerated edge was
        # detected.
        return self._ShapeAnalysis_Wire.CheckDegenerated()

    @Attribute
    def is_ordered(self):
        """True if edges in the wire go in a sequential order (the end of a
        preceding edge is the start of a following one).

        :rtype: bool
        """
        return not self._ShapeAnalysis_Wire.CheckOrder()

    @Attribute
    def is_connected(self):
        """True if edges are connected at their vertices.

        :rtype: bool
        """
        return not self._ShapeAnalysis_Wire.CheckConnected()

    @Attribute
    def reordered(self):
        """(new) Wire in which edges are *ordered*, viz. edges in
        the wire go in a sequential order (the end of a preceding edge is the
        start of a following one).

        :rtype: Wire_
        """
        if not self.is_ordered:
            fix = ShapeFix_Wire()
            fix.Load(self.TopoDS_Wire)
            fix.FixReorder()
            topods_wire = fix.Wire()
            return Wire_(TopoDS_Shape=topods_wire)
        else:
            return self

    def plane_normal_with_tolerance(self, tolerance=0.0):
        """If this wire is planar within ``tolerance``, it will provide the
        normal of the plane in which this Wire lies.

        :param float tolerance: :py:`tolerance == 0.0` means default precision.
        :rtype: parapy.geom.Vector
        """
        # here -1 signals default precision
        tolerance = -1 if tolerance == 0.0 else tolerance

        plane_finder = BRepLib_FindSurface(self.TopoDS_Shape, tolerance, True)
        if plane_finder.Found():  # now only is true if there IS a plane
            geom_surface = plane_finder.Surface()
            geom_plane = Handle_Geom_Plane(geom_surface)
            if geom_plane.IsNull():
                msg = ("Cannot calculate the plane_normal of this plane. "
                       "Could not find a plane that could be used as a "
                       "reference. Use is_planar_with_tolerance() "
                       "to test whether this wire is planar within given "
                       "tolerance. Object: {}.")
                raise RuntimeError(msg.format(self))

            pos = geom_plane.Position()
            return Vector(*pos.Direction().Coord())
        else:
            msg = ("Edges of this wire aren't co-planar within the specified "
                   "tolerance. Either increase the tolerance or use "
                   "is_planar_with_tolerance() to test whether this wire is "
                   "planar within given tolerance. Object: {}.")
            raise RuntimeError(msg.format(self))

    @Attribute
    def plane_normal(self):
        return self.plane_normal_with_tolerance()

    @property
    def is_straight(self):
        raise NotImplementedError('Operation currently not supported for '
                                  'wires. Consult individual edges.')

    def is_planar_with_tolerance(self, tolerance=0.0):
        """Is this curve planar (within `tolerance`)?

        :param float tolerance: :py:`tolerance == 0.0` means default precision.
        :rtype: bool
        """
        # here -1 signals default precision
        tolerance = -1 if tolerance == 0.0 else tolerance

        plane_finder = BRepLib_FindSurface(
            self.TopoDS_Shape, tolerance, True)
        return plane_finder.Found()

    def yield_ordered_vertices(self, repeat_first_if_closed=True):
        """Yield vertices in ordered fashion, see the note for information
        about the order. If last vertex equals first
        (closed wire), first vertex is yielded again unless
        :py:`repeat_last_if_closed=False`.

        >>> from parapy.geom import Box
        >>> wire = Rectangle(1, 1)
        >>> list(wire.yield_ordered_vertices())  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        [<Vertex_ root.vertices[0] ...>, <Vertex_ root.vertices[1] ...>,
         <Vertex_ root.vertices[2] ...>, <Vertex_ root.vertices[3] ...>,
         <Vertex_ root.vertices[0] ...>]
        >>> list(wire.yield_ordered_vertices(repeat_first_if_closed=False))  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        [<Vertex_ root.vertices[0] ...>, <Vertex_ root.vertices[1] ...>,
         <Vertex_ root.vertices[2] ...>, <Vertex_ root.vertices[3] ...>]

        .. note:: to yield ordered vertices, the wire is explored by walking
            over the edges as explained in the note of
            :meth:`yield_ordered_vertices`.

        .. caution:: If the Wire contains any defect, like loops, wrong
            orientation of edges (two edges go in to shared vertex or go
            out from shared vertex), branching of edges or the presence
            of edges with INTERNAL or EXTERNAL orientation, the set of
            vertices that are yielded might vary across calls.

        :param bool repeat_first_if_closed: skip last vertex if wire is closed?
        :rtype: collections.Iterator[parapy.geom.occ.vertex.Vertex_]
        """
        localizer = self._TopoDS2Vertices.__getitem__
        it = yield_ordered_vertices(self.TopoDS_Wire)

        try:
            current_vertex = next(it)
            first_vertex = current_vertex = localizer(current_vertex)
        except StopIteration:
            return  # special case: no edges

        # note: this loop will exit BEFORE the last item
        for next_vertex in it:
            yield current_vertex
            # the localizer should be used BEFORE yielding a next element
            # from `it` due to the OCC-utility 'overwriting' the result
            current_vertex = localizer(next_vertex)

        # here current_vertex is the last vertex of the iterator
        if repeat_first_if_closed or current_vertex is not first_vertex:
            yield current_vertex

    def yield_ordered_edges(self):
        """Yield edges in ordered fashion, see the note for information
        about the order.

        >>> from parapy.geom import Box
        >>> wire = Rectangle(1, 1)
        >>> list(wire.yield_ordered_edges())  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
        [<Edge_ root.edges[0] ...>, <Edge_ root.edges[1] ...>,
         <Edge_ root.edges[2] ...>, <Edge_ root.edges[3] ...>]

        .. note:: each wire edge is connected to the previous
            one by its origin.
            If a wire is not closed, the algorithm only steps over a segment of
            edges which length depends on started in exploration edge. The
            algorithm suggests that wire is valid and has no any defects,
            which can stop edge exploration. Such defects can be loops, wrong
            orientation of edges (two edges go in to shared vertex or go out
            from shared vertex), branching of edges, the presence of edges with
            INTERNAL or EXTERNAL orientation. If wire has such kind of defects
            WireExplorer can return not all edges in a wire. it depends on type
            of defect and position of starting edge.

        .. caution:: If the Wire contains any defect, like loops, wrong
            orientation of edges (two edges go in to shared vertex or go
            out from shared vertex), branching of edges or the presence
            of edges with INTERNAL or EXTERNAL orientation, the set of
            edges that are yielded might vary across calls.

        :rtype: collections.Iterator[parapy.geom.occ.edge.Edge_]
        """
        f = self._TopoDS2Edges.__getitem__
        return map(f, yield_ordered_edges(self.TopoDS_Wire))

# monkey_patch BRep class
BRep.WireClass = Wire_


def make_wires(curves_in, tolerance, ordered=True, fix=True):
    """Return a list of :class:`Wire_` objects made from ``curves_in``. When
    ``ordered`` is set to :py:`True` it tries to make one wire out of it.
    If ``ordered`` is :py:`False` it tries to put curves together in a wire.
    If this fails, it will generate a separate :class:`Wire_` in the output.

    :param collections.Iterable[parapy.geom.Curve] curves_in: CurveLike
        objects to convert into wires.
    :param numbers.Number tolerance: tolerance for point coincidence
    :return: list of Wire_ objects
    :rtype: list[Wire_]
    """
    # TODO: http://www.opencascade.org/org/forum/thread_19660/?forum=3
    gen = _curve_edge_generator(curves_in)

    if ordered:
        # lst =  TopTools_ListOfShape()
        builder = BRepBuilderAPI_MakeWire()
        # add the edges/wires
        for topods_edge in gen:
            #    lst.Append(crv)
            if topods_edge.Orientation() is TopAbs_REVERSED:
                topods_edge = downcast_shape(topods_edge.Reversed(),
                                             TopAbs_EDGE)
            builder.Add(topods_edge)
        status = builder.Error()
        if builder.IsDone():
            if status is not BRepBuilderAPI_WireDone:
                warnings.warn(_WireError[status])
            topods_wires = [builder.Wire()]
        else:
            raise Exception(_WireError[status])

    else:
        h_seq_in = TopTools_HSequenceOfShape_factory(gen).handle
        h_seq_out = TopTools_HSequenceOfShape_factory().handle
        ShapeAnalysis_FreeBounds_ConnectEdgesToWires(
            h_seq_in, tolerance, False, h_seq_out)
        topods_wires = TopTools_HSequenceOfShapeGenerator(h_seq_out)

    if fix:
        fixed_topods_wires = []
        for topods_wire in topods_wires:
            fixer = ShapeFix_Wire()
            handle = fixer.handle  # claim memory
            fixer.Load(downcast_shape(topods_wire, TopAbs_WIRE))
            fixer.Perform()
            fixed_topods_wires.append(fixer.WireAPIMake())
        return [Wire_(TopoDS_Shape=shape) for shape in fixed_topods_wires]
    else:
        return [Wire_(TopoDS_Shape=shape) for shape in topods_wires]


class Wire(Wire_):
    """Builds one wire or a sequence of ``wires`` out of sequence of un-sorted
    <curves_in>. Tries to build wires of maximum length. Building a wire is
    stopped when no curves can be connected to it at its head or at its tail.
    This object self is the first wire found. If more wires are found, access
    them through ``wires`` slot: a list of all wires found.
    Note: if you have multiple wires, they are not sorted by length.

    Usage:

    >>> from parapy.geom import Wire, LineSegment, Point
    >>> crv1 = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> crv2 = LineSegment(Point(1, 0, 0), Point(1, 1, 0))
    >>> obj = Wire([crv1, crv2])
    """

    __initargs__ = ["curves_in"]

    #: List of curves, edges, wires.
    #: :type: collections.Sequence[parapy.geom.Curve]
    curves_in = Input([])

    #: Tolerance for point coincidence.
    #: :type: float
    tolerance = Input(1.0e-8)

    #: Input is ordered, only specify one list of curves.
    #: :type: bool
    ordered = Input(True)

    #: Fix this wire? Caution: may re-order/re-orient edges of resulting wires.
    #: :type: bool
    fix = Input(False)

    @Attribute
    def wires(self):
        """
        :rtype: list[Wire_]
        """
        return make_wires(self.curves_in, self.tolerance, self.ordered,
                          self.fix)

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.wires[0].TopoDS_Shape

    def history(self, curve, raise_exception=True):
        """Returns new Edge object.

        :rtype: parapy.geom.occ.edge.Edge_
        """
        curve = next(_curve_edge_generator([curve]))
        for wire in self.wires:
            for edge in wire.edges:
                if curve.IsPartner(edge.TopoDS_Shape):
                    return edge
        if raise_exception:
            raise Exception("could not find linkage between "
                            "curve and any wire")
        else:
            return []

    # @Input # can be set by ClonedShape
    # def builder(self):
    #     """Returns BRepBuilderAPI_MakeWire"""
    #     if self._clone:
    #         return self._clone.builder
    #     else:
    #         curves_in = self.curves_in
    #         if curves_in:
    #             lst =  TopTools_ListOfShape()
    #             builder = BRepBuilderAPI_MakeWire()
    #             # add the edges/wires
    #             for crv in ensure_iterable(self.curves_in):
    #                 level = crv.TOPOLEVEL
    #                 if level == 6:
    #                     lst.Append(TopoDS__Edge(crv.TopoDS_Shape))
    #                 elif level == 5:
    #                     lst.Append(TopoDS__Wire(crv.TopoDS_Wire))
    #                 else:
    #                     raise Exception("Only curves, edges and wires "
    #                                     "are valid for curves_in."
    #                                     " Not: %s" % (repr(crv)))
    #             builder.Add(lst)
    #             status = builder.Error()
    #             if builder.IsDone():
    #                 if not status is BRepBuilderAPI_WireDone:
    #                     warnings.warn("{:} {:}".format(self,
    #                                                    _WireError[status]))
    #                 return builder
    #             else:
    #                 raise Exception("{:} {:}".format(self,
    #                                                  _WireError[status]))


# def _ConnectedCurves___TopoDS_Wires_validator(lst, obj, slot):
#     if len(lst) >= 1:
#         return True
#     else:
#         raise Exception("Wires couldn't find any wire, "
#                         "check your curves_in...")

# class Wires(Wire):
#     """Builds one wire or a sequence of <wires> out of sequence of not sorted
#     <curves_in>. Tries to build wires of maximum length. Building a wire is
#     stopped when no curves can be connected to it at its head or
#     at its tail. This object self is the first wire found. If more
#     wires are found, access them
#     through wires: a list of all wires found.
#     Note: if you have multiple wires, they are not sorted by length.
#     """
#
#     __initargs__ = ["curves_in"]
#
#     @Attribute(validator=_ConnectedCurves___TopoDS_Wires_validator)
#     def _TopoDS_Wires(self):
#         return make_wires(self.curves_in, self.tolerance)
#
#     @PrivatePartNoParsing
#     def wires(self):
#         return map(lambda shape: Wire_(TopoDS_Shape=shape),
#                    self._TopoDS_Wires)
#
#     @Attribute
#     def TopoDS_Shape(self):
#         return self._TopoDS_Wires[0]


class Polygon(Wire_):
    """A sequence of connected line segments between a list of :attr:`points`.
    A polygon is always closed by default (the closure is forced in case
    supplied first and last points do not match). The polygon can be kept open
    by setting :attr:`force_closure` to False.

    Usage:

    >>> from parapy.geom import Point, Polygon
    >>> points = [Point(0, 0, 0), Point(1, 0, 0), Point(1, 1, 0),
    ...           Point(0, 1, 0)]
    >>> obj = Polygon(points=points)
    """

    __initargs__ = ["points"]

    #: A list of points. Will be closed if first and last don't match.
    #: :type: collections.Sequence[parapy.geom.generic.positioning.Point]
    points = Input()

    #: Position defaults to OXY.
    #: :type: parapy.geom.generic.positioning.Position
    position = Input(OXY, defaulting=True)

    #: Force closure of polygon in case supplied first and last points don't
    #: match. Defaults to True.
    #: :type: bool
    force_closure = Input(True)

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakePolygon
        """
        points = self.points
        builder = BRepBuilderAPI_MakePolygon()
        for point in points:
            builder.Add(gp_Pnt(*point))
        if self.force_closure and not points[0] == points[-1]:
            builder.Add(gp_Pnt(*points[0]))
        if not builder.IsDone():
            raise Exception("building polygon failed")
        return builder


class NSidedPolygon(Polygon):
    """Make an N-sided Polygon.

    Usage:

    >>> from parapy.geom import NSidedPolygon
    >>> obj = NSidedPolygon(N=10, radius=1)
    """

    __initargs__ = ["N", "radius"]

    #: The number of sides.
    #: :type: int
    N = Input()

    #: The radius of the polygon (value > 0)
    #: :type: float
    radius = Input(validator=val.Positive())

    #: constant override of Polygon.force_closure
    #: :type: bool
    force_closure = True

    @Attribute
    def points(self):
        """
        :rtype: tuple[parapy.geom.Point]
        """
        angle = 2 * math.pi / self.N
        r = self.radius
        get_point = self.position.get_point
        return tuple(get_point(x=r * math.cos(angle * i),
                               y=r * math.sin(angle * i))
                     for i in range(self.N))

    @Attribute
    def is_closed(self):
        """
        :rtype: bool
        """
        return True


class NamedNSidedPolygon(NSidedPolygon):
    """Make a N-sided Polygon by name."""

    __initargs__ = ["radius"]

    # constant override of NSidedPolygon.N, implemented in subclasses.
    N = None


class Triangle(NamedNSidedPolygon):
    """Make a 3-sided Polygon.

    Usage:

    >>> from parapy.geom import Triangle
    >>> obj = Triangle(radius=1)
    """
    #: :type: int
    N = 3


class Quadrilateral(NamedNSidedPolygon):
    """Make a 4-sided Polygon.

    Usage:

    >>> from parapy.geom import Quadrilateral
    >>> obj = Quadrilateral(radius=1)
    """
    #: :type: int
    N = 4


class Pentagon(NamedNSidedPolygon):
    """Make a 5-sided Polygon.

    Usage:

    >>> from parapy.geom import Pentagon
    >>> obj = Pentagon(radius=1)
    """
    #: :type: int
    N = 5


class Hexagon(NamedNSidedPolygon):
    """Make a 6-sided Polygon.

    Usage:

    >>> from parapy.geom import Hexagon
    >>> obj = Hexagon(radius=1)
    """
    #: :type: int
    N = 6


class Heptagon(NamedNSidedPolygon):
    """Make a 7-sided Polygon.

    Usage:

    >>> from parapy.geom import Heptagon
    >>> obj = Heptagon(radius=1)
    """
    #: :type: int
    N = 7


class Octagon(NamedNSidedPolygon):
    """Make an 8-sided Polygon.

    Usage:

    >>> from parapy.geom import Octagon
    >>> obj = Octagon(radius=1)
    """
    #: :type: int
    N = 8


class Nonagon(NamedNSidedPolygon):
    """Make a 9-sided Polygon.

    Usage:

    >>> from parapy.geom import Nonagon
    >>> obj = Nonagon(radius=1)
    """
    #: :type: int
    N = 9


class Decagon(NamedNSidedPolygon):
    """Make a 10-sided Polygon.

    Usage:

    >>> from parapy.geom import Decagon
    >>> obj = Decagon(radius=1)
    """
    #: :type: int
    N = 10


# =============================================================================
# Synonyms
# =============================================================================
Tetragon = Quadrilateral
Septagon = Heptagon


# TODO (RvD): length shadows Wire.length attribute.
class Rectangle(Polygon):
    """Rectangular Wire consisting of 4 segments. position.Vx corresponds to
    width, position.Vy to length. Vz is the normal vector. Usage:

    >>> from parapy.geom import Rectangle
    >>> obj = Rectangle(width=1, length=1)

    By default, :attr:`position` corresponds to the center of the rectangle.
    If you prefer the bottom-left vertex as reference, use :attr:`centered`:

    >>> obj = Rectangle(width=1, length=1, centered=False)

    .. note:: if you want the total *length* of this wire, for now use
        ``super(Rectangle, obj).length``.
    """

    __initargs__ = ["width", "length"]

    #: :type: float
    width = Input()
    #: :type: float
    length = Input()
    #: If False, :attr:`position` input corresponds to lower-left vertex.
    #: :type: bool
    centered = Input(True)
    # uninherited
    force_closure = Attribute(False)

    @Attribute
    def points(self):
        """The corner points. The first corner is repeated at the end, to
        form a closed wire.

        :rtype: tuple[Point]
        """
        w, l = self.width, self.length
        p = self.position
        pt1, (vx, vy, _) = p.location, p.orientation
        if self.centered:
            pt1 = translate(pt1, vx, -0.5 * w, vy, -0.5 * l)
        pt2 = translate(pt1, vx, w)
        pt3 = translate(pt2, vy, l)
        pt4 = translate(pt1, vy, l)
        return pt1, pt2, pt3, pt4, pt1


# Experimental
class HomoWires(Base):
    """Homogenizes multiple wires. See wires for result.
    When the wires have different amount of edges, it tries to conform them to
    have the same amount of edges.

    .. Note:: Doesn't work yet for more than 2 wires_in.
    """

    __initargs__ = ["wires_in"]

    #: list of two wires
    #: :type: collections.Sequence[Wire]
    wires_in = Input()

    @Attribute
    def wires(self):
        """
        :rtype: list[Wire_]
        """
        wires = sorted(self.wires_in,
                       key=lambda wire: len(wire.edges),
                       reverse=True)
        #         max_edges=-1
        #         for wire in wires:
        #             if len(wire.edges) > max_edges:
        #                 max_edges = len(wire.edges)
        #                 max_wire = wire

        topods_wire1_in = wires.pop().TopoDS_Wire
        topods_wire2_in = wires.pop().TopoDS_Wire
        topods_wire1_out = TopoDS_Wire()
        topods_wire2_out = TopoDS_Wire()
        ShapeAlgo_AlgoContainer().HomoWires(topods_wire1_in,
                                            topods_wire2_in,
                                            topods_wire1_out,
                                            topods_wire2_out,
                                            True)
        wire1 = Wire_(TopoDS_Shape=topods_wire1_out)
        wire2 = Wire_(TopoDS_Shape=topods_wire2_out)

        L = len(wire1.edges)

        topods_wire1_in = topods_wire1_out
        new_wires = []
        for next_wire in wires:
            topods_wire2_in = next_wire.TopoDS_Wire
            topods_wire1_out = TopoDS_Wire()
            topods_wire2_out = TopoDS_Wire()
            ShapeAlgo_AlgoContainer().HomoWires(topods_wire1_in,
                                                topods_wire2_in,
                                                topods_wire1_out,
                                                topods_wire2_out,
                                                True)
            wire2 = Wire_(TopoDS_Shape=topods_wire2_out)
            L_ = len(list(SubShapeGenerator_(topods_wire1_out, 1)))
            if not L_ == L:
                raise Exception("Not expected. %i != %i" % (L_, L))
            new_wires.append(wire2)
        return [wire1, wire2] + new_wires


# TODO (TBD): Combine with SplitEdge.
# TODO (RvD): Support tools that split the curve_in... Author: RvD.
# /todo ...at multiple locations at once.
class SplitCurve(Wire):
    """Split a curve/edge :attr:`curve_in` with a :attr:`tool`
    into a Wire. The :attr:`tool` can
    be a single object, splitting :attr:`curve_in` in 2, or a
    sequence of objects of length ``N``,
    splitting :attr:`curve_in` in ``N + 1`` edges. A valid tool
    is (a sequence) of type:
    
    1. float: a u-parameter on :attr:`curve_in`
    2. Point: point on (or very close to) the :attr:`curve_in`
    3. Curve: split at intersection with another curve
    4. Surface: split at intersection with another surface

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> # split crv in 4 pieces at different u-parameters
    >>> obj = SplitCurve(curve_in=crv, tool=(0.25, 0.50, 0.75))
    >>> len(obj.edges)
    4

    .. note:: if u-parameter(s) used for splitting lies outside
        the range [u1-u2] of :attr:`curve_in`, a RuntimeError is raised.
    .. caution: make sure another curve or a surface limit does
        intersect only once with the :attr:`curve_in`, otherwise a
        RuntimeError is raised.
    """

    __initargs__ = ["curve_in", "tool"]

    #: base curve or edge
    #: :type: parapy.geom.occ.curve.Curve | parapy.geom.occ.edge.Edge
    curve_in = Input(validator=lambda crv: crv.TOPOLEVEL == 6)

    #: single u-parameter, point, or plane, or list of these.
    #: Only specify *internal*
    #: values, where you want a split. Don't include
    #: limits of the curve_in.
    #: :type: float|Point|Plane | collections.Sequence[float | Point | Plane]
    tool = Input()

    #: by default, this object will check that the
    #: u-parameters corresponding to a limit lie
    #: within the range [u1-u2] of :attr:`basis_curve`. If it doesn't,
    #: a RuntimeError is raised.
    #: :type: str
    on_extrapolation = Attribute('raise')

    @Attribute
    def curves_in(self):
        """
        :rtype: list[TrimmedCurve]
        """
        curve_in, tool, on_extrapolation = (self.curve_in, self.tool,
                                            self.on_extrapolation)
        if (not hasattr(type(tool), "__iter__") or isinstance(tool,
                                                              AbstractPoint)):
            tool = [tool]
        else:
            tool = list(tool)
        u1, u2 = curve_in.u1, curve_in.u2
        tool = [u1] + tool + [u2]

        return [TrimmedCurve(curve_in, l1, l2,
                             on_extrapolation=on_extrapolation)
                for l1, l2 in pairwise(tool)]

        # FIXME: use approach below instead.
        #
        # curve = edge.Handle_Geom_Curve_basis
        # builder = BRep_Builder()
        # topods_edge = TopoDS__Edge(edge.TopoDS_Shape)
        # vStart = TopExp_FirstVertex(topods_edge)
        # vEnd = TopExp_LastVertex(topods_edge)
        # vMiddle = TopoDS_Vertex()
        #
        # builder.MakeVertex(vMiddle, pt.gp_Pnt, Precision__Confusion())
        #
        # edge1 = BRepBuilderAPI_MakeEdge(curve, vStart, vMiddle)
        #                                 #TopoDS__Vertex(vMiddle.Reversed()))
        # edge2 = BRepBuilderAPI_MakeEdge(curve, vMiddle, vEnd)
        #                                 #TopoDS__Vertex(vEnd.Reversed()));
        #
        # edge1 = Edge_(TopoDS_Shape=edge1.Edge())
        # edge2 = Edge_(TopoDS_Shape=edge2.Edge())

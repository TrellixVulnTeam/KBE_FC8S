#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines Solid type and various derived types to create (primitive) solids"""

import functools
import os
import warnings

from OCC.wrapper.BRep import BRep_Tool_Tolerance
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeSolid, BRepBuilderAPI_RightCorner,
    BRepBuilderAPI_RoundCorner, BRepBuilderAPI_Transformed)
from OCC.wrapper.BRepClass3d import (
    BRepClass3d_SolidClassifier, BRepClass3d__OuterShell)
from OCC.wrapper.BRepFill import (
    BRepFill_Contact, BRepFill_ContactOnBorder,
    BRepFill_NoContact)
from OCC.wrapper.BRepOffsetAPI import (
    BRepOffsetAPI_MakePipe, BRepOffsetAPI_MakePipeShell,
    BRepOffsetAPI_MakeThickSolid)
from OCC.wrapper.BRepPrimAPI import BRepPrimAPI_MakePrism
from OCC.wrapper.GeomFill import (
    GeomFill_IsConstantNormal,
    GeomFill_IsCorrectedFrenet, GeomFill_IsDarboux,
    GeomFill_IsDiscreteTrihedron, GeomFill_IsFixed,
    GeomFill_IsFrenet, GeomFill_IsGuideAC,
    GeomFill_IsGuideACWithContact, GeomFill_IsGuidePlan,
    GeomFill_IsGuidePlanWithContact)
from OCC.wrapper.Precision import Precision__Confusion
from OCC.wrapper.ShapeAnalysis import ShapeAnalysis_Shell
from OCC.wrapper.ShapeFix import ShapeFix_ShapeTolerance
from OCC.wrapper.TopAbs import (
    TopAbs_EDGE, TopAbs_FACE, TopAbs_IN, TopAbs_ON,
    TopAbs_SOLID, TopAbs_VERTEX)
from OCC.wrapper.TopTools import TopTools_ListOfShape
from OCC.wrapper.gp import gp_Dir
from OCC.utils.top import downcast_shape

from parapy.core import Attribute, Input, derived, ensure_iterable, val
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.part import Part, PrivatePartNoParsing
from parapy.geom import Orientation
from parapy.geom.generic import Position
from parapy.geom.generic.positioning import orthogonal_vector
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.curve import Circle, ZeroCurvature
from parapy.geom.occ.face import Face
from parapy.geom.occ.utilities import SubShapeGenerator_

_SWEEP_MODES = {
    "corrected_frenet": GeomFill_IsCorrectedFrenet,
    "fixed": GeomFill_IsFixed,
    "frenet": GeomFill_IsFrenet,
    "constant_normal": GeomFill_IsConstantNormal,
    "darboux": GeomFill_IsDarboux,
    "guide_ac": GeomFill_IsGuideAC,
    "guide_ac_contact": GeomFill_IsGuideACWithContact,
    "guide_plan": GeomFill_IsGuidePlan,
    "guide_plan_contact": GeomFill_IsGuidePlanWithContact,
    "discrete": GeomFill_IsDiscreteTrihedron
}


class Solid_(BRep):
    """Abstract Solid class. Wraps a TopoDS_Solid instance."""

    # 7:Vertex,6:Edge,5:Wire,4:Face,3:Shell,2:Solid,1:CompSolid,0:Compound
    TOPOLEVEL = 2
    TOPODIM = 3
    BUILDERKEY = "Solid"  # self.builder.Solid_()

    # ---------------- dimensions -------------------
    @Attribute
    def area(self):
        """Total surface area, i.e. the sum of area of all faces.

        :rtype: float
        """
        return self._gprops2d.Mass()

    @Attribute
    def volume(self):
        """Volume enclosed by the faces.

        :rtype: float
        """
        return self._gprops3d.Mass()

    # ---------------- topology -------------------
    @Attribute(private=True)
    def TopoDS_Solid(self):
        """Underlying OCC BRep shape.

        :rtype: OCC.TopoDS.TopoDS_Solid
        """
        return downcast_shape(self.TopoDS_Shape, TopAbs_SOLID)

    @PrivatePartNoParsing  # don't trickle down
    def vertices(self):
        """This solid its vertices.

        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return list(self._sub_shape_generator("vertex"))

    @PrivatePartNoParsing  # don't trickle down
    def edges(self):
        """This solid its edges.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        return list(self._sub_shape_generator("edge"))

    @PrivatePartNoParsing  # don't trickle down
    def wires(self):
        """This solid its wires

        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        return list(self._sub_shape_generator("wire"))

    @PrivatePartNoParsing  # don't trickle down
    def faces(self):
        """his solid its faces.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return list(self._sub_shape_generator("face"))

    @PrivatePartNoParsing  # don't trickle down
    def shells(self):
        """This solid its shells.

        :rtype: list[parapy.geom.occ.shell.Shell_]
        """
        return list(self._sub_shape_generator("shell"))

    @PrivatePartNoParsing  # don't trickle down
    def solids(self):
        """This solid its solids (the solid itself)

        :rtype: list[parapy.geom.occ.solid.Solid_]
        """
        return list(self._sub_shape_generator("solid"))

    @Attribute  # don't trickle down
    def outer_shell(self):
        """The outer shell of this solid.

        :rtype: parapy.geom.occ.shell.Shell_
        """
        topods_shell = BRepClass3d__OuterShell(self.TopoDS_Solid)
        return self._TopoDS2Shells[topods_shell]

    # ---------------- Analysis -------------------
    @Attribute
    def _shell_analyser(self):
        """An OCC tool to perform shape analysis with on a shell.

        :rtype: OCC.ShapeAnalysis.ShapeAnalysis_Shell
        """
        sas = ShapeAnalysis_Shell()
        sas.CheckOrientedShells(self.TopoDS_Shape, True)
        return sas

    @Attribute
    def bad_edges(self):
        """flat list of bad edges in this solid.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        sas = self._shell_analyser
        if sas.HasBadEdges():
            topods_compound = sas.BadEdges()
            topods_edges = list(SubShapeGenerator_(topods_compound, "edge"))
            return self._TopoDS2Shapes(topods_edges, "edge", "ignore")
        else:
            return []

    @Attribute
    def free_edges(self):
        """flat list of free edges in this solid.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        sas = self._shell_analyser
        if sas.HasFreeEdges():
            topods_compound = sas.FreeEdges()
            topods_edges = list(SubShapeGenerator_(topods_compound, "edge"))
            return self._TopoDS2Shapes(topods_edges, "edge", "ignore")
        else:
            return []

    @Attribute
    def is_valid(self):
        """Is this shape valid?

        :rtype: bool
        """
        flag = True
        if self.bad_edges:
            print("Solid_ has {} bad edges. See bad_edges.".format(
                len(self.bad_edges)))
            flag = False
        if self.free_edges:
            print("Solid_ has {} free edges. See free_edges.".format(
                len(self.free_edges)))
            flag = False
        return flag

    @Attribute
    def is_reversed(self):
        """Useful to test if solid is inside-out. (negative volume). Will
        turn True if inside-out. Use reverse method to give a new solid
        that is the reversed of this solid.

        :rtype: bool
        """
        classifier = BRepClass3d_SolidClassifier(self.TopoDS_Shape)
        classifier.PerformInfinitePoint(Precision__Confusion())
        return classifier.State() == TopAbs_IN

    # ---------------- Point tests -------------------
    @Attribute
    def point_inside(self):
        """Calls :meth:`find_point_inside` with default settings.

        >>> from parapy.geom import Box
        >>> Box(1, 2, 3, centered=True).point_inside
        Point(0.0, 0.0, 0.0)

        :rtype: parapy.geom.Point
        """
        return self.find_point_inside()

    def is_inside(self, *args, **kwargs):
        """**DEPRECATED** Use :meth:`is_point_inside`"""
        msg = ('.is_inside() is deprecated, use .is_point_inside() instead. '
               'Object: {}.')
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.is_point_inside(*args, **kwargs)

    def is_point_inside(self, point, precision=1.0e-7, include_boundary=False):
        """Test if point lies inside enclosed volume. Return True if point is
        inside. A point ON one of the boundary (faces) is not considered inside
        unless ``include_boundary=True``.

        >>> from parapy.geom import Box, Point
        >>> obj = Box(1, 2, 3, centered=True)
        >>> obj.is_point_inside(Point(0.0, 0.0, 0.0))
        True
        >>> obj.is_point_inside(Point(5.0, 0.0, 0.0))  # outside
        False
        >>> obj.is_point_inside(Point(0.5, 0.0, 0.0))  # on the boundary
        False
        >>> obj.is_point_inside(Point(0.5, 0.0, 0.0), include_boundary=True)
        True

        :param parapy.geom.Point point: A Point inside the solid, or not.
        :param float precision: tolerance used for checking if point
            is inside, default is 1e-7.
        :param bool include_boundary: qualify ``point`` on the (face) boundary
            as *inside*?
        :rtype: bool

        .. caution:: be careful with solids that are reversed as any point
            outside of the intended volume is actually considered inside the
            actual volume. Check :attr:`is_reversed` or positive values of
            :attr:`volume` to verify properly oriented solid.
        """
        gp_pnt = point.gp_Pnt
        classifier = BRepClass3d_SolidClassifier(
            self.TopoDS_Shape, gp_pnt, precision)
        state = classifier.State()
        return state == TopAbs_IN or (include_boundary and state == TopAbs_ON)

    def find_point_inside(self, eps=0.1, precision=1.0e-7):
        """Tries to return a point that is inside the enclosed volume. First
        tries the bbox.center. Then recurses over the faces to create test
        points by normally offsetting the face center points inward. The offset
        distance is controlled by ``eps``, which is a fraction of the minimal
        bbox dimension. For thin-walled (hollow) solid, a smaller ``eps``
        should be specified.

        >>> from parapy.geom import Box
        >>> Box(1, 2, 3, centered=True).find_point_inside()
        Point(0.0, 0.0, 0.0)

        :param float eps: determines the offset distance, which
            is bbox.min_dimension * eps. Default: 0.1. Decrease this number
            as needed.
        :param float precision: tolerance used for checking if point
            is inside, default is 1e-7.
        :raises RuntimeError: if no point was found, or if solid is reversed,
            or if one of the bbox dimensions is zero.
        """
        if self.is_reversed:
            msg = ("Solid is reversed. Fix solid creation upstream or use "
                   ".reversed to get a properly oriented solid. Object: {}.")
            raise RuntimeError(msg.format(self))

        test = functools.partial(self.is_point_inside, precision=precision)

        # first try the bbox_center
        pt_test = self.bbox.center
        if test(pt_test):
            return pt_test
        else:
            d = self.bbox.min_dimension
            if d == 0:
                msg = ("your solid has a 0 dimension in one of the primary "
                       "directions... Object: {}.")
                raise RuntimeError(msg.format(self))

            offset = d * eps
            for face in self.faces:
                pt = face.uv_center_point
                vz = -face.uv_center_normal  # points inside volume
                pt_test = pt + vz * offset
                if test(pt_test):
                    return pt_test
        msg = ("Cant find a point inside this shape, current call: "
               ".find_point_inside(eps={}, precision={}). Consider using a "
               "smaller eps (for thin-walled solids) or change precision. "
               "Object: {}.")
        raise RuntimeError(msg.format(eps, precision, self))


# monkey_patch BRep class
BRep.SolidClass = Solid_
BRep.CompsolidClass = Solid_


class Solid(Solid_):
    """Make a solid from a shell. With optionally 1 or 2 extra shells
    that form cavities. These shells may not intersect with the outer shell.

    Usage:

    >>> from parapy.geom import Box, Solid
    >>> box1 = Box(3, 3, 3, centered=True)
    >>> box2 = Box(2, 2, 2, centered=True)
    >>> obj = Solid(built_from=box1, holes=[box2])
    """

    __initargs__ = ["built_from", "holes"]

    #: outer shell of the new solid
    #: :type: parapy.geom.occ.shell.Shell_
    built_from = Input()

    #: Optional cavities are formed from 1 or 2 inner shells.
    #: :type: collections.Sequence[parapy.geom.occ.shell.Shell_]
    holes = Input([], validator=val.Range(0, 2, key=len))

    @Attribute
    def builder(self):
        """Builder object for this Solid.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeSolid
        """
        shells = self.built_from.shells
        if len(shells) == 1:
            outer_shell = shells[0].TopoDS_Shell
        else:
            raise Exception("built_from does not consist of a single shell")

        inner_shells = []
        for i, hole in enumerate(self.holes):
            shells = hole.shells
            if len(shells) == 1:
                inner_shells.append(shells[0].TopoDS_Shell)
            else:
                msg = "Hole {} does not consist of a single shell."
                raise Exception(msg.format(i))

        builder = BRepBuilderAPI_MakeSolid(outer_shell, *inner_shells)
        if not builder.IsDone():
            raise Exception("operation failed")
        else:
            return builder


def max_tolerances(shape):
    """The maximum values found for tolerances of topological sub-shapes of
    ``shape``.

    :param parapy.geom.BRep shape: The shape which should be analyzed for its
        maximum tolerances.
    :returns: (<max vertex tolerances>, <max edge tolerance>,
        <max face tolerance>)
    :rtype: tuple[float]
    """
    return (max(BRep_Tool_Tolerance(s.TopoDS_Vertex) for s in shape.vertices),
            max(BRep_Tool_Tolerance(s.TopoDS_Edge) for s in shape.edges),
            max(BRep_Tool_Tolerance(s.TopoDS_Face) for s in shape.faces))


def limit_max_tolerance(shape, t1, t2, t3):
    """Limit the maximum of the tolerances of sub-shapes in ``shape`` to
    ``t1``, ``t2``, ``t3``.

    :param parapy.geom.BRep shape:
    :param float t1: new maximum tolerance of vertices.
    :param float t2: new maximum tolerance of edges.
    :param float t3: new maximum tolerance of faces.
    """
    s = shape.TopoDS_Shape
    fix = ShapeFix_ShapeTolerance()
    fix.SetTolerance(s, t1, TopAbs_VERTEX)
    fix.SetTolerance(s, t2, TopAbs_EDGE)
    fix.SetTolerance(s, t3, TopAbs_FACE)


class ThickenedSolid(Solid_):
    """Given a solid and faces_to_remove, create an open shell and applies a
    wall thickness to it. Returns a new solid.

    Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 2, 3)
    >>> top_face = box.top_face
    >>> thickened = ThickenedSolid(shape_in=box,
    ...                            faces_to_remove=top_face,
    ...                            thickness=0.42)

    """

    __icon__ = os.path.join(ICN_DIR, 'thickened-solid.png')
    __initargs__ = ["shape_in", "faces_to_remove", "thickness"]
    BUILDERKEY = "Shape"  # self.builder.Shape()

    #: solid
    #: :type: parapy.geom.Solid
    shape_in = Input()

    #: list of faces and/or integers
    #: :type: collections.Sequence[parapy.geom.Face | int]
    faces_to_remove = Input()

    #: positive thickness for outward thickening, negative for inward
    #: :type: float
    thickness = Input()

    #: defines the tolerance criterion for coincidence in generated shapes
    #: :type: float
    tolerance = Input(1.e-3)

    @Attribute
    def true_faces_to_remove(self):
        """
        :rtype: collections.Sequence[parapy.geom.occ.face.Face_]
        """
        token = ensure_iterable(self.faces_to_remove)
        if token:
            if isinstance(token[0], int):
                return self.shape_in.faces[token]
        return token

    @Attribute
    def builder(self):
        """The builder object.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid
        """
        # FIXME: BRepOffsetAPI_MakeThickSolid affects tolerance of
        # shape_in.TopoDS_Shape
        topods_shape = self.shape_in.TopoDS_Shape
        ClosingFaces = TopTools_ListOfShape()
        for face in self.true_faces_to_remove:
            ClosingFaces.Append(face.TopoDS_Shape)
        builder = BRepOffsetAPI_MakeThickSolid(topods_shape, ClosingFaces,
                                               self.thickness, self.tolerance)
        builder.Build()
        if not builder.IsDone():
            raise Exception("operation failed")
        else:
            return builder


class _SweptSolid(Solid_):
    """Mixin for all swept solid classes"""

    __icon__ = os.path.join(ICN_DIR, 'sweep.png')
    BUILDERKEY = "Shape"  # return self.builder.Shape()

    make_solid = True

    @Attribute
    def bottom_face(self):
        """The bottom face of the solid. Only for make_solid = True.

        :rtype: parapy.geom.occ.face.Face_
        """
        if self.make_solid:
            topods_shape = self.builder.FirstShape()
            # can be IsNull on punctional start shape (like lofting with a
            # point as first shape)
            if topods_shape.IsNull():
                return None
            else:
                return self._TopoDS2Shape(topods_shape)
        else:
            raise Exception("B-Rep is not solid, but a shell. Hence, "
                            "bottom face does not exist.")

    @Attribute
    def top_face(self):
        """The top face of the solid. Only for make_solid = True.

        :rtype: parapy.geom.occ.face.Face_
        """
        if self.make_solid:
            topods_shape = self.builder.LastShape()
            # can be IsNull on punctional start shape (like lofting with a
            # point as first shape)
            if topods_shape.IsNull():
                return None
            else:
                return self._TopoDS2Shape(topods_shape)
        else:
            raise Exception("B-Rep is not solid, but a shell. Hence, top "
                            "face does not exist.")

    @Attribute
    def lateral_faces(self):
        """All faces except bottom and top.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        # FIXME: when top_face isn't reliably found, this slot will return
        # the wrong face.
        if self.make_solid:
            # preserve order of faces
            bt_faces = {self.bottom_face, self.top_face}
            return [face for face in self.faces if face not in bt_faces]
            # return list(set(self.faces) - set([self.bottom_face,
            #                                    self.top_face]))
        else:
            return self.faces


class ExtrudedSolid(_SweptSolid):
    """
    Limitation: profile and holes need to lie in one and the same plane!!!
    Otherwise use your own face input.

    Usage:

    >>> from parapy.geom import ExtrudedSolid, Rectangle, Circle
    >>> island = Rectangle(1, 1)
    >>> obj1 = ExtrudedSolid(island=island, distance=1)
    >>> # Let's now extrude with an hole.
    >>> hole = Circle(0.3)
    >>> obj2 = ExtrudedSolid(island=island, distance=1, holes=[hole])
    """

    __icon__ = os.path.join(ICN_DIR, 'extrusion.png')
    __initargs__ = ["island", "distance", "direction"]

    #: Optional, a planar profile. Specify this if you have a
    #: :class:`~parapy.geom.occ.curve.Curve` defining the face to extrude,
    #: optionally with :attr:`holes`. The created face will be available in
    #: attr:`face_in`.
    #: :type: parapy.geom.Curve | None
    island = Input(None)

    #: Direction is relative to the orientation.
    #: :type: parapy.geom.Vector | str
    direction = Input("z")

    #: Optional extrusion distance
    #: :type: float
    distance = Input(derived, validator=val.Positive())

    #: Optional, use this when you already have the face you want to extrude
    #: instead of specifying :attr:`island`. Otherwise it will be created
    #: from :attr:`island` and :attr:`holes`.
    #: :type: parapy.geom.Face
    face_in = Input(derived)

    #: Must be a Sequence of planar Curve, Edge, Wire objects
    #: :type: sequence.Collections[Curve | Edge | Wire]
    holes = Input([])

    #: If True, profile will also be extruded in opposite :attr:`direction`.
    #: Distance_ is same as :attr:`distance`.
    #: :type: bool
    mirrored_extent = Input(False)

    #: Mirrored extent distance
    #: :type: float
    distance_ = Input(distance)

    @distance.getter
    def distance(self):
        """
        :rtype: float
        """
        return self._direction.length

    @face_in.getter
    def face_in(self):
        """
        :rtype: parapy.geom.Face
        """
        return Face(self.island, self.holes)

    # =========================================================================
    # Attributes
    # =========================================================================
    @Attribute
    def _direction(self):
        """Direction is relative to the orientation.

        :rtype: parapy.geom.Vector
        """
        return self.position.ensure_vector(self.direction, False)

    @Attribute
    def _basis_face(self):
        """
        :rtype: parapy.geom.occ.face.Face_
        """
        if self.mirrored_extent:
            return self.face_in.translated(self._direction.reverse,
                                           self.distance_)
        else:
            return self.face_in

    @Attribute
    def builder(self):
        """Builder object for this ExtrudedSolid

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakePrism
        """
        # Note: no need enable the copy option, because the face
        # is created and used only here
        distance = (self.distance +
                    self.distance_ if self.mirrored_extent else self.distance)
        vector = self._direction * distance
        builder = BRepPrimAPI_MakePrism(self._basis_face.TopoDS_Shape,
                                        vector.gp_Vec,
                                        False)  # don't copy
        if builder.IsDone():
            return builder
        else:
            raise Exception("BRepPrimAPI_MakePrism failed")


class SweptSolid(_SweptSolid):
    """Make a pipe solid either with fixed radius or with a constant profile.
    If you input a radius, the profile is a circle with it's z vector aligned
    with the tangent1 of the path. Other types of surface will be
    implemented in the future.

    Usage:

    >>> from parapy.geom import InterpolatedCurve, Point, SweptSolid, Rectangle
    >>> curve = Rectangle(1, 1)
    >>> pts = [Point(0, 0, 0), Point(0, 1, 1), Point(0, 1, 2)]
    >>> path = InterpolatedCurve(points=pts)
    >>> obj = SweptSolid(profile=curve, path=path)

    For more information, check `Open Cascade Documentation
    <https://www.opencascade.com/doc/occt-7.1.0/refman/html/class_b_rep_offset_a_p_i___make_pipe.html>`__.
    """

    __initargs__ = ["path", "profile"]

    #: path that is followed for sweep
    #: :type: parapy.geom.Curve
    path = Input()

    #: Planar profile. This (with holes) or face
    #: :type: parapy.geom.Curve | parapy.geom.Face | None
    profile = Input(None)

    #: Must be a Sequence of planar Curve, Edge, Wire objects
    #: :type: collections.Sequence[Curve | Edge | Wire]
    holes = Input([])

    #: Optional, specify this if needed instead of profile
    #: :type: parapy.geom.Face
    face_in = Input(derived)

    #: Specify a mode influences how the sweep takes place through the
    #: profiles.
    #: :type: str | None
    mode = Input(None, validator=val.OneOf([None] + list(_SWEEP_MODES.keys())))

    #: If set to :py:`True`, will attempt to let the surface of the SweptSolid
    #: approximate C1-continuity, if it is proven that it will be
    #: C0-continuous.
    #: :type: bool
    force_c1_approx = Input(False)

    def _get_face_in(self):
        """
        :rtype: parapy.geom.Face
        """
        return Face(self.profile, self.holes)

    @Attribute
    def builder(self):
        """override on subclassing

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipe
        """
        mode = self.mode
        args = [self.path.TopoDS_Wire, self.face_in.TopoDS_Shape]
        if mode is not None:
            mode = _SWEEP_MODES[mode]
            args += [mode, self.force_c1_approx]

        builder = BRepOffsetAPI_MakePipe(*args)
        if builder.IsDone():
            return builder
        else:
            raise Exception("BRepOffsetAPI_MakePipe failed")


class PipeSolid(SweptSolid):
    """Make a solid with a circular section (for now) of fixed :attr:`radius`
    along a :attr:`path`. Usage:

    >>> from parapy.geom import LineSegment, Point, PipeSolid, Vector
    >>> crv = LineSegment(start=Point(0, 0, 0), end=Point(0, 1, 0))
    >>> obj = PipeSolid(path=crv, radius=0.2)
    >>> obj.orientation.x
    Vector(0.0, 0.0, 1.0)
    >>> # put the seam of the PipeSolid at the right side
    >>> obj = PipeSolid(path=crv, radius=0.2,
    ...                 normal1_reference=Vector(1, 0, 0))
    >>> obj.orientation.x
    Vector(1.0, 0.0, 0.0)
    """

    __initargs__ = ["path", "radius"]

    #: either a pipe radius or profile can be used
    #: :type: float
    radius = Input()

    #: Override the ``normal1`` of :attr:`path`. It can be
    #: useful for cases when the normal cannot be determined because the
    #: :attr:`path` has no curvature at the start.
    #: The provided :class:`~parapy.geom.Vector` will be used as a reference
    #: to create a ``normal1`` Vector that is orthogonal to the tangent
    #: at the start of the :attr:`path`. The resulting
    #: :class:`~parapy.geom.Vector` can be inspected as ``x`` of
    #: :attr:`orientation`.
    #: The constructed normal will point from the starting point of
    #: :attr:`path` to the seam of the of :attr:`profile`.
    #: :type: parapy.geom.Vector | None
    normal1_reference = Input(None)

    @Attribute
    def position(self):
        """Axis system at start of :attr:`path`. Vz points along path tangent,
        Vx is one of the in-plane vectors of the circle at start, and can be
        controlled using :attr:`normal1_reference`.

        :rtype: Position
        """
        path, normal1_ref = self.path, self.normal1_reference
        tangent = path.tangent1

        if normal1_ref:
            # TODO (FT): use make_orthogonal_vector()
            if normal1_ref.is_parallel(tangent):
                msg = ("normal1_reference {!r} is not a valid reference "
                       "Vector: it is parallel to path.tangent1. Please "
                       "provide a value which is not parallel. Object: {!r}")
                raise ValueError(msg.format(normal1_ref, self))

            # use normal1 ref to find the y-component of circle plane at start
            vy = tangent.cross(normal1_ref)
            orientation = Orientation(z=tangent, y=vy)
        else:
            try:
                vx = path.normal1
            except ZeroCurvature as e:
                if e.obj is path:  # check if exception originates from path
                    vx = orthogonal_vector(tangent)
                else:
                    raise  # re-raise ZeroCurvature (originated elsewhere)
            orientation = Orientation(z=tangent, x=vx)

        return Position(location=path.point1, orientation=orientation)

    @Part(in_tree=False)
    def profile(self):
        """The profile of this pipe.

        :rtype: parapy.geom.Circle
        """

        return Circle(radius=self.radius, position=self.position)


class AdvancedPipeSolid(Solid_):
    """Make a solid with a circular section (for now) of fixed :attr:`radius`
    along a :attr:`path`. This class uses a different construction method
    than :class:`PipeSolid`, and exposes more options, for instance a guiding
    path. When you do not need to use the advanced options, it is recommended
    to use :class:`PipeSolid` instead.

    Usage:

    >>> from parapy.geom import InterpolatedCurve, Point
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)]
    >>> crv = InterpolatedCurve(pts)
    >>> obj = AdvancedPipeSolid(path=crv, radius=0.2)

    .. note:: When the surface of the resulting pipe appears to be
        `complex`, it
        might be that the normal of the curve twists a lot, resulting to
        a twisted surface of the PipeSolid. The different modes,
        especially the guide_path, can be used
        to influence how the normal of the :attr:`path` will look.

    .. caution:: This class was added as an experimental feature, and will
        be made more user-friendly in the future. The name
        and functionality of this class might therefore change or disappear
        in future (minor) releases.

    For more information and to get a better understanding of the modes and
    options, check `Open Cascade Documentation
    <https://www.opencascade.com/doc/occt-7.1.0/refman/html/class_b_rep_offset_a_p_i___make_pipe_shell.html>`__.
    """

    __initargs__ = ["path", "radius"]

    #: :type: parapy.geom.Curve
    path = Input()

    #: :type: float
    radius = Input()

    #: Frenet fill mode
    #: :type: bool | None
    is_frenet = Input(None)

    #: Mode which uses a fixed binormal for the path
    #: used to create the PipeSolid. It influences the normal of the curve.
    #: One can give
    #: a Vector, or set to 'True' to use a random Vector that is normal to the
    #: starting point of 'path'
    #: :type: parapy.geom.Vector | None | bool
    binormal = Input(None)

    #: Sets a Discrete trihedron to perform the sweeping.
    discrete = Input(False)

    #: Use an guiding path to create the pipe. It can be used to
    #: influence the surface of the PipeSolid (like the bi-normal).
    #: How the guide path is used is influenced by
    #: :attr:`guide_path_equivalence`, and :attr:`guide_contact`.
    #: :type: parapy.geom.Wire
    guide_path = Input(None)
    #: Defines which points are equivalent on the :attr:`guide_path` and
    #: the :attr:`path`.
    #: If set to True, the corresponding points on the path and the
    #: guide path will be defined by the same length ratio. Otherwise,
    #: it will be defined by the tangent of the Spine. (See opencascade
    # documentation on BRepOffsetAPI_MakePipeShell, about the AuxiliarySpine)
    guide_path_equivalence = Input(False)
    #: Defines the contact of the created pipe with the guide path.
    #: If set to 'no', the corresponding points on path and the guide path
    #: will be used to define the bi-normal of the sweeped section.
    #: If set to 'keep', the normal will be defined so that the sweeped
    #: section is in contact with the sweeped section.
    #: If set to 'border' the auxiliary spine becomes a boundary of the
    #: swept surface and the width of section varies along the path
    guide_contact = Input("no", validator=val.OneOf(["no", "keep", "border"]))

    #: A Face, or higher topology, that supports the spine, and defines the
    #: binormal of the trihedron.
    #: Warning: To be effective, Each edge of the spine must
    #: have an representation on one face of the spine_support.
    spine_support = Input(None)

    # Settings to influence the quality of the calculation and the output
    with_contact = Input(False)
    with_correction = Input(False)
    #: If the resulting surface is C0-continuous, force the generated surface
    #:  of the solid to approximate C1 continuity
    force_c1_approx = Input(False)

    #: 3D tolarance
    tol_3d = Input(1e-4)
    #: boundary tolerance
    tol_boundary = Input(1e-4)
    #: angular tolerance
    tol_angular = Input(1e-2)

    #: Define the maximum number of spans in V-direction on resulting surface.
    # max_segments = Input(None)
    #: Define the maximum V degree of resulting surface.
    # max_degree = Input(None)

    _CONTACT_MAP = {"no": BRepFill_NoContact,
                    "keep": BRepFill_Contact,
                    "border": BRepFill_ContactOnBorder}

    #: Defines how discontinuities in :attr:`path` should be handled to
    #: create one PipeSolid.
    transition_mode = Input("transformed",
                            validator=val.OneOf(["transformed",
                                                 "rounded",
                                                 "right_angle"]))

    BUILDERKEY = "Shape"

    def __set_modes(self, builder):
        """
        :param OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipeShell builder:
        """
        path = self.path
        if self.discrete:
            builder.SetDiscreteMode()

        # frenet mode
        is_frenet = self.is_frenet
        if is_frenet is not None:
            builder.SetMode(is_frenet)

        # use fixed binormal mode
        binormal = self.binormal
        if binormal:
            if binormal is True:
                # use random normal to start of path
                binormal = path.normal(path.u1)
            builder.SetMode(gp_Dir(*binormal))

        # auxiliary spine mode
        guide_path = self.guide_path
        if guide_path is not None:
            contact_flag = self._CONTACT_MAP[self.guide_contact]
            builder.SetMode(guide_path.TopoDS_Wire,
                            self.guide_path_equivalence,
                            contact_flag)

        # spine support mode
        spine_support = self.spine_support
        if spine_support is not None:
            builder.SetMode(spine_support.TopoDS_Shape)

    def __set_quality(self, builder):
        """
        :param OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipeShell builder:
        """
        builder.SetForceApproxC1(self.force_c1_approx)

        builder.SetTolerance(self.tol_3d,
                             self.tol_boundary,
                             self.tol_angular)

        # limits on segments and degree
        # TODO (FT): Removed for now, since it may lead to segmentation faults.
        # max_seg = self.max_segments
        # if max_seg is not None:
        #     builder.SetMaxSegments(max_seg)
        #
        # max_deg = self.max_degree
        # if max_seg is not None:
        #     builder.SetMaxDegree(max_deg)

    @Attribute
    def builder(self):
        """The profile of this pipe.

        :rtype: parapy.geom.Circle
        """
        path = self.path
        builder = BRepOffsetAPI_MakePipeShell(path.TopoDS_Wire)

        self.__set_modes(builder)
        self.__set_quality(builder)

        # what to do to transition a discontinuity
        transition_flag = MultiSectionSolid._TRANSITION_MODE[
            self.transition_mode]
        builder.SetTransitionMode(transition_flag)

        # add profile
        circle = Circle(radius=self.radius, position=path.position1)
        builder.Add(circle.TopoDS_Wire, self.with_contact,
                    self.with_correction)
        builder.Build()

        # create solid
        is_closed = builder.MakeSolid()
        if not is_closed:
            msg = ("Could not create a PipeSolid, not all the profiles were "
                   "closed. Object: {}")
            raise RuntimeError(msg.format(self))

        return builder


class MultiSectionSolid(_SweptSolid):
    """
    Make a swept solid between varying profiles following one or multiple
    spines. As your profiles are (probably) wires consisting of multiple edges,
    separate faces will be composed for each edge pair.
    IMPORTANT: the order of the edges is not altered, make sure you compose
    your wire with desired edge ordering and orientation in mind!
    FIXME: may fail on paths with long parametric range, like resulting
    from InterpolatedCurve/
    FittedCurve. In case of failure, try to normalize your path.

    Usage:

    >>> from parapy.geom import MultiSectionSolid, FittedCurve, Circle, Point
    >>> pnts = [Point(0, 0, 0), Point(0, 0, 1), Point(1, 0, 2)]
    >>> path = FittedCurve(points=pnts)
    >>> profile = Circle(radius=0.1)
    >>> obj = MultiSectionSolid(path=path, profiles=[profile])
    """

    __initargs__ = ["path", "profiles"]

    #: The path for the sweeping operation. Can also be a list of paths
    #: for multi-profile, multi-spline creation
    #: :type: collections.Sequence[parapy.geom.Curve]]
    path = Input()

    #: list of cross-sectional curves/wires. These are the
    #: cross-sections of your solid.
    #: :type: collections.Sequence[parapy.geom.Curve | parapy.geom.Wire]]
    profiles = Input()

    #: Makes a solid out of the swept profiles
    #: :type: bool
    make_solid = Input(True)

    #: keep contact between profiles and path?
    #: :type: bool
    keep_contact = Input(False)

    # tolerance values
    #: :type: float
    tolerance = Input(1.0e-4)  # Tol3d

    # boundary tolerance values
    #: :type: float
    boundary_tolerance = Input(1.0e-4)

    # angular tolerance values
    #: :type: float
    angular_tolerance = Input(1.0e-2)

    #: "Controls the transition mode to manage discontinuities on the swept"
    #: shape caused by fractures on the spine.
    # See:"http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classBRepOffsetAPI__MakePipeShell_a322e05d11186d3042b750688390c4da.html#a322e05d11186d3042b750688390c4da"
    transition_mode = Input("transformed",
                            validator=val.OneOf(["transformed",
                                                 "rounded",
                                                 "right_angle"]))

    #: bi_normal
    #: :type: parapy.geom.Vector | None
    bi_normal = Input(None)

    #: orientation profiles
    #: :type: None | parapy.geom.Curve
    orientation_profiles = Input(None)

    _TRANSITION_MODE = {"transformed": BRepBuilderAPI_Transformed,
                        "rounded": BRepBuilderAPI_RoundCorner,
                        "right_angle": BRepBuilderAPI_RightCorner}

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipeShell
        """
        paths = ensure_iterable(self.path)
        builder = BRepOffsetAPI_MakePipeShell(paths[0].TopoDS_Wire)
        for profile in self.profiles:
            if hasattr(type(profile), "TopoDS_Vertex"):
                builder.Add(profile.TopoDS_Vertex, self.keep_contact)
            else:
                builder.Add(profile.TopoDS_Wire, self.keep_contact)
        if self.bi_normal:
            builder.SetMode(self.bi_normal.gp_Dir)
        if self.orientation_profiles:
            builder.SetMode(self.orientation_profiles.gp_Ax2)
        for auxiliary_path in paths[1:]:
            # add auxiliary spines
            builder.SetMode(auxiliary_path.TopoDS_Wire, True, False)
        builder.SetTolerance(self.tolerance,
                             self.boundary_tolerance,
                             self.angular_tolerance)
        builder.SetTransitionMode(self._TRANSITION_MODE[self.transition_mode])
        builder.Build()
        if builder.IsDone():
            if self.make_solid:
                # FIXME: if shell is empty (has happened), makesolid
                # will raise error
                flag = builder.MakeSolid()
                if not flag:
                    raise Exception("Shell was created, but making a "
                                    "solid failed. "
                                    "Perhaps your profiles aren't planar? "
                                    "Set make_solid to False")
            return builder
        else:
            raise Exception("Operation failed. Check input geometry.")

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os

from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_MakeFace
from OCC.wrapper.BRepOffset import (
    BRepOffset_BadNormalsOnGeometry, BRepOffset_C0Geometry,
    BRepOffset_MakeOffset, BRepOffset_NoError, BRepOffset_NotConnectedShell,
    BRepOffset_NullOffset, BRepOffset_Skin, BRepOffset_UnknownError)
from OCC.wrapper.BRepOffsetAPI import (
    BRepOffsetAPI_MakeOffset,
    BRepOffsetAPI_MakeThickSolid)
from OCC.wrapper.Geom import Geom_OffsetSurface, Handle_Geom_Plane_DownCast
from OCC.wrapper.GeomAbs import GeomAbs_Arc, GeomAbs_Intersection
from OCC.wrapper.ShapeFix import ShapeFix_Shell
from OCC.wrapper.TopAbs import TopAbs_SHELL, TopAbs_SOLID
from OCC.wrapper.TopoDS import TopoDS__Wire

from parapy.core import Attribute, Base, Input, derived
from parapy.core.utilities import raise_conditionally
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.face import Face_
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import Plane_, Surface
from parapy.geom.occ.tolerances import ToleranceGuard, get_max_tolerances
from parapy.geom.occ.utilities import (
    dynamic_transient_type,
    iterate_TopTools_ListOfShape,
    make_TopTools_ListOfShape, sub_shapes, topods_shape_getter)
from parapy.geom.occ.wire import Wire_

__all__ = ["OffsetWire", "OffsetSurface", "OffsetPlane", "OffsetShell",
           "ThickSolid", "ThickShell"]

py_BRepOffset_Error = {BRepOffset_NoError:
                           "BRepOffset_NoError",
                       BRepOffset_UnknownError:
                           "Unknown Error",
                       BRepOffset_BadNormalsOnGeometry:
                           "Bad normals on input geometry",
                       BRepOffset_C0Geometry:
                           "C0 input geometry",
                       BRepOffset_NullOffset:
                           "input geometry with null offset(s)",
                       BRepOffset_NotConnectedShell:
                           "input shell is not connected"}


class OffsetPlane(Plane_):
    """Creates a new plane by normally offsetting another plane
    :attr:`built_from` over :attr:`distance`. Offset direction corresponds to
    the :attr:`~Surface.plane_normal` of input plane. Use a negative distance
    for offsetting in opposite direction.

    Usage:

    >>> from parapy.geom import Plane, OffsetPlane
    >>> plane1 = Plane()  # lies in XOY plane
    >>> plane2 = OffsetPlane(plane1, 10)  # normal vector is positive 'z'
    >>> plane2.location
    Point(0.0, 0.0, 10.0)
    >>> plane3 = OffsetPlane(plane1, -10)  # opposite to plane1 normal.
    >>> plane3.location
    Point(0.0, 0.0, -10.0)
    """

    __initargs__ = ["built_from", "distance"]

    #: base surface that will be offset
    #: :type: parapy.geom.occ.surface.Plane
    built_from = Input()

    #: offset distance
    #: :type: float
    distance = Input()

    #: The dimension for visualization. Corresponds to width/length of plane.
    #: Defaults to :attr:`v_dim` of :attr:`built_from`.
    #: :type: float
    v_dim = Input(derived)

    @v_dim.getter
    def v_dim(self):
        return self.built_from.v_dim

    @Attribute
    def displacement_vector(self):
        """Vector representing the offset its displacement.

        :rtype: parapy.geom.Vector
        """
        d = self.distance
        if hasattr(d, "__iter__"):
            return d
        else:
            v = self.built_from.orientation.z
            return d * v

    @Attribute
    def reference(self):
        """:rtype: parapy.geom.Point | parapy.geom.Position"""
        return self.built_from.reference + self.displacement_vector

    @Attribute
    def normal(self):
        """:rtype: parapy.geom.Vector"""
        return self.built_from.orientation.z

    @Attribute
    def binormal(self):
        """:rtype: parapy.geom.Vector"""
        return self.built_from.orientation.x

    @Attribute
    def position(self):
        """:rtype: parapy.geom.Position"""
        return self.built_from.position + self.displacement_vector

    @Attribute
    def Handle_Geom_Surface(self):
        """:rtype: OCC.Geom.Geom_Plane"""
        h_surf1 = self.built_from.Handle_Geom_Surface
        h_surf2 = Geom_OffsetSurface(h_surf1, self.distance).Surface()
        return Handle_Geom_Plane_DownCast(h_surf2)


class OffsetBase(Base):
    """Abstract base class for thickening operations.

    One at least has to implement :meth:`_build` in a derived class.
    """

    __icon__ = os.path.join(ICN_DIR, 'thickened-solid.png')

    #: Original shape to offset.
    #: :type: parapy.geom.occ.brep.BRep
    built_from = Input()
    #: offset from original shape to new shape. Positive value is outward
    #: offset, negative inwards.
    #: :type: float
    offset = Input()
    #: Tolerance criterion for coincidence in generated shapes.
    #: :type: float
    tolerance = Input(1.e-6)
    #: Defines how to fill the holes that may appear between parallels to
    #: two adjacent faces. Either 'arc' or 'intersection'.
    #: :type: str
    join_type = Input("arc")
    #: OpenCascade tends to place very large tolerances on the resulting
    #: thickened shape. If :py:`True`, ParaPy will limit the maximum
    #: tolerances of the thickened shape to the maximum (vertex, edge and face)
    #: tolerances of :attr:`built_from`.
    #: :type: bool
    fix_tolerances = Input(False)

    @Attribute
    def max_tolerances(self):
        """The maximum encountered tolerance of the vertices, edges, faces
        in the Offset shape.

        :rtype: tuple[float, float, float]
        """
        return get_max_tolerances(self.TopoDS_Shape)

    @Attribute
    def max_tolerances_built_from(self):
        """The maximum encountered tolerance of the vertices, edges, faces
        in the shape referenced by :attr:`built_from`.

        :rtype: tuple[float, float, float]
        """
        return get_max_tolerances(self.built_from.TopoDS_Shape)

    @Attribute
    def builder(self):
        """Builder object of this offsetted shape.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeOffset
        """
        # wraps self._build() and fixes tolerances of input and output shapes.
        topods_shape_in = self.built_from.TopoDS_Shape
        # OCCFIX: BRepOffset(API) modifies tolerances of input shape
        with ToleranceGuard(topods_shape_in) as t:
            builder = self._build()
            if self.fix_tolerances:
                # OCCFIX: BRepOffset(API) puts large tolerances on output shape
                topods_shape_out = builder.Shape()
                t.limit_max_tolerances(topods_shape_out)
            return builder

    @Attribute
    def TopoDS_Shape(self):
        """Thickened shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    # override this method in subclasses
    def _build(self):
        """Return the BRepOffset(API) builder.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeOffset
        """
        raise NotImplementedError()


class OffsetWire(OffsetBase, Wire_):
    """Use to offset a **PLANAR** wire :attr:`built_from` parallel to
    itself (so in the its own plane) over distance :attr:`offset`.

    Usage:

    >>> from parapy.geom import Rectangle
    >>> wire = Rectangle(1, 2)
    >>> # outward offset
    >>> obj = OffsetWire(wire, offset=0.1)
    >>> # inward offset
    >>> obj = OffsetWire(wire, offset=-0.1)
    """

    __initargs__ = ["built_from", "offset"]

    #: Original wire to offset.
    #: :type: parapy.geom.Wire
    built_from = Input()

    # uninherit from OffsetBase
    tolerance = Attribute(None)

    def _build(self):
        """Build the OffsetWire and return the BRepOffset(API) builder.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeOffset
        :raises RuntimeError: if building the OffsetWire failed.
        """
        built_from = self.built_from
        join_type = self.join_type
        Offset = self.offset
        Alt = 0.0
        Spine = built_from.TopoDS_Wire
        # face_builder = BRepBuilderAPI_MakeFace(topods_wire, True)
        # Spine = face_builder.Face()
        Join = GeomAbs_Arc if join_type == "arc" else GeomAbs_Intersection
        IsOpenResult = False
        builder = BRepOffsetAPI_MakeOffset()
        builder.Init(Join) # IsOpenResult = False
        builder.AddWire(Spine)
        builder.Perform(Offset, Alt)

        if not builder.IsDone():
            msg = "BRepOffsetAPI_MakeOffset() failed."
            raise RuntimeError(msg)

        return builder


class OffsetSurface(Surface):
    """Offets basis_surface of :attr:`surface_in` normally to itself over
    :attr:`distance`. The offset results of naturally bounded surfaces
    (BSpline, Bezier, RectangularTrimmed) will be naturally bounded as well.
    Otherwise an unbounded surface is returned. For example, if a Face is
    provided, whose outer_wire lies on a Plane-type basis_surface, the offset
    surface is an infinite plane. Consider :class:`OffsetShell` for trimmed
    results.

    Usage:

    >>> from parapy.geom import Point, BezierSurface, OffsetSurface
    >>> points = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...           (Point(0, 0, 1), Point(1, 2, 1), Point(2, 0, 1)),
    ...           (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> srf = BezierSurface(control_points=points)
    >>> obj = OffsetSurface(surface_in=srf, distance=0.5)
    """

    __initargs__ = ["surface_in", "distance"]

    #: base surface that will be offset
    #: :type: parapy.geom.Surface
    surface_in = Input()

    #: offset distance
    #: :type: float
    distance = Input()

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """override on subclassing

        :rtype: OCC.Geom.Geom_OffsetSurface
        """
        # FIX RvD: Surface() returns bounded surface is possible.
        h_srf = self.surface_in.Handle_Geom_Surface
        builder = Geom_OffsetSurface(h_srf, self.distance)
        transient_type = dynamic_transient_type(h_srf)
        if (transient_type == "Geom_BSplineSurface"
            or transient_type == "Geom_BezierSurface"):
            # DO NOT CALL Surface() -> segfault
            return builder.handle
        else:
            return builder.Surface()


class OffsetFace(OffsetBase, Face_):
    """Use to offset a **PLANAR** face :attr:`built_from` parallel to
    itself (so in the its own plane) over distance :attr:`offset`.

    Usage:

    >>> from parapy.geom.occ.offset import OffsetFace
    >>> from parapy.geom import RectangularFace
    >>> face = RectangularFace(1, 1)
    >>> # Offset is applied outwards
    >>> obj1 = OffsetFace(built_from=face, offset=0.3)
    >>> # Offset is applied inwards
    >>> obj2 = OffsetFace(built_from=face, offset=-0.3)
    """

    __initargs__ = ["built_from", "offset"]

    #: :type: parapy.geom.occ.face.Face_
    built_from = Input()

    #: Re-use the basis surface of **built_from** to create a new face. Can
    #: only work if basis surface is large enough for new offset wire.
    #: :type: parapy.geom.occ.face.Face_
    share_basis_surface = Input(False)

    # uninherit
    tolerance = None

    def _build(self):
        """Build the OffsetFace and return the BRepOffset(API) builder.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeOffset
        :raises RuntimeError: if building the OffsetFace failed.
        """
        built_from = self.built_from
        join_type = self.join_type
        Offset = self.offset
        Alt = 0.0
        Spine = built_from.TopoDS_Face
        # face_builder = BRepBuilderAPI_MakeFace(topods_wire, True)
        # Spine = face_builder.Face()
        Join = GeomAbs_Arc if join_type == "arc" else GeomAbs_Intersection
        IsOpenResult = False
        builder = BRepOffsetAPI_MakeOffset()
        builder.Init(Spine, Join) # IsOpenResult = False
        builder.Perform(Offset, Alt)

        if not builder.IsDone():
            msg = "BRepOffsetAPI_MakeOffset() failed."
            raise RuntimeError(msg)

        return builder

    @Attribute
    def TopoDS_Shape(self):
        """The thickened shape.

        :rtype: OCC.TopoDS.TopoDS_Shape
        :raises RuntimeError: if building the OffsetFace failed.
        """
        shape = self.builder.Shape()
        wire = TopoDS__Wire(shape)
        if self.share_basis_surface:
            h_surf = self.built_from.Handle_Geom_Surface
            face_builder = BRepBuilderAPI_MakeFace(h_surf, wire)
        else:
            face_builder = BRepBuilderAPI_MakeFace(wire, True)
        if face_builder.IsDone():
            return face_builder.Face()
        else:
            msg = "BRepBuilderAPI_MakeFace() failed"
            raise RuntimeError(msg)


class OffsetShell(OffsetBase, Shell_):
    """Creates a new shell by normally offsetting a shell :attr:`built_from`
    over a distance :attr:`offset`. Positive value is outward offset, negative
    inwards. Usage:

    >>> from parapy.geom import OffsetShell, Box, SewnShell
    >>> box = Box(1, 1, 1)
    >>> shell = SewnShell([box.top_face, box.rear_face, box.bottom_face])
    >>> # Offset is applied outwards
    >>> obj = OffsetShell(built_from=shell, offset=0.3)
    >>> # Offset is applied inwards
    >>> obj = OffsetShell(built_from=shell, offset=-0.3)

    .. note:: Warnings:

        1. All the faces of the shape :attr:`built_from` should be based on
            the surfaces with continuity at least C1.
        2. The offset value should be sufficiently small to avoid
            self-intersections in resulting shape. Otherwise these
            self-intersections may appear inside an offset face if its initial
            surface is not plane or sphere or cylinder, also some non-adjacent
            offset faces may intersect each other. Also, some offset surfaces
            may "turn inside out".
        3. The algorithm may fail if the shape contains vertices where more
            than 3 edges converge.
        4. Since 3d-offset algorithm involves intersection of surfaces, it is
            under limitations of surface intersection algorithm.
        5. A result cannot be generated if the underlying geometry of
            :attr:`built_from` is B-Spline with continuity C0.
    """

    __initargs__ = ["built_from", "offset"]

    #: :type: parapy.geom.occ.shell.Shell_
    built_from = Input()

    #: offset from original shell to new shell. Positive value is outward
    #: offset, negative inwards. Can also be a an iterable with Face and
    #: offset pairs.
    #: :type: float | collections.Iterable[parapy.geom.occ.face.Face_, float]
    offset = Input()

    #: Either "raise", "warn", "ignore"
    #: :type: str
    failure = Input("raise")

    #: flag defines whether to remove the INTERNAL edges from the result or not
    #: :type: bool
    remove_internal_edges = Input(False)

    def _build(self):
        """Build the OffsetShell and return the BRepOffset(API) builder.

        :rtype: OCC.BRepOffset.BRepOffset_MakeOffset
        :raises RuntimeError: if building the OffsetShell failed.
        """
        built_from = self.built_from
        join_type = self.join_type
        offset = self.offset

        S = built_from.TopoDS_Shape
        if hasattr(offset, "__iter__"):
            # set to initial offset way bigger than tolerance
            # will be corrected later.
            Offset = 1.0
        else:
            Offset = offset

        Tol = self.tolerance
        Mode = BRepOffset_Skin  # only option implemented
        Intersection = False  # True is not recommended
        SelfInter = False  # only option implemented
        Join = GeomAbs_Arc if join_type == "arc" else GeomAbs_Intersection
        Thickening = False
        builder = BRepOffset_MakeOffset()
        remove_internal_edges = self.remove_internal_edges
        builder.Initialize(S, Offset, Tol, Mode, Intersection,
                           SelfInter, Join, Thickening,
                           remove_internal_edges)
        if hasattr(offset, "__iter__"):
            # first initialize everything to 0.0
            for face in built_from.faces:
                F = face.TopoDS_Face
                builder.SetOffsetOnFace(F, 0.0)
            # then re-apply offsets
            for face, Off in offset:
                print("applying offset:", face, Off)
                F = face.TopoDS_Face
                builder.SetOffsetOnFace(F, Off)

        builder.MakeOffsetShape()

        if not builder.IsDone():
            brepoffset_error = builder.Error()
            try:
                brepoffset_msg = py_BRepOffset_Error[brepoffset_error]
            except KeyError:
                brepoffset_msg = "BRepOffset_Error enum {}".\
                    format(brepoffset_error)
            fmt = "Creating offset shell failed: '{}'."
            msg = fmt.format(brepoffset_msg)
            raise_conditionally(RuntimeError, msg, self.failure)

        return builder

    @Attribute
    def TopoDS_Shape(self):
        """Thickened shape.

        :rtype: OCC.TopoDS.TopoDS_Shell
        :raises RuntimeError: If the resulting shape contains more than one
        shell, or if the result of the operation is not a solid.
        """
        builder = self.builder
        shape = builder.Shape()
        if shape.IsNull():
            msg = "Shape is NULL shape. Object: {}."
            raise RuntimeError(msg.format(self))

        st = shape.ShapeType()
        if st == TopAbs_SOLID:
            # one solid -> return Shell
            shells = tuple(sub_shapes(shape, downcast=True))
            if len(shells) != 1:
                msg = "Resulting shape contains {:} shells.".format(st)
                raise_conditionally(RuntimeError, msg, self.failure)
                return shape
            else:
                topods_shell = shells[0]
                # FIXME (TBD): Should this fix happen?. Author: FT.
                fixer = ShapeFix_Shell(topods_shell)
                fixer.Perform()
                return fixer.Shell()
        elif st == TopAbs_SHELL:
            return shape
        else:
            msg = "Resulting shape is not a shell, but TopAbs_Enum {:}."
            raise_conditionally(RuntimeError, msg.format(st), self.failure)
            return shape

    # TODO (TBD): seems to always return NULL shape. Author: RvD.
    # @Attribute
    # def bad_shape(self):
    #     self.builder.CheckInputData()
    #     topods_shape = self.builder.GetBadShape()
    #     from parapy.geom.occ.compound import Shape
    #     return Shape(TopoDS_Shape=topods_shape)

    @Attribute
    def _face_image(self):
        """:rtype: OCC.BRepAlgo.BRepAlgo_Image"""
        return self.builder.OffsetFacesFromShapes()

    @Attribute
    def _edge_image(self):
        """:rtype: OCC.BRepAlgo.BRepAlgo_Image"""
        return self.builder.OffsetEdgesFromShapes()

    def generated(self, shape):
        """List of shapes generated by ``shape``.

        :type shape: parapy.geom.BRep
        :rtype: list[parapy.geom.BRep]
        :raises RuntimeError: if ``shape`` is not an Edge or a Face
        """
        S = shape.TopoDS_Shape
        st = S.ShapeType()
        if st == 4:
            m = self._face_image
        elif st == 6:
            m = self._edge_image
        else:
            msg = "shape should be either Edge or Face, not {:}".format(shape)
            raise RuntimeError(msg)
        if m.HasImage(S):
            lsh = m.Image(S)
            gen = iterate_TopTools_ListOfShape(lsh)
            return self._TopoDS2Shapes(gen, shape_type=st)
        else:
            return []

    @Attribute
    def face_map(self):
        """A list containing tuples that map a face, out of the shape from
        which this
        OffsetShell is built, to a list of images which were created by the
        offset operation and therefore are present in this OffsetShell.

        :rtype: list[tuple[parapy.geom.Face, list[parapy.geom.Face]]]
        """
        m = self.builder.OffsetFacesFromShapes()
        """:type: OCC.BRepAlgo.BRepAlgo_Image"""
        lst = []
        for face in self.built_from.faces:
            S = face.TopoDS_Shape
            if m.HasImage(S):
                lsh = m.Image(S)
                gen = iterate_TopTools_ListOfShape(lsh)
                images = self._TopoDS2Shapes(gen, shape_type=4)
                lst.append((face, images))
        return lst


    # def _build(self):
    #     built_from = self.built_from
    #     join_type = self.join_type
    #     S = built_from.TopoDS_Shape
    #     Offset = self.offset
    #     Tol = self.tolerance
    #     Mode = BRepOffset_Skin  # only option implemented
    #     Intersection = False  # True is not recommended
    #     SelfInter = False  # only option implemented
    #
    #     if join_type == "arc":
    #         Join = GeomAbs_Arc
    #     elif join_type == "intersection":
    #         Join = GeomAbs_Intersection
    #     else:
    #         msg = ("join_type should either be 'arc' or 'intersection'. "
    #                "Received: ``{:}``.")
    #         raise RuntimeError(msg.format(join_type))
    #
    #     args = (S, Offset, Tol, Mode, Intersection, SelfInter, Join)
    #     builder = BRepOffsetAPI_MakeOffsetShape(*args)
    #
    #     if not builder.IsDone():
    #         raise Exception("operation failed")
    #     else:
    #         return builder


class ThickSolid(OffsetBase, Solid_):
    """This hollowed solid is built from an initial solid and a set of faces on
    this solid, which are to be removed. The remaining faces of the solid
    become the walls of the hollowed solid, their offset defined at the
    time of construction.

    Usage:

    >>> from parapy.geom import ThickSolid, Box
    >>> solid = Box(1, 1, 1)
    >>> obj = ThickSolid(built_from=solid, closing_faces=[solid.top_face],
    ...                 offset=0.3)

    For more information, check `Open Cascade documentation
    <http://www.opencascade.com/doc/occt-6.9.0/refman/html/
    class_b_rep_offset_a_p_i___make_thick_solid.html>`__.
    """

    __initargs__ = ["built_from", "closing_faces", "offset"]

    #: Original solid to offset.
    #: :type: parapy.geom.occ.solid.Solid
    built_from = Input()

    #: Sequence of faces to remove.
    #: :type: collections.Sequence[parapy.geom.occ.face.Face]
    closing_faces = Input()

    def _build(self):
        """Build this ThickSolid and return the builder.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeThickSolid
        :raises RuntimeError: When :attr:`join_type` is not 'arc' or
            'intersection'.
        :raises Exception: when building the ThickShell has failed.
        """
        built_from = self.built_from
        join_type = self.join_type
        closing_faces = self.closing_faces
        closing_topods_faces = map(topods_shape_getter, closing_faces)

        S = built_from.TopoDS_Shape
        ClosingFaces = make_TopTools_ListOfShape(closing_topods_faces)
        Offset = self.offset
        Tol = self.tolerance
        Mode = BRepOffset_Skin  # only option implemented
        Intersection = False  # True is not recommended
        SelfInter = False  # only option implemented

        if join_type == "arc":
            Join = GeomAbs_Arc
        elif join_type == "intersection":
            Join = GeomAbs_Intersection
        else:
            msg = ("join_type should either be 'arc' or 'intersection'. "
                   "Received: ``{:}``.")
            raise RuntimeError(msg.format(join_type))

        args = (S, ClosingFaces, Offset, Tol, Mode, Intersection, SelfInter,
                Join)
        builder = BRepOffsetAPI_MakeThickSolid(*args)

        if not builder.IsDone():
            raise Exception("operation failed")
        else:
            return builder


class ThickShell(OffsetBase, Solid_):
    """Creates a solid from a given a shell :attr:`built_from`, which is
    offsetted. Positive :attr:`offset` results in
    thickening outwards, negative :attr:`offset` results in thickening inwards.

    .. warning:: this ParaPy primitive is experimental. It works best in cases
        where thickening is applied *outwards*, and has often been observed to
        fail on *inward* cases.

    Usage:

    >>> from parapy.geom import ThickShell, Box, SewnShell
    >>> box = Box(1, 1, 1)
    >>> shell = SewnShell([box.top_face, box.rear_face, box.bottom_face])
    >>> # Thickening is applied outwards
    >>> obj = ThickShell(built_from=shell, offset=0.3)
    >>> # Thickening is applied inwards
    >>> obj = ThickShell(built_from=shell, offset=-0.3)

    For more information, check `Open Cascade documentation
    <http://dev.opencascade.org/doc/refman/html/
    class_b_rep_offset___make_offset.html>`__.
    """

    __initargs__ = ["built_from", "offset"]

    #: Original shape to offset.
    #: :type: parapy.geom.occ.shell.Shell_
    built_from = Input()

    def _build(self):
        """Build this ThickShell and return the builder.

        :rtype: OCC.BRepOffset.BRepOffset_MakeOffset
        :raises RuntimeError: when building the ThickShell has failed.
        """
        built_from = self.built_from
        join_type = self.join_type

        S = built_from.TopoDS_Shape
        Offset = self.offset
        Tol = self.tolerance
        Mode = BRepOffset_Skin  # only option implemented
        Intersection = False  # True is not recommended
        SelfInter = False  # only option implemented
        Join = GeomAbs_Arc if join_type == "arc" else GeomAbs_Intersection
        Thickening = True
        builder = BRepOffset_MakeOffset()

        args = (S, Offset, Tol, Mode, Intersection,
                SelfInter, Join, Thickening)
        builder.Initialize(*args)
        builder.MakeOffsetShape()

        if builder.IsDone():
            return builder
        else:
            raise RuntimeError("Creating offset shell failed...")


# class ThickShell2(Solid):
#     __initargs__ = ["built_from", "offset"]
#
#     built_from = Input()
#     offset = Input()
#
#     @Attribute
#     def builder(self):
#         Mode = BRepOffset_Skin
#         Intersection = False
#
#         op = BRepOffsetAPI_MakeOffsetShape(self.built_from.TopoDS_Shape,
#                                            self.offset,
#                                            Precision__Confusion())
#         op.Build()
#         return op
#
#     @Attribute
#     def TopoDS_Shape(self):
#         return self.builder.Shape()
#
#     @Attribute
#     def modified_faces(self):
#         modified = self.history.modified
#         built_from_faces = self.built_from.faces
#         return [(modified(face) for face in built_from_faces]
#
#     @Attribute
#     def generated_edges_from_built_from(self):
#         return self.GeneratedEdge(self.built_from)
#
#     @Attribute
#     def generated_free_edges(self):
#         return [self.GeneratedEdge(e) for e in self.built_from.free_edges]
#
#     def Generated(self, S):
#         lst = TopTools_ListOfShape2list(
#                   self.builder.Generated(S.TopoDS_Shape))
#         return [Edge_(TopoDS_Shape=s) for s in lst]
#
#     def GeneratedEdge(self, S):
#         lst = TopTools_ListOfShape2list(
#             self.builder.GeneratedEdge(S.TopoDS_Shape))
#         return [Edge_(TopoDS_Shape=s) for s in lst]

if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom import Polygon, Plane

    wire1 = Polygon(((0, 0, 0), (1, 0 , 0), (1, 1 , 0), (0, 1, 0)))
    wire2 = OffsetWire(wire1, -0.1)

    plane1 = Plane()
    plane2 = OffsetPlane(plane1, 10)

    display((wire1, wire2, plane1, plane2))

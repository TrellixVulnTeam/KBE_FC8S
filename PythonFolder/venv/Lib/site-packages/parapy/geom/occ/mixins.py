#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Mixin for transformations"""

from OCC.wrapper.gp import gp_Trsf
from parapy.geom.generic.positioning import (AbstractPoint, Orientation,
                                             Axis, Position)


class TransformationMixin(object):
    """Mixin class to add transformations to objects which implement at
    least an :attr:`position`, :attr:`location` and :meth:`_transformed`.
    """

    def _transformed(self, trsf, **info):
        """trsf is gp_Trsf. Info is bashed into new object's _transformation
        slot.

        Form::
 
        {"operation" : "transformed" | "translated" ...,
         ...}
        """
        raise NotImplementedError("implement in subclass")

    def transformed(self, new_position, old_position=None):
        """Transform this shape from ``new_position`` (optionally relative to
        ``old_position``.

        :type new_position: parapy.geom.Position
        :type old_position: parapy.geom.Position
        :return: The transformed shape.
        """
        old_position = old_position or self.position
        trsf = gp_Trsf()
        trsf.SetDisplacement(old_position.gp_Ax3, new_position.gp_Ax3)
        return self._transformed(trsf,
                                 operation="transformed",
                                 from_position=old_position,
                                 to_position=new_position)

    def translated(self, *args, **kwargs):
        """same syntax as point/position.translate()

        :return: The translated shape.
        """
        p1 = self.position
        p2 = p1(*args, **kwargs)
        vec = p2-p1
        trsf = gp_Trsf()
        trsf.SetTranslation(vec.gp_Vec)
        return self._transformed(trsf, operation="translated", vector=vec)

    def rotated(self, rotation_axis, angle, reference_point=None):
        """

        :type rotation_axis: parapy.geom.Axis
        :type angle: float
        :type reference_point: parapy.geom.AbstractPoint
        :return: The rotated shape.
        """
        vector = self.position.ensure_vector(rotation_axis)
        reference_point = reference_point if not reference_point is None else \
            self.position.location
        axis = Axis(reference_point, vector)
        trsf = gp_Trsf()
        trsf.SetRotation(axis.gp_Ax1, angle)
        return self._transformed(trsf, operation="rotated",
                                 axis=axis,
                                 angle=angle)

    def scaled(self, factor, reference_point=None):
        """Scaling by a factor and reference_point (defaults to self.location).
        Non-uniform
        scaling is not supported yet. This requires gp_GTrsf() and
        BRepBuilderAPI_GTransform.

        :type factor: float
        :type reference_point: parapy.geom.AbstractPoint
        :return: The scaled shape.
        """
        trsf = gp_Trsf()
        if reference_point is None:
            reference_point = self.location
        trsf.SetScale(reference_point.gp_Pnt, factor)
        return self._transformed(trsf,
                                 operation="scaled",
                                 reference_point=reference_point,
                                 factor=factor)

    def mirrored(self, reference, dir1=None, dir2=None):
        """Create mirrored version of this :class:`parapy.geom.BRep`.

        Input patterns:

        * [:class:`parapy.geom.AbstractPoint`]: point symmetry
        * [:class:`parapy.geom.AbstractPoint`, :class:`parapy.geom.Vector` |
          str]: line symmetry
        * [:class:`parapy.geom.AbstractPoint`, :class:`parapy.geom.Vector`
          | str, :class:`parapy.geom.Vector` | str]: planar symmetry
        * [obj with 'position']: planar symmetry (e.g. a
          :class:`parapy.geom.Plane`)

        :return: The mirrored shape.
        """
        trsf = gp_Trsf()
        if isinstance(reference, AbstractPoint):
            if not dir1 is None:
                v1 = reference.ensure_vector(dir1)
                if not dir2 is None:
                    v2 = reference.ensure_vector(dir2)
                    pos = Position(reference, Orientation(v1, v2))
                    trsf.SetMirror(pos.gp_Ax2)
                else:
                    axis = Axis(reference, v1)
                    trsf.SetMirror(axis.gp_Ax1)
            else:
                trsf.SetMirror(reference.gp_Pnt)
        elif hasattr(reference, 'position'):
            trsf.SetMirror(reference.position.gp_Ax2)
        else:
            raise ValueError(repr(reference))
        return self._transformed(trsf, operation="mirrored",
                                 reference=reference,
                                 dir1=dir1,
                                 dir2=dir2)

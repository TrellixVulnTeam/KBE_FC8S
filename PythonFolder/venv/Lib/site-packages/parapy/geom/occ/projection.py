#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import warnings
from collections import OrderedDict
from math import sqrt

from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeWire
from OCC.wrapper.BRepOffsetAPI import BRepOffsetAPI_NormalProjection
from OCC.wrapper.BRepProj import BRepProj_Projection
from OCC.wrapper.GeomProjLib import GeomProjLib__Project, GeomProjLib__ProjectOnPlane
from OCC.wrapper.HLRAlgo import HLRAlgo_Projector
from OCC.wrapper.HLRBRep import (
    HLRBRep_Algo, HLRBRep_HLRToShape, HLRBRep_IsoLine, HLRBRep_OutLine,
    HLRBRep_Rg1Line, HLRBRep_RgNLine, HLRBRep_Sharp)
from OCC.wrapper.ShapeBuild import ShapeBuild_Edge
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_FACE
from OCC.wrapper.TopTools import TopTools_ListOfShape
from OCC.wrapper.gp import gp_Dir, gp_Pnt
from OCC.utils.top import sub_shapes
from OCC.utils.utilities import (
    TopTools_ListOfShapeGenerator_, make_TopoDS_Compound)

from parapy.core import Attribute, Input, derived, ensure_iterable
from parapy.core.utilities import apply_to_all, is_iterable
from parapy.core.validate import OneOf, Positive
from parapy.geom.generic.positioning import XOY, name_to_pos
from parapy.geom.occ.compound import Compound_
from parapy.geom.occ.edge import Edge_
from parapy.geom.occ.surface import InfiniteSurface, Plane, Surface
from parapy.geom.occ.utilities import (
    is_curve_aggregate, is_edge_like, is_face_aggregrate, topods_shape_getter)
from parapy.geom.occ.wire import Wire_
from parapy.globs import SUPPORT_EMAIL

__all__ = ("HLR", "ProjectedCurve", "ProjectedEdges")


# TODO (TBD): move to OCC.
def Handle_Geom_Curve_to_TopoDS_Wire(handle_geom_curve):
    b = BRepBuilderAPI_MakeEdge(handle_geom_curve)
    b = BRepBuilderAPI_MakeWire(b.Edge())
    return b.Wire()


# TODO (TBD): move to OCC.
def BRepProj_Projection_Wire_Generator(proj):
    """:type proj: BRepProj_Projection"""
    while proj.More():
        yield Wire_(TopoDS_Shape=proj.Current())
        proj.Next()


# Need BRepProj_Projection. If target is infinite surface, raise.
def project_conical(source, target, point):
    if isinstance(target, InfiniteSurface):
        msg = ("Conical projection on an infinite surface is not supported. "
               "Take a finite representation of your target shape. "
               "Source: {}, Target: {}.")
        raise RuntimeError(msg.format(source, target))
    else:
        wire = source.TopoDS_Shape
        shape = target.TopoDS_Shape
        point = gp_Pnt(*point)
        try:
            proj = BRepProj_Projection(wire, shape, point)
        except RuntimeError as e:
            if "infinite" in str(e).lower():
                msg = ("Conical projection onto shapes with infinite "
                       "surface(s) is not supported. Take a finite "
                       "representation of your target shape. Source: {}, "
                       "Target: {}.")
                raise RuntimeError(msg.format(source, target))
            else:
                raise
        except Exception:
            raise
        else:
            # FIXME (TBD): seems to *fail* when there is no result.
            if not proj.IsDone():
                msg = "Conical projection failed. Source: {}, Target: {}."
                raise RuntimeError(msg.format(source, target))
            else:
                gen = BRepProj_Projection_Wire_Generator(proj)
                return tuple(gen)


# generally use BRepProj_Projection, unless projection a single curve
# onto an infinite Plane.
# TODO: for multi-edge on Plane, project edges and compose Wire
def project_cylindrical(source, target, direction):
    dir_ = gp_Dir(*direction)

    if isinstance(target, Plane):
        if not is_curve_aggregate(source):
            Curve = source.Handle_Geom_Curve
            plane = target.Handle_Geom_Surface
            KeepParametrization = True
            handle_geom_curve = GeomProjLib__ProjectOnPlane(
                Curve, plane, dir_, KeepParametrization)
            topods_wire = Handle_Geom_Curve_to_TopoDS_Wire(handle_geom_curve)
            return Wire_(TopoDS_Shape=topods_wire),
        else:
            msg = ("Cylindrical projection of a wire onto a Plane is not "
                   "supported yet. Either project each individual edge onto "
                   "the Plane and compose the result, or take a finite "
                   "representation of Plane as target (consider using "
                   "RectangularTrimmedSurface). Source: {}, Target: {}.")
            raise NotImplementedError(msg.format(source, target))
    else:
        if isinstance(target, InfiniteSurface):
            msg = ("Cylindrical projection onto an infinite surface (other "
                   "than a Plane) is not supported. Take a finite "
                   "representation the target shape. Source: {}, Target: {}.")
            raise RuntimeError(msg.format(source, target))
        else:
            wire = source.TopoDS_Shape
            shape = target.TopoDS_Shape
            try:
                proj = BRepProj_Projection(wire, shape, dir_)
            except RuntimeError as e:
                if "infinite" in str(e).lower():
                    msg = ("Cylindrical projection onto shapes with infinite "
                           "surface(s) is not supported. Take a finite "
                           "representation of your target shape. Source: {}, "
                           "Target: {}.")
                    raise RuntimeError(msg.format(source, target))
                else:
                    raise
            except Exception:
                raise
            else:
                # FIXME (TBD): seems to *fail* when there is no result.
                if not proj.IsDone():
                    msg = ("Cylindrical projection failed. Source: {}, "
                           "Target: {}.")
                    raise RuntimeError(msg.format(source, target))
                else:
                    gen = BRepProj_Projection_Wire_Generator(proj)
                    return tuple(gen)


# try not to use BRepProj_Projection if not required (internally, it's using
# BRepAlgo_Section, thus deprecated and slow). Instead use GeomProjLib__Project
# We need to use BRepProj_Projection if source is a true wire
# (so Wire with single edge is an Edge) or if target is not a face or higher.
def project_normal(source, target, face_boundaries=True):
    # TODO (TBD): determine of geometric projection can be used regarless of
    # /todo face_boundaries?.
    if (not face_boundaries and
            not is_curve_aggregate(source) and
            isinstance(target, Surface)):
        C = source.Handle_Geom_Curve
        S = target.Handle_Geom_Surface
        handle_geom_curve = GeomProjLib__Project(C, S)
        if handle_geom_curve.IsNull():
            msg = ("Normal projection failed. Try again with "
                   "face_boundaries=True. Source: {}, target: {}.")
            warnings.warn(msg.format(source, target))
            wire = source.TopoDS_Shape
            shape = target.TopoDS_Shape
            proj = BRepProj_Projection(wire, shape)
            if not proj.IsDone():
                msg = "Cylindrical projection failed. Source: {}, Target: {}."
                raise RuntimeError(msg.format(source, target))
            else:
                gen = BRepProj_Projection_Wire_Generator(proj)
                return tuple(gen)
        else:
            topods_wire = Handle_Geom_Curve_to_TopoDS_Wire(handle_geom_curve)
            return [Wire_(TopoDS_Shape=topods_wire)]
    elif not is_face_aggregrate(target):
        S = target.TopoDS_Shape
        proj = BRepOffsetAPI_NormalProjection(S)
        ToProj = source.TopoDS_Shape
        proj.Add(ToProj)
        proj.SetLimit(face_boundaries)
        proj.Compute3d(True)
        proj.Build()
        if proj.IsDone():
            # TODO (TBD): what in case of disconnected wires?
            lst = TopTools_ListOfShape()
            proj.BuildWire(lst)
            topods_wires = TopTools_ListOfShapeGenerator_(lst)
            # topods_shape = proj.Projection()
            # topods_wires = sub_shapes(topods_shape)
            return tuple(Wire_(TopoDS_Shape=w) for w in topods_wires)
        else:
            msg = ("Normal project failed. Source: {}, target: {}.")
            raise RuntimeError(msg.format(source, target))
    else:
        msg = ("Can not perform a normal projection onto a multi-faced target."
               " Project onto individual faces and compose result. "
               "Source: {}, Target: {}.")
        raise NotImplementedError(msg.format(source, target))


class ProjectedCurve(Wire_):
    """Project a :attr:`source` Curve, Edge or Wire instance onto a
    :attr:`target` shape. For 'cylindrical' projection (the default value of
    :attr:`method`), specify a :attr:`direction` vector. For 'conical' or
    'normal' projections, leave the direction empty. Note that projection may
    lead to multiple results. Access the :attr:`wires` slot for a list of
    wires resulting from the projection. In case of multiple results, wire are
    returned in an arbitrary, unordered fashion, and the ProjectedCurve
    instance in itself behaves as the first wire in that list. Usage:

    >>> from parapy.geom import (Point, Vector, LineSegment,
    ...                          RectangularSurface, ProjectedCurve)
    >>> crv = LineSegment(Point(0, 0, 1), Point(1, 0, 1))
    >>> srf = RectangularSurface(3, 3)
    >>> obj = ProjectedCurve(source=crv,
    ...                      target=srf,
    ...                      direction=Vector(0, 1, -1))

    .. caution:: in case of 'normal' projection, best results are obtained
        if the source shape is not too far away from the target shapes. Large
        seperations may result in spurious results.
    """

    __initargs__ = ["source", "target", "direction"]

    #: a curve-like object, i.e. curve, edge or wire.
    #: :type: parapy.geom.occ.curve.Curve
    source = Input()

    #: can be a surface, face, shell, solid.
    #: :type: parapy.geom.occ.brep.BRep
    target = Input()

    #: One of the following methods: :py:`['cylindrical', 'conical', 'normal']`
    #: For :py:`'cylindrical'` projection, specify a :attr:`direction` value.
    #: For :py:`'conical'` projection, provide a value for
    #: :attr:`conical_reference_point`. Only in case of :py:`'normal'`
    #: projection, you don't need to provide anything else. Default is
    #: 'cylindrical'.
    #: :type: str
    method = Input('cylindrical', validator=OneOf(['cylindrical', 'normal',
                                                   'conical']))

    #: Direction for :py:`'cylindrical'` projection (see :attr:`method`)
    #: :type: parapy.geom.Vector
    direction = Input()

    #: Point for :py:`'conical'` projection (see :attr:`method`).
    #: :type: parapy.geom.Point
    conical_reference_point = Input()

    #: by default, in case of normal projections, result will be limited by
    #: face boundaries. If False, basis_surface of :attr:`target` is used,
    #: resulting in projections that aren't bounded by the edges of the face.
    #: :type: bool
    face_boundaries = Input(True)

    @Attribute
    def wires(self):
        """List of all wires founds.

        :rtype: list[Wire]
        """
        method = self.method
        source = self.source
        target = self.target
        face_boundaries = self.face_boundaries
        if method == "cylindrical":
            direction = self.direction
            wires = project_cylindrical(source, target, direction)
        elif method == "normal":
            wires = project_normal(source, target, face_boundaries)
        elif method == "conical":
            point = self.conical_reference_point
            wires = project_conical(source, target, point)
        else:
            msg = "method value of ``{:}`` is not valid.".format(method)
            raise RuntimeError(msg)
        return list(wires)

    @Attribute(private=True)
    def TopoDS_Shape(self):
        wires = self.wires
        if not wires:
            msg = ("Projection did not create any results. You may demand the "
                   "'wires' slot to verify empty list without an exception.")
            raise RuntimeError(msg)
        else:
            return wires[0].TopoDS_Shape

    # TODO (TBD): support the corner-case of a single-faced shell, etc.
    @Attribute
    def pcurves(self):
        wires = self.wires
        target = self.target
        if is_face_aggregrate(target):
            msg = ("target is not a face. Perhaps a shell or solid? In this "
                   "case, pcurves lie on many faces, demand them yourself.")
            raise RuntimeError(msg)
        if target.TOPOLEVEL != TopAbs_FACE:  # Face level, not shell
            target = target.faces[0]

        return [[edge.pcurve(target) for edge in wire.edges] for wire in wires]


class HLR(Compound_):
    """Project :attr:`shape_in` on :attr:`plane` while applying a  Hidden Line
    Removal step.

    The results will lie in the global XY-plane. Procedurally you can think of
    projecting the shapes on :attr:`plane`, and then transforming the
    resulting edges from the :attr:`plane` coordinate system to ``XOY``.

    Usage:

    >>> from parapy.geom import Box, Cylinder, HLR, XOY
    >>> # A Cylinder hovering over a Box, from ISO perspective
    >>> cyl = Cylinder(1, 1)
    >>> box = Box(1, 1, 1, position=XOY.translate(z=-2))
    >>> hlr = HLR(shape_in=(cyl, box), plane='iso')
    >>> # remove seam edge of the Cylinder
    >>> hlr_no_seam = HLR(shape_in=(cyl, box), plane='iso',
    ...                   include_seam_edges=False)
    >>> # no hiding
    >>> hlr_no_hide = HLR(shape_in=(cyl, box), plane='iso', hide=False)

    .. note:: Edges that would be reduced to a :class:`parapy.geom.Vertex`
        due to applied projection, will not appear in both the 2D and the
        3D results.

    .. caution:: The amount of visible edges in 2D might not match the amount
         of visible edges in 3D. For example, in 2D there might not be any
         :attr:`visible_outline_edges` but there might be visible edges in
         :attr:`visible_outline_edges3d`.

    .. note:: If you need a cheaper or faster HLR algorithm, there are
        possibilities in the form of an approximated algorithm. Please contact
        ParaPy support for more information.

    """

    __initargs__ = ["shape_in"]

    TOPODIM = 1

    #: One or more shapes to project on :attr:`plane`.
    #: :type: parapy.geom.BRep | collections.Iterable[parapy.geom.BRep]
    shape_in = Input()

    #: A :class:`~parapy.geom.Position`, :class:`~parapy.geom.Plane` or string.
    #: Defaults to top view ``XOY``.
    #: valid strings: 'top', 'left', 'front' or 'iso'
    #: :type: parapy.geom.Position | parapy.geom.Plane | str
    plane = Input(XOY)

    #: Number of iso-lines to draw on each face of the projected shape.
    #: :type: int
    n_isos = Input(0, validator=Positive(incl_zero=True))

    #: Add sharp edges to the result.
    #: Sharp edges present a C0 continuity (non G1).
    #: :type: bool
    include_sharp_edges = Input(True)

    #: Add smooth edges to the result.
    #: Smooth edges present a G1 continuity (non G2)
    #: :type: bool
    include_smooth_edges = Input(True)

    #: Add seam-edges to the result.
    #: :type: bool
    include_seam_edges = Input(True)

    #: Add the outline edges to the result.
    #: :type: bool
    include_outline = Input(True)

    #: Apply the hidden line removal step? If set to :py:`False`, edges
    #: will not be hidden by faces of the shapes of :attr:`shape_in`.
    #: :type: bool
    hide = Input(True)

    #: Include the iso-lines, created by :attr:`n_isos` in the result. By
    #: default, it is set to :py:`True` if :attr:`n_isos` > 0
    #: :type: bool
    include_iso_lines = Input(derived)

    @include_iso_lines.getter
    def include_iso_lines(self):
        return bool(self.n_isos)

    @Attribute
    def visible_edges3d(self):
        """The visible edges (contained in this shape), but positioned in 3D.

        :rtype: tuple[parapy.geom.occ.edge.Edge_]
        """
        return tuple(self._yield_aggregated_edges(True, True))

    @Attribute
    def hidden_edges(self):
        """The hidden edges.

        :rtype: tuple[parapy.geom.occ.edge.Edge_]
        """
        return tuple(self._yield_aggregated_edges(False, False))

    @Attribute
    def hidden_edges3d(self):
        """The hidden edges, but positioned in 3D.

        :rtype: tuple[parapy.geom.occ.edge.Edge_]
        """
        return tuple(self._yield_aggregated_edges(False, True))

    @Attribute(private=True)
    def TopoDS_Shape(self):
        edges = self._yield_aggregated_edges(True, False)
        return make_TopoDS_Compound(map(topods_shape_getter, edges))

    @Attribute(private=True)
    def builder(self):
        """The HLR projection builder.

        :rtype: OCC.HLRBRep.Handle_HLRBRep_Algo
        """
        builder = HLRBRep_Algo()
        # builder = HLRBRep_PolyAlgo()

        shape_in = self.shape_in
        num_isos = self.n_isos if self.include_iso_lines else 0
        if is_iterable(shape_in):
            # HLRBRep_Algo is currently broken. It will only show the results
            # of the last 'hidden' shape. (see 'Hide()') The current
            # workaround for this, is to put everything in a compound
            comp = make_TopoDS_Compound(map(topods_shape_getter, shape_in))
            builder.Add(comp, num_isos)
        else:
            builder.Add(shape_in.TopoDS_Shape, num_isos)

        # get projection ``plane``
        plane = self.plane
        if isinstance(plane, str):
            plane = name_to_pos(plane)
        elif isinstance(plane, Plane):
            plane = plane.position

        # set projector
        projector = HLRAlgo_Projector(plane.gp_Ax2)
        builder.Projector(projector)

        # perform hlr
        builder.Update()
        if self.hide:
            builder.Hide()

        return builder.handle

    @Attribute
    def _extractor(self):
        """Helper to extract the results from :attr:`builder`.

        :rtype: OCC.HLRBRep.HLRBRep_HLRToShape
        """
        # obj = HLRBRep_PolyHLRToShape()
        # obj.Update(self.builder.handle)
        # return obj
        return HLRBRep_HLRToShape(self.builder)

    # Edges, also the ones that do not pass the 'include' filters, per
    # category.
    # visible 2D
    @Attribute
    def visible_sharp_edges(self):
        return self._get_edges(HLRBRep_Sharp, True, False)

    @Attribute
    def visible_smooth_edges(self):
        return self._get_edges(HLRBRep_Rg1Line, True, False)

    @Attribute
    def visible_seam_edges(self):
        return self._get_edges(HLRBRep_RgNLine, True, False)

    @Attribute
    def visible_iso_edges(self):
        return self._get_edges(HLRBRep_IsoLine, True, False)

    @Attribute
    def visible_outline_edges(self):
        return self._get_edges(HLRBRep_OutLine, True, False)

    # visible 3D
    @Attribute
    def visible_sharp_edges3d(self):
        return self._get_edges(HLRBRep_Sharp, True, True)

    @Attribute
    def visible_smooth_edges3d(self):
        return self._get_edges(HLRBRep_Rg1Line, True, True)

    @Attribute
    def visible_seam_edges3d(self):
        return self._get_edges(HLRBRep_RgNLine, True, True)

    @Attribute
    def visible_iso_edges3d(self):
        return self._get_edges(HLRBRep_IsoLine, True, True)

    @Attribute
    def visible_outline_edges3d(self):
        return self._get_edges(HLRBRep_OutLine, True, True)

    # hidden 2D
    @Attribute
    def hidden_sharp_edges(self):
        return self._get_edges(HLRBRep_Sharp, False, False)

    @Attribute
    def hidden_smooth_edges(self):
        return self._get_edges(HLRBRep_Rg1Line, False, False)

    @Attribute
    def hidden_seam_edges(self):
        return self._get_edges(HLRBRep_RgNLine, False, False)

    @Attribute
    def hidden_iso_edges(self):
        return self._get_edges(HLRBRep_IsoLine, False, False)

    @Attribute
    def hidden_outline_edges(self):
        return self._get_edges(HLRBRep_OutLine, False, False)

    # hidden 3D
    @Attribute
    def hidden_sharp_edges3d(self):
        return self._get_edges(HLRBRep_Sharp, False, True)

    @Attribute
    def hidden_smooth_edges3d(self):
        return self._get_edges(HLRBRep_Rg1Line, False, True)

    @Attribute
    def hidden_seam_edges3d(self):
        return self._get_edges(HLRBRep_RgNLine, False, True)

    @Attribute
    def hidden_iso_edges3d(self):
        return self._get_edges(HLRBRep_IsoLine, False, True)

    @Attribute
    def hidden_outline_edges3d(self):
        return self._get_edges(HLRBRep_OutLine, False, True)

    @Attribute
    def _edge_builder(self):
        return ShapeBuild_Edge()

    def _get_topo_compound_of_edges(self, edge_type, visible, _3d):
        compound = self._extractor.CompoundOfEdges(edge_type, visible, _3d)
        if compound.IsNull():
            compound = make_TopoDS_Compound(())
        else:
            # Add 3D pcurve to edges, this is not done by the exact algorithm.
            edges_gen = sub_shapes(compound, TopAbs_EDGE, downcast=True)
            apply_to_all(self._edge_builder.BuildCurve3d, edges_gen)
        return compound

    def _get_edges(self, *args, **kwargs):
        """Get the ParaPy edges of given edge category, visibility,
        possibly positioned in 3D.

        :param int edge_type: OCC flag for the edge type (see OCC's
            ``HLRBRep_TypeOfResultingEdge`` enum)
        :param bool visible: The visible edgegs? Otherwise return the
            hidden edges.
        :param bool _3d: Get the 3D edges? Otherwise return the projection
            result.
        :rtype: tuple[parapy.geom.occ.edge.Edge_]
        """
        compound = self._get_topo_compound_of_edges(*args, **kwargs)
        topo_edges = sub_shapes(compound, TopAbs_EDGE)
        return tuple(map(lambda topo: Edge_(TopoDS_Shape=topo), topo_edges))

    _check_to_attr_base = {
        'include_sharp_edges': 'sharp_edges',
        'include_smooth_edges': 'smooth_edges',
        'include_seam_edges': 'seam_edges',
        'include_iso_lines': 'iso_edges',
        'include_outline': 'outline_edges',
    }

    def _yield_aggregated_edges(self, visible, _3d):
        """Get all the edges that were selected to be displayed by the
        class according the different ``include`` Inputs, like
        :attr:`include_seam_edges`.

        :param bool visible: Is the edge visible?
        :param bool _3d: Get the 3D positioned edge? If set to :py:`False`,
            one will get the edge on the 2D plane.
        :rtype: collections.Iterator[parapy.geom.occ.edge.Edge_]
        """
        prefix = 'visible_' if visible else 'hidden_'
        postfix = '3d' if _3d else ''

        for check_attr, attr_base in self._check_to_attr_base.items():
            if getattr(self, check_attr):
                category_edges = getattr(self, prefix + attr_base + postfix)
                for edge in category_edges:
                    yield edge


class ProjectedEdges(Compound_):
    """Projects the edges of one or multiple :attr:`source` shapes
    onto a :attr:`target` shape using **normal** projection.

    Usage:

    >>> from parapy.geom import Cylinder, Plane, ProjectedEdges, XOY
    >>> cyl = Cylinder(1, 1)
    >>> pln = Plane(reference=XOY)
    >>> proj = ProjectedEdges(source=cyl, target=pln)
    >>> # Cylinder's top and bottom edges result in (circular) edges in the
    >>> # projection
    >>> len(proj.edges)
    2
    >>> # decomposing the cylinder
    >>> btm_edge = cyl.bottom_face.edges[0]
    >>> top_edge = cyl.top_face.edges[0]
    >>> seam_edge = [edge for edge in cyl.edges if edge.is_seam][0]

    >>> # to associate source->projection, use .generated
    >>> proj.generated(btm_edge)[0] == proj.edges[1]
    True
    >>> proj.generated(top_edge)[0] == proj.edges[0]
    True
    
    >>> # to associate project->source, use .source_edges
    >>> proj.get_source_edge(proj.edges[1]).is_partner(btm_edge)
    True
    >>> proj.get_source_edge(proj.edges[0]).is_partner(top_edge)
    True

    >>> # the seam edges resulted in a Vertex in the end-result
    >>> proj.generated(seam_edge)  # doctest: +ELLIPSIS
    (<Vertex_ root.vertices[2] at 0x...>,)

    .. note:: if a :class:`~parapy.geom.Edge` from the :attr:`source` shape(s)
        becomes a point after projection, it appears in the result as a
        :class:`~parapy.geom.Vertex`. Typically, all such vertices end up in a
        dedicated sub-compound accessible as follows:

        >>> proj.direct_children  # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        [<Edge_ root.edges[0] at 0x...>,
         <Edge_ root.edges[1] at 0x...>,
         <Compound_ root.compounds[1] at 0x...>]
        >>> proj.direct_children[-1].direct_children  # doctest: +ELLIPSIS
        [<Vertex_ root.compounds[1].vertices[0] at 0x...>]
    """

    #: One or multiple shapes that are, or contain edges.
    #: :type: parapy.geom.occ.brep.BRep | collections.Iterable[parapy.geom.occ.brep.BRep]
    source = Input()

    #: Shape on which :attr:`source` will be projected.
    #: :type: parapy.geom.occ.brep.BRep
    target = Input()

    #: If set to :py:`True`, the result will be limited by
    #: face boundaries. If False, basis_surface of :attr:`target` is used,
    #: resulting in projections that aren't bound by the edges of the face.
    #: :type: bool
    face_boundaries = Input(True)

    #: Maximum distance between :attr:`target` shape and the shape to project.
    #: If the shape to project is further away, it will be discarded.
    #: For ``max_distance < 0`` or None this setting will be ignored.
    #: :type: float | None
    max_distance = Input(None)

    #: Constraint on the continuity of the projected curves.
    #:
    #: - 0 -> C0: only geometric continuity.
    #: - 1 -> G1: for each point on the curve, the tangent vectors
    #:     "on the right" and "on the left" are collinear with the same
    #:     orientation.
    #: - 2 -> C1: continuity of the first derivative. The "C1" curve is also
    #:     "G1" but, in addition, the tangent vectors " on the right" and
    #:     "on the left" are equal.
    #: - 3 -> G2: for each point on the curve, the normalized normal vectors
    #:     "on the right" and "on the left" are equal.
    #: - 4 -> C2: continuity of the second derivative.
    #: - 5 -> C3: continuity of the third derivative. 
    #: - 6 -> CN: continuity of the N-th derivative, whatever is the value
    #:     given for N (infinite order of continuity).
    #: :type: int | None
    continuity = Input(4)

    #: The required tolerance between the projected curve and its 3D
    #: representation
    #: :type: float
    tolerance3d = Input(1e-4)

    #: :type: float | None
    tolerance2d = Input(derived)

    #: Maximum degree that of a BSpline approximating the projection result.
    #: :type: int
    max_degree = Input(14)

    #: Maximum amount of segments that might be used for a BSpline
    #: approximating the projection result.
    #: :type: int
    max_segments = Input(16)

    @tolerance2d.getter
    def tolerance2d(self):
        return sqrt(self.tolerance3d)

    @Attribute
    def edge_to_source_shape(self):
        """Map of the edges that are projected to the shape in
        :attr:`source` of which they are deduced, or are a subshape of.

        :rtype: collections.OrderedDict[parapy.geom.occ.edge.Edge_, parapy.geom.occ.brep.BRep]
        """
        # we need to extract the edges, otherwise it will extract edges
        # AND wires from the shapes going in, resulting in
        # duplicate edges in the result.
        sources = ensure_iterable(self.source)
        extract_edges = self.extract_edges

        def yield_edge_to_source():
            for source in sources:
                for edge in extract_edges(source):
                    yield edge, source

        return OrderedDict(yield_edge_to_source())

    @Attribute
    def builder(self):
        """The projection builder object.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_NormalProjection
        :raise RuntimeError: If the projection failed.
        """
        target_shape = self.target.TopoDS_Shape
        proj = BRepOffsetAPI_NormalProjection(target_shape)

        add_edge = proj.Add
        for edge in self.edge_to_source_shape:
            add_edge(edge.TopoDS_Shape)

        proj.SetParams(self.tolerance3d, self.tolerance2d, self.continuity,
                       self.max_degree, self.max_segments)
        proj.SetLimit(self.face_boundaries)
        proj.Compute3d(True)

        if self.max_distance is not None:
            proj.SetMaxDistance(self.max_distance)

        proj.Build()
        if proj.IsDone():
            return proj
        else:
            msg = ("Normal projection failed. "
                   "Source: {}, target: {}. Object: {}")
            raise RuntimeError(msg.format(self.source, self.target, self))

    @staticmethod
    def extract_edges(shape, warn=True):
        """Return the edges that are, or are contained in ``shape``.

        :param parapy.geom.occ.brep.BRep | parapy.geom.Curve shape: a shape
            that is an Edge, or has edges.
        :param bool warn: If set to :py:`True`, will warn if ``shape`` is not
            an :class:`~parapy.geom.occ.edge.Edge_`, :class:`parapy.geom.Curve`
            or does not have an ``edges`` slot. Otherwise it will silently
            just return an empty list.
        :rtype: tuple[parapy.geom.occ.edge.Edge_]
        """
        try:
            return shape.edges
        except AttributeError:
            if is_edge_like(shape):
                return shape,
            else:
                if warn:
                    msg = ("Could not extract edges from {}. It does not have "
                           "edges, and it is no Edge itself. Are you sure it "
                           "is a BRep or a Curve?")
                    warnings.warn(msg.format(shape))
                return ()

    def get_source_edge(self, edge):
        """Return the :class:`~parapy.geom.Edge` of one of the 'source' shapes
        who's projection resulted in ``edge``, or None if ``edge`` is not
        a result of this projection.

        Usage:

        >>> from parapy.geom import Cylinder, Plane, ProjectedEdges, XOY
        >>> cyl = Cylinder(1, 1)
        >>> target = Plane(reference=XOY)
        >>> proj = ProjectedEdges(source=cyl, target=target)
        >>> projected_edge = proj.edges[0]
        >>> source_edge = proj.get_source_edge(projected_edge)
        >>> source_edge.parent == cyl
        True

        .. note:: Note that this edge might be a subshape of one of the
            shapes in :attr:`sources`. If you want to relate it back to the
            source shape, on can use the mapping of
            :attr:`edge_to_source_shape`.

        :param parapy.geom.occ.edge.Edge_ edge: Edge resulting from
            projection.
        :rtype: parapy.geom.occ.edge.Edge_ | None
        """
        edge_topo = edge.TopoDS_Edge
        get_ancestor = self.builder.Ancestor
        try:
            source_edge = get_ancestor(edge_topo)
        except RuntimeError:
            return None  # not found

        matching_edges = [obj for obj in self.edge_to_source_shape
                          if obj.TopoDS_Edge == source_edge]
        num_matches = len(matching_edges)
        if num_matches == 1:
            return matching_edges[0]
        elif not num_matches:  # no match
            return None
        else:  # more than 1 match
            msg = ("More than one matching source edge found ({} matches) "
                   "for edge {!r}, this should never happen. Please contact "
                   "{}. Object: {!r}")
            raise RuntimeError(msg.format(num_matches, edge, SUPPORT_EMAIL,
                                          self))

    def get_coupled_face(self, edge):
        """Gets the :class:`~parapy.geom.occ.face.Face_` of :attr:`target` on
        which ``edge`` was projected, or :py:`None` if ``edge`` is no
        result of the projection.

        Usage:

        >>> from parapy.geom import (Box, Cylinder, ProjectedEdges, translate,
        ...                          XOY)
        >>> cyl = Cylinder(1, 1, position=translate(XOY, x=3))
        >>> target = Box(2, 2, 2, centered=True)
        >>> proj = ProjectedEdges(source=cyl, target=target)
        >>> projected_edge = proj.edges[0]
        >>> face = proj.get_coupled_face(projected_edge)
        >>> face == target.left_face
        True

        :param parapy.geom.occ.edge.Edge_ edge: edge from the projection
            result.
        :rtype: None | parapy.geom.occ.face.Face_
        """
        edge_topo = edge.TopoDS_Edge
        get_coupled_face = self.builder.Couple
        try:
            coupled_face = get_coupled_face(edge_topo)
        except RuntimeError:
            return None
        else:
            topods2shape = self.target._TopoDS2Shape
            try:
                return topods2shape(coupled_face)
            except KeyError:
                # no face in the ``target`` found
                msg = ("Could not link the found coupled face to a face "
                       "on the projection target. This should not happen, "
                       "please contact {}. Object: {}.")
                raise RuntimeError(msg.format(SUPPORT_EMAIL, self))


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom import Point, Vector, LineSegment, RectangularSurface

    pt1, pt2 = Point(0, 0, 1), Point(1, 0, 1)
    curv = LineSegment(pt1, pt2)
    surf = Plane()

    # normal projection
    proj1 = ProjectedCurve(curv, surf, method="normal")
    display(proj1)

    # cylindrical projection (default)
    v = Vector(0, 0, 1)
    proj2 = ProjectedCurve(curv, surf, v)

    # conical projection
    ref = Point(0, 0, -10)
    surf = RectangularSurface(20, 20)
    proj3 = ProjectedCurve(curv, surf, method="conical",
                           conical_reference_point=ref)

    print(proj1.length, proj2.length, proj3.length)

    display([proj1, proj2, proj3])


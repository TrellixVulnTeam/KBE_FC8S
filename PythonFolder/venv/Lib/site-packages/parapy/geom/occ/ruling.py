#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Ruling is the act of sweeping a surface/shell between two opposing
edges/wires."""

import warnings

from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeEdge, BRepBuilderAPI_MakeFace,
    BRepBuilderAPI_MakeWire, BRepBuilderAPI_Sewing)
from OCC.wrapper.BRepFill import BRepFill_Generator, BRepFill__Shell
from OCC.wrapper.GeomFill import GeomFill__Surface
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_SHELL, TopAbs_VERTEX
from OCC.wrapper.TopExp import TopExp__FirstVertex, TopExp__LastVertex
from OCC.utils.top import downcast_shape

from parapy.core import Attribute, Input, pairwise
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.occ.face import Face_
from parapy.geom.occ.lofting import LoftedSolid
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.utilities import sub_shapes

__all__ = ["RuledSurface", "RuledShell", "RuledSolid"]


TOLDEGEN = 1.0e-7


# TODO RvD: move to C++
def ruled_planar_face_builder(lat1, lat2):
    """Create a planar TopoDS_Face between two opposite TopoDS_Edge ``lat1``
     and ``lat2``, viz. face lies on a Geom_Plane-type basis_surface.

    :param OCC.TopoDS.TopoDS_Edge lat1: first edge.
    :param OCC.TopoDS.TopoDS_Edge lat2: second edge.
    :rtype: OCC.TopoDS.TopoDS_Face

    Usage:

    >>> from OCC.wrapper.gp import gp_Pnt
    >>> from OCC.wrapper.BRepBuilderAPI import (BRepBuilderAPI_MakeVertex,
    ...                                 BRepBuilderAPI_MakeEdge)
    >>> pt11 = gp_Pnt(0, 0, 0)
    >>> pt12 = gp_Pnt(1, 0, 0)
    >>> pt21 = gp_Pnt(0, 1, 0)
    >>> pt22 = gp_Pnt(1, 1, 0)
    >>> v11 = BRepBuilderAPI_MakeVertex(pt11).Vertex()
    >>> v12 = BRepBuilderAPI_MakeVertex(pt12).Vertex()
    >>> v21 = BRepBuilderAPI_MakeVertex(pt21).Vertex()
    >>> v22 = BRepBuilderAPI_MakeVertex(pt22).Vertex()
    >>> lat1 = BRepBuilderAPI_MakeEdge(v11, v12).Edge()
    >>> lat2 = BRepBuilderAPI_MakeEdge(v21, v22).Edge()
    >>> ruled_planar_face_builder(lat1, lat2)  # doctest: +ELLIPSIS
    <OCC.TopoDS.TopoDS_Face; proxy of <Swig Object of type 'TopoDS_Face *' at 0x...> >
    """
    #   v21 lat2 v22   -->
    #     +------+
    #     |      |
    # lon1|      |lon2
    #     |      |
    #     +------+
    #   v11 lat1 v12   -->

    v11, v12 = TopExp__FirstVertex(lat1), TopExp__LastVertex(lat1)
    v21, v22 = TopExp__FirstVertex(lat2), TopExp__LastVertex(lat2)

    # reverse vertices and edge
    v12_ = downcast_shape(v12.Reversed(), shape_type=TopAbs_VERTEX)
    v11_ = downcast_shape(v11.Reversed(), shape_type=TopAbs_VERTEX)
    lat2_ = downcast_shape(lat2.Reversed(), shape_type=TopAbs_EDGE)

    lon2 = BRepBuilderAPI_MakeEdge(v12_, v22).Edge()
    lon1 = BRepBuilderAPI_MakeEdge(v21, v11_).Edge()
    MW = BRepBuilderAPI_MakeWire(lat1, lon2, lat2_, lon1)
    if MW.IsDone():
        topods_wire = MW.Wire()
        MF = BRepBuilderAPI_MakeFace(topods_wire, True)  # OnlyPlane=True
        if MF.IsDone():
            return MF.Face()
        else:
            raise RuntimeError("failed to create (planar) face from wire.")
    else:
        raise RuntimeError("failed to create wire from edges.")


# TODO RvD: move to C++
def ruled_planar_shell_builder(wires):
    """Return TopoDS_Shell which is ruled between multiple TopoDS_Wire
    instances ``wires``. All faces will be truly planar, viz. trimmed portions
    on a Geom_Plane-type basis_surface.

    .. note:: it is asserted that :py:`len(wires) > 1`, otherwise might return
        a ``NULL`` shape.

    :type wires: collections.Iterable[OCC.TopoDS.TopoDS_Wire]
    :rtype: OCC.TopoDS.TopoDS_Shell
    """
    #       lat2
    #     +------+
    #     |      |
    # lon1|      |lon2
    #     |      |
    #     +------+
    #       lat1
    SW = BRepBuilderAPI_Sewing(1.0e-6, True, True, False, False)
    for wire1, wire2 in pairwise(wires):
        #: :type: OCC.TopoDS.TopoDS_Edge
        edges1 = sub_shapes(wire1, downcast=True)
        #: :type: OCC.TopoDS.TopoDS_Edge
        edges2 = sub_shapes(wire2, downcast=True)
        for edge1, edge2 in zip(edges1, edges2):
            face = ruled_planar_face_builder(edge1, edge2)
            SW.Add(face)
    SW.Perform()
    topods_shape = SW.SewedShape()

    return downcast_shape(topods_shape, shape_type=TopAbs_SHELL)


# TODO (TBD): not used, remove?
def ruled_planar_shell_builder2(wires):
    """
    :type wires: collections.Iterable[OCC.TopoDS.TopoDS_Wire]
    :rtype: OCC.TopoDS.TopoDS_Shell
    """
    #       lat2
    #     +------+
    #     |      |
    # lon1|      |lon2
    #     |      |
    #     +------+
    #       lat1
    warnings.warn("ruled_planar_shell_builder2 is deprecated, "
                  "use ruled_planar_shell_builder instead.",
                  ParaPyDeprecationWarning, stacklevel=2)
    SW = BRepBuilderAPI_Sewing(1.0e-6, True, True, False, False)
    lat2_ = None
    for wire1, wire2 in pairwise(wires):
        edges1 = sub_shapes(wire1, downcast=True)
        edges2 = sub_shapes(wire2, downcast=True)
        lon2_ = None
        for edge1, edge2 in zip(edges1, edges2):
            v11, v12 = sub_shapes(edge1, downcast=True)
            v21, v22 = sub_shapes(edge2, downcast=True)
            lat1 = BRepBuilderAPI_MakeEdge(v12, v22).Edge()
            if lat2_ is None:
                lat2_ = BRepBuilderAPI_MakeEdge(v21, v11).Edge()
            MW = BRepBuilderAPI_MakeWire(edge1, lat1, edge2, lat2_)
            if MW.IsDone():
                topods_wire = MW.Wire()
                MF = BRepBuilderAPI_MakeFace(topods_wire,
                                             True)  # OnlyPlane=True
                if MF.IsDone():
                    topods_face = MF.Face()
                    SW.Add(topods_face)
                else:
                    msg = "failed to create (planar) face from wire."
                    raise RuntimeError(msg)
            else:
                raise RuntimeError("failed to create wire from edges.")
            lat2_ = lat1

    SW.Perform()
    topods_shape = SW.SewedShape()
    return downcast_shape(topods_shape, TopAbs_SHELL)


class RuledSurface(Face_):
    """Create a ruled surface from two curves, :attr:`curve1` and
    :attr:`curve2`.

    Usage:

    >>> from parapy.geom import RuledSurface, Circle, translate
    >>> crv1 = Circle(1)
    >>> crv2 = Circle(2, position=translate(crv1.position, 'z', 2))
    >>> surf = RuledSurface(curve1=crv1, curve2=crv2)

    If the opposing curves lie in the same plane, consider using
    :attr:`only_plane` is True for a simpler (underlying) geometry.

    .. caution:: only works with bounded curves.
    """

    __initargs__ = ["curve1", "curve2"]

    #: First curve.
    #: :type: parapy.geom.Curve
    curve1 = Input()

    #: second curve.
    #: :type: parapy.geom.Curve
    curve2 = Input()

    #: If curve1 and curve2 are in the same plane, you can put this to True.
    #: Resulting shape will then be a trimmed portion of a simpler plane,
    #: instead of a more complex BSplineSurface.
    #: :type: bool
    only_plane = Input(False)

    @Attribute(private=True)
    def TopoDS_Face(self):
        """:rtype: OCC.TopoDS.TopoDS_Face"""
        curve1 = self.curve1
        curve2 = self.curve2
        if self.only_plane:
            return ruled_planar_face_builder(curve1.TopoDS_Edge,
                                             curve2.TopoDS_Edge)
        else:
            h_surf = GeomFill__Surface(curve1.Handle_Geom_Curve,
                                      curve2.Handle_Geom_Curve)
            face_builder = BRepBuilderAPI_MakeFace(h_surf, TOLDEGEN)
            if face_builder.IsDone():
                return face_builder.Face()
            else:
                raise RuntimeError("Building face failed.")

            # TODO: this operation seems tempting, but gives bad tolerances...
            # topods_edge1 = self.curve1.TopoDS_Edge
            # topods_edge2 = self.curve2.TopoDS_Edge
            # return BRepFill_Face(topods_edge1, topods_edge2)

    TopoDS_Shape = TopoDS_Face


# TODO: add generated method for BRepFill_Generator
class RuledShell(Shell_):
    """Create a ruled shell from two or more profiles that are curves or
    wires. For two profiles, use :attr:`profile1` and :attr:`profile2`. For
    more than two profiles, provide a list of curves/wires to
    :attr:`profiles`. Consecutive faces of the resulting shell will be ruled
    surfaces passing by the curves/wires. Note that wires must have the same
    number of edges. See: http://www.opencascade.com/doc/occt-6.9.1/refman/
    html/class_b_rep_fill___generator.html.

    Usage:

    >>> from parapy.geom import RuledShell, Circle, translate
    >>> crv1 = Circle(1)
    >>> crv2 = Circle(2, position=translate(crv1.position, 'z', 2))
    >>> shell = RuledShell(profile1=crv1, profile2=crv2)

    If edges of consecutive wires lie in the same plane, consider setting
    :attr:`only_plane` to True for a simpler (underlying) geometry.
    """

    __initargs__ = ["profile1", "profile2"]

    #: First curve/wire. Either this in combination with :attr:`profile2` or
    #: :attr:`profiles`.
    #: :type: parapy.geom.Curve | parapy.geom.Wire
    profile1 = Input()

    #: Second curve/wire. Either this in combination with :attr:`profile1` or
    #: :attr:`profiles`.
    #: :type: parapy.geom.Curve | parapy.geom.Wire
    profile2 = Input()

    #: Sequence of curves/wires. Either this or combination of
    #: :attr:`profile1` and :attr:`profile2`.
    #: :type: collections.Sequence[parapy.geom.Curve | parapy.geom.Wire]
    profiles = Input(None)

    #: If consecutive wire edges are in the same plane, you can put this to
    #: True. Resulting shape will then be a shell of trimmed portions of a
    #: plane, instead of more complex shell of BSplineSurfaces.
    #: :type: bool
    only_plane = Input(False)

    @Attribute
    def _topods_wires(self):
        """Wires of the profiles which make this :class:`RuledShell`.

        :rtype: list[OCC.TopoDS.TopoDS_Wire]
        """
        profiles = self.profiles
        if profiles is None:
            return [self.profile1.TopoDS_Wire,
                    self.profile2.TopoDS_Wire]
        else:
            if len(profiles) < 2:
                raise RuntimeError("you have to provide at least 2 profiles.")
            return [p.TopoDS_Wire for p in profiles]

    @Attribute(private=True)
    def TopoDS_Shell(self):
        """The underlying shape of this :class:`RuledShell`.

        :rtype: OCC.TopoDS.TopoDS_Shell
        """
        topods_wires = self._topods_wires
        if self.only_plane:
            return ruled_planar_shell_builder(topods_wires)
        else:
            if len(topods_wires) == 2:
                return BRepFill__Shell(*topods_wires)
            else:
                fill = BRepFill_Generator()
                for topods_wire in topods_wires:
                    fill.AddWire(topods_wire)
                fill.Perform()
                return fill.Shell()

    TopoDS_Shape = TopoDS_Shell


class RuledSolid(LoftedSolid):
    """Given two planar curves, creates a lofted solid between them.
    If you want more intermediate cross-sectional guides use LoftedSolid
    If you need guiding rails, use MultiSectionSolid.

    Usage:

    >>> from parapy.geom import RuledSolid, Circle, translate
    >>> crv1 = Circle(1)
    >>> crv2 = Circle(2, position=translate(crv1.position, 'z', 2))
    >>> solid = RuledSolid(profile1=crv1, profile2=crv2)
    """

    __initargs__ = ["profile1", "profile2"]

    #: First **planar** curve/wire. Either this in combination with
    #: :attr:`profile2` or :attr:`profiles`.
    #: :type: parapy.geom.Curve | parapy.geom.Wire
    profile1 = Input()

    #: Second **planar** curve/wire. Either this in combination with
    #: :attr:`profile1` or :attr:`profiles`.
    #: :type: parapy.geom.Curve | parapy.geom.Wire
    profile2 = Input()

    #: Sequence of curves/wires. First and last profiles **must** be planar.
    #: Either this or combination of :attr:`profile1` and :attr:`profile2`.
    #: :type: collections.Sequence[parapy.geom.Curve | parapy.geom.Wire]
    profiles = Input(None)

    #: If consecutive wire edges are in the same plane, you can put this to
    #: True. Resulting shape will then be a solid of trimmed portions of a
    #: plane, instead of more complex shell of BSplineSurfaces.
    #: :type: bool
    only_plane = Input(False)

    @profiles.getter
    def profiles(self):
        """Default when no :attr:`profiles` is set: :attr:`profile1` and
        :attr:`profile2`.

        :rtype: list[parapy.geom.Curve | parapy.geom.Wire]
        """
        return [self.profile1, self.profile2]

    @Attribute
    def ruled(self):
        """Is this Solid Ruled?

        :rtype: bool
        """
        return True

    @Attribute
    def max_degree(self):
        """The maximum degree of this :class:`RuledSolid`.

        :rtype: int
        """
        return 1


if __name__ == '__main__':
    from parapy.gui import display
    from parapy.geom.occ.wire import Pentagon

    w1 = Pentagon(radius=1)
    w2 = Pentagon(radius=2, position=w1.position.translate(z=1))
    w3 = Pentagon(radius=1, position=w2.position.translate(z=1))
    obj1 = RuledSurface(curve1=w1.edges[0], curve2=w2.edges[0])
    obj2 = RuledShell(profile1=w1, profile2=w2)
    obj3 = RuledShell(profiles=[w1, w2, w3])
    obj4 = RuledSolid(profiles=[w1, w2, w3])
    display((obj1, obj2, obj3, obj4))

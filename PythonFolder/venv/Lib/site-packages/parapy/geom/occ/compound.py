#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
from itertools import repeat

from OCC.utils.enums import HIGHLIGHT_MODE, MARKER_TYPE
from OCC.utils.tcol import (
    make_Quantity_HArray1OfColor,
    make_TColgp_HArray1OfDir, make_TColgp_HArray1OfPnt)
from OCC.utils.top import compound_sub_shapes
from OCC.utils.utilities import rgb_QuantityColor
from OCC.wrapper.GProp import GProp_PGProps
from OCC.wrapper.gp import gp_Dir

from parapy.core import Attribute, Input
from parapy.core.part import PrivatePartNoParsing
from parapy.core.utilities import get_rgb_value, is_color
from parapy.core.validate import OneOf
from parapy.core.widgets import Dropdown
from parapy.geom import Position, Vector, XY
from parapy.geom.generic.positioning import Point
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.utilities import (
    iflatten_color, iflatten_vector, make_TopoDS_Compound, topods_shape_getter)
from parapy.geom.occ.vertex import Vertex


def pointiterator(point):
    """Iterate over a (nested) iterable of :class:`parapy.geom.Point`
    instances. When ``point`` is a single :class:`parapy.geom.Point`,
    it will generate
    the point itself.

    :param parapy.geom.Point | collections.Iterable[parapy.geom.Point] point:
        single point or iterable containing :class:`parapy.geom.Point` objects.
    :rtype: collections.Iterator[parapy.geom.Point]
    """
    if hasattr(point, "gp_Pnt"):
        yield point
    elif hasattr(point, "__iter__"):
        for sub in point:
            for subpoint in pointiterator(sub):
                yield subpoint


class Shape(BRep):

    @PrivatePartNoParsing
    def vertices(self):
        """This shape its vertices.

        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return list(self._sub_shape_generator("vertex"))

    @PrivatePartNoParsing
    def edges(self):
        """This shape its edges.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        return list(self._sub_shape_generator("edge"))

    @PrivatePartNoParsing
    def wires(self):
        """This shape its wires

        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        return list(self._sub_shape_generator("wire"))

    @PrivatePartNoParsing
    def faces(self):
        """his shape its faces.

        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return list(self._sub_shape_generator("face"))

    @PrivatePartNoParsing
    def shells(self):
        """This shape its shells.

        :rtype: list[parapy.geom.occ.shell.Shell_]
        """
        return list(self._sub_shape_generator("shell"))

    @PrivatePartNoParsing
    def solids(self):
        """This shape its solids (the solid itself)

        :rtype: list[parapy.geom.occ.solid.Solid_]
        """
        return list(self._sub_shape_generator("solid"))

    @PrivatePartNoParsing
    def compsolids(self):
        """This shape its solids (the solid itself)

        :rtype: list[parapy.geom.BRep]

        .. Note:: should not return anything, not yet used.
        """
        # TODO (TBD): Do something with compsolids?. Author: FT.
        return list(self._sub_shape_generator("compsolid"))

    @PrivatePartNoParsing
    def compounds(self):
        """This shape its solids (the solid itself)

        :rtype: list[parapy.geom.occ.compound.Compound_]
        """
        return list(self._sub_shape_generator("compound"))


class Compound_(Shape):
    """Abstract base class for compounds of topological shapes."""
    
    __icon__ = os.path.join(ICN_DIR, 'compound.png')

    # 7: Vertex, 6: Edge, 5: Wire, 4: Face,
    # 3: Shell, 2: Solid, 1: CompSolid, 0: Compound
    TOPOLEVEL = 0

    @property
    def TOPODIM(self):
        """Should not be directly called on :class:`Compound_`, use sub shapes
        instead.

        :raises RuntimeError:
        """
        msg = ("A Compound can have any TOPODIM, work with its sub shapes "
               "instead. Object: {}.")
        raise RuntimeError(msg.format(self))

    @Attribute
    def direct_children(self):
        """The direct children of this compound. This slot does **not** filter
        outer duplicate shapes. It is the job of the user to assure
        compounds with unique content.

        :rtype: list[parapy.geom.BRep]
        """
        f = self._TopoDS2Shape
        return [f(shape) for shape in compound_sub_shapes(self.TopoDS_Shape)]


# TODO (RvD): get rid of this monkey-patching.
BRep.CompoundClass = Compound_


class Compound(Compound_):
    """Make a compound from a list of shapes, :attr:`built_from`. Usage:

    >>> from parapy.geom import Compound, Box, Cylinder
    >>> box = Box(1, 1, 1)
    >>> cyl = Cylinder(0.5, 2)
    >>> obj = Compound(built_from=[box, cyl])

    .. note:: See :class:`~parapy.geom.occ.boolean.AbstractBooleanBase` for
        extra (optional) inputs.
    """

    __initargs__ = ["built_from"]

    #: A flat list of shapes.
    #: :type: collections.Iterable[parapy.geom.BRep]
    built_from = Input()

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return make_TopoDS_Compound(map(topods_shape_getter, self.built_from))

    @Attribute
    def direct_children(self):
        """The direct children of this compound. Equal to :attr:`built_from`.
        This slot does **not** filter outer duplicate shapes. It is the job of
        the user to assure compounds with unique content.

        :rtype: list[parapy.geom.BRep]
        """
        return self.built_from


class PointCloud(Compound):
    # FIXME: display settings (like color) not working yet.
    # FIXME: don't inherit from Compound
    """Visualize a group of points effectively as one. They can share the
    same color, etc.

    Usage:

    >>> from parapy.geom import Point, PointCloud
    >>> grid = Point.grid(range(-10, 11), range(-10, 11), range(-10, 11))
    >>> obj = PointCloud(grid)
    """

    __icon__ = os.path.join(ICN_DIR, "points.png")
    __initargs__ = ["points"]

    #: :type: collections.Iterable[parapy.geom.AbstractPoint]
    points = Input(())

    #: Colors of the points. If set to None, :attr:`default_color` will be
    #: used.
    #: :type: str | collections.Sequence[int, int, int] | collections.Sequence[collections.Sequence[int, int, int] | str] | None
    colors = Input(None)

    #: Direction vectors of the points. If Set to None, a default direction
    #: will be used.
    #: :type: collections.Iterable[occ.geom.Vector] | None | occ.geom.Vector
    directions = Input(None)

    #: Size/scale of a point in the cloud.
    #: :type: float
    point_scale = Input(5.0)

    #: Way how the points are presented. See MARKER_TYPE for the possibilities.
    #: :type: str
    marker_type = Input('point',
                        widget=Dropdown(list(MARKER_TYPE.keys())),
                        validator=OneOf(MARKER_TYPE))

    #: Control the way this object is highlighted. ('bbox', 'shape' or None)
    #: :type: str | None
    highlight_mode = Input('bbox',
                           widget=Dropdown(list(HIGHLIGHT_MODE.keys())),
                           validator=OneOf(HIGHLIGHT_MODE))

    @Attribute
    def built_from(self):
        """Vertices out of which this PointCloud is built.

        :rtype: tuple[parapy.geom.Vertex]
        """
        return tuple(map(Vertex, pointiterator(self.points)))

    @Attribute(private=True)
    def _pts(self):
        """OCC array with the points.

        :rtype: tuple[OCC.TColgp.Handle_TColgp_HArray1OfPnt, int]
        """
        pts = tuple(pointiterator(self.points))
        pts_arr = make_TColgp_HArray1OfPnt(pts).handle
        len_pts = len(pts)
        return pts_arr, len_pts

    @Attribute(private=True)
    def _pt_colors(self):
        """OCC array with the colors.

        :rtype: OCC.Quantity.Handle_Quantity_HArray1OfColor
        """
        colors = self.colors
        if is_color(colors):
            default_color = colors
            colors = None  # signal the default color should be used
        else:
            default_color = self.color

        _, len_pts = self._pts

        if colors is None:
            # use the same quantity color N times
            default_color = get_rgb_value(default_color)
            q_colors = repeat(rgb_QuantityColor(default_color), len_pts)
            return make_Quantity_HArray1OfColor(q_colors, len_pts).handle
        else:
            def convert(color):
                return rgb_QuantityColor(get_rgb_value(color))

            q_colors = map(convert, iflatten_color(colors))
            return make_Quantity_HArray1OfColor(q_colors, len_pts).handle

    @Attribute(private=True)
    def _pt_dirs(self):
        """OCC array with the directions the points are facing.

        :rtype: OCC.TColgp.Handle_TColgp_HArray1OfDir
        """
        dirs = self.directions
        _, len_pts = self._pts

        if dirs is None:
            q_dirs = repeat(gp_Dir(), len_pts)
        elif isinstance(dirs, Vector):
            q_dirs = repeat(dirs, len_pts)
        else:
            q_dirs = (gp_Dir(*d) for d in iflatten_vector(dirs))
        return make_TColgp_HArray1OfDir(q_dirs, len_pts).handle

    @Attribute(private=True)
    def _Handle_AIS_InteractiveObject(self):
        """
        :rtype: OCC.AIS.AIS_PointCloud
        """
        from OCC.wrapper.AIS import AIS_PointCloud
        from OCC.wrapper.Prs3d import Prs3d_PointAspect
        from OCC.wrapper.Quantity import Quantity_Color, Quantity_NOC_AQUAMARINE2

        # instantiate the cloud
        cloud = AIS_PointCloud().handle

        theCoords, len_pts = self._pts
        theColors = self._pt_colors
        theDirs = self._pt_dirs
        cloud.SetPoints(theCoords, theColors, theDirs)

        # instantiate how the cloud is displayed
        cloud.SetHilightMode(HIGHLIGHT_MODE[self.highlight_mode])

        marker_type = MARKER_TYPE[self.marker_type]
        color = Quantity_Color(Quantity_NOC_AQUAMARINE2)  # ineffective?
        scale = self.point_scale

        drawer = cloud.Attributes()
        """:type: OCC.Prs3d.Handle_Prs3d_Drawer"""
        aspect = Prs3d_PointAspect(marker_type, color, scale).handle
        drawer.SetPointAspect(aspect)

        return cloud

    @Attribute
    def centroid(self) -> Point:
        tcolgp_harray1ofpnt, _ = self._pts
        tcolgp_array1ofpnt = tcolgp_harray1ofpnt.Array1()
        gp_pnt = GProp_PGProps.Barycentre(tcolgp_array1ofpnt)
        return Point(*gp_pnt.Coord())

    cog = Attribute(centroid)

    @Attribute
    def position(self):
        return Position(self.centroid, XY)


def compound_children_generator(compound, recursive=True):
    """Iterate over a ParaPy :class:`parapy.geom.Compound` ``compound``
    and get its children.

    Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 1, 1)
    >>> cmp1 = Compound([box.top_face, box.bottom_face])
    >>> list(compound_children_generator(cmp1))  # doctest: +ELLIPSIS
    [<Face_ ...>, <Face_ ...>]
    >>> cmp2 = Compound([cmp1, box.front_face, box.rear_face])
    >>> list(compound_children_generator(cmp2))  # doctest: +ELLIPSIS
    [<Face_ ...>, <Face_ ...>, <Face_ ...>, <Face_ ...>]
    >>> list(compound_children_generator(cmp2, recursive=False))  # doctest: +ELLIPSIS
    [<Compound_ ...>, <Face_ ...>, <Face_ ...>]

    :param Compound_ compound: ParaPy compound to iterate over.
    :param bool recursive: If ``True`` apply this method recursively when
        one of the children is a :class:`parapy.geom.Compound`.
    :rtype: collections.Iterator[parapy.geom.BRep]
    """
    for child in compound.direct_children:
        if recursive and isinstance(child, Compound_):
            for subchild in compound_children_generator(child, recursive):
                yield subchild
        else:
            yield child


#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Definition of geometrical patterns"""

import math

from parapy.core import Input, Attribute, derived
from parapy.core.sequence import Sequence, make_children
from parapy.geom.generic import (Position, linear_positions, matrix_positions,
                                 radial_positions, positions_along_curve, XOY)


# FIXME: Add GeomBase
# FIXME: change GUI
class UserPattern(Sequence):
    """Custom pattern. User provides positions"""

    __initargs__ = ["built_from", "positions"]

    #: geometric shape that serves as base for the copies in this pattern
    #: :type: Shape
    built_from = Input()

    #: will always include the first element position
    #: :type: collections.Sequence[Position]
    positions = Input()

    #: should :attr:`built_from` be included in the pattern? If you'd like to
    #: skip it, set to True (default).
    #: :type: bool
    skip_first = Input(True)

    #: the reference location for transformations.
    #: :type: Position
    reference = Input(derived)

    #: max_number can control the maximum number of elements, useful to create
    #: sparse topologies. Will be overridden in subclasses.
    #: :type: int
    max_number = Input(0)

    # FIXME: remove
    position = Input(XOY, defaulting=True)

    #: Either a valid string from parapy.globals.X11_COLORS or a 3-integer
    #: iterable with RGB values. RGB ranges 0-255. For example [255,192,203] is
    #: a list. Defaults to value of :attr:`built_from`.
    #: :type: str | collections.Sequence[int, int, int]
    color = Input(derived)

    @reference.getter
    def reference(self):
        return _first_position(self.positions)

    @color.getter
    def color(self):
        return self.built_from.color

    @Attribute
    def _list(self):
        """The list with instances that the Sequence object wraps"""
        positions = self.positions
        # lower_bound = 1 if self.skip_first else 0
        objs = _transformer(self.built_from,
                            self.reference,
                            positions,
                            self.skip_first,
                            self.max_number)
        return make_children(self, objs)

    @Attribute
    def quantify(self):
        raise NotImplementedError("not needed")

    @Attribute
    def type(self):
        return type(self.last)


# TODO: create new LinearPattern class
class RectPattern(UserPattern):
    """Rectangular pattern. If you want a 2d pattern, specify number,
    direction, spacing as lists/tuples of length 2. Special condition for
    rectangular matrices: number can also have 3 items. The third is the
    maximum number of elements in total for sparse matrices.
    """

    __initargs__ = ["built_from", "number", "direction", "spacing"]

    #: number of copies in this pattern
    #: :type: int | (int, int)
    number = Input()

    #: can be a (named) vector
    #: :type: Vector | (Vector, Vector)
    direction = Input()

    #: Distance between subsequent object locations. Specify this or length.
    #: :type: float | (float, float)
    spacing = Input()

    #: Total distance from first element to last. Specify this or
    #: :attr:`spacing`.
    #: :type: float | (float, float)
    length = Input(derived)

    @Attribute
    def max_number(self):
        if self._is_2d and len(self.number) == 3:
            return self.number[2]
        else:
            return 0

    @Attribute
    def _is_2d(self):
        return hasattr(self.number, "__iter__")

    @length.getter
    def length(self):
        if self._is_2d:
            return [self.spacing[0] * (self.number[0] - 1),
                    self.spacing[1] * (self.number[1] - 1)]
        else:
            return self.spacing * (self.number - 1)

    @Attribute
    def direction_vector(self):
        if self._is_2d:
            return [self.position.ensure_vector(self.direction[0]),
                    self.position.ensure_vector(self.direction[1])]
        else:
            return self.position.ensure_vector(self.direction)

    @Attribute
    def positions(self):
        """Will always include the first position"""
        if self._is_2d:
            # preprocess inputs
            return matrix_positions(self.position,
                                    self.number[0],
                                    self.number[1],                                    
                                    self.length[0],
                                    self.length[1],
                                    self.direction_vector[0],
                                    self.direction_vector[1])             
        else:
            return linear_positions(self.position,
                                    self.number,
                                    self.length,
                                    self.direction_vector)


class RadialPattern(UserPattern):

    __initargs__ = ["built_from", "number", "center", "normal", "spacing", "reference"]

    built_from = Input()
    number     = Input()
    normal     = Input('z', "Can be a (named) vector.")
    spacing    = Input(derived, "Angular spacing between subsequent object locations."
                                " Specify either this or total length")
    center     = Input(derived, "Defaults to position.location")
    reference  = Input(derived, "start position of first object")
    angle      = Input(derived, "Total angle from first element to last. Specify this or spacing.")

    @center.getter
    def center(self):
        return self.position.location

    @reference.getter
    def reference(self):
        return self.built_from.position

    @spacing.getter
    def spacing(self):
        return 2 * math.pi / (self.number - 1)

    @angle.getter
    def angle(self):
        return self.spacing * (self.number - 1)

    @Attribute
    def direction_vector(self):
        if self._is_2d:
            return [self.position.ensure_vector(self.direction[0]),
                    self.position.ensure_vector(self.direction[1])]
            
        else:
            return self.position.ensure_vector(self.direction)

    @Attribute
    def positions(self):
        """Will always include the first position"""
        return radial_positions(self.reference,
                                self.center,
                                self.number,
                                self.angle, 
                                self.normal)


class CurvePattern(UserPattern):
    """Create a pattern that follows a :attr:`curve`. If you want a 2d pattern,
    specify number, direction, spacing as lists, tuples of length 1. Special
    condition for rectangular matrices: number can also have 3 items. The
    third is the maximum number of elements in total for sparse matrices."""

    __initargs__ = ["built_from", "curve",  "number", "spacing", "bi_normal"]

    built_from = Input()

    #: :type: int
    number = Input()

    #: A curve object
    curve = Input()

    #: Distance between subsequent object locations. Specify this or length.
    #: :type: float
    spacing = Input()

    #: Total distance from first element to last. Specify this or spacing.
    #: :type: float
    length = Input(derived)
    reference = Input(derived)
    bi_normal = Input(derived)
    u1 = Input(derived)

    def _get_reference(self):
        return self.built_from.position #curve.get_position(self.curve.u1, self.bi_normal)

    def _get_length(self):
        return self.spacing * (self.number - 1)
    
    def _get_bi_normal(self):
        return self.curve.plane_normal # me raise exception

    def _get_u1(self):
        return self.curve.u1

    @Attribute
    def positions(self):
        """Will always include the first position"""
        u1 = self.u1
        u2 = self.curve.parameter(u1 + self.length)
        return positions_along_curve(self.curve, self.number, u1, u2, self.bi_normal)


def _first_position(positions):
    first = positions[0]
    while not isinstance(first, Position):
        first = first[0]
    return first


def _transformer(built_from, ref, positions, skip_first, max_index=0):
    cookie = [not(skip_first), 1] # [treat_me?, counter]
    return list(__transformer(built_from, ref, positions, cookie, max_index))


def __transformer(built_from, ref, objects, cookie, max_index):
    """top-level objects input has to be an iterable"""

    for obj in objects:
        if isinstance(obj, Position):
            if cookie[0]:
                if max_index:
                    if cookie[1] < max_index:
                        cookie[1] += 1 # update counter
                        yield built_from.transformed(obj, ref)
                    else:
                        # stop from here
                        return
                else:
                    yield built_from.transformed(obj, ref)
            else:
                # ignore me
                cookie[0] = True
        else:
            # multi-D
            objs = list(__transformer(built_from, ref, obj, cookie, max_index))
            if len(objs) == 1:
                yield objs[0]
            else:
                yield objs

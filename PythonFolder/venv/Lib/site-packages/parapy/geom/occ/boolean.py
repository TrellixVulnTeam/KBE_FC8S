#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os
import warnings

from OCC.wrapper.BRep import BRep_Tool_Surface
from OCC.wrapper.BRepAlgo import (
    BRepAlgo_Common, BRepAlgo_Cut, BRepAlgo_Fuse,
    BRepAlgo_Section)
from OCC.wrapper.BRepAlgoAPI import (
    BRepAlgoAPI_Common, BRepAlgoAPI_Cut,
    BRepAlgoAPI_Fuse, BRepAlgoAPI_Section)
from OCC.wrapper.BRepTools import (BRepTools_ReShape)
from OCC.wrapper.TopAbs import TopAbs_COMPOUND, TopAbs_FACE, TopAbs_SHELL, TopAbs_SOLID
from OCC.wrapper.TopoDS import TopoDS_Shape
from OCC.utils.top import (
    compound_sub_shapes, create_toptools_listofshape, faces_to_shell,
    is_infinite_face as is_infinite_face_occ, sub_shapes)

from parapy.core import Attribute, Base, Input, Part, derived, val
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.compound import Compound_, compound_children_generator
from parapy.geom.occ.edge import Edge_
from parapy.geom.occ.face import Face_
from parapy.geom.occ.history import HistoryMixin
from parapy.geom.occ.shell import Shell_
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import InfiniteSurface, Plane
from parapy.geom.occ.tolerances import get_max_tolerances, limit_max_tolerances
from parapy.geom.occ.utilities import (
    SubShapeGenerator_, TopTools_ListOfShape2list,
    TopTools_ListOfShapeGenerator_, extract_shape_algo_errors_warnings,
    make_TopoDS_Compound, topods_shape_getter)


class MixedDimensions(RuntimeError):
    pass


def get_dim(obj):
    """Get the TOPODIM of ``obj``. If ``obj`` is a compound, it will look at
    its direct children for the TOPODIM. If those are compounds themselves,
    the process repeats recursively.

    :type obj: parapy.geom.BRep | parapy.geom.Surface | parapy.geom.Curve
    :rtype: int
    :raises MixedDimensions: if ``obj`` is a compound, and the TOPODIMs of its
        direct children are not the same.
    """
    if obj.TOPOLEVEL == 0:
        gen = dim_generator(obj)
        main_dim = next(gen)
        for more in gen:
            if more != main_dim:
                msg = "Compound {} does not compose uni-dimensional objects."
                raise MixedDimensions(msg.format(obj))
        return main_dim
    else:
        return obj.TOPODIM


def dim_generator(obj):
    """Yield the TOPODIM of ``obj``. If ``obj`` is a compound, it will yield
    the dimensions of the direct children recursively. This means that if a
    child is a compound, also the TOPODIMs of that child its direct children
    will be generated, etc.

    :type obj: parapy.geom.BRep | parapy.geom.Surface | parapy.geom.Curve | parapy.geom.Compound
    :rtype: collections.Iterator[int]
    """
    if obj.TOPOLEVEL == 0:
        for child in obj.direct_children:
            for res in dim_generator(child):
                yield res
    else:
        yield obj.TOPODIM


ERROR_STATUS = {0: "Ok",
                1: "The Object is created but Nothing is Done",
                2: "Null source shapes is not allowed",
                3: "Check types of the arguments",
                4: "Can not allocate memory for the DSFiller",
                5: "The Builder can not work with such types of arguments",
                6: "Unknown operation is not allowed",
                7: "Can not allocate memory for the Builder"}


class AbstractBooleanBase(Base, HistoryMixin):
    """Mixin for all boolean operations"""

    __initargs__ = ["shape_in", "tool"]

    #: :type: OCC.BRepAlgo.BRepAlgo_BooleanOperation | None
    OLD_ALGO = None
    #: :type: OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation | None
    NEW_ALGO = None
    BUILDERKEY = "Shape"

    #: Shape to apply boolean operation to.
    #: :type: parapy.geom.occ.drawable.DrawableShape
    shape_in = Input()

    #: Tool to apply to built_from. A single BRep or sequence of these.
    #: :type: parapy.geom.occ.drawable.DrawableShape | collections.Sequence[parapy.geom.occ.drawable.DrawableShape]
    tool = Input()

    #: Either "new" or "old". Default is "new".
    #: :type: str
    algorithm = Input("new", validator=val.OneOf(["old", "new"]))

    #: Will make a compound of all tools and do 1 boolean operation to speed
    #: up the process. If you want an iterative boolean approach, set to False.
    #: Beware that history will not work, because intermediate shapes are not
    #: stored. If True, tools should not intersect each other.
    #: :type: bool
    make_compound = Input(False)

    #: fuse C1 edges? Default is False.
    #: :type: bool
    refine_edges = Input(False)

    #: If True, parallel processing is enabled.
    #: :type: bool
    parallel = Input(True)

    #: Additional tolerance that can be specified to allow this boolean
    #: operation to robustly handle cases of touching and near-coincident
    #: entities of the argument shapes.
    #: :type: float | None
    fuzzy_value = Input(None)

    #: In non-destructive mode the argument shapes are not modified. Instead
    #: a copy of a sub-shape is created in the result if it is needed to be
    #: updated.
    #: :type: bool
    non_destructive = Input(True)

    #: Open CASCADE tends to place very large tolerances on the resulting
    #: shape. If :py:`True` (default), ParaPy will limit the maximum tolerances
    #: of the shape to the maximum (vertex, edge and face) tolerances of
    #: :attr:`built_from`.
    #: :type: bool
    fix_tolerances = Input(False)

    @classmethod
    def check_inputs(cls, shape, tool):
        """Check if the ``shape`` and ``tool``(s) going in this boolean
        operation are okay to perform the boolean operation on.

        Not implemented in :class:`AbstractBooleanBase`, implement in
        derived classes!

        :type shape: parapy.geom.BRep
        :type tool: paray.geom.BRep | collections.Iterable[parapy.geom.BRep]
        """
        raise NotImplementedError("implement in subclass")

    @Attribute
    def _algorithm(self):
        """The underlying algorithm for this operation, based on
        :attr:`algorithm` being set to 'new' or 'old'.

        :rtype: typing.Type[OCC.BRepAlgo.BRepAlgo_BooleanOperation] | typing.Type[OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation]
        """

        algorithm = self.algorithm
        if algorithm == "old":
            msg = ("Using 'old' for Input 'algorithm' is deprecated, do not "
                   "specify 'algorithm' instead. Object: {!r}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning)
            return self.OLD_ALGO

        else:  # algorithm == "new":
            if self.is_user_defined("make_compound"):
                msg = ("Input make_compound has been deprecated in "
                       "combination with algorithm='new'. You can remove the "
                       "specification. Object: {!r}.")
                warnings.warn(msg.format(self), ParaPyDeprecationWarning)
            return self.NEW_ALGO

    @Attribute
    def _tools(self):
        """List of ParaPy objects.

        :rtype: list[parapy.geom.BRep]
        """
        tool = self.tool
        if hasattr(type(tool), "__iter__"):
            if (len(tool) > 1 and self.algorithm == "old" and
                    self.make_compound):
                s = make_TopoDS_Compound(map(topods_shape_getter, tool))
                tool = [self.CompoundClass(TopoDS_Shape=s)]
        else:
            tool = [tool]
        return tool

    # FIXME (TBD): use SetNonDestructive instead of fix.
    @Attribute(private=True)
    def builder(self):
        """Return a builder for this boolean operation. Fixes tolerances if
        :attr:`fix_tolerances` is set to :py:`True`.

        :rtype: OCC.BRepAlgo.BRepAlgo_BooleanOperation | OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation
        """
        shape_in, tools = self.shape_in, self._tools

        self.check_inputs(shape_in, tools)

        fix = self.fix_tolerances
        new_algo = self.algorithm == "new"

        build = self._build

        argument = topods_shape_getter(shape_in)

        if fix:
            tools = list(map(topods_shape_getter, tools))  # materialize
            max_tolerances = get_max_tolerances(argument, *tools)
            tools = iter(tools)  # rest of code expect iterator
        else:
            tools = map(topods_shape_getter, tools)  # materialize

        if new_algo:  # build in one go
            arguments = argument,
            builder = build(arguments, tools)
        else:  # algorithm == 'old'
            builder = build(argument, next(tools))
            for tool in tools:
                argument = builder.Shape()
                builder = build(argument, tool)

        # OCCFIX: BRepBuilder(API) modifies tolerances of output shape
        if fix:
            shape = builder.Shape()
            limit_max_tolerances(shape, *max_tolerances)

        return builder

    def _build(self, s1, s2):
        """Return a builder based on :attr:`_algorithm` that works on argument
        ``s1`` and tool(s) ``s2``.

        :type s1: collections.Iterable[OCC.TopoDS.TopoDS_Shape] | OCC.TopoDS.TopoDS_Shape
        :type s2: collections.Iterable[OCC.TopoDS.TopoDS_Shape] | OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation | OCC.BRepAlgo.BRepAlgo_BooleanOperation
        """
        builder = self._make_builder(s1, s2)
        builder.Build()
        self._check_builder(builder)
        if self.algorithm == "new" and self.refine_edges:
            builder.RefineEdges()
        return builder

    def _make_builder(self, s1, s2):
        if self.algorithm == "new":
            builder = self._make_new_builder(s1, s2)
        else:  # self.algorithm == 'old'
            builder = self._make_old_builder(s1, s2)
        self._set_builder_options(builder)
        return builder

    def _make_new_builder(self, s1, s2):
        """:rtype: OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation"""
        builder = self._algorithm()
        builder.SetArguments(create_toptools_listofshape(s1))
        builder.SetTools(create_toptools_listofshape(s2))
        return builder

    # allows for overriding in IntersectedShapes
    def _make_old_builder(self, s1, s2):
        """:rtype: OCC.BRepAlgo.BRepAlgo_BooleanOperation"""
        return self._algorithm(s1, s2)

    def _set_builder_options(self, builder):
        """If the "new" style algorithms are used, the :attr:`parallel`
        and :attr:`fuzzy_value` parameters are set on the ``builder``.

        :type builder: OCC.BRepAlgo.BRepAlgo_BooleanOperation | OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation
        """
        if self.algorithm == "new":
            if self.parallel:
                builder.SetRunParallel(True)
            if self.fuzzy_value is not None:
                builder.SetFuzzyValue(self.fuzzy_value)
            if self.non_destructive:
                builder.SetNonDestructive(True)

    def _check_builder(self, builder):
        """Checks the status of ``builder`.

        :raises Exception: with the error message if ``builder`` is not
            done.
        :type builder: OCC.BRepAlgo.BRepAlgo_BooleanOperation | OCC.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation
        """
        if not builder.IsDone():
            if self.algorithm == "new":
                my_class = type(self).__name__
                msg_warn = '{cls} warns: {{}}. Object: {obj!r}'.format(
                    cls=my_class, obj=self)
                msg_fail = '{cls} failed: {{}}. Object: {obj!r}'.format(
                    cls=my_class, obj=self)
                extract_shape_algo_errors_warnings(builder, msg_warn=msg_warn,
                                                   msg_fail=msg_fail)
            else:
                raise RuntimeError("{} operation failed!"
                                   .format(self._algorithm.__name__))

    @Attribute
    def section_edges(self):
        """Return a list of edges. The edges represent the result of
        intersection between arguments of the Boolean Operation. Only
        available with :attr:`algorithm` being ``'new'``.

        :rtype: list[parapy.geom.Edge]
        """
        if self.algorithm == "new":
            listofshape = self.builder.SectionEdges()
            topods_edge_gen = TopTools_ListOfShapeGenerator_(listofshape)
            # associate them to real edges.
            return self._TopoDS2Shapes(topods_edge_gen, 6)
        else:
            msg = ("You can not use .section_edges with the 'old' algorithm. "
                   "Change algorithm to 'new'.")
            raise NotImplementedError(msg)

    def _TopTools_ListOfShape2Shapes(self, lsh):
        """Convert `lsh` to a python :class:`list` containing ParaPy shapes.

        :param OCC.TopTools.TopTools_ListOfShape lsh: list of shapes.
        :rtype: tuple[parapy.geom.BRep]
        """
        if lsh.IsEmpty():
            return ()
        else:
            shape_type = lsh.First().ShapeType()
            # TODO: replace with iterator from contrib
            lst = TopTools_ListOfShape2list(lsh)
            return self._TopoDS2Shapes(lst, shape_type)

    def _raise_if_history_not_supported(self):
        """Raise if history isn't supported.

        :raises Exception: if history is not supported.
        """
        if (len(self._tools) > 1 and self.algorithm == "old" and
                not self.make_compound):
            msg = ("Shape evolution is not supported for recursive booleans "
                   "when ``algorithm='old'``. Use ``make_compound=True``.")
            raise RuntimeError(msg)

    def generated(self, shape):
        """Return list of shapes generated from ``shape``.

        :type shape: parapy.geom.BRep
        :rtype: list[parapy.geom.BRep]
        """
        self._raise_if_history_not_supported()
        return super(AbstractBooleanBase, self).generated(shape)

    def modified(self, shape):
        """Return list of shapes modified from ``shape``.

        :type shape: parapy.geom.BRep
        :rtype: list[BRep]
        """
        self._raise_if_history_not_supported()
        return super(AbstractBooleanBase, self).modified(shape)

    def is_deleted(self, shape):
        """Return True if the ``shape`` has been deleted.

        :type shape: parapy.geom.BRep
        :rtype: bool
        """
        self._raise_if_history_not_supported()
        return super(AbstractBooleanBase, self).is_deleted(shape)


class AbstractFuseBase(AbstractBooleanBase):
    """Mixin to fuse two or more shapes together"""

    __icon__ = os.path.join(ICN_DIR, 'fuse.png')
    OLD_ALGO = BRepAlgo_Fuse
    NEW_ALGO = BRepAlgoAPI_Fuse

    @classmethod
    def check_inputs(cls, shape, tools):
        """Fuse algorithm requires all dimensions of the arguments to be the
        same.

        Mapping rules:

        +---------+------------+
        | TOPODIM | TOPOLEVEL  |
        +=========+============+
        | 1       |   5 (wire) |
        +---------+------------+
        | 2       |   3 (shell)|
        +---------+------------+
        | 3       |   2 (solid)|
        +---------+------------+

        :param parapy.geom.BRep shape: shape on which the fuse operation
            will be performed.
        :param collections.Iterable[parapy.geom.BRep] tools: iterable
            collection of tools which will be used for the Fuse.
        :raises ValueError: if the dimensional requirements are not met.
        """
        try:
            dim1 = get_dim(shape)
        except MixedDimensions:
            msg = ("DIM(shape_in) cannot be determined since it "
                   "contains at least one compound that is not "
                   "composed of uni-dimensional objects. Make sure "
                   "that shape_in is uni-dimensional. Class: {}")
            raise ValueError(msg.format(cls))

        try:
            dims2 = list(map(get_dim, tools))
        except MixedDimensions:
            msg = ("DIM(tool) cannot be determined since it "
                   "contains at least one compound that is not "
                   "composed of uni-dimensional objects. Make sure all "
                   "used tools are uni-dimensional. Class: {}")
            raise ValueError(msg.format(cls))

        if not all(dim1 == dim2 for dim2 in dims2):
            msg = ("DIM(shape_in)=={:} != DIM(tool)=={:}. Make sure the "
                   "dimension of `shape_in` and `tool` match. Class: {}")
            raise ValueError(msg.format(dim1, dims2, cls))


class AbstractSubtractedBase(AbstractBooleanBase):
    """Mixin to find remaining part of shape1 after removing regions from one
    or more tools"""

    __icon__ = os.path.join(ICN_DIR, 'cut.png')
    OLD_ALGO = BRepAlgo_Cut
    NEW_ALGO = BRepAlgoAPI_Cut

    @classmethod
    def check_inputs(cls, shape, tools):
        """Subtract rule DIM(self) <= DIM(other).

        Mapping rules:

        +---------+------------+
        | TOPODIM | TOPOLEVEL  |
        +=========+============+
        | 1       |   5 (wire) |
        +---------+------------+
        | 2       |   3 (shell)|
        +---------+------------+
        | 3       |   2 (solid)|
        +---------+------------+

        :param parapy.geom.BRep shape: shape on which the subtract operation
            will be performed.
        :param collections.Iterable[parapy.geom.BRep] tools: iterable
            collection of tools which will be used for the subtract.
        :raises ValueError: if the dimensional requirements are not met.
        """
        try:
            dim1 = get_dim(shape)
        except MixedDimensions:
            msg = ("DIM(shape_in) cannot be determined since it "
                   "contains at least one compound that is not "
                   "composed of uni-dimensional objects. Make sure "
                   "that shape_in is uni-dimensional. Class: {}")
            raise ValueError(msg.format(cls))

        try:
            dims2 = list(map(get_dim, tools))
        except MixedDimensions:
            msg = ("DIM(tool) cannot be determined since it "
                   "contains at least one compound that is not "
                   "composed of uni-dimensional objects. Make sure all "
                   "used tools are uni-dimensional. Class: {}")
            raise ValueError(msg.format(cls))

        if not all(dim1 <= dim2 for dim2 in dims2):
            msg = ("DIM(shape_in)=={:} != DIM(tool)=={:}. Make sure the "
                   "dimension of `shape_in` and `tool` match. Class: {}")
            raise ValueError(msg.format(dim1, dims2, cls))


class AbstractCommonBase(AbstractBooleanBase):
    """Mixin to finds common part between two ore more shapes"""

    __icon__ = os.path.join(ICN_DIR, 'common.png')
    OLD_ALGO = BRepAlgo_Common
    NEW_ALGO = BRepAlgoAPI_Common

    @classmethod
    def check_inputs(cls, shape, tool):
        """Check if the ``shape`` and ``tool``(s) going in this boolean
        operation are okay to perform the boolean operation on.

        :type shape: parapy.geom.BRep
        :type tool: paray.geom.BRep | collections.Iterable[parapy.geom.BRep]
        :rtype: bool
        """
        return True


class IntersectedShapes(AbstractBooleanBase):
    """Class to find all intersection curves between two or several shapes.
    The result is a list of :attr`edges` built on intersection curves.

    Usage:

    >>> from parapy.geom import Box, Cylinder, IntersectedShapes
    >>> box = Box(1, 1, 1, centered=True)
    >>> cyl = Cylinder(radius=0.5, height=2, centered=True)
    >>> obj = IntersectedShapes(shape_in=box, tool=cyl)
    >>> obj.edges  # doctest: +ELLIPSIS
    [<Edge_ root.edges[0] at 0x...>, <Edge_ root.edges[1] at 0x...>]
    >>> obj.on_face(obj.edges[0])  # doctest: +ELLIPSIS
    <Face_ root.faces[...] at 0x...>

    For more information, check `Open Cascade Documentation
    <http://www.opencascade.com/doc/occt-6.9.0/refman/html/class_b_rep_algo___section.html#a8b4fe1c485f647435344f2c246bc19df>`__.
    """

    __icon__ = os.path.join(ICN_DIR, 'section.png')
    OLD_ALGO = BRepAlgo_Section
    NEW_ALGO = BRepAlgoAPI_Section

    #: Further intersections are computed if this option is set to True. See
    # OCC docs for more information.
    #: :type: bool
    Approximation = Input(True)

    #: compute a p-curve on :attr:`shape_in`?
    #: :type: bool
    ComputePCurveOn1 = Input(True)

    #: compute a p-curve on :attr:`tool`?
    #: :type: bool
    ComputePCurveOn2 = Input(True)

    #: :type: bool
    make_compound = Attribute(True)

    @classmethod
    def check_inputs(cls, shape, tool):
        """Check if the ``shape`` and ``tool``(s) going in this boolean
        operation are okay to perform the boolean operation on.

        :type shape: parapy.geom.BRep
        :type tool: paray.geom.BRep | collections.Iterable[parapy.geom.BRep]
        :rtype: bool
        """
        return True

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    @Attribute
    def section_edges(self):
        """Edges from the intersection between :attr:`shape_in` and
        :attr:`tool`.

        :rtype: collections.Sequence[parapy.geom.occ.edge.Edge_]
        """
        return self.edges

    @Part(parse=False)
    def edges(self):
        """Edges from the intersection between :attr:`shape_in` and
        :attr:`tool`.

        :rtype: list[parapy.geom.Edge]
        """
        gen = SubShapeGenerator_(self.TopoDS_Shape, "edge")
        return [Edge_(TopoDS_Shape=shape) for shape in gen]

    def on_face(self, edge, which=None):
        """Return face on which ``edge`` lies or None.

        :type edge: parapy.geom.Edge
        :param str | None which: choose on which of the input shapes the
            returned face resides. Choose either 'shape_in' to
            find a face on the shape going in, or 'tool' to find a face on
            one of the shape(s) used as a tool. Set it to None to get an
            arbitrary one, if any (default).
        :rtype: parapy.geom.Face | None

        .. note:: When a seam of a :attr:`shape_in` or :attr:`tool` lies
            on one of the output edges, it is a known issue that this tool will
            not always detect that this edge lies on one of the faces going in.
        """
        assert which in {None, 'shape_in', 'tool'}

        builder = self.builder
        topods_shape = TopoDS_Shape()
        topods_edge = edge.TopoDS_Shape
        in_face = tool_face = None

        # get shape on shape_in
        flag = builder.HasAncestorFaceOn1(topods_edge, topods_shape)
        if flag:
            in_face =  self.shape_in._TopoDS2Shape(topods_shape,
                                                   shape_type=TopAbs_FACE)
            if which is None or which == 'shape_in':
                return in_face
        elif which == 'shape_in':
            return None

        # get shape on tool
        flag = builder.HasAncestorFaceOn2(topods_edge, topods_shape)
        if flag:
            tool_face = self._tools[0]._TopoDS2Shape(topods_shape,
                                                     shape_type=TopAbs_FACE)

        # it is either set now, or not. It does not matter, because of
        # which, it is always the correct answer
        return tool_face

    def _set_builder_options(self, builder):
        super(IntersectedShapes, self)._set_builder_options(builder)
        builder.Approximation(self.Approximation)
        builder.ComputePCurveOn1(self.ComputePCurveOn1)
        builder.ComputePCurveOn2(self.ComputePCurveOn2)

    def _make_old_builder(self, s1, s2):
        return self._algorithm(s1, s2, False)  # PerformNow=False


class BooleanCompound(Compound_):
    """Abstract base class for general boolean operations, returning a
    compound shape as result.

    Implements TopoDS_Shape
    """

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()


class BooleanShell(AbstractBooleanBase, Shell_):
    """Abstract class that implements TopoDS_Shape and adds :attr:`on_invalid`
    Input to specify what should happen when the given input for this
    boolean operation is invalid.
    """

    #: Fail if final shape does not pass validation tests. Default is "raise".
    #: Valid options are: ``["raise", "warn", "ignore"]``
    #: :type: str
    on_invalid = Input("raise",
                       validator=val.OneOf(["raise", "warn", "ignore"]))

    def validate_result(self, topods_shape):
        """Validate the result of the BooleanShell operation. At least a
        shell should come out, be it a shell alone or a shell in a compound.

        Either raises,
        warns or ignores the fact that it is invalid based in the
        :attr:`on_valid` input.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        def raise_conditionally(msg):
            on_invalid = self.on_invalid
            if on_invalid == "raise":
                raise RuntimeError(msg)
            elif on_invalid == "warn":
                warnings.warn(msg)
                return topods_shape
            elif on_invalid == "ignore":
                return topods_shape
            else:
                msg = "Value for on_invalid ``{:}`` is not allowed."
                msg = msg.format(on_invalid)
                raise RuntimeError(msg)

        shape_type = topods_shape.ShapeType()
        if shape_type == TopAbs_SHELL:
            return topods_shape
        elif shape_type == TopAbs_COMPOUND:
            children = tuple(compound_sub_shapes(topods_shape, recursive=True))
            nb_children = len(children)

            if nb_children == 0:
                msg = "Empty compound found."
                return raise_conditionally(msg)
            elif nb_children == 1:
                # either a shell or a face
                child, = children
                child_type = child.ShapeType()
                if child_type == TopAbs_SHELL:
                    return child
                elif child_type == TopAbs_FACE:
                    return faces_to_shell(child)
                else:
                    msg = ("Unexpected ShapeType found. Found shape with "
                           "ShapeType: {:}.")
                    return raise_conditionally(msg.format(child_type))
            else:
                faces = []
                for child in children:
                    child_type = child.ShapeType()
                    if child_type == TopAbs_SHELL:
                        for topods_face in sub_shapes(child):
                            faces.append(topods_face)
                    elif child_type == TopAbs_FACE:
                        faces.append(child)
                    else:
                        msg = ("Unexpected ShapeType found. Found shape with "
                               "ShapeType: {:}.")
                        return raise_conditionally(msg.format(child_type))
                return faces_to_shell(*faces)

        else:
            msg = ("Unexpected ShapeType found. No shell or compound of one "
                   "shell, but something with ShapeType: {:}")
            return raise_conditionally(msg.format(shape_type))

    @Attribute
    def TopoDS_Shape(self):
        """The resulting shape in the form an OCC BRep representation.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = self.builder.Shape()
        return self.validate_result(topods_shape)


class BooleanSolid(AbstractBooleanBase, Solid_):
    """Implemements TopoDS_Shape and adds on_invalid key."""

    #: Fail if final shape does not pass validation tests. Default is "raise".
    #: Valid options are: ``["raise", "warn", "ignore"]``
    #: :type: str
    on_invalid = Input("raise",
                       validator=val.OneOf(["raise", "warn", "ignore"]))

    def validate_result(self, topods_shape):
        """Validate the result of the BooleanShell operation. Either raises,
        warns or ignores the fact that it is invalid based in the
        :attr:`on_valid` input.

        :type topods_shape: OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        shape_type = topods_shape.ShapeType()
        if shape_type == TopAbs_SOLID:
            return topods_shape
        elif shape_type == TopAbs_COMPOUND:
            shells = list(SubShapeGenerator_(topods_shape, 2))
            if len(shells) == 1:
                return shells[0]
            elif len(shells) == 0:
                msg = "No solids found."
            else:
                msg = ("Found a compound with more than 1 solid. Perhaps "
                       "use a non-solid specific Boolean Operation?")
        else:
            msg = ("Unexpected ShapeType found. No solid or compound of one "
                   "solid, but something with ShapeType: {:}")
            msg = msg.format(shape_type)

        # if we get here, something went wrong. Based on value of on_invalid
        # we raise or return with or without warning.
        on_invalid = self.on_invalid
        if on_invalid == "raise":
            raise Exception(msg)
        elif on_invalid == "warn":
            warnings.warn(msg)
        elif not on_invalid == "ignore":
            msg = "Value for on_invalid ``{:}`` is not allowed."
            msg = msg.format(on_invalid)
            raise Exception(msg)
        return topods_shape

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """The resulting shape in the form an OCC BRep representation.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        topods_shape = self.builder.Shape()
        return self.validate_result(topods_shape)


# ---- concrete classes ----
class Fused(AbstractFuseBase, BooleanCompound):
    """General fuse operation. Not limited to solids or shells. Fuses a
    :attr:`shape_in` with a :attr:`tool`,  viz. the resulting shape is the
    union of ``shape_in`` and ``tool``. In logical terms ``shape = shape_in
    ∪ tool.`` The resulting shape is typically a
    :class:`~parapy.geom.Compound` containing fused images of the
    :attr:`shape_in` and :attr:`tool`. You can access individual sub-shapes
    via :attr:`direct_children` or slots like :attr:`solids`, :attr:`faces`,
    etc.

    Usage:

    >>> from parapy.geom import Point, Wire, LineSegment, Fused
    >>> crv1 = LineSegment(Point(-1, 0, 0), Point(1, 0, 0))
    >>> crv2 = LineSegment(Point(0, -1, 0), Point(0, 1, 0))
    >>> obj = Fused(crv1, crv2)
    >>> # result composes split images of crv1, crv2, viz. both 2 edges
    >>> len(obj.edges)
    4
    >>> len(obj.modified(crv1)), len(obj.modified(crv2))
    (2, 2)
    >>> # to make one Wire from these edges
    >>> wire = Wire(obj.edges)
    >>> len(wire.edges)
    4

    Let's now use surfaces:

    >>> from parapy.geom import translate, RectangularSurface, Fused, SewnShell
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = RectangularSurface(1, 1, position=translate(srf1.position,
    ...                           'x', 0.5, 'y', 0.5))
    >>> obj = Fused(srf1, srf2)
    >>> # result holds split image srf1 and srf2 (both 2 faces), but shared
    >>> # faces is present in result only once
    >>> len(obj.faces)
    3
    >>> len(obj.modified(srf1)), len(obj.modified(srf2))
    (2, 2)
    >>> # to make one Shell from these faces
    >>> shell = SewnShell(obj.faces)
    >>> len(shell.faces)
    3

    .. warning:: If shape and tool do not intersect both will be part of the
        resulting (Compound) shape as-is.

    .. warning:: Take particular precaution with infinite geometry inputs (
        e.g. Plane) since parts of it are kept in the result (making it
        infinite as well).

    .. note:: See :py:class:`~parapy.geom.occ.boolean.AbstractBooleanBase` for
        extra (optional) inputs.
    """
    pass


class Subtracted(AbstractSubtractedBase, BooleanCompound):
    """Very general subtract operation. Not limited to solids or shells.
    Finds common part between a ``shape_in`` and a ``tool``, viz. the
    resulting shape the
    common part between ``shape_in`` and ``tool``. In logical
    terms ``shape = shape_in ∩ tool.``

    Usage:

    >>> from parapy.geom import RectangularSurface, Subtracted
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = RectangularSurface(1, 1).translated(x=0.5, y=0.5)
    >>> obj = Subtracted(srf1, srf2)
    >>> len(obj.faces)
    1
    >>> obj.faces[0].area
    0.75

    .. note:: See :py:class:`~parapy.geom.occ.boolean.AbstractBooleanBase` for
        extra (optional) inputs.
    """
    pass


class Common(AbstractCommonBase, BooleanCompound):
    """Very general common operation. Not limited to solids or shells.
    Finds common part between a ``shape_in`` and a ``tool``, viz. the resulting
    shape the common part between ``shape_in`` and ``tool``. In logical
    terms ``shape = shape_in ∩ tool.``

    Usage:

    >>> from parapy.geom import RectangularSurface, Common
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = RectangularSurface(1, 1).translated('x', 0.5, 'y', 0.5)
    >>> obj = Common(srf1, srf2)
    >>> len(obj.faces)
    1
    >>> obj.faces[0].area
    0.25

    .. note:: See :py:class:`~parapy.geom.occ.boolean.AbstractBooleanBase` for
        extra (optional) inputs.
    """
    pass

# TODO (RvD): get rid of this monkey-patching.
BRep.FusedClass = Fused
BRep.SubtractedClass = Subtracted
BRep.CommonClass = Common


class FusedShell(AbstractFuseBase, BooleanShell):
    """Fuses a shell :attr:`shape_in` with one or several other shells
    :attr:`tool`, viz. the resulting shape is the union of shape_in and tool.
    In logical terms ``shape = shape_in ∪ tool``. Usage:

    >>> from parapy.geom import (RectangularSurface, TranslatedSurface, Vector,
    ...                         FusedShell)
    >>> surf1 = RectangularSurface(1, 1)
    >>> # Now create a second surface with centroid on corner of surf1
    >>> surf2 = TranslatedSurface(surf1, Vector(0.5, 0.5, 0))
    >>> shell = FusedShell(shape_in=surf1, tool=surf2)
    >>> len(shell.faces)
    3

    To fuse a shell with an infinite Plane, you typically want to use this
    class:

    >>> from parapy.geom import Plane, Box, FusedShell
    >>> box = Box(1, 1, 1, centered=True)
    >>> shell = box.outer_shell
    >>> plane = Plane()
    >>> obj = FusedShell(shape_in=shell, tool=plane)
    >>> len(obj.faces)
    11

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """

    #: If :attr:`shape_in` or :attr:`tool` contain *infinite* geometry
    #: (e.g. :class:`~parapy.geom.Plane`), without any post-processing,
    #: infinite faces can end up in the final result. By default, ParaPy
    #: will do a scan on the input arguments to this operation and identify
    #: the presence of infinite geometry. If you are sure that your input is
    #: not infinite, you can skip this scan by setting this Input to False. On
    #: the other hand, the scan may not identify some corner cases, you can
    #: force removal infinite faces, by setting this Input to True.
    #: :type: bool
    remove_infinite_faces = Input(derived)

    @remove_infinite_faces.getter
    def remove_infinite_faces(self):
        """:py:`True` if one of the input shape arguments is an unbounded
        face. Otherwise :py:`False`.

        :rtype: bool
        """
        shape_in, tool = self.shape_in, self.tool
        if is_infinite_arg(shape_in):
            return True
        if hasattr(type(tool), "__iter__"):
            for arg in tool:
                if is_infinite_arg(arg):
                    return True
        elif is_infinite_arg(tool):
            return True
        return False

    def modified(self, shape):
        """Overwrites the "modified" method, because the output might contain
        results which were filtered out.

        :param parapy.geom.BRep shape:
        :rtype: list[parapy.geom.BRep]
        """
        self._raise_if_history_not_supported()

        topods_shape = shape.TopoDS_Shape
        lsh = self.builder.Modified(topods_shape)
        modified_shapes = TopTools_ListOfShape2list(lsh)

        if self.remove_infinite_faces and is_infinite_arg(shape):
            result_topos = set(map(topods_shape_getter, self.faces))
            # only list them in the modified history if we got them in the
            # result
            modified_shapes = [s for s in modified_shapes if s in result_topos]

        return self._TopoDS2Shapes(modified_shapes)

    def validate_result(self, topods_shape):
        # remove infinite faces from result
        validated = super(FusedShell, self).validate_result(topods_shape)

        # if one of shape_in/tools was an infinite surface, remove possible
        # 'artifacts' (faces with one edge) in the result.
        if self.remove_infinite_faces:
            # now remove faces from the output Shell if they are a result
            # of a fuse with an unbounded shape, and are invalid (have only one
            # edge or negative area)
            infinite_faces_out = []

            for face in sub_shapes(validated, TopAbs_FACE, downcast=True):
                if is_infinite_face(face):
                    infinite_faces_out.append(face)

            if infinite_faces_out:
                reshaper = BRepTools_ReShape()
                for face in infinite_faces_out:
                    reshaper.Remove(face)
                validated = reshaper.Apply(validated)

        return validated


class SubtractedShell(AbstractSubtractedBase, BooleanShell):
    """Subtracts from a shell :attr:`shape_in` one or several other shells
    :attr:`tool`, viz. the resulting shape is that part of shape_in that has
    nothing in common with the tool. Logic: ``shape = shape_in \ tool``.

    Usage:

    >>> from parapy.geom import (RectangularSurface, SubtractedShell)
    >>> srf1 = RectangularSurface(1, 1)
    >>> srf2 = RectangularSurface(1, 1).translated('x', 0.5, 'y', 0.5)
    >>> obj = SubtractedShell(shape_in=srf1, tool=srf2)

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """


class CommonShell(AbstractCommonBase, BooleanShell):
    """Finds common part between a shell :attr:`shape_in` and one or several
    other shells :attr:`tool`, viz. the resulting shape the common part between
    shape_in and tool. In logical terms ``shape = shape_in ∩ tool.``

    Usage:

    >>> from parapy.geom import (RectangularSurface, TranslatedSurface, Vector,
    ...                         CommonShell)
    >>> surf1 = RectangularSurface(1, 1)
    >>> # Now create a second surface with centroid on corner of surf1
    >>> surf2 = TranslatedSurface(surf1, Vector(0.5, 0.5, 0))
    >>> shell = CommonShell(shape_in=surf1, tool=surf2)

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """


class FusedSolid(AbstractFuseBase, BooleanSolid):
    """Fuses a solid :attr:`shape_in` with one or several other solids
    :attr:`tool`, viz. the resulting shape is the union of shape_in and tool.
    In logical terms ``shape = shape_in ∪ tool.``

    Usage:

    >>> from parapy.geom import FusedSolid, Box, Cylinder
    >>> box = Box(1, 1, 1, centered=True)
    >>> cyl = Cylinder(radius=0.4, height=2, centered=True)
    >>> obj = FusedSolid(shape_in=box, tool=cyl)

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """


class SubtractedSolid(AbstractSubtractedBase, BooleanSolid):
    """Subtracts from a solid :attr:`shape_in` one or several other solids
    :attr:`tool`, viz. the resulting shape is that part of shape_in that has
    nothing in common with the tool. Logic: ``shape = shape_in \ tool``.

    Usage:

    >>> from parapy.geom import SubtractedSolid, Box, Cylinder
    >>> box = Box(1, 1, 1, centered=True)
    >>> cyl = Cylinder(radius=0.4, height=2, centered=True)
    >>> obj = SubtractedSolid(shape_in=box, tool=cyl)

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """


class CommonSolid(AbstractCommonBase, BooleanSolid):
    """Finds common part between a solid :attr:`shape_in` and one or several
    other solids :attr:`tool`, viz. the resulting shape the common part
    between shape_in and tool. In logical terms ``shape = shape_in ∩ tool.``

    Usage:

    >>> from parapy.geom import CommonSolid, Box, Cylinder
    >>> box = Box(1, 1, 1, centered=True)
    >>> cyl = Cylinder(radius=0.2, height=2, centered=True)
    >>> obj = CommonSolid(shape_in=box, tool=cyl)

    .. note:: See :py:class:`~parapy.geom.occ.AbstractBooleanBase` for
    (optional) inputs.
    """


INFINITE_SURFACE_TYPE_NAMES = frozenset(("Geom_Plane",
                                         "Geom_CylindricalSurface",
                                         "Geom_ConicalSurface"))


def is_infinite_arg(arg):
    if isinstance(arg, InfiniteSurface):
        return True
    elif isinstance(arg, Compound_):
        for child in compound_children_generator(arg):
            if is_infinite_arg(child):
                return True
    elif isinstance(arg, Face_):
        if is_infinite_face(arg.TopoDS_Face):
            return True
    elif isinstance(arg, Shell_) and len(arg.faces) == 1:
        if is_infinite_face(arg.faces[0].TopoDS_Face):
            return True
    return False


def is_infinite_face(topods_face):
    """Checks if ``topods_face`` is infinite.

    :param OCC.TopoDS.TopoDS_Face face:
    :rtype: bool
    """
    # quickest filter
    hgs = BRep_Tool_Surface(topods_face)
    if hgs.DynamicType().Name() in INFINITE_SURFACE_TYPE_NAMES:
        return is_infinite_face_occ(topods_face)
    else:
        return False

    # if not BRepCheck_Analyzer(face).IsValid():
    #     hgs = BRep_Tool_Surface(face)
    #     # (For now?) we only saw problems with Geom_Plane kind
    #     # of cases. It is possible that there are more cases.
    #     if (hgs.IsKind("Geom_Plane") or hgs.IsKind("Geom_CylindricalSurface")
    #             or hgs.IsKind("ConicalSurface")):
    #         if len(edges(face)) == 1:
    #             return True
    #         elif area(face) < 0:
    #             # negative area is probably not the best test to
    #             # see if the face is inside-out.
    #             return True
    # return False

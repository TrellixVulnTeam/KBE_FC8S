#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Description of the code."""

import os
import warnings

from OCC.wrapper import VERSION as OCC_VERSION
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeEdge2d, BRepBuilderAPI_MakeWire)
from OCC.wrapper.BRepExtrema import BRepExtrema_ExtPC
from OCC.wrapper.Bnd import Bnd_Box2d
from OCC.wrapper.BndLib import BndLib_Add2dCurve
from OCC.wrapper.GCPnts import GCPnts_AbscissaPoint
from OCC.wrapper.Geom2d import Handle_Geom2d_Curve
from OCC.wrapper.Geom2dAPI import Geom2dAPI_InterCurveCurve
from OCC.wrapper.Geom2dAdaptor import Geom2dAdaptor_Curve
from OCC.wrapper.GeomAPI import GeomAPI__To2d, GeomAPI__To3d
from OCC.wrapper.GeomAdaptor import GeomAdaptor_Curve
from OCC.wrapper.GeomLib import GeomLib_Tool
from OCC.wrapper.ShapeAnalysis import ShapeAnalysis_Curve
from OCC.wrapper.TColgp import TColgp_SequenceOfPnt2d
from OCC.utils.utilities import handle_is_instance

from parapy.core import Attribute, Base, Input, list_of_numbers
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.generic.positioning import OXY, VZ
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.curve import ClonedCurve, Curve
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.mixins import TransformationMixin
from parapy.geom.occ.patched.gp import *  # @UnusedWildImport


def Curve2D_Handle_Geom_Curve_validator(value, obj, _):
    """Curve Handle_Geom_Curve should be of type __Handle_Geom_Curve__

    :rtype: bool
    """
    return handle_is_instance(value, obj.__Handle_Geom2d_Curve__)


class Curve2d(DrawableShape, TransformationMixin):
    """The abstract class Curve describes the common behavior of curves in
    2D space. PCurves are modelled like this, they have an on-face."""

    __icon__ = os.path.join(ICN_DIR, 'curve.png')
    TOPODIM = 1
    TOPOLEVEL = 6  # 7: Vertex, 6: Edge, 5: Wire, 4: Face,
                   # 3: Shell, 2: Solid, 1: CompSolid, 0: Compound

    # each curve sub-class has to define the specific Handle that it's
    # implementing
    __Handle_Geom2d_Curve__ = Handle_Geom2d_Curve

    @Input(validator=Curve2D_Handle_Geom_Curve_validator)
    def Handle_Geom2d_Curve(self):
        """
        :rtype: OCC.Geom2d.Handle_Geom2d_Curve
        """
        raise NotImplementedError("should have been implemented in subclass")

    on_surface = Input(None, "if this is a PCurve, it will be on_surface")
    # =========================================================================
    # Curve representations
    # =========================================================================
    @property
    def _new_curve_type(self):
        """used by ClonedCurve to decide Curve type to return. Curves can
        override this method.

        :rtype: type
        """
        return Curve2d

    @Attribute
    def downcast(self):
        """Get a more specific representation of this object.

        :rtype: Curve2d
        """
        h_geom_curve, class_ = Handle_Geom2d_Curve2ParaPy(
            self.Handle_Geom2d_Curve)
        return class_(Handle_Geom2d_Curve=h_geom_curve)

    @Attribute
    def Handle_Geom_Curve(self):
        """Return the underlying OCC representation of this object.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return GeomAPI__To3d(self.Handle_Geom2d_Curve, self.position.gp_Pln)

    @Attribute
    def curve(self):
        """Convert this curve into a 3D curve

        :rtype: Curve
        """
        return ClonedCurve(self.Handle_Geom_Curve)

    @Attribute
    def _Geom2d_Curve(self):
        """
        :rtype: OCC.Geom2d.Handle_Geom2d_Curve
        """
        return self.Handle_Geom2d_Curve

    # FIXME: Copy() creates strange results in RefCounts with fatal errors
    # downstream
    # TODO: http://opencascade.blogspot.nl/2008/11/open-cascade-handles-lets-handleem-part_21.html
    def _new_handle(self):
        """Returns a new handle_geom_curve copy.
        Of type :py:`self.__Handle_Geom_Curve__`

        :rtype: OCC.Geom2d.Handle_Geom2d_Curve
        """
        return self.__Handle_Geom2d_Curve__(self._Geom2d_Curve)

    @Input
    def _Convert_ParameterisationType(self):
        """Controls the type of parametrisation used to convert this
        Geom_Curve to a BSpline curve.
        http://dev.opencascade.org/doc/refman/html/_convert___parameterisation_type_8hxx.html

        :rtype: int
        """
        return 0

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return BRepBuilderAPI_MakeEdge2d(self.Handle_Geom2d_Curve).Edge()

    @Attribute
    def TopoDS_Edge(self):
        """
        :rtype OCC.TopoDS.TopoDS_Edge
        """
        return self.TopoDS_Shape

    @Attribute
    def TopoDS_Wire(self):
        """
        :rtype OCC.TopoDS.TopoDS_Wire
        """
        # It is possible to built a wire, but it's rarely
        # necessary (will have just one edge)
        return BRepBuilderAPI_MakeWire(self.TopoDS_Edge).Wire()

    @Attribute
    def _Adaptor2d_Curve(self):
        """
        :rtype: OCC.Geom2d.Geom2dAdaptor_Curve
        """
        return Geom2dAdaptor_Curve(self.Handle_Geom2d_Curve)

    @Attribute
    def _ShapeAnalysis_Curve(self):
        """
        :rtype: OCC.ShapeAnalysis.ShapeAnalysis_Curve
        """
        return ShapeAnalysis_Curve()

    @Attribute
    def _drawable_TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.TopoDS_Edge

    # =========================================================================
    # Attributes
    # =========================================================================
    @Attribute
    def start(self):
        """Start point of this curve.

        :rtype parapy.geom.Point
        """
        return self.point_at_parameter(self.u1)

    @Attribute
    def end(self):
        """End point of this curve.

        :rtype parapy.geom.Point
        """
        return self.point_at_parameter(self.u2)

    @Attribute
    def midpoint(self):
        """Point at parametric midpoint of this curve.

        :rtype parapy.geom.Point
        """
        return self.point_at_parameter(self.u1 + (self.u2 - self.u1) / 2.)

    @Attribute
    def tangent1(self):
        """Unit vector representing the tangent at the start of the curve.

        :rtype parapy.geom.Vector
        """
        return self.derivate(self.u1)

    @Attribute
    def position1(self):
        """Return a position object at start of curve.

        In the returned position::

            location = curve.start
            Vx = curve.tangent1
            Vy = ...
            Vz = global z-axis direction

        :rtype: parapy.geom.Position
        """
        return Position(self.start,
                        Orientation(x=self.tangent1,
                                    z=VZ))

    @Attribute
    def position2(self):
        """Return a position object at start of curve.

        In the returned position::

            location = curve.end
            Vx = curve.tangent2
            Vy = ...
            Vz = global z-axis direction

        :rtype: parapy.geom.Position
        """
        return Position(self.end,
                        Orientation(x=self.tangent2, z=VZ))

    def position_at_parameter(self, u):
        """Return a position object at u.

        In the returned position::

            location = curve.point_at_parameter(u)
            Vx = curve.tangent(u)
            Vy = ...
            Vz = global z-axis direction
        
        :rtype: parapy.geom.Position
        """
        return Position(self.point_at_parameter(u),
                        Orientation(x=self.tangent(u), z=VZ))

    @Attribute
    def tangent2(self):
        """Unit vector representing the tangent at the end of the curve.

        :rtype parapy.geom.Vector
        """
        return self.derivate(self.u2)

    @Attribute
    def direction_vector(self):
        """Unit vector pointing from start to end.

        :rtype parapy.geom.Vector
        """
        # TODO: what if closed curve, allow division by zero error?
        return self.start.vector_to(self.end).normalize

    @Attribute
    def u1(self):
        """Start parameter of this curve.

        :rtype float
        """
        return self._Adaptor2d_Curve.FirstParameter()

    @Attribute
    def u2(self):
        """End parameter of this curve.

        :rtype float
        """
        return self._Adaptor2d_Curve.LastParameter()

    u_min = u1
    u_max = u2

    @Attribute
    def du(self):
        """The total parametric length (u2 - u1)

        :rtype: float
        """
        return self.u2 - self.u1

    @Attribute
    def continuity(self):
        """Continuity of this curve

        :rtype: int
        """
        return self._Adaptor2d_Curve.Continuity()

    @Attribute
    def is_closed(self):
        """Is this curve closed?

        :rtype: bool
        """
        return self._Adaptor2d_Curve.IsClosed()

    @Attribute
    def is_periodic(self):
        """Is this curve periodic?

        :rtype: bool
        """
        return self._Adaptor2d_Curve.IsPeriodic()

    @Attribute
    def is_planar(self):
        """Is this curve planar?

        :rtype: bool
        """
        return True

    @Attribute
    def plane_normal(self):
        """
        Returns the global z-axis. A 2d curve lies in the global XY plane by
        definition.

        :rtype: parapy.geom.Vector
        """
        return VZ

    @Attribute
    def length(self):
        """Total length of this curve.

        :rtype: float

        .. note:: Calculated using default precision. Use :meth:`arc_length`
            if you want to have more control.
        """
        return GCPnts_AbscissaPoint.Length(self._Adaptor2d_Curve)

    @Attribute
    def sample_points(self):
        """Return sample points which will serve as linearization.

        :rtype: list[parapy.geom.Point]
        """
        pts = TColgp_SequenceOfPnt2d()
        self._ShapeAnalysis_Curve.GetSamplePoints(self.Handle_Geom2d_Curve,
                                                  self.u1,
                                                  self.u2,
                                                  pts)
        return [pts.Value(i).point for i in range(1, pts.Length()+1)]

    # =========================================================================
    # Methods
    # =========================================================================
    def point_at_parameter(self, u):
        """Return point at ``u`` parameter.

        :param float u: parametric representation of the point on the curve
        :rtype Point
        """
        return self._Adaptor2d_Curve.Value(u).point

    point = point_at_parameter

    @Attribute
    def _Adaptor3d_Curve(self):
        """
        :rtype: OCC.Adaptor3d.GeomAdaptor_Curve
        """
        return GeomAdaptor_Curve(self.Handle_Geom_Curve)

    #http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classShapeAnalysis__Curve_e24d4b3948c5305a8b54ddc5e02f00da.html#e24d4b3948c5305a8b54ddc5e02f00da
    # TODO: meaning of second pt input???
    def parameter(self, point, precision=1e-6, AdjustToEnds=True):
        """Get the parametric value of ``point`` on the curve, within
        ``precision``.

        :param parapy.geom.Point point:
        :param float precision:
        :param bool AdjustToEnds:
        :rtype: float
        """
        flag, u = GeomLib_Tool.Parameter(self.Handle_Geom2d_Curve,
                                         gp_Pnt2d(point.x, point.y),
                                         precision)
        if not flag:
            msg = ("Failed to convert point to parameter. Point is either "
                   "located further away from curve than precision ({}) or "
                   "computation failed. Try to specify a Point closer to "
                   "this curve or provide larger precision. Object: {}.")
            raise RuntimeError(msg.format(precision, self))
        return u

    def projected_point(self, point, precision=1e-6, AdjustToEnds=True):
        """Projects a ``point`` on this curve within a ``precision``.

        Returned value::

            {
                "pt" : Point projected on the curve,
                "u" : float, the parametric value of the point projected,
                "tol" : float, the tolerance of the projection
            }

        :param parapy.geom.Point point:
        :param float precision:
        :param bool AdjustToEnds:
        :rtype: dict[str, float | parapy.geom.Point]
        """
        proj = gp_Pnt()
        tol, p = self._ShapeAnalysis_Curve.Project(self._Adaptor3d_Curve,
                                                   point.gp_Pnt,
                                                   precision,
                                                   proj,
                                                   AdjustToEnds)
        return {"pt": proj.point, "u": p, "tol": tol}

    def parameter_at_length(self, length, precision=None):
        """Get the parameter at ``length`` on this Curve2d.

        :param float length:
        :param float | None precision: The precision of the result. Set to
            :py:`None` for default precision.
        :rtype: float
        """
        if precision is None:
            measure = GCPnts_AbscissaPoint(self._Adaptor2d_Curve,
                                           length, self.u1)
        else:
            measure = GCPnts_AbscissaPoint(precision,self._Adaptor2d_Curve,
                                           length, self.u1)
        assert measure.IsDone(), ("measuring is not done. Contact "
                                  "support@parapy.nl.")
        return measure.Parameter()

    def point_at_length(self, length):
        """

        :param float length:
        :rtype: parapy.geom.Point
        """
        return self.point_at_parameter(self.parameter_at_length(length))

    def arc_length(self, u1=None, u2=None, precision=None):
        """Returns arc length between parameters ``u1`` and ``u2``. If both
        parameters are None, full arc length is returned.

        :param float | None u1: first parameter on this curve from which arc
            length is measured. If None, :attr:`u1` is used (start of curve).
        :param float | None u2: second parameter on this curve untill which arc
            length is measured. If None, :attr:`u2` is used (end of curve).
        :param float | None precision: tolerance for measuring. If None,
            OCC's default precision is used.
        :rtype: float

        .. warning:: specifying precision has been known to return strange
            results.
        """
        adaptor = self._Adaptor2d_Curve
        if u1 is None and u2 is None:
            if precision is None:
                return GCPnts_AbscissaPoint.Length(adaptor)
            else:
                return GCPnts_AbscissaPoint.Length(adaptor, precision)
        if u1 is None:
            u1 = self.u1
        if u2 is None:
            u2 = self.u2
        if precision is None:
            return GCPnts_AbscissaPoint.Length(adaptor, u1, u2)
        else:
            return GCPnts_AbscissaPoint.Length(adaptor, u1, u2, precision)

    def derivate(self, u, order=1):
        """Return NORMALIZED derivate at u parameter. Order control
        which derivate, e.g. order=1 return first
        derivate. Error is raised if continuity of curve and
        requested order of derivate don't match.

        :rtype: parapy.geom.Vector
        """
        vec = self._Adaptor2d_Curve.DN(u, order)
        return vec.vector.normalize

    def tangent(self, u):
        """the tangent vector at parameter u

        :rtype: parapy.geom.Vector
        """
        return self.derivate(u)

    def tangent_at_point(self, point):
        """

        :param parapy.geom.Point point:
        :rtype: parapy.geom.Vector
        """
        return self.tangent(self.parameter(point))

    def normal(self, u, bi_tangent=None):
        """``bi_tangent`` is other vector for cross-product:
        tangent x bi_tangent. bi_tangent is
        None by default. You can leave it at None, only if your curve is
        planar, plane_normal is'
        then used instead.

        :param float u:
        :param parapy.geom.Vector bi_tangent:
        :rtype: parapy.geom.Vector
        """
        return self.tangent(u).cross(bi_tangent or self.plane_normal)

    def normal_at_point(self, point, bi_tangent=None):
        """``bi_tangent`` is other vector for cross-product:
        tangent x bi_tangent. bi_tangent is
        None by default. You can leave it at None, only if your curve is
        planar, plane_normal is'
        then used instead.

        :param parapy.geom.Point point:
        :param parapy.geom.Vector bi_tangent:
        :rtype: parapy.geom.Vector
        """
        return self.tangent_at_point(point).cross(
            bi_tangent or self.plane_normal)

    def normal1(self, bi_tangent):
        """``bi_tangent`` is other vector for cross-product:
        tangent x bi_tangent

        :param parapy.geom.Vector bi_tangent:
        :rtype: parapy.geom.Vector
        """
        return self.tangent1.cross(bi_tangent)

    def normal2(self, bi_tangent):
        """``bi_tangent`` is other vector for cross-product:
        tangent x bi_tangent

        :param parapy.geom.Vector bi_tangent:
        :rtype: parapy.geom.Vector
        """
        return self.tangent2.cross(bi_tangent)

    def is_planar_with_tolerance(self, tolerance=0.0):
        """"tolerance == 0.0 means use default precision.

        :rtype: bool
        """
        warnings.warn('deprecated, use is_planar instead',
                      ParaPyDeprecationWarning)
        return True

    def get_points(self, n):
        """Return ``n`` points on the curve.

        :param int n:
        :rtype list[parapy.geom.Point]
        """
        curve = self._Adaptor2d_Curve
        return [curve.Value(u).point for u in list_of_numbers(self.u1,
                                                              self.u2,
                                                              n)]

    def equispaced_points(self, n):
        """Return ``n`` equispaced points on the curve.

        :param int n:
        :rtype list[parapy.geom.Point]
        """
        L = self.length
        ls = list_of_numbers(0, L, n)
        return [self.point_at_length(l) for l in ls]

    def get_equispaced_parameters(self, n):
        """Return ``n`` equispaced parameters on the curve.

        :param int n:
        :rtype list[float]
        """
        L = self.length
        ls = list_of_numbers(0, L, n)
        return [self.parameter(self.point_at_length(l)) for l in ls]

    def minimum_distance_to_point(self, point):
        """

        :param parapy.geom.Point point:
        :rtype: dict[str, float | parapy.geom.Point]
        """
        return self._distance_to_point(point, min)

    def maximum_distance_to_point(self, point):
        """

        :param parapy.geom.Point point:
        :rtype: dict[str, float | parapy.geom.Point]
        """
        return self._distance_to_point(point, max)

    def _distance_to_point(self, point, min_or_max):
        """Finds the maximum distance between a curve and a point.

        Returns:

            with three keys: 'distance', 'point, 'parameter'.


        :param types.FunctionType min_or_max: the min or max function.
        :rtype: dict[str, float | parapy.geom.Point]
        """
        assert hasattr(point, 'TopoDS_Vertex'), ("point is either Point or "
                                                 "Position.")
        result = BRepExtrema_ExtPC(point.TopoDS_Vertex, self.TopoDS_Edge)

        nr_of_extrema = result.NbExt()
        if nr_of_extrema == 0:
            raise Exception("No extrema found... Strange! Check input?")

        # Find the extreme point on curve with maximum distance to point,
        # using max().
        # max() works on the first element of each tuple. Therefore a list is 
        # constructed of (distance, n) tuples.
        #     distance: result.Value(n)
        #     n: [1..#] inclusive, hence the range adjustment

        # RvD: Value() method became SquareDistance() in OCE > 0.12 
        if OCC_VERSION == '0.6':
            agumented_distances = [(result.Value(n), n)
                                        for n in range(1, nr_of_extrema + 1)]
        else:
            agumented_distances = [(result.SquareDistance(n), n)
                                        for n in range(1, nr_of_extrema + 1)]

        distance, n = min_or_max(agumented_distances)

        return {'distance':     distance,
                'point':        result.Point(n).point,
                'parameter':    result.Parameter(n)}

    def intersection_points(self, other_curve2d):
        """other_curve has to be 2D curve!!!

        :param Curve2d other_curve2d:
        :rtype: list[parapy.geom.Point]
        """
        #raise NotImplementedError("should use 2d curve-curve intersect")
        algo = Geom2dAPI_InterCurveCurve(self.Handle_Geom2d_Curve,
                                         other_curve2d.Handle_Geom2d_Curve)
        return [algo.Point(i+1).point for i in range(algo.NbPoints())]

    def surface_intersection(self, surface):
        """Return a list of intersection results

        :param parapy.geom.Surface surface:
        :rtype: list[dict[str, any]]
        """
        from OCC.wrapper.GeomAPI import GeomAPI_IntCS
        ints = GeomAPI_IntCS(self.Handle_Geom_Curve,
                             surface.Handle_Geom_Surface)
        if not ints.IsDone():
            raise Exception("intersect computation failed.")
        results = []
        for i in range(1, ints.NbPoints()+1):
            pt = ints.Point(i).point
            u, v, w = ints.Parameters(i)
            results.append({'point': pt, 'u' : w, 'uv': (u,v)})
        return results

    def intersection_point(self, surface):
        """

        :param parapy.geom.Surface surface:
        :rtype: parapy.geom.Point
        """
        ints = self.surface_intersection(surface)
        if len(ints) == 0:
            raise Exception("there was no intersection")
        elif len(ints) > 1:
            raise Exception("there were multiple intersections, "
                            "use surface_intersection results")
        else:
            return ints[0]["point"]

    def dynamic_type(self, Handle_Geom_Curve=None):
        """return as string naming class of OCC

        :param OCC.Geom.Handle_Geom_Curve Handle_Geom_Curve:
        :rtype: str
        """
        handle = Handle_Geom_Curve or self.Handle_Geom2d_Curve
        return handle.DynamicType().Name()

    def is_dynamic_subclass_of(self, name):
        """Name is one of:

        - "Geom_BSplineCurve"
        - "Geom_BezierCurve"

        http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeom__Curve.html

        :param str name:
        :rtype: bool
        """
        return self._Geom2d_Curve.DynamicType().SubType(name)

    # =========================================================================
    # transformations
    # =========================================================================
    @Attribute
    def reversed(self):
        """Return a new curve that is the reversed of this curve

        :rtype Curve2d
        """
        h_geom_curve = self._Geom2d_Curve.Reversed()
        # downcast to similar type
        crv = ClonedCurve2d(h_geom_curve)
        if crv.u1!=self.u1 or crv.u2!=self.u2:
            warnings.warn("u1, and u2 were changed, probably because this "
                          "is a trimmed curve")
        return crv

    @Attribute
    def normalized(self):
        """New curve with u1, u2 normalized to 0-1.

        :rtype: Curve2d
        """
        raise NotImplementedError()

    @Attribute
    def Handle_Geom2d_BSplineCurve(self):
        """

        :rtype: OCC.Geom2d.Handle_Geom2d_BSplineCurve
        """
        raise NotImplementedError()

    @Attribute
    def bspline(self):
        """BSplineCurve instance

        :rtype: BSplineCurve
        """
        raise NotImplementedError()

    @Attribute
    def bezier(self):
        """Returns a single or a list of BezierCurve objects

        :rtype: list[BezierCurve] | BezierCurve
        """
        raise NotImplementedError()

    def directed(self, vector):
        """Return a new curve based on the given ``vector`` and the
        ``direction_vector`` of this
        curve. If these vectors have a positive inner product, the
        original curve is returned,]
        otherwise the reversed of this curve.

        :rtype Curve2d
        """
        prod = vector * self.direction_vector
        if prod >= 0:
            return self
        else:
            return self.reversed

    def _transformed(self, trsf, **info):
        """ Transform the Geom2d_Curve, not the wire like Wire_ does.
        Return a :py:`Handle_Geom_Geometry` instance, which we know is a
        :py:`Handle_Geom_Curve`

        :param OCC.gp.gp_Trsf trsf:
        :param parapy.geom.Position position:
        :rtype: Curve2d
        """
        raise NotImplementedError("have to do something with **info here.")
        new_handle = self._Geom2d_Curve.Transformed(trsf)
        handle, class_ = Handle_Geom2d_Curve2ParaPy(new_handle)
        return class_(Handle_Geom2d_Curve=handle)

    # =========================================================================
    # Bounding box
    # =========================================================================
    @Attribute
    def _Bnd_Box(self):
        """
        :rtype: OCC.Bnd.Bnd_Box2d
        """
        # FIXME: control-points are used splines, this may be wrong.
        #        Consider using mesh and BrepBndLib
        box = Bnd_Box2d()
        # FIXME: tolerance hard-coded
        BndLib_Add2dCurve.Add(self._Adaptor2d_Curve, 1e-8, box)
        return box

    @Attribute
    def _bbox_bounds(self):
        return tuple(self._Bnd_Box.Get())


def Handle_Geom2d_Curve2ParaPy(Handle_Geom2d_Curve):
    """Tries to find most corresponding ParaPy class to
    Handle_Geom_Curve object

    :rtype tuple[OCC.Geom2d.Handle_Geom2d_Curve, type]
    """
    return Handle_Geom2d_Curve, Curve2d


class ClonedCurve2d(Base):
    """Can be used to make a new clone of an existing curve.

    Usage::
    
        ClonedCurve2d(other_curve2d, *args, **kwargs)
        ClonedCurve2d([other_curve2d, other_curve2d, ...], *args, **kwargs)
        ClonedCurve2d(built_from=other_curve2d, **kwargs)
        
    Where ``other_curve2d`` is one of:
    
    * parapy.geom.Curve2d
    * OCC.Geom.Handle_Geom2d_Curve
    """

    __initargs__ = ["curve_in"]
    __newargs__ = ["curve_in"]

    curve_in = Input(doc="The object to clone. Can be another curve, "
                         "Edge_ or Handle_Geom_Curve")

    @classmethod
    def make(cls, curve_in, *args, **kwargs):
        if isinstance(curve_in, Curve2d):
            class_ = curve_in._new_curve_type
            h_geom_curve = curve_in._new_handle()
            return class_(Handle_Geom2d_Curve=h_geom_curve, *args, **kwargs)
        elif handle_is_instance(curve_in, Handle_Geom2d_Curve):
            h_geom_curve, class_ = Handle_Geom2d_Curve2ParaPy(curve_in)
            return class_(Handle_Geom2d_Curve=h_geom_curve, *args, **kwargs)
        else:
            raise Exception("curve_in was not a valid Curve, "
                            "Edge_ or Handle_Geom_Curve.")

    def __new__(cls, curve_in, *args, **kwargs):
        """tests for iterables"""
        if hasattr(curve_in, "__iter__"):
            return [cls.make(obj, *args, **kwargs) for obj in curve_in]
        else:
            return cls.make(curve_in, *args, **kwargs)


# =============================================================================
# Conversion 2d to 3d and vice versa
# =============================================================================
# TODO: position is changed to not be defaulting and use global XY plane
class Curve3d2d(Curve2d):
    """Allows for conversion from a 3d curve to a 2d curve.
    This function builds (in the
    parametric space of the plane XY) a 2D curve equivalent to the 3D curve
    curve_in. The 3D curve curve_in is considered to be located in the
    plane plane XY.

    Note that this object will downgrade to Curve2d. Use Curve.curve2d a
    Curve that retains type.

    See: http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeomAPI_268006e895c4b50efc77ed99c5b6c9df.html#268006e895c4b50efc77ed99c5b6c9df
    """

    __initargs__ = ["curve_in"]

    #: :type: parapy.geom.Curve | Curve2d
    curve_in = Input(doc="3d curve in")

    #: :type: parapy.geom.Position
    position = Input(OXY, defaulting=True)

    @Attribute(private=True)
    def Handle_Geom2d_Curve(self):
        """Can be used to convert a 3d curve to a 2d curve.
        The conversion, for now, is always done using XY plane.
        So, the z coordinate is expected to be zero everywhere.

        :rtype: OCC.Geom2d.Handle_Geom2d_Curve
        """
        return GeomAPI__To2d(self.curve_in.Handle_Geom_Curve,
                             self.position.gp_Pln)

    @Attribute
    def Handle_Geom_Curve(self):
        """Can be used to convert a 3d curve to a 2d curve.
        The conversion is always done using XY plane.
        So, the z coordinate is expected to be zero everywhere.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return GeomAPI__To3d(self.Handle_Geom2d_Curve,
                             self.position.gp_Pln)


# TODO: position is changed to not be defaulting and use global XY plane
class Curve2d3d(Curve):
    """Builds a 3D curve equivalent to the 2D curve C 
    described in the parametric space defined by the local 
    coordinate system of plane P.

    Note that this object will downgrade to Curve. Use Curve2d.curve to get a
    Curve that retains type.

    See: http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classGeomAPI_268006e895c4b50efc77ed99c5b6c9df.html#268006e895c4b50efc77ed99c5b6c9df
    """

    __initargs__ = ["curve_in"]

    #: :type: Curve2d
    curve_in = Input(doc="2d curve in")

    #: :type: parapy.geom.Position
    position = Input(OXY, defaulting=True)

    @Attribute(private=True)
    def Handle_Geom2d_Curve(self):
        """Can be used to convert a 3d curve to a 2d curve.
        The conversion, for now, is always done using XY plane.
        So, the z coordinate is expected to be zero everywhere.

        :rtype: OCC.Geom2d.Handle_Geom2d.Curve
        """
        return self.curve_in.Handle_Geom2d_Curve

    @Attribute(private=True)
    def Handle_Geom_Curve(self):
        """Can be used to convert a 3d curve to a 2d curve.
        The conversion is always done using XY plane.
        So, the z coordinate is expected to be zero everywhere.

        :rtype: OCC.Geom.Handle_Geom_Curve
        """
        return GeomAPI__To3d(self.Handle_Geom2d_Curve, self.position.gp_Pln)

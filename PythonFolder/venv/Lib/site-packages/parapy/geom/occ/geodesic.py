#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import warnings

from parapy.core import Attribute, Input, Part, val
from parapy.geom.generic.positioning import Point
from parapy.geom.occ.curve import FittedCurve
from parapy.geom.occ.edge import FoldedCurve
from parapy.geom.occ.surface import Plane, Surface


class GeodesicOffsetCurve(FoldedCurve):
    """Perform a geodesic offset on :attr:`curve` along :attr:`surface` by
    :attr:`offset`. The offset direction is the cross product of the local
    surface normal and the :attr:`curve` tangent. Specify a negative offset
    to reverse the offset direction. Usage:

    >>> # offsetting an edge along a BSplineSurface
    >>> from parapy.geom import Point, BSplineSurface  #, GeodesicOffsetCurve
    >>> from parapy.geom.occ.geodesic import GeodesicOffsetCurve
    >>> points = ((Point(-1, -1, 0), Point(-1, 0, 2), Point(-1, 1, 0)),
    ...           (Point(0, -1, 2), Point(0, 0, -2), Point(0, 1, 2)),
    ...           (Point(1, -1, 0), Point(1, 0, 2), Point(1, 1, 0)))
    >>> face = BSplineSurface(points)
    >>> edge = face.edges[0]
    >>> offset = -0.2
    >>> offset_edge = GeodesicOffsetCurve(surface=face,
    ...                                   curve=edge,
    ...                                   offset=offset)

    .. note:: this class works in geometric space. As such, the resulting
        curve will not be restricted to the bounds of the input surface / face.
        To achieve that, you can use a :attr:`~parapy.geom.Common` operation
        between this curve and the original face. Moreover, if this curve falls
        short of reaching the boundaries, it is the user's responsibility to
        provide and input :attr:`curve` that is extended long enough.
    """

    __initargs__ = ["curve", "surface", "offset"]

    #: Curve which is offset along :attr:`surface`
    #: :type: parapy.geom.occ.Curve
    curve = Input()

    #: Surface along which the :attr:`curve` is offset
    #: :type: parapy.geom.Surface
    surface = Input()

    #: Value with which to offset :attr:`curve` along :attr:`surface`.
    #: The offset direction is the cross product of the local surface normal
    #: and curve.tangent. Specify a negative offset to reverse the direction.
    #: :type: float
    offset = Input()

    #: Number of sampling points used to generate the geodesic offset curve.
    #: Higher numbers tend to improve accuracy, but can also lead to higher
    #: computational times and may result in a less smooth result.
    #: :type: int
    nb_sample_points = Input(20)

    #: Tolerance used for curve fitting in UV space. This tolerance indicates
    #: the maximum allowed distance between offset UV-points and the fitted
    #: curve.
    #: :type: float
    tolerance_2d = Input(1e-4)

    #: Minimum degree used for the FittedCurve fitting algorithm.
    #: :type: int
    min_degree_2d = Input(1)

    #: Maximum degree used for the FittedCurve fitting algorithm.
    #: :type: int
    max_degree_2d = Input(3)

    #: Specify what occurs when invalid results are generated.
    #: :type: str
    on_invalid = Input("warn",
                       validator=val.OneOf(["raise", "warn", "ignore"]))

    #: Show intermediate steps in GUI?
    #: :type: bool
    show_details = Input(False)

    @Attribute
    def parameters(self):
        """Parameter points (x=u, y=v, z=0) through which the offset fits.

        :rtype: list[parapy.geom.Point]
        """
        curve = self.curve
        surface = self.surface
        offset = self.offset
        nb_sample_points = self.nb_sample_points

        parameters = curve.equispaced_parameters(self.nb_sample_points)

        lst = []
        nb_ignored_points = 0
        for i, u in enumerate(parameters):
            point = curve.point(u)
            tangent = curve.tangent(u)
            plane = Plane(point, tangent)
            edges_ints = Surface.intersection_curves(surface, plane)
            nb_ints = len(edges_ints)
            if nb_ints == 0:
                nb_ignored_points += 1
                continue
            elif nb_ints > 1:
                edge_ints, u0 = find_edge_containing_point(edges_ints, point)
            else:
                edge_ints = edges_ints[0]
                u0 = edge_ints.parameter_at_point(point)
            pt_offset = edge_ints.point_at_length(offset, u0=u0)
            if surface.is_point_inside(pt_offset):
                u, v = surface.parameter(pt_offset)
                lst.append(Point(u, v, 0))
            else:
                nb_ignored_points += 1
                continue

        if nb_ignored_points == nb_sample_points:
            msg = ("\nNone of the sampling points lie inside the face, likely "
                   "because the offset distance is too large (c.q. surface too"
                   " small) in combination with the direction of the offset. "
                   "Check the direction of your offset and/or consider "
                   "extending the surface prior to this operation. {}")
            # if self.on_invalid == "raise":
            #     raise RuntimeError(msg.format(self))
            # elif self.on_invalid == "warn":
            #     warnings.warn(msg.format(self), RuntimeWarning)
            # else:
            #     pass
            raise RuntimeError(msg.format(self))

        elif nb_ignored_points > 0:
            msg = ("\n{}/{} of the sample points are ignored because they are "
                   "not inside the face. By extending the surface this can be "
                   "avoided. {}")
            if self.on_invalid == "raise":
                raise RuntimeError(msg.format(nb_ignored_points,
                                              nb_sample_points,
                                              self))
            elif self.on_invalid == "warn":
                warnings.warn(msg.format(nb_ignored_points,
                                         nb_sample_points,
                                         self), RuntimeWarning)
            else:
                pass

        return lst

    @Part
    def curve_in(self):
        """Fitted curve through :attr:`parameters`, the uv-parameters.
        """
        return FittedCurve(hidden=not self.show_details,
                           points=self.parameters,
                           min_degree=self.min_degree_2d,
                           max_degree=self.max_degree_2d,
                           tolerance=self.tolerance_2d)

    @Attribute
    def surface_in(self):
        """Surface on which :attr:`curve_in` is folded.

        :rtype: parapy.geom.Surface
        """
        return self.surface


def find_edge_containing_point(edges, point, tolerance=1e-3):
    """Find the edge from :attr:`edges` on which :attr:`point` lies within
    :attr:`tolerance`.

    :param list[parapy.geom.occ.Edge] edges:
    :param list[parapy.geom.Point] point:
    :param float tolerance:
    :rtype: tuple[parapy.geom.occ.Edge, float]
    """
    for edge in edges:
        dct = edge.projected_point(point,
                                   precision=tolerance,
                                   AdjustToEnds=False)
        if dct["distance"] < tolerance:
            return edge, dct["u"]
    raise RuntimeError("failed to find edge")


if __name__ == '__main__':
    from parapy.geom import BSplineSurface, ExtendedCurve
    from parapy.gui import display

    points = ((Point(-1, -1, 0), Point(-1, 0, 2), Point(-1, 1, 0)),
              (Point(0, -1, 2), Point(0, 0, -2), Point(0, 1, 2)),
              (Point(1, -1, 0), Point(1, 0, 2), Point(1, 1, 0)))
    face = BSplineSurface(points)
    edge = face.edges[0]

    lst = []
    for offset in [-0.1, -0.2, -0.5, -1.0, -1.5, -2.0]:
        curve = GeodesicOffsetCurve(surface=face,
                                    curve=edge,
                                    offset=offset)
        lst.append(curve)
        curve.parameters

    display(lst)

    # extensions
    edge = ExtendedCurve(edge, distance=edge.length, mirrored_extent=True)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Module defines abstract :class:`Surface` class and concrete derived classes
to create various surface objects.
"""

import math
import os
import warnings

from OCC.wrapper.Adaptor3d import Adaptor3d_CurveOnSurface
from OCC.wrapper.BRepBuilderAPI import BRepBuilderAPI_MakeFace
from OCC.wrapper.BRepExtrema import BRepExtrema_ExtPF
from OCC.wrapper.BRepGProp import BRepGProp__SurfaceProperties
from OCC.wrapper.BSplCLib import BSplCLib__Reparametrize
from OCC.wrapper.Bnd import Bnd_Box
from OCC.wrapper.BndLib import BndLib_AddSurface
from OCC.wrapper.GProp import GProp_GProps
from OCC.wrapper.Geom import (
    Geom_BSplineSurface, Geom_BezierSurface, Geom_ConicalSurface,
    Geom_CylindricalSurface, Geom_Plane, Geom_RectangularTrimmedSurface,
    Geom_SphericalSurface, Geom_SurfaceOfLinearExtrusion,
    Geom_SurfaceOfRevolution, Geom_ToroidalSurface, Handle_Geom_BSplineSurface,
    Handle_Geom_BezierSurface, Handle_Geom_BoundedSurface,
    Handle_Geom_ConicalSurface, Handle_Geom_CylindricalSurface,
    Handle_Geom_Plane, Handle_Geom_RectangularTrimmedSurface,
    Handle_Geom_SphericalSurface, Handle_Geom_Surface,
    Handle_Geom_SurfaceOfLinearExtrusion, Handle_Geom_SurfaceOfRevolution,
    Handle_Geom_SweptSurface,
    Handle_Geom_ToroidalSurface)  # TODO (RvD): re-enable after reworking to OCC7.1.0; Handle_Geom_BSplineSurface_DownCast,; TODO (RvD): re-enable after reworking to OCC7.1.0; Handle_Geom_Plane_DownCast
from OCC.wrapper.Geom2dAdaptor import Geom2dAdaptor_HCurve
from OCC.wrapper.GeomAPI import (
    GeomAPI_ExtremaCurveSurface, GeomAPI_ExtremaSurfaceSurface,
    GeomAPI_PointsToBSplineSurface)
from OCC.wrapper.GeomAbs import GeomAbs_C0, GeomAbs_C1, GeomAbs_C2
from OCC.wrapper.GeomAdaptor import (
    GeomAdaptor_HCurve, GeomAdaptor_HSurface,
    GeomAdaptor_Surface)
from OCC.wrapper.GeomConvert import (
    GeomConvert_ApproxSurface, GeomConvert_BSplineSurfaceKnotSplitting,
    GeomConvert__SplitBSplineSurface, GeomConvert__SurfaceToBSplineSurface)
from OCC.wrapper.GeomFill import (
    GeomFill_BSplineCurves, GeomFill_BoundWithSurf,
    GeomFill_ConstrainedFilling, GeomFill_CoonsStyle, GeomFill_CurvedStyle,
    GeomFill_IsCorrectedFrenet, GeomFill_IsFixed, GeomFill_Pipe,
    GeomFill_StretchStyle)
from OCC.wrapper.GeomLib import GeomLib_IsPlanarSurface, GeomLib__ExtendSurfByLength
from OCC.wrapper.GeomPlate import (
    GeomPlate_BuildPlateSurface,
    GeomPlate_CurveConstraint, GeomPlate_MakeApprox)
from OCC.wrapper.ShapeAnalysis import ShapeAnalysis_Surface
from OCC.wrapper.TColGeom import TColGeom_SequenceOfCurve
from OCC.wrapper.gp import gp_Ax1
from OCC.utils.top import find_uv_in_face, point_in_face, uv_in_face
from OCC.utils.utilities import handle_deref_class, handle_is_instance

from parapy.core import (
    Attribute, Input, derived, getattrs, lazy_hasattr, list_of_numbers, val)
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.part import PartNoParsing, PrivatePartNoParsing
from parapy.geom.generic.geom_base import GeomBase
from parapy.geom.generic.positioning import (
    AbstractPoint, VZ, XOY, orthogonal_vector)
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.curve import (
    Circle, Curve, Handle_Geom_Curve2ParaPy, UIso, VIso)
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.mixins import TransformationMixin
from parapy.geom.occ.patched.tcol import *  # @UnusedWildImport
from parapy.globs import SUPPORT_EMAIL

TOLDEGEN = 1.0e-7


def _Surface_Handle_Geom_Surface_validator(value, obj, _):
    return handle_is_instance(value, obj.__Handle_Geom_Surface__)


class Surface(DrawableShape, TransformationMixin):
    __icon__ = os.path.join(ICN_DIR, 'surface.png')
    TOPODIM = 2
    TOPOLEVEL = 4  # 7: Vertex, 6: Edge, 5: Wire, 4: Face, 3: Shell, 2: Solid, 1: CompSolid, 0: Compound

    __Handle_Geom_Surface__ = Handle_Geom_Surface
    FaceClass = None  # will be assigned by Face
    ShellClass = None  # will be assigned by Shell

    _transformation = Input(None, "contains possible _transformation info")

    # --- Surface representations ---
    @Input(validator=_Surface_Handle_Geom_Surface_validator, private=True)
    def Handle_Geom_Surface(self):
        raise NotImplementedError("should have been implemented in subclass")

    @Attribute
    def _Geom_Surface(self):
        """The underlying Geom_Surface object that :attr:`Handle_Geom_Surface`
        deferres to.

        :rtype: OCC.Geom.Geom_Surface
        """
        msg = ("Surface._Geom_Surface has been deprecated, use "
               "Surface.Handle_Geom_Surface instead")
        warnings.warn(msg, ParaPyDeprecationWarning, stacklevel=4)
        handle = self.Handle_Geom_Surface
        cls = handle_deref_class(handle)
        srf = cls.__new__(cls)
        srf.this = handle.get()
        return srf

    @Attribute
    def _Adaptor3d_Surface(self):
        return GeomAdaptor_Surface(self.Handle_Geom_Surface)

    @Attribute(private=True)
    def Handle_Geom_BSplineSurface(self):
        """B-Spline representation of this surface.

        :rtype: OCC.Geom.Handle_Geom_Surface
        """
        return GeomConvert__SurfaceToBSplineSurface(self.Handle_Geom_Surface)

    @Attribute
    def bspline(self):
        """B-Spline representation of this surface.

        :rtype: BSplineSurface_"""
        return BSplineSurface_(
            Handle_Geom_Surface=self.Handle_Geom_BSplineSurface)

    @Attribute
    def _ShapeAnalysis_Surface(self):
        return ShapeAnalysis_Surface(self.Handle_Geom_Surface)

    @property
    def basis_surface(self):
        return self

    # FIXME (RvD): Get rid of __Handle_Geom_Surface__, use type of
    # /fixme Handle_Geom_Surface instead.
    def _new_handle(self):
        """Returns a new Handle_Geom_Surface copy.

        :rtype: OCC.Geom.Handle_Geom_Surface
        """
        return self.__Handle_Geom_Surface__(self.Handle_Geom_Surface)

    @property
    def _new_surface_type(self):
        """Used by clone and transform classes to determine appropriate
        constructor class for cloning this surface.

        :rtype: type
        """
        return Surface

    def _transformed(self, trsf, **info):
        """:type: trsf: OCC.gp.gp_Trsf"""
        new_handle = self.Handle_Geom_Surface.Transformed(trsf)
        handle, class_ = Handle_Geom_Surface2ParaPy(new_handle)
        return class_(Handle_Geom_Surface=handle,
                      _transformation=[trsf, self, info])

    @Attribute(private=True)
    def builder(self):
        builder = BRepBuilderAPI_MakeFace(self.Handle_Geom_Surface, TOLDEGEN)
        if builder.IsDone():
            return builder
        else:
            raise RuntimeError("Converting surface to face failed.")

    @Attribute(private=True)
    def TopoDS_Shape(self):
        return self.builder.Shape()

    @Attribute(private=True)
    def TopoDS_Face(self):
        return self.builder.Face()

    @Attribute
    def brep(self):
        topods_shape = self.TopoDS_Shape
        return self.FaceClass(TopoDS_Shape=topods_shape)

    @Attribute
    def outer_wire(self):
        """The outer wire is the outer-most trimming loop used to build this
        face from its basis-surface.

        :rtype: parapy.geom.occ.wire.Wire_
        """
        return self.brep.outer_wire

    @Attribute
    def inner_wires(self):
        """List of all the inner wires (holes) used while trimming this face
        from its basis-surface.

        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        return self.brep.inner_wires

    @Attribute  # don't trickle down
    def faces(self):
        return self.brep.faces

    @Attribute
    def wires(self):
        return self.brep.wires

    @Attribute
    def edges(self):
        return self.brep.edges

    @Attribute
    def vertices(self):
        return self.brep.vertices

    # --- Surface properties ---
    @Attribute
    def uv_bounds(self):
        """
        :returns: (u1, u2, v1, v2)
        :rtype: (float, float, float, float)
        """
        return tuple(self.Handle_Geom_Surface.Bounds())

    @Attribute
    def u1(self):
        """Start parameter of this surface, in u-direction.

        :rtype: float
        """
        return self.uv_bounds[0]

    @Attribute
    def u2(self):
        """End parameter of this surface, in u-direction.

        :rtype: float
        """
        return self.uv_bounds[1]

    @Attribute
    def v1(self):
        """Start parameter of this surface, in v-direction.

        :rtype: float
        """
        return self.uv_bounds[2]

    @Attribute
    def v2(self):
        """End parameter of this surface, in v-direction.

        :rtype: float
        """
        return self.uv_bounds[3]

    u_min = u1
    u_max = u2
    v_min = v1
    v_max = v2

    # FIXME (RvD): return tuple (u, v), not a point
    @Attribute
    def uv_center(self):
        """Return uv point at center of uv_bounds.

        :rtype: Point
        """
        u1, u2, v1, v2 = self.uv_bounds
        u = u1 + (u2 - u1) / 2.0
        v = v1 + (v2 - v1) / 2.0
        return Point(u, v)

    @Attribute
    def uv_center_point(self):
        """Return uv point at center of uv_bounds
        :rtype: Point
        """
        u1, u2, v1, v2 = self.uv_bounds
        u = u1 + (u2 - u1) / 2.0
        v = v1 + (v2 - v1) / 2.0
        return self.point(u, v)

    @Attribute
    def uv_center_normal(self):
        """The normal vector at uv_center
        :rtype: Vector
        """
        u1, u2, v1, v2 = self.uv_bounds
        u = u1 + (u2 - u1) / 2.0
        v = v1 + (v2 - v1) / 2.0
        return self.normal(u, v)

    @Attribute
    def uv_center_position(self):
        u1, u2, v1, v2 = self.uv_bounds
        u = u1 + (u2 - u1) / 2.0
        v = v1 + (v2 - v1) / 2.0
        return self.get_position(u, v)

    @Attribute
    def continuity(self):
        """Return the continuity of the surface:

        - 0 -> C0: only geometric continuity.
        - 1 -> G1: for each point on the curve, the tangent vectors
            "on the right" and "on the left" are collinear with the same
            orientation.
        - 2 -> C1: continuity of the first derivative. The "C1" curve is also
            "G1" but, in addition, the tangent vectors " on the right" and
            "on the left" are equal.
        - 3 -> G2: for each point on the curve, the normalized normal vectors
            "on the right" and "on the left" are equal.
        - 4 -> C2: continuity of the second derivative.
        - 5 -> C3: continuity of the third derivative. 
        - 6 -> CN: continuity of the N-th derivative, whatever is the value
            given for N (infinite order of continuity).

        :rtype: int
        """
        return min(self.u_continuity, self.v_continuity)

    @Attribute
    def u_continuity(self):
        """Return the continuity of the surface in u-direction:

        - 0 -> C0: only geometric continuity.
        - 1 -> G1: for each point on the curve, the tangent vectors
            "on the right" and "on the left" are collinear with the same
            orientation.
        - 2 -> C1: continuity of the first derivative. The "C1" curve is also
            "G1" but, in addition, the tangent vectors " on the right" and
            "on the left" are equal.
        - 3 -> G2: for each point on the curve, the normalized normal vectors
            "on the right" and "on the left" are equal.
        - 4 -> C2: continuity of the second derivative.
        - 5 -> C3: continuity of the third derivative. 
        - 6 -> CN: continuity of the N-th derivative, whatever is the value
            given for N (infinite order of continuity).

        :rtype: int
        """
        return self._Adaptor3d_Surface.UContinuity()

    @Attribute
    def v_continuity(self):
        """Return the continuity of the surface in v-direction:

        - 0 -> C0: only geometric continuity.
        - 1 -> G1: for each point on the curve, the tangent vectors
            "on the right" and "on the left" are collinear with the same
            orientation.
        - 2 -> C1: continuity of the first derivative. The "C1" curve is also
            "G1" but, in addition, the tangent vectors " on the right" and
            "on the left" are equal.
        - 3 -> G2: for each point on the curve, the normalized normal vectors
            "on the right" and "on the left" are equal.
        - 4 -> C2: continuity of the second derivative.
        - 5 -> C3: continuity of the third derivative. 
        - 6 -> CN: continuity of the N-th derivative, whatever is the value
            given for N (infinite order of continuity).

        :rtype: int
        """
        return self._Adaptor3d_Surface.VContinuity()

    @Attribute
    def is_u_closed(self):
        """determines if surface is closed in u-direction.

        :rtype: bool
        """
        return bool(self._Adaptor3d_Surface.IsUClosed())

    @Attribute
    def is_v_closed(self):
        """determines if surface is closed in v-direction.

        :rtype: bool
        """
        return bool(self._Adaptor3d_Surface.IsVClosed())

    @Attribute
    def is_closed(self):
        """determines if surface is closed in both u- and v- direction.

        :rtype: bool
        """
        return bool(self.is_u_closed and self.is_v_closed)

    @Attribute
    def is_u_periodic(self):
        """determines if surface is periodic in u-direction

        :rtype: bool
        """
        return self._Adaptor3d_Surface.IsUPeriodic()

    @Attribute
    def is_v_periodic(self):
        """determines if surface is periodic in u-direction

        :rtype: bool
        """
        return self._Adaptor3d_Surface.IsVPeriodic()

    @Attribute
    def is_periodic(self):
        """determines if surface is periodic in u-direction

        :rtype: bool
        """
        return self.is_u_periodic and self.is_v_periodic

    @Attribute
    def _Surface_GProps(self):
        """Attaches a properties object to this instance.
        This properties object will expose surface properties like area, etc.

        :rtype: GProp_GProps
        """
        props = GProp_GProps()
        BRepGProp__SurfaceProperties(self.TopoDS_Shape, props)
        return props

    @Attribute
    def area(self):
        """Surface area.

        :rtype: float
        """
        return self._Surface_GProps.Mass()

    @Attribute
    def cog(self):
        """Center of mass of this surface.

        :rtype: Point
        """
        gp_pnt = self._Surface_GProps.CentreOfMass()
        return Point(*gp_pnt.Coord())

    @Attribute
    def u_reversed(self):
        """Reverses the U direction of parametrization of me. The bounds of
        the surface are not modified. A copy of me is returned.

        :rtype: Surface
        """
        h_geom_surface = self.Handle_Geom_Surface.UReversed()
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)

    @Attribute
    def v_reversed(self):
        """Reverses the V direction of parametrization of me. The bounds of
        the surface are not modified. A copy of me is returned.

        :rtype: Surface
        """
        h_geom_surface = self.Handle_Geom_Surface.VReversed()
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)

    @Attribute
    def reversed(self):
        """Reverses the U&V direction of parametrization of me. The bounds of
        the surface are not modified. A copy of me is returned.

        :rtype: Surface
        """
        h_geom_surface = self.Handle_Geom_Surface.UReversed().VReversed()
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)

    # @Attribute
    # def c0_decomposed_surfaces(self):
    #     return self.decomposed_surfaces(1)
    #
    # @Attribute
    # def c1_decomposed_surfaces(self):
    #     return self.decomposed_surfaces(2)
    #
    # @Attribute
    # def c2_decomposed_surfaces(self):
    #     return self.decomposed_surfaces(3)

    # @Attribute
    # def normalized(self):
    #     """Can be used in @Part expression"""
    #     return self.reparametrize(0, 1, 0, 1)

    # --- Feature recognition ---
    #: Is the surface cylindrical? Defaults to False.
    #: :rtype: bool
    is_cylindrical = Attribute(False)

    #: Is the surface conical? Defaults to False.
    #: :rtype: bool
    is_conical = Attribute(False)

    @Attribute
    def is_planar(self):
        """
        :rtype: bool
        """
        test = GeomLib_IsPlanarSurface(self.Handle_Geom_Surface).IsPlanar()
        return bool(test)

    @Attribute
    def plane_normal(self):
        """Determines the normal vector in case the surface is planar

        :rtype: Vector
        :raises RuntimeError: if surface isn't planar. Use .normal() instead.
        """
        test = GeomLib_IsPlanarSurface(self.Handle_Geom_Surface)
        if not test.IsPlanar():
            msg = ("Surface isn't planar. Use .normal(u, v) instead. "
                   "Object: {}.")
            raise RuntimeError(msg.format(self))
        else:
            gp_Pln = test.Plan()
            gp_dir = gp_Pln.Axis().Direction()
            return Vector(*gp_dir.Coord())

    def UIso(self, value, **kwargs):
        """U isoparametric curve fixed at u-parameter ``value``.

        :param float value: u-parameter.
        :param dct kwargs: extra inputs for :class:`UIso`.
        :rtype: UIso
        """
        return UIso(surface=self, value=value, **kwargs)

    def VIso(self, value, **kwargs):
        """V isoparametric curve fixed at v-parameter ``value``.

        :param float value: v-parameter.
        :param dct kwargs: extra inputs for :class:`VIso`.
        :rtype: VIso
        """
        return VIso(surface=self, value=value, **kwargs)

    def UIsoCurves(self, nb, **kwargs):
        """``nb`` U isoparametric curves fixed at u-parameters evenly
        distributed from :attr:`u1`-:attr:`u2`.

        :param int nb: number of iso-curves
        :param dct kwargs: extra inputs for :class:`UIso`.
        :rtype: list[UIso]
        """
        return [UIso(surface=self, value=value, **kwargs) for
                value in list_of_numbers(self.u1, self.u2, nb)]

    def VIsoCurves(self, nb, **kwargs):
        """``nb`` V isoparametric curves fixed at v-parameters evenly
        distributed from :attr:`v1`-:attr:`v2`.

        :param int nb: number of iso-curves
        :param dct kwargs: extra inputs for :class:`VIso`.
        :rtype: list[VIso]
        """
        return [VIso(surface=self, value=value, **kwargs)
                for value in list_of_numbers(self.v1, self.v2, nb)]

    def point(self, u, v):
        """Returns a point at ``u``- and ``v``-parameters. Usage:

        >>> from parapy.geom import RectangularFace
        >>> srf = RectangularFace(width=1, length=2)
        >>> srf.point(0.3, 0.6)
        Point(0.3, 0.6, 0.0)

        :param float u: u parameter on surface.
        :param float v: v parameter on surface.
        :rtype: Point
        """
        gp_pnt = self._Adaptor3d_Surface.Value(u, v)
        return Point(*gp_pnt.Coord())

    def points(self, n, m):
        msg = ("Surface.points() is deprecated. Use "
               "Surface.equispaced_points() instead. Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.equispaced_points(n, m)

    def equispaced_points(self, n, m):
        """Returns ``n`` x ``m`` points. ``n`` corresponds to u-direction,
        ``m`` to v-direction. Usage:

        >>> from parapy.geom import RectangularFace
        >>> srf = RectangularFace(width=1, length=2)
        >>> srf.equispaced_points(2, 3)  # doctest: +ELLIPSIS
        [[Point(-0.5, -1.0, 0.0), Point(-0.5, 0.0, 0.0), Point(-0.5, 1.0, 0.0)], ...]

        :param int n: number of points in u-direction
        :param int m: number of points in v-direction
        :rtype: list[list[Point]]
        """
        surf = self._Adaptor3d_Surface
        lstu = list_of_numbers(self.u1, self.u2, n)
        lstv = list_of_numbers(self.v1, self.v2, m)
        return [[Point(*surf.Value(u, v).Coord()) for v in lstv] for u in lstu]

    # FIXME (TBD): what if d1u is zero vector?. Author: RvD.
    def get_position(self, u, v):
        """Get :class:`Position` object at ``u``, ``v``. Location of the
        result lies at .point(u, v), x-vector of Orientation aligned with
        local u-tangent, y-vector alinged with local v-tangent. As such, the
        z-vector will be the local surface normal. Usage:

        >>> from parapy.geom import RectangularFace
        >>> srf = RectangularFace(width=1, length=2)
        >>> srf.get_position(0.3, 0.6)
        Position(Point(0.3, 0.6, 0.0))

        :param float u: u parameter on surface.
        :param float v: v parameter on surface.
        :rtype: Position
        """
        pt, d1u, d1v = gp_Pnt(), gp_Vec(), gp_Vec()
        self._Adaptor3d_Surface.D1(u, v, pt, d1u, d1v)
        pt = Point(*pt.Coord())

        # do not attempt to normalize a zero-vector
        x, y, z = d1u = Vector(*d1u.Coord())
        if x != 0 or y != 0 or z != 0:
            d1u = d1u.normalized

        # do not attempt to normalize a zero-vector
        x, y, z = d1v = Vector(*d1v.Coord())
        if x != 0 or y != 0 or z != 0:
            d1v = d1v.normalized

        w = d1u.cross(d1v)
        orient = Orientation(x=d1u, z=w)
        return Position(pt, orient)

    def parameter(self, point, precision=1.0e-3, failure='raise'):
        """Return (u, v) corresponding to ``point`` on (or close to the) this
        surface. Point is projected onto the surface. If gap between original
        ``point`` and project point on this surface is larger than
        ``precision``, this can either ignored, warned for or raised,
        depending on the value of ``failure`` (one of: 'ignore', 'warn',
        'raise'). Usage:

        >>> from parapy.geom import RectangularFace, Point
        >>> srf = RectangularFace(width=1, length=2)
        >>> srf.parameter(Point(0.3, 0.5, 0))
        (0.3, 0.5)

        :param Point point: point on or close to the surface.
        :param float precision:
        :param str failure: one of 'ignore', 'warn' or 'raise'
        :rtype: (float, float)
        """
        gp_pnt = gp_Pnt(*point)
        analysis = self._ShapeAnalysis_Surface
        gp_pnt2d = analysis.ValueOfUV(gp_pnt, precision)
        if analysis.Gap() > precision:
            if failure != 'ignore':
                msg = ("Gap ({}) between specified point ({}) and "
                       "corresponding point on surface larger than precision "
                       "({}). Specify a point closer to the surface or lower "
                       "precision. Object: {}.").format(analysis.Gap(), point,
                                                        precision, self)
                if failure == "raise":
                    raise RuntimeError(msg)
                elif failure == "warn":
                    warnings.warn(msg)
                else:
                    msg = ("Value ``{}`` is not one of ('raise', 'warn', "
                           "'ignore')")
                    raise ValueError(msg.format(failure))
        return gp_pnt2d.X(), gp_pnt2d.Y()

    def is_parameter_inside(self, u, v, include_edges=False):
        """Do ``u, v`` parameters lie inside this surface?

        >>> from parapy.geom import Point, RectangularSurface
        >>> srf = RectangularSurface(2, 2)
        >>> srf.is_parameter_inside(0, 0)
        True
        >>> srf.is_parameter_inside(1, 1)
        False
        >>> srf.is_parameter_inside(1, 1, include_edges=True)
        True
        >>> srf.is_parameter_inside(2, 2)
        False

        :param float u: u parameter
        :param float v: v parameter
        :param bool include_edges: if u, v in on one of the edges, does it also
            count as *in*?
        :rtype: bool
        """
        return uv_in_face(self.TopoDS_Face, u, v, include_edges=include_edges)

    def is_point_inside(self, point, precision=1.0e-7, include_edges=False):
        """Does ``point`` lie inside this surface?

        >>> from parapy.geom import Point, RectangularSurface
        >>> srf = RectangularSurface(2, 2)
        >>> srf.is_point_inside(Point(0, 0, 0))
        True
        >>> srf.is_point_inside(Point(1, 1, 0))
        False
        >>> srf.is_point_inside(Point(1, 1, 0), include_edges=True)
        True
        >>> srf.is_point_inside(Point(2, 2, 0))
        False
        >>> srf.is_point_inside(Point(0, 0, 0.001))
        False
        >>> srf.is_point_inside(Point(0, 0, 0.001), precision=2e-3)
        True

        :param parapy.geom.Point point: point to test.
        :param bool include_edges: if point is on one of the edges, does it also
            count as *in*?
        :param float precision: allowed gap between ``point`` and projection on
            basis surface.
        :rtype: bool
        """
        return point_in_face(self.TopoDS_Face, gp_Pnt(*point), tol=precision,
                             include_edges=include_edges)

    def find_parameter_inside(self):
        """Find a (u, v) parameter inside this surface.

        >>> from parapy.geom import Point, RectangularSurface
        >>> srf = RectangularSurface(2, 2)
        >>> srf.find_parameter_inside()
        (-0.17531412340000008, -0.8)

        :rtype: (float, float)
        """
        return find_uv_in_face(self.TopoDS_Face)

    def find_point_inside(self):
        """Find a point inside this surface.

        >>> from parapy.geom import Point, RectangularSurface
        >>> srf = RectangularSurface(2, 2)
        >>> srf.find_point_inside()
        Point(-0.1753141234, -0.8, 0.0)

        :rtype: parapy.geom.Point
        """
        u, v = self.find_parameter_inside()
        return self.point(u, v)

    def derivate(self, u, v, order_u=0, order_v=0):
        msg = 'derivate() deprecated, use derivative() instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.derivative(u, v, order_u=order_u, order_v=order_v)

    # FIXME (RvD): returns zero-vector if both orders are 0 or 1, etc.
    def derivative(self, u, v, order_u=0, order_v=0):
        """Returns NORMALIZED derivative at parameters ``u``, ``v``. Usage:

        >>> from parapy.geom import CylindricalSurface
        >>> srf = CylindricalSurface(radius=1, height=1)
        >>> srf.derivative(0, 0, order_u=1)
        Vector(0.0, 1.0, 0.0)
        >>> srf.derivative(0, 0, order_v=1)
        Vector(0.0, 0.0, 1.0)
        >>> srf.derivative(0, 0, order_u=2)
        Vector(-1.0, 0.0, 0.0)

        :param float u: u-parameter of point
        :param float v: v-parameter of point
        :param int order_u: order of derivative in u-direction
        :param int order_v: order of derivative in v-direction
        :rtype: Vector
        """
        if order_u == 0 and order_v == 0:
            msg = ("Surface.derivative: either order_u and/or order_v must be "
                   "non-zero, not both zero. Object: {}.")
            raise RuntimeError(msg.format(self))
        gp_vec = self._Adaptor3d_Surface.DN(u, v, order_u, order_v)
        x, y, z = gp_vec.Coord()
        vec = Vector(x, y, z)
        # do not attempt to normalize a zero-vector
        if x == 0 and y == 0 and z == 0:
            return vec
        else:
            return vec.normalized

    def u_tangent(self, u, v):
        """the NORMALIZED tangent vector in u-direction at paramater ``u``,
        ``v``. Usage:

        >>> from parapy.geom import CylindricalSurface
        >>> srf = CylindricalSurface(radius=1, height=1)
        >>> srf.u_tangent(0., 0.)
        Vector(0.0, 1.0, 0.0)

        :param float u: u-parameter on surface
        :param float v: v-parameter on surface
        :rtype: Vector
        """
        d1u = gp_Vec()
        self._Adaptor3d_Surface.D1(u, v, gp_Pnt(), d1u, gp_Vec())

        # do not attempt to normalize a zero-vector
        x, y, z = d1u = Vector(*d1u.Coord())
        if x != 0 or y != 0 or z != 0:
            return d1u.normalized
        else:
            return d1u

    def v_tangent(self, u, v):
        """the NORMALIZED tangent vector in v-direction at paramater ``u``,
        ``v``. Usage:

        >>> from parapy.geom import CylindricalSurface
        >>> srf = CylindricalSurface(radius=1, height=1)
        >>> srf.v_tangent(0, 0)
        Vector(0.0, 0.0, 1.0)

        :param float u: u-parameter on surface
        :param float v: v-parameter on surface
        :rtype: Vector
        """
        d1v = gp_Vec()
        self._Adaptor3d_Surface.D1(u, v, gp_Pnt(), gp_Vec(), d1v)

        # do not attempt to normalize a zero-vector
        x, y, z = d1v = Vector(*d1v.Coord())
        if x != 0 or y != 0 or z != 0:
            return d1v.normalized
        else:
            return d1v

    def normal(self, u, v):
        """The NORMALIZED normal vector at parameter ``u``, ``v``. Usage:

        >>> from parapy.geom import CylindricalSurface
        >>> srf = CylindricalSurface(radius=1, height=1)
        >>> srf.normal(0, 0)
        Vector(1.0, 0.0, 0.0)

        :param float u: u-parameter on surface
        :param float v: v-parameter on surface
        :rtype: Vector
        """
        d1u, d1v = gp_Vec(), gp_Vec()
        self._Adaptor3d_Surface.D1(u, v, gp_Pnt(), d1u, d1v)

        # do not attempt to normalize a zero-vector
        x, y, z = d1u = Vector(*d1u.Coord())
        if x != 0 or y != 0 or z != 0:
            d1u = d1u.normalized

        # do not attempt to normalize a zero-vector
        x, y, z = d1v = Vector(*d1v.Coord())
        if x != 0 or y != 0 or z != 0:
            d1v = d1v.normalized

        return Vector.cross(d1u, d1v)

    def Vu(self, *args, **kwargs):
        msg = 'Vu() deprecated, use u_tangent() instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.u_tangent(*args, **kwargs)

    def Vv(self, *args, **kwargs):
        msg = 'Vv() deprecated, use v_tangent() instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.v_tangent(*args, **kwargs)

    def Vw(self, *args, **kwargs):
        msg = 'Vw() deprecated, use normal() instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=2)
        return self.normal(*args, **kwargs)

    @Attribute
    def Vu_start(self):
        """U-tangent vector at (u1, v1).

        :rtype: Vector
        """
        msg = 'Vu_start deprecated, use u_tangent(u1, v1) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.u_tangent(self.u1, self.v1)

    @Attribute
    def Vu_end(self):
        """U-tangent vector at (u2, v2).

        :rtype: Vector
        """
        msg = 'Vu_end deprecated, use u_tangent(u2, v2) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.u_tangent(self.u2, self.v2)

    @Attribute
    def Vv_start(self):
        """V-tangent vector at (u1, v1).

        :rtype: Vector
        """
        msg = 'Vv_start deprecated, use v_tangent(u1, v1) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.v_tangent(self.u1, self.v1)

    @Attribute
    def Vv_end(self):
        """V-tangent vector at (u2, v2).

        :rtype: Vector
        """
        msg = 'Vv_end deprecated, use v_tangent(u2, v2) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.v_tangent(self.u2, self.v2)

    @Attribute
    def Vw_start(self):
        """Normal vector at (u1, v1).

        :rtype: Vector
        """
        msg = 'Vw_start deprecated, use normal(u1, v1) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.normal(self.u1, self.v1)

    @Attribute
    def Vw_end(self):
        """Normal vector at (u2, v2).

        :rtype: Vector
        """
        msg = 'Vw_end deprecated, use normal(u2, v2) instead. Object: {}.'
        warnings.warn(msg.format(self), ParaPyDeprecationWarning, stacklevel=4)
        return self.normal(self.u2, self.v2)

    # -------- extrema / intersections --------
    def extrema(self, other):
        """See :meth:`Curve.extrema` for the general idea."""
        if isinstance(other, AbstractPoint):
            return self._point_extrema(other)
        elif lazy_hasattr(other, "Handle_Geom_Curve"):
            return self._curve_extrema(other)
        elif lazy_hasattr(other, "Handle_Geom_Surface"):
            return self._surface_extrema(other)
        else:
            msg = "{:} is not a valid Point, Curve or Surface object."
            raise RuntimeError(msg.format(repr(other)))

    def _point_extrema(self, point):
        """Return list of extrema found between this surface and ``point``.
        Each entry is a dictionary with information regarding the extremum:

        - "point": point on this surface
        - "other_point": other point
        - "uv": parameter on this surface
        - "distance": distance between curve and ``point`` at this extremum

        :type point: AbstractPoint
        :rtype: list[dict]
        :returns: [{"point", Point, "other_point": Point,
                    "u": float, "distance": float}, ...]
        """
        ext = BRepExtrema_ExtPF(point.TopoDS_Vertex, self.TopoDS_Face)
        results = []
        if not ext.IsDone():
            return results
        for i in range(1, ext.NbExt() + 1):
            results.append({"point": Point(*ext.Point(i).Coord()),
                            "other_point": point,
                            "uv": ext.Parameter(i),
                            "distance": math.sqrt(ext.SquareDistance(i))})
        return results

    def _curve_extrema(self, other):
        """Return list of extrema found between this curve and ``surface``.
        Each entry is a dictionary with information regarding the extremum:

        - "point": point on this surface
        - "other_point": point on ``curve``
        - "u": parameter on this curve
        - "uv": parameters on surface
        - "distance": distance between points

        :param other: parapy.geom.Curve
        :rtype: list[dict]
        :returns: [{"point", Point, "other_point": Point, "u": float,
                    "uv": (float, float), "distance": float}, ...]
        """
        ext = GeomAPI_ExtremaCurveSurface(other.Handle_Geom_Curve,
                                          self.Handle_Geom_Surface)

        results = []
        for i in range(1, ext.NbExtrema() + 1):
            pt1, pt2 = gp_Pnt(), gp_Pnt()
            ext.Points(i, pt1, pt2)
            w, u, v = ext.Parameters(i)
            results.append(
                {"other_point": Point(*pt1.Coord()),
                 "u": w,
                 "distance": ext.Distance(i),
                 "point": Point(*pt2.Coord()),
                 "uv": (u, v)})
        return results

    def _surface_extrema(self, other):
        """Return list of extrema found between this and ``other`` surface.
        Each entry is a dictionary with information regarding the extremum:

        - "point": point on this curve
        - "other_point": point on ``surface``
        - "uv": parameter on this surface
        - "other_uv": parameters on other surface
        - "distance": distance between points

        :param other: Surface
        :rtype: list[dict]
        :returns: [{"point", Point, "other_point": Point, "u": float,
                    "uv": (float, float), "distance": float}, ...]
        """
        ext = GeomAPI_ExtremaSurfaceSurface(self.Handle_Geom_Surface,
                                            other.Handle_Geom_Surface)

        results = []
        for i in range(1, ext.NbExtrema() + 1):
            pt1, pt2 = gp_Pnt(), gp_Pnt()
            ext.Points(i, pt1, pt2)
            u1, v1, u2, v2 = ext.Parameters(i)
            results.append(
                {"point": Point(*pt1.Coord()),
                 "uv": (u1, v1),
                 "distance": ext.Distance(i),
                 "other_point": Point(*pt2.Coord()),
                 "other_uv": (u2, v2)})
        return results

    def intersections(self, curve, tolerance=1.0e-7):
        """List intersections between this surface and a :attr:`curve`. Each
        intersection is a dict of the form::

        [{"point": Point,
          "u", float,
          "other_uv": (float, float),  # only if other is Surface
          },
          # next intersection ..
        }

        Where:
        - "point": intersection Point
        - "u": parameter on Curve
        - "other_uv": parameters on Surface

        Usage:

        >>> from parapy.geom import PipeSurface, Point, LineSegment
        >>> crv1 = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
        >>> srf = PipeSurface(path=crv1, radius=0.2)
        >>> crv2 = LineSegment(Point(0.5,0,-0.5),Point(0.5,0,0.5))
        >>> intersections = srf.intersections(crv2)

        :param curve: Curve
        :param float tolerance: tolerance for intersection.
        :return: list[dict]
        """
        return curve.intersections(self, tolerance)

    def intersection_points(self, curve, tolerance=1.0e-7):
        """Intersecting points between this surface and a :attr:`curve`. Usage:

        >>> from parapy.geom import RectangularFace, BSplineCurve, Point
        >>> crv = BSplineCurve((Point(0.0, -0.25, -1.0), Point(0.0, 0.0, 2.0),
        ...                     Point(0.0, 0.25, -1.0)))
        >>> srf = RectangularFace(width=2, length=1)
        >>> srf.intersection_points(crv)
        [Point(0.0, -0.144337567297, 0.0), Point(0.0, 0.144337567297, 0)]

        :param Curve curve: a curve that intersects with surface
        :param float tolerance: tolerance for intersection.
        :rtype: list[Point]
        """
        return curve.intersection_points(self, tolerance)

    def intersection_point(self, curve, tolerance=1.0e-7):
        """Intersecting point between this surface and a :attr:`curve`. Usage:

        >>> from parapy.geom import RectangularFace, LineSegment, Point
        >>> srf = RectangularFace(width=1, length=2)
        >>> line = LineSegment(Point(0.3, 0.3, -1), Point(0.3, 0.3, 1))
        >>> srf.intersection_point(line)
        Point(0.3, 0.3, 0.0)

        :param Curve curve: a curve that intersects with surface
        :param float tolerance: tolerance for intersection.
        :rtype: Point
        """
        return curve.intersection_point(self, tolerance)

    def intersection_curves(self, other_surface, tolerance=1.0e-7):
        """Intersecting curves between this surface and :attr:`other_surface`.

        >>> from parapy.geom import XOY, rotate90, RectangularSurface
        >>> srf1 = RectangularSurface(width=2, length=1)
        >>> srf2 = RectangularSurface(width=2, length=1,
        ...                           position=rotate90(XOY, 'x'))
        >>> srf1.intersection_curves(srf2)  # doctest: +ELLIPSIS
        [<TrimmedCurve_ root at 0x...>]

        :param Surface other_surface: a surface that intersects with this
            surface
        :param float tolerance: tolerance for intersection.
        :rtype: list[Curve]
        :raises RuntimeError: if intersection failed
        """
        from OCC.wrapper.GeomAPI import GeomAPI_IntSS
        builder = GeomAPI_IntSS(self.Handle_Geom_Surface,
                                other_surface.Handle_Geom_Surface,
                                tolerance)
        if not builder.IsDone():
            raise RuntimeError("intersection failed")
        else:
            curves = []
            for i in range(1, builder.NbLines() + 1):
                handle = builder.Line(i)
                new_handle, class_ = Handle_Geom_Curve2ParaPy(handle)
                curve = class_(Handle_Geom_Curve=new_handle)
                curves.append(curve)
            return curves

    # --- Bounding box ---
    @Attribute
    def _Bnd_Box(self):
        # FIXME: control-points are used splines, this may be wrong.
        #        Consider using mesh and BrepBndLib
        box = Bnd_Box()
        # FIXME (RvD): tolerance hard-coding
        BndLib_AddSurface.Add(self._Adaptor3d_Surface, 1e-8, box)
        return box

    @Attribute
    def _bbox_bounds(self):
        return tuple(self._Bnd_Box.Get())


def Handle_Geom_Surface2ParaPy(handle):
    """Tries to find most corresponding ParaPy class to ``handle``. If
    required, downcasts ``handle``, return ``(handle, Surface)``.

    :rtype: (OCC.Geom.Handle_Geom_Surface, Surface)
    """
    # added this guard to prevent segfault in DynamicType()
    if handle.IsNull():
        msg = "Handle_Geom_Surface2ParaPy() was given null handle {}."
        raise RuntimeError(msg.format(handle))

    dynamic_type = handle.DynamicType()
    name = dynamic_type.Name()
    fn = dynamic_type.SubType

    if fn("Geom_BoundedSurface"):
        if name == "Geom_BSplineSurface":
            return Handle_Geom_BSplineSurface(handle), BSplineSurface_
        elif name == "Geom_BezierSurface":
            return Handle_Geom_BezierSurface(handle), BezierSurface_
        elif name == "Geom_RectangularTrimmedSurface":
            return (Handle_Geom_RectangularTrimmedSurface(handle),
                    RectangularTrimmedSurface_)
        assert False, "Shouldn't happen"
    elif fn("Geom_ElementarySurface"):
        if name == "Geom_Plane":
            return Handle_Geom_Plane(handle), Plane_
        elif name == "Geom_CylindricalSurface":
            return (Handle_Geom_CylindricalSurface(handle),
                    InfiniteCylindricalSurface_)
        elif name == "Geom_ConicalSurface":
            return Handle_Geom_ConicalSurface(handle), InfiniteConicalSurface_
        elif name == "Geom_SphericalSurface":
            return Handle_Geom_SphericalSurface(handle), SphericalSurface_
        elif name == "Geom_ToroidalSurface":
            return Handle_Geom_ToroidalSurface(handle), ToroidalSurface_
        assert False, "Shouldn't happen"
    elif fn("Geom_SweptSurface"):
        if name == "Geom_SurfaceOfLinearExtrusion":
            return (Handle_Geom_SurfaceOfLinearExtrusion(handle),
                    ExtrudedSurface_)
        elif name == "Geom_SurfaceOfRevolution":
            return Handle_Geom_SurfaceOfRevolution(handle), RevolvedSurface_
        assert False, "Shouldn't happen"
    else:
        return handle, Surface


# --- Bounded Surfaces ---
def BezierSurface_control_points(pts, obj, slot):
    return 1 < len(pts) < 27 and 1 < len(pts[0]) < 27


class BezierSurface(Surface):
    """Create a Bezier surface that is determined from a list of lists of
    :attr:`control_points`. The outer border points form end points of the
    surface, intermediate points do not have to lie on the surface. Columns
    correspond to the u-direction, rows are in v-direction::

            V ---------------->
        U [[pt00, pt01 ... pt0n],
        |  [pt10, pt11 ... pt1n],
        |  ...
        v  [ptm0, ptm1 ... ptmn]]

    Usage:

    >>> from parapy.geom import Point, BezierSurface
    >>> points = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...           (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...           (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> srf = BezierSurface(control_points=points)
    >>> srf.u_degree
    2
    >>> srf.v_degree
    2
    >>> srf.degree
    2

    Optionally, an array of `:attr:weights` can be given. The default weight
    for a control point is 1.0:

    >>> weights = [[1.0, 2.0, 1.0], [1.0, 3.0, 1.0], [1.0, 4.0, 1.0]]
    >>> srf = BezierSurface(control_points=points, weights=weights)
    """

    __icon__ = os.path.join(ICN_DIR, 'bsplinesurface.png')
    __Handle_Geom_Surface__ = Handle_Geom_BezierSurface

    __initargs__ = ["control_points", "weights"]

    #: a list of lists of control points
    #: :type: collections.Sequence[collections.Sequence[Point]]
    control_points = Input(validator=BezierSurface_control_points)

    #: List of lists of weights. Defaults an array of 1.0's, viz. a
    #: non-rational b-spline curve.
    #: :type: collections.Sequence[collections.Sequence[float]]
    weights = Input(derived)

    @weights.getter
    def weights(self):
        pts = self.control_points
        return [[1.0] * len(pts[0])] * len(pts)

    @Attribute
    def u_degree(self):
        """Degree in u-direction.

        :rtype: float
        """
        return self.Handle_Geom_Surface.UDegree()

    @Attribute
    def v_degree(self):
        """Degree in v-direction.

        :rtype: float
        """
        return self.Handle_Geom_Surface.VDegree()

    @Attribute
    def degree(self):
        """Degree of this surface, minimum value of :attr:`u_degree` and
        :attr:`v_degree`.

        :rtype: float
        """
        return min(self.u_degree, self.v_degree)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """The SWIG proxy object for this curve.

        :rtype: OCC.Geom.Handle_Geom_BezierSurface
        """
        return Geom_BezierSurface(
            TColgp_Array2OfPnt_factory(self.control_points),
            TColStd_Array2OfReal_factory(self.weights)).handle

    @property
    def _new_surface_type(self):
        return BezierSurface_

    def increase(self):
        """Elevate degree of bezier"""
        raise NotImplementedError("todo")

    def decrease(self):
        """decrease degree of bezier"""
        raise NotImplementedError("todo")


class BezierSurface_(BezierSurface):
    """Purposed for computed Bezier Surface objects, for example as the result
    of some sweeping, filling or lofting operations. If you want to *create*
    your own Bezier Surface from scratch, refer to :class:`BezierSurface`.

    .. note:: this class expects an input type Handle_Geom_BezierSurface
    """

    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def control_points(self):
        """Control_points of the Bezier surface, a 2D sequence of Points.

        :rtype: list[list[Point]]
        """
        handle = self.Handle_Geom_Surface
        arr = TColgp_Array2OfPnt(1, handle.NbUPoles(), 1, handle.NbVPoles())
        handle.Poles(arr)
        return arr.points

    @Attribute
    def weights(self):
        """Weights of the Bezier surface.

        :rtype: list[list[float]]
        """
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array2OfReal(1, handle.NbUPoles(), 1, handle.NbVPoles())
        handle.Weights(arr)
        return arr.list


# FIXME (RvD): fix degree logic for u and v seperately.
class BSplineSurface(Surface):
    """Create a B-Spline surface that is determined from a list of lists of
    :attr:`control_points`. Columns correspond to the u-direction, rows are in
    v-direction::

            V ---------------->
        U [[pt00, pt01 ... pt0n],
        |  [pt10, pt11 ... pt1n],
        |  ...
        v  [ptm0, ptm1 ... ptmn]]

    The :attr:`degree` (in both u- and v-directions) is determined
    automatically but can also be prescribed. Prescribing separate degrees in
    u- and v-direction is also possible with :attr:`u_degree` and
    :attr:`v_degree`. Optional `:attr:weights` can be given (defaults to 1).

    Usage:

    >>> from parapy.geom import BSplineSurface, Point
    >>> data = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...         (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...         (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> srf1 = BSplineSurface(control_points=data)
    >>> #Let us change the u and v degree
    >>> srf2 = BSplineSurface(control_points=data, u_degree=1, v_degree=1)

    Unlike Bezier surfaces, the BSpline surface does not always pass through
    the end points. For more information, see `Open Cascade Documentation <http://dev.opencascade.org/doc/refman/html/class_geom___b_spline_surface.html>`__.
    """

    __icon__ = os.path.join(ICN_DIR, 'bsplinesurface.png')
    __Handle_Geom_Surface__ = Handle_Geom_BSplineSurface

    __initargs__ = ["control_points", "weights", "u_knots",
                    "u_multiplicities",
                    "v_multiplicities", "u_degree", "v_degree",
                    "is_u_periodic", "is_v_periodic"]

    #: a list of list of control points
    #: :type: collections.Sequence[collections.Sequence[Point]]
    control_points = Input()

    #: Optional degree of surface. Range 1 - 25
    #: :type: int
    degree = Input(derived, validator=val.Range(1, 25))

    #: degree of the BSplines in u direction. Range 1 - 25
    #: :type: int
    u_degree = Input(degree, validator=val.Range(1, 25))

    #: degree of the BSplines in v direction. Range 1 - 25
    #: :type: int
    v_degree = Input(degree, validator=val.Range(1, 25))

    #: Optional weights, defaults to a non-rational b-spline surface, i.e.
    #: ``[1.0, 1.0, ...]``.
    #: :type: collections.Sequence[Sequence[float]]
    weights = Input(derived)

    #: Optional table of knots in u direction: an increasing sequence of reals
    #: without repetition. :attr:`u_multiplicities` define the repetition of
    #: the knots.
    #: :type: collections.Sequence[float]
    u_knots = Input(derived)

    #: Optional table of knots in v direction: an increasing sequence of reals
    #: without repetition. :attr:`v_multiplicities` define the repetition of
    #: the knots.
    #: :type: collections.Sequence[float]
    v_knots = Input(derived)

    #: optional u multiplicities, defaults to a uniform b-spline surface
    #: :type: collections.Sequence[int]
    u_multiplicities = Input(derived)

    #: optional V multiplicities, defaults to a uniform b-spline surface
    #: :type: collections.Sequence[int]
    v_multiplicities = Input(derived)

    #: Set to true if the surface is closed in the V direction. Default is
    #: False.
    #: :type: bool
    is_u_periodic = Input(False)

    #: Set to true if the surface is closed in the U direction. Default is
    #: False.
    #: :type: bool
    is_v_periodic = Input(False)

    # FIXME (RvD): why is there a minimum degree of 3?
    @degree.getter
    def degree(self):
        """Degree of this curve.

        :rtype: int
        """
        return min(len(self.control_points) - 1,
                   len(self.control_points[0]) - 1,
                   3)

    @weights.getter
    def weights(self):
        """
        Defaults to a non-rational b-spline surface
        """
        return [[1] * len(self.control_points[0])] * len(self.control_points)

    @u_knots.getter
    def u_knots(self):
        """The table of knots in u direction: an increasing sequence of reals
        without repetition. Multiplicities define the repetition of the knots.

        :rtype: list[float]
        """
        c = len(self.control_points)
        d = self.u_degree
        L = c - d + 1
        if not L >= 2:
            msg = ("This should hold: len(self.control_points) - "
                   "self.u_degree - 1 > 0. In this case: NOT {} - {} - 1"
                   " >= 0. Perhaps your degree is to high? Object: {}")
            raise ValueError(msg.format(len(self.control_points),
                                        self.u_degree, self))
        step = 1 / (L - 1)
        return [step * i for i in range(L - 1)] + [1.0]

    @v_knots.getter
    def v_knots(self):
        """The table of knots in v direction: an increasing sequence of reals
        without repetition. Multiplicities define the repetition of the knots.

        :rtype: list[float]
        """
        c = len(self.control_points[0])
        d = self.v_degree
        L = c - d + 1
        if not L >= 2:
            msg = ("This should hold: len(self.control_points[0]) - "
                   "self.v_degree - 1 >= 0. In this case: NOT {} - {} - 1 "
                   ">= 0. Perhaps your degree is to high? Object: {}")
            raise ValueError(msg.format(len(self.control_points[0]),
                                        self.v_degree, self))
        step = 1 / (L - 1)
        return [step * i for i in range(L - 1)] + [1.0]

    @u_multiplicities.getter
    def u_multiplicities(self):
        """Defaults to a uniform b-spline surface
        ``SUM = len(self.control_points) + self.u_degree + 1``. On a
        non-periodic curve the first and last multiplicities should be
        ``self.degree + 1``, so
        ``L = len(self.control_points) - self.u_degree - 1``.

        :rtype: list[float]
        """
        c = len(self.control_points)
        d = self.u_degree
        # On non-periodic curve first and last multiplicities are Degree + 1
        mult = d + 1
        # SUM = c + d + 1 --> L = c - d + 1 --> IL = c - d - 1
        IL = c - d - 1
        return [mult] + [1] * IL + [mult]

    @v_multiplicities.getter
    def v_multiplicities(self):
        """Defaults to a uniform b-spline surface
        ``SUM = len(self.control_points[0]) + self.v_degree + 1``. On a
        non-periodic curve the first and last multiplicities should be
        ``self.degree + 1``. So,
        ``L = len(self.control_points[0]) - self.v_degree - 1``.

        :rtype: list[float]
        """
        c = len(self.control_points[0])
        d = self.v_degree
        # On non-periodic curve first and last multiplicities are Degree + 1
        mult = d + 1
        # SUM = c + d + 1 --> L = c - d + 1 --> IL = c - d - 1
        IL = c - d - 1
        return [mult] + [1] * IL + [mult]

    @Attribute
    def u_knot_sequence(self):
        """Returns the knots sequence in U direction. In this sequence the
        knots with a multiplicity greater than 1 are repeated.

        :rtype: list[int]
        """
        L = sum(self.u_multiplicities)
        arr = TColStd_Array1OfReal(1, L)
        self.Handle_Geom_Surface.UKnotSequence(arr)
        return arr.list

    @Attribute
    def v_knot_sequence(self):
        """Returns the knots sequence in V direction. In this sequence the
        knots with a multiplicity greater than 1 are repeated.

        :rtype: list[int]
        """
        L = sum(self.v_multiplicities)
        arr = TColStd_Array1OfReal(1, L)
        self.Handle_Geom_Surface.VKnotSequence(arr)
        return arr.list

    @Attribute
    def is_u_rational(self):
        return self.Handle_Geom_Surface.IsURational()

    @Attribute
    def is_v_rational(self):
        return self.Handle_Geom_Surface.IsVRational()

    @Attribute
    def is_rational(self):
        return self.is_u_rational or self.is_v_rational

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_BSplineSurface(
            TColgp_Array2OfPnt_factory(self.control_points),
            TColStd_Array2OfReal_factory(self.weights),
            TColStd_Array1OfReal_factory(self.u_knots),
            TColStd_Array1OfReal_factory(self.v_knots),
            TColStd_Array1OfInteger_factory(self.u_multiplicities),
            TColStd_Array1OfInteger_factory(self.v_multiplicities),
            self.u_degree,
            self.v_degree,
            self.is_u_periodic,
            self.is_v_periodic).handle

    @Attribute(private=True)
    def Handle_Geom_BSplineSurface(self):
        return self.Handle_Geom_Surface

    @Attribute
    def bspline(self):
        return self

    @property
    def _new_surface_type(self):
        return BSplineSurface_


class BSplineSurface_(BSplineSurface):
    """Purposed for computed BSpline Surface objects, for example as the
    result of some sweeping, filling or lofting operations. If you want to
    *create* your own BSpline Surface from sratch, refer to BSplineSurface.

    .. note:: this class expects an input type Handle_Geom_BSplineSurface
    """

    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def control_points(self):
        handle = self.Handle_Geom_Surface
        arr = TColgp_Array2OfPnt(1, handle.NbUPoles(), 1, handle.NbVPoles())
        handle.Poles(arr)
        return arr.points

    @Attribute
    def u_degree(self):
        return self.Handle_Geom_Surface.UDegree()

    @Attribute
    def v_degree(self):
        return self.Handle_Geom_Surface.VDegree()

    @Attribute
    def degree(self):
        return min(self.u_degree, self.v_degree)

    @Attribute
    def weights(self):
        """Returns the weights of the B-spline surface."""
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array2OfReal(1, handle.NbUPoles(), 1, handle.NbVPoles())
        handle.Weights(arr)
        return arr.list

    @Attribute
    def u_knots(self):
        """Returns the knots in the U direction."""
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array1OfReal(1, handle.NbUKnots())
        handle.UKnots(arr)
        return arr.list

    @Attribute
    def v_knots(self):
        """Returns the knots in the V direction."""
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array1OfReal(1, handle.NbVKnots())
        handle.VKnots(arr)
        return arr.list

    @Attribute
    def u_multiplicities(self):
        """Returns the multiplicities of the knots in the U direction."""
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array1OfInteger(1, handle.NbUKnots())
        handle.UMultiplicities(arr)
        return arr.list

    @Attribute
    def v_multiplicities(self):
        """Returns the multiplicities of the knots in the V direction."""
        handle = self.Handle_Geom_Surface
        arr = TColStd_Array1OfInteger(1, handle.NbVKnots())
        handle.VMultiplicities(arr)
        return arr.list

    @Attribute
    def is_u_periodic(self):
        return self.Handle_Geom_Surface.IsUPeriodic()

    @Attribute
    def is_v_periodic(self):
        return self.Handle_Geom_Surface.IsVPeriodic()


def _FittedSurface_max_degree_validator(num, obj, slot):
    return num >= obj.min_degree


class FittedSurface(BSplineSurface_):
    """Fit a B-Spline surface passing through an **array** of :attr:`points`
    with a given :attr:`continuity`. The array is formed by a list of lists
    of points. Columns correspond to the u-direction, rows are in
    v-direction::

            V ---------------->
        U [[pt00, pt01 ... pt0n],
        |  [pt10, pt11 ... pt1n],
        |  ...
        v  [ptm0, ptm1 ... ptmn]]


    The precision of the *fit* is defined by :attr:`tolerance`, it prescribes
    the maximum distance between :attr:`points` and the resulting surface. The
    fitting algorithm takes the freedom to vary the :attr:`degree` of the
    B-Spline surface between :attr:`min_degree` and :attr:`max_degree` bounds.
    Generally, a higher value of :attr:`max_degree` may provide greater freedom
    to the fitting algorithm to find a better fit, but can also result in
    wiggles. Usually, :attr:`max_degree` of 8, is a good compromise, although
    you may also want to limit it to 3 (cubic) for smoothness. Usage:

    >>> from parapy.geom import FittedSurface, Point
    >>> data = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...         (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...         (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> obj = FittedSurface(points=data)

    For more information, see `Open Cascade Documentation
    <http://www.opencascade.com/doc/occt-6.9.1/refman/html/class_geom_a_p_i___points_to_b_spline_surface.html>`__.
    """

    CONTINUITY = [GeomAbs_C0, GeomAbs_C1, GeomAbs_C2]

    __initargs__ = ["points", "continuity"]

    #: a list of list of control points
    #: :type: collections.Sequence[collections.Sequence[Point]]
    points = Input()

    #: desired C-continuity. Defaults to C2. Range is 0-2.
    #: :type: int
    continuity = Input(2, validator=val.OneOf([0, 1, 2]))

    #: min degree of surface
    #: :type: int
    min_degree = Input(3)

    #: max degree of surface
    #: :type: int
    max_degree = Input(8, validator=_FittedSurface_max_degree_validator)

    #: maximum distance between points and resulting surface
    #: :type: float
    tolerance = Input(1.0e-3)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        builder = GeomAPI_PointsToBSplineSurface(
            TColgp_Array2OfPnt_factory(self.points),
            self.min_degree,
            self.max_degree,
            self.CONTINUITY[self.continuity],
            self.tolerance)
        if builder.IsDone():
            return builder.Surface()
        else:
            raise RuntimeError("fitting failed.")


class InterpolatedSurface(BSplineSurface_):
    """Interpolates a surface passing through a list of lists of :attr:`points`
    . Columns correspond to the u-direction, rows are in v-direction::

            V ---------------->
        U [[pt00, pt01 ... pt0n],
        |  [pt10, pt11 ... pt1n],
        |  ...
        v  [ptm0, ptm1 ... ptmn]]



    Usage:

    >>> from parapy.geom import InterpolatedSurface, Point
    >>> data = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...         (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...         (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> obj = InterpolatedSurface(points=data)
    """

    __initargs__ = ["points"]

    #: a list of list of Point
    #: :type: collections.Sequence[collections.Sequence[Point]]
    points = Input()

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        builder = GeomAPI_PointsToBSplineSurface()
        builder.Interpolate(TColgp_Array2OfPnt_factory(self.points))
        if builder.IsDone():
            return builder.Surface()
        else:
            raise RuntimeError("fitting failed.")


class ApproximatedSurface(BSplineSurface_):
    """To convert a 3D surface to a 3D BSpline surface. Defaults to a cubic
    Spline (max_degree=3). Degrees in both u- and v-direction can be
    precribed with :attr:`max_u_degree` and :attr:`max_v_degree`. Usage:

    >>> from parapy.geom import ApproximatedSurface, CylindricalSurface
    >>> srf1 = CylindricalSurface(radius=1, height=1)
    >>> srf2 = ApproximatedSurface(surface_in=srf1)
    """

    __initargs__ = ["surface_in"]

    #: the surface that will be approximated
    #: :type: Surface
    surface_in = Input()

    #: degree of  continuity in u direction
    #: :type: int
    u_continuity = Input(2)

    #: degree of  continuity in v direction
    #: :type: int
    v_continuity = Input(2)

    #: the highest u degree which the polynomial defining the BSpline surface
    #: may have
    #: :type: int
    max_u_degree = Input(3)

    #: the highest v degree which the polynomial defining the BSpline surface
    #: may have
    #: :type: int
    max_v_degree = Input(3)

    #: the maximum number of segments allowed in the resulting BSpline surface
    #: :type: int
    max_segments = Input(200)

    #: allowed distance between points and surface
    #: :type: float
    tolerance = Input(1.0e-3)

    _CONTINUITY = [GeomAbs_C0, GeomAbs_C1, GeomAbs_C2]

    @Attribute
    def is_within_tolerance(self):
        return self.max_error <= self.tolerance

    @Attribute
    def max_error(self):
        """Return the greatest distance between a point on :attr:`surface_in`
        and the approximated BSpline surface resulting from the approximation
        (>0 when an approximation has been done, 0 if no approximation).

        :rtype: float
        """
        return self._GeomConvert_ApproxSurface.MaxError()

    @Attribute
    def _GeomConvert_ApproxSurface(self):
        builder = GeomConvert_ApproxSurface(
            self.surface_in.Handle_Geom_Surface,
            self.tolerance,
            self._CONTINUITY[self.u_continuity],
            self._CONTINUITY[self.v_continuity],
            self.max_u_degree,
            self.max_v_degree,
            self.max_segments,
            0)  # PrecisCode
        if builder.HasResult():
            if builder.MaxError() > self.tolerance:
                msg = ("GeomConvert_ApproxSurface algorithm could not "
                       "approximate a surface within the given tolerance")
                warnings.warn(msg)
            return builder
        else:
            msg = ("GeomConvert_ApproxSurface algorithm could not find a "
                   "surface with the given inputs")
            raise ValueError(msg)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return self._GeomConvert_ApproxSurface.Surface()


class RectangularTrimmedSurface(Surface):
    """Trim an existing surface to new :attr:`uv_bounds`, ordered as: u1, u2,
    v1, v2. Usage:

    >>> from parapy.geom import (InfiniteCylindricalSurface,
    ...                          RectangularTrimmedSurface)
    >>> from math import pi
    >>> cyl = InfiniteCylindricalSurface(radius=1)
    >>> obj = RectangularTrimmedSurface(basis_surface=cyl,
    ...                                 uv_bounds=(0, pi, 0, 2))
    """

    __initargs__ = ["basis_surface", "uv_bounds"]

    __Handle_Geom_Surface__ = Handle_Geom_RectangularTrimmedSurface

    #: :type: Surface
    basis_surface = Input()

    #: new bounds. Tuple of four numbers (u1, u2, v1, v2)
    #: :type: (float, float, float, float)
    uv_bounds = Input()

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """override on subclassing"""
        u1, u2, v1, v2 = self.uv_bounds
        return Geom_RectangularTrimmedSurface(
            self.basis_surface.Handle_Geom_Surface,
            # convert to float explicitly
            float(u1), float(u2), float(v1), float(v2)).handle

    @property
    def _new_surface_type(self):
        return RectangularTrimmedSurface_


class RectangularTrimmedSurface_(RectangularTrimmedSurface):
    """Purposed for computed RectangularTrimmedSurface Surface objects.

    ..note:: class expects an input type Handle_Geom_RectangularTrimmedSurface
    """

    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def uv_bounds(self):
        return self.get_slot_value("uv_bounds", cls=Surface)

    @PrivatePartNoParsing
    def basis_surface(self):
        h_geom_surface = self.Handle_Geom_Surface.BasisSurface()
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)


class InfiniteSurface(Surface):
    display_mode = Input("wireframe")

    @property
    def v_dim(self):
        raise NotImplementedError()

    def find_parameter_inside(self):
        return 0, 0


class InfiniteConicalSurface(InfiniteSurface):
    """Infinite conical surface. You define two reference radii and
    the height (distance from ref to apex), such that Apex is located at
    ``self.position(z=height)``. Usage:

    >>> from parapy.geom import InfiniteConicalSurface
    >>> obj = InfiniteConicalSurface(radius=1, height=1)
    """

    __initargs__ = ["radius", "height"]
    __Handle_Geom_Surface__ = Handle_Geom_ConicalSurface

    #: The reference plane radius of the cone
    #: :type: float
    radius = Input()

    #: The height of the cone is the distance between reference plane and Apex
    #: point, measured along axis of revolution (z).
    #: :type: float
    height = Input()

    #: :type: Position
    position = Input(XOY, defaulting=True)

    #: The dimension for visualization. Corresponds to width/length of plane.
    #: :type: float
    v_dim = Input(1)

    is_conical = Attribute(True)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        pos = self.position
        semi_angle = -math.atan(self.radius / self.height)
        cone = Geom_ConicalSurface(pos.gp_Ax3, semi_angle, self.radius)
        return cone.handle

    @Attribute
    def semi_angle(self):
        """semi-angle of conical surface [radians]"""
        return self.Handle_Geom_Surface.SemiAngle()

    @Attribute
    def apex(self):
        """The Apex point of this surface"""
        return Point(*self.Handle_Geom_Surface.Apex().Coord())

    @Attribute
    def builder(self):
        srf = self.Handle_Geom_Surface.Cone()
        builder = BRepBuilderAPI_MakeFace(srf)
        if builder.IsDone():
            return builder
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @Attribute
    def _drawable_TopoDS_Shape(self):
        dim = 0.5 * self.v_dim
        srf = self.Handle_Geom_Surface.Cone()
        builder = BRepBuilderAPI_MakeFace(srf, 0, 2 * math.pi, -dim, dim)
        if builder.IsDone():
            return builder.Shape()
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @property
    def _new_surface_type(self):
        return InfiniteConicalSurface_


class InfiniteConicalSurface_(InfiniteConicalSurface):
    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def position(self):
        return self.Handle_Geom_Surface.Position().position

    @Attribute
    def radius(self):
        return self.Handle_Geom_Surface.RefRadius()

    @Attribute
    def height(self):
        return self.radius / math.tan(self.semi_angle)


class ConicalSurface(RectangularTrimmedSurface):
    """Infinite conical surface. You define the reference radi at basis and
    the height (distance from ref to apex), such that:
    Apex is located at self.position(z=height)
    Usage:

    >>> from parapy.geom import ConicalSurface
    >>> obj = ConicalSurface(radius=1, height=2)
    """

    __initargs__ = ["radius", "height"]

    #: The reference plane radius of the cone
    #: :type: float
    radius = Input()

    #: The height of the cone is the distance between reference plane and Apex
    #: point, measured along axis of revolution (z).
    #: :type: float
    height = Input()

    #: Leave ``None`` for an infinite cylindrical surface.
    #: :type: float | None.
    angle = Input(2 * math.pi,
                  validator=val.Range(0, 2 * math.pi, incl_min=False))

    #: Position.
    #: :type: Position
    position = Input(XOY, defaulting=True)

    is_conical = Attribute(True)

    @PrivatePartNoParsing
    def basis_surface(self):
        return InfiniteConicalSurface()

    basis_surface.pass_down = "radius, height, position"

    @Attribute
    def uv_bounds(self):
        angle, height = self.angle, self.height
        u1, u2, v1, v2 = self.basis_surface.uv_bounds
        # trimmed surface demanded.
        if angle != 2 * math.pi:
            u2 = angle
        semi_angle = math.atan(self.radius / height)
        #: RvD fix: 0.0 instead of 0. Otherwise strange behavior.
        v1, v2 = 0.0, height / math.cos(semi_angle)
        return u1, u2, v1, v2

    @Attribute
    def semi_angle(self):
        """semi-angle of conical surface [radians]"""
        return self.basis_surface.semi_angle

    @Attribute
    def apex(self):
        """The Apex point of this surface"""
        return self.basis_surface.apex


class InfiniteCylindricalSurface(InfiniteSurface):
    """ Infinite cylindrical surface. Usage:

    >>> from parapy.geom import InfiniteCylindricalSurface
    >>> obj = InfiniteCylindricalSurface(radius=2, v_dim=0.25)
    """

    __initargs__ = ["radius"]
    __Handle_Geom_Surface__ = Handle_Geom_CylindricalSurface

    #: radius of cylinder
    #: :type: float
    radius = Input()

    #: Position.
    #: :type: Position
    position = Input(XOY, defaulting=True)

    #: The dimension for visualization. Corresponds to width/length of plane.
    #: :type: float
    v_dim = Input(1)

    is_cylindrical = Attribute(True)
    is_conical = Attribute(True)
    angle = Attribute(2 * math.pi)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_CylindricalSurface(self.position.gp_Ax3,
                                       self.radius).handle

    @Attribute
    def builder(self):
        srf = self.Handle_Geom_Surface.Cylinder()
        builder = BRepBuilderAPI_MakeFace(srf)
        if builder.IsDone():
            return builder
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @Attribute
    def _drawable_TopoDS_Shape(self):
        dim = 0.5 * self.v_dim
        srf = self.Handle_Geom_Surface.Cylinder()
        builder = BRepBuilderAPI_MakeFace(srf, 0, 2 * math.pi, -dim, dim)
        if builder.IsDone():
            return builder.Shape()
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @property
    def _new_surface_type(self):
        return InfiniteCylindricalSurface_


class InfiniteCylindricalSurface_(InfiniteCylindricalSurface):
    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def position(self):
        return self.Handle_Geom_Surface.Position().position

    @Attribute
    def radius(self):
        return self.Handle_Geom_Surface.Radius()


class CylindricalSurface(RectangularTrimmedSurface):
    """Finite cylindrical surface. Usage:

    >>> from parapy.geom import CylindricalSurface
    >>> obj = CylindricalSurface(radius=1, height=2)
    """

    __initargs__ = ["radius", "height"]

    #: radius of cylinder
    #: float.
    radius = Input()

    #: height of cylinder
    #: float
    height = Input()

    #: Leave ``None`` for an infinite cylindrical surface.
    #: :type: float | None.
    angle = Input(2 * math.pi,
                  validator=val.Range(0, 2 * math.pi, incl_min=False))

    #: Position.
    #: :type: Position
    position = Input(XOY, defaulting=True)

    is_cylindrical = Attribute(True)
    is_conical = Attribute(True)

    @PrivatePartNoParsing
    def basis_surface(self):
        return InfiniteCylindricalSurface()

    basis_surface.pass_down = "radius, position"

    @Attribute
    def uv_bounds(self):
        angle, height = self.angle, self.height
        u1, u2, v1, v2 = self.basis_surface.uv_bounds
        # trimmed surface demanded.
        if angle != 2 * math.pi:
            u2 = angle
        if height:
            #: RvD fix: 0.0 instead of 0. Otherwise strange behavior.
            v1, v2 = 0.0, height
        return u1, u2, v1, v2


class SphericalSurface(Surface):
    """position determines orientation and center. Usage:

    >>> from parapy.geom import SphericalSurface
    >>> obj = SphericalSurface(radius=1)
    """

    __initargs__ = ["radius", "position"]
    __Handle_Geom_Surface__ = Handle_Geom_SphericalSurface

    #: radius of sphere
    #: :type: float
    radius = Input()

    #: position of sphere
    #: :type: Position
    position = Input(XOY, defaulting=True)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_SphericalSurface(self.position.gp_Ax3, self.radius).handle

    @Attribute
    def builder(self):
        srf = self.Handle_Geom_Surface.Sphere()
        builder = BRepBuilderAPI_MakeFace(srf)
        if builder.IsDone():
            return builder
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @Attribute
    def area(self):
        return self.Handle_Geom_Surface.Area()

    @property
    def _new_surface_type(self):
        return SphericalSurface_


class SphericalSurface_(SphericalSurface):
    """Wraps around Handle_Geom_SphericalSurface"""

    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def position(self):
        return self.Handle_Geom_Surface.Position().position

    @Attribute
    def radius(self):
        return self.Handle_Geom_Surface.Radius()


class ToroidalSurface(Surface):
    """The position determines orientation and center. Usage:

    >>> from parapy.geom import ToroidalSurface
    >>> obj = ToroidalSurface(major_radius=5, minor_radius=1)
    """

    __Handle_Geom_Surface__ = Handle_Geom_ToroidalSurface

    # ==============================================================================================
    # API
    # ==============================================================================================
    __initargs__ = ["major_radius", "minor_radius"]

    #: radius of torus
    #: :type: float
    major_radius = Input(validator=val.Positive())

    #: radius of cross section
    #: :type: float
    minor_radius = Input(validator=val.Positive())

    #: position of geometry
    #: :type: Position
    position = Input(XOY, defaulting=True)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_ToroidalSurface(self.position.gp_Ax3,
                                    self.major_radius,
                                    self.minor_radius).handle

    @Attribute
    def builder(self):
        srf = self.Handle_Geom_Surface.Torus()
        builder = BRepBuilderAPI_MakeFace(srf)
        if builder.IsDone():
            return builder
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @Attribute
    def area(self):
        return (2 * math.pi * self.major_radius) * \
               (2 * math.pi * self.minor_radius)
        # return self.Handle_Geom_Surface.Volume()

    @Attribute
    def volume(self):
        return (math.pi * self.minor_radius ** 2) * \
               (2 * math.pi * self.major_radius)
        # return self.Handle_Geom_Surface.Volume()

    @property
    def _new_surface_type(self):
        return ToroidalSurface_


class ToroidalSurface_(ToroidalSurface):
    """Wraps around Handle_Geom_SphericalSurface"""

    __initargs__ = ["Handle_Geom_Surface"]

    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def position(self):
        return self.Handle_Geom_Surface.Position().position

    @Attribute
    def major_radius(self):
        return self.Handle_Geom_Surface.MajorRadius()

    @Attribute
    def minor_radius(self):
        return self.Handle_Geom_Surface.MinorRadius()


_ExtendedSurface_Continuity_Options = frozenset((1, 2, 3))


def _extendedsurface_continuity_validator(value):
    if hasattr(value, "__iter__"):
        return all(i in _ExtendedSurface_Continuity_Options for i in value)
    else:
        return value in _ExtendedSurface_Continuity_Options


class ExtendedSurface(BSplineSurface_):
    """Extends a **bounded** surface :attr:`surface_in` in u- or v-direction
    depending on :attr:`in_u` by given :attr:`distance` with
    :attr:`continuity` (1, 2 or 3). The extension is built on the side of
    the first parameters if :attr:`after` is False else at the last
    parameter (default). Usage:

    >>> from parapy.geom import Point, FittedSurface, ExtendedSurface
    >>> points = [[Point(0, 0, 0), Point(1, 0, 0)],
    ...           [Point(0, 1, 0), Point(1, 1, 0)]]
    >>> srf = FittedSurface(points=points)
    >>> srf.area
    1.0
    >>> # extend all sides by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0).area  # doctest: +ELLIPSIS
    9.0...
    >>> # same as explicit side='all'
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='all').area  # doctest: +ELLIPSIS
    9.0...
    >>> # extend only 'u+' side by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='u+').area  # doctest: +ELLIPSIS
    2.0...
    >>> # extend only 'u-' side by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='u-').area  # doctest: +ELLIPSIS
    2.0...
    >>> # extend both 'u' sides (- and +) by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='u').area  # doctest: +ELLIPSIS
    3.0...
    >>> # extend only 'v+' side by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='v+').area  # doctest: +ELLIPSIS
    2.0...
    >>> # extend only 'v-' side by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='v-').area  # doctest: +ELLIPSIS
    2.0...
    >>> # extend both 'v' sides (- and +) by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side='v').area  # doctest: +ELLIPSIS
    3.0...
    >>> # extend 'u+' and 'v-' sides by 1.0
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=1.0,
    ...                 side=['u+', 'v-']).area  # doctest: +ELLIPSIS
    4.0...
    >>> # extend 'u+' and 'v-' sides by 1.0 and 2.0, respectively
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=[1.0, 2.0],
    ...                 side=['u+', 'v-']).area  # doctest: +ELLIPSIS
    6.0...
    >>> # extend both 'u' sides and 'v-' side by 1.0 and 2.0, respectively
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=[1.0, 2.0],
    ...                 side=['u', 'v-']).area  # doctest: +ELLIPSIS
    9.0...
    >>> # finally, you may define multiple continuity specs
    >>> ExtendedSurface(surface_in=srf,
    ...                 distance=[1.0, 2.0],
    ...                 continuity=[1, 2],
    ...                 side=['u', 'v-']).area  # doctest: +ELLIPSIS
    9.0...

    .. note:: :attr:`distance` should not be too large with respect
        to the size of :attr:`surface_in`.
    .. note:: :attr:`surface_in` must not be a periodic B-Spline surface in
        the parametric direction corresponding to the direction of extension.
    .. warning:: :attr:`surface_in` must be bounded, viz. one can not extend
        infinite geometry, like :class:`Plane` or
        :class:`InfiniteCylindricalSurface`.
    """

    __initargs__ = ["surface_in", "distance"]

    #: surface that will be extended, should be a *bounded* surface
    #: :type: Surface
    surface_in = Input()

    #: Distance of the extension. Either a single float or a list of floats,
    #: each corresponding to a side as specified in :attr`side`.
    #: :type: float | list[float]
    distance = Input()

    #: Side(s) to extend. Valid options are:
    #:
    #: - 'all': all sides
    #: - 'u': both in u+ and u- direction
    #: - 'v': both in v+ and v- direction.
    #: - 'u+': only in u+ direction
    #: - 'u-': only in u- direction
    #: - 'v+': only in v+ direction
    #: - 'v-': only in v- direction
    #:
    #: You can specifiy other combinations of sides by providing a sequence of
    #: these, e.g. :py:`['u+', 'v+']`.
    #:
    #: :type: str | list[str]
    side = Input("all")

    #: Continuity of extension, can be 1, 2 or 3. Either a single int or a
    #: list of ints, each corresponding to a side as specified in :attr`side`.
    #: :type: int | list[int]
    continuity = Input(3, validator=_extendedsurface_continuity_validator)

    #: **DEPRECATED**
    #: True means extension in u-direction, False means in v-direction.
    #: :type: bool
    in_u = Input(True)

    #: **DEPRECATED**
    #: If True, extension is built on rear end (or last parameter) of surface.
    #: False means on front end (or first parameter) of surface.
    #: :type: bool
    after = Input(True)

    _USER_SIDE_MAP = {'all': ['u-', 'u+', 'v-', 'v+'],
                      'u': ['u-', 'u+'],
                      'v': ['v-', 'v+'],
                      'u-': ['u-'],
                      'u+': ['u+'],
                      'v-': ['v-'],
                      'v+': ['v+']}

    #                       inU,  After
    _SIDE_OCC_MAP = {'u-': (True, False),
                     'u+': (True, True),
                     'v-': (False, False),
                     'v+': (False, True)}

    @Attribute
    def side_specs(self):
        """Triples of (side, distance, continuity).

        :returns: (['u+', 1.0, 1], ...)
        :rtype: tuple[list[str, float, int]]
        """
        distance = self.distance
        continuity = self.continuity
        multi_dist = hasattr(distance, "__iter__")
        multi_cont = hasattr(continuity, "__iter__")

        is_in_u_defined = self.is_user_defined("in_u")
        is_after_defined = self.is_user_defined("after")

        # old mode for backwards compatibility
        if is_in_u_defined or is_after_defined:

            in_u, after = self.in_u, self.after
            side = ('u' if in_u else 'v') + ('+' if after else '-')

            if is_in_u_defined and is_after_defined:
                head = "ExtendedSurface.in_u and ExtendedSurface.after have "
            elif is_in_u_defined:
                head = "ExtendedSurface.in_u has "
            else:
                head = "ExtendedSurface.after has "

            msg = ("{} been deprecated, use ExtendedSurface.side={} instead. "
                   "Object: {}.")
            warnings.warn(msg.format(head, repr(side), self),
                          ParaPyDeprecationWarning, stacklevel=4)

            if multi_dist:
                msg = ("Found imcompatible combination of multiple distances "
                       "with (deprecated) in_u/after specification. "
                       "Object: {}.")
                raise ValueError(msg.format(self))

            if multi_cont:
                msg = ("Found imcompatible combination of multiple continuity "
                       "with (deprecated) in_u/after specification. "
                       "Object: {}.")
                raise ValueError(msg.format(self))

            if self.is_user_defined("side"):
                msg = ("Found imcompatible combination of side with "
                       "(deprecated) in_u/after specification. "
                       "Object: {}.")
                raise ValueError(msg.format(self))

            return (side, distance, continuity),

        side = self.side
        multi_side = not isinstance(side, str)

        if multi_side:
            nb_sides = len(side)
            if multi_dist:

                nb = len(distance)
                if nb_sides != nb:
                    msg = ("The number of sides (len={}), doesn't match the "
                           "number of distances (len={}). Match these. "
                           "Object: {}.")
                    raise ValueError(msg.format(nb_sides, nb, self))

                distances = distance
            else:
                distances = [distance] * nb_sides

            if multi_cont:

                nb = len(continuity)
                if nb_sides != nb:
                    msg = ("The number of sides (len={}), doesn't match the "
                           "number of continuities (len={}). Match these. "
                           "Object: {}.")
                    raise ValueError(msg.format(nb_sides, nb, self))

                continuities = continuity
            else:
                continuities = [continuity] * nb_sides

            distances_unpacked = []
            continuities_unpacked = []
            sides_unpacked = []
            for side, distance, continuity in zip(
                    side, distances, continuities):
                try:
                    side_unpacked = self._USER_SIDE_MAP[side]
                except KeyError:
                    msg = ("Side {} is not a valid option. Use one of {}. "
                           "Object: {}.")
                    raise ValueError(msg.format(
                        repr(side),
                        repr(list(self._USER_SIDE_MAP.keys())),
                        self))
                else:
                    for side_candidate in side_unpacked:
                        if side_candidate in sides_unpacked:
                            msg = ("Found double specification for side "
                                   "{}, offending key: {}. Object: {}.")
                            raise ValueError(msg.format(
                                repr(side_candidate), repr(side), self))

                    nb = len(side_unpacked)

                    distance_unpacked = [distance] * nb
                    continuity_unpacked = [continuity] * nb

                    sides_unpacked.extend(side_unpacked)
                    distances_unpacked.extend(distance_unpacked)
                    continuities_unpacked.extend(continuity_unpacked)

            return tuple(zip(sides_unpacked,
                             distances_unpacked,
                             continuities_unpacked))

        else:
            if multi_dist:
                msg = ("ExtendedSurface received one side specification ({}) "
                       "with multiple distance specs ({}). Either specify a "
                       "single distance value or specify a list of sides. "
                       "Object: {}.")
                raise ValueError(msg.format(
                    repr(side), repr(distance), self))
            elif multi_cont:
                msg = ("ExtendedSurface received one side specification ({}) "
                       "with multiple continuity specs ({}). Either specify a "
                       "single continuity value or specify a list of sides. "
                       "Object: {}.")
                raise ValueError(msg.format(
                    repr(side), repr(continuity), self))
            else:
                # single distance
                try:
                    sides = self._USER_SIDE_MAP[side]
                except KeyError:
                    msg = ("Side {} is not a valid option. Use one of {}. "
                           "Object: {}.")
                    raise ValueError(msg.format(
                        repr(side),
                        repr(list(self._USER_SIDE_MAP.keys())),
                        self))
                else:
                    return tuple((side, distance, continuity)
                                 for side in sides)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        surface_in = self.surface_in
        side_specs = self.side_specs

        h_geom_surface = surface_in.Handle_Geom_Surface
        h_bounded_surface = Handle_Geom_BoundedSurface.DownCast(h_geom_surface)
        if h_bounded_surface.IsNull():
            msg = ("surface_in is not a bounded surface: {}. It the surface "
                   "is infinite (e.g. Plane) there should not not be need to "
                   "extend it. Current object: {}.")
            raise RuntimeError(msg.format(surface_in, self))

        # copy input surface, since operation changes original surface
        h_geom_geometry = h_bounded_surface.Copy()
        h_bounded_surface = Handle_Geom_BoundedSurface.DownCast(
            h_geom_geometry)

        dct = self._SIDE_OCC_MAP
        for side, d, c in side_specs:
            in_u, after = dct[side]
            GeomLib__ExtendSurfByLength(h_bounded_surface, d, c, in_u, after)

        result = Handle_Geom_BSplineSurface.DownCast(h_bounded_surface)
        if result.IsNull():
            msg = "Extension did not return a B-Spline surface, contact {}."
            raise RuntimeError(msg.format(SUPPORT_EMAIL))
        return result


class NormalizedSurface(BSplineSurface_):
    """Normalizes a surface between u- and v-parameters. Usage:

    >>> from parapy.geom import NormalizedSurface, RectangularSurface
    >>> srf = RectangularSurface(width=2, length=2)
    >>> srf.uv_bounds
    (-1.0, 1.0, -1.0, 1.0)
    >>> obj = NormalizedSurface(srf, u1=0, u2=1, v1=0, v2=1)
    >>> obj.uv_bounds
    (0.0, 1.0, 0.0, 1.0)
    """

    __initargs__ = ["surface_in", "u1", "u2", "v1", "v2"]

    #: surface that will be normalized
    #: :type: Surface
    surface_in = Input()

    #: u start, defaults to 0.
    #: :type: float
    u1 = Input(0)

    #: u end, defaults to 1.
    #: :type: float
    u2 = Input(1)

    #: v start, defaults to 0.
    #: :type: float
    v1 = Input(0)

    #: v end, defaults to 1.
    #: :type: float
    v2 = Input(1)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        h_geom_bsplinesurface = self.surface_in.Handle_Geom_BSplineSurface

        # make a copy, since BSplCLib__Reparametrize mutates original!
        h_geom_geometry = h_geom_bsplinesurface.Copy()
        h_geom_bsplinesurface = Handle_Geom_BSplineSurface.DownCast(
            h_geom_geometry)

        uknots = TColStd_Array1OfReal(1, h_geom_bsplinesurface.NbUKnots())
        h_geom_bsplinesurface.UKnots(uknots)
        BSplCLib__Reparametrize(self.u1, self.u2, uknots)
        h_geom_bsplinesurface.SetUKnots(uknots)
        vknots = TColStd_Array1OfReal(1, h_geom_bsplinesurface.NbVKnots())
        h_geom_bsplinesurface.VKnots(vknots)
        BSplCLib__Reparametrize(self.v1, self.v2, vknots)
        h_geom_bsplinesurface.SetVKnots(vknots)
        return h_geom_bsplinesurface


class RectangularSurface(RectangularTrimmedSurface):
    """Make rectangular surface with :attr:`width` and :attr:`length`. The
    :attr:`position` input defines location and orientation. Where:

    - position.location is center of surface
    - position.Vz is normal
    - position.Vx corresponds to width direction
    - position.Vy corresponds to length direction

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> obj = RectangularSurface(width=2.0, length=1.0)
    >>> obj.area
    2.0
    """

    __initargs__ = ["width", "length"]

    #: width of surface
    #: :type: float
    width = Input(validator=val.Positive())

    #: length of surface
    #: :type: float
    length = Input(validator=val.Positive())

    @Attribute
    def uv_bounds(self):
        w, l = self.width, self.length
        return -0.5 * w, 0.5 * w, -0.5 * l, 0.5 * l

    @Attribute
    def basis_surface(self):
        return Plane(reference=self.position)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        plan = Geom_Plane(self.position.gp_Ax3).handle
        return Geom_RectangularTrimmedSurface(
            plan, self.u1, self.u2, self.v1, self.v2).handle


def validator_FilledSurface_curves(value, obj, slot):
    """Checks if the input is 2-4 b-spline curves"""
    return 2 <= len(value) <= 4 and all(
        [isinstance(val, Curve) for val in value])


class FilledSurface(BSplineSurface_):
    """Can fill a surface between 2-4 :attr:`curves`. Warning Some problems
    may show up with rational curves. If you want to fill more than 4 curves,
    consider a plate surface (ask support@parapy.nl). Usage:

    >>> from parapy.geom import FilledSurface, FittedCurve, LineSegment, Point
    >>> pts1 = [Point(0, 0, 0), Point(1, 0, 1), Point(2, 0, 0)]
    >>> crv1 = FittedCurve(points=pts1)
    >>> pts2 = [Point(0, 1, 0), Point(1, 1, 1), Point(2, 1, 0)]
    >>> crv2 = FittedCurve(points=pts2)
    >>> rail1 = LineSegment(start=crv1.start, end=crv2.start)
    >>> rail2 = LineSegment(start=crv1.end, end=crv2.end)
    >>> obj = FilledSurface(curves=[rail1, rail2, crv1, crv2])
    """

    __initargs__ = ["curves", "filling_style"]

    #: sequence of 2-4 curves that forms a closed loop.
    #: :type: collections.Sequence[Curve]
    curves = Input(validator=validator_FilledSurface_curves)

    #: type of filling, can be flat, medium or curved.
    #: - 'flat': the style with the flattest patches
    #: - 'medium': a rounded style of patch with less depth than 'curved'
    #: - 'curved': the style with the most rounded patches.
    #: :type: str
    filling_style = Input("flat",
                          validator=val.OneOf(["flat", "medium", "curved"]))

    @Attribute
    def bspline_curves(self):
        return getattrs(self.curves, "bspline")

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        curves = getattrs(self.bspline_curves, "Handle_Geom_BSplineCurve")
        style = self.filling_style
        if style == "flat":
            args = curves + [GeomFill_StretchStyle]
        elif style == "medium":
            args = curves + [GeomFill_CoonsStyle]
        else:
            args = curves + [GeomFill_CurvedStyle]
        return GeomFill_BSplineCurves(*args).Surface()


# TODO (TBD): default continuity to that of :attr:`path`.
# FIXME (TBD): rename NbMaxSegment to Pythonic something.
class _PipeSurface(BSplineSurface_):
    #: path used for sweeping
    #: :type: parapy.geom.Curve
    path = Input()
    #: desired C-continuity in path direction
    #: :type: int
    continuity = Input(1, validator=val.OneOf([0, 1, 2]))
    #: tolerance
    #: :type: float
    tolerance = Input(1.0e-6)
    #: max degree in v direction
    #: :type: int
    max_degree = Input(11, validator=val.Range(1, 11))
    #: max number of segments
    #: :type: int
    NbMaxSegment = Input(30)
    #:
    #: :type: bool
    polynomial = Input(False)

    _CONTINUITY = [GeomAbs_C0, GeomAbs_C1, GeomAbs_C2]

    @Attribute
    def _GeomFill_Pipe(self):
        """Build GeomFill_Pipe instance.

        :rtype: GeomFill_Pipe
        """
        builder = GeomFill_Pipe()
        self._init_GeomFill_Pipe(builder)
        builder.GenerateParticularCase(False)
        conti = self._CONTINUITY[self.continuity]
        # builder.Perform()
        builder.Perform(self.tolerance, self.polynomial, conti,
                        self.max_degree, self.NbMaxSegment)
        return builder

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        builder = self._GeomFill_Pipe
        handle = builder.Surface()
        return Handle_Geom_BSplineSurface(handle)

    @Attribute
    def error(self):
        """Returns the approximation's error.

        :rtype: float
        """
        return self._GeomFill_Pipe.ErrorOnSurf()

    def _init_GeomFill_Pipe(self, builder):
        """:type builder: GeomFill_Pipe"""
        raise NotImplementedError()


# TODO (TBD): GeomFill_IsConstantNormal? Do something with bi-normals?
class SweptSurface(_PipeSurface):
    """Make a surface with a constant :attr:`profile` along a :attr:`path`.
    By default, :attr:`frenet` is True in order to control the orientation of
    profile along the path in such a way that it minimizes twist. For a
    constant orientation, set it to False.

    Usage:

    >>> from parapy.geom import Point, FittedCurve, SweptSurface
    >>> pts = [Point(-1, 0, 0), Point(0, 0, 1), Point(2, 0, 0)]
    >>> profile = FittedCurve(pts)
    >>> pts = [Point(0, 0, 0), Point(0, 1, 1), Point(0, 2, 0)]
    >>> path = FittedCurve(points=pts)
    >>> obj = SweptSurface(profile=profile, path=path)
    >>> # for a not Frenet-corrected trihedron (constant orientation profile)
    >>> obj = SweptSurface(profile=profile, path=path, frenet=False)
    """

    __initargs__ = ["path", "profile"]

    #: curve that is swept along path
    #: :type: parapy.geom.Curve
    profile = Input()
    #: If True (default), a CorrectedFrenet trihedron is used (To avoid
    #:  twisted surface). If False, a constant trihedron is used to have all
    #: the sections in a same plane.
    #: :type: bool
    frenet = Input(True)

    def _init_GeomFill_Pipe(self, builder):
        if self.frenet:
            option = GeomFill_IsCorrectedFrenet
        else:
            option = GeomFill_IsFixed
        builder.Init(self.path.Handle_Geom_Curve,
                     self.profile.Handle_Geom_Curve,
                     option)


class PipeSurface(_PipeSurface):
    """Make a surface with a circular section of fixed :attr:`radius` along
    a :attr:`path`. Usage:

    >>> from parapy.geom import FittedCurve, Point, PipeSurface
    >>> pts = [Point(0, 0, 0), Point(0, 1, 1), Point(0, 2, 0)]
    >>> path = FittedCurve(points=pts)
    >>> obj = PipeSurface(path=path, radius=0.2)
    """

    __initargs__ = ["path", "radius"]

    #: radius of the pipe
    #: :type: float
    radius = Input()

    def _init_GeomFill_Pipe(self, builder):
        builder.Init(self.path.Handle_Geom_Curve, self.radius)


# FIXME (TBD): update docstring.
# FIXME (TBD): seems to not respect cross-section and deviates from them....
# FIXME (TBD): Circular profiles raising RuntimeError
class MultiSectionSurface(_PipeSurface):
    """Make a surface by sweeping N cross-sectional :attr:`profiles` along
    a :attr:`path`. Works best with 4-9 curves. Use
    :class:`~parapy.geom.occ.solid.MultiSectionSolid` for better results in
    case of 2-3 curves. If your profiles are wires, use
    :class:`~parapy.geom.SweptShell`. Usage:

    >>> from parapy.geom import (TrimmedCurve, FittedCurve, Circle, Point,
    ...                          MultiSectionSurface)
    >>> pts = [Point(0, 0, 0), Point(1, 4, 0), Point(0, 8, 0)]
    >>> path = FittedCurve(points=pts)
    >>> # Make a list of circles, positioned along path.
    >>> profiles = []
    >>> radius = [1.2, 0.5, 0.7, 1, 1.3]
    >>> for i in range(0, len(radius)):
    ...    position = (path.get_position(i * path.u2 / (len(radius) - 1)))
    ...    curve = Circle(radius=radius[i], position=position)
    ...    curve = TrimmedCurve(curve, 0, math.pi)
    ...    profiles.append(curve)
    >>> obj = MultiSectionSurface(path=path, profiles=profiles)

    .. note:: it helps to normalize your path/profiles! We've seen errors on
        non-normalized curves

    .. note:: When working with profiles that are (made of) Circles,
        creating the MultiSectionSurface might fail. One workaround is to
        trim one or more of these Circles using
        :class:`~parapy.geom.TrimmedCurve` using the original starting and
        ending parameters u1 and u2.
    """

    __initargs__ = ["path", "profiles"]

    #: list of curves
    #: :type: collections.Sequence[Curve]
    profiles = Input()

    def _init_GeomFill_Pipe(self, builder):
        coll = TColGeom_SequenceOfCurve()
        for curve in self.profiles:
            if curve.TOPOLEVEL == 6:
                coll.Append(curve.Handle_Geom_Curve)
            else:
                msg = ("Valid curves are Curve and Edge (not wires or "
                       "higher-level topology). If you have a wire, use "
                       "SweptShell. Invalid object: {}.")
                raise RuntimeError(msg.format(curve))

        try:
            builder.Init(self.path.Handle_Geom_Curve, coll)
        except RuntimeError:
            if any(isinstance(c, Circle) for c in self.profiles):
                msg = ("Creating a MultiSectionSurface failed. It is a known "
                       "error that occurs when some or all profiles are "
                       "circles. A workaround might be to trim the circles "
                       "using TrimmedCurve, "
                       "using the original starting and ending parameters "
                       "(u1, u2). Object: {}")
                raise RuntimeError(msg.format(self))
            else:  # re-raise
                raise


# TODO (TBD): support NxM split instead of 1xM or Nx1 only.
class DecomposedSurface(GeomBase):
    """An algorithm to determine isoparametric curves along which a BSpline
    surface :attr:`surface_in` should be split in order to obtain patches of
    the same continuity, :attr:`u_continuity` and :attr:`v_continuity`. Usage:

    >>> from parapy.geom import (Rectangle, FilletedWire, RuledSurface,
    ...                          DecomposedSurface)
    >>> wire = Rectangle(1,1)
    >>> filleted_wire1 = FilletedWire(wire, 0.1)
    >>> filleted_wire2 = FilletedWire(wire, 0.1).translated('z', 2)
    >>> surface = RuledSurface(curve1=filleted_wire1.curve,
    ...                        curve2=filleted_wire2.curve)
    >>> obj = DecomposedSurface(surface_in=surface)
    >>> len(obj.surfaces)
    8

    For more information, see `Open Cascade Documentation <http://opencascade
    .sourcearchive.com/documentation/6.3.0.dfsg.1-1/
    classGeomConvert__BSplineSurfaceKnotSplitting.html>`__.
    """

    __initargs__ = ("surface_in", "u_continuity", "v_continuity")

    #: B-Spline surface
    #: :type: Surface
    surface_in = Input()

    #: degree of the BSplines in u direction
    #: :type: int
    u_continuity = Input(1, validator=val.GT(-1))

    #: degree of the BSplines in v direction
    #: :type: int
    v_continuity = Input(1, validator=val.GT(-1))

    #: colors of the patches
    #: :type: collections.Sequence[str]
    sub_colors = Input(["RED", "GREEN", "BLUE", "ORANGE", "CYAN", "BLACK"])

    @PartNoParsing
    def surfaces(self):
        sub_colors = self.sub_colors
        L = len(sub_colors)
        h_geom_bpslinesurface = self.surface_in.Handle_Geom_BSplineSurface
        builder = GeomConvert_BSplineSurfaceKnotSplitting(
            h_geom_bpslinesurface,
            self.u_continuity,
            self.v_continuity)
        nbusplits = builder.NbUSplits()
        nbvsplits = builder.NbVSplits()
        if nbusplits > 2:
            if nbvsplits != 2:
                msg = ("this object can only deal with multiple split in one "
                       "isoparametric direction for now, not Nu: {}, Nv: {}.")
                raise RuntimeError(msg.format(nbusplits - 1, nbvsplits - 1))
        if nbvsplits > 2:
            if nbusplits != 2:
                msg = ("this object can only deal with multiple split in one "
                       "isoparametric direction for now, not Nu: {}, Nv: {}.")
                raise RuntimeError(msg.format(nbusplits - 1, nbvsplits - 1))
        uknots = [builder.USplitValue(i + 1) for i in range(nbusplits)]
        vknots = [builder.VSplitValue(i + 1) for i in range(nbvsplits)]
        if nbusplits > 2:
            return [BSplineSurface_(
                Handle_Geom_Surface=GeomConvert__SplitBSplineSurface(
                    h_geom_bpslinesurface,
                    uknots[i], uknots[i + 1],
                    vknots[0], vknots[1]),
                color=sub_colors[int(math.fmod(i, L))])
                for i in range(nbusplits - 1)]
        else:
            return [BSplineSurface_(
                Handle_Geom_Surface=GeomConvert__SplitBSplineSurface(
                    h_geom_bpslinesurface,
                    uknots[0], uknots[1], vknots[i],
                    vknots[i + 1]),
                color=sub_colors[int(math.fmod(i, L))])
                for i in range(nbvsplits - 1)]


class SweptSurface_(Surface):
    """Wraps around :class:`OCC.Geom.Handle_Geom_SweptSurface` instance."""

    __initargs__ = ["Handle_Geom_Surface"]
    __Handle_Geom_Surface__ = Handle_Geom_SweptSurface

    #: :type: OCC.Geom.Handle_Geom_SweptSurface
    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def continuity(self):
        """Return the continuity of the surface:

        - 0 -> C0: only geometric continuity.
        - 1 -> G1: for each point on the curve, the tangent vectors
            "on the right" and "on the left" are collinear with the same
            orientation.
        - 2 -> C1: continuity of the first derivative. The "C1" curve is also
            "G1" but, in addition, the tangent vectors " on the right" and
            "on the left" are equal.
        - 3 -> G2: for each point on the curve, the normalized normal vectors
            "on the right" and "on the left" are equal.
        - 4 -> C2: continuity of the second derivative.
        - 5 -> C3: continuity of the third derivative. 
        - 6 -> CN: continuity of the N-th derivative, whatever is the value
            given for N (infinite order of continuity).

        :rtype: int
        """
        return self.Handle_Geom_Surface.Continuity()

    @Attribute
    def direction(self):
        """Return the reference direction of the swept surface. For a surface
        of revolution it is the direction of the revolution axis, for a
        surface of linear extrusion it is the direction of extrusion..

        :rtype: parapy.geom.Vector
        """
        return Vector(*self.Handle_Geom_Surface.Direction().Coord())

    @PrivatePartNoParsing
    def basis_curve(self):
        """Return the referenced curve of the surface. For a surface of
        revolution it is the revolution curve, for a surface of linear
        extrusion it is the extruded curve.

        :rtype: parapy.geom.Curve
        """
        handle = self.Handle_Geom_Surface.BasisCurve()
        h_geom_curve, class_ = Handle_Geom_Curve2ParaPy(handle)
        return class_(Handle_Geom_Curve=h_geom_curve)

    @property
    def _new_surface_type(self):
        return SweptSurface_


class RevolvedSurface_(SweptSurface_):
    """Wraps around :class:`OCC.Geom.Handle_Geom_SurfaceOfRevolution`
    instance."""

    __Handle_Geom_Surface__ = Handle_Geom_SurfaceOfRevolution

    #: :type: OCC.Geom.Handle_Geom_SurfaceOfRevolution
    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def center(self):
        return Point(*self.Handle_Geom_Surface.Location().Coord())

    @property
    def _new_surface_type(self):
        return RevolvedSurface_


class RevolvedSurface(RevolvedSurface_):
    """Rotates a :attr:`basis_curve` about an axis defined by :attr:`center` and
    :attr:`direction`. Usage:

    >>> from parapy.geom import Point, Vector, FittedCurve, RevolvedSurface
    >>> crv = FittedCurve([Point(1, 0, 0), Point(2, 0, 1), Point(1, 0, 2)])
    >>> obj = RevolvedSurface(basis_curve=crv,
    ...                       center=Point(0, 0, 0),
    ...                       direction=Vector(0, 0, 1))
    >>> obj.uv_bounds  # doctest: +ELLIPSIS
    (0.0, 6.2831..., 0.0, 1.0)
    >>> # for a partial revolution, specifiy angle
    >>> import math
    >>> obj = RevolvedSurface(basis_curve=crv,
    ...                       center=Point(0, 0, 0),
    ...                       direction=Vector(0, 0, 1),
    ...                       angle=math.pi)
    >>> obj.uv_bounds  # doctest: +ELLIPSIS
    (0.0, 3.1415..., 0.0, 1.0)
    """

    __initargs__ = ["basis_curve", "center", "direction"]

    @property
    def __Handle_Geom_Surface__(self):
        angle = self.angle
        if angle is None or angle == 2 * math.pi:
            return Handle_Geom_SurfaceOfRevolution
        else:
            return Handle_Geom_RectangularTrimmedSurface

    #: curve that will be rotated
    #: :type: Curve
    basis_curve = Input()
    #: center of revolution. Defaults to :attr:`position`'s location.
    #: :type: Point
    center = Input(derived)
    #: direction of revolution. Defaults to :attr:`position` z-axis.
    #: :type: Vector
    direction = Input(derived)
    #: angle of revolution, ``None`` (i.e. ``2 * math.pi``) by default.
    #: :type: float | None
    angle = Input(None)

    #: **DEPRECATED**. Use basis_curve instead.
    profile = Input()

    @center.getter
    def center(self):
        return self.position.location

    @direction.getter
    def direction(self):
        return self.position.Vz

    @Attribute(private=True)
    def Handle_Geom_SurfaceOfRevolution(self):
        if self.is_user_defined("profile"):
            msg = ("RevolvedSurface.profile has been deprecated, use "
                   "basis_curve instead. Object: {}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning,
                          stacklevel=4)
            basis_curve = self.profile
        else:
            basis_curve = self.basis_curve

        ax1 = gp_Ax1(gp_Pnt(*self.center), gp_Dir(*self.direction))
        return Geom_SurfaceOfRevolution(
            basis_curve.Handle_Geom_Curve, ax1).handle

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        angle = self.angle
        srf = self.Handle_Geom_SurfaceOfRevolution
        if angle is None or angle == 2 * math.pi:
            return srf
        else:
            u1, _, v1, v2 = srf.Bounds()
            u2 = angle
            return Geom_RectangularTrimmedSurface(
                srf,
                # convert to float explicitly
                float(u1), float(u2), float(v1), float(v2)).handle

    @Attribute
    def basis_surface(self):
        angle = self.angle
        if angle is None or angle == 2 * math.pi:
            return self
        else:
            return RevolvedSurface_(
                Handle_Geom_Surface=self.Handle_Geom_SurfaceOfRevolution)

    @property
    def _new_surface_type(self):
        angle = self.angle
        if angle is None or angle == 2 * math.pi:
            return RevolvedSurface_
        else:
            return RectangularTrimmedSurface_


class ExtrudedSurface_(SweptSurface_):
    """Wraps around :class:`OCC.Geom.Handle_Geom_SurfaceOfLinearExtrusion`
    instance."""

    __Handle_Geom_Surface__ = Handle_Geom_SurfaceOfLinearExtrusion

    #: :type: OCC.Geom.Handle_Geom_SurfaceOfLinearExtrusion
    Handle_Geom_Surface = Input(private=True)

    @property
    def _new_surface_type(self):
        return ExtrudedSurface_


class ExtrudedSurface(ExtrudedSurface_, InfiniteSurface):
    """Sweep a curve, :attr:`basis_curve` linearly along vector
    :attr:`direction`. Default direction is z-direction of :attr:`position`.
    The resulting surface is **infinite** in sweeping direction, :attr:`v_dim`
    controls visualization length. Usage:

    >>> from parapy.geom import Point, Vector, FittedCurve, ExtrudedSurface
    >>> crv = FittedCurve([Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)])
    >>> srf = ExtrudedSurface(basis_curve=crv, direction=Vector(0, 1, 0))
    """

    __initargs__ = ["basis_curve", "direction"]

    #: Curve that will be extruded.
    #: :type: parapy.geom.Curve
    basis_curve = Input()

    #: direction in which the curve is linearly swept. Defaults to z-direction
    #: of :attr:`position`.
    #: :type: Vector
    direction = Input(derived)

    #: The dimension for visualization. Corresponds to dimension in extrusion
    #: direction.
    #: :type: float
    v_dim = Input(1)

    #: copy of InfiniteSurface
    #: :type: str
    display_mode = Input("wireframe")

    #: **DEPRECATED**. Use basis_curve instead.
    profile = Input()

    @direction.getter
    def direction(self):
        return self.position.Vz

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        if self.is_user_defined("profile"):
            msg = ("RevolvedSurface.profile has been deprecated, use "
                   "basis_curve instead. Object: {}.")
            warnings.warn(msg.format(self), ParaPyDeprecationWarning,
                          stacklevel=4)
            basis_curve = self.profile
        else:
            basis_curve = self.basis_curve
        crv = basis_curve.Handle_Geom_Curve
        v = gp_Dir(*self.direction)
        return Geom_SurfaceOfLinearExtrusion(crv, v).handle

    @Attribute
    def _drawable_TopoDS_Shape(self):
        u1, u2, _, _ = self.uv_bounds
        dim = 0.5 * self.v_dim
        builder = BRepBuilderAPI_MakeFace(self.Handle_Geom_Surface,
                                          u1, u2, -dim, dim, TOLDEGEN)
        if builder.IsDone():
            return builder.Shape()
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    def find_parameter_inside(self):
        u1, u2, _, _ = self.uv_bounds
        return u1 + (u2 - u1) / 2., 0


class LinearlySweptSurface(ExtrudedSurface):
    def __init__(self, *args, **kwargs):
        msg = ("LinearlySweptSurface is deprecated, use ExtrudedSurface "
               "instead. Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning)
        super(LinearlySweptSurface, self).__init__(*args, **kwargs)


# TODO (TBD): check that no legacy code uses Plane(position=...)
# TODO (TBD): exploit new value_available() method in v1 to provide better
# /todo defaults for all Inputs.
class Plane(InfiniteSurface):
    """Infinite planar surface. Position.Vz is normal.Usage:

    >>> from parapy.geom import XOY, rotate90, Point, Vector, Plane
    >>> # from point and normal vector
    >>> pln = Plane(reference=Point(0, 0, 0), normal=Vector(0, 0, 1))
    >>> # with explicit binormal ('x')
    >>> pln = Plane(reference=Point(0, 0, 0), normal=Vector(0, 0, 1),
    ...             binormal=Vector(0, 1, 0))
    >>> # from Position instance
    >>> pln = Plane(rotate90(XOY, 'z'))
    >>> pln.orientation.x
    Vector(0.0, 1.0, 0.0)
    >>> pln.get_point(x=1, y=2, z=3)
    Point(-2.0, 1.0, 3.0)
    >>> pln.distance_to_point(Point(0, 0, 3))
    3.0
    >>> pln.point_in_plane(Point(0, 0, 3))
    False
    >>> pln.point_in_plane(Point(0, 0, 0))
    True
    >>> pln.point_in_plane(Point(0, 0, 1e-3))
    False
    >>> pln.point_in_plane(Point(0, 0, 1e-3), tolerance=2e-3)
    True
    """

    __initargs__ = ["reference", "normal", "binormal"]
    __Handle_Geom_Surface__ = Handle_Geom_Plane

    #: Optional center point for plane definition. Can be a point or a
    # Position. Defaults to ``position`` in ancestor object, if available,
    # else ``XOY``.
    #: :type: Point | Position
    reference = Input(XOY, defaulting="position")
    #: Optional plane normal or 'z' direction.
    #: :type: Vector
    normal = Input(derived)
    #: Optional plane bi-normal or 'x' direction. This input is optional.
    #: The default value is derived from the primary normal.
    #: :type: Vector
    binormal = Input(derived)
    #: The dimension for visualization. Corresponds to width/length of plane.
    #: :type: float
    v_dim = Input(1.0)

    @normal.getter
    def normal(self):
        if isinstance(self.reference, Position):
            return self.reference.Vz
        else:
            return VZ

    @binormal.getter
    def binormal(self):
        if isinstance(self.reference, Position):
            return self.reference.Vx
        else:
            v = self.normal
            return orthogonal_vector(v, normalize=False)

    @Attribute
    def is_planar(self):
        return True

    @Attribute
    def position(self):
        pt, vz, vx = self.reference, self.normal, self.binormal
        orient = Orientation(x=vx, z=vz)
        return Position(pt, orient)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_Plane(self.position.gp_Ax3).handle

    @Attribute
    def plane_normal(self):
        return self.orientation.z

    @Attribute
    def coefficients(self):
        """Ax + By + Cz + D = 0.0"""
        return self.Handle_Geom_Surface.Coefficients()

    @Attribute
    def builder(self):
        srf = self.Handle_Geom_Surface.Pln()
        builder = BRepBuilderAPI_MakeFace(srf)
        if builder.IsDone():
            return builder
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @Attribute
    def _drawable_TopoDS_Shape(self):
        srf = self.Handle_Geom_Surface.Pln()
        dim = 0.5 * self.v_dim
        builder = BRepBuilderAPI_MakeFace(srf, -dim, dim, -dim, dim)
        if builder.IsDone():
            return builder.Shape()
        else:
            msg = "Converting surface to face failed. Object: {}."
            raise RuntimeError(msg.format(self))

    @property
    def _new_surface_type(self):
        return Plane_

    def get_point(self, x=0, y=0, z=0):
        """Get a 3d point relative to this plane's location and orientation.

        :rtype: parapy.geom.Point
        """
        pt = self.location
        vx, vy, vz = self.orientation
        return pt + x * vx + y * vy + z * vz

    def distance_to_point(self, point, signed=False):
        """Distance between point and plane.

        :param parapy.geom.Point point:
        :param signed: When False the distance is always >= 0;
            When True the distance will be negative when the point
            lies in the halfspace opposite to were this plane's normal
            points to.
        :type signed: bool
        :rtype: float
        """
        return Point.distance_to_plane(point, reference=self.location,
                                       normal=self.plane_normal,
                                       signed=signed)

    def point_in_plane(self, point, tolerance=1.0e-7):
        """Does ``point`` lie in this plane within given ``tolerance``?

        :param parapy.geom.Point point:
        :param float tolerance: numeric tolerance for determining if this
            point lies in plane.
        :rtype: bool
        """
        return Point.in_plane(point, reference=self.location,
                              normal=self.plane_normal, tolerance=tolerance)


class Plane3P(Plane):
    """Create a Plane from 3 points: :attr:`point1`, :attr:`point2` and
    :attr:`point3`. The plane will be located at :attr:`point1` and it normal
    vector is the cross product of the vectors :attr:`point1`-:attr:`point2`
    and :attr:`point1`-:attr:`point3`. If these vectors are parallel, a
    RuntimeError is raised. Usage:

    >>> from parapy.geom import Point, Plane3P
    >>> srf = Plane3P(Point(0, 0, 0), Point(1, 0, 0), Point(0, 1, 0))
    >>> srf.normal
    Vector(0.0, 0.0, 1.0)
    >>> srf.reference
    Point(0, 0, 0)
    >>> # if points are in-line, an error is raised
    >>> srf = Plane3P(Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0))
    >>> srf.normal  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
        ...
    RuntimeError: Vectors pt1->pt2 and pt1->pt3 are parallel, ...
    """

    __initargs__ = "point1", "point2", "point3"

    #: :type: Point
    point1 = Input()
    #: :type: Point
    point2 = Input()
    #: :type: Point
    point3 = Input()

    @Attribute
    def normal(self):
        """Plane normal is cross product of vectors
        :attr:`point1`-:attr:`point2` and :attr:`point1`-:attr:`point3`.
        Returned as unit-vector.

        :rtype: Vector
        """
        v = self.point2 - self.point1
        w = self.point3 - self.point1
        z = Vector.cross(v, w)
        if z.is_zero:
            msg = ("Vectors point1-point2 and point1-point3 are parallel, "
                   "leading to zero-vector in cross product. Make sure points "
                   "aren't in line. Object: {}.")
            raise RuntimeError(msg.format(self))
        else:
            return z.normalized

    @Attribute
    def reference(self):
        """:rtype: Point"""
        return Point(*self.point1)


class Plane_(Plane):
    __initargs__ = ["Handle_Geom_Surface"]

    #: :type: OCC.Geom.Handle_Geom_Plane
    Handle_Geom_Surface = Input(private=True)

    @Attribute
    def position(self):
        return self.Handle_Geom_Surface.Position().position

    @Attribute
    def reference(self):
        return self.position

    @Attribute
    def normal(self):
        return self.position.orientation.z

    @Attribute
    def binormal(self):
        return self.position.orientation.x


class TranslatedPlane(Plane):
    """Translate some plane :attr:`built_from` over :attr:`displacement`
    (either a float or a :class:`Vector`). Usage:

    >>> from parapy.geom import Plane, TranslatedPlane, Point, Vector
    >>> # simple: point and normal vector
    >>> pln1 = Plane(reference=Point(0, 0, 0), normal=Vector(0, 0, 1))
    >>> # displacement as distance float (direction normal to built_from plane)
    >>> pln2 = TranslatedPlane(built_from=pln1, displacement=1)
    >>> pln2.center, pln2.normal
    (Point(0.0, 0.0, 1.0), Vector(0.0, 0.0, 1.0))
    >>> # displacement as Vector (explicit direction)
    >>> pln3 = TranslatedPlane(built_from=pln1, displacement=Vector(1, 0, 0))
    >>> pln3.center, pln3.normal
    (Point(1.0, 0.0, 0.0), Vector(0.0, 0.0, 1.0))
    """

    __initargs__ = ["built_from", "displacement"]

    #: plane to translate.
    #: :type: Plane
    built_from = Input()
    #: either a scalar value or a Vector. In case of a scalar value,
    #: :attr:`built_from` normal is used. Use a negative value to reverse
    #: displacement.
    #: :type: float | Vector
    displacement = Input()
    #: The dimension for visualization. Corresponds to width/length of plane.
    #: Defaults to :attr:`v_dim` of :attr:`built_from`.
    #: :type: float
    v_dim = Input(derived)

    @v_dim.getter
    def v_dim(self):
        return self.built_from.v_dim

    @Attribute
    def displacement_vector(self):
        d = self.displacement
        if hasattr(type(d), "__iter__"):
            return d
        else:
            v = self.built_from.position.Vz
            return d * v

    @Attribute
    def reference(self):
        """:rtype: parapy.geom.Point | parapy.geom.Position"""
        return self.built_from.reference + self.displacement_vector

    @Attribute
    def normal(self):
        """:rtype: parapy.geom.Vector"""
        return self.built_from.orientation.z

    @Attribute
    def binormal(self):
        """:rtype: Vector"""
        return self.built_from.orientation.x

    @Attribute
    def position(self):
        """:rtype: parapy.geom.Position"""
        return self.built_from.position + self.displacement_vector

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        vec = self.displacement_vector
        trsf = gp_Trsf()
        trsf.SetTranslation(gp_Vec(*vec))
        surf = self.built_from.Handle_Geom_Surface
        handle = surf.Transformed(trsf)
        return Handle_Geom_Plane(handle)


class Plane4C(Plane_):
    """Givens four coefficients Ax + By + Cz + D = 0.0. Usage:

    >>> from parapy.geom import Plane4C
    >>> obj = Plane4C(coefficients=(1, 2, 3, 4))
    """

    __initargs__ = ["coefficients"]

    #: tuple of plane coefficients A, B, C and D.
    #: :type: collections.Sequence[float]
    coefficients = Input()

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return Geom_Plane(*self.coefficients).handle


# FIXME (TBD): rename NbMaxSegment to Pythonic something.
class QuadBlendSurface(BSplineSurface_):
    """Returns a new surface where u-v and are aligned with borders. The input
    face :attr:`built_from` should only have 4 edges! Usage:

    >>> from parapy.geom import rotate, Rectangle, TrimmedSurface, QuadBlendSurface
    >>> srf = RectangularSurface(3, 3)
    >>> wire = Rectangle(1, 1, position=rotate(XOY, 'z', 45, deg=True))
    >>> face = TrimmedSurface(srf, wire)
    >>> face.uv_bounds
    (-0.7071067811865476, 0.7071067811865475, -0.7071067811865475, 0.7071067811865476)
    >>> srf = QuadBlendSurface(face)
    >>> srf.uv_bounds
    (0.0, 1.0, 0.0, 1.0)
    """

    __initargs__ = ["built_from"]

    #: an existing face with 4 edges
    #: :type: Surface
    built_from = Input()

    #: The surface to be filled along this boundary will be in the tolerance
    #: range defined by tolerance.
    #: :type: float
    tolerance = Input(1e-6)

    #: What's more, at each point of CurveOnSurf, the angle between the normal
    #: to the surface to be filled along this boundary, and the normal to the
    #: surface on which CurveOnSurf lies, must not be greater than
    #: angular_tolerance.
    #: :type: float
    angular_tolerance = Input(1e-6)

    #: max degree
    #: :type: int
    max_degree = Input(11, validator=val.Range(1, 11))

    #: max number of segments
    #: :type: int
    NbMaxSegment = Input(30)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return self._GeomFill_ConstrainedFilling.Surface()

    @Attribute
    def _GeomFill_ConstrainedFilling(self):
        face = self.built_from
        L = len(face.edges)
        if not L == 4:
            msg = "Your input geometry should have only 4 edges, not:"
            raise Exception(msg, L)
        else:
            bounds = []
            for edge in face.edges:
                # FIXME (RvD): what was this supposed to do?
                pcurve = edge.Handle_Geom2d_Curve  # (face)
                # pcurve = edge._Handle_Geom2d_Curve(face)
                curv = Geom2dAdaptor_HCurve(pcurve).handle
                surf = GeomAdaptor_HSurface(face.Handle_Geom_Surface).handle
                curv_on_surf = Adaptor3d_CurveOnSurface(curv, surf)
                bound = GeomFill_BoundWithSurf(curv_on_surf,
                                               self.tolerance,
                                               self.angular_tolerance).handle
                bounds.append(bound)
            builder = GeomFill_ConstrainedFilling(self.max_degree,
                                                  self.NbMaxSegment)
            builder.Init(*bounds)
            return builder
            # return ReconstructedFace.builder.fn(self) # no super(...)


# TODO (TBD): allows Point constraints.
class PlateSurface(BSplineSurface_):
    """Makes a plate surface that conforms to curve constraints, viz. a
    sequences of :attr:`curves`. Usage:

    >>> from parapy.geom import Point, BezierSurface, PlateSurface
    >>> points = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...           (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...           (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> bezier = BezierSurface(control_points=points)
    >>> obj = PlateSurface(curves=bezier.edges)
    """

    __initargs__ = ["curves"]

    #: Sequence of curves forming constraints for this plate surface.
    #: :type: collections.Sequence[parapy.geom.Curve]
    curves = Input()

    #: maximum allowed approximation error
    #: :type: float
    tolerance = Input(1.0e-4)

    #: max degree
    #: :type: int
    max_degree = Input(11, validator=val.Range(1, 11))

    #: max number of segments
    #: :type: int
    NbMaxSegment = Input(30)

    @Attribute
    def _Handle_GeomPlate_Surface(self):
        builder = GeomPlate_BuildPlateSurface()
        for curve in self.curves:
            hcurve = GeomAdaptor_HCurve(curve.Handle_Geom_Curve,
                                        curve.u1, curve.u2).handle
            constr = GeomPlate_CurveConstraint(hcurve, 0).handle
            builder.Add(constr)
        builder.Perform()
        if not builder.IsDone():
            raise Exception("GeomPlate_BuildPlateSurface failed")
        else:
            return builder.Surface()

    @Attribute
    def _GeomPlate_MakeApprox(self):
        Tol3d = self.tolerance
        Nbmax = self.NbMaxSegment
        dgmax = self.max_degree
        dmax = Tol3d
        return GeomPlate_MakeApprox(self._Handle_GeomPlate_Surface,
                                    Tol3d, Nbmax, dgmax, dmax)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        return self._GeomPlate_MakeApprox.Surface()


class ReconstructedSurface(PlateSurface):
    """Makes a plate surface that conforms the edges of :attr:`built_from`
    surface. Usage:

    >>> from parapy.geom import Point, BezierSurface, ReconstructedSurface
    >>> points = ((Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)),
    ...           (Point(0, 0, 1), Point(1, -1, 1), Point(2, 0, 1)),
    ...           (Point(0, 0, 2), Point(1, 1, 2), Point(2, 0, 2)))
    >>> bezier = BezierSurface(control_points=points)
    >>> obj = ReconstructedSurface(built_from=bezier)
    """

    __initargs__ = ["built_from"]

    #: (bounded) Surface / Face that will be reconstructed with its border
    #: edges as constraints (no holes allowed!).
    #: :type: parapy.geom.Surface
    built_from = Input()

    @Attribute
    def curves(self):
        return self.built_from.edges

    def __init__(self, *args, **kwargs):
        msg = ("ReconstructedSurface is deprecated, use PlateSurface "
               "instead with curves=built_from.edges. Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning)
        super(ReconstructedSurface, self).__init__(*args, **kwargs)


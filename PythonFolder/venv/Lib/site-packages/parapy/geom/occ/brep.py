#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import warnings
from collections import OrderedDict

from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_NurbsConvert, BRepBuilderAPI_Transform)
from OCC.wrapper.BRepCheck import BRepCheck_Analyzer
from OCC.wrapper.BRepGProp import (
    BRepGProp__LinearProperties, BRepGProp__SurfaceProperties,
    BRepGProp__VolumeProperties)
from OCC.wrapper.GProp import GProp_GProps
from OCC.wrapper.TopAbs import TopAbs_FORWARD, TopAbs_REVERSED
from OCC.wrapper.TopLoc import TopLoc_Location
from OCC.wrapper.TopoDS import TopoDS_Shape

from parapy.core import Attribute, Input  # , PrivatePartNoParsing, getattrs
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.globs import (
    Level2Attr, Level2Class, Name2Level, TopAbs2Class)
from parapy.geom.occ.history import HistoryMixin
from parapy.geom.occ.mixins import TransformationMixin
from parapy.geom.occ.tolerances import get_max_tolerances, limit_max_tolerances
from parapy.geom.occ.utilities import (
    AncestorMap_, SUB_ANCESTOR_SHAPE_TYPE_MAP, SubShapeGenerator, TOPABS_NAMES,
    ancestors, iterate_TopTools_ListOfShape, iterate_TopTools_SequenceOfShape,
    unique_shape_generator_)


# TODO: Don't inherit DrawableShape
class BRep(DrawableShape, TransformationMixin, HistoryMixin):
    """Root class of Vertex, Edge, Wire, Face, Shell, Solid and Compound

    All subclasses implement, builder and TopoDS_Shape."""

    # ---- these will be patched by respective subclasses in other modules ----
    VertexClass = None
    EdgeClass = None
    WireClass = None
    FaceClass = None
    ShellClass = None
    SolidClass = None
    CompsolidClass = None
    CompoundClass = None
    FusedClass = None
    SubtractedClass = None
    CommonClass = None
    BRepClass = None
    TOPODIM = None
    TOPOLEVEL = None  # 7: Vertex, 6: Edge, 5: Wire, 4: Face, 3: Shell,
                      # 2: Solid, 1: CompSolid, 0: Compound
    BUILDERKEY = "Shape"  # self.builder.Shape()

    # TODO: change from Input to simple property or something (no caching).
    #: Another BRep object from which this object clones.
    #: :type: parapy.geom.occ.brep.BRep
    _clone = Input(None)

    #: Input of type TopLoc_Location
    #: :type: OCC.TopLoc.TopLoc_Location | None
    _transformation = Input(None)

    # FIXME: history should only be an attribute inside BRepBuilder classes.
    #: :type: SubShapeHistory
    # history = HiddenPartNoParsing(SubShapeHistory)

    # ---------------- representations -------------------
    @Input(private=True)
    def builder(self):
        """The builder of this shape

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        """
        if self._clone:
            if self._transformation:
                builder = BRepBuilderAPI_Transform(self._clone.TopoDS_Shape,
                                                   self._transformation[0],
                                                   True)
                if builder.IsDone():
                    # FIXME: use BRepBuilderAPI_Copy
                    return builder
                else:
                    raise Exception("transformation failed")
            return self._clone.builder
        # TODO: different builder for _transformation BRepBuilder... Transform
        else:
            raise RuntimeError("Apparently this class has no builder, "
                               "perhaps because it's a subshape?")

    @Input(private=True)
    def TopoDS_Shape(self):
        """if needed, override on subclassing. But leave an input in
        direct subclasses of BRep!

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        if self._clone:
            if self._transformation:
                return self.builder.Shape()
            else:
                # FIXME: use BRepBuilderAPI_Copy
                return self._clone.TopoDS_Shape
        else:
            return getattr(self.builder, self.BUILDERKEY)()

    @Input
    def _owner(self):
        """My topological owner. If None, I'm the root object of
        this topology.

        :rtype: BRep | None
        """
        if self._clone and not self._transformation:
            return self._clone._owner
        else:
            return None

    @property
    def brep(self):
        """
        :rtype: BRep
        """
        return self

    @Attribute
    def dynamic_shape_type(self):
        """Dynamic shape type. Returns ParaPy BRep class.

        :rtype: parapy.core.meta.basetype
        """
        return getattr(self, TopAbs2Class[self.TopoDS_Shape.ShapeType()])

    @Attribute
    def downcast(self):
        """Get a more specific representation of this object.

        :rtype: BRep
        """
        class_ = getattr(self, TopAbs2Class[self.TopoDS_Shape.ShapeType()])
        return class_(TopoDS_Shape = self.TopoDS_Shape,
                      _owner = self._owner)

    @property
    def _new_shape_type(self):
        """Dynamic shape type. Returns ParaPy BRep class

        :rtype: parapy.core.meta.basetype
        """
        return getattr(self, Level2Class[self.TOPOLEVEL])

    # ---------------- booleans -------------------
    def __add__(self, other):
        """boolean fuse"""
        return self.FusedClass(self, other)

    def __sub__(self, other):
        """boolean subtraction"""
        return self.SubtractedClass(self, other)

    def __and__(self, other):
        """boolean common"""
        return self.CommonClass(self, other)

    # ---------------- topology -------------------
    @Attribute
    def calculated_position(self):
        """Retrieves position from TopoDS_Shape

        :rtype: parapy.geom.Position
        """
        return self.TopoDS_Shape.Location().Transformation().position

    @Attribute
    def brep_orientation(self):
        """Forward shape orientation means that the logical direction
        matches direction of the
        underlying geometry. Reversed orientation means that logical
        direction is opposite to the
        direction of the geometry. For example, an edge can have a
        reversed orientation from its
        underlying curve.

        :returns: 'forward' or 'reversed'.
        :rtype str | tuple[bool, str]
        """
        orient = self.TopoDS_Shape.Orientation()
        if orient == TopAbs_FORWARD:
            return "forward"
        elif orient == TopAbs_REVERSED:
            return "reversed"
        assert False, ("Shape orientation was expected to either match"
                       " TopAbs_FORWARD or TopAbs_REVERSED. "
                       "Not: {}").format(orient)

    @Attribute
    def max_tolerances(self):
        """
        :rtype: tuple[float]
        """
        topods_shape = self.TopoDS_Shape
        return get_max_tolerances(topods_shape)

    def _TopTools_ListOfShape2Shapes(self, lsh, shape_type=None):
        """
        :param OCC.TopTools.TopTools_ListOfShape lsh: list of shapes.
        :param str | int shape_type: Set to a shape type name or
            TopAbs_ShapeEnum to denote that all results are of the same shape
            type (which results in a performance boost, and otherwise might
            result in errors). See :func:`~BRep._TopoDS2Shapes`.
        :rtype: tuple[BRep]
        """
        if lsh.IsEmpty():
            return ()
        else:
            gen = iterate_TopTools_ListOfShape(lsh)
            return self._TopoDS2Shapes(gen, shape_type=shape_type)

    def _TopTools_SequenceOfShape2Shapes(self, seq, shape_type=None):
        """
        :param OCC.TopTools.TopTools_SequenceOfShape seq: list of shapes.
        :param str | int shape_type: Set to a shape type name or
            TopAbs_ShapeEnum to denote that all results are of the same shape
            type (which results in a performance boost, and otherwise might
            result in errors). See :func:`~BRep._TopoDS2Shapes`.
        :rtype: tuple[BRep]
        """
        if seq.IsEmpty():
            return ()
        else:
            gen = iterate_TopTools_SequenceOfShape(seq)
            return self._TopoDS2Shapes(gen, shape_type=shape_type)

    def _find_owner(self, shape_type_upper_limit):
        """
        :param int shape_type_upper_limit:
        :rtype: BRep
        """
        current_owner = self._owner
        if current_owner is None:
            fmt = "BRep '{:}' ins't *owned* (_owner is None)."
            msg = fmt.format(self)
            raise RuntimeError(msg)
        else:
            flag = True
            while flag:
                st = current_owner.TopoDS_Shape.ShapeType()
                if st <= shape_type_upper_limit:
                    return current_owner
                else:
                    next_owner = getattr(current_owner, "_owner", None)
                    if next_owner is not None and next_owner == current_owner:
                        current_owner = next_owner
                    else:
                        flag = False
            fmt = ("Highest-level owner is of type '{:}', "
                   "while <= '{:}' requested.")
            msg = fmt.format(TOPABS_NAMES[st],
                             TOPABS_NAMES[shape_type_upper_limit])
            raise RuntimeError(msg)

    def _ancestors(self, owner=None, ancestor_type=None):
        """
        :param OCC.TopoDS.TopoDS_Shape owner:
        :param int ancestor_type:
        :rtype: collections.Iterator[OCC.TopoDS.TopoDS_Shape]
        """
        shape = self.TopoDS_Shape
        sub_shape_type = shape.ShapeType()
        if ancestor_type is None:
            ancestor_type = SUB_ANCESTOR_SHAPE_TYPE_MAP[sub_shape_type]
        if owner is None:
            owner = self._find_owner(ancestor_type)
            owner = owner.TopoDS_Shape
        return ancestors(shape, owner, ancestor_type)

    @Attribute
    def is_free(self):
        """Is this a free shape?

        :rtype: bool
        """
        return not self.is_shared

    @Attribute
    def is_shared(self):
        """Is this shape shared between higher level topological elements?

        :rtype: bool
        """
        if self._owner:
            return len(self.get_ancestors()) > 1
        else:
            return False

    @Attribute
    def is_valid(self):
        """
        :rtype: bool
        """
        return BRepCheck_Analyzer(self.TopoDS_Shape).IsValid()

    # ---------------- dimensions -------------------
    @Attribute
    def _gprops1d(self):
        """Attach a 1D properties object to this instance.

        :rtype: OCC.GProp.GProp_GProps
        """
        props = GProp_GProps()
        BRepGProp__LinearProperties(self.TopoDS_Shape, props)
        return props

    @Attribute
    def _gprops2d(self):
        """Attach a 2D properties object to this instance.

        :rtype: OCC.GProp.GProp_GProps
        """
        props = GProp_GProps()
        BRepGProp__SurfaceProperties(self.TopoDS_Shape, props)
        return props

    @Attribute
    def _gprops3d(self):
        """Attach a 3D properties object to this instance.

        :rtype: OCC.GProp.GProp_GProps
        """
        props = GProp_GProps()
        BRepGProp__VolumeProperties(self.TopoDS_Shape, props)
        return props

    @Attribute
    def _gprops(self):
        """The main GProp_GProps instance for this shape.

        :rtype: OCC.GProp.GProp_GProps
        """
        dim = self.TOPODIM
        if dim == 1:
            return self._gprops1d
        elif dim==2:
            return self._gprops2d
        elif dim == 3:
            return self._gprops3d
        else:
            msg = "TOPODIM {:} not valid.".format(dim)
            raise RuntimeError(msg)

    @Attribute
    def matrix_of_inertia(self):
        """The 9 quadratic moments of inertia around center of mass and around
        the global Cartesian system, format::

            [[Ixx, Ixy, Ixz],
             [Ixy, Iyy, Iyz],
             [Ixz, Iyz, Izz]]

        :rtype: tuple[
            tuple[float, float, float],
            tuple[float, float, float],
            tuple[float, float, float]]

        .. note:: the density is assumed to be 1. Hence, the mass used to
            calculate inertia is equal to volume. Feel free to multiple these
            results with a specific density.
        """
        mat = self._gprops.MatrixOfInertia()
        return tuple(
            tuple(mat.Value(i, j) for i in range(1, 4)) for j in range(1, 4)
        )

    @Attribute
    def static_moments(self):
        """Return Ix, Iy, Iz, the static moments of inertia of the current
        system; i.e. the moments of inertia about the three axes of the
        Cartesian coordinate system.

        :rtype: tuple[float, float, float]
        """
        return tuple(self._gprops.StaticMoments())

    @Attribute
    def cog(self):
        """Center of gravity.

        :rtype: parapy.geom.Point
        """
        return self._gprops.CentreOfMass().point

    # ---------------- TopoDS_Shape -> ParaPy -------------------
    @Attribute
    def _TopoDS2Vertices(self):
        """Dictionary mapping TopoDS_Vertexs to corresponding ParaPy Vertices

        :rtype: OrderedDict[TopoDS_Shape, Vertex_]
        """
        return OrderedDict(
            (vertex.TopoDS_Shape, vertex) for vertex in self.vertices)
    
    @Attribute
    def _TopoDS2Edges(self):
        """Dictionary mapping TopoDS_Edges to corresponding ParaPy Edges

        :rtype: OrderedDict[TopoDS_Shape, Edge_]
        """
        return OrderedDict(
            (edge.TopoDS_Shape, edge) for edge in self.edges)

    @Attribute
    def _TopoDS2Wires(self):
        """Dictionary mapping TopoDS_Wires to corresponding ParaPy Wires

        :rtype: OrderedDict[TopoDS_Shape, Wire_]
        """
        return OrderedDict(
            (wire.TopoDS_Shape, wire) for wire in self.wires)

    @Attribute
    def _TopoDS2Faces(self):
        """Dictionary mapping TopoDS_Faces to corresponding ParaPy Faces

        :rtype: OrderedDict[TopoDS_Shape, Face_]
        """
        return OrderedDict(
            (face.TopoDS_Shape, face) for face in self.faces)

    @Attribute
    def _TopoDS2Shells(self):
        """Dictionary mapping TopoDS_Shells to corresponding ParaPy Shells

        :rtype: OrderedDict[TopoDS_Shape, Shell_]
        """
        return OrderedDict(
            (shell.TopoDS_Shape, shell) for shell in self.shells)

    @Attribute
    def _TopoDS2Solids(self):
        """Dictionary mapping TopoDS_Solids to corresponding ParaPy Solids

        :rtype: OrderedDict[TopoDS_Shape, Solid_]
        """
        return OrderedDict(
            (solid.TopoDS_Shape, solid) for solid in self.solids)

    @Attribute
    def _TopoDS2Compounds(self):
        """Dictionary mapping TopoDS_Compounds to corresponding ParaPy Solids

        :rtype: OrderedDict[TopoDS_Shape, Solid_]
        """
        return OrderedDict(
            (compound.TopoDS_Shape, compound) for compound in self.compounds)

    # TODO: restructure in v1.0.
    def _sub_shape_generator(self, name):
        """Internal utility to create ParaPy subshapes.

        :param str name: one of 'vertex', 'edge', etc.
        :rtype: collections.Iterator[BRep]
        """
        return SubShapeGenerator(self, name)

    # ---------------- topology accessors -------------------
    def is_partner(self, shape):
        """True if this shape and given shape are *partners*, i.e. if they
        share the same underlying TShape. Locations and Orientations may
        differ.

        :param BRep shape:
        :rtype: bool.
        """
        topods_shape1 = self.TopoDS_Shape
        topods_shape2 = shape.TopoDS_Shape
        flag = topods_shape1.IsPartner(topods_shape2)
        return flag

    def _TopoDS2Shape(self, topods_shape, shape_type=None, failure='raise'):
        """Return ParaPy BRep instance that wraps given ``topods_shape``.

        :param OCC.TopoDS.TopoDS_Shape topods_shape: OCC instance.
        :param shape_type: TopAbs_ShapeEnum or None (let ParaPy detect).
        :type shape_type: int | None
        :param str failure: failure mode when ``topods_shape`` does not belong
            to this topology? Options: 'raise' (raise with KeyError), 'warn'
            (warn about KeyError, but return ParaPy BRep instance, 'ignore'
            (simply return ParaPy BRep instance).
        :raises KeyError: if topods_shape is not within current topology or
            combination with shapetype is wrong.
        :rtype: BRep
        """
        if shape_type is None:
            shape_type = topods_shape.ShapeType()
        elif isinstance(shape_type, str):
            shape_type = Name2Level[shape_type]

        # TODO (TBD): restructure BRep class in v1.0.
        dict_attr = "_TopoDS2" + Level2Attr[shape_type].capitalize()
        dict_ = getattr(self, dict_attr)
        try:
            return dict_[topods_shape]
        except KeyError:
            if failure is True:
                msg = "Value of True for failure is deprecated, use 'raise'."
                warnings.warn(msg, ParaPyDeprecationWarning)
                failure = 'raise'
            elif failure not in ["raise", "warn", "ignore"]:
                fmt = ("Failure value '{:}' is not one of "
                       "['raise', 'warn', 'ignore'].")
                msg = fmt.format(failure)
                raise ValueError(msg)

            if failure == "raise":
                raise
            elif failure == "warn":
                fmt = "Provided shape is not part of current topology `{:}`."
                msg = fmt.format(self)
                warnings.warn(msg)

            cls_attr = Level2Class[shape_type]
            cls = getattr(self, cls_attr)
            return cls(TopoDS_Shape=topods_shape)

    def _TopoDS2Shapes(self, topods_shapes, shape_type=None, failure='raise'):
        """Return ParaPy BRep instances that wrap given ``topods_shapes``.

        :param topods_shapes: OCC instances.
        :type topods_shapes: collections.Iterable[OCC.TopoDS.TopoDS_Shape]
        :param shape_type: If set to :py:`None`, ParaPy will detect the
            shapetype on each individual shape in ``topods_shapes``.
            If it is known that all shapes have the same ``shape_type``,
            specify a TopAbs_ShapeEnum or the name of the
            shapetype to skip the detection step. It will be then assumed
            that each shape in ``topods_shapes`` is of ``shape_type``.
        :type shape_type: int | str | None
        :param str failure: failure mode when ``topods_shape`` does not belong
            to this topology? Options: 'raise' (raise with KeyError), 'warn'
            (warn about KeyError, but return ParaPy BRep instance, 'ignore'
            (simply return ParaPy BRep instance).
        :raise KeyError: if topods_shape is not within current topology or
            combination with shapetype is wrong.
        :rtype: tuple[BRep]
        """
        if isinstance(shape_type, str):
            shape_type = Name2Level[shape_type]

        if shape_type is None:
            # the correct dictionary needs to be found for each shape
            # individually: get_topo2shape does a lookup
            topodict_cache = {}

            def get_topo2shape(topods_shape):
                shape_type = topods_shape.ShapeType()
                try:
                    return topodict_cache[shape_type]
                except KeyError:
                    dict_attr = "_TopoDS2" + Level2Attr[
                        shape_type].capitalize()
                    topo2shape = getattr(self, dict_attr)

                    topodict_cache[shape_type] = topo2shape
                    return topo2shape
        else:
            # We assume every shape has the same shape_type, we do the
            # lookup now, and always return this dictionary
            # TODO (TBD): restructure BRep class in v1.0.
            dict_attr = "_TopoDS2" + Level2Attr[shape_type].capitalize()
            topo2shape = getattr(self, dict_attr)

            def get_topo2shape(topods_shape):
                return topo2shape

        if failure is True:
            msg = ("Value ``True`` for failure has been deprecated, "
                   "use 'raise' instead.")
            warnings.warn(msg, ParaPyDeprecationWarning)
            failure = 'raise'
        elif failure is False:
            msg = ("Value ``False`` for failure has been deprecated, "
                   "use 'ignore' instead.")
            warnings.warn(msg, ParaPyDeprecationWarning)
            failure = 'ignore'
        elif failure not in ["raise", "warn", "ignore"]:
            fmt = ("Failure value '{:}' is not one of "
                   "['raise', 'warn', 'ignore'].")
            msg = fmt.format(failure)
            raise ValueError(msg)

        def topods_to_shape(topods_shape):
            topo2shape = get_topo2shape(topods_shape)
            try:
                return topo2shape[topods_shape]
            except KeyError:
                if failure == "raise":
                    raise
                elif failure == "warn":
                    msg = ("Provided shape is not part of current "
                           "topology `{:}`.")
                    warnings.warn(msg.format(self))

                cls_attr = Level2Class[shape_type]
                cls = getattr(self, cls_attr)
                return cls(TopoDS_Shape=topods_shape)

        return tuple(map(topods_to_shape, topods_shapes))

    def _safe_TopoDS2Vertices(self, *topods_vertices):
        """Convert OCC topods_vertex to ParaPy Vertex, but return None if
        ``topods_vertex`` IsNull().

        :rtype: collections.Iterator[parapy.geom.occ.vertex.Vertex_ | None]
        """
        dct = None
        for topods_vertex in topods_vertices:
            if topods_vertex.IsNull():
                yield None
            else:
                # this style postpones evaluation if all vertices .IsNull()
                dct = dct or self._TopoDS2Vertices
                yield dct[topods_vertex]

    def _trace_back_owner(self, min_level, max_level):
        """Find my direct owner from the ancestor hierarchy who satisfies
        min_level <= TOPOLEVEL <= max_level. Returns BRep

        :param int min_level: a TOPOLEVEL
        :param int min_level: a TOPOLEVEL
        :rtype: BRep
        """
        assert min_level<=max_level, "your inputs are wrong!"
        owner = self._owner
        if owner:
            if owner.TOPOLEVEL > max_level:
                raise Exception("Your trace_back inputs are beyond owner "
                                "level:", owner.TOPOLEVEL)
            else:
                parent = self.parent
                #TODO: is this safe? Not for clones, I guess?
                while parent and not parent is owner:
                    if min_level <= parent.TOPOLEVEL <= max_level:
                        return parent
                    else:
                        parent = parent.parent
                # final test on owner
                if owner.TOPOLEVEL >= min_level:
                    return owner
                else:
                    raise Exception("failed")                
        else:
            raise Exception("Topology isn't owned by any BRep")

    def trace_up_owner(self, lower, upper=0):
        """A way to find the owner of this BRep in a BRep hierarchy.

        :param int | str lower: A string described in ``Name2Level`` or
            integer describing the lower component in the order: (vertex,
            edge, ..., solid)
        :param int | str upper: A string described in ``Name2Level`` or
            integer describing the higher component in the order: (vertex,
            edge, ..., solid)
        :rtype: BRep
        """
        max_level = lower if isinstance(lower, int) else Name2Level[lower]
        min_level = upper if isinstance(upper, int) else Name2Level[upper]
        return self._trace_back_owner(min_level, max_level)

    def _get_ancestors(self, level2=None, owner=None):
        """

        :param int level2:
        :param OCC.TopoDS.TopoDS_Shape owner:
        :rtype: collections.Iterator[OCC.TopoDS_Shape.TopoDS_Shape]
        """
        owner = owner or self._owner.TopoDS_Shape
        if owner:
            level1 = self.TOPOLEVEL
            level2 = level2 if not level2 is None else level1 - 1
            # RvD 21-5-2015: Fix
            # if owner is same as level2, simply return owner.
            # Before fix, edge owned by a single face would look for
            # face.faces leading to error.
            if level2 == owner.ShapeType():
                yield owner
            else:
                shape = self.TopoDS_Shape
                for shape_, ancestor_shapes in AncestorMap_(owner,
                                                            level1,
                                                            level2):
                    # find myself in map using IsSame
                    if shape.IsSame(shape_):
                        # uniquefy this list of shapes
                        for s in unique_shape_generator_(ancestor_shapes):
                            yield s
        else:
            raise Exception("This BRep does not have a Topological owner.")

    def get_ancestors(self, level2=None, owner=None):
        """Utility to find ancestor shapes, viz. higher-level shapes on which
        I lie. For example, all faces on which this edge lies, or all edges on
        which this vertex lies. level can be None, int or str.

        :param level2: TOPOLEVEL of ancestor shapes to find. If None, it
            defaults to self.TOPOLEVEL - 1. For example, if this object is a
            vertex, we return all wires on which this object lies. (if you
            wanted faces, specify ``level2=3`` or ``level2='face').
        :type level2: int | str
        :param BRep owner: defaults to self._owner, but you can specify an
            owner to limit search to local topology branch.
        :rtype: list[BRep]
        """
        owner = owner or self._owner
        if owner:
            if level2 is None:
                level2 = self.TOPOLEVEL-1
            else:
                level2 = level2 if isinstance(level2, int) \
                    else Name2Level[level2]

            # RvD 21-5-2015: Fix
            # if owner is same as level2, simply return owner.
            # Before fix, edge owned by a single face would look
            # for face.faces leading to error.
            if level2 == owner.TOPOLEVEL:
                return [owner]
            else:
                shape_gen = self._get_ancestors(level2, owner.TopoDS_Shape)
                return [owner._TopoDS2Shape(shape) for shape in shape_gen]
        else:
            msg = "This BRep does not have a Topological owner."
            warnings.warn(msg)
            return []

    def _get_neighbours(self, level1, owner=None):
        """Return generator of TopoDS_Shape objects (not downcast).

        :param int level1: level for sub_shapes.
        :param OCC.TopoDS.TopoDS_Shape owner: the owner shape for neighbours
            search
        """
        # FIXME: try to preserve order of the result. Use of set()
        # compromises this.
        owner = owner or self._owner.TopoDS_Shape
        if owner:
            level2 = self.TOPOLEVEL
            level1 = level1 if not level1 is None else level2 + 1
            shape = self.TopoDS_Shape
            neighbours = set()
            sub_shape_attr = Level2Attr[level1]
            sub_shapes = getattr(self, sub_shape_attr)

            amap = AncestorMap_(owner, level1, level2)
            for sub_shape in sub_shapes:
                neighbours.update(set(amap[sub_shape.TopoDS_Shape]))

            # remove self from this set() and uniquefy the TopoDS_shape list
            f = shape.IsSame
            return unique_shape_generator_(n for n in neighbours if not f(n))
        else:
            raise Exception("This BRep does not have a Topological owner.")

    def get_neighbours(self, level1=None, owner=None):
        """Utility to find neighbour shapes, viz. similar-level
        shapes with whom I share a
        lower-level shape. For example, the faces that touch this face
        through their edges. Or,
        edges that touch me through a shared vertex (start or end).

        :param int | str level1: TOPOLEVEL of sub_shape to use for neighbours
            search. If None, it defaults to self.TOPOLEVEL + 1. For example,
            if this object is an edge, we use vertices for neighbour search
        :param BRep owner: defaults to self._owner, but you can
            specify an owner to limit search to local topology branch.
        :returns: a list of ParaPy objects.
        :rtype: BRep
        """

        owner = owner or self._owner
        if owner:
            if level1 is None:
                level1 = self.TOPOLEVEL+1
            else:
                level1 = level1 if isinstance(level1, int) \
                    else Name2Level[level1]

            shape_gen = self._get_neighbours(level1, owner.TopoDS_Shape)
            # I don't link back to the original subshapes of owner,
            # because of orientation stuff.
            Class = getattr(self, Level2Class[self.TOPOLEVEL])
            return [Class(TopoDS_Shape=shape,
                          _owner=owner) for shape in shape_gen]
        else:
            raise Exception("This BRep does not have a Topological owner.")

    # ---------------- transformations -------------------
    def transform(self, new_position, old_position=None):
        """Function to change existing shape in place by transforming it:
        translate,
        rotate. Unlike most operations in ParaPy, this funtion will
        not return a new object,
        instead it will alter the existing geometry in place and
        invalidate potential
        dependendants. Moreover, it will broadcast a "change" event.
        Side-effects:
    
        - self.position is synchronized
        - self.TopoDS_Shape is moved without creating a new object

        Usage:

        >>> from parapy.geom import Box, XOY, translate
        >>> box = Box(1,2,3, position=XOY)
        >>> box.position
        Position(Point(0, 0, 0))
        >>> old_shape = box.TopoDS_Shape
        >>> new_position = translate(XOY, x=3)
        >>> new_position
        Position(Point(3, 0, 0))
        >>> box.transform(new_position=new_position)
        >>> box.position
        Position(Point(3,0,0))
        >>> box.TopoDS_Shape == old_shape
        True

        :param parapy.geom.Position new_position: new position to transform to.
        :param parapy.geom.Position old_position: Optional, alternative old
            position to transform

        .. caution:: This method does not work like described. The position
            does not change.
        """
        old_position = old_position or self.position
        TopoDS_Shape = self.TopoDS_Shape
    
        trsf = gp_Trsf()
        trsf.SetDisplacement(old_position.gp_Ax3, new_position.gp_Ax3) 
        toploc = TopLoc_Location(trsf)

        # now apply the transformation
        TopoDS_Shape.Location(toploc)
        self.invalidate_dependants("TopoDS_Shape")

    def _transformed(self, trsf, **info):
        """

        :param OCC.gp.gp_Trsf trsf:
        :param any info:
        :rtype: BRep
        """
        class_ = self._new_shape_type
        return class_(_clone = self, _transformation=[trsf, self, info])

    @Attribute
    def to_nurbs(self):
        """A version of this shape built from NURBS curves and surfaces.

        :rtype: BRep
        """
        class_ = self._new_shape_type
        builder = BRepBuilderAPI_NurbsConvert(self.TopoDS_Shape, True)
        return class_(builder=builder, TopoDS_Shape=builder.Shape())


class BRepBuilder(BRep):
    """Operations from the BRepBuilderAPI_MakeShape interface."""

    @Attribute(private=True)
    def builder(self):
        """Root class of all shape constructions in OCC.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        """
        return self.build()

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """Returns shape built by :meth:`build`.

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

    def generated(self, shape):
        """Return list of shapes generated from ``shape``.

        :rtype: list[parapy.geom.occ.brep.BRep]
        """
        topods_shape = shape.TopoDS_Shape
        builder = self.builder
        lsh = builder.Generated(topods_shape)
        return self._TopTools_ListOfShape2Shapes(lsh)

    def modified(self, shape):
        """Return list of shapes modified from ``shape``.

        :rtype: list[parapy.geom.occ.brep.BRep]
        """
        topods_shape = shape.TopoDS_Shape
        builder = self.builder
        lsh = builder.Modified(topods_shape)
        return self._TopTools_ListOfShape2Shapes(lsh)

    def is_deleted(self, shape):
        """Return True if the ``shape`` has been deleted.

        :rtype: bool
        """
        topods_shape = shape.TopoDS_Shape
        builder = self.builder
        flag = builder.IsDeleted(topods_shape)
        return flag

    def build(self):
        """Performs shape construction.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        """
        raise NotImplementedError()


class BRepBuilderWithFix(BRepBuilder):
    """Fixes pre- and post build shape tolerance for operations in
    BRepBuilderAPI_MakeShape. Assumes single :attr:`built_from` slot.
    """

    #: Shape that is input to the builder
    #: :type: BRep
    built_from = Input()

    #: OpenCascade tends to place very large tolerances on the resulting
    #: shape. If :py:`True`, ParaPy will limit the maximum tolerances
    #: of the shape to the maximum (vertex, edge and face) tolerances of
    #: :attr:`built_from`.
    #: :type: bool
    fix_tolerances = Input(False)

    @Attribute(private=True)
    def builder(self):
        """Root class of all shape constructions in OCC.

        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        """
        fix_tolerances = self.fix_tolerances
        if fix_tolerances:
            s1 = self.built_from.TopoDS_Shape
            vtol, etol, ftol = get_max_tolerances(s1)
        builder = super(BRepBuilderWithFix, self).builder
        if fix_tolerances:
            self.__fix(builder, vtol, etol, ftol)
        return builder

    # FIXME (TBD): FilletedSolid may miss faces.
    # /fixme Replicate: RibTool tag 2.0, solid_with_fillets.fix_tolerances=True
    def __fix(self, builder, vtol, etol, ftol):
        """
        :param OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape builder:
        :param float vtol: vertex tolerance
        :param float etol: edge tolerance
        :param float ftol: face tolerance
        """
        # FIX: BRepBuilderAPI modifies tolerances of input shape
        s1 = self.built_from.TopoDS_Shape
        limit_max_tolerances(s1, vtol, etol, ftol)

        # FIX: BRepBuilderAPI places unreasonable tolerances on output shape
        # do no try this in case of failure
        if builder.IsDone():
            s2 = builder.Shape()
            limit_max_tolerances(s2, vtol, etol, ftol)


class ClonedShape(BRep):
    """Can be used to make a new clone of an existing BRep(s) or wrap
    an OCC.TopoDS.TopoDS_Shape(s).

    It makes an `alias` for the same underlying object. So the underlying
    shapes are identical.

    Usage::

        ClonedShape(other_shape, *args, **kwargs)
        ClonedShape([other_shape, other_shape, ...], *args, **kwargs)
        ClonedShape(built_from=other_shape, **kwargs)

    Where ``other_shape`` is one of:

    * parapy.geom.BRep
    * parapy.geom.Curve
    * parapy.geom.Surface
    """

    __initargs__ = ["built_from"]
    __newargs__ = ["built_from"]

    # dummy node
    built_from = Input(doc="The object(s) to clone. Can be a BRep or ")

    @classmethod
    def make(cls, built_from, *args, **kwargs):
        """deals with single objects

        :type built_from: BRep | parapy.geom.Curve | parapy.geom.Surface
        """
        if isinstance(built_from, BRep):
            class_ = built_from._new_shape_type
            return class_(_clone=built_from, *args, **kwargs)
        elif isinstance(built_from, TopoDS_Shape):
            class_ = TopoDS_Shape2ParaPy(built_from)
            return class_(TopoDS_Shape=built_from, *args, **kwargs)
        else:
            raise Exception("shape_in %s was not a valid BRep or "
                            "OCC.TopoDS_Shape." % repr(built_from))

    def __new__(cls, built_from, *args, **kwargs):
        """tests for iterables"""
        if hasattr(built_from, "__iter__"):
            # FIXME: Vertex will fail, because it has __iter__ defined...
            return [cls.make(obj, *args, **kwargs) for obj in built_from]
        else:
            return cls.make(built_from, *args, **kwargs)


def TopoDS_Shape2ParaPy(topods_shape):
    """Maps TopoDS_Shape().ShapeType() to corresponding ParaPy class

    :rtype: parapy.core.meta.basetype
    """
    return getattr(BRep, TopAbs2Class[topods_shape.ShapeType()])


#     @Attribute
#     def bbox_extremes(self):
#         xyz = self._bbox_xyz
#         pt1 = Point(xyz[0], xyz[1], xyz[2])
#         pt2 = Point(xyz[3], xyz[4], xyz[5])      
#         return [pt1, pt2]
#     @Attribute
#     def bbox_center(self):
#         xyz = self._bbox_xyz
#         pt1 = Point(xyz[0], xyz[1], xyz[2])
#         pt2 = Point(xyz[3], xyz[4], xyz[5])      
#         return pt1.midpoint(pt2)
#     @Attribute
#     def bbox_orientation(self):
#         return self.position.orientation
#     @Attribute
#     def bbox_position(self):
#         return Position(self.bbox_center, self.bbox_orientation)
#     @Attribute
#     def bbox_width(self):
#         return self._bbox_xyz[3] - self._bbox_xyz[0]
#     @Attribute
#     def bbox_length(self): 
#         return self._bbox_xyz[4] - self._bbox_xyz[1]
#     @Attribute
#     def bbox_height(self): 
#         return self._bbox_xyz[5] - self._bbox_xyz[2]
#     @Part(lazy=False)
#     def bbox_shown(self):
#         from kbepy.geom.occ.box import Box
#         return Box(position = self.bbox.position,
#                    transparency = 0.5,
#                    hidden = self.bbox_hide,
#                    width = self.bbox.width,
#                    length = self.bbox.length,
#                    height = self.bbox.height)

# 
#     def minimum_distance_to(self,other):
#         """
#         TODO: description
#         """        
#         return minimum_distance(self.TopoDS_Shape,
#                                 other.TopoDS_Shape)
# 
#     def minimum_distance_to_point(self,point):
#         """
#         TODO: description
#         """          
#         return minimum_distance(self.TopoDS_Shape,
#                                 point.TopoDS_Shape)
# 
#     def minimum_distance_to_curve(self,curve):
#         """
#         TODO: description
#         """  
#         return minimum_distance(self.TopoDS_Shape,
#                                 curve.TopoDS_Shape)
#     
#     def minimum_distance_to_face(self,face):
#         """
#         TODO: description
#         """         
#         return minimum_distance(self.TopoDS_Shape,
#                                 face.TopoDS_Shape)    
# 
#     def minimum_distance_to_brep(self,brep):
#         """
#         TODO: description
#         """          
#         return minimum_distance(self.TopoDS_Shape,
#                                 brep.TopoDS_Shape)    

# class CopyTopo(Topo):
#     
#     built_from = input()
# 
#     @Attribute
#     def kernel_instance(self):
#         return self.built_from.kernel_instance


    #==========================================================================
    # Some OCC Containers
    #==========================================================================
#     @Attribute
#     # yes, mis-spelled, leave it for _make_subshapes.
#     def _TopoDS_Vertexs(self):
#         return list(self._sub_shape_generator("vertex"))
#  
#     @Attribute
#     def _TopoDS_Edges(self):
#         return list(self._sub_shape_generator("edge"))
#  
#     @Attribute
#     def _TopoDS_Faces(self):
#         return list(self._sub_shape_generator("face"))
#  
#     @Attribute
#     def _TopoDS_Wires(self):
#         return list(self._sub_shape_generator("wire")) 
#  
#     @Attribute
#     def _TopoDS_Shells(self):
#         return list(self._sub_shape_generator("shell"))
#  
#     @Attribute
#     def _TopoDS_Solids(self):
#         return list(self._sub_shape_generator("solid"))
#  
#     @Attribute
#     # yes, not CompSolid, leave it for _make_subshapes.
#     def _TopoDS_Compsolids(self):
#         return list(self._sub_shape_generator("compsolid"))
#  
#     @Attribute
#     def _TopoDS_Compounds(self):
#         return list(self._sub_shape_generator("compound"))

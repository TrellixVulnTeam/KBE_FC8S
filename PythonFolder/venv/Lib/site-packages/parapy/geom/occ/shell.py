#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Description of the code"""

from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_MakeShell, BRepBuilderAPI_RightCorner,
    BRepBuilderAPI_RoundCorner, BRepBuilderAPI_Transformed)
from OCC.wrapper.BRepOffsetAPI import (
    BRepOffsetAPI_MakePipe, BRepOffsetAPI_MakePipeShell)
from OCC.wrapper.BRepPrimAPI import BRepPrimAPI_MakePrism
from OCC.wrapper.ShapeAnalysis import ShapeAnalysis_Shell
from OCC.wrapper.TopAbs import TopAbs_EDGE, TopAbs_SHELL
from OCC.utils.top import downcast_shape, faces_to_shell

from parapy.core import Attribute, Input, derived, ensure_iterable, val
from parapy.core.part import PrivatePartNoParsing
from parapy.geom.generic import Position
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.curve import Circle
from parapy.geom.occ.surface import Surface
from parapy.geom.occ.utilities import SubShapeGenerator_


class Shell_(BRep):
    """Wrapper around TopoDS_Shell"""

    # 7:Vertex,6:Edge,5:Wire,4:Face,3:Shell,2:Solid,1:CompSolid,0:Compound
    TOPOLEVEL = 3
    TOPODIM = 2

    # ---------------- dimensions -------------------
    @Attribute
    def area(self):
        """Total surface area, i.e. the sum of area of all faces.

        :rtype: float
        """
        return self._gprops2d.Mass()

    # ---------------- topology -------------------

    @Attribute
    def TopoDS_Shell(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shell
        """
        return downcast_shape(self.TopoDS_Shape, TopAbs_SHELL)

    @PrivatePartNoParsing  # don't trickle down
    def vertices(self):
        """
        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return list(self._sub_shape_generator("vertex"))

    @PrivatePartNoParsing  # don't trickle down
    def edges(self):
        """
        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        return list(self._sub_shape_generator("edge"))

    @PrivatePartNoParsing  # don't trickle down
    def wires(self):
        """
        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        return list(self._sub_shape_generator("wire"))

    @PrivatePartNoParsing  # don't trickle down
    def faces(self):
        """
        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return list(self._sub_shape_generator("face"))

    @PrivatePartNoParsing  # don't trickle down
    def shells(self):
        """
        :rtype: list[parapy.geom.occ.shell.Shell_]
        """
        return list(self._sub_shape_generator("shell"))

    # ---------------- Analysis -------------------
    @Attribute
    def _shell_analyser(self):
        """
        :rtype: OCC.ShapeAnalysis.ShapeAnalysis_Shell
        """
        sas = ShapeAnalysis_Shell()
        sas.CheckOrientedShells(self.TopoDS_Shape, True)
        return sas

    @Attribute
    def bad_edges(self):
        """flat list of bad edges in this solid.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        sas = self._shell_analyser
        if sas.HasBadEdges():
            topods_compound = sas.BadEdges()
            topods_edges = list(SubShapeGenerator_(topods_compound, "edge"))
            return self._TopoDS2Shapes(topods_edges, TopAbs_EDGE, 'ignore')
        else:
            return []

    @Attribute
    def free_edges(self):
        """flat list of free edges in this solid.

        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        sas = self._shell_analyser
        if sas.HasFreeEdges():
            topods_compound = sas.FreeEdges()
            topods_edges = list(SubShapeGenerator_(topods_compound, "edge"))
            return self._TopoDS2Shapes(topods_edges, TopAbs_EDGE, 'ignore')
        else:
            return []

    @Attribute
    def is_valid(self):
        """Is this shell valid?

        :rtype: bool
        """
        flag = True
        if self.bad_edges:
            print("Solid has %i bad edges. See bad_edges." % (len(
                self.bad_edges)))
            flag = False
        return flag

    def is_closed(self):
        """Is this shell closed?

        :rtype: bool
        """
        return not self.free_edges


# monkey_patch BRep class
BRep.ShellClass = Shell_
# monkey_patch Surface class
Surface.ShellClass = Shell_


class ShellFromSurface(Shell_):
    __initargs__ = ["built_from"]

    #: :type: parapy.geom.Surface
    built_from = Input()

    #: force C2-continuity?
    #: :type: bool
    make_c2 = Input(False)

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShell
        """
        segment = self.make_c2
        return BRepBuilderAPI_MakeShell(self.built_from.Handle_Geom_Surface,
                                        segment)

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shell
        """
        return self.builder.Shell()


class _SweptShell(Shell_):
    """Mixin for all swept solid classes"""

    BUILDERKEY = "Shape"  # return self.builder.Shape()

    @Attribute
    def bottom_edge(self):
        """The bottom wire of the solid. Only for make_solid = True.

        :rtype: parapy.geom.occ.edge.Edge_
        :raises: Exception: when the top edge of the lofted shell could
            not be retrieved.
        """
        # may not be one of the wires in the final topology
        shape = self.builder.FirstShape()
        if not shape.IsNull():
            return self._TopoDS2Shape(shape, failure='ignore')
        else:
            raise Exception("couldn't retrieve bottom edge One"
                            " possible cause: LoftedShell "
                            "will never return bottom / top edge, "
                            "use LoftedSolid instead")

    @Attribute
    def top_edge(self):
        """The top face of the solid. Only for make_solid = True.

        :rtype: parapy.geom.occ.edge.Edge_
        :raises: Exception : when the top edge of the lofted shell could
            not be retrieved.
        """
        # FIXME: can be a wire or an edge.
        shape = self.builder.LastShape()
        if not shape.IsNull():
            return self._TopoDS2Shape(shape, failure='ignore')
        else:
            raise Exception("couldn't retrieve top edge. One possible "
                            "cause: LoftedShell "
                            "will never return bottom / top edge, use "
                            "LoftedSolid instead")


class ExtrudedShell(_SweptShell):
    """Extrudes a :attr:`profile` by a :attr:`distance` along a vector,
    :attr:`direction`.

    Usage:

    >>> from parapy.geom import ExtrudedShell, Rectangle
    >>> profile = Rectangle(1, 1)
    >>> obj = ExtrudedShell(profile=profile, distance=1, direction=(0, 0, 1))
    """

    __initargs__ = ["profile", "distance", "direction"]

    #: Planar profile. This (with holes) or face
    #: :type: parapy.geom.Curve | None
    profile = Input(None)

    #: Direction is relative to the orientation.
    #: :type: parapy.geom.Vector | str
    direction = Input('z')

    #: Optional distance
    #: :type: numbers.Number
    distance = Input(derived, validator=val.Positive())

    #: If True, profile will also be extruded in opposite :attr:`direction`.
    #: Distance_ is same as distance.
    #: :type: bool
    mirrored_extent = Input(False)

    #: :type: float
    distance_ = Input(distance)

    def _get_distance(self):
        """
        :rtype: float
        """
        return self._direction.length

    # =========================================================================
    # Attributes
    # =========================================================================
    @Attribute
    def _direction(self):
        """
        :rtype: parapy.geom.Vector
        """
        return self.position.ensure_vector(self.direction, False)

    @Attribute
    def _basis_profile(self):
        """
        :rtype: parapy.geom.Curve
        """
        if self.mirrored_extent:
            return self.profile.translated(self._direction.reverse,
                                           self.distance_)
        else:
            return self.profile

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakePrism
        """
        # Note: no need enable the copy option, because the face
        # is created and used only here
        distance = self.distance + \
                   self.distance_ if self.mirrored_extent else self.distance
        vector = self._direction * distance
        builder = BRepPrimAPI_MakePrism(self._basis_profile.TopoDS_Shape,
                                        vector.gp_Vec,
                                        False)
        if builder.IsDone():
            return builder
        else:
            raise Exception("BRepPrimAPI_MakePrism failed")


class SweptShell(_SweptShell):
    """Like SweptSolid, but will return only a shell, not a solid.

    Usage:

    >>> from parapy.geom import (InterpolatedCurve, Point, SweptShell,
    ...                          LineSegment)
    >>> crv = LineSegment(start=Point(0, 0, 0), end=Point(0, 0, 1))
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 1, 0)]
    >>> path = InterpolatedCurve(points=pts)
    >>> obj = SweptShell(profile=crv, path=path)
    """

    __initargs__ = ["path", "profile"]

    #: Path used for sweeping
    #: :type: parapy.geom.Curve
    path = Input()

    #: profile is curve or wire which is assumed to be open!
    #: :type: parapy.geom.Curve | None
    profile = Input(None)

    @Attribute
    def builder(self):
        """override on subclassing

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipe
        """
        builder = BRepOffsetAPI_MakePipe(self.path.TopoDS_Wire,
                                         self.profile.TopoDS_Shape)
        if builder.IsDone():
            return builder
        else:
            raise Exception("BRepOffsetAPI_MakePipe failed")


class PipeShell(SweptShell):
    """Make a shell with a circular section (for now) of fixed :attr:`radius`
    along a :attr:`path`.

    Usage:

    >>> from parapy.geom import InterpolatedCurve, Point, PipeShell
    >>> pts = [Point(0, 0, 0), Point(1, 1, 0), Point(2, 0, 0)]
    >>> crv = InterpolatedCurve(pts)
    >>> obj = PipeShell(path=crv, radius=0.2)
    """

    __initargs__ = ["path", "radius"]

    #: pipe radius or profile
    #: :type: float | parapy.geom.Curve
    radius = Input()

    @Attribute
    def profile(self):
        """
        :rtype: parapy.geom.Circle
        """
        path = self.path
        if path.is_planar:
            pos = path.position1
        else:
            pos = Position(path.point1).align('z', path.tangent1)
        return Circle(self.radius, position=pos)


class MultiSectionShell(_SweptShell):
    """Like MultiSectionSolid, but will return a shell, not solid.
    FIXME: may fail on paths with long parametric range, like resulting from
    InterpolatedCurve/FittedCurve. In case of failure, try to normalize your
    path.

    Usage:

    >>> from parapy.geom import MultiSectionShell, FittedCurve, Circle, Point
    >>> pnts = [Point(0, 0, 0), Point(0, 0, 1), Point(1, 0, 2)]
    >>> path = FittedCurve(points=pnts)
    >>> profile = Circle(radius=0.1)
    >>> obj = MultiSectionShell(path=path, profiles=[profile])
    """

    __initargs__ = ["path", "profiles"]

    #: The path for the sweeping operation. Can also be a list of paths for
    #: multi-profile, multi-spline creation.
    #: :type: parapy.geom.Curve | collections.Sequence[parapy.geom.Curve]
    path = Input()

    #: list of cross-sectional curves/wires. These are the cross-sections of
    # your solid.
    #: :type: collections.Sequence[parapy.geom.Curve]
    profiles = Input()

    #: keep contact between profiles and path?
    #: :type: bool
    keep_contact = Input(False)

    # tolerance values
    #: :type: float
    tolerance = Input(1.0e-4)

    #: boundary tolerance
    #: :type: float
    boundary_tolerance = Input(1.0e-4)

    #: angular tolerance
    #: :type: float
    angular_tolerance = Input(1.0e-2)

    #: Controls the transition mode to manage discontinuities on
    #: the swept shape caused by fractures
    #: on the spine.
    #: See: http://opencascade.sourcearchive.com/documentation/6.3.0.dfsg.1-1/classBRepOffsetAPI__MakePipeShell_a322e05d11186d3042b750688390c4da.html#a322e05d11186d3042b750688390c4da
    #: default is  :py:"transformed".
    #: :type: str
    transition_mode = Input("transformed",
                            validator=val.OneOf(["transformed",
                                                 "rounded",
                                                 "right_angle"]))

    #: Set the bi_normal for sweeping
    #: :type: parapy.geom.Vector | None
    bi_normal = Input(None)

    #: orientation
    #: :type: parapy.geom.Vector | None
    orientation_profiles = Input(None)

    #: :type: bool
    make_solid = Attribute(False)

    #: :type: dict[str, int]
    _TRANSITION_MODE = {"transformed": BRepBuilderAPI_Transformed,
                        "rounded": BRepBuilderAPI_RoundCorner,
                        "right_angle": BRepBuilderAPI_RightCorner}

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakePipeShell
        """
        paths = ensure_iterable(self.path)
        builder = BRepOffsetAPI_MakePipeShell(paths[0].TopoDS_Wire)
        for profile in self.profiles:
            if hasattr(profile, "TopoDS_Vertex"):
                builder.Add(profile.TopoDS_Vertex, self.keep_contact)
            else:
                builder.Add(profile.TopoDS_Wire, self.keep_contact)
        if self.bi_normal:
            builder.SetMode(self.bi_normal.gp_Dir)
        if self.orientation_profiles:
            builder.SetMode(self.orientation_profiles.gp_Ax2)
        for auxiliary_path in paths[1:]:
            # add auxiliary spines
            builder.SetMode(auxiliary_path.TopoDS_Wire, False, 2)
        builder.SetTolerance(self.tolerance, self.boundary_tolerance,
                             self.angular_tolerance)
        builder.SetTransitionMode(self._TRANSITION_MODE[self.transition_mode])
        builder.Build()
        if builder.IsDone():
            if self.make_solid:
                # FIXME: if shell is empty (has happened),
                # makesolid will raise error
                flag = builder.MakeSolid()
                if not flag:
                    raise Exception("Shell was created, but making a "
                                    "solid failed. "
                                    " Perhaps your profiles aren't planar? "
                                    "Set make_solid to False")
            return builder
        else:
            raise Exception("Operation failed. Check input geometry.")


def face_to_shell(face):
    """Convert a ParaPy Face to a ParaPy Shell

    Usage:

    >>> from parapy.geom import Box
    >>> box = Box(width=1, length=1, height=1)
    >>> face = box.top_face
    >>> face  # doctest: +ELLIPSIS
    <Face_ root.faces[...] at 0x...>
    >>> shell = face_to_shell(face)
    >>> shell  # doctest: +ELLIPSIS
    <Shell_ root at 0x...>

    :type face: parapy.geom.occ.face.Face_ | parapy.geom.Surface
    :rtype: parapy.geom.occ.shell.Shell_
    """
    topods_shell = faces_to_shell(face.TopoDS_Shape)
    return Shell_(TopoDS_Shape=topods_shell)

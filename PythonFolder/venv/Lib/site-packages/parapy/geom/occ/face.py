#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import os

from OCC.wrapper.BRep import BRep_Tool_Parameters, BRep_Tool_Surface
from OCC.wrapper.BRepAdaptor import BRepAdaptor_Surface
from OCC.wrapper.BRepBuilderAPI import (
    BRepBuilderAPI_CurveProjectionFailed,
    BRepBuilderAPI_FaceDone,
    BRepBuilderAPI_MakeFace, BRepBuilderAPI_NoFace,
    BRepBuilderAPI_NotPlanar,
    BRepBuilderAPI_ParametersOutOfRange)
from OCC.wrapper.BRepOffsetAPI import BRepOffsetAPI_MakeFilling
from OCC.wrapper.BRepTools import BRepTools__OuterWire, BRepTools__UVBounds
from OCC.wrapper.Geom import Geom_RectangularTrimmedSurface
from OCC.wrapper.GeomAbs import GeomAbs_G1
from OCC.wrapper.ShapeFix import ShapeFix_Face
from OCC.wrapper.TopAbs import TopAbs_FACE, TopAbs_VERTEX
from OCC.utils.top import downcast_shape

from parapy.core import Attribute, Input, Part, list_of_numbers, val
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.brep import BRep
from parapy.geom.occ.curve import Circle, TrimmedCurve, UIso, VIso
from parapy.geom.occ.surface import Handle_Geom_Surface2ParaPy, Surface
from parapy.geom.occ.wire import NSidedPolygon, Polygon, Rectangle, Wire

BRepBuilderAPI_FaceError = \
    {BRepBuilderAPI_FaceDone: ("FaceDone: No error occurred. "
                               "The face is correctly built."),
     BRepBuilderAPI_NoFace: "NoFace: No initialization of the algorithm; "
                            "only an empty constructor was used",
     BRepBuilderAPI_NotPlanar: ("NotPlanar: No surface was given and the wire "
                                "was not planar"),
     BRepBuilderAPI_CurveProjectionFailed: ("CurveProjectionFailed: no "
                                            "further description"),
     BRepBuilderAPI_ParametersOutOfRange: ("ParametersOutOfRange: The "
                                           "parameters given to limit the "
                                           "surface are out of its bounds.")
     }


class Face_(BRep, Surface):
    """The root class for TopoDS_Face. Behaves like a Surface as well"""

    __icon__ = os.path.join(ICN_DIR, 'surface.png')
    # 7:Vertex,6:Edge,5:Wire,4:Face,3:Shell,2:Solid,1:CompSolid,0:Compound
    TOPOLEVEL = 4
    TOPODIM = 2

    # ---------------- dimensions -------------------
    @Attribute
    def area(self):
        """Total area enclosed by the edges on the basis surface.

        :rtype: float
        """
        return self._gprops2d.Mass()

    # ---------------- representations -------------------
    @Attribute
    def TopoDS_Face(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Face
        """
        return downcast_shape(self.TopoDS_Shape, TopAbs_FACE)

    @Attribute
    def _Adaptor3d_Surface(self):
        """
        :rtype: OCC.BRepAdaptor.BRepAdaptor_Surface
        """
        return BRepAdaptor_Surface(self.TopoDS_Face)

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """
        :rtype: OCC.Geom.Handle_Geom_Surface
        """
        return BRep_Tool_Surface(self.TopoDS_Face)

    @Attribute
    def Handle_Geom_Surface_trimmed(self):
        """potentially trimmed curve handle.

        :rtype: OCC.Geom.Handle_Geom_RectangularTrimmedSurface
        """
        h_geom_surface = self.Handle_Geom_Surface
        uv_bounds_basis = h_geom_surface.Bounds()
        uv_bounds = self.uv_bounds
        if uv_bounds == uv_bounds_basis:
            return h_geom_surface
        else:
            return Geom_RectangularTrimmedSurface(h_geom_surface,
                                                  *uv_bounds).handle

    @property
    def brep(self):
        """
        :rtype: Face_
        """
        return self

    @Part(trickle_down=False, in_tree=False, parse=None)
    def basis_surface(self):
        """The underlying surface. Beware: can be larger than the boundaries
        of face.

        :rtype: parapy.geom.Surface
        """
        h_geom_surface = self.Handle_Geom_Surface
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)

    @Part(trickle_down=False, in_tree=False, parse=None)
    def trimmed_surface(self):
        """Returns the rectangular trimmed underlying surface object on which
        this face builds. Each face of a Box, for example, returns a
        rectangular trimmmed planar surface.

        :rtype: parapy.geom.occ.surface.RectangularTrimmedSurface_
        """
        h_geom_surface = self.Handle_Geom_Surface_trimmed
        h_geom_surface, cls = Handle_Geom_Surface2ParaPy(h_geom_surface)
        return cls(Handle_Geom_Surface=h_geom_surface)

    # ---------------- shape features -------------------
    @Attribute
    def is_cylindrical(self):
        """Is this face cylindrical?

        :rtype: bool
        """
        return self.basis_surface.is_cylindrical

    @Attribute
    def is_conical(self):
        """Is this face conical?

        :rtype: bool
        """
        return self.basis_surface.is_conical

    @Attribute
    def is_planar(self):
        """Is this face planar?

        :rtype: bool
        """
        return self.basis_surface.is_planar

    @Attribute
    def plane_normal(self):
        """The plane normal of this face.

        :rtype: parapy.geom.Vector
        """
        v = self.basis_surface.plane_normal
        if self.brep_orientation == "reversed":
            return -v
        else:
            return v

    # ---------------- surface-like attributes -------------------
    @Attribute
    def uv_bounds(self):
        """
        :returns: (u1, u2, v1, v2)
        :rtype: (float, float, float, float)
        """
        topods_face = downcast_shape(self.TopoDS_Shape, TopAbs_FACE)
        return tuple(BRepTools__UVBounds(topods_face))

    @Attribute
    def uv_vertices(self):
        """Return the uv-points of all vertices of this face.

        :return: list. List of (u, v) tuples.
        :rtype: list[tuple[float, float]]
        """
        parameters = []
        topods_face = downcast_shape(self.TopoDS_Shape, TopAbs_FACE)
        for vertex in self.vertices:
            topods_vertex = downcast_shape(vertex.TopoDS_Shape, TopAbs_VERTEX)
            gp_Pnt2d = BRep_Tool_Parameters(topods_vertex, topods_face)
            parameters.append((gp_Pnt2d.X(), gp_Pnt2d.Y()))

        return parameters

    def normal(self, u, v):
        """The NORMALIZED normal vector at point u, v.

        :type u: float
        :type v: float
        :rtype: parapy.geom.Vector
        """
        v = Surface.normal(self, u, v)
        if self.brep_orientation == "reversed":
            return -v
        else:
            return v

    # TODO (RvD): http://www.opencascade.org/org/forum/thread_6871/?forum=3
    def UIso(self, value, v1=None, v2=None, **kwargs):
        """U isoparametric curve fixed at u-parameter ``value`` and trimmed
        to ``v1`` and ``v2``. By default, it is trimmed to the uv_bounds of
        this Face. As such, iso-lines are not garantueed to be exactly trimmed
        to the wire contour of the face, but can be larger. One should use the
        pcurves of the edges of this face to exactly trim the iso_curve.

        :param float value: u-parameter.
        :param float | None v1: if None, :attr:`v1` used.
        :param float | None v2: if None, :attr:`v2` used.
        :param dct kwargs: extra inputs for :class:`UIso`.
        :rtype: parapy.geom.TrimmedCurve
        """
        curve = UIso(surface=self, value=value)
        v1 = v1 if v1 is not None else self.v1
        v2 = v2 if v2 is not None else self.v2
        return TrimmedCurve(curve, v1, v2, **kwargs)

    # TODO (RvD): http://www.opencascade.org/org/forum/thread_6871/?forum=3
    def VIso(self, value, u1=None, u2=None, **kwargs):
        """V isoparametric curve fixed at v-parameter ``value`` and trimmed
        to ``u1`` and ``u2``. By default, it is trimmed to the uv_bounds of
        this Face. As such, iso-lines are not garantueed to be exactly trimmed
        to the wire contour of the face, but can be larger. One should use the
        pcurves of the edges of this face to exactly trim the iso_curve.

        :param float value: v-parameter.
        :param float | None u1: if None, :attr:`u1` used.
        :param float | None u2: if None, :attr:`u2` used.
        :param dct kwargs: extra inputs for :class:`VIso`.
        :rtype: parapy.geom.TrimmedCurve
        """
        curve = VIso(surface=self, value=value)
        u1 = u1 if u1 is not None else self.u1
        u2 = u2 if u2 is not None else self.u2
        return TrimmedCurve(curve, u1, u2, **kwargs)

    def UIsoCurves(self, nb, v1=None, v2=None, **kwargs):
        """``nb`` U isoparametric curves fixed at u-parameters evenly
        distributed from :attr:`u1`-:attr:`u2`. Iso-curves are trimmed
        to ``v1`` and ``v2``. By default, it is trimmed to the uv_bounds of
        this Face. As such, iso-lines are not garantueed to be exactly trimmed
        to the wire contour of the face, but can be larger. One should use the
        pcurves of the edges of this face to exactly trim the iso_curve.

        :param int nb: number of iso-curves
        :param float | None v1: if None, :attr:`v1` used.
        :param float | None v2: if None, :attr:`v2` used.
        :param dct kwargs: extra inputs for :class:`UIso`.
        :rtype: list[UIso]
        """
        v1 = v1 if v1 is not None else self.v1
        v2 = v2 if v2 is not None else self.v2
        return [self.UIso(value, v1, v2, **kwargs) for
                value in list_of_numbers(self.u1, self.u2, nb)]

    def VIsoCurves(self, nb, u1=None, u2=None, **kwargs):
        """``nb`` V isoparametric curves fixed at v-parameters evenly
        distributed from :attr:`v1`-:attr:`v2`. Iso-curves are trimmed
        to ``u1`` and ``u2``. By default, it is trimmed to the uv_bounds of
        this Face. As such, iso-lines are not garantueed to be exactly trimmed
        to the wire contour of the face, but can be larger. One should use the
        pcurves of the edges of this face to exactly trim the iso_curve.

        :param int nb: number of iso-curves
        :param float | None u1: if None, :attr:`u1` used.
        :param float | None u2: if None, :attr:`u2` used.
        :param dct kwargs: extra inputs for :class:`VIso`.
        :rtype: list[UIso]
        """
        u1 = u1 if u1 is not None else self.u1
        u2 = u2 if u2 is not None else self.u2
        return [self.VIso(value, u1, u2, **kwargs) for
                value in list_of_numbers(self.u1, self.u2, nb)]

    # ---------------- topology -------------------
    @Part(trickle_down=False, in_tree=False, parse=None)
    def vertices(self):
        """
        :rtype: list[parapy.geom.occ.vertex.Vertex_]
        """
        return list(self._sub_shape_generator("vertex"))

    @Part(trickle_down=False, in_tree=False, parse=None)
    def edges(self):
        """
        :rtype: list[parapy.geom.occ.edge.Edge_]
        """
        return list(self._sub_shape_generator("edge"))

    @Part(trickle_down=False, in_tree=False, parse=None)
    def wires(self):
        """
        :rtype: list[parapy.geom.occ.wire.Wire_]
        """
        return list(self._sub_shape_generator("wire"))

    @Attribute
    def faces(self):
        """
        :rtype: list[parapy.geom.occ.face.Face_]
        """
        return [self]

    @Attribute
    def outer_wire(self):
        """The outer wire is the outer-most trimming loop used to build this
        face from its basis-surface. Can be None, if underlying geometry is
        infinite (e.g. Plane).

        :rtype: parapy.geom.Wire_ | None
        """
        dct = self._TopoDS2Wires
        if not dct:
            return None
        else:
            topods_wire = BRepTools__OuterWire(self.TopoDS_Face)
            return dct[topods_wire]

    @Attribute
    def inner_wires(self):
        """List of all the inner wires (holes) used while trimming this face
        from its basis-surface.

        :rtype: list[parapy.geom.Wire_]
        """
        outer_wire = self.outer_wire
        # order preserving
        return [wire for wire in self.wires if not wire == outer_wire]
        # return list(set(self.wires)-set([self.outer_wire]))

    @Attribute
    def on_solids(self):
        """
        :rtype: list[parapy.geom.occ.solid.Solid_]
        """
        return self.get_ancestors("solid")

    @Attribute
    def on_shells(self):
        """
        :rtype: list[parapy.geom.occ.shell.Shell_]
        """
        return self.get_ancestors("shell")

    @Attribute
    def neighbours(self):
        """list of neighbouring faces. Check on faces for all edges, and
        remove self.

        :rtype: list[Face_]
        """
        return self.get_neighbours("edge")

    @Attribute
    def opposite_face(self):
        """Returns opposite Face_. You have to retrieve this face through a
        reference chain that at least involves a shell or solid object!

        So use it like:

        >>> from parapy.geom import Box
        >>> box = Box(1, 1, 1)
        >>> face = box.faces[0]
        >>> face.opposite_face

        :rtype: Face_
        """
        opposite_faces = self.opposite_faces
        if opposite_faces:
            if len(opposite_faces) == 1:
                return opposite_faces[0]
            else:
                msg = ("Opposite face is ambiguous as there are {:} opposite "
                       "faces. Use opposite_faces instead.")
                raise Exception(msg.format(len(opposite_faces)))
        else:
            msg = ("Couldn't find any opposite face. Are you sure the "
                   "topology is cube-like or larger?")
            raise RuntimeError(msg)

    @Attribute
    def opposite_faces(self):
        """Same conditions apply as for :attr:`opposite_face`, but always
        returns a list of faces.

        :rtype: list[Face_]
        """
        if self._owner:
            s = self.trace_up_owner("shell", "compsolid")
            shape = self.TopoDS_Shape
            fn = shape.IsSame
            other_faces = [f for f in s.faces if not fn(f.TopoDS_Shape)]
            # level 6 is Edge
            neighbours = self._get_neighbours(6, owner=s.TopoDS_Shape)
            # now find difference between other_edges and neighbours
            for n in neighbours:
                fn = n.IsSame
                for other in other_faces:
                    if fn(other.TopoDS_Shape):
                        other_faces.remove(other)
            return other_faces
        else:
            raise Exception("this face isn't owned...")


# monkey_patch BRep class
BRep.FaceClass = Face_
# monkey_patch Surface class
Surface.FaceClass = Face_


class Face(Face_):
    """Make a face from a (planar) :attr:`island`. Potentially with multiple
    :attr:`holes`.

    Usage:

    >>> from parapy.geom import Face, Rectangle, Circle
    >>> island = Rectangle(1, 1)
    >>> hole = Circle(radius=0.3)
    >>> obj = Face(island=island, holes=[hole])
    """

    __initargs__ = ["island", "holes"]

    #: The boundary on the basis_surface can be a single curve/wire or a list
    #: of these.
    #: :type: parapy.geom.Curve | collections.Sequence[parapy.geom.Curve]
    island = Input()

    #: You can specify holes. The input is a list, that can subsequently
    #: contain single curves/wires or lists of these.
    #: :type: collections.Sequence[parapy.geom.Curve]
    holes = Input([])

    #: if only_plane is true, the computed surface will be a plane. If it is
    #: not possible to find a plane, an exception will be raised.
    #: :type: bool
    only_plane = Input(True)

    #: Sometimes holes can become reversed. This check is there to fix the
    #: resulting face if this occurs.
    #: :type: bool
    check_orientation = Input(False)

    @Attribute
    def island_wire(self):
        """
        :rtype: parapy.geom.Wire | parapy.geom.Curve
        """
        island = self.island
        if hasattr(island, "__iter__"):
            island = Wire(island)
        return island

    @Attribute
    def hole_wires(self):
        """
        :rtype: list[parapy.geom.Wire | parapy.geom.Curve]
        """
        wires = []
        for hole in self.holes:
            if hasattr(hole, "__iter__"):
                wire = Wire(hole)
            else:
                wire = hole
            wires.append(wire)
        return wires

    def _init_BRepBuilderAPI_MakeFace(self):
        """
        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeFace
        """
        topods_wire = self.island_wire.TopoDS_Wire
        builder = BRepBuilderAPI_MakeFace(topods_wire, self.only_plane)
        return builder

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Face
        """
        builder = self._init_BRepBuilderAPI_MakeFace()
        for wire in self.hole_wires:
            topods_wire = wire.TopoDS_Wire
            builder.Add(topods_wire)
        if builder.IsDone():
            topods_face = builder.Face()
            if self.check_orientation:
                # print "fixing face, wires are misoriented."
                fixer = ShapeFix_Face(topods_face)
                fixer.FixOrientation()
                topods_face = fixer.Face()
            return topods_face
        else:
            raise Exception("Creation of the face failed.\nMessage:",
                            BRepBuilderAPI_FaceError[builder.Error()])


class PlanarFace(Face):
    """Specialized for planar face construction, nothing more, nothing less.

    Usage:

    >>> from parapy.geom import PlanarFace, Rectangle
    >>> crv = Rectangle(1, 1)
    >>> obj = PlanarFace(island=crv)
    """
    #: :type: bool
    only_plane = Attribute(True)


class TrimmedSurface(Face):
    """Make a face from a Surface and an island curve(s)/wire. Potentially
    with multiple holes.

    Usage:

    >>> from parapy.geom import RectangularFace, Circle, TrimmedSurface
    >>> srf = RectangularFace(4, 2)
    >>> hole = Circle(0.5)
    >>> obj = TrimmedSurface(built_from=srf, island=hole)
    """

    __initargs__ = ["built_from", "island", "holes"]

    #: The underlying surface object or another face
    #: :type: parapy.geom.Surface | Face
    built_from = Input()

    def _init_BRepBuilderAPI_MakeFace(self):
        """
        :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeFace
        """
        # topods_face = TopoDS__Face(self.built_from.TopoDS_Shape)
        h_surf = self.built_from.Handle_Geom_Surface
        topods_wire = self.island_wire.TopoDS_Wire
        builder = BRepBuilderAPI_MakeFace(h_surf, topods_wire)
        return builder


class CircularFace(PlanarFace):
    """Make a circular trimmed face.

    Usage:

    >>> from parapy.geom import CircularFace
    >>> obj = CircularFace(radius=1)
    """

    __initargs__ = ["radius"]

    #: Face radius
    #: :type: float
    radius = Input()

    @Part(in_tree=False)
    def island(self):
        """
        :rtype: parapy.geom.Circle
        """
        return Circle(pass_down="radius")


class PolygonalFace(Face):
    """Create a face from a polygon described by :attr:`points`. Points have
    to lie in the same plane!

    Usage:

    >>> from parapy.geom import PolygonalFace, Point
    >>> pts = [Point(0, 0, 0), Point(1, 0, 0), Point(1, 1, 0), Point(0, 1, 0)]
    >>> obj = PolygonalFace(pts)
    """

    __initargs__ = ["points"]

    #: list of points
    #: :type: collections.Sequence[Point]
    points = Input()

    @Part(in_tree=False)
    def island(self):
        """
        :rtype: parapy.geom.Polygon
        """
        return Polygon(points=self.points, force_closure=True)


class NSidedPolygonalFace(PlanarFace):
    """Usage:

    >>> from parapy.geom import NSidedPolygonalFace
    >>> obj = NSidedPolygonalFace(radius=0.5, N=5)
    """

    __initargs__ = ["radius", "N"]

    #: radius
    #: :type: float
    radius = Input(validator=val.Positive())

    #: The number of vertices
    #: :type: int
    N = Input()

    @Part(in_tree=False)
    def island(self):
        """
        :rtype: parapy.geom.NSidedPolygon
        """
        return NSidedPolygon(pass_down="radius, N")


class RectangularFace(PolygonalFace):
    """Position.Vz vector is normal of face width and length control
    dimensions in Vx and Vy directions, respectively.

    Usage:

    >>> from parapy.geom import RectangularFace
    >>> obj = RectangularFace(width=1, length=1)

    By default, :attr:`position` corresponds to the center of the face.
    If you prefer the bottom-left vertex as reference, use :attr:`centered`:

    >>> obj = Rectangle(width=1, length=1, centered=False)
    """
    __initargs__ = ["width", "length"]

    #: width of face
    #: :type: float
    width = Input(validator=val.Positive())

    #: lenth of face
    #: :type: float
    length = Input(validator=val.Positive())

    #: If False, :attr:`position` input corresponds to lower-left vertex.
    #: :type: boolean
    centered = Input(True)

    @Part(in_tree=False)
    def island(self):
        """
        :rtype: parapy.geom.Rectangle
        """
        return Rectangle(pass_down="width, length, centered")

    @Attribute
    def points(self):
        """Corner Points of the RectangularFace with the first point repeated.

        :rtype: tuple[parapy.geom.Point]
        """
        return self.island.points


# Experimental
class ReconstructedFace(Face_):
    """Takes a face (e.g. trimmed surface) and reconstructs a new face
    respecting its borders.
    """

    __initargs__ = ["built_from"]

    #: an existing face
    #: :type: Face
    built_from = Input()

    @Attribute
    def builder(self):
        """
        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_MakeFilling
        """
        TopoDS_Face = self.built_from.TopoDS_Face
        builder = BRepOffsetAPI_MakeFilling()
        for edge in self.built_from.edges:
            # Problem: Only C0 and G1 seems to work. G2 causes problem
            # See: 
            builder.Add(edge.TopoDS_Edge, TopoDS_Face, GeomAbs_G1)
        builder.Build()
        if not builder.IsDone():
            raise Exception("BRepOffsetAPI_MakeFilling failed on this face")
        else:
            return builder

    @Attribute
    def TopoDS_Shape(self):
        """
        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()

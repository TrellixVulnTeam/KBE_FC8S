#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Contains all solid primitives"""

import math
import os
import warnings

from OCC.wrapper.BRepPrimAPI import (
    BRepPrimAPI_MakeBox, BRepPrimAPI_MakeCone, BRepPrimAPI_MakeCylinder,
    BRepPrimAPI_MakeRevolution, BRepPrimAPI_MakeSphere, BRepPrimAPI_MakeTorus,
    BRepPrimAPI_MakeWedge)
from OCC.wrapper.gp import gp_Ax2, gp_Dir, gp_Pnt

from parapy.core import Attribute, Input, derived, val
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.geom.generic import OXY
from parapy.geom.generic.geom_base import BBox
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.face import Face
from parapy.geom.occ.solid import Solid_
from parapy.geom.occ.surface import Plane_
from parapy.utilities import deprecated


def check_IsDone(builder):
    """Perform ``Build()`` and check if ``builder`` is done building without 
    errors. Return ``builder`` if no errors occurred.

    :type builder: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
    :rtype: OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape
    :raises Exception: if something went wrong during the construction using
        ``builder``.
    """
    builder.Build()
    if builder.IsDone():
        return builder
    else:
        raise Exception("construction failed")


class PrimitiveSolid(Solid_):
    """Abstract base class for primitive solid-creating operations."""

    #: The position or placement of this object. An instance of
    #: :class:`~parapy.geom.generic.positioning.Position`, which consists of a
    #: ``location`` in and ``orientation`` in space.
    #: :type: parapy.geom.generic.positioning.Position
    position = Input(OXY, defaulting=True)

    @Attribute(private=True)
    def TopoDS_Shape(self):
        """if needed, override on subclassing. But leave an input in direct
        subclasses of BRep!

        :rtype: OCC.TopoDS.TopoDS_Shape
        """
        return self.builder.Shape()


class Box(PrimitiveSolid):
    """A box with dimensions :attr:`width`, :attr:`length` and :attr:`height`.
    By default, the reference axis system :attr:`position` corresponds to the
    vertex at -dx, -dy, -dz or at the *lower-left-front*.

    Usage:

    >>> from parapy.geom import Box
    >>> box = Box(1, 2, 3)  # keywords: Box(width=1, length=2, height=3)
    >>> box.position
    Position(Point(0, 0, 0))
    >>> box.center
    Point(0.5, 1.0, 1.5)
    >>> box.area
    22
    >>> box.volume
    6
    >>> box.top_face  # doctest: +ELLIPSIS
    <Face_ root.faces[5] at 0x...>

    For a box centered at :attr:`position`, put :attr:`centered` to :py:`True`.
    >>> box = Box(1, 2, 3, centered=True)
    >>> box.center
    Point(0, 0, 0)
    """

    __icon__ = os.path.join(ICN_DIR, 'box.png')
    __initargs__ = ["width", "length", "height"]

    #: width of the box
    #: :type: float
    width = Input(validator=val.Positive())

    #: length of the box
    #: :type: float
    length = Input(validator=val.Positive())

    #: height of the box
    #: :type: float
    height = Input(validator=val.Positive())

    #: if :py:`True`, the box is centered at :attr:`position`.
    #: :type: bool
    centered = Input(False)

    @Attribute
    def area(self):
        """Total surface area of the faces.

        :rtype: float
        """
        w = self.width
        l = self.length
        h = self.height
        return 2 * (w * l + w * h + l * h)

    @Attribute
    def volume(self):
        """Volume of the enclosed volume.

        :rtype: float
        """
        return self.width * self.length * self.height

    @Attribute
    def center(self):
        """Center of the volume.

        :rtype: parapy.geom.Point
        """
        return self.center_position.location

    @Attribute
    def center_position(self):
        """Position at center of the box.

        :rtype: parapy.geom.Position
        """
        # Not DRY, lots of apparent repetitions inside [X]_position
        # Attributes. One could argue that slots should just reuse
        # corner_position and move relative to that. However the style below
        # is deliberate as it results in the shortest evaluation paths and
        # therefore theoretically perfect dependencies (not evaluating slots
        # that aren't required).
        pos = self.position
        if self.centered:
            return pos
        else:
            w, l, h = self.width, self.length, self.height
            return pos.translate(x=0.5 * w, y=0.5 * l, z=0.5 * h)

    @Attribute
    def bottom_position(self):
        """Position at center of the bottom_face, useful for conversion to an
        extrusion object.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(z=-0.5 * self.height)
        else:
            return pos.translate(x=0.5 * self.width, y=0.5 * self.length)

    @Attribute
    def top_position(self):
        """Position at center of the top face.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(z=0.5 * self.height)
        else:
            return pos.translate(
                x=0.5 * self.width, y=0.5 * self.length, z=self.height)

    @Attribute
    def corner_position(self):
        """Position at -dx, -dy, -dz or *lower-left-front*.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:
            w, l, h = self.width, self.length, self.height
            return pos.translate(x=-0.5 * w, y=-0.5 * l, z=-0.5 * h)
        else:
            return pos

    @Attribute(private=True)
    def builder(self):
        """The builder of this Box.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeBox
        """
        w, l, h = self.width, self.length, self.height
        pos = self.corner_position
        P, N, Vx = pos.location, pos.orientation.z, pos.orientation.x
        ax2 = gp_Ax2(gp_Pnt(*P), gp_Dir(*N), gp_Dir(*Vx))
        builder = BRepPrimAPI_MakeBox(ax2, w, l, h)
        return check_IsDone(builder)

    @Attribute
    def _local_bbox_bounds(self):
        w, l, h = self.width, self.length, self.height
        pos = self.corner_position
        x1, y1, z1 = pos
        x2, y2, z2 = pos.translate(x=w, y=l, z=h)
        return x1, y1, z1, x2, y2, z2

    @Attribute
    def right_face(self):
        """x-max face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.FrontFace()]

    @Attribute
    def left_face(self):
        """x-min face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.BackFace()]

    @Attribute
    def rear_face(self):
        """y-max face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.RightFace()]

    @Attribute
    def front_face(self):
        """y-min face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.LeftFace()]

    @Attribute
    def top_face(self):
        """z-max face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.TopFace()]

    @Attribute
    def bottom_face(self):
        """z-min face.

        :rtype: parapy.geom.Face
        """
        return self._TopoDS2Faces[self.builder.BottomFace()]


class Cube(Box):
    """A :class:`Box` with equal dimensions.

    Usage:

    >>> obj = Cube(2)  # keywords: Cube(dimension=2)
    >>> obj.dimension
    2
    >>> obj.width, obj.length, obj.height
    (2, 2, 2)
    >>> obj.volume
    8
    """

    __initargs__ = ["dimension"]

    #: the value of width, length and height
    #: :type: float
    dimension = Input(validator=val.Positive())

    @Attribute
    def width(self):
        """same as :attr:`dimension`.

        :rtype: float
        """
        return self.dimension

    @Attribute
    def length(self):
        """same as :attr:`dimension`.

        :rtype: float
        """
        return self.dimension

    @Attribute
    def height(self):
        """same as :attr:`dimension`.

        :rtype: float
        """
        return self.dimension

    @Attribute
    def area(self):
        """Total surface area of the faces.

        :rtype: float
        """
        return 6 * self.dimension ** 2

    @Attribute
    def volume(self):
        """Volume of the enclosed volume.

        :rtype: float
        """
        return self.dimension ** 3


@deprecated(replaced_by='parapy.geom.Box')
class VisualBBox(Box):
    """Can be used to visualize a :class:`~parapy.geom.generic.geom_base.BBox`
    instance :attr:`bbox`. The dimensions of this box will equal those of the
    :attr:`bbox` and its :attr:`position` corresponds to the center of the
    :attr:`bbox`.

    Usage:

    >>> bbox = Cylinder(radius=1, height=3).bbox
    >>> obj = VisualBBox(bbox)  # keywords: (bbox=bbox)
    >>> obj.width, obj.length, obj.height  # doctest: +ELLIPSIS
    (2.0..., 2.0..., 3.0...)
    """

    __initargs__ = ["bbox"]

    #: :class:`~parapy.geom.generic.geom_base.BBox` instance to visualize
    #: :type: parapy.geom.generic.geom_base.BBox
    bbox = Input()

    #: by definition True
    #: :type: bool
    centered = Attribute(True)

    @Attribute
    def width(self):
        """width of the :attr:`built_from` BBox.

        :rtype: float
        """
        return self.bbox.width

    @Attribute
    def length(self):
        """length of the :attr:`built_from` BBox.

        :rtype: float
        """
        return self.bbox.length

    @Attribute
    def height(self):
        """height of the :attr:`built_from` BBox.

        :rtype: float
        """
        return self.bbox.height

    @Attribute
    def position(self):
        """position is at center of the :attr:`built_from` BBox.

        :rtype: parapy.geom.Position
        """
        return self.bbox.position


# Monkey-patch BBox
BBox.box.fn = lambda _: Box()


class Wedge(PrimitiveSolid):
    """Position is at vertex -x, -y, -z. Defaults to a pyramid shape. Usage:

    >>> obj = Wedge(dx=2, dy=1, dz=2, xmin=0.5, zmin=0.5, xmax=1.5, zmax=1.5)

    .. caution:: if you specify a custom ``position`` argument, the shape may
        fail. This has been fixed in later OpenCascade releases, but current
        wrappers target older OpenCascade version. See `Open Cascade issue
        <http://tracker.dev.opencascade.org/view.php?id=24144>`__. For now,
        create a wedge with the standard orientation and use any of the
        transformation operations on this shape to get the desired result.
    """

    __initargs__ = ["dx", "dy", "dz", "xmin", "zmin", "xmax", "zmax"]

    #: Dimension in **local** x direction.
    #: :type: float
    dx = Input(validator=val.Positive())

    #: Dimension in **local** y direction.
    #: :type: float
    dy = Input(validator=val.Positive())

    #: Dimension in **local** z direction.
    #: :type: float
    dz = Input(validator=val.Positive())

    #: Minimum x location of face at dy. Defaults to dx/2.
    #: :type: float.
    xmin = Input(derived)

    #: Maximum x location of face at dy. Defaults to xmin (dx/2).
    #: :type: float.
    xmax = Input(derived)

    #: Minimum z location of face at dy. Defaults to dz/2.
    #: :type: float.
    zmin = Input(derived)

    #: Maximum z location of face at dy. Defaults to zmin (dz/2).
    #: :type: float.
    zmax = Input(derived)

    def _get_xmin(self):
        """:rtype: float"""
        return 0.5 * self.dx

    def _get_zmin(self):
        """:rtype: float"""
        return 0.5 * self.dz

    def _get_xmax(self):
        """:rtype: float"""
        return self.xmin

    def _get_zmax(self):
        """:rtype: float"""
        return self.zmin

    @Attribute
    def builder(self):
        """The builder of this Wedge.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeWedge
        """
        Axes = self.position.gp_Ax2
        dx, dy, dz = self.dx, self.dy, self.dz
        xmin, zmin, xmax, zmax = self.xmin, self.zmin, self.xmax, self.zmax
        args = Axes, dx, dy, dz, xmin, zmin, xmax, zmax
        builder = BRepPrimAPI_MakeWedge(*args)
        builder.Build()
        if builder.IsDone():
            return builder
        else:
            raise Exception("construction failed")


def _OneAxisSolid_angle_validator(value, obj, slot):
    """validator to test if ``value`` describes an angle within one full
    circle.

    :param float value:
    :param parapy.geom.Base obj: instance which contains ``slot``.
    :param slot:
    :rtype: bool
    """
    return 0. < value <= 2. * math.pi


def _OneAxisSolid_angle_preprocessor(value, obj, slot):
    """preprocessor that clips ``value`` to a maximum of :py:`2 * math.pi`
    when value is bigger than :py:`2 * math.pi`, and returns the
    pre-processed value.

    :param float value: value to pre-process
    :param parapy.geom.Base obj: instance which contains ``slot``.
    :param slot:
    :rtype: float
    """
    if value > 2 * math.pi:
        return 2 * math.pi
    else:
        return value


class OneAxisSolid(PrimitiveSolid):
    """Base class for all rotational solid"""

    #: angle of the revolution. Defaults to :py:`2 * math.pi`. Provide a
    #: smaller value, for a partial revolution.
    #: :type: float
    angle = Input(math.pi * 2,
                  validator=_OneAxisSolid_angle_validator,
                  preprocessor=_OneAxisSolid_angle_preprocessor)

    @Attribute
    def is_partial(self):
        """Full revolution or partial?

        :rtype: float
        """
        return self.angle != 2 * math.pi

    @Attribute
    def lateral_face(self):
        """Face in the lateral direction (v-parameter).

        :rtype: Face
        """
        return self._TopoDS2Faces[self.builder.Face()]


class Cylinder(OneAxisSolid):
    """Cylinder dimensioned by :attr:`radius` and :attr:`height`. The axis
    system :attr:`position` is located at the bottom/base of the cylinder and
    the height of cylinder corresponds to the z-direction of the system. If
    :attr:`centered` is True, the provided axis system locates the center
    of the cylinder.

    Usage:

    >>> from parapy.geom import Cylinder
    >>> obj = Cylinder(1, 2)  # keywords: (radius=1, height=2)
    >>> obj.radius, obj.height
    (1, 2)
    >>> obj.angle  # doctest: +ELLIPSIS
    6.2831...

    For partial cylinders, provide an :attr:`angle` smaller than the
    default :py:`2 * math.pi`. Usage:

    >>> from parapy.geom import Cylinder
    >>> import math
    >>> cyl = Cylinder(1, 2, angle=(math.pi * 3. / 2.))
    >>> cyl.radius, cyl.height
    (1, 2)
    >>> cyl.angle  # doctest: +ELLIPSIS
    4.712...
    """

    __icon__ = os.path.join(ICN_DIR, 'cylinder.png')
    __initargs__ = ["radius", "height", "angle"]

    #: the radius of the cylinder
    #: :type: float
    radius = Input(validator=val.Positive())

    #: the height of the cylinder
    #: :type: float
    height = Input(validator=val.Positive())

    #: angle of the cylinder. Defaults to :py:`2 * math.pi`. Provide a smaller
    #: value, for a partial cylinder.
    #: :type: float
    angle = Input(math.pi * 2)

    #: if :py:`True`, the cylinder is centered at :attr:`position`.
    #: :type: bool
    centered = Input(False)

    @Attribute
    def center(self):
        """Center of the volume.

        :rtype: parapy.geom.Point
        """
        return self.center_position.location

    @Attribute
    def area(self):
        """Area of the faces of this cylinder.

        :rtype: float
        """
        r, h, angle = self.radius, self.height, self.angle
        area = angle * r ** 2 + angle * r * h
        if self.is_partial:
            area += 2 * r * h
        return area

    @Attribute
    def volume(self):
        """Volume of this cylinder.

        :rtype: float
        """
        return 0.5 * self.angle * self.radius ** 2 * self.height

    @Attribute(private=True)
    def builder(self):
        """The builder of this cylinder.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeCylinder
        """
        r, h, A = self.radius, self.height, self.angle
        pos = self.bottom_position
        P, N, Vx = pos.location, pos.orientation.z, pos.orientation.x
        ax2 = gp_Ax2(gp_Pnt(*P), gp_Dir(*N), gp_Dir(*Vx))
        if A == 2 * math.pi:
            builder = BRepPrimAPI_MakeCylinder(ax2, r, h)
        else:
            builder = BRepPrimAPI_MakeCylinder(ax2, r, h, A)
        return check_IsDone(builder)

    @Attribute
    def surface(self):
        """Infinite cylindrical surface. Position becomes center of inifinit
        surface.

        :rtype: parapy.geom.occ.surface.Surface
        """
        return self.lateral_face.basis_surface

    @Attribute
    def center_position(self):
        """Position at center of the cylinder.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos
        else:
            return pos.translate(z=0.5 * self.height)

    @Attribute
    def top_position(self):
        """Centered Position of top face.

        :rtype: parapy.geom.Position
        """
        pos, h = self.position, self.height
        if self.centered:  # Not DRY, but see Box.center_position why
            h *= 0.5
        return pos.translate(z=h)

    @Attribute
    def bottom_position(self):
        """Position at center of the bottom face.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(z=-0.5 * self.height)
        else:
            return pos

    @Attribute
    def lateral_position(self):
        """Start point of rotation at bottom face.

        :rtype: parapy.geom.Position
        """
        r, pos = self.radius, self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(x=r, z=-0.5 * self.height)
        else:
            return pos.translate(x=r)

    @Attribute
    def _local_bbox_bounds(self):
        r, h, angle = self.radius, self.height, self.angle
        pos = self.bottom_position

        if angle >= 1.5 * math.pi:
            rx, rx_, ry, ry_ = r, r, r, r
        elif angle >= math.pi:
            rx, rx_, ry = r, r, r
            ry_ = math.sin(angle - math.pi) * r
        elif angle >= 0.5 * math.pi:
            rx, ry, ry_ = r, r, 0
            rx_ = math.sin(angle - 0.5 * math.pi) * r
        else:
            rx, rx_, ry_ = r, 0, 0
            ry = math.sin(angle) * r

        x1, y1, z1 = pos.translate(x=-rx_, y=-ry_)
        x2, y2, z2 = pos.translate(x=rx, y=ry, z=h)

        return x1, y1, z1, x2, y2, z2

    @Attribute
    def bottom_face(self):
        """The bottom face.

        :rtype: parapy.geom.Face
        """
        f_lat = self.lateral_face  # accesible by identity
        p_bot = self.bottom_position
        for face in self.faces:
            if face != f_lat and face.basis_surface.position == p_bot:
                return face
        assert False, "Could not find bottom_face"

    @Attribute
    def top_face(self):
        """The top face.

        :rtype: parapy.geom.Face
        """
        f_lat = self.lateral_face  # accesible by identity
        p_top = self.top_position
        for face in self.faces:
            if face is not f_lat and face.basis_surface.position == p_top:
                return face
        assert False, "Could not find bottom_face"

    @Attribute
    def end_caps(self):
        """Tuple with either two faces (partial cylinder) or empty.

        :rtype: tuple[parapy.geom.Face]
        """
        if self.is_partial:
            skip = {self.lateral_face, self.bottom_face, self.top_face}
            return tuple(face for face in self.faces if face not in skip)
        else:
            return ()

    @Attribute
    def end_cap1(self):
        """The first end cap if cylinder is partial.

        :returns None: if cylinder is not partial.
        :rtype: parapy.geom.Face | None
        """
        if self.is_partial:
            v = self.position.Vy_
            for face in self.end_caps:
                if face.plane_normal == v:
                    return face
            assert False, "for some reason couldn't find end cap 1"

    @Attribute
    def end_cap2(self):
        """The second end cap if cylinder is partial.

        :returns None: if cylinder is not partial.
        :rtype: parapy.geom.Face | None
        """
        if self.is_partial:
            f1 = self.end_cap1
            for face in self.end_caps:
                if face is not f1:
                    return face
            assert False, "for some reason couldn't find end cap 1"


class Cone(OneAxisSolid):
    """Cone dimensioned by bottom radius :attr:`radius1`, top radius
    :attr:`radius2` and :attr:`height`. The axis system :attr:`position` is
    located at the bottom/base of the cone and the height of cone
    corresponds to the z-direction of the system. If :attr:`centered` is
    True, the provided axis system locates the center of the cone.

    Usage:

    >>> from parapy.geom import Cone
    >>> obj = Cone(radius1=1, radius2=0.4, height=2)
    >>> # or a 3-quarter cone
    >>> import math
    >>> cone = Cone(radius1=1, radius2=0.4, height=2, angle=math.pi * 3. / 2.)
    """
    __initargs__ = ["radius1", "radius2", "height", "angle"]

    #: :type: float
    radius1 = Input(validator=val.Positive())

    #: :type: float
    radius2 = Input(validator=val.Positive(incl_zero=True))

    #: :type: float
    height = Input(validator=val.Positive())

    #: :type: float
    angle = Input(2 * math.pi, validator=val.Positive())

    #: if :py:`True`, the cone is centered at :attr:`position`.
    #: :type: bool
    centered = Input(False)

    @Attribute
    def builder(self):
        """The builder object of this Cone.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeCone
        """
        r1, r2, h, angle = self.radius1, self.radius2, self.height, self.angle
        pos = self.bottom_position
        args = [pos.gp_Ax2, r1, r2, h]
        if angle != 2 * math.pi:
            args.append(angle)
        builder = BRepPrimAPI_MakeCone(*args)
        return check_IsDone(builder)

    @Attribute
    def center(self):
        """Center of the this cone.

        :rtype: parapy.geom.Point
        """
        return self.center_position.location

    @Attribute
    def center_position(self):
        """Position at center of the cone.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos
        else:
            return pos.translate(z=0.5 * self.height)

    @Attribute
    def bottom_position(self):
        """Position at center of the bottom face.

        :rtype: parapy.geom.Position
        """
        pos = self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(z=-0.5 * self.height)
        else:
            return pos

    @Attribute
    def top_position(self):
        """Position at center of the top face.

        :rtype: parapy.geom.Position
        """
        pos, h = self.position, self.height
        if self.centered:  # Not DRY, but see Box.center_position why
            h *= 0.5
        return pos.translate(z=h)

    @Attribute
    def lateral_position(self):
        """Position at start of rotation at bottom face.

        :rtype: parapy.geom.Position
        """
        r, pos = self.radius1, self.position
        if self.centered:  # Not DRY, but see Box.center_position why
            return pos.translate(x=r, z=-0.5 * self.height)
        else:
            return pos.translate(x=r)

    # ---- BBox ----
    @Attribute
    def _local_bbox_bounds(self):
        """A list of numbers representing the two defining corners of this
        bounding box.

        .. caution:: Only works for angles of between 0. and :py:`2*math.pi`

        :rtype: tuple[float, float, float, float, float, float]
        """
        r1, r2, h, angle = self.radius1, self.radius2, self.height, self.angle
        pos = self.bottom_position

        r = max(r1, r2)
        if angle >= 1.5 * math.pi:
            rx, rx_, ry, ry_ = r, r, r, r
        elif angle >= math.pi:
            rx, rx_, ry = r, r, r
            ry_ = math.sin(angle - math.pi) * r
        elif angle >= 0.5 * math.pi:
            rx, ry, ry_ = r, r, 0
            rx_ = math.sin(angle - 0.5 * math.pi) * r
        else:
            rx, rx_, ry_ = r, 0, 0
            ry = math.sin(angle) * r

        x1, y1, z1 = pos.translate(x=-rx_, y=-ry_)
        x2, y2, z2 = pos.translate(z=h, x=rx, y=ry)

        return x1, y1, z1, x2, y2, z2

    # ---- Topology ----
    @Attribute
    def bottom_face(self):
        """The bottom face.

        :rtype: parapy.geom.Face
        """
        for face in self.faces:
            surf = face.basis_surface
            if isinstance(surf, Plane_):
                if surf.position == self.bottom_position:
                    return face
        assert False, ("For some reason no bottom-face was found. Object {"
                       "}").format(self)

    @Attribute
    def top_face(self):
        """The top face. Returns None if apex is singular point.

        :rtype: parapy.geom.Face | None
        """
        if self.radius2:  # also catches 0
            for face in self.faces:
                surf = face.basis_surface
                if isinstance(surf, Plane_):
                    if surf.position == self.top_position:
                        return face
            assert False, ("No top-face found, but it should be there with "
                           "top radius {}. Object {}.").format(self.radius2,
                                                               self)

    @Attribute
    def end_caps(self):
        """Tuple with either two faces (partial cylinder) or empty.

        :rtype: tuple[parapy.geom.Face]
        """
        if self.is_partial:
            skip = {self.lateral_face, self.bottom_face, self.top_face}
            return tuple(face for face in self.faces if face not in skip)
        else:
            return ()

    @Attribute
    def end_cap1(self):
        """The first end cap if cylinder is partial.

        :returns None: if cylinder is not partial.
        :rtype: parapy.geom.Face | None
        """
        if self.is_partial:
            v = self.position.Vy_
            for face in self.end_caps:
                if face.plane_normal == v:
                    return face
            assert False, "for some reason couldn't find end cap 1"

    @Attribute
    def end_cap2(self):
        """The second end cap if cylinder is partial.

        :returns None: if cylinder is not partial.
        :rtype: parapy.geom.Face | None
        """
        if self.is_partial:
            f1 = self.end_cap1
            for face in self.end_caps:
                if face is not f1:
                    return face
            assert False, "for some reason couldn't find end cap 1"


class CCone(Cone):
    """CCone has been **deprecated**, use Cone(centered=True) instead."""

    centered = Attribute(True)

    def __init__(self, *args, **kwargs):
        msg = ("CCone is deprecated, use Cone(centered=True) "
               "instead. Object: {}.")
        warnings.warn(msg.format(self), ParaPyDeprecationWarning)
        super(CCone, self).__init__(*args, **kwargs)


def Sphere_angle1_validator(value, obj, slot):
    """Validates if ``value`` is greater or equal than :py:`-0.5 * math.pi`
    and smaller than :attr:`angle2` on instance ``obj``.

    :param float value:
    :param parapy.geom.Base obj: instance which contains ``slot``.
    :param slot:
    :rtype: bool
    """
    return -0.5 * math.pi <= value < obj.angle2


class Sphere(OneAxisSolid):
    """position determines orientation and center.

    Usage:

    >>> from parapy.geom import Sphere
    >>> from math import pi
    >>> obj1 = Sphere(radius=1)  # complete sphere with radius 1
    >>> obj2 = Sphere(radius=1, angle=1.5*pi, angle1=-pi/4.0, angle2=pi/4.0)
    """

    __initargs__ = ["radius", "angle", "angle1", "angle2"]

    #: :type: float
    radius = Input()

    #: :type: parapy.geom.Position
    position = Input(OXY, defaulting=True)

    #: Angle of rotation [rad]. Range: [0, 2 pi).
    #: Default: 2*pi.
    #: :type: float
    angle = Input(2 * math.pi, validator=val.Range(0, 2 * math.pi))

    #: Angle of rotation in -v direction [rad]. Range: [-0.5*pi, angle2).
    #: Default: -0.5*pi.
    #: :type: float
    angle1 = Input(-0.5 * math.pi, validator=Sphere_angle1_validator)

    #: Angle of rotation in +v direction [rad]. Range: (angle1, 0.5*pi].
    #: Default: 0.5*pi.
    #: :type: float
    angle2 = Input(0.5 * math.pi,
                   validator=val.LE(0.5 * math.pi))

    @Attribute
    def builder(self):
        """The builder object that constructed this :class:`Sphere`.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeSphere
        """
        a, a1, a2 = self.angle, self.angle1, self.angle2
        # (const gp_Ax2 &Axis, const Standard_Real R)
        args = (self.position.gp_Ax2, self.radius)
        if a1 == -0.5 * math.pi and a2 == 0.5 * math.pi:
            if not a == 2 * math.pi:
                # (const gp_Ax2 &Axis, const Standard_Real R,
                #  const Standard_Real angle)
                args += (a,)
        else:
            if a == 2 * math.pi:
                # (const gp_Ax2 &Axis, const Standard_Real R,
                # const Standard_Real angle1, const Standard_Real angle2)
                args += (a1, a2)
            else:
                # (const gp_Ax2 &Axis, const Standard_Real R,
                # const Standard_Real angle1, const Standard_Real angle2,
                # const Standard_Real angle3)
                args += (a1, a2, a)
        builder = BRepPrimAPI_MakeSphere(*args)
        return check_IsDone(builder)


class Torus(OneAxisSolid):
    """Creates a torus or a portion of a torus if optional angle is defined.
    The position determines orientation and center.

    Usage:

    >>> from parapy.geom import Torus
    >>> from math import pi
    >>> # Let's make a torus that revolves completely around the z-axis
    >>> torus1 = Torus(major_radius=30, minor_radius=10)
    >>> # Let's make a torus that revolves partially around the z-axis
    >>> torus2 = Torus(major_radius=30, minor_radius=10, angle=1.5*pi)
    """

    # =========================================================================
    # API
    # =========================================================================
    __initargs__ = ["major_radius", "minor_radius", "angle"]


    #: radius of torus
    #: :type: float
    major_radius = Input(validator=val.Positive())

    #: radius of cross section
    #: :type: float
    minor_radius = Input(validator=val.Positive())

    #: Revolving angle around z-axis. Range: [0, 2*pi). Default: 2*pi.
    #: :type: float
    angle = Input(2 * math.pi, validator=val.Range(0, 2 * math.pi))

    #: Start angle of the cross-section
    #: :type: float
    angle1 = Input(None)

    #: End angle of the cross-section
    #: :type: float
    angle2 = Input(None)

    @Attribute
    def builder(self):
        """The builder object that constructed this :class:`Torus`.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeTorus
        """
        a, a1, a2 = self.angle, self.angle1, self.angle2
        args = (self.position.gp_Ax2, self.major_radius, self.minor_radius)
        if not a1 is None:
            args += (a1, a2)
        if not a == 2 * math.pi:
            args += (a,)
        builder = BRepPrimAPI_MakeTorus(*args)
        return check_IsDone(builder)


class Revolution(OneAxisSolid):
    """Solid_ by revolving a curve :attr:`curve_in` around the z-direction of
    :attr:`position`.

    Usage:

    >>> from parapy.geom import Revolution, Point, InterpolatedCurve
    >>> pts = [Point(0, 0, 1), Point(1, 0, 1), Point(2, 0, 0)]
    >>> crv = InterpolatedCurve(pts)
    >>> obj = Revolution(curve_in=crv)
    """

    # =========================================================================
    # API
    # =========================================================================
    __initargs__ = ["curve_in", "angle"]

    #: Revolving  angle around z-axis. Range: [0, 2*pi). Default: 2*pi.
    #: :type: parapy.geom.Curve
    curve_in = Input()

    #: Revolving  angle around z-axis. Range: [0, 2*pi). Default: 2*pi.
    #: :type: float
    angle = Input(2 * math.pi,
                  validator=val.Range(0, 2 * math.pi, incl_min=False))

    #: :type: float
    v_min = Input(derived)

    #: :type: float
    v_max = Input(derived)

    # =========================================================================
    # Implementation
    # =========================================================================
    def _get_v_min(self):
        """:rtype: float"""
        return self.curve_in.u_min

    def _get_v_max(self):
        """:rtype: float"""
        return self.curve_in.u_max

    @Attribute
    def builder(self):
        """The builder object that constructed this :class:`Revolution`.

        :rtype: OCC.BRepPrimAPI.BRepPrimAPI_MakeRevolution
        """
        a = self.angle
        args = (
            self.position.gp_Ax2, self.curve_in.Handle_Geom_Curve, self.v_min,
            self.v_max)
        if not a == 2 * math.pi:
            args += (a,)
        builder = BRepPrimAPI_MakeRevolution(*args)
        return check_IsDone(builder)

if __name__ == '__main__':
    from parapy.gui import display
    cyl = Cylinder(radius=1, height=2, centered=True, angle=1.5 * math.pi)
    display(cyl)

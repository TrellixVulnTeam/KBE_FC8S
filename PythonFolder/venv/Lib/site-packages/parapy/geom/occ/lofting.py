#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Lofting is the operation of drawing a surface / solid through as set of
cross-sectional profiles.
"""

import os

from OCC.wrapper import Approx, GeomAbs
from OCC.wrapper.BRepOffsetAPI import BRepOffsetAPI_ThruSections
from OCC.wrapper.Geom import Geom_BSplineSurface
from OCC.wrapper.GeomFill import (
    GeomFill_AppSurf, GeomFill_Line, GeomFill_SectionGenerator)
from OCC.wrapper.Precision import Precision__PConfusion, Precision__Parametric

from parapy.core import Attribute, Input, derived
from parapy.core.validate import Optional, Range
from parapy.geom.globs import ICN_DIR
from parapy.geom.occ.shell import _SweptShell
from parapy.geom.occ.solid import _SweptSolid
from parapy.geom.occ.surface import BSplineSurface_

__all__ = ["LoftedSurface", "LoftedShell", "LoftedSolid"]


class LoftedSurface(BSplineSurface_):
    """No path, only cross-sectional curves. Works only well with few curves.
    If it is periodic in u- or v-direction, you have to specify this for now.
    Otherwise Geom_BSplineSurface Construction Error.

    Usage:

    >>> from parapy.geom import LoftedSurface, Circle, XOY
    >>> crv1 = Circle(radius=1.0, position=XOY)
    >>> crv2 = Circle(radius=2.0, position=XOY.translate('z', 5))
    >>> crv3 = Circle(radius=1.0, position=XOY.translate('z', 10))
    >>> obj = LoftedSurface(profiles=[crv1, crv2, crv3])
    """

    __icon__ = os.path.join(ICN_DIR, 'loft.png')
    __initargs__ = ["profiles"]

    #: list of curves. Limit: 9 curves.
    #: :type: collections.Sequence[parapy.geom.Curve]
    profiles = Input()

    #: tolerance
    #: :type: float
    tolerance = Input(1.0e-4)

    #: optional 2D tolerance
    #: :type: float
    tolerance_2d = Input(derived)

    #: min degree
    #: :type: int
    min_degree = Input(1)

    #: max degree in v direction
    #: :type: int
    max_degree = Input(25, validator=Range(1, 25))

    #: Set to true if the surface is closed in the U direction
    #: :type: bool
    is_u_periodic = Input(False)

    #: Set to true if the surface is closed in the V direction
    #: :type: bool
    is_v_periodic = Input(False)

    #: continuity of surface
    #: :type: int
    continuity = Input(2)

    #: if False, seems to not fit surface through curves for larger number of
    #: curves. Consequences on performance or results unknown at this stage.
    #: :type: bool
    SpApprox = Input(True)

    # NbMaxP = Input(1)

    #: :type: bool
    knownP = Attribute(False)

    #: :type: int
    aNbIt = Attribute(0)

    def _get_tolerance_2d(self):
        """Get the parametric tolerance in the 2D space of this curve.

        :rtype: float
        """
        return Precision__Parametric(self.tolerance)

    @Attribute
    def _AppSurf(self):
        """The approximated BSpline surface through :attr:`profiles`.

        :rtype: OCC.GeomFill.GeomFill_AppSurf
        :raises Exception: if the lofting operation failed.
        """
        aSecGenerator = GeomFill_SectionGenerator()
        for profile in self.profiles:
            aSecGenerator.AddCurve(profile.Handle_Geom_Curve)
        aSecGenerator.Perform(Precision__PConfusion())
        aLine = GeomFill_Line(len(self.profiles))
        anAlgo = GeomFill_AppSurf(self.min_degree, self.max_degree,
                                  self.tolerance, self.tolerance_2d,
                                  self.aNbIt)  # , self.knownP)
        continuity = self.continuity * 2
        anAlgo.SetContinuity(continuity)
        anAlgo.Perform(aLine.handle, aSecGenerator)  # , self.SpApprox)
        if anAlgo.IsDone():
            return anAlgo
        else:
            raise Exception("lofting failed")

    @Attribute(private=True)
    def Handle_Geom_Surface(self):
        """The handle to the the BSplineSurface Geometry.

        :rtype: OCC.Geom.Handle_Geom_BSplineSurface
        """
        anAlgo = self._AppSurf
        surf = Geom_BSplineSurface(anAlgo.SurfPoles(), anAlgo.SurfWeights(),
                                   anAlgo.SurfUKnots(), anAlgo.SurfVKnots(),
                                   anAlgo.SurfUMults(), anAlgo.SurfVMults(),
                                   anAlgo.UDegree(), anAlgo.VDegree(),
                                   self.is_u_periodic, self.is_v_periodic)
        return surf.handle

    @Attribute
    def error(self):
        """The achieved tolerances during the loft operation.

        :returns: [tol3d, tol2d]
        :rtype: list[float, float]
        """
        return self._AppSurf.TolReached()


# TODO: combine inputs / attributes into an mixin class called LoftAPI
class LoftedShell(_SweptShell):
    """Create a shell through various :attr:`profiles`. The first and last
    point input may be a point. If you need guides, use PipeSolid.

    Usage:

    >>> from parapy.geom import XOY, Circle, LoftedShell
    >>> crv1 = Circle(radius=1.0, position=XOY)
    >>> crv2 = Circle(radius=2.0, position=XOY.translate('z', 5))
    >>> crv3 = Circle(radius=1.0, position=XOY.translate('z', 10))
    >>> obj = LoftedShell(profiles=[crv1, crv2, crv3])
    """
    __icon__ = os.path.join(ICN_DIR, 'loft.png')
    __initargs__ = ["profiles"]

    #: list of curves/wires. First and Last inputs may be points.
    #: :type: collections.Sequence[parapy.geom.Point | parapy.geom.Curve]
    profiles = Input()

    #: prevents twisted results by recomputing origin and orientation on wires.
    #: Wires are updated in order to have same number of edges.
    #: :type: bool
    check_compatibility = Input(False)

    #: the precision criterion used by the approximation algorithm; the
    #: default value is 1.0e-6.
    #: :type: float
    tolerance = Input(1.0e-6)

    #: Maximal U degree of surface
    #: :type: int
    max_degree = Input(3, validator=Optional(Range(1, 25)))

    #: optional generation of ruled surfaces out of edges of two
    #: consecutive wires if True. Default is smoothing
    # by approximation.
    #: :type: bool
    ruled = Input(derived)

    #: different approximation algorithm
    #: :type: bool
    smoothing = Input(False)

    #: Continuity used in approximation.
    #: :type: int
    continuity = Input(2)

    #: Type of parameterization used in approximation.
    #: 0 = Approx_ChordLength
    #: 1 = Approx_Centripetal
    #: 2 = Approx_IsoParametric
    #: :type: int
    parameterization = Input(0, validator=Range(0, 2))

    make_solid = False

    _continuity = [GeomAbs.GeomAbs_C0,
                   GeomAbs.GeomAbs_C1,
                   GeomAbs.GeomAbs_C2,
                   GeomAbs.GeomAbs_CN,
                   GeomAbs.GeomAbs_G1,
                   GeomAbs.GeomAbs_G2,
                   GeomAbs.GeomAbs_C3]

    _parameterization = [Approx.Approx_ChordLength,
                         Approx.Approx_Centripetal,
                         Approx.Approx_IsoParametric]

    def _get_ruled(self):
        """Set to true if the faces generated between
        the edges of two consecutive wires are ruled surfaces or to
        false (the default value) if they are smoothed out by approximation

        :rtype: bool
        """
        return True if len(self.profiles) == 2 else False

    @Attribute
    def builder(self):
        """The builder object undert this LoftedShell.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_ThruSections
        """
        # TODO: Check construction success & translate errors
        builder = BRepOffsetAPI_ThruSections()
        builder.CheckCompatibility(self.check_compatibility)
        max_degree = self.max_degree
        if max_degree is not None:
            builder.SetMaxDegree(max_degree)
        builder.SetSmoothing(self.smoothing)
        builder.SetContinuity(self._continuity[self.continuity])
        builder.SetParType(self._parameterization[self.parameterization])

        builder.Init(self.make_solid, self.ruled, self.tolerance)
        for object in self.profiles:
            if hasattr(object, "TopoDS_Vertex"):
                builder.AddVertex(object.TopoDS_Vertex)
            else:
                builder.AddWire(object.TopoDS_Wire)
        builder.Build()
        if not builder.IsDone():
            raise Exception("BRepOffsetAPI_ThruSections failed")
        return builder


class LoftedSolid(_SweptSolid):
    """Create a solid through various profiles. If you need guides, use
    PipeSolid.

    Usage:

    >>> from parapy.geom import XOY, Circle, LoftedSolid
    >>> crv1 = Circle(radius=1.0, position=XOY)
    >>> crv2 = Circle(radius=2.0, position=XOY.translate('z', 5))
    >>> crv3 = Circle(radius=1.0, position=XOY.translate('z', 10))
    >>> obj = LoftedSolid(profiles=[crv1, crv2, crv3])
    """

    __icon__ = os.path.join(ICN_DIR, 'loft.png')
    __initargs__ = ["profiles"]

    #: list of curves/wires. First and Last inputs may be points.
    #: :type: collections.Sequence[parapy.geom.Curve | parapy.geom.Wire]
    profiles = Input()

    #: if you set this to ``False``, you only get an open shell.
    #: :type: bool
    make_solid = Input(True)

    #: prevents twisted results by recomputing origin and orientation on
    #: wires. Wires are updated in order to have same number of edges.
    #: :type: bool
    check_compatibility = Input(False)

    #: tolerance
    #: :type: float
    tolerance = Input(1.0e-6)

    #: Maximal U degree of surface
    #: :type: int
    max_degree = Input(3, validator=Optional(Range(1, 25)))

    #: generation of ruled surfaces out of edges of consecutive
    #: wires if True. Default is smoothing by approximation.
    #: :type: bool
    ruled = Input(derived)

    #: Different approximation algorithm. Be careful as it may consume a lot
    #: of memory.
    #: :type: bool
    smoothing = Input(False)

    #: C-continuity used in approximation. For example, specify 0 for
    #: C0-continuous lofting.
    #: :type: int
    continuity = Input(2)

    #: Type of parameterization used in approximation.
    #: 0 = Approx_ChordLength
    #: 1 = Approx_Centripetal
    #: 2 = Approx_IsoParametric
    #: :type: int
    parameterization = Input(0, validator=Range(0, 2))

    _continuity = [GeomAbs.GeomAbs_C0,
                   GeomAbs.GeomAbs_C1,
                   GeomAbs.GeomAbs_C2,
                   GeomAbs.GeomAbs_CN,
                   GeomAbs.GeomAbs_G1,
                   GeomAbs.GeomAbs_G2,
                   GeomAbs.GeomAbs_C3]

    _parameterization = [Approx.Approx_ChordLength,
                         Approx.Approx_Centripetal,
                         Approx.Approx_IsoParametric]

    @ruled.getter
    def ruled(self):
        """Set to true if the faces generated between
        the edges of two consecutive wires are ruled surfaces or to
        false (the default value) if they are smoothed out by approximation

        :rtype: bool
        """
        return True if len(self.profiles) == 2 else False

    @Attribute
    def builder(self):
        """The builder of this LoftedSolid.

        :rtype: OCC.BRepOffsetAPI.BRepOffsetAPI_ThruSections
        """
        # TODO: Check construction success & translate errors
        profiles = self.profiles
        builder = BRepOffsetAPI_ThruSections()
        builder.Init(self.make_solid, self.ruled, self.tolerance)
        builder.CheckCompatibility(True if self.check_compatibility else False)
        max_degree = self.max_degree
        if not max_degree is None:
            builder.SetMaxDegree(max_degree)
        builder.SetSmoothing(self.smoothing)
        builder.SetContinuity(self._continuity[self.continuity])
        builder.SetParType(self._parameterization[self.parameterization])

        idxn = len(profiles) - 1
        for i, obj in enumerate(profiles):
            if hasattr(type(obj), "TopoDS_Vertex"):
                if i == 0 or i == idxn:
                    builder.AddVertex(obj.TopoDS_Vertex)
                else:
                    msg = ("Only first and/or last profile can be punctual. "
                           "Found punctual input for profile {}.")
                    raise RuntimeError(msg.format(i))
            else:
                builder.AddWire(obj.TopoDS_Wire)
        builder.Build()
        if not builder.IsDone():
            raise RuntimeError("BRepOffsetAPI_ThruSections failed")
        return builder


if __name__ == '__main__':
    from parapy.gui import display

    from parapy.geom import Point, Circle, FittedCurve, XOY

    # LoftedSurface
    pts1 = [Point(0, 0, 0), Point(11, 2, 0), Point(15, 0, 0),
            Point(11, -1, 0), Point(3, -1, 0), Point(0, 0, 0)]
    pts2 = [Point(0, 0, 5), Point(13, 2, 5), Point(15, 0, 5),
            Point(13, -2, 5), Point(3, -2, 5), Point(0, 0, 5)]
    crv1 = FittedCurve(points=pts1)
    crv2 = FittedCurve(points=pts2)
    surf = LoftedSurface(profiles=[crv1, crv2], color="blue")

    # LoftedShell
    crv1 = Circle(radius=1.0, position=XOY)
    crv2 = Circle(radius=2.0, position=XOY.translate('z', 5))
    crv3 = Circle(radius=1.0, position=XOY.translate('z', 10))
    shell = LoftedShell(profiles=[crv1, crv2, crv3])

    # LoftedSolid
    crv1 = Circle(radius=1.0, position=XOY)
    crv2 = Circle(radius=2.0, position=XOY.translate('z', 5))
    crv3 = Circle(radius=1.0, position=XOY.translate('z', 10))
    solid = LoftedSolid(profiles=[crv1, crv2, crv3])

    display((surf, shell, solid))

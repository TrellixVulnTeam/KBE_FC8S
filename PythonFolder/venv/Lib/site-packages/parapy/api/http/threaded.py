#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""
enables you to server the |ParaPy| server in a different thread
any do other stuff.
"""

import time
import multiprocessing as mp
from parapy.api.http import main


def create_initial_instance(app, iid, module, klass):
    """is pickable for threading"""
    import importlib

    mod = importlib.import_module(module)
    klass = getattr(mod, klass)
    instance = klass()
    app.add_instance(**{iid: instance})


# def timed_while(predicate, timeout, sleep_interval=1):
#     count = 0
#     while predicate() and \
#             (not timeout or count * sleep_interval < timeout):
#         count += 1
#         time.sleep(sleep_interval)


def app_run(before_run=None, before_run_args=[], before_run_kwargs={}, **kwargs):
    """Pickable function for mp.

    :param before_run: callabe with at least one positional arg.
        first arg accepts main.app.
    :param before_run_args:
    :param before_run_kwargs:
    :param kwargs:
    """
    if before_run:
        before_run(main.app, *before_run_args, **before_run_kwargs)
    main.app.run(**kwargs)


def threaded_app(*args, **kwargs):
    """returns thread where app will live in"""
    return mp.Process(target=app_run, args=args, kwargs=kwargs)


def _app_run_with_timeout(timeout, sleep_interval=0.1, **kwargs):
    """
    Will block the **main** thread for max ``timeout`` seconds unless the
    server app is shutdown in between. Will spawn the |ParaPy| server in a
    different thread using multiprocessing

    :param timeout: time-out in seconds.
    :param sleep_interval: updating interval for checking server status
    :param kwargs: app.run() parameters.
    """

    print("app timeout set to {:}s".format(timeout))

    server_thread = threaded_app(**kwargs)
    server_thread.start()

    count = 0
    while server_thread.is_alive() and \
            (not timeout or count * sleep_interval < timeout):
        count += 1
        time.sleep(sleep_interval)

    if server_thread.is_alive():
        print("server reached timeout limit of {:}s".format(timeout))
        server_thread.terminate()
        server_thread.join()
        return True
    else:
        print("server was shut down")
        server_thread.terminate()
        server_thread.join()
        return False


app = main.app

# monkey-patch app here
app.run_with_timeout = _app_run_with_timeout


if __name__ == '__main__':

    mp.freeze_support()

    ###########################################################################
    # new run_with_timeout function
    ##########################################################################

    # running server with timeout of 2s
    app.run_with_timeout(timeout=2, port=80)

    ###########################################################################
    # basic threaded server
    ###########################################################################

    # running threaded server and shutting down in main thread
    server_thread = threaded_app(port=80)
    server_thread.start()

    # main code
    import urllib.request, urllib.error, urllib.parse
    time.sleep(2)
    url = "http://{:}:{:}/shutdown".format(main.default_host, main.default_port)
    urllib.request.urlopen(url).read()

    # be careful, thread is not immediately finished
    time.sleep(0.2)
    assert not server_thread.is_alive(), "something went wrong?"

    server_thread.terminate()
    server_thread.join()

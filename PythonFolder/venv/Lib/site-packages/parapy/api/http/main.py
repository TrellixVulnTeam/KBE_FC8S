#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""
Welcome to the RESTFul HTTP Server of |ParaPy|. This server enables other
programs to create, modify or delete |ParaPy| instances over the web. It is the
enabler of proven interfaces to Matlab (check out the package
``examples.api.http.matlab``) and
`Optimus <http://www.noesissolutions.com/Noesis/>`__
(see ``examples.api.optimus``).

If you didn't already, you need to install three dependencies: `flask <http://flask.pocoo.org/>`__,
`flask-restful <https://flask-restful.readthedocs.org>`__ and
`flask-restful-swagger <https://github.com/rantav/flask-restful-swagger>`__.
In a cmd prompt, type::

    >>> pip install flask
    >>> pip install flask-restful
    >>> pip install flask-restful-swagger

To start the main server and test it, simply run this file

Now visit http://127.0.0.1:80/ in your browser and confirm that you get::

    Welcome to the RESTful ParaPy Server! Visit this documentation for a
    complete overview of the API
"""

# built-in modules
import configparser
import importlib
import os
from ast import literal_eval
from urllib.parse import parse_qsl, urlparse

try:
    from flask import Flask, request, jsonify, Response
    from flask.json import JSONEncoder, loads as json_loads
    from flask_restful import Resource, reqparse, Api, abort
    from flask_restful_swagger import swagger

except ImportError as e:
    raise Exception(
        "Couldn't import one or multiple flask (extension) modules. It's a required "
        "dependency for the ParaPy server. Make sure you've installed all missing "
        "components and they are visible in your PYTHONPATH\n"
        "Message: {:}\n"
        "Solution:\n"
        "   pip install flask\n"
        "   pip install flask-restful\n"
        "   pip install flask-restful-swagger\n"
            .format(e))

from parapy.core.abstractbase import AbstractBase
from parapy.core import getslot as core_getslot, setslot as core_setslot, \
    delslot as core_delslot
from parapy.api.http.swagger_types import *
from parapy.api.http.exceptions import *

CONVERSION_ERROR = "ConversionError: couldn't convert value. Consider specifying type (and register a converter in the back-end)."

# ===============================================================================
# Configuration Settings
# ===============================================================================
config = configparser.ConfigParser()
config.read(os.path.join(os.path.dirname(os.path.abspath(__file__)),
                         "configuration.cnf"))
default_host = config.get("server", "host")
default_port = int(config.get("server", "port"))


class ParaPyFlask(Flask):
    """Specialisation of :py:class:`flask.Flask` that adds several |ParaPy|-
    specific methods.
    """

    #: (dict) dictionary of |ParaPy| instances created through this server
    instances = {}

    #: (dict) dictionary of ``value`` conversion functions. Each key-value pair
    #: defines a converter accessed by name, and pointing to a function
    #: that takes a (string) value and converts it to the desired |ParaPy|
    #: object.
    converters = {"str": str, "eval": literal_eval, "int": int, "float": float}

    #: (callable) function that is invoked when server is shutdown
    # on_shutdown = None

    def __init__(self, *args, **kwargs):
        super(ParaPyFlask, self).__init__(*args, **kwargs)
        self.instances = {}

    def add_instance(self, **kwargs):
        """Add an Base instance to server for Restful interaction
        It allows the user to create an instance inside the scripting
        environment. This is an alternative to creating things through the
        Restful API.

        :param kwargs: sequence of ``str`` - :py:class:`~parapy.core.Base`
            instance pairs. Format::

                {<iid>: <obj>, ...)

        The corresponding HTTP request to achieve this over the web is::

            PUT /instances/<iid>?module=<module>&class=<class>
        """
        for key, value in kwargs.items():
            self.instances[key] = value

    def delete_instance(self, iid):
        """Delete an instance with key ``iid`` from the server

        :param str iid: valid key inside ``app.instances``.

        The corresponding HTTP request to achieve this over the web is::

            DELETE /instances/<iid>
        """
        # TODO: should this method throw error if user tries to delete non-existing instance?
        # TODO: is instance gc'ed?
        self.instances.pop(iid, None)

    def delete_instances(self):
        """Delete **all** instances previously created from the sever.
        The corresponding HTTP request to achieve this over the web is::

            DELETE /instances
        """
        # TODO: are instances gc'ed?
        for key in list(app.instances.keys()):
            self.delete_instance(key)


class ParaPyJSONEncoder(JSONEncoder):
    """Enables JSONifying Base instances"""

    def default(self, obj):
        if isinstance(obj, AbstractBase):
            return {"name": obj.label or repr(obj),
                    "class": type(obj).__name__,
                    "module": obj.__module__,
                    "id": str(id(obj))}
        else:
            try:
                return JSONEncoder.default(self, obj)
            except TypeError:
                return repr(obj)

# ===============================================================================
# Server instance and api
# ===============================================================================

#: The Flask server object. As a :py:class:`~parapy.api.http.main.ParaPyFlask`
#: instance, it has several extra methods over basic :py:class:`flask.Flask`
#: instances. Start server:
#:
#: >>> app.run(port=80, host=127.0.0.1)
#:  * Running on http://127.0.0.1:80/ (Press CTRL+C to quit)

app = ParaPyFlask(__name__)

app.json_encoder = ParaPyJSONEncoder
api = swagger.docs(Api(app, catch_all_404s=True),
                   apiVersion='0.0',
                   basePath='http://localhost:80',
                   resourcePath='/',
                   produces=["application/json", "text/html"],
                   api_spec_url='/api/spec',
                   description='ParaPy RESTful web server')

# ===============================================================================
# Request handlers
# ===============================================================================


class Welcome(Resource):
    """Basic Welcome"""

    @swagger.operation(
        notes='Basic welcome message',
        responseMessages=[
            {
                "code": 200,
                "message": "Server is online"
            }
        ]
    )
    def get(self):
        """Basic welcome"""
        msg = ("Welcome to the RESTful ParaPy Server!"
               # " Visit this <a href='api/spec.html'>documentation</a> "
               # "for a complete overview of the API"
               )
        return Response(msg, mimetype='text/html')


class Instances(Resource):
    """Get an overview of all instances or delete them.

    url: /instances
    """

    @swagger.operation(
        notes='Get list of all ParaPy objects created on the server.',
        responseMessages=[{"code": 200, "message": "Success"}])
    def get(self):
        """
        Get list of all ParaPy objects created on the server.
        :returns: JSON
        """
        return jsonify(app.instances)

    @swagger.operation(
        notes='Delete all ParaPy instances created on the server.',
        responseMessages=[{"code": 204, "message": "Success"}])
    def delete(self):
        """
        Delete all objects previously stored on the server.
        :returns: JSON
        """
        app.delete_instances()
        return '', 204


class Instance(Resource):
    """
    Create a new instance, delete an existing or get an overview of its slots.
    """

    parser = reqparse.RequestParser()
    parser.add_argument('module',
                        type=str,
                        required=True,
                        help='Missing module argument: Name of module where '
                             'class object resides')
    parser.add_argument('class',
                        type=str,
                        required=True,
                        help='Missing class argument: name of the class to be '
                             'instantiated')
    parser.add_argument('arguments',
                        type=dict,
                        action='append',
                        required=False,
                        help='Missing class argument: name of the class to be '
                             'instantiated')

    @swagger.operation()
    def get(self, iid):
        """Get information about a ParaPy object.

        :param str iid: unique identifier of instance in server
        :return: json
        :raises: InstanceNotFound
        """
        instance = get_instance(iid)
        return jsonify(get_slots(instance))

    @swagger.operation( \
            parameters=[
                {
                    "name": "iid",
                    "description": "The ID of the to-be created object",
                    "required": True,
                    "allowMultiple": False,
                    "dataType": 'string',
                    "paramType": "path",
                    "defaultValue": "aircraft"
                },
                {
                    "name": "payload",
                    "description": "JSON data with 'class', 'module' and optionally key inputs.",
                    "required": True,
                    "allowMultiple": False,
                    "dataType": InstancePutBody.__name__,
                    "paramType": "body",
                    "defaultValue": InstancePutBody.default
                },
            ])
    def put(self, iid):
        """create a new instance with iid. Optionally with initial
        keyword arguments in URL or in JSON payload.

        Payload example::

            {"arguments":
                 [{"key": "width", "value": 1, "type": "float"},
                  {"key": "length", "value": 2, "type": "float"},
                  {"key": "height", "value": 3, "type": "float"},
                  {"key": "color", "value": "red", "type": "str"}]}

        arguments
            iid(str)
        
        URL parameters:
            module(str)
            class(str)
            keys(json)

        BEWARE: only provide top-level keys for construction

        returns: 
            204
        """

        # TODO: add check to not overwrite existing iid
        # TODO: catch constructor error with keys that are not allowed.

        args = self.parser.parse_args()
        module = args['module']
        klass = args['class']
        arguments = args.get('arguments')

        # argument can be part of the url as well.
        if not arguments:
            arguments = parse_key_value_type(request.url)

        arglist = {}
        if arguments:
            for argument in arguments:
                key = str(argument["key"])  # unicode will break Base __init__.
                value = argument["value"]
                Type = argument.get("type")
                value = convert_value(value, Type)
                arglist[key] = value

        # try to resolve from
        Module = importlib.import_module(module)
        Class = getattr(Module, klass)
        instance = Class(**arglist)
        app.instances[iid] = instance
        return '', 204

    @swagger.operation()
    def delete(self, iid):
        """Delete an instance with iid.
        
        URL arguments:
            iid (str): iid of instance
            
        returns: 
            204
            
        TODO: should this method throw error if user tries to delete non-existing instance?            
        """

        app.delete_instance(iid)
        return '', 204


class Slot(Resource):
    """
    Get, set or delete (reset) a single slot
    """

    parser = reqparse.RequestParser()
    parser.add_argument('value', type=str, required=True,
                        help='Missing value argument: new value of slot')
    parser.add_argument('type', type=str, required=False,
                        help='type argument points to Python type converter (optional)')

    @swagger.operation()
    def get(self, iid, key):
        """
        get slot value.
        
        arguments:
            iid(str): iid of instance
            key(str): period-separated attr reference
        
        raises
            InstanceNotFound
            SlotEvaluationError

        returns: 
            JSON
        """
        instance = get_instance(iid)
        return getslot(instance, str(key), iid)

    @swagger.operation()
    def put(self, iid, key):
        """
        set slot value. key can be a reference chain with dots.
        
        arguments:
            iid(str): iid of instance
            key(str): period-separated slot reference
            value(any): value of slot
            type(str): target type for conversion (optional)

        raises
            InstanceNotFound
            SlotEvaluationError
            TypeNotFound

        returns: 
            204 response
        """
        args = self.parser.parse_args()

        instance = get_instance(iid)
        value = args['value']
        Type = args.get('type')
        value = convert_value(value, Type)
        setslot(instance, key, value, iid)
        return '', 204

    @swagger.operation()
    def delete(self, iid, key):
        """
        reset slot value. key can be a reference chain with dots.
        
        arguments:
            iid(str): iid of instance
            key(str): period-separated slot reference     

        raises
            InstanceNotFound
            SlotEvaluationError
        
        returns: 
            204 response
        """
        instance = get_instance(iid)
        delslot(instance, key, iid)
        return '', 204


class Slots(Resource):
    """
    Get, set or delete (reset) multiple slots simultaneously
    """

    parser = reqparse.RequestParser()
    parser.add_argument('key',
                        type=str,
                        required=True,
                        help='missing key argument: key references a slot (repeatable)',
                        action='append')

    put_parser = reqparse.RequestParser()
    put_parser.add_argument('arguments',
                            type=dict,
                            action='append',
                            required=False,
                            help='Missing class argument: name of the class to '
                                 'be instantiated')

    @swagger.operation()
    def get(self, iid):
        """
        get multiple slot value. Slot can be a reference chain with dots.

        arguments:
            iid(str): iid of instance

        url parameters
            key(str): period-separated slot reference (multiple allowed)     

        raises
            InstanceNotFound

        returns: 
            JSON
        """
        instance = get_instance(iid)
        args = self.parser.parse_args()
        key = args['key']
        # JSON can be {"key": "width"}
        keys = [key] if isinstance(key, str) else key

        result = []
        for key in keys:
            dct = {'key': key, 'value': None}
            try:
                dct['value'] = getslot(instance, str(key), iid)
            except SlotEvaluationError as e:
                # FIXME: remove forward compatibility with patch in WebGUI project.
                dct['exception'] = e.payload

            result.append(dct)

        return jsonify(result)

    @swagger.operation()
    def post(self, iid):
        """
        Same at :py:meth:`~Slots.get`, but enables JSON payload (not allowed in GET)
        BEWARE: set ``Content-Type: application/json`` on your request.

        Payload format::

            {"key" : ["width", "length", "height"]}
        """
        return self.get(iid)

    @swagger.operation()
    def put(self, iid):
        """
        set slot values. key can be a reference chain with dots.
        BEWARE: set Content-Type: application/json on your request.
        
        arguments:
            iid (str): iid of instance               

        Payload format::
            {"arguments":
                 [{"key": "width", "value": 1, "type": "float"},
                  {"key": "length", "value": 2, "type": "float"},
                  {"key": "height", "value": 3, "type": "float"},
                  {"key": "color", "value": "red", "type": "str"}]}

        OR:
        
        url parameters
            key(str): period-separated slot reference (multiple allowed)          
            value(any): value of slot (multiple allowed) 
            type(str): target type for conversion (optional) (multiple allowed)
            
            BEWARE: order of slots is important, read as repetitions of key=<key>&value=<value>&type=<type>

        raises
            InstanceNotFound
            ParaPyServerError: {
                                code=500
                                message='Not all slots could be '
                                        'set. See exceptions for '
                                        'details.',
                                exceptions=[{'key': key, 'value': None,
                                             'type': Type, 'exception': e}]
                                }
        
        returns: 
            204 response
        """

        instance = get_instance(iid)

        args = self.put_parser.parse_args()
        arguments = args.get('arguments')

        # argument can be part of the url as well.
        if not arguments:
            arguments = parse_key_value_type(request.url)

        exceptions = []

        if arguments:
            for argument in arguments:
                key = str(argument["key"])  # unicode will break Base __init__.
                value = argument["value"]
                Type = argument.get("type")

                exception_dct = {'key': key, 'value': None, 'type': Type,
                                 'exception': None}

                try:
                    value = convert_value(value, Type)
                except ValueError:
                    exception_dct['exception'] = CONVERSION_ERROR
                    exceptions.append(exception_dct)
                    continue
                except TypeNotFound as e:
                    # FIXME: remove forward compatibility with patch in WebGUI project.
                    exception_dct['exception'] = e.payload
                    exceptions.append(exception_dct)
                    continue

                try:
                    setslot(instance, key, value, iid)
                except SlotEvaluationError as e:
                    # FIXME: remove forward compatibility with patch in WebGUI project.
                    exception_dct['exception'] = e.payload
                    exceptions.append(exception_dct)

        if not exceptions:  # All slots are set.
            return '', 204
        else:  # Exceptions occurred.
            raise ParaPyServerError(code=500,
                                    message='Not all slots could be '
                                            'set. See exceptions for '
                                            'details.',
                                    exceptions=exceptions  # Add exceptions
                                    # to Error payload.
                                    )

    @swagger.operation()
    def delete(self, iid):
        """
        reset slot values. key can be a reference chain with dots.
        
        arguments:
            iid (str): iid of instance
            key (str): dot-separated message key(s)

        raises
            InstanceNotFound
            ParaPyServerError: {
                                code=500
                                message='Not all slots could be '
                                            'deleted. See exceptions for '
                                            'details.',
                                exceptions=[{'key': key, 'exception': e}]
                                }
        
        returns: 
            204 response
        """

        instance = get_instance(iid)
        args = self.parser.parse_args()
        keys = args['key']

        exceptions = []

        for key in keys:
            try:
                delslot(instance, key, iid)
            except SlotEvaluationError as e:
                # FIXME: remove forward compatabilty with patch in WebGUI project.
                exceptions.append({'key': key, 'exception': e.payload})

        if not exceptions:  # All slots are deleted.
            return '', 204
        else:  # Exceptions occurred.
            raise ParaPyServerError(code=500,
                                    message='Not all slots could be '
                                            'deleted. See exceptions for '
                                            'details.',
                                    exceptions=exceptions  # Add exceptions
                                    # to Error payload.
                                    )


class ShutDown(Resource):
    def get(self):
        shutdown_server()
        return 'Server shutting down...'

    post = get


# ==================================================================================================
# Register request handlers
# ==================================================================================================
api.add_resource(Welcome, '/', '/welcome')
api.add_resource(ShutDown, '/shutdown')
api.add_resource(Instances, '/instances')
api.add_resource(Instance, '/instances/<iid>')
api.add_resource(Slot, '/instances/<iid>/slot/<key>')
api.add_resource(Slots, '/instances/<iid>/slots')


#===============================================================================
# Utilities
#===============================================================================

def shutdown_server():
    """Shutdown running WerkZeug server"""
    func = request.environ.get('werkzeug.server.shutdown')
    if func is None:
        raise RuntimeError('Not running with the Werkzeug Server')
    func()
    # if app.on_shutdown:
    #    app.on_shutdown()


def is_json(request):
    """New utility to check if an incoming request has json mimetype.
    :param request: incoming Request object.
    :rtype: bool
    """
    # TODO: from version 0.11 this becomes obsolete
    # TODO: adding this functions as method to Request class gives error
    return 'Content-Type' in request.headers and \
           request.headers['Content-Type'] in (
               "application/json", "application/*+json")


def add_type_converter(type_str, fn):
    """
    Adds a type converter to this module. Can be used for json conversion.

    arguments
        type_str(str): names a new type, e.g. "mytype"
        fn(lambda): a function taking one str input and returning some converted object. Raise TypeError if necessary.

    Example
       add_type_converter("myfloat", lambda str: float(str))

    """
    app.converters[type_str] = fn


def convert_value(value, Type=None):
    """Converts request ``value`` to specific type using ``Type``. If
    ``Type is None``, ``json.loads(str(value))`` defines the outcome.

    :param value: the value to convert
    :param Type: valid type specifier, e.g. 'float' or 'literal_eval'.
    :type Type: None | str
    :return: converted value
    """
    if Type:
        try:
            f = app.converters[Type]
        except KeyError:
            try:
                f = getattr(__builtin__, Type)
            except KeyError:
                raise TypeNotFound(
                    "type spec {:} does not name a valid converter".format(
                        Type))
        return f(value)
    else:
        return json_loads(str(value))


def get_request_args(resource, request):
    if is_json(request):
        try:
            return request.get_json()
        except:
            raise BadJSON()
    else:
        return resource.parser.parse_args()


def parse_key_value_type(url):
    """
    parses query string part of url. Converts numeric value if possible.
    format of request part::

        ?key=<key>&value=<value>[&type=<type>]&...

    :param url: the url string
    :type url: request.url
    :returns: [{'key': str, 'value': object[, 'type'=str]}, ...]
    :rtype: list
    """

    tup = parse_qsl(urlparse(url)[4])

    result = []
    current_key = None
    for key, value in tup:
        key = str(key)
        if key == 'key':
            current_key = str(value)
        elif key == 'value':
            result.append({"key": current_key, 'value': value})
        elif key == 'type':
            result[-1]['type'] = str(value)

    return result


def get_instance(iid):
    """Tries to retrieve ParaPy instance from server given ``iid``.
    :param str iid: unique identifier of instance in server
    :rtype: parapy.core.Base
    :raises: InstanceNotFound
    """

    try:
        return app.instances[iid]
    except KeyError:
        raise InstanceNotFound(iid=iid)


def getslot(obj, attr, iid):
    """parapy.core.getslot wrapped in try ... except block.
    :param obj: ParaPy instance
    :param str attr: reference chain to ParaPy slot
    :param str iid: unique identifier of instance in server
    :return: Anything
    :raises SlotEvaluationError
    """
    try:
        return core_getslot(obj, attr)
    except Exception as e:
        raise SlotEvaluationError(instance=obj, iid=iid, slot=attr,
                                  exception=e)


def setslot(obj, attr, value, iid):
    """parapy.core.getslot wrapped in try ... except block.
    :param obj: ParaPy instance
    :param str attr: reference chain to ParaPy slot
    :param value: the value to which ``attr`` will be bound
    :param str iid: unique identifier of instance in server
    :raises SlotEvaluationError
    """
    try:
        return core_setslot(obj, attr, value)
    except Exception as e:
        raise SlotEvaluationError(instance=obj, iid=iid, slot=attr,
                                  value=value, exception=e)


def delslot(obj, attr, iid):
    """parapy.core.getslot wrapped in try ... except block.
    :param obj: ParaPy instance
    :param str attr: reference chain to ParaPy slot
    :param str iid: unique identifier of instance in server
    :raises SlotEvaluationError
    """
    try:
        return core_delslot(obj, attr)
    except Exception as e:
        raise SlotEvaluationError(instance=obj, iid=iid, slot=attr,
                                  exception=e)


def get_slots(obj):
    """
    Returns data for \instances\<iid>\slots GET request.
    :param obj: ParaPy instance
    :rtype: dict
    """

    result = {}

    for slot, cache in obj.__cache__.items():
        key = slot.__name__
        result[key] = {"value": cache.value,
                       "slot_type": type(slot).__name__}

    return result


if __name__ == "__main__":

    # app.run(port=default_port, host=default_host)
    app.run(port=default_port, host=default_host)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2014-2016 Reinier van Dijk
#
# This code is subject to a Non-Disclosure Agreement. You have received a
# temporary copy of the ParaPy software for non-commercial, educational
# purposes only.
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
from math import cos, pi

from parapy.geom import Point
from parapy.lib.cst.globs import DAT_DIR


# from: http://stackoverflow.com/questions/3025162/statistics-combinations-in-python
def comb(n, k):
    """The number of combinations of ``n`` things taken ``k`` at a time, also
    known as "n choose k".

    >>> from parapy.lib.cst.utils import comb
    >>> comb(10, 3)
    120

    :param int n: number of things
    :param int k: number of elements taken
    :rtype: int
    """
    if 0 <= k <= n:
        ntok = 1
        ktok = 1
        for t in range(1, min(k, n - k) + 1):
            ntok *= n
            ktok *= t
            n -= 1
        return ntok // ktok
    else:
        return 0


def cst_to_points(coefficients, n, n1=0.5, n2=1.0, chord=1.0):
    """Convert CST ``coefficients`` to a list of ``n`` Points, ordered LE to TE.

    :param coefficients: surface coefficients
    :type coefficients: collections.Sequence[float]
    :param int n: number of points
    :param float n1: first exponent to "Class Function".
    :param float n2: second exponent to "Class Function".
    :param float chord: distance from LE to TE.
    :return: [Point_1, Point_2, ... Point_n]
    :rtype: list[Point]
    """
    x_lst = [1 - cos(pi / 2 * x / (n - 1)) for x in range(n - 1)] + [1]
    p_lst = [x ** n1 * (1 - x) ** n2 for x in x_lst]
    y_lst = [0] * len(x_lst)
    nw = len(coefficients)
    for i in range(nw):
        s_lst = [comb(nw - 1, i) * x ** i * (1 - x) ** (nw - 1 - i)
                 for x in x_lst]
        y_lst = [y + s * coefficients[i] for y, s in zip(y_lst, s_lst)]
    return [Point(chord * x, chord * p * y, 0)
            for x, y, p in zip(x_lst, y_lst, p_lst)]


def points_to_cst(points, n, normalize=False, tol=1.0e-6, routine='MATLAB'):
    """Return ``n`` CST coefficients for given ``points``. A legacy Matlab
    routine can be used under the bonnet, for which you need to install
    matlab.engine. Otherwise, you will need to import the numpy and scipy
    site-packages. These routines expects a *normalized* set of x, y
    coordinates. Either set ``normalize=True``, or make sure that that
    ``points`` have x-coordinates that range 0-1 and are increasing. See also
    :func:`normalized_points`.

    .. note: its generally recommended to use n >= 5 for convergence.

    Matlab q3d function signature::

        function coefficients = points_to_cst(points, n)
        coefficients = f(points, n);

    :param points: sequence of Points on airfoil (in XY plane).
    :type points: collections.Sequence[Point]
    :param int n: desired number of CST coefficients.
    :param bool normalize: do you want this function to normalize your points?
    :param float tol: numeric tolerance for normalization.
    :param str routine: choose between MATLAB or SCIPY.
    :returns: [c1, c2, ... cn]
    :rtype: list[float]
    :raises RuntimeError: if matlab.engine module couldn't be imported, or if
        your points don't seem to be normalized correctly.
    """
    # TODO: working directory switch?
    # names = matlab.engine.find_matlab()
    # if names:
    #     # connect to shared Matlab
    #     name = names[0]
    #     eng = matlab.engine.connect_matlab(name)
    #     close = False
    # else:

    if routine == 'MATLAB':
        try:
            import matlab.engine
        except ImportError:
            msg = ("Didn't find matlab.engine module. Make sure you have "
                   "installed the MATLAB Engine for Python. Refer to readme.rst "
                   "for instructions.")
            raise RuntimeError(msg)
        check = 0
        run_check = 0  # counter for breaking in case of infinite loop
        while check == 0 and run_check < 10:
            try:
                eng = matlab.engine.connect_matlab()
                check = 1
            except:
                print("Waiting for previous matlab engine to close")
                import time
                time.sleep(5.5)    # pause 5.5 seconds
                pass
            run_check += 1
        # eng = matlab.engine.connect_matlab()
        # close = True

        if normalize:
            points = normalized_points(points, tol)
        else:
            pt1, ptn = points[0], points[-1]
            if pt1[0] > ptn[0]:
                logging.warning("reversing points as first x bigger than last x")
                points = points[::-1]
                pt1, ptn = ptn, pt1
            x1, y1, xn = pt1[0], pt1[1], ptn[0]
            s = 1 / (xn - x1)

            if abs(x1) > tol or abs(xn - 1) > tol or abs(1 - s) > tol:
                msg = ("x values are not in range [0-1]. Normalize your points, "
                       "consider using normalize=True. Provided range: [{:}-{:}].")
                raise RuntimeError(msg.format(x1, xn))

        Xu_in = matlab.double(tuple(pt[0] for pt in points))
        Yu_in = matlab.double(tuple(pt[1] for pt in points))
        # sets the directory for matlab run
        eng.addpath(DAT_DIR, nargout=0)
        print("Running .m file '{:}\{:}'.".format(DAT_DIR, "points_to_cst.m"))
        ret = eng.points_to_cst(Xu_in, Yu_in, n, nargout=2)

        # disconnect if must
        #if close:
        #    eng.quit()
        cst_coefficients = list(ret[0][0])

    elif routine == "SCIPY":
        from numpy import ones, zeros
        from scipy.optimize import minimize
        #: definition of optimization parameters
        #: initial value of design vector x
        #: :type: ndarray[float]
        x0 = zeros(n)

        #: upper and lower bound of vector x
        #: :type: ndarray[float]
        lb = -2*ones(n)

        #: upper bound of vector x
        #: :type: ndarray[float]
        ub = 2*ones(n)

        #: list of bounds used in fmin_slsqp
        #: :type: list[tuple]
        bounds = list(zip(lb,ub))

        #: optimization using sequential least squares algorithm
        res = minimize(fun=CST_objective, x0=x0, args=(points), method='SLSQP', bounds=bounds)

        #: minimizer of objective function; cst_coefficients
        cst_coefficients = res.x

    return cst_coefficients


def CST_objective(x, points, n1=0.5, n2=1.0):
    """Objective function used for determining CST coefficients, returns error
    between actual curve and fitted curve. Python implementation of
    Class-Shape Transformation (CST) method by Kulfan.

    :param: x: design vector
    :type: ndarray[float]
    :param: points: normalized coordinates of curve to be fitted with CST coefficients
    :type: ndarray[Point]
    :param: n1: 1st coefficient for Class function
    :type: float
    :param: n2: 2nd coefficient for Class function
    :type: float
    :returns: error
    :rtype: float
    """

    #: List of x-coordinates of input points
    #: :type: list[float]
    zeta = [pt.x for pt in points]

    #: List of y-coordinates of input points
    #: :type: list[float]
    y_in = [pt.y for pt in points]

    #: List of Class function at input x-coordinate
    #: :type: list[float]
    c_lst = [z ** n1 * (1 - z) ** n2 for z in zeta]

    #: Initial value for Shape function
    #: :type: list[float]
    s_lst = [0] * len(zeta)

    #: For-loop to calculate Shape function value based on CST-method with x
    #: being the design vector
    nw = len(x)
    for i in range(nw):
        s_i = [comb(nw - 1, i) * z ** i * (1 - z) ** (nw - 1 - i) for z in zeta]
        s_lst = [s0 + s * x[i] for s0, s in zip(s_lst, s_i)]

    #: create final y-coordinate list
    #: :type: list[float]
    y_out = [s * c for s, c in zip(s_lst, c_lst)]

    #: Least squares error on y-coordinates, used as objective function value
    #: :type: float
    error = sum([(y - y_cst)**2 for y, y_cst in zip(y_in, y_out)])

    return error


def normalized_points(points, tol=1.0e-6):
    """Normalize sequence of Points: x-increasing, start point anchored at
    (0, 0) and scaled x-range from 0-1. Returns 3d Points.

    >>> pts = [Point(-1, 10), Point(0.5, 10.5), Point(1, 10)]
    >>> normalized_points(pts)
    [Point(0.0, 0.0, 0), Point(0.75, 0.25, 0), Point(1.0, 0.0, 0)]

    :param points: sequence of points, e.g. ``[Point(0, 0, 0), Point(2, 0, 0)]``
    :type points: collections.Sequence[Point]
    :param float tol: numeric tolerance
    :rtype: list[Point]
    """

    result = points

    # reversed?
    pt1, ptn = points[0], points[-1]
    if pt1[0] > ptn[0]:
        logging.warning("reversing points as first x bigger than last x")
        result = reversed(result)
        pt1, ptn = ptn, pt1

    # move to (0, 0)?
    x1, y1, xn = pt1[0], pt1[1], ptn[0]
    if abs(x1) > tol or abs(y1) > tol:
        result = ((pt[0]-x1, pt[1]-y1) for pt in result)

    # scale?
    s = 1 / (xn - x1)
    if abs(1 - s) > tol:
        result = ((pt[0]*s, pt[1]*s) for pt in result)

    if result is not points:
        # we have an iterator
        return [Point(*args) for args in result]
    else:
        return list(points)


if __name__ == '__main__':
    print(comb(10, 2))

    pts = ((0, 0), (0.5, 0.5), (1, 0))
    result = normalized_points(pts)
    assert result == [(0, 0), (0.5, 0.5), (1, 0)]

    pts = ((-1, 0), (0.5, 0.5), (1, 0))
    result = normalized_points(pts)
    assert result == [Point(0.0, 0.0), Point(0.75, 0.25), Point(1.0, 0.0)]

    pts = ((-1, 10), (0.5, 10.5), (1, 10))
    result = normalized_points(pts)
    assert result == [Point(0.0, 0.0), Point(0.75, 0.25), Point(1.0, 0.0)]

    pts = ((1, 10), (0.5, 10.5), (-1, 10))
    result = normalized_points(pts)
    assert result == [Point(0.0, 0.0), Point(0.75, 0.25), Point(1.0, 0.0)]

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
from math import atan, cos, pi, sin, sqrt
from operator import itemgetter

from OCC.wrapper.GeomLProp import GeomLProp_CLProps

__all__ = ["naca4_points"]


def linspace(start, stop, n):
    """Yield ``n`` values between ``start`` and ``stop`` with linear spacing.

    :param float start: start value
    :param float stop: end value
    :param int n: number of points
    :rtype: collections.Iterable[float]
    """
    step = (stop - start) / (n - 1.)
    current = start
    yield current
    for _ in range(n - 2):
        current += step
        yield current
    yield stop


def cosspace(start, stop, n, theta1=0, theta2=0.5 * pi):
    """Yield ``n`` values between ``start`` and ``stop`` with cosine spacing:
    ``|| |  |   |    |     |``.

    :param float start: start value
    :param float stop: end value
    :param int n: number of points
    :param float theta1: start angle in radians (``0`` by default).
    :param float theta2: end angle in radians (``1/2 * pi`` by default).
    :rtype: collections.Iterable[float]
    """
    step_theta = (theta2 - theta1) / (n - 1.)
    dtheta = cos(theta1) - cos(theta2)
    dlength = stop - start
    yield start
    theta = theta1
    for _ in range(n - 2):
        theta += step_theta
        yield start + (cos(theta1) - cos(theta)) / dtheta * dlength
    yield stop


def naca4_points(s, n, sampling="linear", sharp_te=True):
    """Return ``n`` xy coordinates for camber, upper and lower lines of a
    NACA 4-digit airfoil. Sampling of xc-coordinates is either ``'linear'``
    (default) or ``'cosine'`` between 0 and 1. Airfoil will be closed by
    default (``sharp_te=True``), but can also be open. Usage:

    >>> naca4_points("0012", 50)
    ([(0.0, 0.0), ...],
     [(0.0, 0.0), ...],
     [(0.0, 0.0), ...],
    )

    :param str s: NACA string, e.g. "0012".
    :param int n: number of points per side.
    :param str sampling: "linear" or "cosine".
    :param bool sharp_te: closed TE or not?
    :returns: (xy_camber, xy_upper, xy_lower)
    :rtype: (list[(float, float)], list[(float, float)], list[(float, float)])
    """
    m = int(s[0]) / 100.
    p = int(s[1]) / 10.
    t = int(s[2:4]) / 100.

    # do sanity check on inputs
    if m == 0 and p != 0:
        msg = ("Airfoil with camber (m = 0), should have p = 0. Found p = {}. "
               "Forcing p = 0.")
        logging.warning(msg.format(p))
        p = 0
    elif m != 0 and p == 0:
        msg = "Maximum camber position can not be 0. Received p = {}."
        raise RuntimeError(msg.format(p))
    if t == 0:
        msg = "Impossible to have zero-thickness airfoil."
        raise RuntimeError(msg)

    c0 = 0.2969
    c1 = -0.1260
    c2 = -0.3516
    c3 = 0.2843
    if sharp_te:
        c4 = -0.1036
    else:
        c4 = -0.1015

    # make x-spacing
    if sampling == "linear":
        xgen = linspace(0, 1, n)
    elif sampling == "cosine":
        xgen = cosspace(0, 1, n)
    else:
        msg = "sampling is either 'linear' or 'cosine', not {}"
        raise RuntimeError(msg.format(repr(sampling)))

    lst_c, lst_u, lst_l = [], [], []
    for xc in xgen:
        yt = 5 * t * (c0 * sqrt(xc) +
                      c1 * xc +
                      c2 * xc ** 2 +
                      c3 * xc ** 3 +
                      c4 * xc ** 4)
        # zero camber
        if m == 0:
            yc = 0
            xu, yu = xc, yt
            xl, yl = xc, -yt
        else:
            if xc <= p:
                yc = m / p ** 2 * (2 * p * xc - xc ** 2)
                dycdx = 2 * m / p ** 2 * (p - xc)
            else:
                yc = m / (1 - p) ** 2 * ((1 - 2 * p) + 2 * p * xc - xc ** 2)
                dycdx = 2 * m / (1 - p) ** 2 * (p - xc)
            theta = atan(dycdx)
            xu, yu = xc - yt * sin(theta), yc + yt * cos(theta)
            xl, yl = xc + yt * sin(theta), yc - yt * cos(theta)
        lst_c.append((xc, yc))
        lst_u.append((xu, yu))
        lst_l.append((xl, yl))
    return lst_c, lst_u, lst_l


def airfoil_le_parameter(curve, sample=25, sweeps=4, precision=1.0e-7):
    """Return parameter of LE point on ``curve``. By default, it will do 4
    consecutive ``sweeps`` with a ``sample`` size of 25 to walk to the point
    with maximum curvature.

    >>> # some airfoil curve
    >>> airfoil = FittedCure(points=[pt1, pt2, ...])
    >>> airfoil_le_parameter(airfoil)
    0.5

    :param parapy.geom.occ.curve.Curve curve: airfoil curve
    :param int sample: number of sample points per sweep
    :param int sweeps: number of sweeps
    :param float precision: resolution for GeomLProp_CLProps
    :rtype: float
    """
    props = GeomLProp_CLProps(curve.Handle_Geom_Curve, 2, precision)

    u1, u2 = curve.u1, curve.u2

    for _ in range(sweeps):
        lst = []
        for u in linspace(u1, u2, sample):
            props.SetParameter(u)
            r = props.D2().Magnitude()
            lst.append((r, u))

        elt = max(lst, key=itemgetter(0))
        idx = lst.index(elt)

        if idx == 0 or idx == sample - 1:
            return elt[0]

        u1 = lst[idx - 1][1]
        u2 = lst[idx + 1][1]

    elt = max(lst, key=itemgetter(0))
    return elt[1]

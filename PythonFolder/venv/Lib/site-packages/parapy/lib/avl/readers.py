#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines AVL read utilities"""
import logging
import os
import re
from collections import OrderedDict

from parapy.geom import Point

__all__ = ["read_surface_forces", "read_strip_forces", "read_element_forces",
           "read_af_file"]

_FN_HEADER1 = ["n", "Area", "CL", "CD", "Cm", "CY", "Cn", "Cl", "CDi", "CDv"]
_FN_HEADER2 = ["n", "Ssurf", "Cave", "cl", "cd", "cdv", "cm_LE"]
_FS_HEADER = ["j", "Yle", "Chord", "Area", "c cl", "ai", "cl_norm", "cl", "cd",
              "cdv", "cm_c/4", "cm_LE", "C.P.x/c"]
_FE_HEADER = ["I", "X", "Y", "Z", "DX", "Slope", "dCp"]
_FN_LOCATIONS1 = (2, 12, 20, 28, 36, 44, 52, 60, 68, 76)
_FN_LOCATIONS2 = (4, 14, 24, 33, 42, 51, 60)

_FS_REGEX1 = r"Surface #\s*(\d+)\s*(.*)"
_FS_REGEX1 = re.compile(_FS_REGEX1)
_FE_REGEX1 = (r"Strip #\s*(\d+)\s*"
              r"# Chordwise\s*=\s*(\d+)\s*"
              r"First Vortex\s*=\s*(\d+)")
_FE_REGEX1 = re.compile(_FE_REGEX1)


class AVLFormatError(Exception):
    def __init__(self, *args, **kwargs):
        super(AVLFormatError, self).__init__(*args, **kwargs)


class PPOrderedDict(OrderedDict):
    __repr__ = dict.__repr__


def read_number(s, bag, fn=float):
    try:
        return fn(s)
    except ValueError as e:
        if all(c == "*" for c in s.strip()):
            bag[0] += 1
            return None
        else:
            raise e


def split_locations(s, locations):
    """Split line at fixed locations

    >>> s = ' 1 ********* -0.2456  0.0000******** -0.0000 -0.0000133.9692  0.0000  0.0000   Main Wing'
    >>> split_locations(s, (2, 12, 20, 28, 36, 44, 52, 60, 68, 76))
    [' 1', ' *********', ' -0.2456', '  0.0000', '********', ' -0.0000', ' -0.0000', '133.9692', '  0.0000', '  0.0000', '   Main Wing']
    >>> s = '   1   531.692    10.502   0.2078   0.0032   0.0000   0.0000  Wing'
    >>> split_locations(s, (4, 14, 24, 33, 42, 51, 60))
    ['   1', '   531.692', '    10.502', '   0.2078', '   0.0032', '   0.0000', '   0.0000', '  Wing']
    """
    lst = []
    i = 0
    for j in locations:
        lst.append(s[i:j])
        i = j
    lst.append(s[i:])
    return lst


#     Xle =**********    Ave. Chord   = 5686.7773   Incidence  =    0.0000 deg
def split_equal_signs(s):
    tokens = s.split("=")
    first_name = tokens.pop(0).strip()
    last_value = tokens.pop(-1).strip()
    names = [first_name]
    values = []
    for token in tokens:
        temp = token.split()
        value = temp[0].strip()
        name = " ".join(temp[1:]).strip()
        names.append(name)
        values.append(value)
    values.append(last_value)
    return names, values


def read_surface_forces(filename):
    """Return dict with surfaces forces from an AVL .fs output file. Usage:

    >>> read_surface_forces("path/to/your/forces.fn")
    {'Bref': 113.0,
     'Cref': 1260.0,
     'Sref': 11.0,
     'Xref': 0.0,
     'Yref': 60.0,
     'Zref': 0.0,
     'surfaces': {'Wing': {'Area': 531.692,
                           'CD': 0.0013,
                           'CDi': 0.0013,
                           'CDv': 0.0,
                           'CL': 0.0875,
                           'CY': -0.0062,
                           'Cave': 10.502,
                           'Cl': -0.0209,
                           'Cm': -0.0545,
                           'Cn': 0.0006,
                           'Ssurf': 531.692,
                           'cd': 0.0032,
                           'cdv': 0.0,
                           'cl': 0.2078,
                           'cm_LE': 0.0,
                           'n': 1},
                # more surfaces ...
                }
    }
    """
    bag = [0]
    dct = {}
    dct["surfaces"] = dct_surfaces = PPOrderedDict()

    with open(filename) as f:
        # skip 4 lines
        for _ in range(4):
            next(f)
        # Sref =   1260.       Cref =   11.0000   Bref =  113.0000
        # Xref =     60.0000   Yref =    0.0000   Zref =    0.0000
        for _ in range(2):
            line = next(f)
            keys, values = split_equal_signs(line)
            for k, v in zip(keys, values):
                dct[k] = read_number(v, bag, float)

        next(f)
        next(f)

        line = next(f)
        while line and not line.isspace():
            values = split_locations(line, _FN_LOCATIONS1)
            name = values.pop().strip()
            dct_surfaces[name] = dct_surface = PPOrderedDict()
            for k, v in zip(_FN_HEADER1, values):
                dct_surface[k] = read_number(v, bag, float)
            line = next(f)

        # skip 3 lines
        next(f)
        next(f)
        next(f)

        line = next(f)
        while not line.startswith(" -"):
            values = split_locations(line, _FN_LOCATIONS2)
            name = values.pop().strip()
            dct_surface = dct_surfaces[name]
            for k, v in zip(_FN_HEADER2, values):
                dct_surface[k] = read_number(v, bag, float)
            # hack to correct float -> int
            dct_surface["n"] = int(dct_surface["n"])
            line = next(f)

    if bag[0]:
        filename = os.path.abspath(filename)
        count = bag[0]
        msg = ("Large integer ('********') found in avl output file '{}'. "
               "Found {:} ocurrence{:}. Consider scaling geometry or using "
               "different reference values for normalizing.")
        logging.warning(msg.format(filename, count, 's' if count > 1 else ''))

    return dct


def read_strip_forces(filename):
    """Return dict with surfaces forces from an AVL .fs output file. Usage:

    >>> read_strip_forces("path/to/your/forces.fs")
    {'Wing': {'# Chordwise': 26,
              '# Spanwise': 12,
              'Ave. chord': 10.502089,
              'CDisurf': 0.00134,
              'CDsurf': 0.00134,
              'CDvsurf': 0.0,
              'CLsurf': 0.08746,
              'CYsurf': -0.00619,
              'Clsurf': -0.02093,
              'Cmsurf': -0.05449,
              'Cnsurf': 0.00059,
              'First strip': 1,
              'Surface area': 531.691528,
              'id': 1,
              'strips': {1: {'Area': 3.4703,
                             'C.P.x/c': 0.509,
                             'Chord': 20.9725,
                             'Yle': 6.0412,
                             'ai': 0.1822,
                             'c cl': 0.3895,
                             'cd': 0.0007,
                             'cdv': 0.0,
                             'cl': 0.0186,
                             'cl_norm': 0.0248,
                             'cm_LE': -0.0087,
                             'cm_c/4': -0.0048,
                             'j': 1},
                         # more strips ...
                         }
              },
     # more surfaces ...
     }
    """
    bag = [0]
    dct = PPOrderedDict()

    with open(filename) as f:
        for line in f:
            if "Surface #" in line:
                matches = _FS_REGEX1.search(line)
                id_srf, name = matches.groups()
                id_srf = read_number(id_srf, bag, int)
                name = name.strip()
                dct[name] = dct_srf = PPOrderedDict()
                dct_srf["id"] = id_srf

                # walk over 11 lines
                lines = []
                cnt = 1
                for line in f:
                    lines.append(line)
                    if cnt == 11:
                        break
                    cnt += 1

                # Chordwise = 10   # Spanwise =  5     First strip =  1
                line = lines[0]
                (k1, k2, k3), (v1, v2, v3) = split_equal_signs(line)
                dct_srf[k1] = read_number(v1, bag, int)
                dct_srf[k2] = read_number(v2, bag, int)
                dct_srf[k3] = read_number(v3, bag, int)

                for i in range(1, 6):
                    line = lines[i]
                    (k1, k2), (v1, v2) = split_equal_signs(line)
                    dct_srf[k1] = read_number(v1, bag, float)
                    dct_srf[k2] = read_number(v2, bag, float)

                dct_strips = PPOrderedDict()
                dct_srf["strips"] = dct_strips

            if "C.P.x/c" in line:
                for line in f:
                    if len(line) > 65:
                        data = line.split()
                        j = read_number(data[0], bag, int)
                        dct_strips[j] = {k: read_number(v, bag, float) for
                                         k, v in zip(_FS_HEADER, data)}
                        # hack: convert float to int here
                        dct_strips[j]["j"] = j
                    else:
                        break

    if bag[0]:
        filename = os.path.abspath(filename)
        count = bag[0]
        msg = ("Large integer ('********') found in avl output file '{}'. "
               "Found {:} ocurrence{:}. Consider scaling geometry or using "
               "different reference values for normalizing.")
        logging.warning(msg.format(filename, count, 's' if count > 1 else ''))

    return dct


def read_element_forces(filename):
    """Return dict with element forces from an AVL .fe output file:

    >>> read_element_forces("path/to/your/forces.fe")
    {'Wing': {'# Chordwise': 26,
              '# Spanwise': 12,
              'Ave. chord': 10.502089,
              'CDisurf': 0.00134,
              'CDsurf': 0.00134,
              'CDvsurf': 0.0,
              'CLsurf': 0.08746,
              'CYsurf': -0.00619,
              'Clsurf': -0.02093,
              'Cmsurf': -0.05449,
              'Cnsurf': 0.00059,
              'First strip': 1,
              'Surface area': 531.691528,
              'id': 1,
              'strips': {1: {'# Chordwise': 12,
                             'Ave. Chord': 49.48284,
                             'First Vortex': 1,
                             'Incidence': 4.9551,
                             'Strip Area': 3.470294,
                             'Strip Dihed.': 5.9941,
                             'Strip Width': 6.04118,
                             'Xle': 20.9725,
                             'Yle': 0.16547,
                             'Zle': 0.00432,
                             'ca': 0.00074,
                             'cd': 0.01857,
                             'cdv': 0.0,
                             'cl': 0.00074,
                             'cm c/4': -0.00481,
                             'cmLE': -0.00873,
                             'cn': 0.3895,
                             'cnc': 0.01857,
                             'elements': {1: {'DX': 0.51323,
                                              'I': 1,
                                              'Slope': 0.03551,
                                              'X': 49.54829,
                                              'Y': 6.08228,
                                              'Z': 0.00864,
                                              'dCp': 0.11822},
                                          # more elements ...
                                          }
                             },
                         # more strips ...
                         }
              },
     # more surfaces ...
     }
    """
    bag = [0]
    dct = PPOrderedDict()
    with open(filename) as f:
        for line in f:
            if "Surface #" in line:
                matches = _FS_REGEX1.search(line)
                id_srf, name = matches.groups()
                id_srf = read_number(id_srf, bag, int)
                name = name.strip()
                dct[name] = dct_srf = PPOrderedDict()
                dct_srf["id"] = id_srf

                # walk over 11 lines
                lines = []
                cnt = 1
                for line in f:
                    lines.append(line)
                    if cnt == 11:
                        break
                    cnt += 1

                # Chordwise = 10   # Spanwise =  5     First strip =  1
                line = lines[0]
                (k1, k2, k3), (v1, v2, v3) = split_equal_signs(line)
                dct_srf[k1] = read_number(v1, bag, int)
                dct_srf[k2] = read_number(v2, bag, int)
                dct_srf[k3] = read_number(v3, bag, int)

                for i in range(1, 6):
                    line = lines[i]
                    (k1, k2), (v1, v2) = split_equal_signs(line)
                    dct_srf[k1] = read_number(v1, bag, float)
                    dct_srf[k2] = read_number(v2, bag, float)

                dct_strips = PPOrderedDict()
                dct_srf["strips"] = dct_strips

            # Strip #  1     # Chordwise = 10   First Vortex =   1
            if "Strip #" in line:
                matches = _FE_REGEX1.search(line)
                id_strip, n_chordwise, first_vortex = matches.groups()
                id_strip = read_number(id_strip, bag, int)
                n_chordwise = read_number(n_chordwise, bag, int)
                first_vortex = read_number(first_vortex, bag, int)
                dct_strips[id_strip] = dct_strip = PPOrderedDict()
                dct_strip["# Chordwise"] = n_chordwise
                dct_strip["First Vortex"] = first_vortex

                # walk over 8 lines
                lines = []
                cnt = 1
                for line in f:
                    lines.append(line)
                    if cnt == 8:
                        break
                    cnt += 1

                for i, line in enumerate(lines):
                    if i == 3 or i == 7:  # empty line
                        continue
                    keys, values = split_equal_signs(line)
                    if i == 0:
                        values[-1] = values[-1].rstrip(" deg")

                    for key, value in zip(keys, values):
                        dct_strip[key] = read_number(value, bag, float)

                dct_elms = PPOrderedDict()
                dct_strip["elements"] = dct_elms

            if "dCp" in line:
                for line in f:
                    # walk lines until there is a much shorter line (end of element data lines)
                    if len(line) > 65:
                        data = line.split()
                        i = read_number(data[0], bag, int)
                        dct_elms[i] = {k: read_number(v, bag, float) for
                                       k, v in zip(_FE_HEADER, data)}
                        # hack: convert float to int here
                        dct_elms[i]["I"] = i
                    else:
                        break

    if bag[0]:
        filename = os.path.abspath(filename)
        count = bag[0]
        msg = ("Large integer ('********') found in avl output file '{}'. "
               "Found {:} ocurrence{:}. Consider scaling geometry or using "
               "different reference values for normalizing.")
        logging.warning(msg.format(filename, count, 's' if count > 1 else ''))

    return dct


def read_af_file(filename):
    """Read provided airfoil file and return coordinates as points.

    :rtype: list[parapy.geom.Point]
    """
    lst = []
    with open(filename) as f:
        next(f)
        for line in f:
            x, y = line.split()
            lst.append(Point(float(x), float(y), 0))
    return lst

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Defines AVL primitives"""

# --- ABBREVIATIONS ---
#
# af = airfoil
# pt = point
# pts = points
# vec = vector
# n = number
# a = angle
# vars = variables
# msg = message
# c = chord(wise)
# s = span(wise)
# b = body(wise)
# ref = reference


import math
import os
import subprocess
import sys
from time import sleep

from parapy.core import *
from parapy.geom import *
from parapy.gui.globs import ICN_DIR as ICN_DIR_GUI

from parapy.lib.avl import find_avl_executable
from parapy.lib.avl.airfoil import airfoil_le_parameter, cosspace, naca4_points
from parapy.lib.avl.readers import (
    read_af_file, read_element_forces, read_strip_forces, read_surface_forces)

__all__ = ["Interface", "MassProperties", "RunCase", "Geometry",
           "Surface", "AirfoilSection", "AirfoilCurveSection", "Section"]

TIMEOUT = 10

ANTI_SYMMETRIC = -1
NOT_SYMMETRIC = 0
SYMMETRIC = 1

SPACING_LINEAR = 0
SPACING_COSINE = 1
SPACING_SINE = 2
SPACING_INV_SINE = -2

MODIFIABLE_ATTRS = {"V": "velocity", "D": "density"}

ICN_DIR = os.path.join(os.path.dirname(__file__), "icons", "")


class AVLBase(Base):
    """Base class for all AVL primitives."""

    def write(self, f=sys.stdout):
        return NotImplementedError()


class Interface(Base):
    """Interface class writing to, executing, and reading from AVL. You have
    to specify a base :attr:`filename` (excluding an extension) for all files
    written to and from AVL , e.g. :py:`"mysession"`. Files will be placed in
    the current working directory, unless :attr:`directory` is given.
    Moreover, you have to specify :attr:`geometry`, an instance of
    :class:`Geometry`. You can request AVL to generate various outputs by
    defining :attr:`outputs`, a list of extensions. Valid extensions are:
    :py:`["fn", "fs", "fe", "ft", "fb", "hm", "vm"]`. If :attr:`log` is True,
    a .log file is created containing all commands send from |ParaPy| to
    avl.exe.

    This exposes three slots to automatically extract force results.

    1. :attr:`surface_forces`: force info on surface level
    2. :attr:`strip_forces`: force info on surface strip level
    3. :attr:`element_forces`: force info on surface strip element level

    Demanding their values will automatically take care of executing AVL.

    Usage:

    >>> intf = Interface(filename="b737",
    ...                  directory="output",
    ...                  geometry=geom,
    ...                  outputs=["fn", "fs", "fe"]),  # ["ft", "fb", "hm", "vm"]
    >>> intf.surface_forces
    {'Bref': 113.0,
     'Cref': 1260.0,
     'Sref': 11.0,
     'Xre': 0.0,
     'Yref': 60.0,
     'Zref': 0.0,
     'surfaces': {'Wing': {'Area': 531.692,
                           'CD': 0.0013,
                           'CDi': 0.0013,
                           'CDv': 0.0,
                           'CL': 0.0875,
                           'CY': -0.0062,
                           'Cave': 10.502,
                           'Cl': -0.0209,
                           'Cm': -0.0545,
                           'Cn': 0.0006,
                           'Ssurf': 531.692,
                           'cd': 0.0032,
                           'cdv': 0.0,
                           'cl': 0.2078,
                           'cm_LE': 0.0,
                           'n': 1},
                  # more surfaces ...
                  }
    }
    """

    __icon__ = os.path.join(ICN_DIR, "interface.png")

    #: base filename for all files, excluding extension.
    #: :type: str
    filename = Input()
    #: directory for all output files generated. Defaults to ".", i.e. the
    #: current working directory.
    #: :type: str
    directory = Input(".")
    #: geometry to be considered.
    #: :type: parapy.lib.avl.Geometry
    geometry = Input(in_tree=True)
    #: list of requested output files. Valid options are:
    #:
    #: - :py:`"FT"`: total forces
    #: - :py:`"FN"`: surface forces
    #: - :py:`"FS"`: strip forces
    #: - :py:`"FE"`: element forces
    #: - :py:`"FB"`: body forces
    #: - :py:`"HM"`: hinge moments
    #: - :py:`"VM"`: strip shear, moment
    #:
    #: :type: list[str]
    outputs = Input([])
    #: by default, output of AVL console will be sent to Python console. If
    #: you want to suppress the output, set to True.
    #:
    #: .. note:: keep at False if you set ``close_when_done`` to False.
    silent = Input(False)
    #: close avl automatically when done? If False, avl interface remains open.
    #: user is in charge to *quit* AVL. Typical session (visualize geometry):
    #:
    #: >>> G
    #: >>> <ENTER>
    #: >>> q
    #:
    #: .. note:: only possible, if :attr:`silent` is False.
    #:
    #: :type: bool
    close_when_done = Input(True)
    #: by default, AVL will overwrite your previous output files, if present.
    #: options include: 'append', 'overwrite' and 'cancel'.
    #: :type: str
    if_exists = Input("overwrite", validator=val.OneOf(
        ['overwrite', 'append', 'cancel']))
    #: create .log file with all commands send to avl
    #: :type: bool
    log = Input(True)
    #: list of the run cases to be considered.
    # .. attention:: support only one run case at a time.
    #: :type: list[parapy.lib.avl.RunCase]
    run_cases = Input([])
    #: optional mass properties associated with the provided geometry.
    #: :type: parapy.lib.avl.MassProperties | None
    mass_properties = Input(None)

    @Attribute
    def surface_forces(self):
        """Dict with surface force results from an AVL .fn output file::

            {'Bref': 113.0,
             'Cref': 1260.0,
             'Sref': 11.0,
             'Xref': 0.0,
             'Yref': 60.0,
             'Zref': 0.0,
             'surfaces': {'Wing': {'Area': 531.692,
                                   'CD': 0.0013,
                                   'CDi': 0.0013,
                                   'CDv': 0.0,
                                   'CL': 0.0875,
                                   'CY': -0.0062,
                                   'Cave': 10.502,
                                   'Cl': -0.0209,
                                   'Cm': -0.0545,
                                   'Cn': 0.0006,
                                   'Ssurf': 531.692,
                                   'cd': 0.0032,
                                   'cdv': 0.0,
                                   'cl': 0.2078,
                                   'cm_LE': 0.0,
                                   'n': 1},
                          # more surfaces ...
                          }
             }

        :rtype: dict[str, T]
        """
        self._has_written  # establish dependency
        self._has_run  # establish dependency

        base_filename = self.filename
        directory = os.path.abspath(self.directory)

        filename = os.path.abspath(
            os.path.join(directory, base_filename + ".fn"))
        if not os.path.exists(filename):
            msg = ("No .fn file found at '{:}'. Make sure you've included "
                   "'fn' as a member of 'outputs'.")
            raise RuntimeError(msg.format(filename))
        else:
            print("Reading: '{}'".format(filename))
            dct = read_surface_forces(filename)
            return dct

    @Attribute
    def strip_forces(self):
        """Dict with strip force results from an AVL .fs output file::

            {'Wing': {'# Chordwise': 26,
                      '# Spanwise': 12,
                      'Ave. chord': 10.502089,
                      'CDisurf': 0.00134,
                      'CDsurf': 0.00134,
                      'CDvsurf': 0.0,
                      'CLsurf': 0.08746,
                      'CYsurf': -0.00619,
                      'Clsurf': -0.02093,
                      'Cmsurf': -0.05449,
                      'Cnsurf': 0.00059,
                      'First strip': 1,
                      'Surface area': 531.691528,
                      'id': 1,
                      'strips': {1: {'Area': 3.4703,
                                     'C.P.x/c': 0.509,
                                     'Chord': 20.9725,
                                     'Yle': 6.0412,
                                     'ai': 0.1822,
                                     'c cl': 0.3895,
                                     'cd': 0.0007,
                                     'cdv': 0.0,
                                     'cl': 0.0186,
                                     'cl_norm': 0.0248,
                                     'cm_LE': -0.0087,
                                     'cm_c/4': -0.0048,
                                     'j': 1},
                                 # more strips ...
                                 }
                      },
             # more surfaces ...
             }

        :rtype: dict[str, T]
        """
        self._has_written  # establish dependency
        self._has_run  # establish dependency

        base_filename = self.filename
        directory = os.path.abspath(self.directory)

        filename = os.path.abspath(
            os.path.join(directory, base_filename + ".fs"))
        if not os.path.exists(filename):
            msg = ("No .fs file found at '{:}'. Make sure you've included "
                   "'fs' as a member of 'outputs'.")
            raise RuntimeError(msg.format(filename))
        else:
            print("Reading: '{}'".format(filename))
            dct = read_strip_forces(filename)
            return dct

    @Attribute
    def element_forces(self):
        """Dict with element force results from an AVL .fe output file::

            {'Wing': {'# Chordwise': 26,
                      '# Spanwise': 12,
                      'Ave. chord': 10.502089,
                      'CDisurf': 0.00134,
                      'CDsurf': 0.00134,
                      'CDvsurf': 0.0,
                      'CLsurf': 0.08746,
                      'CYsurf': -0.00619,
                      'Clsurf': -0.02093,
                      'Cmsurf': -0.05449,
                      'Cnsurf': 0.00059,
                      'First strip': 1,
                      'Surface area': 531.691528,
                      'id': 1,
                      'strips': {1: {'# Chordwise': 12,
                                     'Ave. Chord': 49.48284,
                                     'First Vortex': 1,
                                     'Incidence': 4.9551,
                                     'Strip Area': 3.470294,
                                     'Strip Dihed.': 5.9941,
                                     'Strip Width': 6.04118,
                                     'Xle': 20.9725,
                                     'Yle': 0.16547,
                                     'Zle': 0.00432,
                                     'ca': 0.00074,
                                     'cd': 0.01857,
                                     'cdv': 0.0,
                                     'cl': 0.00074,
                                     'cm c/4': -0.00481,
                                     'cmLE': -0.00873,
                                     'cn': 0.3895,
                                     'cnc': 0.01857,
                                     'elements': {1: {'DX': 0.51323,
                                                      'I': 1,
                                                      'Slope': 0.03551,
                                                      'X': 49.54829,
                                                      'Y': 6.08228,
                                                      'Z': 0.00864,
                                                      'dCp': 0.11822},
                                                  # more elements ...
                                                  }
                                     },
                                 # more strips ...
                                 }
                      },
             # more surfaces ...
             }

        :rtype: dict[str, T]
        """
        self._has_written  # establish dependency
        self._has_run  # establish dependency

        base_filename = self.filename
        directory = os.path.abspath(self.directory)

        filename = os.path.abspath(
            os.path.join(directory, base_filename + ".fe"))
        if not os.path.exists(filename):
            msg = ("No .fe file found at '{:}'. Make sure you've included "
                   "'fe' as a member of 'outputs'.")
            raise RuntimeError(msg.format(filename))
        else:
            print("Reading: '{}'".format(filename))
            dct = read_element_forces(filename)
            return dct

    @Attribute
    def _has_written(self):
        # placeholder for status of a file. If user runs write() from GUI,
        # this slot's dependents will be invalidated.
        self.write(from_gui=False)
        return True

    @Attribute
    def _has_run(self):
        # placeholder for status of a file. If user runs run() from GUI,
        # this slot's dependents will be invalidated.
        self._has_written  # create dependency
        self.run(from_gui=False)
        return True

    @action(icon=os.path.join(ICN_DIR_GUI, "export.png"))
    def write(self, from_gui=True):
        """Write all of geometry, run case(s), and mass properties files."""
        base_filename = self.filename
        directory = os.path.abspath(self.directory)
        if not os.path.exists(directory):
            os.mkdir(directory)

        # Write geometry file
        filename = os.path.abspath(
            os.path.join(directory, base_filename + ".avl"))
        if not os.path.exists(filename) or not self.if_exists == "cancel":
            with open(filename, "w") as f:
                self.geometry.write(f)
            print("Written:", filename)

        # Write run case file(s)
        run_cases = self.run_cases
        if run_cases:
            for i, run_case in enumerate(run_cases, 1):
                filename = base_filename + "{}.run".format(i)
                if (not os.path.exists(filename)
                    or not self.if_exists == "cancel"):
                    with open(filename, "w") as f:
                        run_case.write(f)

        # Write mass properties file
        mass_properties = self.mass_properties
        if mass_properties:
            filename = base_filename + ".mass"
            if (not os.path.exists(filename)
                or not self.if_exists == "cancel"):
                with open(filename, "w") as stream:
                    mass_properties.write(stream)

        # invalidate forces
        if from_gui:
            self.get_cache("_has_written", eager=True)\
                .invalidate_dependents()

    @action(icon=os.path.join(ICN_DIR_GUI, "controls.png"))
    def run(self, from_gui=True):
        """Run AVL with the provided geometry and run-case."""
        self._has_written

        if self.silent:
            if not self.close_when_done:
                msg = ("If you want to interact with AVL "
                       "(close_when_done=True), silent should be False, not "
                       "True.")
                raise RuntimeError(msg)
            stdout = subprocess.PIPE
        else:
            stdout = sys.stdout

        app = self.__init_avl_interface(stdout)

        outputs = self.outputs

        if outputs:
            for output in outputs:
                app.generate_output(output)
            # last_file = os.path.join(os.path.abspath(self.directory),
            #                          self.filename + "." + outputs[-1])
            # t = 0
            # step = 0.01
            # while not os.path.exists(last_file) or os.stat(last_file).st_size == 0:
            #     if t > TIMEOUT:
            #         msg = "Output file '{}' wasn't created within {} seconds."
            #         raise RuntimeError(msg.format(last_file, TIMEOUT))
            #     sleep(step)
            #     t += step
            # if t > 0:
            #     print "WAITED {} seconds for last output file '{}'".format(t, last_file)

        if self.close_when_done:
            app.close_avl()
            app.close()
        else:
            import threading
            import queue

            def reading_task(queue):
                """Request raw input for as long as thread exists."""
                while True:
                    queue.put(input())

            input_queue = queue.Queue()

            thread = threading.Thread(target=reading_task, args=(input_queue,))
            thread.daemon = True
            thread.start()

            while app.poll() is None:
                if not input_queue.empty():
                    cmd = input_queue.get() + "\n"
                    app.stdin.write(cmd)
                    app.stdin.flush()
            app.close()
            thread.join(0)

        if self.log:
            filename = os.path.join(os.path.abspath(self.directory),
                                    self.filename + ".log")
            app.log_history(filename)

        # invalidate forces
        if from_gui:
            self.get_cache("_has_run", eager=True)\
                .invalidate_dependents()

    @action(label="Display AVL geometry and loads 10 seconds",
            icon=os.path.join(ICN_DIR_GUI, "inspect.gif"))
    def display_geometry(self):
        """Run AVL with the provided geometry and run-case."""
        self._has_written  # establish dependency
        if self.silent:
            stdout = subprocess.PIPE
        else:
            stdout = sys.stdout
        app = self.__init_avl_interface(stdout)
        app.command(["G", "LO"])
        sleep(10)
        app.close_avl()
        app.close()
        if self.log:
            filename = os.path.join(os.path.abspath(self.directory),
                                    self.filename + ".log")
            app.log_history(filename)

    def __open_avl_interface(self, stdout):
        """Start an instance of the avl application."""
        return _AVL(filename=self.filename,
                    executable=find_avl_executable(),
                    stdin=subprocess.PIPE,
                    stdout=stdout,
                    directory=self.directory,
                    if_exists=self.if_exists)

    def __init_avl_interface(self, stdout):
        geometry = self.geometry
        app = self.__open_avl_interface(stdout)
        app.load_geometry()
        app.oper()

        # flow settings
        mod = {}
        for k, attr in MODIFIABLE_ATTRS.items():
            value = getattr(geometry, attr)
            if value is not None:
                mod[k] = str(value)
        if mod:
            app.modify_parameters(**mod)
        app.execute()
        return app


class _AVL(subprocess.Popen):
    """Create Popen instance running AVL specifically."""

    def __init__(self, filename, executable=None, directory=".",
                 if_exists="cancel", *args, **kwargs):
        executable = executable or find_avl_executable()
        cmd = [executable]  # escaping now done by Python?
        # self._stdout = kwargs["stdout"]
        self.process = super(_AVL, self).__init__(cmd, *args, text=True,
                                                  **kwargs)  # cwd=CURRENT_DIR,
        #: filename under which to store the generated output, extension of the file is
        #: determined on the type of output requested.
        #: ATTENTION: directory + filename is limited to maximum 80 characters!
        self.filename = filename
        #: directory where to save the generated output under the specified filename.
        #: ATTENTION: directory + filename is limited to maximum 80 characters!
        self.directory = directory
        self.if_exists = if_exists
        self.history = []

    def log_history(self, filename):
        with open(filename, 'w') as f:
            for cmd in self.history:
                f.write(cmd)

    def command(self, cmds):
        """Send a (series of) command(s) to AVL and return to main screen."""
        stdin = self.stdin
        for cmd in cmds:
            cmd += "\n"
            stdin.write(cmd)
            stdin.flush()  # make sure the command is actually written
            self.history.append(cmd)

    def load_geometry(self):
        """Command AVL to load the geometry from the specified file."""
        filename = os.path.join(os.path.abspath(self.directory), self.filename + ".avl")
        cwd = os.path.abspath(os.getcwd())
        common_prefix = os.path.commonprefix([cwd, filename])
        filename_relative = os.path.relpath(filename, common_prefix)
        self.command(["LOAD " + filename_relative])

    def oper(self):
        self.command(["OPER"])

    # Parameters of run case 1/1:   -unnamed-
    #   B  bank      =  0.000      deg
    #   E  elevation =  0.000      deg
    #   MN Mach no.  =  0.000
    #   V  velocity  =  0.000      Lunit/Tunit
    #   D  air dens. =  1.000      Munit/Lunit^3
    #   G  grav.acc. =  1.000      Lunit/Tunit^2
    #   M  mass      =  1.000      Munit
    #   IX Ixx       =  1.000      Munit-Lunit^2
    #   IY Iyy       =  1.000      Munit-Lunit^2
    #   IZ Izz       =  1.000      Munit-Lunit^2
    #   X  X_cg      =  60.00      Lunit
    #   Y  Y_cg      =  0.000      Lunit
    #   Z  Z_cg      =  0.000      Lunit
    #   CD CDo       =  0.000
    #   LA dCL_a     =  0.000
    #   LU dCL_u     =  0.000
    #   MA dCM_a     =  0.000
    #   MU dCM_u     =  0.000
    def modify_parameters(self, **kwargs):
        self.command(["M"])
        for k, v in kwargs.items():
            self.command([k, v])
        self.command([""])

    def execute(self):
        self.command(["X"])

    def generate_output(self, output):
        """Generate requested output and save to specified directory."""
        filename = os.path.join(os.path.abspath(self.directory),
                                self.filename + "." + output)
        exists = os.path.exists(filename)
        if_exists = self.if_exists
        # remove file to overcome lagging behavior when reading.
        if exists and if_exists == "overwrite":
            os.remove(filename)

        cwd = os.path.abspath(os.getcwd())
        common_prefix = os.path.commonprefix([cwd, filename])
        filename_relative = os.path.relpath(filename, common_prefix)

        cmd = [output + " " + filename_relative]
        self.command(cmd)

        if exists and if_exists != "overwrite":
            # if if_exists == "overwrite":
            #     token = "O"
            if if_exists == "append":
                token = "A"
            elif if_exists == "cancel":
                token = "C"
            else:
                msg = ("if_exists should be one of ['overwrite', 'append', "
                       "'cancel'], not {}")
                raise RuntimeError(msg.format(if_exists))
            self.command([token])

    def close_avl(self):
        self.command(["", "", "q"])

    def close(self):
        """Command AVL to stop running."""
        self.stdin.close()
        if self.stdout and self.stdout != sys.stdout:
            self.stdout.close()
        if self.wait() != 0:
            print("There were some errors")


class Geometry(AVLBase):
    """The AVL *geometry* consists of :attr:`surfaces`, each of type
    :class:`Surface` or :class:`Body`. AVL results will be normalized based on
    several reference values. For this purpose, you have to define reference
    point (:attr:`ref_pt`), area (:attr:`ref_area`), chord (:attr:`ref_chord`)
    and span (:attr:`ref_span`). Do this in the same units as your (scaled)
    geometry units or **LUnit**. Moreover, you can specify the flight
    condition, i.e. :attr:`velocity`, :attr:`density` and :attr:`mach_number`
    (free-stream Mach number for Prandtl-Glauert correction). Usage:

    >>> Geometry(name="My geometry",
    ...          description="My description",
    ...          surfaces=[wing, htp, vtp],
    ...          mach_number=0.0,
    ...          velocity=200,
    ...          density=1.225,
    ...          ref_area=1260,
    ...          ref_chord=11,
    ...          ref_span=113,
    ...          ref_pt=(60, 0, 0))
    """

    __icon__ = os.path.join(ICN_DIR, "geometry.png")

    #: Case title
    #: :type: str
    name = Input("Unnamed Case")
    #: Case description
    #: :type: str
    description = Input("No description")
    #: list of surface(s) of the geometry
    #: :type: list[Surface | Body]
    surfaces = Input(in_tree=True)
    #: Default location about which moments and rotation rates are defined
    #: ATTENTION: for trim calculations, :attr:`ref_pt` must be the CG (see
    #: MSET command).
    #: :type: Point
    ref_pt = Input()
    #: Reference area used to define all coefficients (CL, CD, Cm, etc.)
    #: :type: float
    ref_area = Input()
    #: Reference chord used to define pitching moment (Cm)
    #: :type: float
    ref_chord = Input()
    #: Reference span used to define roll and yaw moments (Cl, Cn)
    #: :type: float
    ref_span = Input()
    #: Velocity. Unit: Lunit/Tunit
    #: :type: float | None
    velocity = Input(None)
    #: Velocity. Unit: Munit/Lunit^3
    #: :type: float | None
    density = Input(None)
    #: Default free-stream Mach number for Prandtl-Glauert correction
    #: :type: float
    mach_number = Input(0.)
    #: Symmetry conditions about Y=0
    #: :type: int
    symmetry_y = Input(NOT_SYMMETRIC, validator=val.OneOf(
        [ANTI_SYMMETRIC, NOT_SYMMETRIC, SYMMETRIC]))
    #: Symmetry condition about Z=`symmetry_z_coord`
    #: :type: int
    symmetry_z = Input(NOT_SYMMETRIC, validator=val.OneOf(
        [ANTI_SYMMETRIC, NOT_SYMMETRIC, SYMMETRIC]))
    #: Z-coordinate about which `symmetry_z` applies
    #: :type: float
    symmetry_z_coord = Input(0.)
    #: Default profile drag coefficient added to geometry, applied at `ref_pt`
    #: :type: float | None
    c_prof_drag = Input(None)

    @Attribute
    def label(self):
        return self.name

    def write(self, f=sys.stdout):
        """Write the AVL geometry file."""
        lines = (
            "# ------------------------------------------------\n" +
            "# CASE: {}\n".format(self.description) +
            "# ------------------------------------------------\n" +
            "{}\n".format(self.name) +
            "# Mach\n" +
            "{}\n".format(self.mach_number) +
            "# iYsym  iZsym  Zsym\n" +
            "{} {} {}\n".format(self.symmetry_y, self.symmetry_z, self.symmetry_z_coord) +
            "# Sref   Cref   Bref\n" +
            "{} {} {}\n".format(self.ref_area, self.ref_chord, self.ref_span) +
            "# Xref   Yref   Zref\n" +
            "{0[0]} {0[1]} {0[2]}\n".format(self.ref_pt))

        if self.c_prof_drag is not None:
            lines += (
                "# CDp\n" +
                "{0}\n".format(self.c_prof_drag))
        f.write(lines)

        for surface in self.surfaces:
            surface.write(f)


class Surface(AVLBase):
    """AVL surface, consisting of two or more :attr:`sections`, each section
    of type :class:`Section`. You have to specify a :attr:`name`, e.g.
    :py:`"Main Wing"`. These names will come back in the outputs from an
    AVL run. You have to specify both the number and distribution of chordwise
    vortices (:attr:`n_chord` and :attr:`c_spacing`).
    Optionally, you can specify both the number and distribution of spanwise
    vortices (:attr:`Section.n_span` and :attr:`Section.s_spacing`). While
    spanwise vortex distributions are typically defined on this
    class:`Surface` level, it is also allowed to define the number of
    and distribution of spanwise vortices on :class:`Section`-level
    (:attr:`Section.n_span` and :attr:`Section.s_spacing`). To create a
    mirror image of a surface (left-wing as mirrored from right wing), set
    :attr:`y_duplicate` to a coordinate (float), e.g. :py:`0.0` to mirror a
    surface in the XZ-plane at the :py:`0.0 y-coordinate. You can modify the
    surface geometry, first by scaling (:attr:`scale`) and then by translation
    (:attr:`translate`).

    >>> Surface(name="VTP",
    ...         sections=[section_vtp_root, section_vtp_tip],
    ...         n_chord=6,      # 6 vortex panels from le -> te
    ...         n_span=20,      # 20 vortex panels root -> tip
    ...         c_spacing=2.0,  # sine:  || |  |   |    |    |     |
    ...         s_spacing=1.0,  # cosine: ||  |    |      |    |  ||
    ...         scale=(0.001, 0.001, 0.001),  # scale mm -> m
    ...         )

    .. note:: incidence angle :attr:`angle` is not visualized in the |ParaPy|
        GUI, but is correctly written to AVL.

    **Vortex Spacing**

    - :attr:`c_spacing`: leading edge -> trailing edge
    - :attr:`s_spacing`: first section -> last section

    Settings::

     parameter      type                      spacing
     ---------      ----                      -------
        3.0        equal         |   |   |   |   |   |   |   |   |
        2.0        sine          || |  |   |    |    |     |     |
        1.0        cosine        ||  |    |      |      |    |  ||
        0.0        equal         |   |   |   |   |   |   |   |   |
       -1.0        cosine        ||  |    |      |      |    |  ||
       -2.0       -sine          |     |     |    |    |   |  | ||
       -3.0        equal         |   |   |   |   |   |   |   |   |
    """

    __icon__ = os.path.join(ICN_DIR, "surface.png")

    #: name of the surface.
    #: :type: str
    name = Input()
    #: list of section(s) that define this surface
    #: :type: list[Section, AirfoilSection]
    sections = Input()
    #: number of chordwise panels for this surface its sections
    #: :type: int
    n_chord = Input()
    #: number of spanwise panels for this surface its sections [optional]
    #: :type: int | None
    n_span = Input(None)
    #: chordwise spacing option between -3.0 and 3.0. Options::
    #:
    #:    parameter      type                      spacing
    #:    ---------      ----                      -------
    #:        3.0        equal         |   |   |   |   |   |   |   |   |
    #:        2.0        sine          || |  |   |    |    |     |     |
    #:        1.0        cosine        ||  |    |      |      |    |  ||
    #:        0.0        equal         |   |   |   |   |   |   |   |   |
    #:        -1.0       -cosine       ||  |    |      |      |    |  ||
    #:        -2.0       -sine         |     |     |    |    |   |  | ||
    #:       -3.0        equal         |   |   |   |   |   |   |   |   |
    #:
    #: :type: int
    c_spacing = Input()
    #: spanwise spacing option [optional]. Specify here, or for each
    #: :class:`Section` individually. Options::
    #:
    #:    parameter      type                      spacing
    #:    ---------      ----                      -------
    #:        3.0        equal         |   |   |   |   |   |   |   |   |
    #:        2.0        sine          || |  |   |    |    |     |     |
    #:        1.0        cosine        ||  |    |      |      |    |  ||
    #:        0.0        equal         |   |   |   |   |   |   |   |   |
    #:        -1.0       -cosine       ||  |    |      |      |    |  ||
    #:        -2.0       -sine         |     |     |    |    |   |  | ||
    #:       -3.0        equal         |   |   |   |   |   |   |   |   |
    #:
    #: :type: int | None
    s_spacing = Input(None)
    #: DUPLICATE key-word creates a geometric mirror image of the surface.
    #: :type: float | None
    y_duplicate = Input(None)
    #: Index used to identify surfaces of a particular component instance
    #: :type: int | None
    lcomp = Input(None)
    #: SCALE key-word allows convenient rescaling of the surface.
    #: format: tuple(x_scale, y_scale, z_scale)
    #: :type: (float, float, float)
    scale = Input((1, 1, 1))
    #: TRANSLATE key-word allows convenient relocation of the surface.
    #: format: Vector(dX, dY, dZ)
    #: :type: parapy.geom.Vector | None
    translate = Input(None)
    #: ANGLE key-word allows changing the incidence angle of the surface.
    #: :type: float | None
    angle = Input(None)
    #: NOWAKE key-word specifies whether this surface sheds a wake.
    #: When True: surface generates near-zero lift but a nonzero moment.
    #: :type: bool
    no_wake = Input(False)
    #: NOALBE key-word specifies whether surface is affected by free-stream direction
    #: changes specified by alpha, beta angles and p, q, r rotation rates.
    #: :type: bool
    no_al_be = Input(False)
    #: NOLOAD key-word specifies that force and moment acting on surface are not
    #: considered in the overall forces and moments of the configuration.
    #: :type: bool
    no_load = Input(False)
    #: CDCL key-word specifies simple profile drag CD(CL) function for all
    #: sections. This function is parabolic between CL1..CL2 and CL2..CL3.
    #: format: tuple(CL1, CD1, CL2, CD2, CL3, CD3)
    #: :type: tuple(float, float, float, float, float, float) | None
    cd_cl = Input(None)

    @Attribute
    def label(self):
        return self.name

    @Attribute
    def le_points(self):
        """List all LE point of invididual sections.
        
        :rtype: list[Point]
        """
        pts = [section.le_pt for section in self.sections]
        v = self.translate
        s = self.scale
        if v is not None:
            x_, y_, z_ = v
            pts = [Point(x + x_, y + y_, z + z_) for (x, y, z) in pts]
        if s != (1, 1, 1):
            sx, sy, sz = s
            pts = [Point(sx * x, sy * y, sz * z) for (x, y, z) in pts]
        return pts

    @Attribute
    def te_points(self):
        """List all TE point of invididual sections.

        :rtype: list[Point]
        """
        pts = [section.te_pt for section in self.sections]
        v = self.translate
        s = self.scale
        if v is not None:
            x_, y_, z_ = v
            pts = [Point(x + x_, y + y_, z + z_) for (x, y, z) in pts]
        if s != (1, 1, 1):
            sx, sy, sz = s
            pts = [Point(sx * x, sy * y, sz * z) for (x, y, z) in pts]
        return pts

    @Attribute
    def section_curves(self):
        return [section.curve for section in self.sections]

    @Attribute
    def section_camberlines(self):
        return [section.camberline for section in self.sections]

    @Part
    def le_crv(self):
        """Leading edge curve of the surface."""
        return FittedCurve(points=[edge.start for edge in self.translated_camberlines],
                           max_degree=1,
                           color="red")

    @Part
    def te_crv(self):
        """Trailing edge curve of the surface."""
        return FittedCurve(points=[edge.end for edge in self.translated_camberlines],
                           max_degree=1,
                           color="red")

    @Attribute
    def from_to_positions(self):
        sections = self.sections
        points = self.le_points
        # extra point extrapolated beyond last section
        extra_point = points[-2].interpolate(points[-1], frac=2.0)
        points += [extra_point]
        vx = Vector(1, 0, 0)
        vy = Vector(0, 1, 0)
        lst = []
        for section, (pt1, pt2) in zip(sections, pairwise(points)):
            le_pt = section.le_pt
            vz = Point.vector_to(pt1, pt2)
            vy_new = vx.cross(vz)
            from_pos = Position(le_pt, Orientation(vx, vy))
            to_pos = Position(le_pt, Orientation(vx, vy_new))
            lst.append((from_pos, to_pos))
        return lst

    @Part
    def positioned_camberlines(self):
        return TransformedCurve(
            quantify=len(self.section_camberlines),
            curve_in=self.section_camberlines[child.index],
            from_position=self.from_to_positions[child.index][0],
            to_position=self.from_to_positions[child.index][1],
            color="green",
            hidden=True)

    @Part
    def scaled_camberlines(self):
        return ScaledCurve(
            quantify=len(self.positioned_camberlines),
            curve_in=self.positioned_camberlines[child.index],
            reference_point=Point(0, 0, 0),
            factor=self.scale,
            color="green",
            hidden=True)

    @Part
    def translated_camberlines(self):
        return TranslatedCurve(
            quantify=len(self.scaled_camberlines),
            curve_in=self.scaled_camberlines[child.index],
            displacement=Vector(*self.translate) if self.translate else Vector(0, 0, 0),
            color="green",
            hidden=False)

    @Part
    def positioned_curves(self):
        return TransformedCurve(
            quantify=len(self.section_curves),
            curve_in=self.section_curves[child.index],
            from_position=self.from_to_positions[child.index][0],
            to_position=self.from_to_positions[child.index][1],
            color="green",
            hidden=True)

    @Part
    def scaled_curves(self):
        return ScaledCurve(
            quantify=len(self.positioned_curves),
            curve_in=self.positioned_curves[child.index],
            reference_point=Point(0, 0, 0),
            factor=self.scale,
            color="green",
            hidden=True)

    @Part
    def translated_curves(self):
        return TranslatedCurve(
            quantify=len(self.scaled_curves),
            curve_in=self.scaled_curves[child.index],
            displacement=Vector(*self.translate) if self.translate else Vector(0, 0, 0),
            color="green",
            hidden=False)
    
    @Part
    def surface(self):
        """3D surface representation of the AVL surface"""
        return RuledShell(profiles=self.translated_camberlines)

    @Part
    def mirrored_le_crv(self):
        return MirroredCurve(curve_in=self.le_crv,
                             reference_point=Point(0, self.y_duplicate, 0),
                             vector1=Vector(1, 0, 0),
                             vector2=Vector(0, 0, 1),
                             suppress=self.y_duplicate is None,
                             color="red")

    @Part
    def mirrored_te_crv(self):
        return MirroredCurve(curve_in=self.te_crv,
                             reference_point=Point(0, self.y_duplicate, 0),
                             vector1=Vector(1, 0, 0),
                             vector2=Vector(0, 0, 1),
                             suppress=self.y_duplicate is None,
                             color="red")

    @Part
    def mirrored_camberlines(self):
        return MirroredCurve(quantify=len(self.translated_camberlines),
                             curve_in=self.translated_camberlines[child.index],
                             reference_point=Point(0, self.y_duplicate, 0),
                             vector1=Vector(1, 0, 0),
                             vector2=Vector(0, 0, 1),
                             suppress=self.y_duplicate is None,
                             color="green")

    @Part
    def mirrored_surface(self):
        return MirroredShape(shape_in=self.surface,
                             reference_point=Point(0, self.y_duplicate, 0),
                             vector1=Vector(1, 0, 0),
                             vector2=Vector(0, 0, 1),
                             suppress=self.y_duplicate is None)

    def write(self, f=sys.stdout):
        """Write a section of the AVL geometry file defining a surface.

        :param lcomp: if this Surface is part of a Component, this index is
            pass by the owning Component to this write() method
        :type lcomp: int | None
        """
        s_spacing = self.s_spacing
        if s_spacing is None:
            s_spacing = ""
        n_span = self.n_span
        if n_span is None:
            n_span = ""
        lines = (
            "\n# ------------------------------------------------\n" +
            "SURFACE\n" +
            "{0}\n".format(self.name) +
            "# n_chord c_spacing [n_span] [s_spacing]\n" +
            "{0} {1} {2} {3}\n".format(
                self.n_chord, self.c_spacing, n_span, s_spacing))

        if self.lcomp is not None:
            lines += (
                "\nCOMPONENT\n" +
                "# index\n" +
                "{0}\n".format(self.lcomp))

        if self.angle is not None:
            lines += (
                "\nANGLE\n" +
                "{0}\n".format(self.angle))

        if self.y_duplicate is not None:
            lines += (
                "\nYDUPLICATE\n" +
                "{0}\n".format(self.y_duplicate))

        if self.translate is not None:
            lines += (
                "\nTRANSLATE\n" +
                "{0[0]} {0[1]} {0[2]}\n".format(self.translate))

        if self.scale is not None:
            lines += (
                "\nSCALE\n" +
                "{0[0]} {0[1]} {0[2]}\n".format(self.scale))

        if self.no_wake:
            lines += (
                "\nNOWAKE\n")

        if self.no_al_be:
            lines += (
                "\nNOALBE\n")

        if self.no_load:
            lines += (
                "\nNOLOAD\n")

        if self.cd_cl is not None:
            lines += (
                "\nCDCL\n" +
                "# CL1 CD1 CL2 CD2 CL3 CD3\n"
                "{} {} {} {} {} {}\n".format(*self.cd_cl))

        f.write(lines)

        for section in self.sections:
            section.write(f)


class Section(AVLBase):
    """Defines a flat-plate section at a spanwise location on a surface
    given LE point :attr:`le_pt` and :attr:`chord`. This type of
    :class:`Section` is useful for symmetrical airfoils (without camber)
    like those encountered in vertical tails. Optionally, an incidence angle
    :attr:`a_inc` can be specified (see note below). While panel
    distributions can be defined on :class:`Surface` level, it is also
    allowed to define the number of and distribution of spanwise vortices (
    :attr:`n_span` and :attr:`s_spacing`) on section-level. See
    :class:`Surface` for spacing options. Usage:

    >>> s = Section(le_pt=Point(0, 0, 0),
    ...             chord=6.0)

    .. note:: while incidence angles are not visualized in the |ParaPy| GUI,
        they are correctly written to AVL.
    """

    __icon__ = os.path.join(ICN_DIR, "section.png")

    #: section leading edge location
    #: :type: Point
    le_pt = Input()
    #: section chord (trailing edge location is at translate(le_pt, "x", chord))
    #: :type: float
    chord = Input()
    #: Incidence angle, taken as a rotation about the surface's spanwise axis
    #: projected onto surface's *planform*, Y-Z plane for horizontal wings, X-Z
    #: plane for vertical wings.
    #: :type: float
    a_inc = Input(0.)
    #: Number of spanwise vortices until the next section. You can define it
    #: here or define it once in the owning Surface instance.
    #: :type: int | None
    n_span = Input(None)
    #: [optional] spanwise spacing method used for the vortices. Options::
    #:
    #:    parameter      type                      spacing
    #:    ---------      ----                      -------
    #:        3.0        equal         |   |   |   |   |   |   |   |   |
    #:        2.0        sine          || |  |   |    |    |     |     |
    #:        1.0        cosine        ||  |    |      |      |    |  ||
    #:        0.0        equal         |   |   |   |   |   |   |   |   |
    #:        -1.0       -cosine       ||  |    |      |      |    |  ||
    #:        -2.0       -sine         |     |     |    |    |   |  | ||
    #:       -3.0        equal         |   |   |   |   |   |   |   |   |
    #:
    #: :type: int | None
    s_spacing = Input(None)
    #: CLAF key-word scales the effective dcl/da of the section as:
    #: dcl/da = 2 * pi * CLaf
    #: :type: float | None
    cl_af = Input(None)
    #: CDCL key-word specifies simple profile drag CD(CL) function for this
    #: section. This function is parabolic between CL1..CL2 and CL2..CL3.
    #: format: list(CL1, CD1, CL2, CD2, CL3, CD3)
    #: :type: list[float, float, float, float, float, float]
    cd_cl = Input(None)
    #: list of all control variables for this section.
    #: format: list(list(name, gain, Xhinge, XYZhvec, SgnDup))
    #: :type: list[list[str, float, float, parapy.geom.Vector, int]]
    control_vars = Input(())
    #: list of all design variables for this section.
    #: format: list(tuple(name, local_weight))
    #: :type: list[list[str, float]]
    design_vars = Input(())

    def write(self, f=sys.stdout):
        """Write a section of the AVL geometry file defining an section."""
        s_spacing = self.s_spacing
        if s_spacing is None:
            s_spacing = ""
        n_span = self.n_span
        if n_span is None:
            n_span = ""
        lines = (
            "\n" +
            "SECTION\n" +
            "# LE_x LE_y LE_z chord angle [n_span] [s_spacing]\n" +
            "{0[0]} {0[1]} {0[2]} {1} {2} {3} {4}\n".format(
                self.le_pt, self.chord, self.a_inc, n_span, s_spacing))

        if self.cl_af is not None:
            lines += (
                "\nCLAF\n" +
                "{}\n".format(self.cl_af))

        if self.cd_cl is not None:
            lines += (
                "\nCDCL\n" +
                "# CL1 CD1 CL2 CD2 CL3 CD3\n"
                "{} {} {} {} {} {}\n".format(*self.cd_cl))

        for design_var in self.design_vars:
            lines += (
                "\nDESIGN\n" +
                "# name local_weight\n" +
                "{0} {1}\n".format(*design_var))

        for control_var in self.control_vars:
            lines += (
                "\nCONTROL\n" +
                "# name gain Xhinge XYZhvec SgnDup\n" +
                "{0} {1} {2} {3[0]} {3[1]} {3[2]} {4}\n".format(*control_var))

        f.write(lines)

    @Attribute
    def te_pt(self):
        """Trailing edge coordinate of this section in 3D space.

        :rtype: Point
        """
        return translate(self.le_pt, 'x', self.chord)

    @Attribute
    def camber_points3d(self):
        """All points of camber line in XY plane.

        :rtype: list[Point]
        """
        return [self.le_pt, self.te_pt]

    @Part
    def curve(self):
        """Airfoil representation for this section."""
        return LineSegment(start=self.le_pt,
                           end=self.te_pt,
                           color="blue")

    @Part
    def camberline(self):
        """camber line for this section in XY plane."""
        return LineSegment(start=self.le_pt,
                           end=self.te_pt,
                           color="green")


class AirfoilSection(Section):
    """Defines an airfoil section at a spanwise location on the surface.
    Airfoils are either defined as NACA4-series type or by points. Point
    should come from a .dat file or provided directly as a list of normalized
    points in XY plane.

    In case :attr:`af_type` is set to :py:`"AIRFOIL"`: the x/c,
    y/c :attr:`points` run from TE, to LE, back to the TE again in either
    direction. These coordinates are splined, and the slope of the camber y(
    x) function is obtained from the middle y/c values between the top and
    bottom. The number of points N is determined when a line without two
    readable numbers is encountered:

    >>> # cambered airfoil section from points file
    ... AirfoilSection(af_type="AIRFOIL",
    ...                points=[Point(1, 0, 0), Point(0.95, 0.02, 0), ...],
    ...                le_pt=Point(15, 0, 0),
    ...                chord=1.0)

    In case :attr:`af_type` is set to :py:`"NACA"`, specify
    :attr:`naca4series` as well, e.g. :py:`"0012"` or :py:`"2412"`:

    >>> # cambered NACA4 airfoil section
    ... AirfoilSection(af_type="NACA",
    ...                naca4series="2412",
    ...                le_pt=Point(15, 0, 0),
    ...                chord=1.0)

    In case :attr:`af_type` is set to :py:`"AFILE"`, specify
    :attr:`af_file` as well, e.g. :py:`ag35.dat"`:

    >>> # cambered ag35 airfoil section from .dat file
    ... AirfoilSection(af_type="AFILE",
    ...                af_file="ag35.dat",
    ...                le_pt=Point(15, 0, 0),
    ...                chord=1.0)

    If present, the optional :attr:`xc_start` and :attr:`xc_end` numerical
    parameters indicate that only the x/c range X1..X2 from the coordinates
    is to be assigned to the surface. If the surface is a 20%-chord flap,
    for example, then X1 X2 would be 0.80 1.00. This allows the camber shape
    to be easily assigned to any number of surfaces in piecewise manner.
    """

    __icon__ = os.path.join(ICN_DIR, "airfoilsection.png")

    #: determines input type for the airfoil data.
    #: :type: str
    af_type = Input(validator=val.OneOf(["NACA", "AIRFOIL", "AFILE"]))
    #: starting x/c for section of airfoil which is assigned to this section
    #: :type: float
    xc_start = Input(0.)
    #: ending x/c for section of airfoil which is assigned to this section
    #: :type: float
    xc_end = Input(1.)
    #: Normalized points of airfoil. Applicable when :attr:`af_type` equals
    # "AIRFOIL".
    #: :type: list[Point]
    points = Input()
    #: naca 4-series definition. Applicable when :attr:`af_type` equals "NACA".
    #: :type: str
    naca4series = Input(None)
    #: file with airfoil coordinates. Applicable when :attr:`af_type` equals
    #: "AFILE"
    #: :type: file | str
    af_file = Input(None)

    @Attribute
    def __naca_points(self):
        """Caches all naca4_points results"""
        if self.af_type == "NACA":
            s = self.naca4series
            xy_c, xy_u, xy_l = naca4_points(s, 50, sampling="cosine")
            return ([Point(x, y, 0) for x, y in xy_c],
                    [Point(x, y, 0) for x, y in xy_u],
                    [Point(x, y, 0) for x, y in xy_l])

    @Attribute
    def normalized_points(self):
        """Points from TE->LE->TE.
        
        :rtype: list[Point]
        """
        af_type = self.af_type
        if af_type == "AFILE":
            return read_af_file(self.af_file)
        elif af_type == "NACA":
            _, pts_u, pts_l = self.__naca_points
            return list(reversed(pts_u)) + pts_l
        elif af_type == "AIRFOIL":
            return self.points
        else:
            msg = "af_type one of {\"NACA\", \"AIRFOIL\", \"AFILE\"}, not {}"
            raise RuntimeError(msg.format(af_type))

    @Attribute
    def normalized_camberline_points(self):
        """Normalized points for camber line running from LE to TE.

        :rtype: list[Point]
        """
        af_type = self.af_type
        if af_type in {"AFILE", "AIRFOIL"}:
            crv = self.normalized_curve
            u_le = self.normalized_le_parameter
            pts_u = []
            pts_l = []
            pts_c = []
            # TODO (RvD): Use x-parameter instead. Author: RvD.
            for u in cosspace(u_le, crv.u1, 50):
                pts_u.append(crv.point(u))
            for u in cosspace(u_le, crv.u2, 50):
                pts_l.append(crv.point(u))
            for pt1, pt2 in zip(pts_u, pts_l):
                pts_c.append(pt1.midpoint(pt2))
        elif af_type == "NACA":
            pts_c, _, _ = self.__naca_points
        else:
            msg = "af_type one of {\"NACA\", \"AIRFOIL\", \"AFILE\"}, not {}"
            raise RuntimeError(msg.format(af_type))
        return pts_c
    
    @Attribute
    def normalized_le_parameter(self):
        """LE Point parameter on normalized curve.
        
        :rtype: float
        """
        af_type = self.af_type
        if af_type in {"AFILE", "AIRFOIL"}:
            return airfoil_le_parameter(self.normalized_curve)
        elif af_type == "NACA":
            return self.normalized_curve.parameter_at_point(
                self.normalized_le_pt)
        else:
            msg = "af_type one of {\"NACA\", \"AIRFOIL\", \"AFILE\"}, not {}"
            raise RuntimeError(msg.format(af_type))

    @Attribute
    def normalized_le_pt(self):
        """LE Point parameter on normalized curve.

        :rtype: Point
        """
        af_type = self.af_type
        if af_type in {"AFILE", "AIRFOIL"}:
            return self.normalized_curve.point(self.normalized_le_parameter)
        elif af_type == "NACA":
            pts_c, _, _ = self.__naca_points
            return pts_c[0]
        else:
            msg = "af_type one of {\"NACA\", \"AIRFOIL\", \"AFILE\"}, not {}"
            raise RuntimeError(msg.format(af_type))

    @Part
    def normalized_curve(self):
        return FittedCurve(points=self.normalized_points,
                           min_degree=3,
                           color="red",
                           tolerance=1e-4,
                           hidden=True)

    @Part
    def normalized_camberline(self):
        return FittedCurve(points=self.normalized_camberline_points,
                           min_degree=3,
                           color="green",
                           tolerance=1e-4,
                           hidden=True)

    @Part
    def scaled_curve(self):
        return ScaledCurve(curve_in=self.normalized_curve,
                           reference_point=self.normalized_le_pt,
                           factor=self.chord,
                           hidden=True)

    @Part
    def scaled_camberline(self):
        return ScaledCurve(curve_in=self.normalized_camberline,
                           reference_point=self.normalized_le_pt,
                           factor=self.chord,
                           hidden=True)

    @Part
    def curve(self):
        """Curve representation of this section."""
        return TranslatedCurve(curve_in=self.scaled_curve,
                               displacement=self.le_pt - self.normalized_le_pt,
                               color="red")

    @Part
    def camberline(self):
        """Curve representation of camberline."""
        return TranslatedCurve(curve_in=self.scaled_camberline,
                               displacement=self.le_pt - self.normalized_le_pt,
                               color="green")

    # TODO (TBD): just use Section.write()?
    def write(self, f=sys.stdout):
        """Write a section of the AVL geometry file defining an airfoil
        section.
        """
        s_spacing = self.s_spacing
        if s_spacing is None:
            s_spacing = ""
        n_span = self.n_span
        if n_span is None:
            n_span = ""
        lines = (
            "\n" +
            "SECTION\n" +
            "# LE_x LE_y LE_z chord angle [n_span] [s_spacing]\n" +
            "{0[0]} {0[1]} {0[2]} {1} {2} {3} {4}\n".format(
                self.le_pt, self.chord, self.a_inc, n_span, s_spacing))

        if self.af_type == "NACA":
            lines += (
                "\nNACA {} {}\n".format(self.xc_start, self.xc_end) +
                "{}\n".format(self.naca4series))
        elif self.af_type == "AFILE":
            lines += (
                "\nAFILE {} {}\n".format(self.xc_start, self.xc_end) +
                "{}\n".format(self.af_file))
        else:  # since, logically: self.af_type == "AIRFOIL":
            coordinates = ""
            for pt in self.points:
                coordinates += "{} {}\n".format(pt.x, pt.y)
            lines += (
                "\nAIRFOIL {} {}\n".format(self.xc_start, self.xc_end) +
                coordinates)

        if self.cl_af is not None:
            lines += (
                "\nCLAF\n" +
                "{}\n".format(self.cl_af))

        if self.cd_cl is not None:
            lines += (
                "\nCDCL\n" +
                "# CL1 CD1 CL2 CD2 CL3 CD3\n"
                "{} {} {} {} {} {}\n".format(*self.cd_cl))

        for design_var in self.design_vars:
            lines += (
                "\nDESIGN\n" +
                "# name local_weight\n" +
                "{0} {1}\n".format(*design_var))

        for control_var in self.control_vars:
            lines += (
                "\nCONTROL\n" +
                "# name gain Xhinge XYZhvec SgnDup\n" +
                "{0} {1} {2} {3[0]} {3[1]} {3[2]} {4}\n".format(*control_var))

        f.write(lines)

    def _read_af_file(self):
        """Read provided airfoil file, af_file, and return coordinates as points.

        :rtype: list[Point]
        """
        lst = []
        with open(self.af_file) as f:
            next(f)
            for line in f:
                x, y = line.split()
                lst.append(Point(float(x), 0, float(y)))
        return lst


# TODO (RvD): positive camber should be decided on surface level.
class AirfoilCurveSection(AirfoilSection):
    """Create an AVL airfoil section from a **planar** airfoil :attr:`curve`.
    The curve has to start at the Trailing Edge, go round and come back at the
    Trailing Edge. By default, the LE point of the airfoil is placed at the
    LE point of :attr:`curve_in`. However, you may override this to
    effectively translate the 3d curve. Usage:

    >>> crv = FittedCurve([Point(6, 0, 1), Point(5.9, 0, 1.02), ..., Point(6, 0, 1)])
    >>> section = AirfoilCurveSection(curve=crv,
    ...                               nb_points=100)

    .. caution:: to resolve positive camber direction, this class assumes that
        :attr:`curve_in` is defined from ``TE -> upper side -> LE-> lower side ->
        TE``. If :attr:`curve_in` does lower side first, the airfoil will get
        upside down. In this case, set :attr:`reverse` to True.
    """

    __icon__ = os.path.join(ICN_DIR, "airfoilsectioncurve.png")

    #: Closed airfoil curve starting at TE point.
    #: :type: parapy.geom.occ.curve.Curve
    curve_in = Input()
    #: by default, LE point will be anchored at LE point of :attr:`curve_in`
    #: in 3D. However, you may override this.
    le_pt = Input(derived)
    #: number of points one of side of airfoil (i.e. upper or lower)
    #: :type: int
    nb_points = Input(50)
    #: if the curve is not defined TE->upper side->LE->lower side->TE, but
    #: is does lower side first, set this to True.
    # :type: bool
    reverse = Input(False)

    @le_pt.getter
    def le_pt(self):
        return self.le_pt3d

    # --- override of Inputs ---
    af_type = Attribute("AIRFOIL")
    naca4series = Attribute(None)
    af_file = Attribute(None)

    @Attribute
    def plane_normal(self):
        """Plane normal of input :attr:`curve`.

        :rtype: parapy.geom.Vector
        """
        crv = self.curve_in
        if not crv.is_planar:
            msg = "Airfoil curve {} is not planar"
            raise RuntimeError((msg).format(crv))
        u1, u2 = crv.u1, crv.u2
        u1_ = u1 + 0.05 * (u2 - u1)
        u2_ = u2 - 0.05 * (u2 - u1)
        pt0 = crv.start
        pt1 = crv.point(u1_)
        pt2 = crv.point(u2_)
        v1 = pt1 - pt0
        v2 = pt2 - pt0
        w = Vector.cross(v1, v2).normalized
        if self.reverse:
            return -w
        else:
            return w

    @Attribute
    def points3d(self):
        """3d Points spread over airfoil :attr:`curve_in`.

        :rtype: list[Point]
        """
        crv = self.curve_in
        nb = self.nb_points
        u_le = self.le_parameter
        pts = []
        gen1 = cosspace(u_le, crv.u1, nb)
        for u in gen1:
            pts.insert(0, crv.point(u))
        gen2 = cosspace(u_le, crv.u2, nb)
        next(gen2)  # skip le point
        for u in gen2:
            pts.append(crv.point(u))
        return pts

    @Attribute
    def te_pt3d(self):
        """Leading edge Point (start of :attr:`curve`).

        :rtype:
        """
        return self.curve_in.start.midpoint(self.curve_in.end)

    @Attribute
    def le_parameter(self):
        """Leading edge parameter.

        :rtype: float
        """
        crv = self.curve_in
        return airfoil_le_parameter(crv)

    @Attribute
    def le_pt3d(self):
        """Leading edge Point.

        :rtype: Point
        """
        return self.curve_in.point(self.le_parameter)

    @Attribute
    def chord(self):
        """Chord measured in global x-direction.

        :rtype: float
        """
        x1 = self.le_pt3d.x
        x2 = max(self.curve_in.start.x, self.curve_in.end.x)
        return x2 - x1

    @Attribute
    def points(self):
        """Normalized, in-plane airfoil points.

        :rtype: list[Point]
        """
        le_pt = self.le_pt3d
        vz = self.plane_normal
        vx = Vector.project_on_plane(XY.x, vz)
        c = self.chord
        x0, y0, _ = le_pt
        pts = points_in_plane(self.points3d, le_pt, vz, vx)
        pts_norm = [Point((pt.x - x0) / c, (pt.y - y0) / c, 0) for pt in pts]
        return pts_norm


class Body(AVLBase):
    """Defines a body, modeled with a source-doublet line along its axis,
    in accordance with slender-body theory.

    This specifies the shape of the body as an "airfoil" file which gives
    the top or side view of the body, which is assumed to have a round
    cross-section. Hence, the diameter of the body is the difference between
    the top and bottom Y values. Bodies which are not round must be
    approximated with an equivalent round body which has roughly the same
    cross-sectional areas. If the path/filename has embedded blanks double
    quotes should be used to delimit the string.

    >>> fuselage = Body(name="Fuselage",
    ...                 n_body=12,
    ...                 b_spacing=1,
    ...                 translate=(-12.5, 0, -1.4),
    ...                 b_file="input/fuseBD.dat")

    .. note:: no visualization available for this class (yet).
    """

    #: name of the body
    #: :type: str
    name = Input()
    #: number of source-line nodes
    #: :type: int
    n_body = Input()
    #: length-wise node spacing parameter
    #: :type: int
    b_spacing = Input()
    #: file with 'airfoil' coordinates.
    #: :type: str
    b_file = Input()
    #: starting x/c for 'airfoil' which is assigned to this body.
    #: :type: float
    xc_start = Input(0.0)
    #: ending x/c for 'airfoil' which is assigned to this body.
    #: :type: float
    xc_end = Input(1.0)
    #: DUPLICATE key-word creates a geometric mirror image of the body.
    #: format: Ydupl, Y-position of mirror (XZ) plane.
    #: :type: float | None
    y_duplicate = Input(None)
    #: SCALE key-word allows convenient rescaling of the body.
    #: format: tuple(x_scale, y_scale, z_scale)
    #: :type: (float, float, float) | None
    scale = Input(None)
    #: TRANSLATE key-word allows convenient relocation of the body.
    #: format: Vector(dX, dY, dZ)
    #: :type: Vector | None
    translate = Input(None)

    @Attribute
    def label(self):
        return self.name

    def write(self, f=sys.stdout):
        """Write a section of the AVL geometry file defining a body."""
        lines = (
            "\n# ------------------------------------------------\n" +
            "BODY\n" +
            "{0}\n".format(self.name) +
            "# n_body b_spacing\n" +
            "{0} {1}\n".format(self.n_body, self.b_spacing))

        if self.y_duplicate is not None:
            lines += (
                "YDUPLICATE\n" +
                "# Ydupl\n" +
                "{0}\n".format(self.y_duplicate))

        if self.scale is not None:
            lines += (
                "SCALE\n" +
                "# X_scale Y_scale Z_scale\n" +
                "{0[0]} {0[1]} {0[2]}\n".format(self.scale))

        if self.translate is not None:
            lines += (
                "TRANSLATE\n" +
                "# dX dY dZ\n" +
                "{0[0]} {0[1]} {0[2]}\n".format(self.translate))

        if self.b_file is not None:
            lines += (
                "BFILE {} {}\n".format(self.xc_start, self.xc_end) +
                "# filename\n" +
                "{0}\n".format(self.b_file))
        f.write(lines)


class RunCase(AVLBase):
    """(Optional) AVL run case defining parameters for a set of conditions.

    Run Case File Contents
    ----------------------
    A run case file can be listed to show its contents.
    One case block in the file is shown below:

     ---------------------------------------------
     Run case  1:  VIAS=220 mph

     alpha        ->  alpha        =   4.00000
     beta         ->  beta         =   0.00000
     pb/2V        ->  pb/2V        =   0.00000
     qc/2V        ->  qc/2V        =   0.00000
     rb/2V        ->  rb/2V        =   0.00000
     flap         ->  flap         =   0.00000
     aileron      ->  Cl roll mom  =   0.00000
     elevator     ->  Cm pitch mom =   0.00000
     rudder       ->  Cn yaw mom   =   0.00000

     alpha     =   2.31230      deg
     beta      =   0.00000      deg
     pb/2V     =   0.00000
     qc/2V     =  -0.361446E-15
     rb/2V     =   0.00000
     CL        =   0.312309
     CDo       =   0.420000E-01
     bank      =   0.00000      deg
     elevation =   0.00000      deg
     heading   =   0.00000      deg
     Mach      =   0.00000
     velocity  =   312.000      ft/s
     density   =   0.176000E-02 slug/ft^3
     grav.acc. =   32.0000      ft/s^2
     turn_rad. =   0.00000      ft
     load_fac. =   1.00000
     X_cg      =   2.42374
     Y_cg      =   0.00000
     Z_cg      =  -0.103875
     mass      =   800.000      slug
     Ixx       =   121787.      slug-ft^2
     Iyy       =   59146.4      slug-ft^2
     Izz       =   173515.      slug-ft^2
     Ixy       =  -0.113010E-03 slug-ft^2
     Iyz       =   0.00000      slug-ft^2
     Izx       =   1621.01      slug-ft^2
     visc CL_a =   0.00000
     visc CL_u =   0.00000
     visc CM_a =   0.00000
     visc CM_u =   0.00000

    The upper sub-block specifies the constraint associated with each
    operating parameter, and is exactly what appears at the top of the
    OPER menu.

    The lower sub-block simply lists all the current parameter values.
    If this run case was not converged before the run case file was written,
    the operating parameter values may not correspond to the specified
    constraints.  For example, the top constraint

    alpha        ->  alpha       =   4.00000

    indicates that alpha is to be driven to 4.0 degrees, so the alpha value line

     alpha     =   2.31230     deg

    is not "up to date".  The CL value line

     CL        =  0.312309

    is therefore probably not up to date either.  Such "stale" parameter
    values may or may not be of consequence.  A stale alpha or CL value
    doesn't matter, since the run case will always be converged before
    it is used for plotting, listing output, or eigenmode analysis.
    In any case, issuing the XX command in OPER before saving the
    run case file will ensure that alpha and CL are up to date.

    The dimensional parameter values related to the aircraft mass, e.g.

     density   =   1.22500     kg/m^3
     grav.acc. =   9.81000     m/s^2
     X_cg      =   2.95775
     Y_cg      =   0.00000
     Z_cg      =  0.609524
     mass      =  0.231000     kg
     Ixx       =  0.165803E-01 kg-m^2
     Iyy       =  0.113692E-01 kg-m^2
     Izz       =  0.278108E-01 kg-m^2
     Ixy       =  0.304560E-10 kg-m^2
     Iyz       = -0.135360E-10 kg-m^2
     Izx       = -0.362168E-03 kg-m^2

    may also be "stale" if the mass file which was used to create this data
    has since been modified.  The stale data can be changed to reflect the
    new mass file using the MSET command at top level.

    Finally, the velocity, turn radius, and load factor data,

     velocity  =   5.42671     m/s
     turn_rad. =   0.00000     m
     load_fac. =   1.00000

    which depends on the mass file as well as the CL, will probably
    need to be updated is the mass file is changed.  This can be
    done manually, or by using the C1 or C2 trim menus of OPER.
    """


# TODO (TBD): Implement MassProperties, very straight forward; not required. Author: BT.
class MassProperties(AVLBase):
    """Optional file giving masses and inertias, and dimensional units.

    avl_doc:
    Mass Input File -- xxx.mass
    ===========================

    This optional file describes the mass and inertia properties of the
    configuration.  It also defines units to be used for run case setup.
    These units may want to be different than those used to define
    the geometry.  Sample input xxx.mass files are in the runs/ subdirectory.


    Coordinate system
    -----------------
    The geometry axes used in the xxx.mass file are exactly the same
    as those used in the xxx.avl file.


    File format
    -----------
    A sample file for an RC glider is shown below.  Comment lines begin
    with a "#".  Everything after and including a "!" is ignored.
    Blank lines are ignored.



    #  SuperGee
    #
    #  Dimensional unit and parameter data.
    #  Mass & Inertia breakdown.

    #  Names and scalings for units to be used for trim and eigenmode calculations.
    #  The Lunit and Munit values scale the mass, xyz, and inertia table data below.
    #  Lunit value will also scale all lengths and areas in the AVL input file.
    Lunit = 0.0254 m
    Munit = 0.001  kg
    Tunit = 1.0    s

    #-------------------------
    #  Gravity and density to be used as default values in trim setup (saves runtime
    #  typing).
    #  Must be in the unit names given above (i.e. m,kg,s).
    g   = 9.81
    rho = 1.225

    #-------------------------
    #  Mass & Inertia breakdown.
    #  x y z  is location of item's own CG.
    #  Ixx... are item's inertias about item's own CG.
    #
    #  x,y,z system here must be exactly the same one used in the .avl input file
    #     (same orientation, same origin location, same length units)
    #
    #  mass   x     y     z    [ Ixx     Iyy    Izz     Ixy   Ixz   Iyz ]
    *   1.    1.    1.    1.     1.     1.      1.      1.    1.    1.
    +   0.    0.    0.    0.     0.     0.      0.      0.    0.    0.
       58.0   3.34  12.0  1.05   4400   180     4580        ! right wing
       58.0   3.34 -12.0  1.05   4400   180     4580        ! left wing
       16.0  -5.2   0.0   0.0       0    80       80        ! fuselage pod
       18.0  13.25  0.0   0.0       0   700      700        ! boom+rods
       22.0  -7.4   0.0   0.0       0     0        0        ! battery
        2.0  -2.5   0.0   0.0       0     0        0        ! jack
        9.0  -3.8   0.0   0.0       0     0        0        ! RX
        9.0  -5.1   0.0   0.0       0     0        0        ! rud servo
        6.0  -5.9   0.0   0.0       0     0        0        ! ele servo
        9.0   2.6   1.0   0.0       0     0        0        ! R wing servo
        9.0   2.6  -1.0   0.0       0     0        0        ! L wing servo
        2.0   1.0   0.0   0.5       0     0        0        ! wing connector
        1.0   3.0   0.0   0.0       0     0        0        ! wing pins
        6.0  29.0   0.0   1.0      70     2       72        ! stab
        6.0  33.0   0.0   2.0      35    39        4        ! rudder
        0.0  -8.3   0.0   0.0       0     0        0        ! nose wt.


    Units
    - - -
    The first three lines

      Lunit = 0.0254 m
      Munit = 0.001  kg
      Tunit = 1.0    s

    give the magnitudes and names of the units to be used for run case setup
    and possibly for eigenmode calculations.  In this example, standard SI units
    (m,kg,s) are chosen.  But the data in xxx.avl and xxx.mass is given in units
    of Lunit = 1 inch, which is therefore declared here to be equal to "0.0254 m".
    If the data was given in centimeters, the statement would read

      Lunit = 0.01 m

    and if it was given directly in meters, it would read

      Lunit = 1.0 m

    Similarly, Munit used here in this file is the gram, but since the kilogram (kg)
    is to be used for run case calculations, the Munit declaration is

      Munit = 0.001 kg

    If the masses here were given in ounces, the declaration would be

      Munit = 0.02835 kg

    The third line gives the time unit name and magnitude.

    If any of the three unit lines is absent, that unit's magnitude will
    be set to 1.0, and the unit name will simply remain as "Lunit",
    "Munit", or "Tunit".


    The moments of inertia and products of inertia components above are defined as

      Ixx  =  int (y^2 + z^2) dm
      Iyy  =  int (x^2 + z^2) dm
      Izz  =  int (x^2 + y^2) dm
      Ixy  =  int  x y  dm
      Ixz  =  int  x y  dm
      Iyz  =  int  x y  dm

    where the integral is over all the mass elements dm with locations x,y,z.
    The symmetric moment of inertia tensor is given in terms of these
    components as follows.

                             2
                  | 0 -z  y |          | Ixx -Ixy -Ixz |
      =           |         |          |               |
      I  =  - int | z  0 -x | dm   =   |-Ixy  Iyy -Iyz |
                  |         |          |               |
                  |-y  x  0 |          |-Ixz -Iyz  Izz |



    Constants
    - - - - -
    The 4th and 5th lines give the default gravitational acceleration and
    air density, in the units given above.  If these statements are absent,
    these constants default to 1.0, and will need to be changed manually at runtime.


    Mass, Position, and Inertia Data
    - - - - - - - - - - - - - - - - -
    A line which begins with a "*" specifies multipliers to be applied
    to all subsequent data.  If such a line is absent, these default to 1.
    A line which begins with a "+" specifies added constants to be applied
    to all subsequent data.  If such a line is absent, these default to 0.

    Lines with only numbers are interpreted as mass, position, and inertia data.
    Each such line contains values for

      mass   x     y     z      Ixx    Iyy    Izz    Ixz    Ixy    Iyz

    as described in the file comments above.  Note that the inertias are
    taken about that item's own mass centroid given by x,y,z.  The finer
    the mass breakdown, the less important these self-inertias become.
    The inertia values on each line are optional, and any ones which
    are absent will be assumed to be zero.

    Additional multiplier or adder lines can be put anywhere in the data lines,
    and these then re-define these mulipliers and adders for all subsequent lines.
    For example:

    #  mass   x     y     z      Ixx     Iyy     Izz    Ixz

    *   1.2   1.    1.    1.     1.     1.       1.     1.
    +   0.    0.2   0.    0.     0.     0.       0.     0.
       58.0   3.34  12.0  1.05   4400   180      4580    0.   ! right wing
       58.0   3.34 -12.0  1.05   4400   180      4580    0.   ! left wing

    *   1.    1.    1.    1.     1.     1.       1.     1.
    +   0.    0.    0.    0.     0.     0.       0.     0.
       16.0  -5.2   0.0   0.0        0    80        80    0.  ! fuselage pod
       18.0  13.25  0.0   0.0        0   700       700    0.  ! boom+rods
       22.0  -7.4   0.0   0.0        0     0         0    0.  ! battery


    Data lines 1-2 have all their masses scaled up by 1.2, and their locations
    shifted by delta(x) = 0.2.  Data lines 3-5 revert back to the defaults.
    """


# TODO (RvD): make simpler example
def points_in_plane(points, pt, vz, vx):
    """Transforms 3d-points to 2d-points in the plane defined by a point
    ``pt``, a normal vector ``vz`` and bi-normal vx.

    >>> from parapy.geom import Point, Vector
    >>> pts = (Point(0, 0, 2), Point(2, 0, 0), Point(2, 0, 2), Point(0, 0, 2))
    >>> ref_pt = Point(1, 0, 1)
    >>> vz = Vector(0, 1, 0)
    >>> vx = Vector(1, 0, 0)
    >>> points_in_plane(pts, ref_pt, vz, vx)
    [Point(-1.0, -1.0, 0), Point(1.0, 1.0, 0), Point(1.0, -1.0, 0), Point(-1.0, -1.0, 0)]

    :param points: sequence of Points
    :type points: collections.Sequence[(float, float, float)]
    :param Point pt: plane point
    :param Vector vz: plane normal vector ('z')
    :param Vector vx: plane normal vector ('z')
    :rtype: list[Point]
    """
    vx = _norm(vx)
    vz = _norm(vz)
    vy = _cross(vz, vx)
    return [Point(*_point_in_plane(pt_, pt, vx, vy)) for pt_ in points]


def _point_in_plane(pt, ref, v, w):
    """ref is plane point, v is x-vector, w is y-vector"""
    z = _diff(pt, ref)
    return _dot(z, v), _dot(z, w), 0


def _norm(v):
    x, y, z = v
    m = math.sqrt(x ** 2 + y ** 2 + z ** 2)
    return x / m, y / m, z / m


def _cross(v, w):
    return v[1] * w[2] - v[2] * w[1], v[2] * w[0] - v[0] * w[2], v[0] * w[1] - \
           v[1] * w[0]


def _diff(v, w):
    return v[0] - w[0], v[1] - w[1], v[2] - w[2]


def _dot(v, w):
    return v[0] * w[0] + v[1] * w[1] + v[2] * w[2]

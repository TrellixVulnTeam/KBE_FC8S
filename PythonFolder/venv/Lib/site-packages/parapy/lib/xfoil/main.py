#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2019 ParaPy Holding B.V.
#
# This code is subject to a Non-Disclosure Agreement. You have received a
# temporary copy of the ParaPy software for non-commercial, educational
# purposes only.
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import math
import os
import re as re_  # avoid name conflict ``re`` argument run_xfoil
import subprocess
import uuid

from parapy.geom import Point

from parapy.lib.xfoil import globs

__all__ = ["run_xfoil", "points_in_plane"]

_NACA_REGEX = re_.compile(r'^NACA [0-9]+$')


def create_dat_file_from_points(filename, points):
    with open(filename, 'w') as f:
        f.writelines(("{:} {:}\n".format(pt[0], pt[1]) for pt in points))


def run_xfoil(airfoil, re, alpha, mach=None, ncrit=None, norm=True,
              pane=True, xfoil_filename=None, polar_filename=None,
              log_filename=None, cleanup=True, dryrun=False):
    """Run XFoil and return cl-alpha results. Returns cl-alpha data in the
    form ``[[alpha, CL, CD, CDp, CM, Top_Xtr, Bot_Xt]), ...]``. Graphically::

        # alpha    CL        CD       CDp       CM     Top_Xtr  Bot_Xtr
        # ------ -------- --------- --------- -------- -------- --------
        [[0.000  -0.0000   0.00765   0.00222   0.0000   0.4390   0.4390],
         # ...
        [15.000   1.3568   0.02369   0.01870   0.0387   0.0979   1.0000]]

    .. note:: if you have an airfoil curve and want to get a nicely
        distributed list of points, consider using
        :func:`airfoil_spaced_points`

    .. warning:: If you provide 3D Points, only xy coordinates are used.
        The 'z' coordinate is simply ignored. When your points lie in a plane
        different from the global top-plane, consider using function
        :func:`points_in_plane` to transform from 3D to 2D.

    Basic usage:

    >>> from parapy.lib.xfoil import run_xfoil
    >>> re = 2e6
    >>> alpha = (0, 15, 1)

    >>> # from NACA library
    >>> run_xfoil("NACA 0024", re, alpha)  # doctest: +ELLIPSIS
    [[...], ...]

    >>> # from .DAT file
    >>> import os
    >>> from parapy.lib.xfoil import globs
    >>> filename = os.path.join(globs.DAT_DIR, "naca0024.dat")
    >>> run_xfoil(filename, re, alpha)  # doctest: +ELLIPSIS
    [[...], ...]

    >>> # from points
    >>> from parapy.lib.cst import CSTAirfoil
    >>> upper_coefficients = [-0.1294, -0.0036, -0.0666]  # Clark-Y airfoil
    >>> lower_coefficients = [0.206, 0.2728, 0.2292]
    >>> n = 100
    >>> obj = CSTAirfoil(upper_coefficients, lower_coefficients, n)
    >>> points = obj.points
    >>> run_xfoil(points, re, alpha)  # doctest: +ELLIPSIS
    [[...], ...]

    :param airfoil: either a complete filename, or a NACA name, or a list of
        points. So, "path/to/airfoil.dat", "NACA 0024" (with naca=True) or
        ``[Point(1, 0, 0), ... , Point(1, 0, 0)]``.
    :type airfoil: str | collections.Sequence[(float, float, float)]
    :param float re: reynolds number.
    :param alpha: alpha range, format ``(min, max, step)``.
    :type alpha: (float, float, float)
    :param mach: optional Mach number
    :type mach: None | float
    :param ncrit: optional boundary layer stability factor
    :type ncrit: None | float
    :param bool norm: should XFoil normalize the airfoil?
    :param bool pane: let XFoil smooth out the airfoil geometry.
    :param xfoil_filename: full path to XFoil executable. If None,
        'data/xfoil' executable is used.
    :type xfoil_filename: None | str
    :param polar_filename: optional filename for .pol file. If None, a
        temporary file will be created for you.
    :type polar_filename: None | str
    :param log_filename: optional filename for .log file. If None, a temporary
        file will be created for you.
    :type log_filename: None | str
    :param bool cleanup: cleanup .pol, .log and .dat (if created) files?
    :param bool dryrun: don't run XFoil, only print commands to stdout.
    :return: [[alpha, CL, CD, CDp, CM, Top_Xtr, Bot_Xt]), ...]
    :rtype: list[list[float, float, float, float, float, float, float]]
    """

    # random, unique name generator for .pol/.log/.dat files.
    uid = str(uuid.uuid4())

    # if paths are not supplied, set them at standard locations.
    if xfoil_filename is None:
        xfoil_filename = globs.XFOIL_PATH
    if polar_filename is None:
        polar_filename = uid + '.pol'
    if log_filename is None:
        log_filename = uid + '.log'

    builtin_naca = False
    datfile_created = False

    if isinstance(airfoil, str):
        # is airfoil equal to "NACA xxxx" pattern?
        if _NACA_REGEX.match(airfoil):
            builtin_naca = True
            datfile = None
        else:
            datfile = os.path.abspath(airfoil)
            if not os.path.exists(airfoil):
                msg = "Airfoil .dat file '{:}' does not exist."
                raise RuntimeError(msg.format(airfoil))
    elif hasattr(airfoil, "__iter__"):
        datfile = uid + '.dat'
        create_dat_file_from_points(datfile, airfoil)
        datfile_created = True
    else:
        msg = "Input airfoil is either str or (Point(), ...), not: {:}"
        raise RuntimeError(msg.format(repr(airfoil)))

    if os.path.exists(polar_filename):
        os.remove(polar_filename)
    if os.path.exists(log_filename):
        os.remove(log_filename)

    if not len(alpha) == 3:
        msg = "alpha should be a sequence of three numbers, not: {:}"
        raise RuntimeError(msg.format(repr(alpha)))

    ps = subprocess.Popen(xfoil_filename,
                          stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE,
                          text=True)

    if dryrun:
        def write(cmd=''):
            print(cmd)
    else:
        def write(cmd=''):
            ps.stdin.write(cmd + '\n')

    if norm:
        write("NORM")

    # Generate NACA or load from file
    if builtin_naca:
        write(airfoil)
    else:
        write('LOAD ' + os.path.relpath(datfile, os.path.abspath(".")))
        write()
        if pane:
            write("PANE")

    write('OPER')
    if ncrit is not None:
        write('VPAR')
        write('N ' + str(ncrit))
        write()
    write('Visc ' + str(re))
    if mach is not None:
        write('Mach ' + str(mach))
    write('PACC')
    write(os.path.relpath(polar_filename, os.path.abspath(".")))  # output file
    write()  # no dump file
    write('ASeq ' + " ".join(map(str, alpha)))
    write()  # escape OPER
    write('quit')  # exit

    ps.stdin.close()
    with open(log_filename, 'w') as f:
        f.write(ps.stdout.read())
    ps.stdout.close()
    ps.wait()

    try:
        results = read_logfile(polar_filename)
    except Exception as e:
        msg = ("Error while reading polar file: '{:}'.\n"
               "Check the various (logging) files for errors.\n"
               "\tPolar file: '{:}'\n"
               "\tLog file: '{:}'\n"
               "\tDat file: '{:}'")
        msg = msg.format(e, os.path.abspath(polar_filename),
                         os.path.abspath(log_filename),
                         os.path.abspath(datfile) if datfile else None)
        raise XFoilPolarReadError(msg)
    else:
        if cleanup:
            os.remove(polar_filename)
            os.remove(log_filename)
        else:
            print("Saved '{:}'".format(os.path.abspath(polar_filename)))
            print("Saved '{:}'".format(os.path.abspath(log_filename)))

        if datfile_created:
            if cleanup:
                os.remove(datfile)
            else:
                print("Saved '{:}'".format(os.path.abspath(datfile)))

        return results


def read_logfile(filename):
    with open(filename, 'r') as f:
        # read until line startswith alpha
        headers = False
        for line in f:
            if line.lstrip().startswith("alpha"):
                headers = line.split()
                break
        if not headers:
            raise Exception("logfile is empty...")
        line = next(f)
        values = line.split()
        if not all((lambda s: s.startswith("-"), values)):
            raise Exception("expected divider line ----")
        data = []
        for line in f:
            values = line.split()
            if not len(values) == len(headers):
                raise Exception("values and headers don't match...")
            else:
                data.append(list(map(float, values)))
        return data


class XFoilPolarReadError(Exception):
    pass


def points_in_plane(points, pt, vz, vx):
    """Transforms 3d-points to 2d-points in the plane defined by a point
    ``pt``, a normal vector ``vz`` and bi-normal vx.

    >>> from parapy.geom import Point, Vector
    >>> from parapy.lib.xfoil import points_in_plane
    >>> pts = (Point(0, 0, 2), Point(2, 0, 0), Point(2, 0, 2), Point(0, 0, 2))
    >>> points_in_plane(pts, Point(1, 0, 1), Vector(0, 1, 0), Vector(1, 0, 0))
    [Point(-1.0, 1.0, 0), Point(1.0, -1.0, 0), Point(1.0, 1.0, 0), Point(-1.0, 1.0, 0)]

    :param points: sequence of Points
    :type points: collections.Sequence[(float, float, float)]
    :param Point pt: plane point
    :param Vector vz: plane normal vector ('z')
    :param Vector vx: plane normal vector ('z')
    :rtype: list[Point]
    """
    vx = _norm(vx)
    vz = _norm(vz)
    vy = _cross(vx, vz)
    return [Point(*_point_in_plane(pt_, pt, vx, vy)) for pt_ in points]


def _point_in_plane(pt, ref, v, w):
    """ref is plane point, v is x-vector, w is y-vector"""
    z = _diff(pt, ref)
    return _dot(z, v), _dot(z, w), 0


def _norm(v):
    x, y, z = v
    m = math.sqrt(x ** 2 + y ** 2 + z ** 2)
    return x / m, y / m, z / m


def _cross(v, w):
    return (v[1] * w[2] - v[2] * w[1],
            v[2] * w[0] - v[0] * w[2],
            v[0] * w[1] - v[1] * w[0])


def _diff(v, w):
    return v[0] - w[0], v[1] - w[1], v[2] - w[2]


def _dot(v, w):
    return v[0] * w[0] + v[1] * w[1] + v[2] * w[2]


def cosine_spaced_points(crv, n, theta1=0., theta2=0.5 * math.pi):
    """Sample ``n`` points on Curve ``crv`` with cosine distribution, hence
    more fineness at the start: ``|| |  |   |    |     |``. Constraints:
    ``-pi/2 <= theta1 < pi/2`` and ``-pi/2 < theta2 <= pi/2``.

    >>> from parapy.geom import Point, LineSegment
    >>> from parapy.lib.xfoil import cosine_spaced_points
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> # 5 points from u1..u2
    >>> cosine_spaced_points(crv, 5)  # doctest: +ELLIPSIS
    [Point(0.0, 0.0, 0.0), ..., Point(1.0, 0.0, 0.0)]

    :param crv: curve to sample with points.
    :type crv: parapy.geom.occ.curve.Curve
    :param int n: number of points
    :param float theta1: start angle (radians)
    :param float theta2: end angle (radians)
    :rtype: list[Point]
    """
    f = crv.point
    return [f(u) for u in cosine_distribution(n, crv.u1, crv.u2, theta1=theta1,
                                              theta2=theta2)]


def sine_spaced_points(crv, n, theta1=0., theta2=0.5 * math.pi):
    """Sample ``n`` points on Curve ``crv`` with sine distribution, hence
    more fineness at the end: ``|     |    |   |  | ||``. Constraints:
    ``-pi/2 <= theta1 < pi/2`` and ``-pi/2 < theta2 <= pi/2``.

    >>> from parapy.geom import Point, LineSegment
    >>> from parapy.lib.xfoil import cosine_spaced_points
    >>> crv = LineSegment(Point(0, 0, 0), Point(1, 0, 0))
    >>> # 5 points from u1..u2
    >>> sine_spaced_points(crv, 5)  # doctest: +ELLIPSIS
    [Point(0.0, 0.0, 0.0), ..., Point(1.0, 0.0, 0.0)]

    :param crv: curve to sample with points.
    :type crv: parapy.geom.occ.curve.Curve
    :param int n: number of points
    :param float theta1: start angle (radians)
    :param float theta2: end angle (radians)
    :rtype: list[Point]
    """
    f = crv.point
    return [f(u) for u in sine_distribution(n, crv.u1, crv.u2, theta1=theta1,
                                            theta2=theta2)]


def airfoil_spaced_points(crv, n, theta1=0., theta2=math.pi):
    """Sample ``n`` (unique) points on airfoil-shaped Curve ``crv`` with
    more fineness in the middle: ``|     |    |   |  | ||| |  |   |    |
    |``. Your ``crv`` is expected to start and end at the Trailing Edge (
    TE), thus oriented TE->LE->TE in anti-clockwise fashion (up, then down).
    Constraints: ``0 <= theta1 < pi/2`` and ``pi/2 < theta2 <= pi``.

    .. note:: if you have requested an even number of ``n`` points you'll
        find n+1 points here as the TE point is double, viz. if you request
        100 points, you get 101 points back.

    >>> from parapy.lib.cst.instances import Naca0012
    >>> from parapy.lib.xfoil import airfoil_spaced_points
    >>> crv = Naca0012.curve
    >>> # 100 points from TE->TE
    >>> airfoil_spaced_points(crv, 100)  # doctest: +ELLIPSIS
    [Point(1.0, 0.0, 0.0), ..., Point(1.0, 0.0, 0.0)]

    :param crv: curve to sample with points.
    :type crv: parapy.geom.occ.curve.Curve
    :param int n: number of points
    :param float theta1: start angle (radians)
    :param float theta2: end angle (radians)
    :rtype: list[Point]
    """
    f = crv.point
    le = max(crv.extrema(crv.start), key=lambda data: data["distance"])
    u_le = le["u"]
    n_half = n // 2 + 1  # half points
    lst1 = [f(u) for u in sine_distribution(n_half, crv.u1, u_le,
                                            theta1=theta1,
                                            theta2=math.pi / 2)]
    lst2 = [f(u) for u in cosine_distribution(n_half, u_le, crv.u2,
                                              theta1=0,
                                              theta2=theta2 - math.pi / 2)]
    return lst1 + lst2[1:]


def cosine_distribution(n, l1=0., l2=1., theta1=0., theta2=0.5 * math.pi):
    """Half cosine_distribution distribution: ``|| |  |   |    |     |``.
    Constraints: ``-pi/2 <= theta1 < pi/2`` and ``-pi/2 < theta2 <= pi/2``.

    >>> from parapy.lib.xfoil.main import cosine_distribution
    >>> # 5 points from 0..1
    >>> cosine_distribution(5)
    [0.0, 0.07612046748871328, 0.2928932188134525, 0.6173165676349103, 1.0]
    >>> # 5 points from 1..2
    >>> cosine_distribution(5, l1=1.0, l2=2.0)
    [1.0, 1.0761204674887133, 1.2928932188134525, 1.6173165676349104, 2.0]
    >>> # 5 points from 0..1 between 0 and 45 degrees
    >>> cosine_distribution(5, theta2=math.radians(45))
    [0.0, 0.06560315624448676, 0.2598915324741451, 0.5753987353486459, 1.0]

    :param int n: number of points
    :param float l1: start length
    :param float l2: end length
    :param float theta1: start angle (radians)
    :param float theta2: end angle (radians)
    :rtype: list[float]
    """
    if n < 2:
        raise RuntimeError("At least 2 points.")
    sl = l2 - l1
    st = (theta2 - theta1) / (n - 1)  # angle step
    t1 = math.cos(theta1)
    t2 = math.cos(theta2)
    dt = t2 - t1
    lst = [l1 + (math.cos(theta1 + st * i) - t1) / dt * sl
           for i in range(n - 1)]
    lst.append(l2)
    return lst


def sine_distribution(n, l1=0., l2=1., theta1=0., theta2=0.5 * math.pi):
    """Half sine_distribution distribution: ``|     |    |   |  | ||``.
    Constraints: ``-pi/2 <= theta1 < pi/2`` and ``-pi/2 < theta2 <= pi/2``.

    >>> from parapy.lib.xfoil.main import sine_distribution
    >>> # 5 points from 0..1
    >>> sine_distribution(5)
    [0.0, 0.3826834323650898, 0.7071067811865475, 0.9238795325112867, 1.0]
    >>> # 5 points from 1..2
    >>> sine_distribution(5, l1=1.0, l2=2.0)
    [1.0, 1.3826834323650898, 1.7071067811865475, 1.9238795325112867, 2.0]
    >>> # 5 points from 0..1 between 0 and 45 degrees
    >>> sine_distribution(5, theta2=math.radians(45))
    [0.0, 0.275899379282943, 0.541196100146197, 0.7856949583871022, 1.0]

    :param int n: number of points
    :param float l1: start length
    :param float l2: end length
    :param float theta1: start angle (radians)
    :param float theta2: end angle (radians)
    :rtype: list[float]
    """
    if n < 2:
        raise RuntimeError("At least 2 points.")
    sl = l2 - l1
    st = (theta2 - theta1) / (n - 1)  # angle step
    t1 = math.sin(theta1)
    t2 = math.sin(theta2)
    dt = t2 - t1
    lst = [l1 + (math.sin(theta1 + st * i) - t1) / dt * sl
           for i in range(n - 1)]
    lst.append(l2)
    return lst


if __name__ == '__main__':
    re = 2e6
    alpha = (0, 15, 1)

    # from NACA library
    data = run_xfoil("NACA 0024", re, alpha)
    print(data)

    # from .DAT file
    filename = os.path.join(globs.DAT_DIR, "naca0024.dat")
    data = run_xfoil(filename, re, alpha)
    print(data)

    # from points Clark-Y airfoil
    from parapy.lib.cst import CSTAirfoil

    wl = [-0.1294, -0.0036, -0.0666]
    wu = [0.206, 0.2728, 0.2292]
    N = 100
    obj = CSTAirfoil(wl, wu, N)
    points = obj.points
    data = run_xfoil(points, re, alpha)  # doctest: +ELLIPSIS
    print(data)

    from math import sqrt
    from parapy.geom import Vector

    # let's define a plane rotated by 45 degrees around 'z'
    ref, vz, vx = Point(0, 0, 0), Vector(0, 0, 1), Vector(1, 1, 0)

    # let's place two points in global space aligned with new 'x' axis.
    a = sqrt(2) / 2
    pts1 = [Point(a, a, 0), Point(2 * a, 2 * a, 0)]
    print(pts1)

    # project points in plane
    pts2 = points_in_plane(pts1, ref, vz, vx)
    print(pts2)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Slot widgets for property grid"""

import logging
import warnings
from dataclasses import is_dataclass
from functools import partial
from itertools import compress
from typing import Tuple, Type, Union

import wx
from wx import propgrid as wxpg

import parapy.core.widgets as ppwidgets
from parapy.core.abstract import ParaPyObject
from parapy.core.abstractbase import AbstractBase
from parapy.core.decorators import Action
from parapy.core.globs import Undefined
from parapy.gui import wx34
from parapy.gui.actions import ViewerSelection
from parapy.gui.events import create_refresh_event
from parapy.gui.utilities import parse_point, parse_position, truncate
from parapy.gui.wx_utils import StatusBarMessage

__all__ = ["WIDGET_FACTORY"]

# roughly at the amount of characters after which text will stop
# showing up in the TextCtrl due to a bug in wx
WX_TXTCTRL_CHAR_LIMIT = 4000

PGEditorType = Type[wx34.PGEditor]


class NoWidgetError(RuntimeError):
    def __init__(self, obj, *args, **kwargs):
        msg = ("No widget available for object {!r}. Extend behavior of "
               "WidgetFactory.create_widget().").format(obj)
        super(NoWidgetError, self).__init__(msg, *args, **kwargs)


class UnregisteredCoreWidgetError(RuntimeError):
    def __init__(self, cls_core_widget, *args, **kwargs):
        msg = ("Widget class {!r} not registered. "
               "Call WIDGET_FACTORY.register() first.").format(cls_core_widget)
        super(UnregisteredCoreWidgetError, self).__init__(msg, *args, **kwargs)


class ConversionError(RuntimeError):
    def __init__(self, wx_value, *args, **kwargs):
        string = repr(wx_value)
        # get rid of unicode "u'value'" style
        if string.startswith("u'") and string.endswith("'"):
            string = string[1:]
        msg = "Can't convert user value {}.".format(string)
        super(ConversionError, self).__init__(msg, *args, **kwargs)


class WidgetFactory(object):
    """Factory that can create a :class:`Widget` instance from a
    :class:`parapy.core.widgets.Widget` through :meth:`create_widget`. Mapping
    between core and gui widget classes have to be pre-registered using
    :meth:`register`.
    """

    def __init__(self, default_slot_widget_class):
        """
        :type default_slot_widget_class: type[parapy.gui.widgets.SlotWidget]
        """
        #: type: dict[type[parapy.core.widgets.Widget], type[parapy.gui.widgets.Widget]]
        self._core_to_gui_class = {}
        self.default_slot_widget_class = default_slot_widget_class

    def create_widget(self, grid, obj, key):
        """
        :param wxpg.PropertyGrid grid: owner of this widget.
        :param parapy.core.widgets.Widget obj: Parapy object currently
            displayed in :class:`parapy.gui.data.DataPanel`.
        :param key: accessor to reach child item from ``obj``, idx for
            container types, regular key for mapping types, attr for
            AbtractBase.
        :rtype: Widget
        """
        if isinstance(obj, AbstractBase):
            slot = getattr(type(obj), key)

            if isinstance(slot, Action):
                cls_gui_widget = ButtonWidget
            else:  # AbstractSlot
                core_widget = slot.widget  # can be None?
                cls_gui_widget = self._get_cls_slot_widget(core_widget)

            return cls_gui_widget(grid, obj, key)
        elif isinstance(obj, ParaPyObject):
            return MappingWidget(grid, obj, key)
        elif isinstance(obj, dict):
            return MappingWidget(grid, obj, key)
        elif is_dataclass(obj):
            return MappingWidget(grid, obj, key)
        elif hasattr(obj, "__iter__"):
            return ContainerWidget(grid, obj, key)
        else:
            raise NoWidgetError(obj)

    def register(self, cls_core_widget, cls_gui_widget):
        """
        :type cls_core_widget: type[parapy.core.widgets.Widget
        :type cls_gui_widget: type[parapy.gui.widgets.Widget]]
        :return:
        """
        self._core_to_gui_class[cls_core_widget] = cls_gui_widget

    def _get_cls_slot_widget(self, core_widget):
        if not core_widget:
            return self.default_slot_widget_class

        cls_core_widget = type(core_widget)
        try:
            return self._core_to_gui_class[cls_core_widget]
        except KeyError:
            raise UnregisteredCoreWidgetError(cls_core_widget)


class Widget(object):
    """Standard widget for property grid widgets in ParaPy wxPython GUI. It
    can represent a Python value in its EVALUATED state.
    """

    EVALUATED = 'evaluated'
    UNEVALUATED = 'unevaluated'
    MISSING = 'missing'
    ERROR = 'error'

    DEFAULT_BG_COLOR = (255, 255, 255)

    #: Set to ``True`` if the widget can be evaluated (by double clicking in
    #: the grid), ``False`` otherwise.
    evaluable = True

    #: Set to ``True`` if the value behind the widget is allowed to be
    #: inspected, `False` otherwise.
    inspectable = True

    def __init__(self, grid, obj, key):
        #: :type: wxpg.PropertyGrid
        self.grid = grid
        #: :type: parapy.core.abstractbase.AbstractBase
        self.obj = obj
        #: accessor to reach child item from obj
        self.key = key
        #: data panel
        self.panel = grid.Parent

        # --- data set by .create_wxpg_property() ---
        #: EVALUATED, UNEVALUATED, MISSING, ERROR
        self.state = None
        #: current value
        self.value = None
        #: :type: wx.propgrid.PGProperty wxpg_property
        self.wxpg_property = None
        #: Is widget in a fallback state?
        self.falling_back = False

    @property
    def name(self):
        return self.key

    @property
    def label(self):
        return self.key

    def do_create_wxpg_property(self, state, value, fallback=False):
        if fallback:
            prop = self.create_fallback_property(state, value)
        else:
            prop = self.create_wxpg_property(state, value)

        self.wxpg_property = prop
        self.state = state
        self.value = value
        self.falling_back = fallback
        return prop

    def create_wxpg_property(self, state, value):
        """
        :param state: EVALUATED, UNEVALUATED, MISSING or ERROR
        :param value: Python value
        :return:
        """
        if state is not self.EVALUATED:
            raise ValueError("Only ``state is EVALUATED`` allowed")

        wx_value = self.py_to_wx_value(value)
        prop = self.create_wxpg_property_evaluated(wx_value)
        self.apply_evaluated_style(prop)
        return prop

    def create_wxpg_property_evaluated(self, wx_value):
        """Create wx.propgrid.PGProperty to show ``value``.

        :param wx_value: value to display
        :rtype: wx.propgrid.PGProperty
        """
        return StringProperty(self.label, self.name, wx_value)

    def apply_evaluated_style(self, wxpg_property):
        wxpg_property.Enable(False)

    def create_fallback_property(self, state, value):
        # the most basic thing that "always" should work
        return StringProperty(self.label, self.name, repr(value))

    def do_wx_to_py_value(self, wx_value):
        return self.wx_to_py_value(wx_value)

    def wx_to_py_value(self, wx_value):
        return wx_value

    def py_to_wx_value(self, py_value):
        return repr(py_value)

    def editor(self) -> Union[Tuple[PGEditorType], None]:
        """Return :class:`wx.propgrid.PGEditor` classes that can be used in
        call to ``propgrid.RegisterEditor(editor)`` or ``None`` to skip.
        """
        return StaticTextCtrlEditor, DisabledTextCtrlAndButtonEditor

    def enable(self, flag=True):
        self.wxpg_property.Enable(flag)

    def do_update(self, state, value):
        if self.falling_back:
            prop = self.do_create_wxpg_property(state, value)
        else:
            prop = self.update(state, value)
        self.state = state
        self.value = value
        return prop

    def update(self, state, value):
        """Update :attr:`wxpg_property` here.

        :rtype: wx.propgrid.PGProperty
        """
        return self.wxpg_property


class ButtonMixin(object):
    # disable evaluation and inspection since a button has no relation to the
    # value below.
    evaluable = False
    inspectable = False

    def editor(self) -> Union[Tuple[PGEditorType], None]:
        return ButtonEditor,

    def call_onclick(self):
        with StatusBarMessage(self.grid, "Busy"):
            with wx.BusyCursor():
                return self.onclick()

    def create_button_property(self):
        prop = ButtonProperty(
            self.call_onclick, self.button_label, self.label, self.name)
        return prop


class ButtonWidget(ButtonMixin, Widget):
    """Creates ButtonProperty that evaluates method under ``obj.key``.

    :attr int attr: is an index.
    """

    def __init__(self, grid, obj, key):
        Widget.__init__(self, grid, obj, key)
        # name if for consistency with SlotWidget
        #: :type: parapy.core.decorators.Action
        slot = getattr(type(obj), key)
        self.slot = slot

    @property
    def label(self):
        return self.slot.label

    @property
    def button_label(self):
        return self.slot.button_label

    def onclick(self):
        action = self.slot
        action.call(self.obj)
        if action.refresh:
            self.post_refresh()

    def post_refresh(self):
        event = create_refresh_event(self)
        wx.PostEvent(self.panel, event)

    def create_wxpg_property_evaluated(self, wx_value):
        return self.create_button_property()

    def apply_evaluated_style(self, wxpg_property):
        pass


class ContainerWidget(Widget):
    """Creates wxpg Property for list, tuples and other container types.

    :attr int attr: is an index.
    """
    evaluable = False  # the values are already evaluated

    @property
    def name(self):
        return str(self.key)  # key is an index

    @property
    def label(self):
        return str(self.key)  # key is an index


class MappingWidget(ContainerWidget):
    """Creates wxpg Property for list, tuples and other container types"""

    def __init__(self, grid, obj, idx):
        super(ContainerWidget, self).__init__(grid, obj, idx)

    @property
    def name(self):
        return str(self.key)

    @property
    def label(self):
        return repr(self.key)


class SlotWidget(Widget):
    """Base class for all property grid widgets in ParaPy wxPython GUI
    associated to an :class:`~parapy.core.abstractslot.AbstractSlot`.

    :param str name: name of this widget (label in first cell propgrid)
    :param parapy.core.widgets.Widget obj: Parapy object currently displayed
        in :class:`parapy.gui.data.DataPanel`.
    :param parapy.core.abstractslot.AbstractSlot slot: slot for which this
        Widget should be created.
    :param parapy.core.widgets.Widget core_widget: user-defined widget
        instance living in ``parapy.core`` package.
    :param wx.propgrid.PGProperty wxpg_property: wx PGProperty used in
        wx.PropertyGrid.
    """

    LABEL_UNEVALUATED = "<double-click to evaluate>"
    LABEL_MISSING = "<fill out required value>"
    LABEL_ERROR = "<error occurred>"

    def __init__(self, grid, obj, attr):
        super(SlotWidget, self).__init__(grid, obj, attr)

        #: :type: parapy.core.abstractslot.AbstractSlot
        self.slot = getattr(type(obj), attr)
        #: :type: parapy.core.widgets.Widget
        self.core_widget = self.slot.widget
        #: callable to eval() user string
        globals_ = self.panel.globals
        if globals_:
            eval_ = lambda s: eval(s, globals_)
        else:
            eval_ = eval
        self.eval = eval_

    @property
    def enabled(self):
        return (not self.core_widget.read_only) and self.slot.settable

    @property
    def autocompute(self):
        return self.core_widget.autocompute

    @property
    def label(self):
        slot = self.slot
        if slot.label:
            return slot.label  # + " ({})".format(attr)
        else:
            return super(SlotWidget, self).name

    @property
    def fallback_widget_cls(self):
        return SlotWidget  # needs to be dynamic, otherwise will not resolve

    @property
    def fallback_widget(self):
        try:
            return self.__fallback_widget
        except AttributeError:
            fallback_widget = self.create_fallback_widget()
            self.__fallback_widget = fallback_widget
            return fallback_widget

    @fallback_widget.deleter
    def fallback_widget(self):
        del self.__fallback_widget

    def create_fallback_widget(self):
        return self.fallback_widget_cls(self.grid, self.obj, self.key)

    def create_wxpg_property(self, state, value):
        """
        :param state: EVALUATED, UNEVALUATED, MISSING or ERROR
        :param py_value: Python value, None or Exception
        :return:
        """
        if state is SlotWidget.EVALUATED:
            wx_value = self.py_to_wx_value(value)
            prop = self.create_wxpg_property_evaluated(wx_value)
            self.apply_evaluated_style(prop)
        elif state is SlotWidget.UNEVALUATED:
            prop = self.create_wxpg_property_unevaluated(value)
        elif state is SlotWidget.MISSING:
            prop = self.create_wxpg_property_missing_required_input(value)
        elif state is SlotWidget.ERROR:
            prop = self.create_wxpg_property_error(value)
        else:
            raise ValueError("state {!r} not valid".format(state))

        return prop

    def update(self, state, value):
        """Update :attr:`wxpg_property` here.

        :rtype: wx.propgrid.PGProperty
        """
        prop = self.wxpg_property
        old_state = self.state
        old_value = self.value

        if state is old_state and value is old_value:
            return prop

        if state is old_state is SlotWidget.EVALUATED:
            wx_value = self.py_to_wx_value(value)
            prop.SetValue(wx_value)
        else:
            prop = self.create_wxpg_property(state, value)

        return prop

    def create_wxpg_property_unevaluated(self, value=None):
        """Create PGProperty that can show an unevaluated slot, ``value``
        is not relevant for now, just there for API consistency.

        :param value: nothing relevant about it, just for API consistency
        :rtype: wx.propgrid.PGProperty
        """
        prop = wxpg.StringProperty(self.label, self.name)
        self.apply_unevaluated_style(prop)
        return prop

    def create_wxpg_property_missing_required_input(self, exception):
        """Create wx.propgrid.PGProperty, where ``label`` and ``name`` map on
        respective arguments in ``PGProperty.__init__(self, String label,
        String name)``, ``value`` is MissingRequiredInput object.

        :type exception: parapy.core.exceptions.MissingRequiredInput
        :rtype: wx.propgrid.PGProperty
        """
        prop = wxpg.StringProperty(self.label, self.name)
        self.apply_missing_style(prop)
        return prop

    def create_wxpg_property_error(self, exception):
        """Create wx.propgrid.PGProperty, where ``label`` and ``name`` map on
        respective arguments in ``PGProperty.__init__(self, String label,
        String name)``, ``value`` is Exception object.

        :type exception: Exception
        :rtype: wx.propgrid.PGProperty
        """
        prop = wxpg.StringProperty(self.label, self.name)
        self.apply_error_style(prop)
        return prop

    def create_fallback_property(self, state, value):
        fallback_widget = self.fallback_widget
        if self.falling_back:
            # previous widget was also created by the fallback widgets
            # so we can use its update method
            return fallback_widget.update(state, value)
        else:
            return fallback_widget.create_wxpg_property(state, value)

    def apply_evaluated_style(self, wxpg_property):
        wxpg_property.Enable(self.enabled)

    def apply_unevaluated_style(self, wxpg_property):
        wxpg_property.SetValue(self.LABEL_UNEVALUATED)
        wxpg_property.Enable(False)

    def apply_missing_style(self, wxpg_property):
        wxpg_property.SetValue(self.LABEL_MISSING)
        self._apply_error_style(wxpg_property)
        wxpg_property.Enable(self.enabled)

    def apply_error_style(self, wxpg_property):
        wxpg_property.SetValue(self.LABEL_ERROR)
        self._apply_error_style(wxpg_property)
        wxpg_property.Enable(False)

    def _apply_error_style(self, wxpg_property):
        self._color_cell(wxpg_property, 0, fg_color=wx.WHITE, bg_col=wx.RED)
        # bg_col=wx.WHITE, otherwise black background
        self._color_cell(wxpg_property, 1, fg_color=wx.RED, bg_col=wx.WHITE)

    def _color_cell(self, wxpg_property, i, fg_color=None, bg_col=None):
        cell = wxpg_property.GetCell(i)
        if fg_color:
            cell.SetFgCol(fg_color)
        if bg_col:
            cell.SetBgCol(bg_col)

    def reset_style(self, wxpg_property):
        wxpg_property = wxpg_property
        name = wxpg_property.GetName()
        self.grid.SetPropertyColoursToDefault(name)
        wxpg_property.Enable(True)

    def do_wx_to_py_value(self, wx_value):
        if self.falling_back:
            return self.fallback_widget.wx_to_py_value(wx_value)
        else:
            return self.wx_to_py_value(wx_value)

    def wx_to_py_value(self, wx_value):
        return self.wx_to_py_value_eval(wx_value)

    def wx_to_py_value_eval(self, wx_value):
        """Conversion based on eval() of user string"""
        string = str(wx_value)
        eval = self.eval

        try:
            return eval(string)
        except Exception:
            cur_value = self.value
            value = self.non_literal_conversion(string, cur_value)
            if value is not Undefined:  # couldn't convert
                return value

        raise ConversionError(string)

    @staticmethod
    def non_literal_conversion(string, old_val):
        """
        :param str string: string the user entered for conversion
        :param old_val: current value of this slot
        :return:
        """
        # TODO (FT): Hardcoded implementation for now. Try to implement a
        # /todo more general (registration based?) approach.
        # try if it is a point
        if 'Position' in string:
            pos = parse_position(string)
            if pos:
                if isinstance(old_val, pos.__class__):  # is Position
                    pos.orientation = old_val.orientation
                return pos
        elif 'Point' in string:
            pt = parse_point(string)
            if pt:
                return pt
        return Undefined


class PyField(SlotWidget):

    #: :type: parapy.core.widgets.PyField
    core_widget = None

    def __init__(self, grid, obj, attr):
        super(PyField, self).__init__(grid, obj, attr)

        eval_ = self.core_widget.eval
        if eval_ is not eval:
            self.eval = eval_

    # Override SlotWidget's, because we use our own StringProperty (not wxpg's)
    def create_wxpg_property_evaluated(self, wx_value):
        return StringProperty(self.label, self.name, wx_value)

    def create_wxpg_property_unevaluated(self, value=None):
        prop = StringProperty(self.label, self.name, self.LABEL_UNEVALUATED)
        self.apply_unevaluated_style(prop)
        return prop

    def create_wxpg_property_missing_required_input(self, exception):
        prop = StringProperty(self.label, self.name, self.LABEL_MISSING)
        self.apply_missing_style(prop)
        return prop

    def create_wxpg_property_error(self, exception):
        prop = StringProperty(self.label, self.name, self.LABEL_ERROR)
        self.apply_error_style(prop)
        return prop

    @property
    def background_color(self):
        color = self.core_widget.background_color
        if callable(color):
            try:
                color = color(self.obj)
            except Exception as e:
                logging.warning(e)
                color = self.DEFAULT_BG_COLOR
        if color is None:
            color = self.DEFAULT_BG_COLOR
        return color

    def apply_evaluated_style(self, wxpg_property):
        super(PyField, self).apply_evaluated_style(wxpg_property)
        self.apply_evaluated_dynamic_style(wxpg_property)

    def apply_evaluated_dynamic_style(self, wxpg_property):
        bg_col = self.background_color
        self._color_cell(wxpg_property, 1, bg_col=bg_col)

    def update(self, state, value):
        prop = self.wxpg_property

        old_state = self.state
        old_value = self.value

        same_state = state is old_state
        same_value = value is old_value

        if same_state and same_value:
            if state is SlotWidget.EVALUATED:
                self.apply_evaluated_dynamic_style(prop)
            return prop

        if state is not old_state:
            self.reset_style(prop)

        if state is SlotWidget.EVALUATED:
            if not same_state or not same_value:
                wx_value = self.py_to_wx_value(value)
                prop.SetValue(wx_value)
            self.apply_evaluated_style(prop)
        elif state is SlotWidget.UNEVALUATED:
            self.apply_unevaluated_style(prop)
        elif state is SlotWidget.MISSING:
            self.apply_missing_style(prop)
        elif state is SlotWidget.ERROR:
            self.apply_error_style(prop)
        else:
            raise ValueError("state {!r} not valid".format(state))

        return prop


# TODO (TBD): support runtime switching of core_widget.multiline attribute
class TextField(SlotWidget):

    #: :type: parapy.core.widgets.TextField
    core_widget = None

    def wxpg_property_class(self):
        if self.core_widget.multi_line:
            return wxpg.LongStringProperty
        else:
            return wxpg.StringProperty

    def create_wxpg_property_evaluated(self, wx_value):
        cls = self.wxpg_property_class()
        return cls(self.label, self.name, wx_value)

    def create_wxpg_property_unevaluated(self, value=None):
        cls = self.wxpg_property_class()
        prop = cls(self.label, self.name, self.LABEL_UNEVALUATED)
        self.apply_unevaluated_style(prop)
        return prop

    def create_wxpg_property_missing_required_input(self, exception):
        cls = self.wxpg_property_class()
        prop = cls(self.label, self.name, self.LABEL_MISSING)
        self.apply_missing_style(prop)
        return prop

    def create_wxpg_property_error(self, exception):
        cls = self.wxpg_property_class()
        prop = cls(self.label, self.name, self.LABEL_ERROR)
        self.apply_error_style(prop)
        return prop

    @property
    def background_color(self):
        color = self.core_widget.background_color
        if callable(color):
            try:
                color = color(self.obj)
            except Exception as e:
                logging.warning(e)
                color = None
        return color

    def apply_evaluated_style(self, wxpg_property):
        super(TextField, self).apply_evaluated_style(wxpg_property)
        self.apply_evaluated_dynamic_style(wxpg_property)

    def apply_evaluated_dynamic_style(self, wxpg_property):
        bg_col = self.background_color
        self._color_cell(wxpg_property, 1, bg_col=bg_col)

    def update(self, state, value):
        prop = self.wxpg_property

        old_state = self.state
        old_value = self.value

        same_state = state is old_state
        same_value = value is old_value

        if same_state and same_value:
            if state is SlotWidget.EVALUATED:
                self.apply_evaluated_dynamic_style(prop)
            return prop

        if state is not old_state:
            self.reset_style(prop)

        if state is SlotWidget.EVALUATED:
            if not same_state or not same_value:
                wx_value = self.py_to_wx_value(value)
                prop.SetValue(wx_value)
            self.apply_evaluated_style(prop)
        elif state is SlotWidget.UNEVALUATED:
            self.apply_unevaluated_style(prop)
        elif state is SlotWidget.MISSING:
            self.apply_missing_style(prop)
        elif state is SlotWidget.ERROR:
            self.apply_error_style(prop)
        else:
            raise ValueError("state {!r} not valid".format(state))

        return prop

    def wx_to_py_value(self, wx_value):
        return str(wx_value)  # convert from unicode

    def py_to_wx_value(self, py_value):
        return py_value


class Dropdown(SlotWidget):

    #: :type: parapy.core.widgets.Dropdown
    core_widget = None

    def __init__(self, parent, obj, slot):
        super(Dropdown, self).__init__(parent, obj, slot)
        self._py_values = self.core_widget.values

    def create_wxpg_property_evaluated(self, wx_value):
        label, name, core_widget = self.label, self.name, self.core_widget

        values = core_widget.values
        labels = core_widget.labels

        # convert python values to indices (that is what EnumProperty wants)
        values = list(range(len(values)))

        return wxpg.EnumProperty(
            label, name, labels, values, wx_value)

    def wx_to_py_value(self, wx_value):
        if self.state is Widget.EVALUATED:  # wx_value is int (idx)
            return self._py_values[wx_value]
        else:
            value = self.wx_to_py_value_eval(wx_value)
            if value not in self._py_values:
                msg = "Value {!r} not one of {!r}"
                raise ValueError(msg.format(value, self._py_values))
            return value

    def py_to_wx_value(self, py_value):
        return self._py_values.index(py_value)


class FilePicker(SlotWidget):
    #: :type: parapy.core.widgets.FilePicker
    core_widget = None

    def create_wxpg_property_evaluated(self, wx_value):
        """:type core_widget: parapy.core.widgets.FilePicker"""
        label, name, core_widget = self.label, self.name, self.core_widget

        prop = wxpg.FileProperty(label, name, wx_value)

        wildcard = core_widget.wildcard
        if wildcard:
            prop.SetAttribute(wxpg.PG_FILE_WILDCARD, wildcard)

        title = core_widget.title
        if title:
            prop.SetAttribute(wxpg.PG_FILE_DIALOG_TITLE, title)

        # when set to None, will show absolute path
        relative_to_dir = core_widget.relative_to_dir
        if relative_to_dir:
            prop.SetAttribute(wxpg.PG_FILE_SHOW_RELATIVE_PATH,
                              relative_to_dir)

        full_path = core_widget.full_path
        prop.SetAttribute(wxpg.PG_FILE_SHOW_FULL_PATH, full_path)

        default_dir = core_widget.default_dir
        if default_dir:
            prop.SetAttribute(wxpg.PG_FILE_INITIAL_PATH, default_dir)

        return prop

    def wx_to_py_value(self, wx_value):
        return wx_value

    def py_to_wx_value(self, py_value):
        return py_value


class CheckBox(SlotWidget):
    #: :type: parapy.core.widgets.CheckBox
    core_widget = None

    @property
    def checked_value(self):
        return self.core_widget.checked_value

    @property
    def unchecked_value(self):
        return self.core_widget.unchecked_value

    def create_wxpg_property_evaluated(self, wx_value):
        label, name, core_widget = self.label, self.name, self.core_widget
        prop = wxpg.BoolProperty(label, name, wx_value)
        prop.SetAttribute('UseCheckbox', True)
        return prop

    def wx_to_py_value(self, wx_value):
        checked_value = self.checked_value
        unchecked_value = self.unchecked_value
        if self.state is Widget.EVALUATED:
            return checked_value if wx_value else unchecked_value
        else:
            # convert to a python value, it was manually entered in a different
            # state than 'evaluated'
            try:
                wx_value = self.wx_to_py_value_eval(wx_value)
            except Exception:
                raise ConversionError(wx_value)
            else:
                if wx_value == checked_value or wx_value == unchecked_value:
                    return wx_value
                else:
                    msg = ("Provided value {!r} is not the checked value: "
                           "{!r} nor the unchecked value: {!r}. Please "
                           "specify one of these.")
                    raise ValueError(msg.format(wx_value, checked_value,
                                                unchecked_value))

    def py_to_wx_value(self, py_value):
        if py_value == self.checked_value:
            return True
        elif py_value == self.unchecked_value:
            return False
        else:
            msg = ("The value {!r} set on slot {} is not the "
                   "checked value: {!r} nor the unchecked value: {!r}. "
                   "Please specify one of these. Object: {}")
            raise ValueError(msg.format(py_value, self.slot,
                                        self.checked_value,
                                        self.unchecked_value, self.obj))


class ColorPicker(SlotWidget):
    #: :type: parapy.core.widgets.ColorPicker
    core_widget = None

    @property
    def system(self):
        return self.core_widget.system

    def create_wxpg_property_evaluated(self, wx_value):
        label, name = self.label, self.name
        if self.system:
            prop = wxpg.SystemColourProperty(label, name, wx_value)
        else:
            prop = wxpg.ColourProperty(label, name, wx_value)
        return prop

    def wx_to_py_value(self, wx_value):
        """
        :type wx_value: wx.Colour | wxpg.ColourPropertyValue
        """
        if self.system:
            #: type wx_value: ColourPropertyValue
            wx_value = wx_value.m_colour

        return wx_value.Get()[:3]  # ( r, g, b) or (r, g, b, a )

    def py_to_wx_value(self, py_value):
        if self.system:
            if isinstance(py_value, str):
                name = py_value.upper()
                wx_color = wx.TheColourDatabase.Find(name)
            elif py_value is None:  # must be tuple
                wx_color = wx.WHITE
            else:  # must be tuple
                wx_color = wx.Colour(*py_value)
            return wxpg.ColourPropertyValue(wx_color)
        else:
            # both str and tuple are fine
            return py_value


class Button(ButtonMixin, SlotWidget):
    #: :type: parapy.core.widgets.Button
    core_widget = None

    def __init__(self, grid, obj, attr):
        SlotWidget.__init__(self, grid, obj, attr)
        # onclick(obj) -> T. Bind ``obj`` here.
        self.onclick = partial(self.core_widget.onclick, obj)

    @property
    def button_label(self):
        return self.core_widget.label

    def create_wxpg_property(self, state, value):
        prop = self.create_button_property()

        if not self.enabled:
            prop.Enable(False)

        return prop

    def update(self, state, value):
        # nothing to update, never
        return self.wxpg_property


class ObjectPicker(SlotWidget):
    #: :type: parapy.core.widgets.ObjectPicker
    core_widget = None

    LABEL_MISSING = "<click button to start selection>"

    def create_wxpg_property_evaluated(self, wx_value):
        prop = self._create_wxpg_property()
        prop.SetValue(wx_value)
        return prop

    def create_wxpg_property_unevaluated(self, value=None):
        prop = self._create_wxpg_property()
        self.apply_unevaluated_style(prop)
        return prop

    def create_wxpg_property_missing_required_input(self, exception):
        prop = self._create_wxpg_property()
        self.apply_missing_style(prop)
        return prop

    def create_wxpg_property_error(self, exception):
        prop = self._create_wxpg_property()
        self.apply_error_style(prop)
        return prop

    def update(self, state, value):
        prop = self.wxpg_property

        old_state = self.state
        old_value = self.value

        same_state = state is old_state
        same_value = value is old_value

        if same_state and same_value:
            return prop

        if state is not old_state:
            self.reset_style(prop)

        if state is SlotWidget.EVALUATED:
            if not same_state or not same_value:
                wx_value = self.py_to_wx_value(value)
                prop.SetValue(wx_value)
            self.apply_evaluated_style(prop)
        elif state is SlotWidget.UNEVALUATED:
            self.apply_unevaluated_style(prop)
        elif state is SlotWidget.MISSING:
            self.apply_missing_style(prop)
        elif state is SlotWidget.ERROR:
            self.apply_error_style(prop)
        else:
            raise ValueError("state {!r} not valid".format(state))

        self.state = state
        self.value = value

        return prop

    def wx_to_py_value(self, wx_value):
        return wx_value

    def editor(self) -> Union[Tuple[PGEditorType], None]:
        return (ObjectPickerEditor,) + super(ObjectPicker, self).editor()

    def _create_wxpg_property(self):
        return ObjectPickerProperty(
            self._create_viewer_selection, self.label, self.name)

    def _create_viewer_selection(self):
        main_window = self.grid.GetTopLevelParent()
        core_widget = self.core_widget
        return ViewerSelection(main_window,
                               msg=core_widget.msg,
                               multiple=core_widget.multiple,
                               validator=core_widget.validator,
                               popup=core_widget.popup,
                               ask_confirmation=core_widget.ask_confirmation)


class MultiCheckBox(SlotWidget):
    #: :type: parapy.core.widgets.MultiCheckBox
    core_widget = None

    LABEL_UNKNOWN = "<unknown>"
    INVALID_VALUE_MSG = ("The value {!r} set on slot {!r} contains at least "
                         "one value that is not one of the options {!r} of "
                         "MultiCheckBox. Object: {!r}")

    @property
    def values(self):
        return self.core_widget.values

    @property
    def labels(self):
        return self.core_widget.labels

    @property
    def autoexpand(self):
        return self.core_widget.autoexpand

    @property
    def separator(self):
        return self.core_widget.separator

    def create_wxpg_property_evaluated(self, wx_value):
        prop = MultiCheckBoxProperty(self.label, self.name, labels=self.labels,
                                     value=wx_value,
                                     autoexpand=self.autoexpand,
                                     separator=self.separator)
        self.apply_evaluated_style(prop)
        return prop

    def create_wxpg_property_unevaluated(self, wx_value=None):
        labels = self.labels
        child_values = [self.LABEL_UNKNOWN] * len(labels)

        prop = MultiStringProperty(self.label, self.name, child_labels=labels,
                                   child_values=child_values,
                                   autoexpand=self.autoexpand)
        self.apply_unevaluated_style(prop)
        return prop

    def py_to_wx_value(self, py_value):
        checked_boxes = [(val in py_value) for val in self.values]
        self._validate_py_value(py_value)
        return checked_boxes

    def wx_to_py_value(self, wx_value):
        if self.state is Widget.EVALUATED:
            py_values = self.values
            return list(compress(py_values, wx_value))
        else:
            value = self.wx_to_py_value_eval(wx_value)
            self._validate_py_value(value)
            return value

    def _validate_py_value(self, py_value):
        values = self.values
        # we do not make a set, because some items are not hashable, but
        # can be compared/provided
        for value in py_value:
            if value not in values:
                msg = self.INVALID_VALUE_MSG
                raise ValueError(msg.format(py_value, self.slot, values,
                                            self.obj))


class SingleSelection(MultiCheckBox):
    #: :type: parapy.core.widgets.SingleSelection

    INVALID_VALUE_MSG = ("The value {!r} set on slot {!r} is not one of the "
                         "options {!r} of SingleSelection. Object: {!r}")

    @property
    def separator(self):
        return None

    def create_wxpg_property_evaluated(self, wx_value):
        prop = SingleSelectionProperty(self.label, self.name,
                                       labels=self.labels, value=wx_value,
                                       autoexpand=self.autoexpand)
        self.apply_evaluated_style(prop)
        return prop

    def py_to_wx_value(self, py_value):
        self._validate_py_value(py_value)
        values = self.values
        checked_boxes = [0] * len(values)
        checked_box_index = values.index(py_value)
        checked_boxes[checked_box_index] = 1
        return checked_boxes

    def wx_to_py_value(self, wx_value):
        if self.state is Widget.EVALUATED:
            # exactly one of the options will have value 1 because this is a
            # single-selection property
            py_values = self.values
            selected_index = wx_value.index(1)
            return py_values[selected_index]
        else:
            value = self.wx_to_py_value_eval(wx_value)
            self._validate_py_value(value)
            return value

    def _validate_py_value(self, py_value):
        values = self.values
        # we do not make a set, because some items are not hashable, but
        # can be compared/provided
        if py_value not in values:
            msg = self.INVALID_VALUE_MSG
            raise ValueError(msg.format(py_value, self.slot, values, self.obj))

    def update(self, state, value):
        prop = super(SingleSelection, self).update(state, value)
        prop.RefreshChildren()  # needed, otherwise a deselect is possible
        return prop


class StringProperty(wx34.LongStringProperty):
    #: After this amount of characters, the text will only be editable through
    #: the multiline text editor.
    #: :type: int
    _force_multiline_limit = WX_TXTCTRL_CHAR_LIMIT

    _truncation_limit = 99

    def __init__(self, label, name=wx34.WXPG_LABEL_STRING, value="",
                 truncation_limit=-1, single_line_limit=-1,
                 force_multiline_limit=-1):
        """Create a StringProperty with ``label`` and a ``name``
        showing ``value``.  After ``truncation_limit``, the displayed value
        will be truncated. After ``single_line_limit`` a button
        for a multiline editor will appear. After ``force_multiline_limit``
        the value can only be edited through the multi-line editor.

        .. caution:: due to a bug in :mod:`wx`, setting ``truncation_limit``,
            ``single_line_limit`` or ``force_multiline_limit`` to
            a higher value than ``WX_TXTCTRL_CHAR_LIMIT`` currently will
            cause the Property its TextCtrl to appear blank if ``value`` is
            longer than ``WX_TXTCTRL_CHAR_LIMIT``.

        :param str label: label of the property
        :param str name: name of the property, by default equal to its label
        :param str value: value of the property
        :param int | None truncation_limit: After this amount of characters,
            the text will show up truncated in the editor when one is not
            editing. Set to :py:`None` or ``0`` if the value should not be
            truncated. Set to ``-1`` if the class default
            (:attr:`_truncation_limit`) will be used. (default: ``-1``)
        :param int single_line_limit: After this amount of
            characters, there will be a button with a multi-line editor next
            to the value. Set to ``-1`` to use the
            applicable ``truncation_limit`` as a default (default: ``-1``).
        :param int force_multiline_limit: Force the use of the
            multi-line editor after this amount of characters. If set to
            ``-1`` it will use the class default
            (:attr:`_force_multiline_limit`). (default: ``-1``)
        :raises ValueError: when the active ``force_multiline_limit`` is
            smaller than the ``single_line_limit``. Note that if any of these
            values is not set, or set to :py:`None`, take the class-defaults
            into account for these values.
        """
        if (truncation_limit is None or
                truncation_limit > WX_TXTCTRL_CHAR_LIMIT):
            msg = ("truncation_limit '{}' was set to None or a bigger value "
                   "than WX_TXTCTRL_CHAR_LIMIT, which might cause the "
                   "Property to appear blank on values with more "
                   "characters than this limit. Object: {!r}")
            warnings.warn(msg.format(truncation_limit, self))

        if truncation_limit != -1:
            self._truncation_limit = truncation_limit

        if single_line_limit != -1:
            self._single_line_limit = single_line_limit
        else:  # take currently set value for truncation_limit
            self._single_line_limit = self._truncation_limit

        if force_multiline_limit != -1:
            self._force_multiline_limit = force_multiline_limit
            if force_multiline_limit > WX_TXTCTRL_CHAR_LIMIT:
                msg = ("force_multiline_limit '{}' was set to a bigger "
                       "value than WX_TXTCTRL_CHAR_LIMIT, which might cause "
                       "the  Property to appear blank when editing values "
                       "with more characters than this limit. Object: {!r}")
            warnings.warn(msg.format(force_multiline_limit, self))

        # check if single_line_limit < force_multiline_limit, otherwise the
        # multiline editor button is not present
        if single_line_limit is not None or force_multiline_limit is not None:
            if self._force_multiline_limit < self._single_line_limit:
                msg = ("The single_line_limit ({}) should be larger than "
                       "the force_multiline_limit ({})! Object: {!r}")
                raise ValueError(msg.format(self._single_line_limit,
                                            self._force_multiline_limit,
                                            self))

        self._trunc_cache = None
        super(StringProperty, self).__init__(label, name, value)
        # OnSetValue is not called by __init__, so manually sync
        self._sync_multiline_attributes()

    if wx34.WX_MAJOR_VERSION > 3:
        def DoGetEditorClass(self):
            return wxpg.PropertyGridInterface.GetEditorByName(self.GetEditor())

    def GetEditor(self):
        if self.GetAttribute('show_multiline'):
            if self.GetAttribute('disable_textctrl'):
                return "DisabledTextCtrlAndButtonEditor"
            else:
                return "TextCtrlAndButton"
        else:
            if self.GetAttribute('disable_textctrl'):
                return "StaticTextCtrlEditor"
            else:
                return "TextCtrl"

    def ValueToString(self, value, flags):
        want_full_value = flags & (wxpg.PG_EDITABLE_VALUE | wxpg.PG_FULL_VALUE |
                                   wxpg.PG_SETVAL_BY_USER)
        if want_full_value and len(value) <= self._force_multiline_limit:
            # under the multiline limit we do not have to truncate
            return value

        # try to get truncated value from cache
        if self._trunc_cache:
            old_val, truncated = self._trunc_cache
            if old_val == value:
                return truncated

        # not cached: truncate and cache it.
        truncated = truncate(value, self._truncation_limit)
        self._trunc_cache = value, truncated
        return truncated

    def OnSetValue(self):
        changes = self._sync_multiline_attributes()
        if any(changes):
            # if any of the attributes changed values, editor might have
            # changed, so refresh the property grid
            #: :type: wxpg.PropertyGrid
            grid = self.GetGrid()
            grid.RefreshProperty(self)

        wx34.CallSuper(self, "OnSetValue")

    def _sync_multiline_attributes(self):
        """Sync 'show_multiline' and 'disable_textctrl' attributes with
        current values and return if the values of these attributes
        changed.

        :returns: ('show_multiline' changed?, 'disable_textctrl' changed?)
        :rtype: tuple[bool, bool]
        """
        new_val_len = len(self.GetValue())

        show_multiline_changed = False
        show_multiline = new_val_len > self._truncation_limit
        if show_multiline != self.GetAttribute('show_multiline'):
            show_multiline_changed = True
            self.SetAttribute('show_multiline', show_multiline)

        disable_textctrl_changed = False
        disable_textctrl = new_val_len > self._force_multiline_limit
        if disable_textctrl != self.GetAttribute('disable_textctrl'):
            disable_textctrl_changed = True
            self.SetAttribute('disable_textctrl', disable_textctrl)

        return show_multiline_changed, disable_textctrl_changed


class ObjectPickerProperty(wx34.LongStringProperty):

    def __init__(self, viewer_selection_factory, label,
                 name=wx34.WXPG_LABEL_STRING, value=""):
        super(ObjectPickerProperty, self).__init__(label, name, value)
        self.viewer_selection_factory = viewer_selection_factory

    def OnEvent(self, propgrid, wnd_primary, event):
        if event.GetEventType() == wx.wxEVT_COMMAND_BUTTON_CLICKED:
            action = self.viewer_selection_factory()
            flag = action.start()
            if flag:
                self.SetValueInEvent(action.selected)
        return True

    def GetEditor(self):
        return "ObjectPickerEditor"

    if wx34.WX_MAJOR_VERSION > 3:
        def DoGetEditorClass(self):
            return wxpg.PropertyGridInterface.GetEditorByName(self.GetEditor())


class ButtonProperty(wx34.LongStringProperty):

    def __init__(self, onclick, button_label, label,
                 name=wx34.WXPG_LABEL_STRING, value=""):
        super(ButtonProperty, self).__init__(label, name, value)

        if wx34.WX_MAJOR_VERSION > 3:
            self.onclick = onclick
            self.button_label = button_label
            self._created_controls = False
        else:
            # we need to set them through attributes because the editor
            # receives PGProperty and not a ButtonProperty
            self.SetAttribute('onclick', onclick)
            self.SetAttribute('button_label', button_label)
            self.SetAttribute('_created_controls', False)

    def OnEvent(self, propgrid, wnd_primary, event):
        event_type = event.GetEventType()

        clicked = False
        if wx34.WX_MAJOR_VERSION > 3:
            created_controls = self._created_controls
        else:
            created_controls = self.GetAttribute('_created_controls')

        if event_type == wx.wxEVT_COMMAND_BUTTON_CLICKED:
            clicked = True
        elif event_type == wx.wxEVT_SET_FOCUS and created_controls:
            # if focus and controls are just created, we assume it is
            # equivalent to clicking the button IF the mouse is currently
            # over the button
            target = event.EventObject
            if (isinstance(target, wx.Button) and
                    target.ScreenRect.Contains(wx.GetMousePosition())):
                clicked = True

            if wx34.WX_MAJOR_VERSION > 3:
                self._created_controls = False
            else:
                self.SetAttribute('_created_controls', False)

        if clicked and not _BUTTON_LOCK.active:
            with _BUTTON_LOCK:

                if wx34.WX_MAJOR_VERSION > 3:
                    onclick = self.onclick
                else:
                    onclick = self.GetAttribute('onclick')

                result = onclick()
                wx.SafeYield()
                self.SetValueInEvent(result)
                return True

        return False

    def GetEditor(self):
        return "ButtonEditor"

    if wx34.WX_MAJOR_VERSION > 3:
        def DoGetEditorClass(self):
            return wxpg.PropertyGridInterface.GetEditorByName(self.GetEditor())


# See https://github.com/wxWidgets/wxWidgets/blob/master/src/propgrid/editors.cpp#L1648
class ButtonEditor(wx34.PGEditor):

    def DrawValue(self, dc, rect, property, text):
        renderer = wx.RendererNative.Get()
        win = property.GetGrid()
        dx = 1
        dy = 2

        rect.x += dx
        rect.y -= dy
        rect.width -= dx
        rect.height += dy

        if wx34.WX_MAJOR_VERSION > 3:
            label = property.button_label
        else:
            label = property.GetAttribute('button_label')

        # TODO (TBD): Implement hovering logic, currently the button will
        #  not react on hovering/holding the button.
        renderer.DrawPushButton(win, dc, rect)
        dc.DrawLabel(label, rect, alignment=wx.ALIGN_CENTRE)

    def OnEvent(self, propgrid, property, ctrl, event):
        """Return True if modified editor value should be committed to
        the property. To just mark the property value modified, call
        propgrid.EditorsValueWasModified().
        """
        if not ctrl:
            return False
        return True

    def UpdateControl(self, property, ctrl):
        # abstract, must be overridden. However, there is no control for us
        # to update (there's only a button), so we pass
        pass

    def CreateControls(self, propgrid, property, pos, sz):
        # print "creating controls"
        panel = propgrid.GetPanel()
        x, y = pos
        w, h = sz

        if wx34.WX_MAJOR_VERSION > 3:
            label = property.button_label
        else:
            label = property.GetAttribute('button_label')

        button = wx.Button(
            panel, wxpg.PG_SUBID1, label,
            (x, y), (w, h), wx.WANTS_CHARS)

        if wx34.WX_MAJOR_VERSION > 3:
            property._created_controls = True
            return wxpg.PGWindowList(button)
        else:
            property.SetAttribute('_created_controls', True)
            return button


class ObjectPickerEditor(wx34.PGTextCtrlEditor):

    def CreateControls(self, propgrid, property, pos, sz):
        x, y = pos
        w, h = sz

        w_button = propgrid.GetRowHeight()
        w_textctrl = w - w_button

        # Create the 'primary' textctrl editor control
        textctrl = wx34.CallSuper(
            self, "CreateControls", propgrid, property, pos, (w_textctrl, h))

        if wx34.WX_MAJOR_VERSION > 3:  # received a PGWindowList
            textctrl = textctrl.m_primary

        bitmap = self._get_bitmap()
        button = wx.BitmapButton(
            propgrid.GetPanel(), wxpg.PG_SUBID2, bitmap,
            (x + w_textctrl, y), (w_button, h), wx.WANTS_CHARS)

        if wx34.WX_MAJOR_VERSION > 3:
            return wxpg.PGWindowList(textctrl, button)
        else:
            return textctrl, button

    def _get_bitmap(self):
        return wx.ArtProvider.GetBitmap(wx.ART_GO_FORWARD)


class MultiCheckBoxProperty(wx34.PGProperty):

    def __init__(self, label, name, labels=None, value=None,
                 autoexpand=False, separator="; "):
        super(MultiCheckBoxProperty, self).__init__(label, name)
        self.label = label
        self.name = name
        self.labels = labels

        self.autoexpand = autoexpand
        self.separator = separator

        # labels need to be unique, otherwise it does not understand the
        # origin of the click, when property values change
        assert len(set(labels)) == len(labels)
        for child_label, val in zip(labels, value):
            item = wxpg.BoolProperty(child_label, child_label, val)
            item.SetAttribute("UseCheckbox", True)
            self.AddPrivateChild(item)  # use private child for wx34 compat
        self.SetValue(value)

    def GetEditor(self):
        return "StaticTextCtrlEditor"

    if wx34.WX_MAJOR_VERSION > 3:
        def DoGetEditorClass(self):
            return wxpg.PropertyGridInterface.GetEditorByName(self.GetEditor())

    def yield_children(self):
        for i in range(self.GetChildCount()):
            yield self.Item(i)

    def RefreshChildren(self):
        for child, value in zip(self.yield_children(), self.GetValue()):
            child.SetValue(value)

    def ChildChanged(self, this_value, index, child_value):
        this_value[index] = child_value
        return this_value

    def StringToValue(self, text, argFlags=0):
        return [child.GetValue() for child in self.yield_children()]

    def ValueToString(self, value, argFlags=0):
        if any(value):
            selected_labels = compress(self.labels, value)
            return self.separator.join(selected_labels)
        else:
            return "<no selection>"


class SingleSelectionProperty(MultiCheckBoxProperty):

    def __init__(self, label, name, labels=None, value=None, autoexpand=False):
        super(SingleSelectionProperty, self).__init__(
            label, name, labels=labels, value=value, autoexpand=autoexpand,
            separator=None)

    def ChildChanged(self, this_value, index, child_value):
        if child_value:
            this_value = [0] * self.GetChildCount()
            this_value[index] = child_value
        return this_value

    def ValueToString(self, value, argFlags=0):
        selected_index = value.index(1)
        return self.labels[selected_index]


class MultiStringProperty(wx34.PGProperty):
    def __init__(self, label, name, value=None, child_labels=(),
                 child_values=(), autoexpand=False):
        """Shows a parent label, value, and none or more children. The parent
        value does not depend on the child values, and vice-versa.

        :param str label: parent label
        :param str name: parent name
        :param str value: parent value
        :param collections.Sequence[str] child_labels: labels of the children
            of this property, make sure it is equal in length to
            ``child_values``.
        :param collections.Sequence[str] child_values: values of the children
            make sure this is equal in length ot ``child_labels``.
        :param bool autoexpand:
        """
        # TODO (TBD): proper error message
        assert len(child_labels) == len(child_values)

        super(MultiStringProperty, self).__init__(label, name)

        self.child_labels = child_labels
        self.child_values = child_values

        self.SetValue(value)

        self.autoexpand = autoexpand
        # create the child properties
        for label, val in zip(child_labels, child_values):
            item = wxpg.StringProperty(label, name, value=val)
            self.AddPrivateChild(item)  # use private child for wx34 compat

    def yield_children(self):
        for i in range(self.GetChildCount()):
            yield self.Item(i)

    def RefreshChildren(self):
        for child, value in zip(self.yield_children(), self.child_values):
            child.SetValue(value)

    def ChildChanged(self, this_value, index, child_value):
        self.child_values[index] = child_value
        return this_value  # parent value stays the same

    def ValueToString(self, value, argFlags=0):
        return self.GetValue()


class StaticTextCtrlEditor(wx34.PGEditor):
    """Display a text without the possibility to edit or select it"""
    def CreateControls(self, propgrid, property, pos, sz):
        # create "None" control so text becomes non-editable
        if wx34.WX_MAJOR_VERSION > 3:
            return wxpg.PGWindowList(None)
        else:
            return None


class DisabledTextCtrlAndButtonEditor(wx34.PGTextCtrlAndButtonEditor):
    def CreateControls(self, propgrid, property, pos, sz):
        # do not use CallSuper here: super works in wx4. For wx3, we emulate
        # the class in Python. Then CallSuper seems to refer to the wxpg
        # base class instead of our Python-editor.
        controls = super(DisabledTextCtrlAndButtonEditor,
                         self).CreateControls(propgrid, property, pos, sz)
        if wx34.WX_MAJOR_VERSION > 3:
            text_ctrl = controls.m_primary
        else:
            text_ctrl = controls[0]
        text_ctrl.Disable()  # disable the TextCtrl
        return controls


WIDGET_FACTORY = WidgetFactory(PyField)  # default is TextCtrl
WIDGET_FACTORY.register(ppwidgets.Dropdown, Dropdown)
WIDGET_FACTORY.register(ppwidgets.PyField, PyField)
WIDGET_FACTORY.register(ppwidgets.TextField, TextField)
WIDGET_FACTORY.register(ppwidgets.FilePicker, FilePicker)
WIDGET_FACTORY.register(ppwidgets.CheckBox, CheckBox)
WIDGET_FACTORY.register(ppwidgets.ColorPicker, ColorPicker)
WIDGET_FACTORY.register(ppwidgets.ObjectPicker, ObjectPicker)
WIDGET_FACTORY.register(ppwidgets.Button, Button)
WIDGET_FACTORY.register(ppwidgets.MultiCheckBox, MultiCheckBox)
WIDGET_FACTORY.register(ppwidgets.SingleSelection, SingleSelection)


class ButtonLock(object):
    """Lock to ensure only one button click is handled at a time"""
    __slots__ = "_active",

    @property
    def active(self):
        return self._active

    def __init__(self):
        self._active = False

    def __enter__(self):
        assert not self._active
        self._active = True

    def __exit__(self, exc_type, exc_val, exc_tb):
        assert self._active
        self._active = False


_BUTTON_LOCK = ButtonLock()


if __name__ == '__main__':
    class TestPanel(wx.Panel):

        def __init__(self, parent):
            wx.Panel.__init__(self, parent, wx.ID_ANY)

            sizer = wx.BoxSizer(wx.VERTICAL)

            # Difference between using PropertyGridManager vs PropertyGrid is
            # that the manager supports multiple pages and a description box.
            self.pg = pg = wxpg.PropertyGridManager(
                self, style=(wxpg.PG_SPLITTER_AUTO_CENTER |
                             wxpg.PG_AUTO_SORT | wxpg.PG_TOOLBAR))

            # pg.RegisterEditor(WxChoiceEditor)

            sizer.Add(pg, 1, wx.EXPAND)
            self.SetSizer(sizer)
            self.Layout()

            pg.Bind(wxpg.EVT_PG_CHANGED, self.OnPropGridChange)

        def OnPropGridChange(self, event):
            p = event.GetProperty()
            if p:
                print(repr(p.GetValue()))  # , repr(p.GetValueAsString())

    app = wx.GetApp() or wx.App()
    frame = wx.Frame(None)
    panel = TestPanel(frame)

    from parapy.core import Base, Input
    # avoid name conflict Dropdown in this module
    from parapy.core.widgets import Dropdown as Dropdown_, TextField

    class MyClass(Base):
        textfield_1 = Input(1.0)
        textfield_2 = Input(1.0, widget=TextField)
        textfield_3 = Input(1.0, widget=TextField())

        dropdown_1 = Input(1.0, widget=Dropdown_([True, 1.0, "bar", None]))
        dropdown_2 = Input(1.0, widget=Dropdown_(
            [True, 1.0, "bar", None], str=str))
        dropdown_3 = Input(1.0, widget=Dropdown_(
            [True, 1.0, "bar", None],
            labels=["True", "1", "bar", "Nothing"]))

    obj = MyClass()

    # get all Inputs local to MyClass
    slots = sorted([slot for slot in MyClass._inputs.values()
                    if slot._owner is MyClass],
                   key=lambda slot: slot._creation_counter)

    widgets = [WIDGET_FACTORY.create_widget(obj, slot) for slot in slots]
    for widget in widgets:
        wxpg_property = widget.wxpg_property
        panel.pg.Append(wxpg_property)

    frame.Show()
    app.MainLoop()

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import gc
import warnings
from itertools import chain, count

import wx

from parapy.core import Attribute, FileWriter, Input, derived, ensure_iterable
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.exceptions import ParaPyDeprecationWarning
from parapy.core.validate import OneOf
from parapy.geom import Curve, Vector
from parapy.gui import wx34
from parapy.gui.camera import (
    MinimalCamera, yield_cameras_on_path, yield_circular_sweep_cameras,
    yield_linear_sweep_cameras)
from parapy.gui.utilities import (
    generate_filenames, safe_drawable_children_generator)
from parapy.gui.viewer import new_viewer, unregister_viewer


class Image(FileWriter):
    """An image of several ParaPy objects which can be written to a file.

    Usage:

    >>> from parapy.geom import Box, Point
    >>> box = Box(1, 2, 3)
    >>> image = Image(shapes=box, fit=True)
    >>> image.write('box_default.jpg')  # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # create an image from the top-view
    >>> image = Image(shapes=box, view='top', width=300, height=300)
    >>> image.write('box_top.jpg')  # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # more complicated camera controls, top view, 45 degrees rotated
    >>> camera = MinimalCamera(viewing_center=Point(0, 0, 0),
    ...                        eye_location=Point(0, 0, 10),
    ...                        up_direction=Vector(1, 1, 0),
    ...                        scale=10, aspect_ratio=1.5)
    >>> image = Image(shapes=box, camera=camera, height=100)
    >>> image.write('box_custom_camera.gif')  # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # background
    >>> image = Image(shapes=box, background_color='black', camera=camera)
    >>> image.write('box_black_bg.jpg')  # doctest: +ELLIPSIS
    Saved image to: ...

    ..caution:: There is a problem with the garbage collection of Image
        instances. One should re-use the same Image instance as much as
        possible. A garbage collection can be forced by calling
        image.destroy().
    """

    file_or_dir = "file"
    _img_types = ('*.gif', '*.bmp', '*.jpg', '*.png', '*.pgf', '*.ps',
                  '*.emf', '*.eps', '*.tex', '*.pdf')
    wildcard = "Image files ({}) | {}".format(
        '{},{}'.format(','.join(_img_types), ','.join(_img_types).upper()),
        '{};{}'.format(';'.join(_img_types), ';'.join(_img_types).upper()))

    #: The drawable shapes of the composition.
    #: :type: parapy.geom.BRep | collections.Iterable[parapy.geom.BRep]
    shapes = Input([])

    #: ParaPy ``trees`` of the composition. The drawable children of
    #: these trees will be displayed in the image.
    #: :type: parapy.core.Base | collections.Iterable[parapy.core.Base]
    trees = Input([])

    #: Viewer in which the image composition will be made.
    #: :type: parapy.gui.viewer.Viewer
    viewer = Input(derived)

    #: Width of the image in pixels. If not specified, it will try to deduce
    #: the width
    #: from either the height in pixels and the aspect ratio of the camera,
    #: or the size of the frame that contains the viewer.
    #: :type: int
    width = Input(None)

    #: Height of the image in pixels. If not specified, it will try to deduce
    #: the height
    #: from either the width in pixels and the aspect ratio of the camera,
    #: or the size of the frame that contains the viewer. If none lead to an,
    #: image with an area, it will set the height to 100 pixels.
    #: :type: int
    height = Input(None)

    #: Using a default view to view the composition. The screen will
    #: automatically be fitted to fit all the shapes in the image. If set to
    #: None the camera will be used.
    #: :type: str
    view = Input(None, validator=OneOf(['top', 'bottom', 'left', 'right',
                                        'front', 'back', None]))

    #: Camera used for the composition.
    #: :type: parapy.gui.camera.MinimalCamera
    camera = Input(None)

    #: Image that will be used as the background for the image.
    #: :type: str
    background_image = Input(None)

    #: Color that will be used as the background for this image.
    #: :type: tuple[float, float, float] | str
    background_color = Input(None)

    #: If set to True, based on the current camera settings it will be tried
    #: to fit the composition in the image .
    #: :type: bool
    fit = Input(False)

    #: If set to True the axes system will be shown. If set to False it will
    #: not be shown. If None, the default setting will be used.
    #: :type: bool
    show_axes = Input(None)

    @viewer.getter
    def viewer(self):
        return new_viewer()

    @Attribute
    def _populated_viewer(self):
        viewer = self.viewer

        viewer.remove_all()  # otherwise the changes in shapes and trees might
                             # not be represented correctly
        # add shapes
        shapes = self.shapes
        if isinstance(shapes, DrawableParaPyObject):
            shapes = shapes,
        else:
            shapes = ensure_iterable(shapes)
        viewer.display(shapes)

        # for each ParaPy object generate all their drawable (children
        # including the object itself)
        trees = self.trees
        if trees:
            if isinstance(trees, DrawableParaPyObject):
                trees = trees,
            else:
                trees = ensure_iterable(trees)
            drawable_tree_shapes = set(
                chain(*((do for do in safe_drawable_children_generator(o))
                        for o in trees)))
            viewer.display(drawable_tree_shapes)

        return viewer

    @Attribute
    def _width(self):
        """Calculated width of the image in pixels.

        :rtype: int
        """
        if self.width is None:
            height = self.height
            if height is None:
                w, h = self._frame_client_dimensions
                if h:
                    height = h
                elif w:
                    height = w / self.camera.occ_camera.aspect_ratio
                else:  # no w or h
                    height = 100

            return int(height * self._used_camera.occ_camera.aspect_ratio)
        else:
            return self.width

    @Attribute
    def _height(self):
        """Calculated height of the image in pixels.

        :rtype: int
        """
        if self.height is None:
            width = self.width
            if width is None:
                width = self._width
            return int(width / self._used_camera.occ_camera.aspect_ratio)
        else:
            return self.height

    @Attribute
    def occ_viewer(self):
        occ_viewer = self._populated_viewer._occ_viewer

        # toggle axes if needed
        show_axes = self.show_axes
        if show_axes is not None:
            if show_axes != occ_viewer.triedron:
                occ_viewer.toggle_axes()

        # background color and image
        bg_color = self.background_color
        if bg_color is not None:
            occ_viewer.set_background_color(bg_color)

        bg_img = self.background_image
        if bg_img is not None:
            occ_viewer.set_background_image(bg_img)

        # set how we look at the shapes
        view = self.view
        if view:
            view_to_viewsetter = {
                'top': occ_viewer.view_top,
                'bottom': occ_viewer.view_bottom,
                'left': occ_viewer.view_left,
                'right': occ_viewer.view_right,
                'front': occ_viewer.view_front,
                'back': occ_viewer.view_back
            }
            view_to_viewsetter[view](fit=False)
        else:
            # set camera
            occ_viewer.camera.copy_from_camera(self._used_camera.occ_camera)

        # set viewer dimensions, these will set the image dimensions
        # must happen last because the camera settings have an influence
        # on how the width and height are calculated
        img_width = self._width
        img_height = self._height
        wx34.SetFrameSize(occ_viewer, 0, 0, img_width, img_height)

        # fit to the shapes
        if self.fit or self.view:
            occ_viewer.fit_all()

        return occ_viewer

    @Attribute
    def _used_camera(self):
        """The actual camera used for this composition (if :attr:`view` is not
        set). If :attr:`camera` is set, this one will be used. Otherwise
        the camera of :attr:`viewer` is used.

        :rtype: parapy.gui.camera.MinimalCamera
        """
        camera = self.camera
        if camera is None:
            # use OCC camera
            # A non-circularity hack: use viewer instead of occ_viewer
            occ_cam = self.viewer._occ_viewer.camera
            min_camera = MinimalCamera(eye_location=occ_cam.eye_location,
                                       viewing_center=occ_cam.viewing_center,
                                       up_direction=occ_cam.up_direction,
                                       scale=occ_cam.scale,
                                       aspect_ratio=occ_cam.aspect_ratio)
            return min_camera
        else:
            return camera

    @Attribute
    def _frame_client_dimensions(self):
        """:rtype: tuple[float, float]"""
        return self.viewer.GetParent().GetClientSize()

    def destroy(self):
        """Properly destroys the viewer of this image. Due to an
        memory leak this is necessary. Should be called
        before the image runs out of scope. Otherwise use the
        destroy_registered_viewers method in parapy.gui.viewer."""
        viewer = self.viewer

        parent = viewer.TopLevelParent
        parent.Close()

        # propagate the close command
        app = wx.GetApp()
        if app.GetMainLoop():
            while parent:  # wxpython specific: False if deleted
                wx.SafeYield()
        else:
            app.MainLoop()

        unregister_viewer(viewer)
        self.get_cache('viewer').invalidate()

        # Quick fix to make sure any Viewer that is opened directly after
        # this call will interfere with objects that are not gc'ed (and still
        # use handles that they should not)
        gc.collect()

    def write(self, filename=None, cleanup_viewer=True):
        """Write the current created composition to ``filename`` as an image.
        The image type depends on the extension of ``filename``.

        :type str filename:
        :param bool cleanup_viewer: If set to :py:`True`, it will de-allocate
            the viewer after use. If you set it to :py:`False`, do not forget
            to remove the viewer using :meth:`destroy`.
        :rtype: bool
        """
        occ_viewer = self.occ_viewer
        succes = occ_viewer.save_image(filename)

        if cleanup_viewer:
            self.destroy()

        return succes


def write_image(filename, objects, fit=False, width=None, height=None,
                view=None, camera=None, show_axes=None, display_all=False):
    """Write an image of 1 or several ``objects`` to ``filename`` using
    minimal settings. The image type is based on the extension of the
    filename (viz. '.png' creates a PNG image). If you want more advanced
    control, consider using :class:`Image`.

    >>> from parapy.geom import Box, Vector, Point
    >>> from parapy.gui.camera import MinimalCamera
    >>>
    >>> box = Box(1, 2, 3)
    >>> # set image size to 300x300, fit the shapes in the image
    >>> write_image("box_image.gif", box,
    ...             width=300, height=300, fit=True) # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # top view by name
    >>> write_image("box_top.gif", box, view='top') # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # using a camera object instead
    >>> camera = MinimalCamera(eye_location=Point(0, 0, 5),
    ...                        viewing_center=Point(0, 0, 0),
    ...                        up_direction=Vector(0, 1, 0))
    >>> write_image("box_camera.gif", box,
    ...             camera=camera, fit=True) # doctest: +ELLIPSIS
    Saved image to: ...
    >>> # no axes
    >>> write_image("box_no_axes.gif", box,
    ...             view='top', show_axes=False) # doctest: +ELLIPSIS
    Saved image to: ...

    :param str filename: File to write to. The extension (for instance .bmp or
        .gif) will decide the image format.
    :param collections.Iterable[parapy.core.Base] | parapy.core.Base objects:
        ParaPy objects to display. If they are not drawable themselves, specify
        ``display_all``.
    :param bool fit: If set to :py:`True` it will set the camera so all
        the shapes will fit in the picture exactly. (default: :py:`False`)
    :param float width: width in pixels of the image
    :param float height: height in pixels of the image
    :param str view: A standard view of the image ('top', 'bottom', 'front',
        'back', 'left', 'right'). The viewer will automatically fit the shapes
        in the composition. If this is set, the camera will be ignored.
    :param parapy.gui.camera.MinimalCamera camera: The camera used to view
        the shapes.
    :param bool show_axes: If set to :py:`False`, no axis system will be shown.
        If set to :py:`True`, the axis system will be shown. Otherwise the
        default setting is used.
    :param bool display_all: If set to :py:`True` it will display the drawable
        children of ``objs`` including ``objs`` themselves. One need to set
        this to :py:`True` if objs themselves are not drawable. (default:
        :py:`False`)
    :returns: the created image
    """
    image = Image()

    if width:
        image.width = width
    if height:
        image.height = height

    # add elements to the composition
    if display_all:
        image.trees = objects
    else:
        image.shapes = objects

    if view is not None:
        image.view = view
    elif camera is not None:
        image.camera = camera

    # if set, do something with the axes
    if show_axes is not None:
        image.show_axes = show_axes

    if fit is not None:
        image.fit = fit

    # write image
    image.write(filename)


def write_images(basename, objects, cameras, postfix_fmt='{}', start_idx=0,
                 **kwargs):
    """Instead of one, create several images, using different ``cameras``.

    >>> from parapy.geom import Box, Vector, Point
    >>> from parapy.gui.camera import MinimalCamera
    >>>
    >>> box = Box(1, 2, 3)
    >>> # define 2 cameras ('top' and 'right' view, respectively)
    >>> camera1 = MinimalCamera(eye_location=Point(0, 0, 5),
    ...                         viewing_center=Point(0, 0, 0),
    ...                         up_direction=Vector(0, 1, 0))
    >>> camera2 = MinimalCamera(eye_location=Point(5, 0, 0),
    ...                         viewing_center=Point(0, 0, 0),
    ...                         up_direction=Vector(0, 0, 1))
    >>> # set image size to 300x300, fit the shapes in the image
    >>> write_images("box_camera.gif", box, [camera1, camera2],
    ...              postfix_fmt="{:03d}", width=300, height=300, fit=True) # doctest: +ELLIPSIS
    Saved image to: ...
    Saved image to: ...

    :param str basename: base name of the file. This base name if postfixed
        with an index. So, if you give `path/to/myfile.gif`, this utility will
        create the images: `path/to/myfile_0.gif`, `path/to/myfile_1.gif`, etc.
    :param Iterable[Base] | Base objects: See :func:`write_image`.
    :param collections.Iterable[parapy.gui.camera.MinimalCamera] cameras:
        collection of cameras used to make the different images of ``objects``.
    :param str postfix_fmt: optional formatter of the image-name numbers,
        takes one integer, e.g. ``"{:03d}"``.
    :param int start_idx: default counter for filenames is 0, but can be
        changed here.
    :param kwargs: keyword arguments that are appropriate for
        the write_image utility. The ``camera`` or ``view`` keyword may not be
        given.
    """
    image = Image(**kwargs)
    display_all = kwargs.pop('display_all', False)
    if display_all:
        image.trees = objects
    else:
        image.shapes = objects

    # we use count so we do not need to know the length of cameras generator
    name_generator = generate_filenames(basename, count(start_idx),
                                        postfix_fmt=postfix_fmt)
    try:
        # although name_generator is infinite, izip stops if no cameras remain
        for cam, name in zip(cameras, name_generator):
            image.camera = cam
            # we want to create the image once, and re-use the viewer,
            # otherwise it is too slow
            image.write(filename=name, cleanup_viewer=False)
    finally:
        image.destroy()  # always destroy


def write_camera_sweep_images(basename, objects, camera1, camera2, nb,
                              path_type='circular', postfix_fmt='{}',
                              rotation_center=None, shortest_path=True,
                              **kwargs):
    """Create ``nb`` images of ``objects``. This is done by creating a
    camera sweep between ``camera1`` and ``camera2``. The camera settings of
    ``camera1`` will be used, but the eye location is moved among a path.

    Usage:

    >>> from parapy.gui.camera import MinimalCamera
    >>> from parapy.geom import Point, Box, ORIGIN
    >>> box = Box(1, 1, 1)
    >>> viewing_center = box.cog
    >>> # set up cameras
    >>> cam1 = MinimalCamera(viewing_center=viewing_center, scale=3,
    ...                      eye_location=Point(3, 3, 3))
    >>> cam2 = MinimalCamera(viewing_center=viewing_center, scale=3,
    ...                      eye_location=Point(-3, -3, 3))
    >>> # linear sweep, 5 images
    >>> write_camera_sweep_images("box_linear.gif", box, cam1, cam2, 5, rotation_center=ORIGIN,
    ...                           path_type="linear")  # doctest: +ELLIPSIS
    Saved image ...
    >>> # circular sweep, 5 images
    >>> write_camera_sweep_images("box_circular.gif", box, cam1, cam2,
    ...                           20, rotation_center=ORIGIN)  # doctest: +ELLIPSIS
    Saved image ...

    :param str basename: Name of the file. No image with this filename is
        written out, if you give `path/to/myfile.gif`, this utility will create
        the images:  `path/to/myfile_0.gif`, `path/to/myfile_1.gif`, etc.
    :param Iterable[Base] | Base objects: See ``write_image``
    :param parapy.gui.camera.MinimalCamera camera1: The camera to start the
        sweep from (see ``linear_sweep_cameras``).
    :param parapy.gui.camera.MinimalCamera camera2: The other camera in the
        sweep (see ``linear_sweep_cameras``).
    :param int nb: Amount of images (camera positions) used to
        create the sweep.
    :param str | parapy.geom.Curve path_type: either 'circular' or 'linear'
        for an interpolation based on the eye_locations of ``camera1`` and
        ``camera2``. Otherwise one can give a Curve which is used to perform
        the camera sweep.
    :param str postfix_fmt: optional formatter of the image-name numbers,
        takes one integer, e.g. ``"{:03d}"``.
    :param parapy.geom.Point rotation_center: If ``path-type`` is circular, one
        can specify the center of the circular path, otherwise the circular
        path has its center at the midpoint between the
        :attr:`~~parapy.gui.camera.MinimalCamera.viewing_center` of ``camera1``
        and ``camera2``.
    :param bool shortest_path: If ``path-type`` is circular, and this is set
        to True, it will take the shortest arc on the circle bound by the
        :attr:`~parapy.gui.camera.MinimalCamera.eye_location` of ``camera1``
        and ``camera2`` (default: :py:`True`).
    :param kwargs: keyword arguments that are appropriate for
        the write_image utility. The ``camera`` or ``view`` keyword may not be
        given.
    """
    if path_type == 'circular':
        opt_args = dict()

        if rotation_center is not None:
            opt_args['rotation_center'] = rotation_center
        else:
            msg = ("Not specfying 'rotation_center' in "
                   "write_camera_sweep_images with 'path_type == 'circular'' "
                   "is deprecated, please provide a valid rotation_point "
                   "instead!")
            warnings.warn(msg, ParaPyDeprecationWarning, stacklevel=2)

        if shortest_path is not None:
            opt_args['shortest_path'] = shortest_path
        camera_generator = yield_circular_sweep_cameras(camera1, camera2, nb,
                                                        **opt_args)
    elif path_type == 'linear':
        camera_generator = yield_linear_sweep_cameras(camera1, camera2, nb)
    elif isinstance(path_type, Curve):
        camera_generator = yield_cameras_on_path(path_type, nb,
                                                 camera1, camera2)
    else:
        msg = ("path_type {} is not supported, use either 'circular' or "
               "'linear', or provide a Curve along which the camera can move")
        raise ValueError(msg.format(repr(path_type)))

    write_images(basename, objects, camera_generator, postfix_fmt=postfix_fmt,
                 **kwargs)

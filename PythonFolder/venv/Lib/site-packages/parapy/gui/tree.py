#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""The GUI's TreePanel is defined in this module"""

from functools import partial
from operator import attrgetter

import wx
from wx.lib.mixins.treemixin import TreeHelper

from parapy.core import (
    Attribute, Base, FileReader, FileWriter, Input, Sequence)
from parapy.core.abstract import ParaPyObject
from parapy.core.abstractbase import AbstractBase
from parapy.core.decorators import Action
from parapy.core.events import broadcast_event
from parapy.core.utilities import get_rgb_value, is_iterable, running_IPython
from parapy.gui import wx34
from parapy.gui.events import (
    EVT_REFRESH, EVT_RIGHT_CLICK_TREE_OBJECT, FirstExpansionEvent,
    create_disp_event, create_refresh_event,
    create_right_click_tree_object_event, create_select_object_event)
from parapy.gui.logger import logger
from parapy.gui.menus import (
    DisplayContextMenu, get_context_menu_icon)
from parapy.gui.utilities import (
    safe_children_dictionary, safe_children_dictionary_sequence)
from parapy.gui.wx_utils import ICON_SIZE

DEF_IMG_PATH = 'default.png'
SEQ_IMG_PATH = 'sequence.png'
ERR_IMG_PATH = 'error.png'
WAR_IMG_PATH = 'warning.png'


class PathNotInTreeError(RuntimeError):
    msg = "Could not resolve path, {} is not a path in the tree."

    def __init__(self, path, msg=None):
        msg = self.msg.format(path)
        super(PathNotInTreeError, self).__init__(msg)


class TreePanel(wx.Panel):
    """This panel shows a tree of ParaPy objects.

    >>> import wx
    >>> from parapy.core import Base
    >>> from parapy.gui.tree import TreePanel
    >>>
    >>> app = wx.GetApp() or wx.App()
    >>> frame = wx.Frame(None)
    >>> obj = Base()
    >>> panel = TreePanel(frame, obj)
    >>> frame.Show()
    True
    >>> app.MainLoop()
    """

    LABEL = "Tree View"

    def __init__(self, parent, obj, globals={}):
        wx.Panel.__init__(self, parent)  # , style=wx.BORDER_SUNKEN)

        self.parent = parent
        self.obj = obj
        self.globals = globals
        self.tree = ObjectTree(self, obj, globals=globals)
        box = wx.StaticBox(self, wx.ID_ANY, self.LABEL)
        sizer = wx.StaticBoxSizer(box, wx.VERTICAL)

        self.Bind(EVT_REFRESH, self.refresh_event_handler)

        sizer.Add(self.tree, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.Layout()

    def hilight(self, path):
        self.tree.hilight(path)

    def refresh(self):
        # TODO: Don't use push, update when refresh is called
        self.tree.refresh()

    def refresh_event_handler(self, evt):
        # print "GUI.tree: received EVT_REFRESH"
        self.refresh()


class ObjectTree(wx.TreeCtrl, TreeHelper):
    """A TreeControl for showing ParaPy objects.

    The tree is constructed in a lazy fashion: only when the user digs into a branch,
    the children minimum required children are instantiated.

    Note that a child needs to be instantiated as soon as its name appears in the tree, because
    we need to check whether it has any children, for the + handle. That's why we need to know
    of which Class the child is, or whether the child is a sequence.
    """

    def __init__(self, parent, obj, globals={}, expand_first_level=True,
                 double_buffered=True):
        """
        Create a tree for the given root object. Expands the first level by default.
        """
        wx.TreeCtrl.__init__(self, parent,
                             style=wx.TR_DEFAULT_STYLE | wx.TR_TWIST_BUTTONS | wx.TR_NO_LINES)
        #                     style = wx.TR_MULTIPLE)

        self.globals = globals
        # self.TreeItemWrapper = {} # {TreeItemId: Wrapper}
        self.style_updates = {}  # dict with {branch_id: old_style}
        self.children_updates = {}  # dict with {branch_id: old}

        # self.obj_branch_id = {} # dict with {Base: branch_id, ...}
        # self.branch_id_obj = {} # dict with {branch_id: obj, ...}
        # self.collapsing = False

        self.context_menu = TreeContextMenuGeneral(
            self, add_default_items=True)
        self.context_menu_writer = TreeContextMenuWriter(
            self, add_default_items=True)
        self.context_menu_reader = TreeContextMenuReader(
            self, add_default_items=True)
        self.image_list = wx.ImageList(*ICON_SIZE)
        self.AssignImageList(self.image_list)

        # Attach some event listeners
        self.Bind(wx.EVT_TREE_ITEM_EXPANDING, self.on_expand_item)
        # self.Bind(wx.EVT_TREE_ITEM_COLLAPSING, self.on_collapse_item)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_select)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_double_click)
        self.Bind(wx.EVT_TREE_ITEM_MENU, self.on_right_click)
        self.Bind(EVT_RIGHT_CLICK_TREE_OBJECT, self.on_right_click_tree_object)
        self.Bind(wx.EVT_TREE_ITEM_MIDDLE_CLICK, self.on_middle_click)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.on_destroy)

        self.SetDoubleBuffered(double_buffered)  # against flickering

        # create initial branch and expand it
        if hasattr(obj, "__name__"):
            root_name = obj.__name__
        else:
            root_name = "root"
        self.root_object = obj
        self.root_id = self.create_branch(None, root_name, obj)
        # self.set_branch_data(self.root_id, obj)
        if expand_first_level:
            # print "expanding root node ..."
            self.Expand(self.root_id)

    def on_destroy(self, evt):
        # remove event listeners
        for child_id in self.GetItemChildren(recursively=True):
            listener = wx34.GetItemData(self, child_id)["listener"]
            if listener:
                listener.unregister()
                wx34.GetItemData(self, child_id)["listener"] = None

    def refresh(self):
        """update Base object style, update children"""

        # ------- child updates -------
        children_updates = self.children_updates
        if children_updates:
            branch_id = self.root_id
            state = self.get_expansion_state(branch_id)

            for child_id, old_children in children_updates.items():
                self._apply_children_update(child_id, old_children)

            self.restore_expansion_state(branch_id, state)
            self.children_updates = {}

        # ------- style updates -------
        for branch_id, old_style in self.style_updates.items():
            self._apply_style_update(branch_id, old_style)
        self.style_updates = {}

    # TODO: only delete specific children
    def _apply_children_update(self, branch_id, old_children=None):
        pydata = wx34.GetItemData(self, branch_id)
        if not pydata:
            return

        listener = pydata["listener"]
        if not listener:
            return

        # remove listeners children to avoid double updates (and segfaults...)
        for child_id in self.GetItemChildren(branch_id, True):
            wx34.GetItemData(self, child_id)["listener"] = None

        self.CollapseAndReset(branch_id)
        obj = wx34.GetItemData(self, branch_id)["obj"]
        has_children = self.has_children(obj)
        self.SetItemHasChildren(branch_id, has_children)
        pydata["children_evaluated"] = False

        # ==================================================================================
        # new_children = obj._children_gui
        # to_remove = dict(((k, v) for k, v in old_children.iteritems()\
        #                   if k not in new_children or v != new_children[k]))
        # to_add = dict(((k, v) for k, v in new_children.iteritems()\
        #                 if k not in old_children or v != old_children[k]))
        #
        # print "old children:", old_children
        # print "new children:", new_children
        # print "role to remove:", to_remove.keys()
        # print "role to add:", to_add.keys()
        # print "roles to keep:", list(set(new_children.keys())\
        #                              - set(to_remove.keys()) - set(to_add.keys()))
        # ==================================================================================

    def _apply_style_update(self, branch_id, old_style):
        pydata = wx34.GetItemData(self, branch_id)
        if not pydata:
            return
        wrapper = pydata["listener"]
        if not wrapper:
            return
        # path = pydata["path"]
        # print "GUI: updating style:", path
        new_style = wrapper.safe_style
        if old_style:
            # old_style might be Undefined
            style_diff = dict(((k, v) for k, v in new_style.items()
                              if k not in old_style or v != old_style[k]))
        else:
            style_diff = new_style
        self.set_branch_style(branch_id, **style_diff)

    def highlight(self, path, obj=None, expand=True, eager=True,
                  ancestor=False):
        """Highlight the item at ``path`` in tree.

        :param tuple[int | str] path: Tree path of the item that needs to be
            highlighted in the tree.
        :param object | None obj: if set, only highlights the item at ``path``
            if it is ``obj``. If set to None, it will always highlight at
            ``path``.
        :param bool expand: If the tree is not expanded until the point the
            path is found, are we allowed to expand it? (default: True)
        :param bool eager: If we are allowed to ``expand``, are we allowed
            to evaluate children that were not yet evaluated in the tree?
            (default: True)
        :param bool ancestor: If ``expand=False``, and ``ancestor=True``
            highlight the last item on ``path`` that is already expanded in
            the tree. Note that it will also highlight this item if path
            as a whole would not resolve to an item in the tree, since we
            stop checking after the part where we need to expand the tree to
            look further. If set to False, the highlighting in the tree
            will not change (default: :py:`False`)
        :raises PathNotInTreeError: If path is not in the tree, as far as
            it was allowed to search it regarding the ``expand`` and
            ``eager`` settings.
        :returns: ``True`` if the object at ``path`` could be highlighted,
            otherwise ``False``
        :rtype: bool
        """
        with ObjectTreeWalker(self) as tree_walker:
            reached_end = tree_walker.walk_to(path, expand=expand, eager=eager)

        if reached_end:
            found_branch_id = tree_walker.current_branch_id
            if obj is not None:
                item_data = tree_walker.get_item_data(found_branch_id)
                if item_data['obj'] is not obj:
                    tree_walker.restore_expansion_state()
                    return False

            # no issues, walker should be at the branch_id we were looking for
            item = tree_walker.current_branch_id
            self.SelectItem(item)
            if not self.IsVisible(item):
                # need to test IsVisible, EnsureVisible is known to scroll to
                # wrong positions when the item is already visible
                # It is known that even with this check, sometimes
                # EnsureVisible does not scroll to the correct location
                self.EnsureVisible(item)
        else:
            if ancestor:
                # current item will be the one before we got the
                # error that we could not expand any further
                self.SelectItem(tree_walker.current_branch_id)
            else:
                # we did not find a node to highlight, so restore the expansion
                # state so it looks like nothing happened
                tree_walker.restore_expansion_state()
        return reached_end

    def set_branch_style(self, branch_id, **kwargs):
        """Set the style properties of branch_id

        Args:
            branch_id (wx.TreeItemId)

        Kwargs:
            color (tuple)
            background_color (tuple)
            icon (path)
            bold (bool)
        """

        label = kwargs.pop("label", None)
        if label:
            self.SetItemText(branch_id, label)

        color = kwargs.pop("color", None)
        if color:
            self.SetItemTextColour(branch_id, wx.Colour(*map(int, color[0:3])))

        background_color = kwargs.pop("background_color", None)
        if background_color:
            self.SetItemBackgroundColour(branch_id, wx.Colour(*map(int, background_color[0:3])))

        icon = kwargs.pop("icon", None)
        if icon:
            bitmap = get_context_menu_icon(icon)
            if bitmap:
                img = self.image_list.Add(bitmap)
                self.SetItemImage(branch_id, img, wx.TreeItemIcon_Normal)

        bold = kwargs.pop("bold", False)
        if bold:
            self.SetItemBold(branch_id, True)

        assert not kwargs, "invalid keys in kwargs: %s" % list(kwargs.keys())

    # -------- EVENT HANDLERS ----------
    def on_expand_item(self, event):
        """Create the child nodes of the expanded item dynamically (lazy
        approach).

        :param wx.TreeEvent event: EVT_TREE_ITEM_EXPANDING instance.
        """
        branch_id = event.GetItem()
        if wx34.GetItemData(self, branch_id)["children_evaluated"]:
            # children already evaluated, don't do it again
            return
        else:
            # create children
            children_ids = self.create_child_branches(branch_id)
            if children_ids:
                self.SetItemHasChildren(branch_id, True)
            else:
                self.SetItemHasChildren(branch_id, False)
            wx34.GetItemData(self, branch_id)["children_evaluated"] = True

            # expansion might have triggered evaluation of node in data grid
            event = FirstExpansionEvent(-1)
            wx.PostEvent(self.GetParent(), event)

    def on_select(self, event):
        """Trigger ShowObjectDataEvent. Triggered by wx.EVT_TREE_SEL_CHANGED. See:
        http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.TreeCtrl.html#event-handling
        """
        branch_id = event.GetItem()
        data = wx34.GetItemData(self, branch_id)
        # print "GUI.tree: selected object:", data["obj"]
        event = create_select_object_event(data["path"], data["obj"])
        wx.PostEvent(self.GetParent(), event)

    def on_double_click(self, event):
        """Create DrawObjectEvent. Triggered by wx.EVT_TREE_ITEM_ACTIVATED. See:
        http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.TreeCtrl.html#event-handling
        """
        branch_id = event.Item
        data = wx34.GetItemData(self, branch_id)
        obj = data["obj"]
        if obj is not None:
            event = create_disp_event(data["path"], True)
            wx.PostEvent(self.GetParent(), event)
        else:
            print("ignored this tree item, it doesn't hold a valid item")

    def on_right_click(self, evt):
        """Show context menu. Triggered by wx.EVT_TREE_ITEM_MENU. See:
        http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.TreeCtrl.html#event-handling
        """
        branch_id = evt.Item
        branch_data = wx34.GetItemData(self, branch_id)
        obj = branch_data["obj"]
        if obj:
            self.SelectItem(branch_id)

            right_click_obj_evt = create_right_click_tree_object_event(
                self, obj, branch_data['path'], evt.Point, branch_id)

            if not broadcast_event(
                    self.root_object, EVT_RIGHT_CLICK_TREE_OBJECT,
                    right_click_obj_evt, [right_click_obj_evt.path]):
                # There was no handler that did not skip: we propagate
                wx.PostEvent(self, right_click_obj_evt)
        else:
            print("ignored this tree item, it doensn't hold a valid item")

    def on_right_click_tree_object(self, evt):
        self._display_context_menu(evt.path, evt.obj, evt.point)

    def _display_context_menu(self, path, obj, point):
        """Displays the context menu for ``obj`` at ``path`` at a ``point``"""
        if isinstance(obj, FileWriter):
            menu = self.context_menu_writer
        elif isinstance(obj, FileReader):
            menu = self.context_menu_reader
        else:
            menu = self.context_menu
        menu.set_path_obj(path, obj)
        self.PopupMenu(menu, point)

    def on_middle_click(self, func):
        """Show context menu. Triggered by wx.EVT_TREE_ITEM_MIDDLE_CLICK. See:
        http://xoomer.virgilio.it/infinity77/wxPython/Widgets/wx.TreeCtrl.html#event-handling
        """
        branch_id = func.Item
        obj = wx34.GetItemData(self, branch_id)["obj"]
        if obj:
            # wx.PostEvent(wx.EVT_TREE_SEL_CHANGED, func)
            print("Tree: middle-clicked object:", obj)
            # self.context_menu.set_selected_object(obj)
            # self.PopupMenu(self.context_menu, func.Point)
        else:
            print("ignored this tree item, it doensn't hold a valid item")

    # ==============================================================================================
    # Branch Management
    # ==============================================================================================
    @classmethod
    def is_valid(cls, obj):
        """lazy test to see if obj is valid object for GUI"""
        if isinstance(obj, ParaPyObject):
            return True
        elif is_iterable(obj):  # avoid infinite recursion on strings
            return all(map(cls.is_valid, obj))
        else:
            return False

    @classmethod
    def has_children(cls, obj):
        """A lazy test to check if obj has children"""
        if isinstance(obj, ParaPyObject):
            if isinstance(obj, Base) and len(obj._tree_slots) > 0:
                return True
            # RvD: fix, wasn't lazy
            if isinstance(obj, Sequence):  # and len(obj) > 0:
                return True
            else:
                # points, Position, etc. have no true children
                return False
        elif hasattr(obj, "__iter__") and len(obj) > 0:
            # must have been a sub-iterable of ParaPyObject
            return True
        else:
            return False

    def NewPyData(self, parent_id, obj, role, children_evaluated, valid,
                  listener=None):
        path = wx34.GetItemData(self, parent_id)["path"] + (role,) \
            if parent_id is not None else ()
        return {"obj": obj,
                "role": role,
                "path": path,
                "children_evaluated": children_evaluated,
                "valid": valid,
                "listener": listener}

    def bind_self(self, obj):
        self.globals['self'] = obj
        print("Bound 'self' to {:}. Try:\nIn[1]: self".format(repr(obj)))

    def create_branch(self, parent_id, role, obj):
        """Create a new tree branch. This method acts as a shim. It first check if obj
        is valid. If so, proceeds to create_valid_branch(), else create_invalid_branch().

        Args:
            parent_id (wx.TreeItemId|None): ``None`` means this branch is the root.
            role (str|int): the role of the next branch. Either a string or an integer (iterables)
            obj (Base): the obj itself
            color_tuple (3-integer tuple): may contain 3-integer for RGB value. Leave None, if you want
                obj to control color. If obj is None, color_tuple will be (0, 0, 0) (i.e. black).
            icon_path (pathname): Path of icon. None means we take it from obj or display default.

        Returns:
            branch_id (int): TreeItemId type from wx, the id of the newly created branch.
        """
        if self.is_valid(obj):
            return self.create_valid_branch(parent_id, role, obj)
        else:
            parent = wx34.GetItemData(self, parent_id)["obj"]
            msg = (f"value {obj!r} of slot {role!r} does not "
                   f"make a valid tree object. Object: {parent!r}")
            logger.warning(msg)
            return self.create_invalid_branch(parent_id, role, obj)

    def create_invalid_branch(self, parent_id, role, obj):
        """create an invalid branch"""
        branch_id = self.AppendItem(parent_id, "TODO")
        self.SetItemHasChildren(branch_id, False)
        pydata = self.NewPyData(parent_id, None, role, True, False)
        wx34.SetItemData(self, branch_id, pydata)
        self.set_branch_style(branch_id, label=role, color=(255, 0, 0),
                              icon=ERR_IMG_PATH, bold=True)
        return branch_id

    def create_valid_branch(self, parent_id, role, obj):
        """Args:
            parent_id (wx.TreeItemId): indentifier of owner of this branch
            role (str|int) the role of this branch w.r.t. to the former
            obj: object that is contained in this branch_id

        Returns:
            wx.TreeItemId: the identifier of this newly created branch."""

        # ==========================================================================================
        # Branch Management
        # ==========================================================================================
        if parent_id is None:
            branch_id = self.AddRoot("TODO")
        else:
            branch_id = self.AppendItem(parent_id, "TODO")

        has_children = self.has_children(obj)
        self.SetItemHasChildren(branch_id, has_children)
        # self.obj_branch_id[obj] = branch_id

        # Retrieve some style properties for tree
        # Fix: this was triggering evaluation of Sequence.quantify
        # if obj and isinstance(obj, Base)
        if isinstance(obj, AbstractBase):
            # TODO: remove this statement if certain
            # assert branch_id not in self.TreeItemWrapper, "should not happen"
            if isinstance(obj, Base):
                wrapper = TreeWrapper(branch_id=branch_id, tree=self, obj=obj,
                                      role=role)
            else:
                wrapper = TreeWrapperSequence(branch_id=branch_id, tree=self,
                                              obj=obj, role=role)
            pydata = self.NewPyData(parent_id, obj, role, False, True, wrapper)
            style = wrapper.safe_style
        else:
            # TODO: also look at names of Point, etc.
            if isinstance(obj, ParaPyObject):
                icon = obj.__icon__
            elif hasattr(obj, '__iter__'):
                icon = SEQ_IMG_PATH
            else:
                icon = DEF_IMG_PATH
            style = {"label": str(role), "icon": icon}
            pydata = self.NewPyData(parent_id, obj, role, False, True)

        wx34.SetItemData(self, branch_id, pydata)
        self.set_branch_style(branch_id, **style)

        return branch_id

    def create_child_branches(self, branch_id):
        """creates all children branches for branch_id.

        Returns:
            [wx.TreeItemId]: branch_ids of all children objects creates. An empty list means no
                            children were created. This is useful for on_tree_expand, to remove +
                            (expand) symbol.

        NOTE: create_child_branches only be invoked for obj that went through ``has_children`` test.
        """
        obj = wx34.GetItemData(self, branch_id)["obj"]

        # assert obj, "something went wrong"

        child_branch_ids = []

        if isinstance(obj, AbstractBase):
            # wrapper = self.TreeItemWrapper[branch_id]
            wrapper = wx34.GetItemData(self, branch_id)["listener"]
            safe_children = wrapper.safe_children
            for slot_name, child_obj in safe_children.items():
                # child_obj = safe_children[slot_name]
                if isinstance(child_obj, Exception):
                    child_branch_id = self.create_invalid_branch(branch_id, slot_name, obj=None)
                else:
                    # healthy object to proceed with
                    child_branch_id = self.create_branch(branch_id, slot_name, child_obj)

                child_branch_ids.append(child_branch_id)

        elif hasattr(obj, "__iter__"):
            # this object was a sequence or sub-sequence
            for index, item in enumerate(obj):
                child_branch_id = self.create_branch(branch_id, index, item)
                child_branch_ids.append(child_branch_id)
        else:
            raise Exception("Invalid child type, should be Base or Sequence: " + str(type(obj)))

        return child_branch_ids
        # if not first_time:
        #    self.restore_expansion_state(state)
        #    TODO: check the focused item with GetFocusedItem and scroll it back in
        #    the view with EnsureVisible

#     def collapse_and_remove_nodes(self, branch_id):
#         """
#         The built-in CollapseAndReset returns immediately if ItemHasChildren is False. This function
#         works around that behaviour.
#
#         Possibly, if the new sequence has a length 0, ItemHasChildren might already have been set to False,
#         while there are in fact still child branches that need to be removed. In that case, temporarily set
#         the ItemHasChildren to True, CollapseAndReset, and restore the value.
#         """
#         if self.GetChildrenCount(branch_id) == 0:
#             return
#         if self.ItemHasChildren(branch_id):
#             wx.TreeCtrl.CollapseAndReset(self, branch_id)
#         else:
#             # So therer are children (from an old object), but the ItemHasChildren setting was set to False (due to a new object)
#             self.SetItemHasChildren(branch_id, True)
#             wx.TreeCtrl.CollapseAndReset(self, branch_id)
#             self.SetItemHasChildren(branch_id, False)

    def get_expansion_state(self, branch_id):
        """Returns a group of nested dictionaries representing open tree
        branches::

            {"root": {"sub_node": {}}}
        """
        if self.IsExpanded(branch_id):
            state = {}

            def walker(child_id, role, state):
                if self.IsExpanded(child_id):
                    substate = {}
                    state[role] = substate
                    for role, sub_id in self.get_children(child_id).items():
                        walker(sub_id, role, substate)

            walker(branch_id, "root", state)
            return state
        else:
            return {}

    def restore_expansion_state(self, branch_id, state):
        """Restore the tree to the given expansion state, where possible.
        Branches that no longer exist are ignored.
        """
        if state:
            state = state['root']
            self.Expand(branch_id)

            def walker(id, state):
                for role, sub_id in self.get_children(id).items():
                    if role in state:
                        self.Expand(sub_id)
                        walker(sub_id, state[role])

            walker(branch_id, state)

    def get_children(self, branch_id):
        """
        Get all children of the given branch. This is used to get and restore the expansion state.
        Returns:
            dict (str: TreeItem)
        """
        children = {}
        child_branchid, cookie = self.GetFirstChild(branch_id)
        while child_branchid.IsOk():
            children[wx34.GetItemData(self, child_branchid)["role"]] = child_branchid
            child_branchid, cookie = self.GetNextChild(branch_id, cookie)
        return children

#     def get_obj_from_path(self, path):
#         obj = self.root_obj
#         for name in path:
#             if type(name) == int:
#                 if name >= len(obj):
#                     return
#                 obj = obj[name]
#             else:
#                 # TODO: hasattr doesn't work properly. Can we do something about that?
#                 try:
#                     obj = getattr(obj, name)
#                 except AttributeError:
#                     return None
#         return obj

    # -------- temporary event handler override mechanism ----------
    on_select_callback = None
    on_double_click_callback = None
    on_right_click_callback = None
    on_middle_click_callback = None

    def override_on_select(self, callback):
        self.Unbind(wx.EVT_TREE_SEL_CHANGED, None, -1, -1, self.on_select)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_select_)
        self.on_select_callback = callback

    def override_double_click(self, callback):
        self.Unbind(wx.EVT_TREE_ITEM_ACTIVATED, None, -1, -1, self.on_double_clickt)
        self.Bind(wx.EVT_TREE_ITEM_ACTIVATED, self.on_double_click_)
        self.on_double_click_callback = callback

    def override_right_click(self, callback):
        self.Unbind(wx.EVT_TREE_ITEM_MENU, None, -1, -1, self.on_right_click)
        self.Bind(wx.EVT_TREE_ITEM_MENU, self.on_right_click_)
        self.on_right_click_callback = callback

    def override_middle_click(self, callback):
        self.Unbind(wx.EVT_TREE_ITEM_MIDDLE_CLICK, None, -1, -1, self.on_middle_click)
        self.Bind(wx.EVT_TREE_ITEM_MIDDLE_CLICK, self.on_middle_click_)
        self.on_middle_click_callback = callback

    def on_select_(self, event):
        self.on_select_callback(event)
        self.on_select_callback = None
        self.Unbind(wx.EVT_TREE_SEL_CHANGED, None, -1, -1, self.on_select_)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_select)

    def on_double_click_(self, event):
        self.on_double_click_callback(event)
        self.on_double_click_callback = None
        self.Unbind(wx.EVT_TREE_SEL_CHANGED, None, -1, -1, self.on_double_click_)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_double_click)

    def on_right_click_(self, event):
        self.on_right_click_callback(event)
        self.on_right_click_callback = None
        self.Unbind(wx.EVT_TREE_SEL_CHANGED, None, -1, -1, self.on_right_click_)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_right_click)

    def on_middle_click_(self, event):
        self.on_middle_click_callback(event)
        self.on_middle_click_callback = None
        self.Unbind(wx.EVT_TREE_SEL_CHANGED, None, -1, -1, self.on_middle_click_)
        self.Bind(wx.EVT_TREE_SEL_CHANGED, self.on_middle_click)


class ObjectTreeWalker(object):
    __slots__ = 'tree', 'current_branch_id', 'expanded_branches', 'walked_path'

    def __init__(self, tree, branch_id=None):
        """Helps navigating the ObjectTree, and can restore any
        expansion-state-changes done in the progress. Every step in the tree
        using :meth:`step_to` will chang the :attr:`current_branch_id` to the
        branch id that we walked to.

        :param parapy.gui.tree.ObjectTree tree:
        :param int | None branch_id: branch_id to start the walk. If set to
            :py:`None`, it will start walking from the root of ``tree``.
        """
        self.tree = tree
        self.current_branch_id = branch_id or tree.root_id
        self.expanded_branches = []
        self.walked_path = []

    def step_to(self, key, expand=True, eager=True):
        """Walk to ``key`` from :attr:`current_branch_id`.

        :param object key: identifier in the tree of this child.
        :param bool expand: Are we allowed to expand the tree?
        :param bool eager: If we need to expand the tree, is it allowed to
            evaluate the object that this branch represents?
        :raises PathNotInTreeError: If :attr:`current_branch_id` does not have
            a child identified by ``key``.
        :returns: ``True`` if we could walk to ``key``. ``False`` if either
            ``expand`` or ``eager`` stopped us from walking to ``key``.
        :rtype: bool
        """
        tree = self.tree
        get_item_path = self.get_item_path
        branch_id = self.current_branch_id

        if not tree.IsExpanded(branch_id):
            if expand:
                try:
                    self.expand(eager=eager)
                except RuntimeError:
                    return False
            else:
                return False

        # now the node should have been expanded
        expected_child_path = get_item_path(branch_id) + (key, )
        for child_id in tree.GetItemChildren(branch_id):
            child_path = get_item_path(child_id)

            if expected_child_path == child_path:
                self.current_branch_id = child_id
                self.walked_path.append(key)
                return True
        else:
            raise PathNotInTreeError(expected_child_path)

    def walk_to(self, path, expand=True, eager=True):
        """Walk along ``path`` from :attr:`current_branch_id`.

        :param typing.Sequence[object] path: identifier in the tree of this
            child.
        :param bool expand: Are we allowed to expand the tree?
        :param bool eager: If we need to expand the tree, is it allowed to
            evaluate the object that this branch represents?
        :raises PathNotInTreeError: If :attr:`current_branch_id` does not have
            a child identified by ``path``.
        :returns: ``True`` if we could walk ``path``. ``False`` if either
            ``expand`` or ``eager`` stopped us from walking``path``.
        :rtype: bool
        """
        step_to = partial(self.step_to, expand=expand, eager=eager)
        gen_is_step_on_path_successful = map(step_to, path)
        try:
            # trick: all short-circuits when any step does not succeed
            return all(gen_is_step_on_path_successful)
        except PathNotInTreeError:
            # re-raise with path that the user was actually looking for
            raise PathNotInTreeError(path)

    def expand(self, eager=True):
        """Expand the :attr:`current_branch_id` if it is not already.

        :param bool eager: If set to :py:`False`, it will only expand the
            branch if it does not need to evaluate the related object.
            Otherwise it will evaluate the object represented
            by :attr:`current_branch_id`.
        :raises RuntimeError: when :attr:`current_branch_id` could not be
            expanded.
        """
        branch_id = self.current_branch_id
        tree = self.tree
        item_data = wx34.GetItemData(tree, branch_id)
        if not tree.IsExpanded(branch_id):
            if eager or item_data["children_evaluated"]:
                tree.Expand(branch_id)  # currently the way to evaluate

                if tree.IsExpanded(branch_id):
                    self.expanded_branches.append(branch_id)
                else:
                    msg = ('Could not expand tree item at path: {}. '
                           'Object: {!r}')
                    raise RuntimeError(msg.format(item_data['path'], tree))
            else:
                msg = ("Could not expand tree item at path: {}, it would "
                       "evaluate the object, but eager is set to False. "
                       "Object: {!r}")
                raise RuntimeError(msg.format(item_data['path'], tree))

    def restore_expansion_state(self):
        """Restores any expansion done in :attr:`tree` due to walking
        through the tree.
        """
        Collapse = self.tree.Collapse
        for branch_id in self.expanded_branches:
            Collapse(branch_id)

    def get_item_data(self, branch_id):
        return wx34.GetItemData(self.tree, branch_id)

    def get_item_path(self, branch_id):
        return self.get_item_data(branch_id)['path']

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            self.restore_expansion_state()


class TreeContextMenu(DisplayContextMenu):
    """Base class for TreeContextMenuGeneral, TreeContextMenuWriter, and
    TreeContextMenuReader"""

    def __init__(self, parent=None, obj=None, path=None,
                 add_default_items=False):
        super(TreeContextMenu, self).__init__(
            parent=parent, obj=obj, path=path,
            add_default_items=add_default_items)

    def set_path_obj(self, path, obj, add_actions=True):
        self.path = path
        self.obj = obj
        self.remove_non_standard_items()

        if add_actions and isinstance(obj, AbstractBase):
            # NOTE: keyword argument `standard=False` is default and therefore
            # not explicitly given, however it's very important that this is
            # maintained so the menu items are cleared consistently
            self.append_actions(add_separator=True)

    def append_default_items(self, standard=False):
        self.append_item(
            "Get reference chain to", icon="refchain_to.png",
            handler=self.on_refchain_to, standard=standard)

        self.append_item(
            "Get reference chain from", icon="refchain_from.png",
            handler=self.on_refchain_from, standard=standard)

        if running_IPython():
            self.append_separator(standard=standard)
            self.append_item(
                "Bind to self (IPython)", icon="inspect.gif",
                handler=self.on_bind_self, standard=standard)

    def append_actions(self, standard=False, add_separator=False):
        obj = self.obj
        actions = [action for _, action in
                   obj.yield_special_methods(Action.__ppmembername__)
                   if action.in_context(Action.Context.TREE)]

        if actions:
            actions.sort(key=attrgetter("_counter"))
            if add_separator:
                self.append_separator()
            post_refresh = self.post_occ_refresh
            for action in actions:
                # the *value* of action is copied in handler() environment
                def handler(_, _action=action):
                    value = _action.call(obj)
                    if _action.refresh:
                        post_refresh()
                    return value

                self.append_item(action.label, icon=action.icon,
                                 handler=handler, standard=standard)

    # ------------- event handlers --------------
    def on_refchain_to(self, evt=None):
        """prints the refererence chain from this obj to the other object"""
        obj1 = self.obj
        if obj1 and isinstance(obj1, AbstractBase):
            tree = self.topmost_menu.GetInvokingWindow()

            def callback(event):
                branch_id = event.GetItem()
                obj2 = wx34.GetItemData(tree, branch_id)["obj"]
                if obj2 and isinstance(obj2, AbstractBase):
                    print("GUI:", obj1.refchain_to(obj2))
                else:
                    print("GUI: only possible to resolve reference chain between two Base instances")

            tree.override_on_select(callback)
        else:
            print("GUI: only possible to resolve reference chain between two Base instances")

    def on_refchain_from(self, evt=None):
        """prints the refererence chain from other object to this object"""
        obj1 = self.obj
        if obj1 and isinstance(obj1, AbstractBase):
            tree = self.topmost_menu.GetInvokingWindow()

            def callback(event):
                branch_id = event.GetItem()
                obj2 = wx34.GetItemData(tree, branch_id)["obj"]
                if obj2 and isinstance(obj2, AbstractBase):
                    print("GUI:", obj1.refchain_from(obj2))
                else:
                    print("GUI: only possible to resolve reference chain "
                          "between two Base instances")

            tree.override_on_select(callback)
        else:
            print("GUI: only possible to resolve reference chain between two "
                  "Base instances")

    def post_occ_refresh(self):
        event = create_refresh_event(self)
        # need to post event on the panel i.e. InvokingWindow
        tree = self.topmost_menu.GetInvokingWindow()
        wx.PostEvent(tree, event)


class TreeContextMenuGeneral(TreeContextMenu):
    """General context menu for tree nodes"""

    def __init__(self, parent=None, obj=None, path=None,
                 add_default_items=False):
        super(TreeContextMenuGeneral, self).__init__(
            parent=parent, obj=obj, path=path,
            add_default_items=add_default_items)

    def append_default_items(self, standard=False):
        self.append_default_display_items(standard=standard)
        self.append_separator(standard=standard)
        super(TreeContextMenuGeneral, self).append_default_items(
            standard=standard)


class TreeContextMenuWriter(TreeContextMenu):
    """Specific context menu for Writer objects"""

    def __init__(self, parent=None, obj=None, path=None,
                 add_default_items=False):
        super(TreeContextMenuWriter, self).__init__(
            parent=parent, obj=obj, path=path,
            add_default_items=add_default_items)

    def append_default_items(self, standard=False):
        self.append_item(
            "write", icon="export.png", handler=self.on_write,
            standard=standard)
        self.append_separator(standard=standard)
        super(TreeContextMenuWriter, self).append_default_items(
            standard=standard)

    def on_write(self, evt=None):
        """Write stuff to disk"""
        obj = self.obj
        message = "Write contents to disk"
        default_directory = obj.default_directory
        file_or_dir = obj.file_or_dir
        style = wx.FD_SAVE

        if file_or_dir == "file":

            dlg = wx.FileDialog(None, message, default_directory, style=style)
            if obj.wildcard:
                dlg.SetWildcard(obj.wildcard)
        else:
            dlg = wx.DirDialog(None, message, default_directory, style=style)
        if dlg.ShowModal() == wx.ID_CANCEL:
            dlg.Destroy()
            return
        else:
            path = dlg.GetPath()
            dlg.Destroy()

            try:
                obj.write(path)
            except Exception:
                logger.exception(f"GUI: Executing read failed. "
                                 f"Object: {obj!r}", exc_info=True)


class TreeContextMenuReader(TreeContextMenu):
    """Specific context menu for Writer objects"""

    def __init__(self, parent=None, obj=None, path=None,
                 add_default_items=False):
        super(TreeContextMenuReader, self).__init__(
            parent=parent, obj=obj, path=path,
            add_default_items=add_default_items)

    def append_default_items(self, standard=False):
        self.append_item(
            "read", icon="import.png", handler=self.on_read,
            standard=standard)
        self.append_separator(standard=standard)
        super(TreeContextMenuReader, self).append_default_items(
            standard=standard)

    def on_read(self, evt=None):
        """Write stuff to disk"""
        obj = self.obj
        message = "Read from disk"
        default_directory = obj.default_directory
        file_or_dir = obj.file_or_dir
        multiple = getattr(obj, 'multiple', False)

        style = wx.FD_OPEN

        if file_or_dir == "file":
            if multiple:
                style |= wx.FD_MULTIPLE

            dlg = wx.FileDialog(None, message, default_directory, style=style)
            if obj.wildcard:
                dlg.SetWildcard(obj.wildcard)
        else:  # dir
            if multiple:
                logger.exception(f"Multiple selection is not supported when "
                                 f"selecting directories! Set multiple "
                                 f"to False. Object: {obj!r}",
                                 exc_info=False)
                return

            dlg = wx.DirDialog(None, message, default_directory, style=style)
        if dlg.ShowModal() == wx.ID_CANCEL:
            dlg.Destroy()
            return
        else:
            path = dlg.GetPaths() if multiple else dlg.GetPath()
            dlg.Destroy()

            try:
                obj.read(path)
            except Exception:
                logger.exception(f"Executing read failed. Object: {obj!r}",
                                 exc_info=True)

            # try a refresh on the GUI, this read probably changed the
            # state of the parapy model, safely to avoid error if we
            # are re-used in a very different Frame than MainWindow
            invoker = self.GetInvokingWindow()
            frame = invoker.TopLevelParent
            if hasattr(frame, 'refresh'):
                # duck typing: probably MainWindow
                frame.refresh()


class TreeWrapper(Base):
    """For each Tree branch that traps a Base instance, an associated Wrapper
    object is constructed"""

    branch_id = Input(doc="the branch_id owning me")
    tree = Input(doc="owning TreeCtrl instance")
    obj = Input(doc="Base instance")
    role = Input(doc="role in GUI. str|int!")

    @Attribute
    def safe_style(self):
        """Slot that GUI "listens" to. Returns exception if style failed."""
        obj = self.obj
        try:
            user_style = obj.tree_style
            label = user_style.get("label", obj.label)
            label = label if label is not None else str(self.role)

            if not isinstance(label, str):
                raise TypeError(f"label has type {type(label)} but should be "
                                f"of type str. Object: {obj!r}")

            color = user_style.get("color", None)
            if color:
                color = get_rgb_value(obj.color if color is True else color)

            background_color = user_style.get("background_color", None)
            if background_color:
                background_color = get_rgb_value(
                    obj.color if background_color is True else background_color)

            icon = user_style.get("icon", obj.__icon__)
            bold = user_style.get("bold", False)

            return {"label": label, "color": color,
                    "background_color": background_color,
                    "icon": icon, "bold": bold}
        except Exception as e:
            logger.warning("GUI: Evaluation of %s._tree_style failed."
                           " Message:%s" % (obj.refchain, e),
                           exc_info=True)
            return {"icon": WAR_IMG_PATH,
                    "color": (0, 0, 0),
                    "background_color": None,
                    "label": str(self.role)}

    @Attribute
    def safe_children(self):
        """True children dict for GUI tree. Includes all ``_tree_slots`` and corresponding values.
        Returns an Exception object if something failed, GUI will know what to do.

        Returns:
            {slot_name (str): obj (ParaPyObject|Exception),
             ...
             }
        """
        return safe_children_dictionary(self.obj)

    @safe_style.on_slot_change
    def on_style_change(self, slot, new, old):
        self.tree.style_updates[self.branch_id] = old

    @safe_children.on_slot_change
    def on_topology_change(self, slot, new, old):
        self.tree.children_updates[self.branch_id] = old

    def unregister(self):
        """Remove the listeners"""
        safe_style_slot = self.get_slot('safe_style')
        safe_children_slot = self.get_slot('safe_children')

        safe_style_slot._listeners = list()
        safe_children_slot._listeners = list()


class TreeWrapperSequence(TreeWrapper):

    @Attribute
    def safe_style(self):
        return {"label": str(self.role), "icon": self.obj.__icon__}

    @Attribute
    def safe_children(self):
        """True children dict for GUI tree."""
        return safe_children_dictionary_sequence(self.obj)

    @safe_style.on_slot_change
    def on_style_change(self, slot, new, old):
        self.tree.style_updates[self.branch_id] = old

    @safe_children.on_slot_change
    def on_topology_change(self, slot, new, old):
        self.tree.children_updates[self.branch_id] = old

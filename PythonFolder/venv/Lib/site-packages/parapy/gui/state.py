#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from collections.abc import Sequence

from parapy.core import Attribute, Base, Input
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.utilities import _get_slot, _is_int, parse_refchain
from parapy.gui.logger import logger


class PathTree(object):
    __slots__ = 'root'

    class Node(object):
        __slots__ = 'value', 'children'

        def __init__(self, value, children=None):
            """Create a node with ``value``.

            :param T value: Value of this node
            :param collections.Sequence[PathTree.Node] children: Optionally
                a list of children of this node.
            """
            self.value = value
            self.children = [] if children is None else list(children)

        def get_child(self, child_value):
            """Get child with ``child_value``. Returns :py:`None` if no child
            was found. If there are multiple children, only the first that
            was found is returned.

            :param T child_value:
            :rtype: PathTree.Node | None
            """
            children = self.children
            child = [c for c in children if c.value == child_value]
            return child[0] if len(child) > 0 else None

        def add_child(self, child_value):
            """Add child with ``child_value``. This will always add the
            child, even if another child with that value is already present.

            :param T child_value:
            :returns: The node that was added as a child.
            :rtype: PathTree.Node
            """
            new_child = PathTree.Node(child_value)
            self.children.append(new_child)
            return new_child

        def remove_child(self, child_value):
            """Removes child with ``child_value`` from the tree. A child with
            ``child_value`` should exist.

            :param T child_value:
            """
            child = self.get_child(child_value)
            self.children.remove(child)

        def walk_tree(self):
            """Walk through the nodes in the sub-tree starting at this child.

            :rtype: collections.Iterator[PathTree.Node]
            """
            to_process = list()  # children to be processed
            node = self
            while node:
                yield node
                to_process += node.children
                try:
                    node = to_process.pop()
                except IndexError as e:
                    break

    def __init__(self):
        #: The root is the encapsulation of the path-tree. It represents the
        #: empty path.
        #: :type: PathTree.Node
        self.root = PathTree.Node(value=None)

    def contains(self, path):
        """Is ``path`` contained by this PathTree?

        :param str path:
        :rtype: bool
        """
        ref_tokens = parse_refchain(path)
        return self._contains(ref_tokens)

    def _contains(self, ref_tokens):
        """Is ``path`` in this tree?

        :type collections.Sequence[str] ref_tokens: str
        :rtype: bool
        """
        node = self._get_node(ref_tokens)
        return bool(node)

    def get_node(self, path):
        """Return the PathTree.Node corresponding to ``path`` in this
        PathTree. If it is not present, this method returns :py:`None`.

        :param str path:
        :rtype: PathTree.Node | None
        """
        ref_tokens = parse_refchain(path)
        return self._get_node(ref_tokens)

    def _get_node(self, ref_tokens):
        """Return the PathTree.Node corresponding to ``path`` in this
        PathTree. If it is not present, this method returns :py:`None`.

        :param collections.Sequence[str] ref_tokens:
        :rtype: PathTree.Node | None
        """
        #: :type: PathTree.Node
        node = self.root

        for token in ref_tokens:
            node = node.get_child(token)
            if node is None:
                return None

        return node

    def insert(self, path):
        """Insert ``path`` in this PathTree.

        :param str path:
        :rtype: PathTree.Node
        """
        ref_tokens = parse_refchain(path)
        return self._insert(ref_tokens)

    def _insert(self, ref_tokens):
        """Insert ``path`` in this PathTree.

        :param collections.Sequence[str] ref_tokens:
        :rtype: PathTree.Node
        """
        node = self.root

        for token in ref_tokens:
            child = node.get_child(token)
            if child is None:
                child = node.add_child(token)
            node = child

        return node

    def remove(self, path):
        """Remove ``path`` from this PathTree. It will not trim the tree to
        its minimal size, it just removes ``path`` and all 'child paths` from
        the tree.

        :param str path:
        """
        ref_tokens = parse_refchain(path)
        self._remove(ref_tokens)

    def _remove(self, ref_tokens):
        """Remove ``path`` from this PathTree. It will not trim the tree to
        its minimal size, it just removes ``path`` and all 'child paths` from
        the tree.

        :param collections.Sequence[str] ref_tokens:
        """
        node = self.root

        if len(ref_tokens) == 0:
            node.children = list()
        else:
            parent_node = self._get_node(ref_tokens[:-1])
            parent_node.remove_child(ref_tokens[-1])


class DrawState(Base):
    """Captures the display state of a ParaPy refchain node in the GUI.

    The object that needs to be drawn is decided by the ``path`` from the
    object managed by a ``tree_parent`` DrawState to me. If that path does
    not exist anymore, and this path therefore is unreachable, this DrawState
    will be removed, and ``on_unregister`` will be called, causing updates
    in the GUI.
    """

    __slots__ = []  # <-- why?

    #: The parent of this object in the refchain
    #: :type: DrawState
    tree_parent = Input()

    #: path as seen from owner (a tuple)
    #: :type: str
    path = Input()

    #: Display this node?
    #: :type: bool
    display = Input(False)

    #: Called when this DrawState is unregistered, and by that should not
    #: manage this part of the reference chain path anymore
    #: :type: collections.Callable[DrawState]
    on_unregister = None

    #: Called when there has been a change in the object that should be
    #: displayed based on the refchain managed by this object.
    #: :type: collections.Callable[DrawState, parapy.core.Base | None]
    on_drawn_object_change = None

    #: Called when the refchain managed by this object is not reachable anymore
    #: :type: collections.Callable[tuple[str | int]]
    on_unreachable = None

    @Attribute
    def obj(self):
        """root object of draw operation"""
        obj = self.tree_parent.obj

        path = self.path
        try:
            return _get_slot(obj, path)
        except (AttributeError, KeyError, IndexError, TypeError) as e:
            try:
                slot_exists = _has_slot(obj, path)
            except Exception:
                # maybe we show more warnings than strictly necessary,
                # but we assume that an implementation of the
                # slot exists, so the error is a user error
                slot_exists = True

            if slot_exists:
                logger.warning(e, exc_info=True)
        except Exception:
            pass

    @Attribute
    def tree_refchain(self):
        """The reference chain of :attr:`obj` in this tree.

        :rtype: tuple[str | int]
        """
        owner = self.tree_parent
        my_path = self.path

        if owner and (owner.path is not None):
            return owner.tree_refchain + (my_path,)
        elif my_path is not None:
            return my_path,
        else:
            return ()

    @Attribute
    def object_to_draw(self):
        """The object to draw. Returns None if this object should not be
        drawn.

        :rtype: DrawableParaPyObject | None
        """
        obj = self.obj  # can return None if exception occurred
        if obj and self.display:
            if isinstance(obj, DrawableParaPyObject):
                try:
                    hidden = obj.hidden
                except Exception as e:
                    msg = "Evaluation of 'hidden' on {:} failed"
                    logger.warning(msg.format(repr(obj)), exc_info=True)
                else:
                    if not hidden:
                        return obj
            else:
                msg = "Don't know how to draw object {:} defined by path {:}"
                logger.warning(msg.format(repr(obj), self.tree_refchain),
                               exc_info=True)

        return None

    @object_to_draw.on_slot_change
    def on_draw_change(self, slot, new, old):
        # print "GUI: draw command on {} was invalidated".format(self.path)
        # Check if we are still reachable from the root.
        if self.obj is None:  # not reachable anymore
            # We are not in the tree anymore, so notify that the refchain that
            # we manage is not existing anymore
            self.unregister()  # needs to be done, because we have no value

            # callback to notify that the reference chain is unreachable
            on_unreachable = self.on_unreachable
            if on_unreachable:
                path = self.tree_refchain
                on_unreachable(path)

        on_drawn_object_change = self.on_drawn_object_change
        if on_drawn_object_change:
            on_drawn_object_change(self, old)

    # TODO (RvD): very hackish programming, think of better strategy.
    def unregister(self):
        # break link between cache surrounding "objects_to_draw" and its
        # precedents, otherwise invalidation of "objects_to_draw" might
        # trigger the on_slot_change listener to
        # communicate with TreeViewerPanel
        to_draw_cache = self.get_cache("object_to_draw", eager=False)

        if to_draw_cache:
            precs = to_draw_cache.precedents
            while precs:
                precs.pop().dependents.remove(to_draw_cache)  # note discard()!

        # notify that we are unregistering
        on_unregister = self.on_unregister
        if on_unregister:
            on_unregister(self)


def _has_key_or_index(obj, item):
    if not hasattr(obj, '__getitem__'):  # indexable or not
        return False

    try:
        _ = obj[item]
    except IndexError:
        if not isinstance(obj, dict):
            return False
        raise
    except KeyError:
        if isinstance(obj, dict):
            return False
        raise
    except TypeError:
        if isinstance(obj, Sequence):
            return False
        raise
    return True


def _has_slot(obj, attr_or_item):
    """Deduces if ``obj`` has an attribute, or item
    ``token``. Supports: integers, basestrings, tuples.

    Might not work
    correctly for objects that act like a dictionary, but are not an
    instance of ``dict`` when non-integers are used as keys.
    """
    if _is_int(attr_or_item):
        return _has_key_or_index(obj, int(attr_or_item))
    elif isinstance(attr_or_item, str):  # basestring also includes unicode
        try:
            getattr(obj, attr_or_item)
        except AttributeError:
            if isinstance(obj, dict):  # retry
                try:
                    _ = obj[attr_or_item]
                except KeyError:
                    return False
                else:
                    return True
            return False
        else:
            return True
    elif isinstance(attr_or_item, tuple):
        return _has_key_or_index(obj, attr_or_item)
    else:
        return False


class RootDrawState(DrawState):
    """
    The DrawState for the root of the ParaPy model displayed in the GUI. It
    does not maintain links to parents, so it assumes that the root instance
    is always available in the GUI.
    """
    #: The root object.
    #: :type: parapy.core.Base
    obj = Input()

    tree_parent = None

    path = None


# TODO (FT): Refactor: get rid of Tree class, everything can be managed
# /todo using Nodes. The tree is a useless structure. Would also allow some
# /todo optimizations with the tree modifications in tree_viewer.py
class DrawStateTree(PathTree):
    """A PathTree maintaining a DrawState per PathTree node. It assumes that
    the root object does not change or can be removed from the tree."""
    __slots__ = 'pathnode_to_drawstate', 'root'

    def __init__(self, root_object):
        super(DrawStateTree, self).__init__()

        root_draw_wrapper = RootDrawState(obj=root_object)
        root = self.root  # set by the super method

        #: Dictionary keeping track of the drawstates for every node in the
        #: path tree
        #: :type: dict[DrawStateTree.Node, RootDrawState]
        self.pathnode_to_drawstate = {root: root_draw_wrapper}

    def get_state(self, path):
        """Get the DrawState of a tree element denoted by ``path``.

        :param PathTree.Node path_node:
        :rtype: DrawState
        """
        path_node = self.get_node(path)

        if path_node:
            return self._get_state(path_node)

    def _get_state(self, path_node):
        """Get the DrawState of ``path_node``. Assumes that it is there.

        :param PathTree.Node path_node:
        :rtype: DrawState
        """
        return self.pathnode_to_drawstate[path_node]

    def _insert(self, ref_tokens):
        """Insert ``path`` in this DrawStateTree. Makes sure every new node
        gets a DrawState.

        :param collections.Sequence[str] ref_tokens:
        :rtype: DrawStateTree.Node
        """
        dct_node_to_state = self.pathnode_to_drawstate

        node = self.root
        node_state = dct_node_to_state[node]
        for token in ref_tokens:
            child_node = node.get_child(token)
            if child_node is None:
                child_state = DrawState(path=token, tree_parent=node_state)

                # TODO (FT): Would be even better if this would not be done
                # /todo over here. Also makes the clear method/_clean_subtree
                # /todo very implicit.
                # we remove ourself from the DrawStateTree when this state is
                # not queried anymore (unreachable, or forced to be
                # unregistered
                def on_unregister(state, node=node, token=token):
                    child = node.get_child(token)
                    del dct_node_to_state[child]  # remove the state
                    node.remove_child(token)  # remove this part of the tree

                child_state.on_unregister = on_unregister

                child_node = node.add_child(token)
                dct_node_to_state[child_node] = child_state
                node_state = child_state
            else:
                node_state = dct_node_to_state[child_node]
            node = child_node

        return node

    def _remove(self, ref_tokens):
        """Remove ``path`` from this DrawStateTree. It will not trim the
        tree to
        its minimal size, it just removes ``path`` and all 'child paths` from
        the tree.

        :param collections.Sequence[str] ref_tokens:
        """
        node = self._get_node(ref_tokens)
        self._clean_subtree(node)  # nodes are removed by the on_unregister
        # callbacks

    def clear(self):
        """Remove all nodes and drawstates from the tree except for the root.
        """
        # root itself is not removed since it does not register an
        # on_unregister callback which clears itself from the tree
        self._clean_subtree(self.root)
        self.root.children = list()

    def _clean_subtree(self, path_node):
        """Removes the nodes and drawstates from this subtree starting at
        ``path_node``.
        This removing is done by calling the unregister() method on these
        states. The states then have the opportunity to deregister themselves,
        and call their on_unregister callback, which cleans the state from this
        DrawStateTree.

        :param PathTree.Node path_node: Root of the subtree.
        """
        node_to_state = self.pathnode_to_drawstate

        node = path_node
        to_unregister = list()  # states to unregister

        for node in node.walk_tree():
            draw_state = node_to_state.get(node)

            if draw_state:
                to_unregister.append(draw_state)

        # Unregistering the states as a post-processing step to make sure
        # no things are altered while traversing the tree
        for state in to_unregister:
            state.unregister()


if __name__ == '__main__':
    tree = PathTree()

    assert tree.contains('')
    assert not tree.contains('root')

    tree.insert("root.box_holder.boxes[2]")
    tree.insert("root.cylinder.forest[1]")
    tree.insert("root.cylinder.forest[2]")
    tree.insert("root.cylinder.forest[5]")

    assert tree.contains('root')
    assert tree.contains('root.box_holder')
    assert tree.contains('root.cylinder')
    assert tree.contains('root.box_holder.boxes[2]')
    assert tree.contains('root.cylinder.forest[1]')
    assert tree.contains('root.cylinder.forest[2]')
    assert tree.contains('root.cylinder.forest[5]')

    tree.remove("root.cylinder.forest[1]")
    assert not tree.contains("root.cylinder.forest[1]")
    assert tree.contains("root.cylinder")

    tree.remove('root.box_holder')
    assert not tree.contains("root.box_holder.boxes[2]")
    assert not tree.contains("root.box_holder")

    root = tree.root

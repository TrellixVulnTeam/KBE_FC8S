#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import wx

from parapy.gui.events import EVT_LEFT_CLICK_OBJECT
from parapy.gui.wx_utils import popup

__all__ = ["SimpleViewerSelection", "ViewerSelection"]


class ViewerSelectionState(object):
    INITIALIZED = "initialized"
    STARTED = "started"
    CANCELLED = "cancelled"
    SUBMITTED = "submitted"


STOPPED_STATES = frozenset((ViewerSelectionState.SUBMITTED,
                            ViewerSelectionState.CANCELLED))


class SimpleViewerSelection(object):
    """Sets up a context in which the user can select one or multiple objects
    in the :class:`~parapy.gui.viewer.Viewer`.

    Usage:

    >>> from parapy.gui.actions import SimpleViewerSelection
    >>>
    >>> context = SimpleViewerSelection(viewer)
    >>> success = context.start()
    >>> if success:  # alternatively: ``if context.start():``
    >>>     print context.selected
    >>> else:
    >>>     print "cancelled"

    :param parapy.gui.viewer.Viewer viewer: Viewer panel.
    :param str | None msg: a *short* info message shown at the start of
        each selection action. A standard :attr:`INSTRUCTION_MSG` sentence is
        appended to this ``msg`` explaining which keys to press for submitting
        or cancelling. Example: :py:`"Select 2 planes."`.
    :param bool multiple: If True, the selection (single / multiple
        objects) is returned in a list. If False and a single object is
        selected, the selected object itself is returned.
    :param callable | None validator: like a regular ``validator`` that can be
        specified for slots (:class:`~parapy.core.abstractslot.AbstractSlot`),
        this callback function can validate user selection. Signature:
        ``(value) -> flag | (flag, msg)``, where ``flag`` is either :py:`True`
        (valid) or :py:`False` (invalid). If invalid, the optional ``msg``
        string is shown in a popup dialog (if not specified, a default message
        is shown) and the user stays in selection mode. And ``value`` is:

        - a single :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`False`.
        - a list of :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`True`.
    :param bool popup: if there's a status bar in the top-level window, it will
        be used to show the initial message to the user unless this value is
        :py:`True` in which case a popup dialog is shown. If there's no status
        bar, there will always be a popup dialog irrespective of this value.
    :param bool ask_confirmation: show confirmation dialog on submit?
    """

    POPUP_TITLE_INVALID = "Invalid Selection"
    POPUP_MESSAGE_INVALID = "Selection is not valid."
    CONFIRMATION_TITLE = "Confirm"
    CONFIRMATION_MSG = "Are you sure you want to submit the selection?"
    INSTRUCTION_MSG = "Press ENTER/RETURN to submit or ESCAPE to cancel."

    def __init__(self, viewer, msg=None, multiple=False, validator=None,
                 popup=False, ask_confirmation=False):
        # ensure there's at least some message at start of selection
        msg = msg or self._create_default_message(multiple)
        # status bar is either there or None
        status_bar = viewer.GetTopLevelParent().GetStatusBar()
        # if there's no status_bar, we do a forced popup
        popup = popup or not status_bar

        # private attributes that shouldn't be changed after init
        self._msg = None  # done in .setter
        self._viewer = viewer
        self._status_bar = status_bar  # shouldn't be changed after creation
        self._selected = None
        self._state = ViewerSelectionState.INITIALIZED

        # public attributes that can be changed as pleased
        self.msg = msg
        self.multiple = multiple
        self.validator = validator
        self.popup = popup
        self.ask_confirmation = ask_confirmation

    @property
    def selected(self):
        """Selected object(s) or :py:`None` if selection was never started
        or cancelled. In single-object selection mode (default), a single
        object is returned. In multi-object selection (:attr:`multiple` is
        :py:`True`), a list is returned.

        :rtype: parapy.core.abstract.DrawableParaPyObject | list[parapy.core.abstract.DrawableParaPyObject] | None
        """
        return self._selected

    @property
    def state(self):
        return self._state

    @property
    def viewer(self):
        return self._viewer

    @property
    def status_bar(self):
        return self._status_bar

    @property
    def msg(self):
        return self._msg

    @msg.setter
    def msg(self, value):
        self._msg = self._compose_message(value)

    def start(self):
        if self._state is not ViewerSelectionState.STARTED:
            with self.context():
                self._bind_listeners()
                self._state = ViewerSelectionState.STARTED
                self.display_message(self.msg)

                # block GUI until a selection is made or action is cancelled
                while self.state not in STOPPED_STATES:
                    wx.Yield()

                return self._state is ViewerSelectionState.SUBMITTED
        else:
            msg = "Selection is still running. Object: {!r}"
            raise RuntimeError(msg.format(self))

    def submit(self):
        self._ensure_started()
        viewer = self.viewer
        selected = viewer.selected

        is_valid, msg = self.validate(selected)

        if not is_valid:
            title = self.POPUP_TITLE_INVALID
            popup(title, msg, cancel_button=False)
            return  # stay in selection mode

        if not self._confirm():
            return  # stay in selection mode

        self._selected = self._unpack(selected)
        self._stop(ViewerSelectionState.SUBMITTED)

    def cancel(self):
        self._ensure_started()
        self._stop(ViewerSelectionState.CANCELLED)

    def context(self):
        """Return a context manager that is used to put setup GUI in
        for selection and restores GUI when done. Can be overridden in
        subclasses.
        """
        return SimpleViewerSelectionContext(self._viewer)

    def on_keypress(self, evt):
        key_code = evt.KeyCode

        if key_code == wx.WXK_ESCAPE:
            self.cancel()
        elif key_code in {wx.WXK_RETURN, wx.WXK_NUMPAD_ENTER}:
            self.submit()
        else:
            evt.Skip()

    def display_message(self, msg):
        if self.popup:
            title = "Viewer Selection"
            popup(title, msg, cancel_button=False)
        elif self._status_bar:
            self._status_bar.SetStatusText(msg)
        else:
            print(msg)  # to console

    def validate(self, selected):
        # first go through internal validator
        is_valid, msg = self._validate(selected)

        # if valid, go through user-defined validator
        if is_valid and self.validator:

            # TODO (PP): _unpack repeated here and in .selected
            selected = self._unpack(selected)

            is_valid = self.validator(selected)
            if hasattr(is_valid, "__iter__"):  # validator() -> (bool, msg)
                is_valid, msg = is_valid
            else:  # validator() -> bool
                msg = self.POPUP_MESSAGE_INVALID if not is_valid else None

        return is_valid, msg

    @staticmethod
    def _create_default_message(multiple):
        fmt = "Select {} object{} in the viewer."
        count = "multiple" if multiple else "one"
        plural = "s" if multiple else ""
        return fmt.format(count, plural)

    def _compose_message(self, msg):
        # add instruction message to (user) msg.
        return msg.rstrip(" ") + " " + self.INSTRUCTION_MSG

    def _ensure_started(self):
        if self._state is not ViewerSelectionState.STARTED:
            msg = "First start the selection. Object: {!r}."
            raise RuntimeError(msg.format(self))

    def _stop(self, state):
        self._unbind_listeners()
        self._state = state

    def _validate(self, selected):
        if not self.multiple and len(selected) != 1:
            return False, "Select 1 object"
        return True, None

    def _confirm(self):
        """Popup showing confirmation dialog. True to submit, False to cancel.

        :rtype: bool
        """
        if self.ask_confirmation:
            flag = popup(self.CONFIRMATION_TITLE, self.CONFIRMATION_MSG)
            return flag == wx.ID_OK
        else:
            return True

    def _bind_listeners(self):
        main_window = self._viewer.GetTopLevelParent()
        main_window.Bind(wx.EVT_CHAR_HOOK, self.on_keypress)

    def _unbind_listeners(self):
        main_window = self._viewer.GetTopLevelParent()
        main_window.Unbind(wx.EVT_CHAR_HOOK, handler=self.on_keypress)

    def _unpack(self, selected):
        if selected and not self.multiple and len(selected) == 1:
            return selected[0]  # list holding 1 value only
        else:
            return selected


class ViewerSelection(SimpleViewerSelection):
    """Sets up a context in which the user can select one or multiple objects
    in the :class:`parapy.gui.viewer.Viewer`. Disables tree and property view
    panels.

    Usage:

    >>> from parapy.gui.actions import ViewerSelection
    >>>
    >>> context = ViewerSelection(main_window)
    >>> success = context.start()
    >>> if success:  # alternatively: ``if context.start():``
    >>>     print context.selected
    >>> else:
    >>>     print "cancelled"

    :param parapy.gui.main.MainWindow main_window: main GUI window.
    :param str | None msg: a *short* info message shown at the start of
        each selection action. A standard :attr:`INSTRUCTION_MSG` sentence is
        appended to this ``msg`` explaining which keys to press for submitting
        or cancelling. Example: :py:`"Select 2 planes."`.
    :param bool multiple: If True, the selection (single / multiple
        objects) is returned in a list. If False and a single object is
        selected, the selected object itself is returned.
    :param callable | None validator: like a regular ``validator`` that can be
        specified for slots (:class:`~parapy.core.abstractslot.AbstractSlot`),
        this callback function can validate user selection. Signature:
        ``(value) -> flag | (flag, msg)``, where ``flag`` is either :py:`True`
        (valid) or :py:`False` (invalid). If invalid, the optional ``msg``
        string is shown in a popup dialog (if not specified, a default message
        is shown) and the user stays in selection mode. And ``value`` is:

        - a single :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`False`.
        - a list of :class:`~parapy.core.abstract.DrawableParaPyObject` in case
            :attr:`multiple` is :py:`True`.
    :param bool popup: if there's a status bar in the top-level window, it will
        be used to show the initial message to the user unless this value is
        :py:`True` in which case a popup dialog is shown. If there's no status
        bar, there will always be a popup dialog irrespective of this value.
    :param bool ask_confirmation: show confirmation dialog on submit?
    """
    def __init__(self, main_window, msg=None, multiple=False, validator=None,
                 popup=False, ask_confirmation=False):
        viewer = main_window.viewer
        super(ViewerSelection, self).__init__(
            viewer, msg=msg, multiple=multiple, validator=validator,
            popup=popup, ask_confirmation=ask_confirmation)
        self._main_window = main_window

    def context(self):
        return ViewerSelectionContext(self._main_window)


class SimpleViewerSelectionContext(object):
    """If status bar is present, will empty status bar and restore on exit.
    Moreover, it will temporarily unbind Esc / Enter keys presses from Viewer.

    :type viewer: parapy.gui.viewer.Viewer
    """
    def __init__(self, viewer):
        self.viewer = viewer
        self._status_bar = viewer.GetTopLevelParent().GetStatusBar()
        self._state = {}

    def __enter__(self):
        self._state = self.setup()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.teardown(self._state)

    def setup(self):
        state = {}
        if self._status_bar:
            state["status_message"] = self._status_bar.GetStatusText()
        self.viewer._occ_viewer.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
        return state

    def teardown(self, state):
        if self._status_bar:
            self._status_bar.SetStatusText(state["status_message"])
        self.viewer._occ_viewer.Unbind(wx.EVT_KEY_DOWN, handler=self.OnKeyDown)

    @staticmethod
    def OnKeyDown(evt):
        if evt.GetKeyCode() in {wx.WXK_ESCAPE, wx.WXK_RETURN,
                                wx.WXK_NUMPAD_ENTER}:
            pass  # don't .Skip()
        else:
            evt.Skip()


class ViewerSelectionContext(SimpleViewerSelectionContext):
    """Set up MainWindow for object selection and restores on exit. It disables
    tree and data panels and suppresses EVT_LEFT_CLICK_OBJECT from viewer.

    :type main_window: parapy.gui.main.MainWindow
    """
    def __init__(self, main_window):
        self.main_window = main_window
        viewer = main_window.viewer
        super(ViewerSelectionContext, self).__init__(viewer)

    def setup(self):
        # super call sets up status bar (if present)
        state = super(ViewerSelectionContext, self).setup()

        main_window, viewer = self.main_window, self.viewer
        tree_panel = main_window.tree_panel
        data_panel = main_window.data_panel

        # save before state
        state["tree_panel_enabled"] = tree_panel.IsEnabled()
        state["data_panel_enabled"] = data_panel.IsEnabled()

        # put gui in state for selection by disabling tree and data panels
        # and not having EVT_LEFT_CLICK_OBJECT trickle up from the Viewer
        tree_panel.Enable(False)
        data_panel.Enable(False)

        def OnLeftClickObject(evt):
            pass  # don't .Skip()

        viewer.Bind(EVT_LEFT_CLICK_OBJECT, OnLeftClickObject)

        state["viewer_on_left_click_object"] = OnLeftClickObject

        return state

    def __exit__(self, exc_type, exc_val, exc_tb):
        # super call restores status bar (if present)
        super(ViewerSelectionContext, self).__exit__(exc_type, exc_val, exc_tb)

        main_window, viewer, state = self.main_window, self.viewer, self._state
        main_window.tree_panel.Enable(state["tree_panel_enabled"])
        main_window.data_panel.Enable(state["data_panel_enabled"])
        viewer.Unbind(EVT_LEFT_CLICK_OBJECT,
                      handler=state["viewer_on_left_click_object"])

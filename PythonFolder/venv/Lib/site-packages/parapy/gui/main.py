#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""The graphical inspector is an application to view and interact with a
tree of ParaPy objects, display their attributes and geometry.
"""

import os
import pickle
import sys
import warnings
from functools import partial

import wx
from OCC.gui.viewer import VALID_IMAGE_EXTENSIONS
from parapy.core import parse_refchain
from parapy.globs import PKG_DIR
from parapy.gui import wx34
from parapy.gui.data import DataPanel
from parapy.gui.dialogs import AboutBox
from parapy.gui.events import (
    EVT_DISP, EVT_EXPAND, EVT_HIDE, EVT_REFRESH, EVT_SELECTION_CHANGED,
    EVT_SELECT_OBJECT)
from parapy.gui.globs import CONFIGURATION, DAT_DIR
from parapy.gui.tree import PathNotInTreeError, TreePanel
from parapy.gui.tree_viewer import TreeViewerPanel
from parapy.gui.wx_utils import popup

VALID_GEOMETRY_EXTENSIONS = (".brep", ".iges", ".brep", ".stl", ".igs", ".stp")
VALID_GEOMETRY_EXTENSIONS_SET = frozenset(VALID_GEOMETRY_EXTENSIONS)


# FIXME (RvD): reimplement support for saving / loading perspectives.
class MainWindow(wx.Frame):
    """The main window of the graphical inspector.

    :param obj: root object(is) to display.
    :param int display_number: which display to display on, default is 1.
    :param dict globals: module globals used for eval in property grid.

    To gain access to the GUI in interactive Python
    from parapy.gui import WindowManager
    WindowManager.newest / oldest / etc. -> <MainWindow>

    To customize the WxPython-based user interface, see:
    http://wxpython.org/Phoenix/docs/html/
    """

    STATUS_BAR = CONFIGURATION["status_bar"]
    #: :type: wx.App | None
    #: display() can add a reference to wx.App here to avoid gc'ing
    _app = None

    def __init__(self, obj, display_number=1,
                 globals=None, view='iso',
                 title="ParaPy Graphical User Interface"):

        pos = wx.DefaultPosition
        if display_number != 1:
            num_displays = wx.Display.GetCount()
            if display_number > num_displays:
                msg = ("Found only {} displays on this system. Will open on "
                       "display 1 instead of {}.")
                warnings.warn(msg.format(num_displays, display_number))
            else:
                display = wx.Display(display_number - 1)
                pos = display.GetGeometry().GetTopLeft()

        wx.Frame.__init__(self, None, -1, title, pos)

        #: :type: parapy.core.Base
        self.obj = obj
        #: :type: dict
        self.globals = globals or {}
        #: :type: bool
        self.triedron = True

        #: :type: wx.BoxSizer
        self.sizer = None
        #: :type: wx.SplitterWindow
        self.splitter_left_right = None
        #: :type: wx.SplitterWindow
        self.splitter_left = None
        #: :type: parapy.gui.tree.TreePanel
        self.tree_panel = None
        #: :type: parapy.gui.data.DataPanel
        self.data_panel = None
        #: :type: parapy.gui.tree_viewer.TreeViewerPanel
        self.tree_viewer_panel = None
        #: :type: parapy.gui.dialogs.AboutBox
        self.about_dialog = AboutBox(self)
        #: :type: wx.MenuBar
        self.menu_bar = None
        #: :type: wx.StatusBar
        self.status_bar = None

        self.init_layout()

        #: :type: parapy.gui.tree.ObjectTree
        self.tree = self.tree_panel.tree
        #: :type: parapy.gui.viewer.Viewer
        self.viewer = self.tree_viewer_panel.viewer

        self.init_menu_bar()
        self.init_event_handling()
        self.set_view(view)

        if self.STATUS_BAR:
            self.init_status_bar()

    def init_event_handling(self):
        self.Bind(wx.EVT_CLOSE, self.on_close)
        self.Bind(EVT_SELECT_OBJECT, self.on_select_object)
        self.data_panel.Bind(EVT_REFRESH, self.refresh_event_handler)
        # self.tree_panel.Bind(EVT_REFRESH, self.refresh_event_handler)
        self.Bind(EVT_REFRESH, self.refresh_event_handler)
        self.Bind(EVT_DISP, self.on_display)
        self.Bind(EVT_HIDE, self.tree_viewer_panel.hide_event_handler)
        self.Bind(EVT_EXPAND, self.on_initial_tree_expand)
        self.Bind(EVT_SELECTION_CHANGED, self.on_selection_changed)

        # unbind handlers which should not handle the refresh anymore
        self.tree_panel.Unbind(EVT_REFRESH)

    def init_layout(self):
        obj = self.obj

        self.Maximize(True)

        sizer = wx.BoxSizer(wx.HORIZONTAL)
        sty = wx.SP_3D  # wx.SP_LIVE_UPDATE |
        splitter_left_right = wx.SplitterWindow(self, -1, style=sty)
        splitter_left = wx.SplitterWindow(splitter_left_right, -1, style=sty)

        tree_panel = TreePanel(splitter_left, obj, globals=self.globals)
        data_panel = DataPanel(splitter_left, obj, globals=self.globals,
                               autodisplay=False)
        tree_viewer_panel = TreeViewerPanel(splitter_left_right, obj)

        splitter_left.SetMinimumPaneSize(250)
        splitter_left.SplitHorizontally(tree_panel, data_panel)
        splitter_left_right.SetMinimumPaneSize(200)
        pos = int(self.GetSize().GetWidth() * 0.25)
        splitter_left_right.SplitVertically(splitter_left, tree_viewer_panel, pos)
        sizer.Add(splitter_left_right, 1, wx.EXPAND, 5)

        self.SetSizer(sizer)
        self.Layout()

        self.sizer = sizer
        self.splitter_left_right = splitter_left_right
        self.splitter_left = splitter_left
        self.tree_panel = tree_panel
        self.data_panel = data_panel
        self.tree_viewer_panel = tree_viewer_panel

    def init_menu_bar(self):

        self.menu_bar = menu_bar = wx.MenuBar()
        self.SetMenuBar(menu_bar)

        # File menu items
        menu = wx.Menu()
        menu_bar.Append(menu, "&File")
        m_clear_viewport = menu.Append(-1, "Clear viewport")
        m_exit = menu.Append(wx.ID_EXIT, "E&xit\tAlt-X", "Close window and exit program.")
        m_save_geometry = menu.Append(-1, "Save geometry...")
        m_save_image = menu.Append(-1, "Save image...")

        # View menu items
        menu = wx.Menu()
        menu_bar.Append(menu, "&View")
        m_save_view = menu.Append(-1, "Save perspective...")
        m_load_view = menu.Append(-1, "Load perspective...")
        m_toggle_axes = menu.AppendCheckItem(-1, "Display Axes")
        m_toggle_autodraw = menu.AppendCheckItem(-1, "Auto Redraw")

        m_bg_color = menu.Append(-1, "Choose background color...")
        m_bg_color_reset = menu.Append(-1, "Reset Background")

        camera_menu = wx.Menu()
        menu.AppendSubMenu(camera_menu, "&Camera")
        m_print_camera = camera_menu.Append(-1, "Print current camera")
        m_camera_code = camera_menu.Append(-1, "Print current camera code")

        persp_menu = wx.Menu()
        menu.AppendSubMenu(persp_menu, "&Perspectives")
        m_top = persp_menu.Append(-1, "Top (z+)")
        m_bottom = persp_menu.Append(-1, "Bottom (z-)")
        m_right = persp_menu.Append(-1, "Right view (x+)")
        m_left = persp_menu.Append(-1, "Left view (x-)")
        m_front = persp_menu.Append(-1, "Front view (y+)")
        m_back = persp_menu.Append(-1, "Back view (y-)")
        m_iso = persp_menu.Append(-1, "Iso view")

        # Selection mode
#         menu = wx.Menu()
#         m_about = menu.Append(wx.ID_ABOUT, "&Selection Mode", "Selection modes")
#         self.Bind(wx.EVT_MENU, self.on_about, m_about)
#         m_html_docs = menu.Append(wx.ID_HELP, "&Documentation (HTML)", "ParaPy documentation")
#         self.Bind(wx.EVT_MENU, self.open_html_doc, m_html_docs)
#         # FIXME: choosing ID_HELP again, will override previous event...
#         m_pdf_docs = menu.Append(wx.ID_HELP_CONTENTS, "&Documentation (PDF)", "ParaPy documentation")
#         self.Bind(wx.EVT_MENU, self.open_pdf_doc, m_pdf_docs)
#         menuBar.Append(menu, "&Selection modes")

        # Help menu items
        menu = wx.Menu()
        menu_bar.Append(menu, "&Help")
        m_about = menu.Append(wx.ID_ABOUT, "&About",
                              "Information about this program")
        m_keymap = menu.Append(wx.ID_ANY, "&Default Keymap Reference",
                               "Default Keymap Reference")
        # TODO RvD: link documentation again.
        # menu.AppendSeparator()
        # m_html_docs = menu.Append(wx.ID_HELP, "&Documentation (HTML)", "ParaPy documentation")
        # m_pdf_docs = menu.Append(wx.ID_HELP_CONTENTS, "&Documentation (PDF)", "ParaPy documentation") # not ID_HELP

        self.Bind(wx.EVT_MENU, self.save_view, m_save_view)
        self.Bind(wx.EVT_MENU, self.load_view, m_load_view)
        self.Bind(wx.EVT_MENU, self.toggle_axes, m_toggle_axes)
        self.Bind(wx.EVT_MENU, self.change_background_color, m_bg_color)
        self.Bind(wx.EVT_MENU, self.reset_background, m_bg_color_reset)
        self.Bind(wx.EVT_MENU, self.print_camera, m_print_camera)
        self.Bind(wx.EVT_MENU, self.print_camera_code, m_camera_code)
        self.Bind(wx.EVT_MENU, self.set_top_view, m_top)
        self.Bind(wx.EVT_MENU, self.set_bottom_view, m_bottom)
        self.Bind(wx.EVT_MENU, self.set_right_view, m_right)
        self.Bind(wx.EVT_MENU, self.set_left_view, m_left)
        self.Bind(wx.EVT_MENU, self.set_front_view, m_front)
        self.Bind(wx.EVT_MENU, self.set_back_view, m_back)
        self.Bind(wx.EVT_MENU, self.set_iso_view, m_iso)
        self.Bind(wx.EVT_MENU, self.on_clear_viewport, m_clear_viewport)
        self.Bind(wx.EVT_MENU, self.on_close, m_exit)
        self.Bind(wx.EVT_MENU, self.on_save_displayed_geometry, m_save_geometry)
        self.Bind(wx.EVT_MENU, self.save_image, m_save_image)
        self.Bind(wx.EVT_MENU, self.on_about, m_about)
        self.Bind(wx.EVT_MENU, self.on_keymap, m_keymap)
        self.Bind(wx.EVT_MENU, self.on_autodraw, m_toggle_autodraw)
        # self.Bind(wx.EVT_MENU, self.open_html_doc, m_html_docs)
        # self.Bind(wx.EVT_MENU, self.open_pdf_doc, m_pdf_docs)

        self.Bind(wx.EVT_UPDATE_UI, self.on_update_toggle_axes_menu,
                  m_toggle_axes)
        self.Bind(wx.EVT_UPDATE_UI, self.on_update_toggle_autodraw_menu,
                  m_toggle_autodraw)

    def on_update_toggle_axes_menu(self, evt):
        evt.Check(self.viewer._occ_viewer.triedron)

    def on_update_toggle_autodraw_menu(self, evt):
        evt.Check(self.tree_viewer_panel.autodraw)

    def init_status_bar(self, style=wx.STB_DEFAULT_STYLE, **kwargs):
        """Create a status bar at bottom of main window.

        :param style: wx.StatusBar style, by default:

            - displays a gripper at the right-hand side of the status bar which
                can be used to resize the parent window.
            - displays tooltips for those panes whose status text has been
                ellipsized/truncated because the status text doesn’t fit the
                pane width.
            - replaces the end of the status texts with an ellipsis when the
                status text widths exceed the status bar pane’s widths
            - repaints on resize

            See: https://wxpython.org/Phoenix/docs/html/wx.StatusBar.html.

        :param kwargs: Other inputs for wx.CreateStatusBar (excluding style).
        """

        # ATTENTION: we need to pass style explicitly, even when
        # STB_DEFAULT_STYLE otherwise style does not take affect
        # (at least in wx3...).
        self.status_bar = self.CreateStatusBar(style=style, **kwargs)

        # set the background, otherwise it will have a different tint of gray
        colour = wx34.SystemSettings_GetColour(wx.SYS_COLOUR_FRAMEBK)
        self.status_bar.SetBackgroundColour(colour)

    def on_close(self, event):
        if CONFIGURATION["warn_on_close_inspector"]:
            dlg = wx.MessageDialog(self,
                                   "Do you really want to close this application?",
                                   "Confirm Exit", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result != wx.ID_OK:
                return

        self._destroy()
        event.Skip()

    def _destroy(self):
        # if this window is in the process of being destroyed, don't destroy
        # it again
        if not self.IsBeingDeleted():
            self.about_dialog.Destroy()
            self.viewer.dlg_appearance.Destroy()
            self.viewer.dlg_background_grid.Destroy()
            self._app = None  # allow gc'ing of wx.App (set through display())
            self.Destroy()

    def on_about(self, evt):
        self.about_dialog.ShowModal()
        self.about_dialog.HideWithEffect(0)

    def on_keymap(self, evt):
        filename = os.path.join(DAT_DIR, "keymap.pdf")
        open_file_default_application(filename)

    def on_autodraw(self, evt):
        tree_viewer = self.tree_viewer_panel
        tree_viewer.autodraw = autodraw = bool(evt.Selection)
        if autodraw:  # if autodraw was just checked, then display everything
            tree_viewer.display((), state=True)
            self.refresh()  # drawing could have side-effected values

    def open_html_doc(self, event):
        self._open_file('HTML')

    def open_pdf_doc(self, event):
        self._open_file('PDF')

    def _open_file(self, mode):
        # FIXME: webbrowser package doesn't open files in browser.
        # For now use os/subprocess functionality to achieve this.
        import subprocess, os
        assert mode == 'HTML' or mode == 'PDF'
        if mode == 'HTML':
            filepath = os.path.abspath(os.path.join(PKG_DIR, '..', '..',
                                                    "doc/build/html/index.html"))
        elif mode == 'PDF':
            filepath = os.path.abspath(os.path.join(PKG_DIR, '..', '..',
                                                    "doc/build/latex/ParaPy.pdf"))
        if sys.platform.startswith('darwin'):
            subprocess.call(('open', filepath))
        elif os.name == 'nt':
            try:
                os.startfile(filepath)
            except WindowsError as e:
                raise Exception("""Windows probably couldn't find the default application to open {mode} files with.
                If you want to open the documentation from within this GUI, tell Windows what the default application is for openings {mode} files.
                Otherwise manually open {file} with your application of choice.
                Error message: {e}""".format(mode = mode, file = filepath, e = e))
        elif os.name == 'posix':
            subprocess.call(('xdg-open', filepath))

    def refresh(self, panels_to_skip=()):
        all_panels = [self.tree_panel, self.data_panel, self.tree_viewer_panel]
        for panel in all_panels:
            if panel in panels_to_skip:
                continue
            panel.refresh()

    def refresh_event_handler(self, evt):
        self.refresh(panels_to_skip={evt.source})
        evt.Skip()

    def on_initial_tree_expand(self, evt):
        self.data_panel.refresh()

    def on_display(self, evt):
        self.tree_viewer_panel.display_event_handler(evt)
        self.data_panel.refresh()

    def on_draw(self, event):
        self.tree_viewer_panel.draw(event.path_to_draw, event.recursive)

    def on_erase(self, event):
        self.tree_viewer_panel.erase(event.path_to_erase, event.recursive)

    def on_clear_viewport(self, event):
        self.tree_viewer_panel.viewer.hide_all(update=True)

    def on_select_object(self, evt):
        self.data_panel.display(evt.path, evt.obj)

    def on_selection_changed(self, evt):
        # change data_panel to selected object
        if CONFIGURATION['update_data_panel_on_geom_click']:
            owner = evt.owner
            path = evt.refchain

            if not (path is None or owner is None):
                self.data_panel.display(path, owner)

        # highlight object in the tree
        update_tree = CONFIGURATION['update_tree_on_viewer_object_click']
        if update_tree:
            if update_tree == 'item':
                highlight_tree = self.tree_panel.tree.highlight
            elif update_tree == 'item_no_expand':
                highlight_tree = partial(self.tree_panel.tree.highlight,
                                         expand=False, ancestor=True)

            tree = self.tree_panel.tree
            owner = evt.owner
            with wx.FrozenWindow(tree):
                # an object can be known by multiple refchains, try them one
                # by one if there is one pointing at the tree item
                for refchain in self._yield_refchains(evt):
                    try:
                        could_highlight = highlight_tree(refchain, obj=owner)
                    except PathNotInTreeError:
                        continue
                    else:
                        if could_highlight:
                            break
                        else:
                            continue

    def _yield_refchains(self, evt):
        """Yield rechains from EVT_SELECTION_CHANGED ``evt``."""
        # event refchain has preference since it can be modified by
        # the end-user to the point where it should be
        yield evt.refchain

        obj = evt.owner
        # then the 'parapy refchain' has the highest chance to have a
        # relation with the ObjectTree
        try:
            parapy_refchain = obj.refchain
        except AttributeError:  # has no attribute refchain
            pass
        else:  # has an attribute refchain
            # remove 'root.' prefix, then parse it
            yield parse_refchain(parapy_refchain[5:])

        # then ask the tree_viewer if there are paths known for the object
        for path in self.tree_viewer_panel.get_object_paths(obj):
            yield path

    def set_view(self, name):
        """Set named view.

        :param str name: one of 'iso', 'front', 'right', 'back', 'left',
            'bottom', 'top'.
        :raises RuntimeError: if ``name`` doesn't name valid view.
        """
        if name == 'iso':
            self.set_iso_view()
        elif name == 'front':
            self.set_front_view()
        elif name == 'back':
            self.set_back_view()
        elif name == 'left':
            self.set_left_view()
        elif name == 'right':
            self.set_right_view()
        elif name == 'top':
            self.set_top_view()
        elif name == 'bottom':
            self.set_bottom_view()
        else:
            raise RuntimeError("view {:} not one of 'iso' (default), 'front', "
                               "'back', 'right', 'left', 'top', "
                               "'bottom'".format(repr(name)))

    def set_top_view(self, evt=None):
        self.viewer._occ_viewer.view_top()

    def set_bottom_view(self, evt=None):
        self.viewer._occ_viewer.view_bottom()

    def set_right_view(self, evt=None):
        self.viewer._occ_viewer.view_right()

    def set_left_view(self, evt=None):
        self.viewer._occ_viewer.view_left()

    def set_front_view(self, evt=None):
        self.viewer._occ_viewer.view_front()

    def set_back_view(self, evt=None):
        self.viewer._occ_viewer.view_back()

    def set_iso_view(self, evt=None):
        self.viewer._occ_viewer.view_iso()

    def fit_all(self, evt=None):
        self.viewer.fit_all()

    def toggle_axes(self, evt=None):
        self.viewer._occ_viewer.toggle_axes()

    def reset_background(self, event=None):
        self.viewer._occ_viewer.reset_background(update=False)
        self.viewer._occ_viewer.init_background()

    def print_camera(self, event=None):
        occ_viewer = self.viewer._occ_viewer
        occ_viewer.camera.dump()

    def print_camera_code(self, event=None):
        camera = self.viewer._occ_viewer.camera
        template = ("from parapy.gui.camera import MinimalCamera\n"
                    "MinimalCamera(eye_location={}, viewing_center={}, "
                    "up_direction={}, scale={}, aspect_ratio={})")
        print(template.format(camera.eye_location, camera.viewing_center,
                              camera.up_direction, camera.scale,
                              camera.aspect_ratio))

    def change_background_color(self, event=None):
        dlg = wx.ColourDialog(self)
        if dlg.ShowModal() == wx.ID_OK:
            retData = dlg.GetColourData()
            col = retData.GetColour()
            r, g, b = col.Get(includeAlpha=False)
            self.viewer._occ_viewer.set_background_color((r, g, b))
        dlg.Destroy()

    def save_image(self, evt=None):
        """Save image of view. Open file dialog."""
        message = "Save image"
        default_dir = os.path.expanduser("~")
        wildcard = "Images (*.{})|*.{}".format(
            ",*.".join(VALID_IMAGE_EXTENSIONS),
            ";*.".join(VALID_IMAGE_EXTENSIONS))

        path = self._select_file(message, default_dir, wildcard, True)
        if path:
            self.viewer.save_image(path)

    def on_save_displayed_geometry(self, evt=None):
        """Save currently displayed geometry. Open file dialog."""
        if not self.viewer.displayed:
            # TODO: show pop-up message
            popup("Warning", "Display something first!")
            return

        s1 = "'" + "'*'".join(VALID_GEOMETRY_EXTENSIONS) + "'"
        s2 = "*" + ",*".join(VALID_GEOMETRY_EXTENSIONS)
        s3 = "*" + ";*".join(VALID_GEOMETRY_EXTENSIONS)

        message = "Save geometry ({})".format(s1)
        wildcard = "Geometry files ({}) |{}".format(s2, s3)
        default_dir = os.getcwd()

        path = self._select_file(message, default_dir, wildcard, True)
        if path:
            self.save_displayed_geometry(path)

    def save_displayed_geometry(self, filename):
        """Save currently displayed geometry to ``filename``. Valid extensions
        are .step, .stp, .iges, .igs., .brep or .stl.

        :param str filename: file to save geometry in.
        """
        objs = self.viewer.displayed

        if not objs:
            warnings.warn("Display something first!")
            return

        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in VALID_GEOMETRY_EXTENSIONS_SET:
            msg = "Invalid format '{}'. choose one of: {}."
            raise RuntimeError(msg.format(ext, VALID_GEOMETRY_EXTENSIONS))

        if ext == ".step" or ext == ".stp":
            from parapy.exchange.step import STEPWriter
            STEPWriter(nodes=objs).write(filename)
        elif ext == ".iges" or ext == ".igs":
            from parapy.exchange.iges import IGESWriter
            IGESWriter(nodes=objs).write(filename)
        elif ext == ".brep":
            from parapy.exchange.brep import BRepWriter
            BRepWriter(shape_in=objs).write(filename)
        elif ext == ".stl":
            from parapy.exchange.stl import STLWriter
            if len(objs) > 1:
                from parapy.geom import Compound
                obj = Compound(built_from=objs)
            else:
                obj = objs[0]
            STLWriter(shape_in=obj).write(filename)

    def load_view(self, evt=None):
        path = self._select_camera_file_dlg(False)
        if path:
            self._load_view(path)

    def save_view(self, evt=None):
        """Saves view to .CAMERA file"""
        path = self._select_camera_file_dlg(True)
        if path:
            self._save_view(path)

    def _select_camera_file_dlg(self, save):
        if save:
            message = "Save a view"
        else:
            message = "Load a view"
        wildcard = "CAMERA files (*.CAMERA) |*.CAMERA"
        return self._select_file(message, None, wildcard, save)

    def _select_file(self, message, default_dir, wildcard, save):
        if default_dir is None:
            default_dir = ""
        style = wx.FD_SAVE if save else wx.FD_OPEN
        dlg = wx.FileDialog(self, message, default_dir, "", wildcard, style)
        if dlg.ShowModal() == wx.ID_CANCEL:
            path = None
        else:
            path = dlg.GetPath()
        dlg.Destroy()
        return path

    def _save_view(self, path):
        """Save the current 'view' (the camera position) to ``path``.

        :param str path: path to the file in which one wants to save the view.
        """
        # we get the OCC camera, because it is pickleable
        pickle = pickle.dumps(self.viewer._occ_viewer.camera)
        with open(path, 'w') as f:
            f.write(pickle)

    def _load_view(self, path):
        """Load a previously saved view from ``path``, and restore it
        in the Viewer.

        :param str path: path to a file previously made with :meth:`_save_view`
        """
        with open(path) as f:
            #: :type: OCC.gui.camera.Camera
            camera = pickle.loads(f.read())

        # now yield processing power to wx to handle any events still in the
        # queue. At this point, we want to have processed all mouse events
        # that were cast with the previous camera settings to avoid
        # MoveTo calls based on obsolete data
        wx.SafeYield()

        self.viewer.set_camera(camera)


def open_file_default_application(filename):
    import subprocess
    if sys.platform.startswith('darwin'):
        subprocess.call(('open', filename))
    elif os.name == 'nt':
        os.startfile(filename)
    elif os.name == 'posix':
        subprocess.call(('xdg-open', filename))


if __name__ == '__main__':
    app = wx.GetApp() or wx.App(False)
    app.locale = wx.Locale(wx.LANGUAGE_ENGLISH)
    frame = MainWindow([], globals={}, display_number=1, view='iso')
    app.SetTopWindow(frame)
    frame.Show(True)
    frame.Raise()

    app.MainLoop()

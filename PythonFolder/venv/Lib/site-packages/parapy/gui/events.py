#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This module defines several events that are triggered by the components (
child panels) of the graphical user interface. The main window catches these
and takes appropriate action w.r.t. other components. This is how the
different parts of the GUI communicate.

Creating an event is done through create_..._event() functions: this ensures
that the required parameters are available and the event object has the
correct attributes.
"""

from wx.lib.newevent import NewCommandEvent

from parapy.core import on_event
from parapy.core.abstract import ParaPyObject
from parapy.core.events import VetoableEvent
from parapy.core.utilities import _parse_refchain

# --- common events ---
RefreshEvent, EVT_REFRESH = NewCommandEvent()

# --- Tree events ---
DisplayEvent, EVT_DISP = NewCommandEvent()
HideEvent, EVT_HIDE = NewCommandEvent()
SetSelfEvent, EVT_SELF = NewCommandEvent()
FirstExpansionEvent, EVT_EXPAND = NewCommandEvent()
SelectObjectEvent, EVT_SELECT_OBJECT = NewCommandEvent()
RightClickTreeObjectEvent, EVT_RIGHT_CLICK_TREE_OBJECT = NewCommandEvent()

# --- Viewer events ---
LeftClickObjectEvent, EVT_LEFT_CLICK_OBJECT = NewCommandEvent()
RightClickObjectEvent, EVT_RIGHT_CLICK_OBJECT = NewCommandEvent()
LeftClickBackgroundEvent, EVT_LEFT_CLICK_BACKGROUND = NewCommandEvent()
RightClickBackgroundEvent, EVT_RIGHT_CLICK_BACKGROUND = NewCommandEvent()
TooltipEvent, EVT_TOOLTIP = NewCommandEvent()
SelectionChangedEvent, EVT_SELECTION_CHANGED = NewCommandEvent()
# not wx events, bind it in a ParaPy class
EVT_OBJECT_TOOLTIP = "evt_object_tooltip"
EVT_SELECTION_CHANGING = "evt_selection_changing"


# These functions here are to enforce the data is present in each event cast
def create_refresh_event(source):
    """Send refresh event."""
    return RefreshEvent(-1, source=source)


def create_disp_event(path, state):
    """Creates a display event.
    
    Args:
        path (tuple)
        state (True|False|None):
            - True: display this object and all children
            - False: display only top object
            - None: display only the children
    """
    return DisplayEvent(-1, path=path, state=state)


def create_hide_event(path, state):
    """Creates a hide event.
    
    Args:
        path (tuple): path from root.
        state (True|False|None):
            - True: display this object and all children
            - False: display only top object
            - None: display only the children
    """
    return HideEvent(-1, path=path, state=state)


def create_set_self_event(path):
    """Create a EVT_SETSELF. In interactive Python mode, the clicked objects
    becomes the bound to 'self' inside main module.

    Args:
        path (tuple): path from root.
    """
    return SetSelfEvent(-1, path=path)


def create_select_object_event(path, obj=None):
    """Create a EVT_SELECT_OBJECT. Triggered by Tree. Handled by Grid.

    Args:
        obj (ParaPyObject): selected object
    """
    return SelectObjectEvent(-1, path=path, obj=obj)


def create_right_click_tree_object_event(source, obj, path, point, item):
    return RightClickTreeObjectEvent(-1, source=source, obj=obj, path=path,
                                     point=point, item=item)


def create_left_click_object_event(source, pos, selected, multiple):
    return LeftClickObjectEvent(-1, source=source, pos=pos, selected=selected,
                                multiple=multiple)


def create_right_click_object_event(source, pos, selected, multiple):
    return RightClickObjectEvent(-1, source=source, pos=pos, selected=selected,
                                 multiple=multiple)


def create_left_click_background_event(source, pos):
    return LeftClickBackgroundEvent(-1, source=source, pos=pos)


def create_right_click_background_event(source, pos):
    return RightClickBackgroundEvent(-1, source=source, pos=pos)


def create_tooltip_event(source, detected):
    return TooltipEvent(-1, source=source, detected=detected)


def on_left_click(fget=None, filters=None):
    """Syntactic sugar for :func:`on_event` to quickly add handlers to
    left-click events.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.gui.events import on_left_click
    >>> class FooBox(Box):
    ...     @on_left_click
    ...     def on_foo_left_click(self, evt):
    ...         x, y = evt.pos
    ...         print("I was left-clicked at x={}, y={}".format(x, y))
    ... 


    See :func:`on_event` for an extended explanation.
    """
    event_decorator = on_event(event_type=EVT_LEFT_CLICK_OBJECT,
                               filters=filters)
    return event_decorator if fget is None else event_decorator(fget=fget)


def on_right_click(fget=None, filters=None):
    """Syntactic sugar for :func:`on_event` to quickly add handlers to
    right-click events ``of_objects``.

    Usage:

    >>> from parapy.geom import Box
    >>> from parapy.gui.events import on_right_click
    >>> class FooBox(Box):
    ...     @on_right_click
    ...     def on_foo_right_click(self, evt):
    ...         x, y = evt.pos
    ...         print("I was right-clicked at x={}, y={}".format(x, y))
    ... 

    See :func:`on_event` for an extended explanation.
    """
    event_decorator = on_event(event_type=EVT_RIGHT_CLICK_OBJECT,
                               filters=filters)
    return event_decorator if fget is None else event_decorator(fget=fget)


def create_selection_changing_event(source, owner, refchain,
                                    refchain_resolver):
    return SelectionChangingEvent(source=source, owner=owner,
                                  refchain=refchain,
                                  refchain_resolver=refchain_resolver,
                                  EventType=EVT_SELECTION_CHANGING)


def create_object_tooltip_event(source, owner, refchain, refchain_resolver):
    return ObjectTooltipEvent(source=source, owner=owner, refchain=refchain,
                              refchain_resolver=refchain_resolver,
                              EventType=EVT_OBJECT_TOOLTIP)


def create_selection_changed_event(source, owner, refchain):
    return SelectionChangedEvent(-1, source=source, owner=owner,
                                 refchain=refchain)


class OwnerEvent(VetoableEvent):
    """Base class allowing the user to set a new owner, if its reference
    chain can be resolved.

    :param parapy.core.Base owner: The newly set owner.
    :param tuple[int | str] refchain: The 'parsed' reference chain to 'owner'.
        .. caution:: No check is done at this point if the reference chain
            is indeed going to the owner.
    :param types.Callable[[parapy.core.Base], list[tuple[int | str]]] refchain_resolver:
        A callable that resolves a the reference chain to a given object. It
        should return a list of the parsed reference chains
    """

    def __init__(self, **kwargs):
        owner = kwargs.pop('owner', None)
        refchain = kwargs.pop('refchain', None)
        refchain_resolver = kwargs.pop('refchain_resolver', None)

        if owner is None or refchain is None or refchain_resolver is None:
            msg = ('{} at least expects "owner", '
                   '"refchain" and "refchain_resolver" keyword during '
                   'construction. Object: {!r}')
            raise TypeError(msg.format(type(self), self))

        self.__owner = owner
        self.__refchain = refchain  # the user should know what he's doing
        self.__refchain_resolver = refchain_resolver
        super(OwnerEvent, self).__init__(**kwargs)

    @property
    def refchain(self):
        return self.__refchain

    @property
    def refchain_resolver(self):
        return self.__refchain_resolver

    @property
    def owner(self):
        return self.__owner

    @owner.setter
    def owner(self, new_owner):
        if not isinstance(new_owner, ParaPyObject):
            msg = ("Could not set owner to {}. The owner can only be a "
                   "ParaPyObject.")
            raise TypeError(msg.format(new_owner))

        resolve_refchain = self.refchain_resolver
        refchain = resolve_refchain(new_owner)
        if refchain:
            refchain = refchain[0]
        elif hasattr(new_owner, 'root') and hasattr(new_owner, 'refchain'):
            root_refchain = resolve_refchain(new_owner.root)
            if root_refchain:
                # TODO (TBD): Now chooses the first reference chain, might be
                # /todo ambiguous if there are multiple.
                refchain = root_refchain[0] + tuple(_parse_refchain(
                    new_owner.refchain))[1:]  # skip 'root'
            else:
                refchain = None
        else:
            refchain = None

        if refchain is None:
            msg = ("Could not resolve a reference chain to the new owner {}. "
                   "Make sure the new owner is in the same ParaPy tree as the "
                   "old owner, or that the new owner is a child of the "
                   "same ParaPy tree.")
            raise RuntimeError(msg.format(new_owner))
        else:
            self.__refchain = refchain
            self.__owner = new_owner


class ObjectTooltipEvent(OwnerEvent):
    """Event object thrown during EVT_OBJECT_TOOLTIP"""
    pass


class SelectionChangingEvent(OwnerEvent):
    """Event object thrown during EVT_SELECTION_CHANGING. It allows the user to
    set a new owner, if its reference chain can be resolved.

    :param parapy.core.Base owner: The newly set owner.
    :param tuple[int | str] refchain: The 'parsed' reference chain to 'owner'.
        .. caution:: No check is done at this point if the reference chain
            is indeed going to the owner.
    :param types.Callable[[parapy.core.Base], list[tuple[int | str]]] refchain_resolver:
        A callable that resolves a the reference chain to a given object. It
        should return a list of the parsed reference chains
    """

    def __init__(self, **kwargs):
        self.__allow = True
        super(SelectionChangingEvent, self).__init__(**kwargs)

    def Allow(self, allow=True):
        self.__allow = allow

    def Veto(self, veto=True):
        self.__allow = not veto

    @property
    def IsAllowed(self):
        """Is the event allowed to happen?"""
        return self.__allow


if __name__ == '__main__':
    pass


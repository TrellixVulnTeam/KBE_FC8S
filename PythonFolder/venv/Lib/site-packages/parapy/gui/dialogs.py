#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import sys

import wx
import wx.html
from wx.lib.intctrl import EVT_INT, IntCtrl
from wx.lib.masked import EVT_NUM, NumCtrl

from parapy.core import is_iterable
from parapy.core.globs import DEFAULT_COLOR_RGB


# TODO (TBD): In case multiple objects are selected in viewer, and traits are
# /todo are dissimilar (for example colors of 2 objects different), give a
# /todo user a visual cue in dialog. Now. set_values() takes None as a
# /todo means to express this situation.


class AppearanceDialog(wx.Dialog):
    ###########################################################################
    ## Python code generated with wxFormBuilder (version Jun  5 2014)
    ## http://www.wxformbuilder.org/
    ###########################################################################

    DEFAULT_COLOR = DEFAULT_COLOR_RGB
    DEFAULT_TRANSPARENCY = 0.0
    DEFAULT_LINE_THICKNESS = 1.0
    DEFAULT_DEVIATION_COEFFICIENT = 0.001
    DEFAULT_U_ISOS = 0
    DEFAULT_V_ISOS = 0
    DEFAULT_DISPLAY_MODES = ["shaded",
                             "wireframe",
                             "quick_hlr",
                             "exact_hlr"]
    DEFAULT_DISPLAY_MODE = 'shaded'  # 'shaded'
    DEFAULT_DISPLAY_PRIORITY = 5

    _DEFAULT_DISPLAY_MODE_IDX = DEFAULT_DISPLAY_MODES.index(
        DEFAULT_DISPLAY_MODE)

    def __init__(self, parent, pos=wx.DefaultPosition):
        wx.Dialog.__init__(self, parent, id=wx.ID_ANY,
                           title="Choose display controls",
                           pos=pos,
                           size=wx.DefaultSize,
                           style=wx.DEFAULT_DIALOG_STYLE)

        w = wx.DefaultSize.width
        h = wx.DefaultSize.height
        self.SetSizeHints(w, h, w, h)
        self.SetFont(wx.Font(wx.NORMAL_FONT.GetPointSize(), 70, 90, 90, False,
                             wx.EmptyString))

        vsizer = wx.BoxSizer(wx.VERTICAL)
        sziser1 = wx.StaticBoxSizer(
            wx.StaticBox(self, wx.ID_ANY, "Appearance"), wx.VERTICAL)
        gridsizer1 = wx.FlexGridSizer(3, 2, 0, 0)
        gridsizer1.SetFlexibleDirection(wx.BOTH)
        gridsizer1.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_SPECIFIED)
        sziser2 = wx.StaticBoxSizer(
            wx.StaticBox(self, wx.ID_ANY, "Rendering"), wx.VERTICAL)
        gridsizer2 = wx.FlexGridSizer(3, 2, 0, 0)
        gridsizer2.SetFlexibleDirection(wx.BOTH)
        gridsizer2.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_SPECIFIED)

        buttonsizer = wx.StdDialogButtonSizer()
        self.buttonsizerOK = wx.Button(self, wx.ID_OK)
        buttonsizer.AddButton(self.buttonsizerOK)
        self.buttonsizerCancel = wx.Button(self, wx.ID_CANCEL)
        buttonsizer.AddButton(self.buttonsizerCancel)
        self.buttonsizerReset = wx.Button(self, wx.ID_NO, label="Reset")
        buttonsizer.AddButton(self.buttonsizerReset)
        buttonsizer.Realize()

        sziser1.Add(gridsizer1, 1, wx.EXPAND, 5)
        vsizer.Add(sziser1, 1, wx.EXPAND, 5)
        sziser2.Add(gridsizer2, 1, wx.EXPAND, 5)
        vsizer.Add(sziser2, 0, wx.EXPAND, 5)
        vsizer.Add(buttonsizer, 0, wx.ALIGN_RIGHT, 5)

        self.SetSizer(vsizer)

        # --- color ---
        self.text1 = wx.StaticText(self, wx.ID_ANY, "color",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text1.Wrap(-1)
        self.text1.SetFont(
            wx.Font(wx.NORMAL_FONT.GetPointSize(), 70, 90, 90, False,
                    wx.EmptyString))
        tip_str = ("Choose the display color. You can type a named color ("
                   "e.g. 'red', 'yellow') or choose a custom  RGB color in "
                   "the colorpicker.")
        tip_text1 = wx.ToolTip(tip_str)
        self.text1.SetToolTip(tip_text1)

        gridsizer1.Add(self.text1, 0, wx.ALL | wx.EXPAND, 5)

        self.color = wx.ColourPickerCtrl(
            self, wx.ID_ANY, self.DEFAULT_COLOR, wx.DefaultPosition,
            wx.DefaultSize, wx.CLRP_DEFAULT_STYLE | wx.CLRP_USE_TEXTCTRL)

        tip_color = wx.ToolTip(tip_str)
        self.color.SetToolTip(tip_color)

        gridsizer1.Add(self.color, 0, wx.ALL, 5)

        # --- transparency ---
        min, max = 0.0, 1.0
        fraction_width = 3

        self.text2 = wx.StaticText(self, wx.ID_ANY, "transparency",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text2.Wrap(-1)
        tip_str = ("Specify the transparency for display in shaded mode, "
                   "range: [0.0-1.0].")
        tip_text2 = wx.ToolTip(tip_str)
        self.text2.SetToolTip(tip_text2)

        gridsizer1.Add(self.text2, 0, wx.ALL | wx.EXPAND, 5)

        self.transparency = NumCtrl(self, wx.ID_ANY, self.DEFAULT_TRANSPARENCY,
                                    wx.DefaultPosition, wx.DefaultSize, 0)
        self.transparency.SetMin(min)
        self.transparency.SetMax(max)
        self.transparency.SetFractionWidth(fraction_width)

        tip_transparency = wx.ToolTip(tip_str)
        self.transparency.SetToolTip(tip_transparency)

        gridsizer1.Add(self.transparency, 0, wx.ALL, 5)

        # --- line width ---
        min = 1.0  # no maximum
        fraction_width = 1

        self.text3 = wx.StaticText(self, wx.ID_ANY, "line width",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text3.Wrap(-1)
        tip_str = "Specify the line width for display in wireframe mode. It " \
                  "should be a positive integer."
        tip_text3 = wx.ToolTip(tip_str)
        self.text3.SetToolTip(tip_text3)

        gridsizer1.Add(self.text3, 0, wx.ALL | wx.EXPAND, 5)

        self.line_thickness = NumCtrl(self, wx.ID_ANY,
                                      self.DEFAULT_LINE_THICKNESS,
                                      wx.DefaultPosition, wx.DefaultSize, 0)
        self.line_thickness.SetMin(min)
        self.line_thickness.SetFractionWidth(fraction_width)

        tip_line_thickness = wx.ToolTip(tip_str)
        self.line_thickness.SetToolTip(tip_line_thickness)

        gridsizer1.Add(self.line_thickness, 0, wx.ALL, 5)

        # --- display mode ---
        self.text4 = wx.StaticText(self, wx.ID_ANY, "mode",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text4.Wrap(-1)
        gridsizer2.Add(self.text4, 0, wx.ALL | wx.EXPAND, 5)

        self.display_mode = wx.Choice(self, wx.ID_ANY, wx.DefaultPosition,
                                      wx.DefaultSize,
                                      self.DEFAULT_DISPLAY_MODES, 0)
        self.display_mode.SetSelection(self._DEFAULT_DISPLAY_MODE_IDX)
        gridsizer2.Add(self.display_mode, 0, wx.ALL, 5)

        # --- isos ---
        u_min = 0  # no max
        v_min = 0  # no max

        self.text5 = wx.StaticText(self, wx.ID_ANY, "isos",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text5.Wrap(-1)
        tip = wx.ToolTip(
            "Specify the number of U and V isoparameters to be displayed. ")
        self.text5.SetToolTip(tip)

        gridsizer2.Add(self.text5, 0, wx.ALL | wx.EXPAND, 5)

        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        self.u_isos = IntCtrl(self, wx.ID_ANY, self.DEFAULT_U_ISOS,
                              wx.DefaultPosition, wx.DefaultSize, 0)
        self.u_isos.SetMin(u_min)
        tip = wx.ToolTip(
            "The number of isos in u-direction is a non-negative integer.")
        self.u_isos.SetToolTip(tip)

        hsizer.Add(self.u_isos, 0, wx.ALL, 5)

        self.v_isos = IntCtrl(self, wx.ID_ANY, self.DEFAULT_V_ISOS,
                              wx.DefaultPosition, wx.DefaultSize, 0)
        self.v_isos.SetMin(v_min)
        tip = wx.ToolTip(
            "The number of isos in v-direction is a non-negative integer.")
        self.v_isos.SetToolTip(tip)

        hsizer.Add(self.v_isos, 0, wx.ALL, 5)

        gridsizer2.Add(hsizer, 1, wx.EXPAND, 5)

        # --- accuracy ---
        min = 1e-5
        max = 1.0
        fraction_width = 5

        self.text6 = wx.StaticText(self, wx.ID_ANY, "3d accuracy",
                                   wx.DefaultPosition, wx.DefaultSize, 0)
        self.text6.Wrap(-1)
        tip_str = ("Specifies the deviation coefficient. Drawings of curves"
                   " or patches are made with respect to a maximal chordal "
                   "deviation. A Deviation coefficient is used in the "
                   "shading display mode. The shape is decomposed into "
                   "triangles. These are used to calculate reflection of "
                   "light from the surface of the object. The triangles are "
                   "formed from chords of the curves in the shape. The "
                   "deviation coefficient gives the highest value of the "
                   "angle with which a chord can deviate from a tangent to "
                   "a curve. If this limit is \nreached, a new triangle is "
                   "begun. Deviation = SizeOfObject * DeviationCoefficient.")
        tip = wx.ToolTip(tip_str)
        self.text6.SetToolTip(tip)

        gridsizer2.Add(self.text6, 0, wx.ALL | wx.EXPAND, 5)

        self.devcoef = NumCtrl(self, wx.ID_ANY, 1.0, wx.DefaultPosition,
                               wx.DefaultSize, 0)
        self.devcoef.SetFractionWidth(fraction_width)
        self.devcoef.SetMin(min)
        self.devcoef.SetMax(max)
        self.devcoef.ChangeValue(self.DEFAULT_DEVIATION_COEFFICIENT)

        tip = wx.ToolTip(tip_str)
        self.devcoef.SetToolTip(tip)

        gridsizer2.Add(self.devcoef, 0, wx.ALL, 5)

        self.Layout()
        vsizer.Fit(self)

        # self.CentreOnParent( wx.BOTH )

        # Connect Events
        self.Bind(wx.EVT_INIT_DIALOG, self.on_init)
        self.buttonsizerReset.Bind(wx.EVT_BUTTON, self.on_reset)
        # self.buttonsizerReset.Disable()
        self.color.Bind(wx.EVT_COLOURPICKER_CHANGED, self.on_color_changed)
        self.display_mode.Bind(wx.EVT_CHOICE, self.on_mode_change)
        self.u_isos.Bind(EVT_INT, self.on_u_isos_changed)
        self.v_isos.Bind(EVT_INT, self.on_v_isos_changed)
        self.line_thickness.Bind(EVT_NUM, self.on_line_thickness_changed)
        self.transparency.Bind(EVT_NUM, self.on_transparency_changed)
        self.devcoef.Bind(EVT_NUM, self.on_devcoef_changed)

        self.value = {}

    def on_init(self, event):
        """initialize value status"""
        self.value = {}

    def reset_values(self):
        self.set_values()

    def on_reset(self, event):
        self.reset_values()
        self.EndModal(wx.ID_RESET)

    def on_color_changed(self, event):
        self.value['color'] = self.color.GetColour().Get()[0:3]

    def on_mode_change(self, event):
        self.value['display_mode'] = str(
            self.display_mode.GetString(self.display_mode.Selection))

    def on_transparency_changed(self, event):
        self.value['transparency'] = self.transparency.GetValue()

    def on_devcoef_changed(self, event):
        value = self.devcoef.GetValue()
        if value >= 1.0e-5:
            self.value['deviation_coefficient'] = value

    def on_line_thickness_changed(self, event):
        self.value['line_thickness'] = self.line_thickness.GetValue()

    def on_u_isos_changed(self, event):
        self.value['u_isos'] = self.u_isos.GetValue()

    def on_v_isos_changed(self, event):
        self.value['v_isos'] = self.v_isos.GetValue()

    def set_values(self, color=None, transparency=None,
                 deviation_coefficient=None, line_thickness=None,
                 u_isos=None, v_isos=None, display_mode=None,
                 display_priority=None):
        self.value = {}

        def get_value(value, default):
            return value if value is not None else default

        value = wx.Colour(*get_value(color, self.DEFAULT_COLOR))
        self.color.SetColour(value)

        value = get_value(transparency, self.DEFAULT_TRANSPARENCY)
        self.transparency.SetValue(value)

        value = get_value(deviation_coefficient,
                          self.DEFAULT_DEVIATION_COEFFICIENT)
        self.devcoef.SetValue(value)

        value = get_value(line_thickness, self.DEFAULT_LINE_THICKNESS)
        self.line_thickness.SetValue(value)

        value = get_value(u_isos, self.DEFAULT_U_ISOS)
        self.u_isos.SetValue(value)

        value = get_value(v_isos, self.DEFAULT_V_ISOS)
        self.v_isos.SetValue(value)

        if display_mode is not None:
            display_mode = self.DEFAULT_DISPLAY_MODES.index(display_mode)
        value = get_value(display_mode, self._DEFAULT_DISPLAY_MODE_IDX)
        self.display_mode.SetSelection(value)

    def get_color(self):
        return self.color.GetColour().Get()[0:3]

    def get_display_mode(self):
        ctrl = self.display_mode
        return str(ctrl.GetString(ctrl.Selection))

    def get_transparency(self):
        return self.transparency.GetValue()

    def get_deviation_coefficient(self):
        return self.devcoef.GetValue()

    def get_line_thickness(self):
        return self.line_thickness.GetValue()

    def get_u_isos(self):
        return self.u_isos.GetValue()

    def get_v_isos(self):
        return self.v_isos.GetValue()

    def get_values(self):
        """Return dict with all values::

            {'color': (198, 145, 29),
             'display_mode': 'shaded',
             'transparency': 0.0,
             'deviation_coefficient': 0.001,
             'line_thickness': 1,
             'u_isos': 0,
             'v_isos': 0}
        """
        return {'color': self.get_color(),
                'display_mode': self.get_display_mode(),
                'transparency': self.get_transparency(),
                'deviation_coefficient': self.get_deviation_coefficient(),
                'line_thickness': self.get_line_thickness(),
                'u_isos': self.get_u_isos(),
                'v_isos': self.get_v_isos()}

    def get_values_changed(self):
        """Return dict with all user-changed values, may contain any of these::

            {'color': (198, 145, 29),
             'display_mode': 'shaded',
             'transparency': 0.0,
             'deviation_coefficient': 0.001,
             'line_thickness': 1,
             'u_isos': 0,
             'v_isos': 0}
        """
        return self.value


class BackgroundGridDialog(wx.Dialog):
    def __init__(self, parent,
                 show=True, xorig=0.0, yorig=0.0, zorig=0.0,
                 width=500.0, length=500.0, xstep=10.0, ystep=10.0):
        wx.Dialog.__init__(self, parent, id=wx.ID_ANY,
                           title="Grid Properties", pos=wx.DefaultPosition,
                           size=wx.DefaultSize, style=wx.DEFAULT_DIALOG_STYLE)

        w = wx.DefaultSize.width
        h = wx.DefaultSize.height
        self.SetSizeHints(w, h, w, h)

        sizer = wx.BoxSizer(wx.VERTICAL)

        fgSizer1 = wx.GridSizer(0, 2, 0, 0)

        self.m_staticText6 = wx.StaticText(self, wx.ID_ANY, "show",
                                           wx.DefaultPosition, wx.DefaultSize,
                                           0)
        self.m_staticText6.Wrap(-1)
        fgSizer1.Add(self.m_staticText6, 0, wx.ALL, 5)

        self.ctrl_show = wx.CheckBox(self, wx.ID_ANY, wx.EmptyString,
                                     wx.DefaultPosition, wx.DefaultSize, 0)
        self.ctrl_show.SetValue(show)
        tip = wx.ToolTip("show the grid?")
        self.ctrl_show.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_show, 0, wx.ALL, 5)

        self.m_staticText10 = wx.StaticText(self, wx.ID_ANY, "X origin",
                                            wx.DefaultPosition, wx.DefaultSize,
                                            0)
        self.m_staticText10.Wrap(-1)
        fgSizer1.Add(self.m_staticText10, 0, wx.ALL, 5)

        self.ctrl_xorig = NumCtrl(self, wx.ID_ANY, xorig, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=True, fractionWidth=3)
        tip = wx.ToolTip("origin of grid (X)")
        self.ctrl_xorig.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_xorig, 0, wx.ALL, 5)

        self.m_staticText101 = wx.StaticText(self, wx.ID_ANY, "Y origin",
                                             wx.DefaultPosition,
                                             wx.DefaultSize, 0)
        self.m_staticText101.Wrap(-1)
        fgSizer1.Add(self.m_staticText101, 0, wx.ALL, 5)

        self.ctrl_yorig = NumCtrl(self, wx.ID_ANY, yorig, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=True, fractionWidth=3)
        tip = wx.ToolTip("origin of grid (Y)")
        self.ctrl_yorig.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_yorig, 0, wx.ALL, 5)

        self.m_staticText9 = wx.StaticText(self, wx.ID_ANY, "Z origin",
                                           wx.DefaultPosition, wx.DefaultSize,
                                           0)
        self.m_staticText9.Wrap(-1)
        fgSizer1.Add(self.m_staticText9, 0, wx.ALL, 5)

        self.ctrl_zorig = NumCtrl(self, wx.ID_ANY, zorig, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=True, fractionWidth=3)
        tip = wx.ToolTip("origin of grid (Z)")
        self.ctrl_zorig.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_zorig, 0, wx.ALL, 5)

        self.m_staticText7 = wx.StaticText(self, wx.ID_ANY, "width",
                                           wx.DefaultPosition, wx.DefaultSize,
                                           0)
        self.m_staticText7.Wrap(-1)
        fgSizer1.Add(self.m_staticText7, 0, wx.ALL, 5)

        self.ctrl_width = NumCtrl(self, wx.ID_ANY, width, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=False, fractionWidth=3,
                                  min=0.0001)
        tip = wx.ToolTip("width of the grid (X)")
        self.ctrl_width.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_width, 0, wx.ALL, 5)

        self.m_staticText8 = wx.StaticText(self, wx.ID_ANY, "length",
                                           wx.DefaultPosition, wx.DefaultSize,
                                           0)
        self.m_staticText8.Wrap(-1)
        fgSizer1.Add(self.m_staticText8, 0, wx.ALL, 5)

        self.ctrl_length = NumCtrl(self, wx.ID_ANY, length, wx.DefaultPosition,
                                   wx.DefaultSize, 0,
                                   allowNegative=False, fractionWidth=3,
                                   min=0.0001)
        tip = wx.ToolTip("length of the grid (Y)")
        self.ctrl_length.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_length, 0, wx.ALL, 5)

        self.m_staticText81 = wx.StaticText(self, wx.ID_ANY, "X step",
                                            wx.DefaultPosition, wx.DefaultSize,
                                            0)
        self.m_staticText81.Wrap(-1)
        fgSizer1.Add(self.m_staticText81, 0, wx.ALL, 5)

        self.ctrl_xstep = NumCtrl(self, wx.ID_ANY, xstep, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=False, fractionWidth=3,
                                  min=0.0001)
        tip = wx.ToolTip("interval between 2 vertical grid lines (X)")
        self.ctrl_xstep.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_xstep, 0, wx.ALL, 5)

        self.m_staticText811 = wx.StaticText(self, wx.ID_ANY, "Y step",
                                             wx.DefaultPosition,
                                             wx.DefaultSize, 0)
        self.m_staticText811.Wrap(-1)
        fgSizer1.Add(self.m_staticText811, 0, wx.ALL, 5)

        self.ctrl_ystep = NumCtrl(self, wx.ID_ANY, ystep, wx.DefaultPosition,
                                  wx.DefaultSize, 0,
                                  allowNegative=False, fractionWidth=3,
                                  min=0.0001)
        tip = wx.ToolTip("interval between 2 horizontal grid lines (Y)")
        self.ctrl_ystep.SetToolTip(tip)

        fgSizer1.Add(self.ctrl_ystep, 0, wx.ALL, 5)

        buttonsizer = wx.StdDialogButtonSizer()
        self.buttonsizerOK = wx.Button(self, wx.ID_OK)
        buttonsizer.AddButton(self.buttonsizerOK)
        self.buttonsizerCancel = wx.Button(self, wx.ID_CANCEL)
        buttonsizer.AddButton(self.buttonsizerCancel)
        buttonsizer.Realize()

        sizer.Add(fgSizer1, 1, wx.ALIGN_RIGHT, 5)
        sizer.Add(buttonsizer, 0, wx.ALIGN_RIGHT, 5)

        self.SetSizer(sizer)
        self.Layout()
        fgSizer1.Fit(self)
        self.Centre(wx.BOTH)

    def set_values(self, show, xorig, yorig, zorig, width, length, xstep, ystep):
        self.ctrl_show.SetValue(show)
        self.ctrl_xorig.SetValue(xorig)
        self.ctrl_yorig.SetValue(yorig)
        self.ctrl_zorig.SetValue(zorig)
        self.ctrl_width.SetValue(width)
        self.ctrl_length.SetValue(length)
        self.ctrl_xstep.SetValue(xstep)
        self.ctrl_ystep.SetValue(ystep)

    def get_values(self):
        return self.ctrl_show.GetValue(), \
               self.ctrl_xorig.GetValue(), \
               self.ctrl_yorig.GetValue(), \
               self.ctrl_zorig.GetValue(), \
               self.ctrl_width.GetValue(), \
               self.ctrl_length.GetValue(), \
               self.ctrl_xstep.GetValue(), \
               self.ctrl_ystep.GetValue()

    def GetValue(self):
        return self.get_values()


class HtmlWindow(wx.html.HtmlWindow):
    def __init__(self, parent, _id, size=(600, 400)):
        wx.html.HtmlWindow.__init__(self, parent, _id, size=size)
        if "gtk2" in wx.PlatformInfo:
            self.SetStandardFonts()

    def OnLinkClicked(self, link):
        wx.LaunchDefaultBrowser(link.GetHref())


class AboutBox(wx.Dialog):
    contents = """
        <p>
            This GUI enables you to explore your product model interactively,
            visualize geometry and inspect and update slot values.
        </p>
        <p>
            It is running on version {wxpy} of <b>wxPython</b> and {python} of
            <b>Python</b>. For more information, check http://www.parapy.nl.
            </a>
        </p>
    """

    def __init__(self, parent=None, title="About this GUI",
                 style=(wx.DEFAULT_DIALOG_STYLE | wx.RESIZE_BORDER |
                        wx.TAB_TRAVERSAL)):

        wx.Dialog.__init__(self, parent, -1, title, style=style)
        hwin = HtmlWindow(self, -1, size=(400, 200))
        hwin.SetPage(self.contents.format(python=sys.version.split()[0],
                                          wxpy=wx.VERSION_STRING))
        irep = hwin.GetInternalRepresentation()
        hwin.SetSize((irep.GetWidth() + 25, irep.GetHeight() + 10))
        self.SetClientSize(hwin.GetSize())
        self.CentreOnParent(wx.BOTH)
        self.SetFocus()


class HoverableListMixin:
    """Adds hover-selection to `wx.ListBox` instances.

    One has to call `bind_evt_handlers` once to add the hover selection
    behavior to the subclass.

    On a hover, the `SetSelection` method will be called to change the
    selection. No `EVT_LISTBOX` event will be generated!
    """
    def bind_evt_handlers(self):
        self.Bind(wx.EVT_MOTION, self._on_motion)

    def _on_motion(self, evt):
        index = self.HitTest(evt.Position)
        if index != wx.NOT_FOUND:
            self._update_selection(index)

    def _update_selection(self, i):
        if self.Selection != i:
            self.SetSelection(i)


class HoverableCheckListBox(wx.CheckListBox, HoverableListMixin):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bind_evt_handlers()


class HoverableListBox(wx.ListBox, HoverableListMixin):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bind_evt_handlers()


class ViewerObjectListBox(HoverableListBox):
    _last_highlighted = None

    def __init__(self, *args, viewer, choices, labels=None, **kwargs):
        """A `ListBox` that highlights shapes in the viewer when you hover over
        them.

        .. note:: currently should only be used without multiple selection
            (so use `wx.LB_SINGLE`)

        :param args: :class:`wx.ListBox` arguments
        :param parapy.gui.viewer.Viewer viewer: viewer in which `choices`
            reside.
        :param typing.Sequence[parapy.core.abstract.DrawableParaPyObject] choices:
            The (ParaPy) objects that will be the
            choices in the `ListBox`. They should be present in the `viewer`.
        :param typing.Sequence[str] | None labels: Either `len(choices)` labels
            or `None` if the labels should be deduced from `choices` (using
            the `str` function).
        :param kwargs: :class:`wx.ListBox` keyword-arguments
        """
        self._viewer = viewer
        self._choices = choices
        labels = self._conform_labels(choices, labels)
        super().__init__(*args, choices=labels, **kwargs)

        self.Bind(wx.EVT_LISTBOX, self._on_listbox_change)

        if len(choices):  # select the first entry
            self.SetSelection(0)

    def get_selected_object(self):
        """Get the currently selected object."""
        i = self.Selection
        if i is wx.NOT_FOUND:
            return None
        else:
            return self.get_object(i)

    def get_selected_objects(self):
        """Return a list of all the selected objects in this `ListBox`."""
        return list(map(self.get_object, self.GetSelections()))

    def get_object(self, i):
        """Get the object at index `i` of the ListBox."""
        return self._choices[i]

    def _conform_labels(self, choices, labels):
        """Return a list of labels for `choices`.

        :param typing.Sequence choices: The (ParaPy) objects that will be the
            choices in the `ListBox`.
        :param typing.Sequence[str] | None labels: Either `len(choices)` labels
            or `None` if the labels should be deduced from `choices` (using
            the `str` function).
        :rtype: typing.List[str]
        :raise ValueError: when `labels` is an iterable, and is not of the
            same length as `labels`.
        """
        if labels is None:
            return list(map(str, choices))  # str for visual-friendly name
        elif is_iterable(labels):
            if len(labels) != len(choices):
                raise ValueError(f"Amount of labels specified should match "
                                 f"the amount of choices! Got {len(choices)} "
                                 f"choices and {len(labels)} labels. "
                                 f"Object: {self!r}.")
            else:
                return labels
        else:
            raise TypeError(f"Parameter labels should be either an iterable "
                            f"of labels or None. Got: {type(labels)}. "
                            f"Object: {self!r}.")

    def _highlight_shape(self, i):
        self._unhighlight_last()

        obj = self.get_object(i)
        self._viewer.highlight(obj)
        self._last_highlighted = obj

    def _unhighlight_last(self):
        last_hl = self._last_highlighted
        if last_hl is not None:
            viewer = self._viewer
            viewer.unhighlight(last_hl)

    def _update_highlighting(self, i):
        if i is wx.NOT_FOUND:
            self._unhighlight_last()
        else:
            self._highlight_shape(i)

    def SetSelection(self, n):
        # SetSelection is called by the HoverableListMixin when the hover
        # selection changes
        super().SetSelection(n)
        self._update_highlighting(n)

    def _on_listbox_change(self, evt):
        i = evt.GetInt()
        self._update_highlighting(i)
        evt.Skip()


class ObjectSelectionDialog(wx.Dialog):
    default_title = "Selection"

    def __init__(self, *args, viewer: "parapy.gui.viewer.Viewer",
                 choices, labels=None, show_buttons=True, **kwargs):
        """A dialog that allows one to select one object out of `choices`
        in the `viewer`.

        .. note:: Currently should be only used with `ShowModal`.

        :param args: arguments of :class:`wx.Dialog`
        :param parapy.gui.viewer.Viewer viewer: viewer in which `choices`
            reside and should be highlighted.
        :param typing.Sequence[parapy.core.abstract.DrawableParaPyObject] choices:
            The (ParaPy) objects that will be the choices in the `ListBox`.
            They should be present in the `viewer`.
        :param typing.Sequence[str] | None labels: Either `len(choices)` labels
            or `None` if the labels should be deduced from `choices` (using
            the `str` function).
        :param bool show_buttons: Show the OK and Cancel dialog buttons
            (Default: `True`).
        :param kwargs: keyword arguments of :class:`wx.Dialog`
        """
        kwargs.setdefault("title", self.default_title)
        super().__init__(*args, **kwargs)
        sizer = wx.BoxSizer(orient=wx.VERTICAL)

        self._viewer = viewer
        self._listbox = listbox = ViewerObjectListBox(
            self, viewer=viewer, choices=choices, labels=labels,
            style=wx.LB_NEEDED_SB | wx.LB_SINGLE)
        sizer.Add(listbox)

        # enable click-selection
        self._listbox.Bind(wx.EVT_LEFT_UP, self._on_select_item)

        if show_buttons:
            button_sizer = self._create_buttons()
            sizer.Add(button_sizer)

            # take the minimum size from dialog buttons, and height of listbox
            # so the listbox fills up the width of the dialog
            min_size = (button_sizer.CalcMin()[0], listbox.GetSize()[1])
            listbox.SetMinSize(min_size)
        else:
            # add enter for submit, esc for cancel, needed without buttons
            self.Bind(wx.EVT_CHAR_HOOK, self._on_char)

        self.SetSizer(sizer)
        self.Layout()
        sizer.Fit(self)

        self._restore_highlighting = False

        self.Bind(wx.EVT_INIT_DIALOG, self._on_dialog_init)
        self.Bind(wx.EVT_WINDOW_DESTROY, self._on_window_destroy)
        self._modal = False

    def ShowModal(self):
        self._modal = True
        return super().ShowModal()

    def Show(self, *args, **kwargs):
        self._modal = False
        return super().Show(*args, **kwargs)

    def _on_dialog_init(self, evt):
        if self._modal:
            occ_viewer = self._viewer._occ_viewer
            if occ_viewer.automatic_highlighting_enabled():
                # the viewer isn't updated anymore by our mouse behavior, so
                # we need to make sure the clicked shape doesn't have
                # a highlight anymore (due to us hovering over it).
                self._restore_highlighting = True
                occ_viewer.enable_automatic_highlighting()
                occ_viewer.update_selected()

    def _on_window_destroy(self, evt):
        # Make our highlighting undone. Don't move this to logic to listbox,
        # it's `EVT_WINDOW_DESTROY` is called quite some time later,
        # possibly undoing (selection) highlights
        self._listbox._unhighlight_last()

        if self._modal and self._restore_highlighting:
            # restore viewer automatic highlighting state
            occ_viewer = self._viewer._occ_viewer
            occ_viewer.disable_automatic_highlighting()
            occ_viewer.update_selected()
        evt.Skip()

    def _on_char(self, evt):
        key_code = evt.KeyCode
        if key_code == wx.WXK_ESCAPE:
            self._end_with_code(wx.ID_CANCEL)
        elif key_code == wx.WXK_RETURN or key_code == wx.WXK_NUMPAD_ENTER:
            self._end_with_code(wx.ID_OK)
        else:
            evt.Skip()

    def _end_with_code(self, code):
        if self.IsModal():
            self.EndModal(code)
        else:
            self.SetReturnCode(code)

    def _on_select_item(self, evt):
        # selection was already done through hovering
        self._end_with_code(wx.ID_OK)

    def _create_buttons(self):
        button_sizer = wx.StdDialogButtonSizer()

        self.button_ok = button_ok = wx.Button(self, wx.ID_OK)
        button_ok.SetDefault()  # to make 'enter' to submit work
        button_sizer.SetAffirmativeButton(button_ok)

        self.button_cancel = button_cancel = wx.Button(self, wx.ID_CANCEL)
        button_sizer.SetCancelButton(button_cancel)

        button_sizer.Realize()
        return button_sizer

    def get_values(self):
        return self._listbox.get_selected_objects()


if __name__ == '__main__':

    class DialogTester(wx.App):

        def __init__(self, DialogClass, *args, **kwargs):
            self._DialogClass = DialogClass
            super(DialogTester, self).__init__(*args, **kwargs)

        def OnInit(self):
            self.dlg = dlg = self._DialogClass(None)

            # This function returns the button pressed to close the dialog
            ret = dlg.ShowModal()
            # Let's check if user clicked OK or pressed ENTER
            if ret == wx.ID_OK:
                print('You entered values:', dlg.get_values())
            elif ret == wx.ID_RESET:
                print("you've requested a reset")
            elif ret == wx.ID_CANCEL:
                print('You canceled')
            else:
                print("not expected")

            # The dialog is not in the screen anymore, but it's still in memory
            # for you to access it's values. remove it from there.
            dlg.Destroy()
            return True

    # Always use zero here. otherwise, you will have an error window that will
    # last only nano seconds on the screen. dumb.
    # (Only if the error is in the startup code before MainLoop is called. --RobinDunn)
    app = DialogTester(AppearanceDialog, redirect=0)
    app.MainLoop()

    # Always use zero here. otherwise, you will have an error window that will
    # last only nano seconds on the screen. dumb.
    # (Only if the error is in the startup code before MainLoop is called. --RobinDunn)
    app = DialogTester(BackgroundGridDialog, redirect=0)
    app.MainLoop()

    # Always use zero here. otherwise, you will have an error window that will
    # last only nano seconds on the screen. dumb.
    # (Only if the error is in the startup code before MainLoop is called. --RobinDunn)
    app = DialogTester(AboutBox, redirect=0)
    app.MainLoop()

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import logging
from weakref import WeakSet

import wx
from OCC.wrapper.AIS import AIS_Shaded
from OCC.wrapper.Graphic3d import (
    Graphic3d_TMF_ZoomPers, Graphic3d_TransformPers, Graphic3d_ZLayerId_Top)
from OCC.wrapper.Quantity import Quantity_Color, Quantity_NOC_BLACK
from OCC.gui.interactive_objects import make_ais_line
from parapy.cae.nastran import Arrow
from parapy.core import Attribute, Input, Part, apply_to_all, child, on_event
from parapy.core.events import VetoableEvent
from parapy.geom import (
    GeomBase, Plane, Sphere, XOY, rotate, translate)
from parapy.geom.occ.transform import (
    get_transformation, rebase_trsf,
    transform, transform_position)
from parapy.gui import wx34
from parapy.gui.actions import ViewerSelectionContext
from parapy.gui.events import EVT_LEFT_CLICK_OBJECT

__all__ = "Manipulable", "Manipulation", "transform"


class Manipulable(GeomBase):
    """A shape inheriting from this can be manipulated in the ParaPy Viewer.
    Only works when mixing this class in with a shape that inherits from
    :class:`~parapy.geom.occ.drawable.DrawableShape`.

    Usage:

    >>> from parapy.geom import Plane
    >>> from parapy.gui import Manipulable
    ...
    >>> class ManipulablePlane(Plane, Manipulable):
    ...     translation_axes = ['z']  # only allow translation in z-direction
    ...     zoom_persistent = True  # make manipulator zoom persistent
    ...     # you need to implement to following method to submit the result
    ...     # back to the ParaPy model
    ...     def on_submit(self, start_position, end_position):
    ...         self.reference = end_position
    ... 

    Advanced usage:

    - Show the Manipulator on a different location or with a different
        orientation, see :attr:`manipulator_position`.
    - Set limits to where the Manipulator can move, or override the behavior
        of what should happen when manipulating the object (the position
        it should be actually dragged to, displaying information about the
        manipulation or stopping some kinds of movement from happening), see
        :meth:`on_transform`.
    - Change the size of the Manipulator, see :attr:`manipulator_size`. To
      make it user-settable, consider exposing it as an Input.
    - Show a different representation of the shape that is being dragged, see
        :attr:`ghost`.
    - Change elements in the GUI, for instance setting a camera before
        starting a manipulation, see :meth:`on_manipulation_start`.
    - If the :attr:`position` of the object is not a good reference for the
        gizmo, one can specify a different :attr:`reference_position`.
    - Do not show the guiding line which shows the axis along which the
        Manipulator is dragged, see :attr:`show_guide`.
    """

    #: Names of the axes that can be used for translation. Specify up to 3
    #: from: 'x', 'y', 'z'. The directions of these axes are defined by
    # :attr:`manipulator_position`.
    #: :type: typing.Sequence[str]
    translation_axes = ['x', 'y', 'z']

    #: Axes over which one can rotate this Manipulable object. The directions
    #: of these axes are defined by :attr:`manipulator_position`.
    #:
    #: .. caution:: currently not implemented!
    #:
    #: :type: typing.Sequence[str]
    rotation_axes = ['x', 'y', 'z']

    #: If set to :py:`True` the size of the manipulator will be defined in
    #: on-screen pixels and will not resize when zooming. Otherwise the
    #: manipulator its size will be defined in world-units, and will be
    #: subjective to zooming.
    #: :type: bool
    zoom_persistent = False

    #: If :py:`True`, a line will appear aligned with the axis of translation.
    #: :type: bool
    show_guide = True

    @Attribute
    def manipulator_size(self):
        """Size of the manipulator. If :attr:`zoom_persistent` is :py:`True`,
        this will be the size of the main axes of the manipulator in on-screen
        pixels. If :attr:`zoom_persistent` is :py:`False`, it is the size
        of the main axes in world-units.

        :rtype: int
        """
        if self.zoom_persistent:
            return 80  # bit of a random guess, seems reasonable in most cases
        else:
            return 1

    def __init__(self, *args, **kwargs):
        super(Manipulable, self).__init__(*args, **kwargs)

        # weak set avoids keeping viewers alive where one pressed close
        # during a manipulation
        # TODO (TBD): cancel the manipulation in these viewers to allow cleanup
        #  Not sure if the created Manipulation will be cleaned up
        self._manipulation_active_in_viewers = WeakSet()

    def is_active(self, viewer):
        """True if the object is currently manipulated"""
        return viewer in self._manipulation_active_in_viewers

    @Attribute
    def manipulator_position(self):
        """The :class:`~parapy.geom.Position` that is used to position the
        Manipulator object. One needs to override this if the desired
        rotation/translation axes do not correspond with the main axes of
        this object its :attr:`position`.

        :rtype: parapy.geom.Position
        """
        return self.position

    @Attribute
    def reference_position(self):
        """The :class:`~parapy.geom.Position` that is used as a reference
        for the Manipulation (it
        will show the start and final position relative to this position).
        It is useful when the position of the Manipulable object does not
        give a good representation of where the shape itself is located (for
        instance when using shapes resulting from a Boolean operation).

        :rtype: parapy.geom.Position
        """
        return self.position

    @Part(in_tree=False)
    def gizmo(self):
        """The *axis system* that is shown when this object is selected, and
        is dragged along with this object during manipulation.

        .. caution:: the gizmo should not be updated/changed when
            the manipulation :attr:`is_active`.

        :rtype: Gizmo
        """
        return Gizmo(translation_axes=self.translation_axes,
                     rotation_axes=self.rotation_axes,
                     position=self.manipulator_position,
                     scale=self.manipulator_size)

    @Attribute
    def ghost(self):
        """The 'ghost' that is dragged along with the manipulator.

        One can specify any :class:`~parapy.core.abstract.DrawableParapyObject`
        that will act as a ghost. If set to self, the manipulable object itself
        will move. Set the ghost to :py:`None` if no shape, apart from the
        manipulator, should move along with the manipulation.

        .. caution:: the ghost should not be updated/changed when
            the manipulation :attr:`is_active`.

        :rtype: parapy.core.abstract.DrawableParapyObject | None
        """
        return self

    def _make_manipulation(self, viewer):
        """
        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation takes place.
        :rtype: Manipulation
        """
        return Manipulation(
            viewer, self.gizmo, ghost=self.ghost,
            zoom_persistent=self.zoom_persistent,
            show_guide=self.show_guide,
            reference_position=self.reference_position)

    def _start(self, viewer):
        """Start to manipulate this Manipulable object inside ``viewer``."""
        if viewer in self._manipulation_active_in_viewers:
            logging.warning("Manipulation still in progress")
            return

        self.on_manipulation_start(viewer)

        manipulation = self._make_manipulation(viewer)

        # TODO (FT): serious events/set_callback functions.
        manipulation.on_transform = self.on_transform
        manipulation.on_manipulation_end = self._on_manipulation_end

        self._manipulation_active_in_viewers.add(viewer)
        manipulation.start()

    def on_manipulation_start(self, viewer):
        """User can override this method to initiate the viewer for the
        Manipulation, like setting a specific camera position, disable parts
        of the gui, or showing hints to the user. See also
        :meth:`on_manipulation_end` for restoring this.

        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation takes place.
        """
        pass

    def on_transform(self, evt):
        """Override this to override the default transformation behavior.

        :param TransformEvent evt: The event object has the following
            properties:
            - evt.mode: ('translation'/'rotation')
            - evt.axis: ('x'/'y'/'z')
            - evt.obj: object being transformed
            - evt.start_position:
            - evt.current_position: the position that will be the result of the
                current transformation action, if the default behaviour will be
                allowed. Setting this to a different
                value will cause a transformation from ``start_position` to the
                provided position instead.
            - evt.viewer: viewer in which the transformation takes place

            and the following method:
            - evt.Veto(): When calling this, the transformation will not take
                place at all, and the object will stay at its previous position.
        """
        pass

    def on_submit(self, start_position, end_position):
        """Called when manipulation is succesfully submitted. It allows the
        user to apply changes to the model.

        :param parapy.geom.Position start_position: the position (
            :attr:`reference_position`) before any manipulation took place.
        :param parapy.geom.Position end_position: the position as it was
            at the end of the Manipulation. The relative movement between
            ``start_position`` and ``end_position`` represents the
            transformation done during the manipulation.
        """
        pass

    def on_manipulation_end(self, viewer, submitted, start_position,
                            end_position):
        """Called at the end of the manipulation. It allows the user to
        restore the viewer (if the state was changed for this manipulation in
        :meth:`on_manipulation_start`).

        :param parapy.gui.viewer.Viewer viewer: viewer in which the
            manipulation took place.
        :param bool submitted: if set to :py:`True` the user wants to submit
            the transformation back to the ParaPy model. Otherwise changes
            should not be committed back to the model.
        :param parapy.geom.Position start_position: the position (
            :attr:`reference_position`) before any manipulation took place.
        :param parapy.geom.Position end_position: the position as it was
            at the end of the Manipulation. The relative movement between
            ``start_position`` and ``end_position`` represents the
            transformation done during the manipulation.
        """
        pass

    def _on_manipulation_end(self, viewer, submitted, start_position,
                             end_position):
        if submitted:
            self.on_submit(start_position, end_position)

        self.on_manipulation_end(
            viewer, submitted, start_position, end_position)

        self._manipulation_active_in_viewers.discard(viewer)

    @on_event(EVT_LEFT_CLICK_OBJECT)
    def _on_left_click(self, evt):
        if self.is_active(evt.source):
            evt.Skip()
            return

        selected = evt.selected
        if len(selected) == 1 and self is selected[0]:
            self._start(evt.source)
        else:
            evt.Skip()


class Manipulation(object):
    DRAG_INSTRUCTION_MSG = "Drag the Manipulator..."
    INSTRUCTION_MSG = (DRAG_INSTRUCTION_MSG +
                       " Press ENTER/RETURN to submit or ESCAPE to cancel.")
    GUIDE_COLOR = Quantity_NOC_BLACK

    def __init__(self, viewer, gizmo, ghost=None, zoom_persistent=False,
                 show_guide=False, reference_position=None):
        self._viewer = viewer
        self._main_window = viewer.GetTopLevelParent()
        self._gizmo = gizmo
        self._ghost = ghost
        self._zoom_persistent = zoom_persistent
        self._show_guide = show_guide
        self._reference_position = reference_position or obj.position

        self._arrow_shape_to_axis = dict(
            zip(gizmo.arrows, gizmo.translation_axes))

        self._manipulator_position = gizmo.position or obj.position

        # last_man_position will be used to maintain the state of the
        # manipulator across drags
        self._last_man_position = self._manipulator_position
        self._last_ref_position = self._reference_position

        self._gizmo_facade = GizmoViewerFacade(
            gizmo, viewer, zoom_persistent=self._zoom_persistent)

        if ghost:
            self._ghost_facade = GhostViewerFacade(ghost, viewer)
        else:
            self._ghost_facade = None

        # the saved window_state
        self._gui_state = None

    @property
    def status_bar(self):
        main_window = self._viewer.GetTopLevelParent()
        return main_window.GetStatusBar()

    def _disable_window(self):
        main_window = self._main_window
        self._save_window(main_window)

        main_window.data_panel.Disable()
        main_window.tree_panel.Disable()
        self._viewer.toolbar.wx_toolbar.EnableTool(
            self._viewer.toolbar.btn_delete_all.GetId(), False)

    def _save_window(self, main_window):
        toolbar = self._viewer.toolbar

        state = {
            'data': main_window.data_panel.IsEnabled(),
            'tree': main_window.data_panel.IsEnabled(),
            'delete_button': toolbar.wx_toolbar.GetToolEnabled(
                toolbar.btn_delete_all.GetId())
        }
        self._gui_state = state

    def _restore_window(self):
        toolbar = self._viewer.toolbar

        state = self._gui_state

        if state is None:
            msg = ("Cannot restore window state before the state was saved "
                   "using _save_window. Object: {!r}")
            raise RuntimeError(msg.format(self))

        main_window = self._main_window
        main_window.data_panel.Enable(state['data'])
        main_window.tree_panel.Enable(state['tree'])
        toolbar.wx_toolbar.EnableTool(toolbar.btn_delete_all.GetId(),
                                      state['delete_button'])

    def context(self):
        """Return a context manager that is used to put setup GUI in
        for selection and restores GUI when done. Can be overridden in
        subclasses.
        """
        return ViewerSelectionContext(self._main_window)

    def display(self, update=True):
        self._gizmo_facade.display()
        if self._ghost_facade:
            self._ghost_facade.display(update=update)

    def transform(self, start_man_pos, current_man_pos,
                  start_ref_pos, current_ref_pos, update=True):
        # update the position of gizmo and ghost
        if self._ghost:
            self._ghost_facade.transform(start_ref_pos, current_ref_pos)
        self._gizmo_facade.transform(
            start_man_pos, current_man_pos, update=update)

    def remove(self, update=True):
        if self._ghost:
            self._ghost_facade.remove(update=update)
            self._ghost_facade = None

        self._gizmo_facade.remove(update=update)
        self._gizmo_facade = None

    def start(self):
        viewer = self._viewer
        # set transformation state
        self._trsf_state = TransformationState(viewer)

        self._disable_window()

        self.display()

        # bind events
        self._bind_drag_start_stop()
        self._bind_submit_cancel()

        # set instruction text
        status_bar = self.status_bar
        if status_bar:
            status_bar.PushStatusText(self.INSTRUCTION_MSG)

    def start_drag(self, mode, axis, x, y, arrow_shape=None):
        # arrow currently highlighted, remove highlighted presentation
        # it otherwise stays in the screen, but will not follow the arrow
        if arrow_shape:
            # TODO (PP): investigate how to remove highlighting efficiently
            facade = self._gizmo_facade
            i = facade._shapes.index(arrow_shape)
            ais_shape = facade._ais_shapes[i]
            context = ais_shape.GetContext()
            context.Erase(ais_shape, False)
            context.Display(ais_shape, False)

        # start the bookkeeping of the manipulation its calculated position
        trsf_state = self._trsf_state
        if mode == 'translation':
            trsf_state.start_translation(self._last_man_position, axis, x, y)
        else:
            raise NotImplementedError("Rotation currently not implemented!")

        self._setup_viewer_drag()

        # events
        self._bind_dragging()
        self._unbind_submit_cancel()

        # print "drag of axis {} started".format(axis)
        status_bar = self.status_bar
        if status_bar:  # update text: submit/cancel not possible
            status_bar.PushStatusText(self.DRAG_INSTRUCTION_MSG)

    def _on_transform(self, x, y):
        """Updates position of gizmo, ghost and calls on_transform event.

        :param int x: screen coordinate
        :param int y: screen coordinate
        """
        # start/current position of the manipulator
        start_man_pos = self._manipulator_position
        current_man_pos = self._trsf_state.get_current_position(x, y)
        manipulator_trsf = get_transformation(start_man_pos, current_man_pos)

        # apply the relative movement to the start of the reference
        # position, leading to the new position
        start_ref_pos = self._reference_position
        current_ref_pos = transform_position(start_ref_pos,
                                             start_man_pos, manipulator_trsf)

        trsf_state = self._trsf_state
        trsf_evt = _create_transform_evt(x, y, self, start_ref_pos,
                                         current_ref_pos, trsf_state.mode,
                                         trsf_state.axis, self._viewer)

        self.on_transform(trsf_evt)

        if trsf_evt.IsAllowed:
            if trsf_evt.current_position is not current_ref_pos:
                # user specified a different position: override both the
                # manipulator position and current reference position
                current_ref_pos = trsf_evt.current_position
                current_man_pos = transform(start_man_pos, start_ref_pos,
                                            current_ref_pos)

            self._last_ref_position = current_ref_pos
            self._last_man_position = current_man_pos

            self.transform(start_man_pos, current_man_pos,
                           start_ref_pos, current_ref_pos)

    def on_transform(self, evt):
        pass  # placeholder, monkey patch this!

    def stop_drag(self):
        self._trsf_state.stop_transformation()

        self._teardown_viewer_drag()

        # events
        self._unbind_dragging()
        self._bind_submit_cancel()

        # print "drag {} stopped"
        status_bar = self.status_bar
        if status_bar:  # update text: previous message
            status_bar.PopStatusText()

    def submit(self):
        self._on_manipulation_end(submitted=True)
    
    def cancel(self):
        self._on_manipulation_end(submitted=False)

    def _on_manipulation_end(self, submitted):
        self._unbind_drag_start_stop()
        self._unbind_submit_cancel()

        self.remove(update=False)
        self._trsf_state = None

        viewer = self._viewer
        self.on_manipulation_end(viewer, submitted,
                                 self._reference_position,
                                 self._last_ref_position)
        viewer.refresh(update=True)
        # print "manipulation ended"

        self._restore_window()

        status_bar = self.status_bar
        if status_bar:  # update text: previous message
            status_bar.PopStatusText()

    def on_manipulation_end(self, viewer, submitted, start_position,
                            end_position):
        pass  # placeholder, monkey patch this!

    # drag line add/remove, mouse cursor
    def _setup_viewer_drag(self):
        viewer = self._viewer
        viewer.SetCursor(wx34.Cursor(wx.CURSOR_SIZING))

        if self._show_guide:
            trsf_state = self._trsf_state
            occ_viewer = viewer._occ_viewer
            self._ais_line = ais_line = make_ais_line(
                trsf_state._pnt_start, trsf_state._axis)
            q_color = Quantity_Color(self.GUIDE_COLOR)
            ais_line.SetColor(q_color)
            occ_viewer.display(ais_line, fit=False)

    def _teardown_viewer_drag(self):
        viewer = self._viewer
        viewer.SetCursor(wx34.Cursor(wx.CURSOR_ARROW))

        if self._show_guide:
            occ_viewer = viewer._occ_viewer
            occ_viewer.remove(self._ais_line, fit=False)

    # binding events
    def _bind_submit_cancel(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Bind(wx.EVT_KEY_UP, self._on_key_up)

    def _unbind_submit_cancel(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Unbind(wx.EVT_KEY_UP, handler=self._on_key_up)

    def _bind_drag_start_stop(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Bind(wx.EVT_LEFT_DOWN, self._on_left_down)
        occ_viewer.Bind(wx.EVT_LEFT_UP, self._on_left_up)

    def _unbind_drag_start_stop(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Unbind(wx.EVT_LEFT_DOWN, handler=self._on_left_down)
        occ_viewer.Unbind(wx.EVT_LEFT_UP, handler=self._on_left_up)

    def _bind_dragging(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Bind(wx.EVT_MOTION, self._on_motion)

    def _unbind_dragging(self):
        occ_viewer = self._viewer._occ_viewer
        occ_viewer.Unbind(wx.EVT_MOTION, handler=self._on_motion)

    # event handling
    def _on_key_up(self, evt):
        # TODO (FT): Bind on MainWindow instead.
        key_code = evt.KeyCode

        if key_code == wx.WXK_ESCAPE:
            self.cancel()
        elif key_code in (wx.WXK_NUMPAD_ENTER, wx.WXK_RETURN):
            self.submit()
        else:
            evt.Skip()

    def _on_left_down(self, evt):
        viewer = self._viewer
        detected = viewer.detected

        if detected:
            detected_object = detected[0]
            if detected_object in self._gizmo.arrows:
                trsf_state = self._trsf_state
                if not (trsf_state and trsf_state.is_active):
                    axis = self._arrow_shape_to_axis[detected_object]
                    self.start_drag('translation', axis, evt.x, evt.y,
                                    arrow_shape=detected_object)

        evt.Skip()

    def _on_motion(self, evt):
        trsf_state = self._trsf_state
        # called on any motion while dragging an axis of the Gizmo
        if evt.Dragging() and trsf_state and trsf_state.is_active:
            self._on_transform(evt.x, evt.y)
        else:
            evt.Skip()

    def _on_left_up(self, evt):
        trsf_state = self._trsf_state
        if trsf_state and trsf_state.is_active:
            self.stop_drag()
        else:
            evt.Skip()


class ViewerFacade(object):
    """Facade to :meth:`display` multiple ``shapes`` in ``viewer``
    :meth:`transform` them efficiently, and :meth:`remove` them from viewer at
    the end, optionally resetting shapes back to original location/orientation.

    >>> shapes = [box1, box2]
    >>> facade = ViewerFacade(shapes, viewer)
    >>> facade.display()
    >>> facade.transform(old_position, new_position)
    >>> facade.remove()
    """
    def __init__(self, shapes, viewer):
        self._shapes = shapes
        self._viewer = viewer

        self._ais_shapes = None  # is set via .display()

    def display(self, update=True, **kwargs):
        """Display all ``shapes`` in ``viewer``.

        :param bool update: update viewer?
        :param dict kwargs: see :meth:`~parapy.gui.viewer.Viewer.display`.
        """
        shapes = self._shapes
        viewer = self._viewer

        viewer.display(shapes, update=update, **kwargs)

        shape_to_ais = viewer._dct_pp_occ
        self._ais_shapes = [shape_to_ais[s] for s in shapes]

    def transform(self, from_position, to_position, update=True):
        """Transform all shapes in viewer."""
        trsf = get_transformation(from_position, to_position)

        for ais_shape in self._ais_shapes:
            self._transform_shape(
                ais_shape, from_position, to_position, trsf)

        if update:
            self._update_viewer()

    def remove(self, reset_transformation=True, update=True, **kwargs):
        """Removes ``shapes`` from ``viewer``

        :param bool reset_transformation: reset original shapes?
        :param bool update: update viewer?
        :param dict kwargs: see :meth:`~parapy.gui.viewer.Viewer.remove`.
        """
        if reset_transformation:
            self._reset_transformation()

        self._viewer.remove(self._shapes, update=update, **kwargs)

    @staticmethod
    def _transform_shape(ais_shape, from_position, to_position, local_trsf=None):
        if not local_trsf:
            trsf = get_transformation(from_position, to_position)
            local_trsf = rebase_trsf(trsf, from_position, XOY)

        ais_shape.SetLocalTransformation(local_trsf)
        ais_shape.Redisplay(False)

    def _reset_transformation(self):
        for ais_shape in self._ais_shapes:
            ais_shape.ResetTransformation()

    def _update_viewer(self):
        self._viewer.update()


class GizmoViewerFacade(ViewerFacade):
    """A facade to make it easier to manage the shape of the gizmo
    (Manipulator) in the Viewer during a Manipulation by providing
    display/transform/remove methods.
    """
    def __init__(self, gizmo, viewer, zoom_persistent=False):
        shapes = gizmo.arrows + [gizmo.center]
        # the arrows should appear with a shaded highlight to show
        # that the user should interact with it
        self._shaded_highlight_shapes = gizmo.arrows

        super(GizmoViewerFacade, self).__init__(shapes, viewer)

        self._gizmo = gizmo
        self._zoom_persistent = zoom_persistent

    def display(self, update=True, **kwargs):
        """Display, but also apply style to shapes on AIS level."""

        # don't update yet, need also style adjustments
        super(GizmoViewerFacade, self).display(update=False, **kwargs)

        shape_to_ais = self._viewer._dct_pp_occ
        self._shaded_highlight_ais = frozenset([
            shape_to_ais[shape] for shape in self._shaded_highlight_shapes])
        apply_to_all(self._style_shape, self._ais_shapes)

        if update:
            self._update_viewer()

    def _transform_shape(self, ais_shape, from_position, to_position,
                         local_trsf=None):
        # TODO (FT): MIGHT NOT WORK FOR ROTATION because the positions
        # /todo of the arrows might not be centered in the manipulator_position
        # /todo causing arrows/rotation elements to rotate individually
        # /todo AIS objects all are located on XOY by default
        # /todo (in ParaPy Viewer)
        if self._zoom_persistent:
            # while rotation will work as expected, translation had no
            # effect (we're not in 3d space). Define anchorpoint to give
            # the idea that it transforms with the cursor
            graphic3d_pers = ais_shape.TransformPersistence()
            graphic3d_pers.SetAnchorPoint(to_position.location.gp_Pnt)

        super(GizmoViewerFacade, self)._transform_shape(
            ais_shape, from_position, to_position, local_trsf)

    def _style_shape(self, ais_shape):
        """Forces shapes to (highlight) in shaded mode"""
        # show on top of other things drawn in the viewer
        ais_shape.SetZLayer(Graphic3d_ZLayerId_Top)

        if ais_shape in self._shaded_highlight_ais:
            ais_shape.SetHilightMode(AIS_Shaded)

        if self._zoom_persistent:
            transform_pers = Graphic3d_TransformPers(
                Graphic3d_TMF_ZoomPers).handle

            gizmo_location = self._gizmo.position.location
            transform_pers.SetAnchorPoint(gizmo_location.gp_Pnt)
            ais_shape.SetTransformPersistence(transform_pers)


class GhostViewerFacade(ViewerFacade):
    """A facade to make it easier to manage the shape of the ghost in the
    Viewer during a Manipulation by providing display/transform/remove methods.
    """
    def __init__(self, ghost, viewer):
        super(GhostViewerFacade, self).__init__([ghost], viewer)
        self._ghost = ghost
        self._was_already_in_viewer = None  # is set in .display()

    def display(self, update=True, **kwargs):
        # this state is used on remove()
        self._was_already_in_viewer = self._ghost in self._viewer._dct_pp_occ

        super(GhostViewerFacade, self).display(update=update, **kwargs)

        # FIXME (FT): This will lead to an exception when trying to select it.
        # /fixme self._ghost_prev_auto_hilight = ghost_ais.IsAutoHilight()
        # /fixme ghost_ais.SetAutoHilight(False)

    def remove(self, reset_transformation=True, update=True, **kwargs):
        # only remove ghost, if not already shown in Viewer before (not ours)
        if not self._was_already_in_viewer:
            super(GhostViewerFacade, self).remove(
                reset_transformation=reset_transformation, update=update,
                **kwargs)
        elif reset_transformation:
            self._reset_transformation()

        self._was_already_in_viewer = None

        # FIXME (FT): This will lead to an exception when trying to select it.
        # /fixme ghost_ais.SetAutoHilight(self._ghost_prev_auto_hilight)
        # /fixme self._ghost_prev_auto_hilight = None


class TransformationState(object):
    """Calculates the current Position of the manipulator based on a
    ``start_position``, and ``x, y`` screen coordinates. Supports translation
    and rotation. Usage:

    >>> obj = TransformationState(viewer)
    >>> x, y = 100, 200
    >>> # start drag along 'z' axis
    >>> obj.start_translation(start_position, 'z', x, y)
    >>> x, y = 200, 300
    >>> new_position = obj.get_current_position(x, y)
    >>> obj.stop_transformation()
    >>> x, y = 200, 300
    >>> # start rotation around 'z' axis
    >>> obj.start_rotation(new_position, 'z', x, y)
    >>> x, y = 300, 400
    >>> newer_position = obj.get_current_position(x, y)
    >>> obj.stop_transformation()

    :param parapy.gui.viewer.Viewer viewer:
    """
    __slots__ = ('_viewer', '_pos_start', '_pnt_start', '_pnt_start_proj',
                 '_mode', '_axis')

    def __init__(self, viewer):
        self._viewer = viewer
        self._init_vars()

    def _init_vars(self):
        self._pos_start = None
        self._pnt_start = None
        self._pnt_start_proj = None
        self._mode = None
        self._axis = None

    @property
    def start_position(self):
        return self._start_pos

    @property
    def mode(self):
        return self._mode

    @property
    def axis(self):
        return self._axis

    @property
    def is_active(self):
        return bool(self._mode)

    def start_translation(self, start_position, axis, x, y):
        self._start_transformation(start_position, 'translation', axis, x, y)

    def start_rotation(self, start_position, axis, x, y):
        self._start_transformation(start_position, 'rotation', axis, x, y)

    def get_current_position(self, x, y):
        pos_start = self._pos_start
        pnt_start_proj = self._pnt_start_proj
        pnt_curnt_proj = self._project_from_screen(x, y)

        # no movement
        if pnt_curnt_proj == pnt_start_proj:
            return pos_start

        axis = self._axis

        if self._mode == 'translation':
            vector = pnt_curnt_proj - pnt_start_proj
            return pos_start + vector

        else:  # 'rotation'
            v1 = pnt_start_proj - pos_start
            v2 = pnt_curnt_proj - pos_start

            # calculate real angle, in radians
            angle, v_rot = v1.angle_and_axis(v2)
            if v_rot.dot(axis) < 0:
                angle = -angle

            return rotate(pos_start, axis, angle)

    def stop_transformation(self):
        if not self.is_active:
            raise RuntimeError("Start transformation first.")
        self._init_vars()  # cleanup / reset

    def _start_transformation(self, start_position, mode, axis, x, y):
        if self.is_active:
            raise RuntimeError("Stop transformation first.")

        self._pos_start = start_position
        self._pnt_start = start_position.location
        self._mode = mode
        self._axis = start_position.ensure_vector(axis, normalize=True)

        # leave call here, requires ._mode and ._axis to be set
        self._pnt_start_proj = self._project_from_screen(x, y)

    def _project_from_screen(self, x, y):
        viewer = self._viewer

        if self._mode == "translation":
            return viewer.screen_to_point_on_axis(
                x, y, self._pnt_start, self._axis)
        else:  # 'rotation'
            return viewer.screen_to_point_in_plane(
                x, y, self._pnt_start, self._axis)


class TransformEvent(VetoableEvent):
    def Skip(self, skipped=True):
        raise RuntimeError("Skipping not supported on TransformEvent")


def _create_transform_evt(x, y, obj, start_pos, current_pos, mode, axis,
                          viewer):
    return TransformEvent(x=x, y=y, obj=obj, start_position=start_pos,
                          current_position=current_pos, mode=mode, axis=axis,
                          viewer=viewer)


class Gizmo(GeomBase):
    """Representation of a 'Manipulator' object showing translation axes"""

    #: :type: numbers.Number
    scale = Input(1.)

    #: :type: typing.Sequence[str]
    translation_axes = Input(['x', 'y', 'z'])

    #: :type: typing.Sequence[str]
    rotation_axes = Input(['x', 'y', 'z'])

    colors = {'x': 'red', 'y': 'green', 'z': 'blue'}

    display_mode = Attribute("shaded")
    transparency = Attribute(0.0)

    @Attribute
    def translation_vectors(self):
        position = self.position
        return {'x': position.Vx, 'y': position.Vy, 'z': position.Vz}

    @Part
    def arrows(self):
        return Arrow(quantify=len(self.translation_axes),
                     point=self.location,
                     direction=self.translation_vectors[
                         self.translation_axes[child.index]],
                     color=self.colors[
                         self.translation_axes[child.index]],
                     head_length=self.scale / 3.)

    @Part
    def center(self):
        return Sphere(radius=self.scale / 10.,
                      color='white')


if __name__ == '__main__':
    import math

    from parapy.gui import display

    class ManipulablePlane(Plane, Manipulable):
        translation_axes = ['z']

        reverse = Input(False)

        @Attribute
        def manipulator_position(self):
            position = self.position
            if self.reverse:
                position = rotate(position, 'x', math.pi)

            return translate(position, 'z', 0.5)

        def on_transform(self, evt):
            current_position = evt.current_position
            if -3 > current_position.z or current_position.z > 3:
                evt.Veto()

        def on_manipulation_end(self, viewer, submitted, start_position,
                                end_position):
            if submitted:
                self.reference = end_position

    obj = ManipulablePlane()
    display(obj)

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

from functools import partial
from numbers import Number

from OCC.wrapper._Graphic3d import (
    Graphic3d_Camera_Projection_Orthographic,
    Graphic3d_Camera_Projection_Perspective)
from OCC.gui.camera import Camera
from parapy.core import Attribute, Base, Input
from parapy.core.utilities import is_iterable
from parapy.geom import (
    Circle, Orientation, Plane3P, Point, Position,
    RectangularSurface, TrimmedCurve, Vector)
from parapy.geom.generic.utilities import is_almost_equal

_PROJECTIONS = {
    'orthographic': Graphic3d_Camera_Projection_Orthographic,
    'perspective': Graphic3d_Camera_Projection_Perspective
}

__all__ = ["MinimalCamera", "PositionedCamera", "PlaneCamera",
           "cameras_on_path", "linear_sweep_cameras", "circular_sweep_cameras"]


class MinimalCamera(Base):
    """A Camera containing the minimal settings to define a camera view for
    an orthogonal projection.

    Usage:

    >>> from parapy.geom import Vector, Point
    >>> # a camera looking from the top with the screen rotated 45 degrees
    >>> camera = MinimalCamera(viewing_center=Point(0, 0, 0),
    ...                        eye_location=Point(0, 0, 5),
    ...                        up_direction=Vector(1, 1, 0),
    ...                        scale=4, aspect_ratio=1.5)

    """

    #: Point that is in the center of the camera view. The camera will look
    #: from :attr:`eye_location` to this :class:`~parapy.geom.Point`.
    #: :type: parapy.geom.Point
    viewing_center = Input(None)

    #: Location of the camera (its eye).
    #: :type: parapy.geom.Point
    eye_location = Input(None)

    #: A vector defining what is the 'up' direction of a camera view.
    #: :type: parapy.geom.Vector
    up_direction = Input(None)

    #: A measure for the size of the viewport.
    #: :type: float
    scale = Input(None)

    #: camera view its width / height.
    #: :type: float
    aspect_ratio = Input(None)

    @Attribute
    def occ_camera(self):
        """
        :rtype: OCC.gui.camera.Camera
        """
        camera = Camera()

        ctr = self.viewing_center
        eye = self.eye_location
        up = self.up_direction
        scale = self.scale
        aspect_ratio = self.aspect_ratio

        if ctr is not None:
            camera.viewing_center = ctr
        if eye is not None:
            camera.eye_location = eye
        if up is not None:
            camera.up_direction = up
        if scale is not None:
            camera.scale = scale
        if aspect_ratio is not None:
            camera.aspect_ratio = aspect_ratio

        return camera

    @Attribute(pickle=False, private=True)
    def graphic3d_camera(self):
        """OCC camera object

        :return: OCC.Graphic3d.Handle_Graphic3d_Camera
        """
        return self.occ_camera._camera

    @Attribute
    def _calculated_center(self):
        viewing_center = self.viewing_center

        if viewing_center:
            return viewing_center
        elif (self.viewing_direction and self.center_eye_distance and
                  self.eye_location):
            movement = self.viewing_direction * self.center_eye_distance
            return self.eye_location + movement

    @Attribute
    def orientation(self):
        """Orientation of the camera

        :rtype: parapy.geom.Orientation
        """
        up_direction = self.occ_camera.up_direction
        viewing_direction = self.occ_camera.viewing_direction

        return Orientation(y=up_direction, z=viewing_direction)

    @Attribute
    def position(self):
        """Position of this camera

        :rtype: parapy.geom.Position
        """
        location = Point(*self.occ_camera.eye_location)
        orientation = self.orientation

        return Position(location=location, orientation=orientation)

    def interpolate(self, other, frac=0.5):
        """Create a camera with linearly interpolated settings between
        this camera and an ``other`` camera, interpolated at ``frac``.

        :param other: MinimalCamera
        :type frac: float
        :rtype: MinimalCamera
        """
        attr_to_type = {'eye_location': Point,
                        'viewing_center': Point,
                        'scale': Number,
                        'aspect_ratio': Number,
                        'up_direction': Vector}

        # we need to use the occ_camera, we know these values are always set
        cam1_getattr = partial(getattr, self.occ_camera)
        cam2_getattr = partial(getattr, other.occ_camera)

        # interpolate cam settings
        cam_settings = dict()
        for attr, type_ in attr_to_type.items():
            interp_value = _interpolate(cam1_getattr(attr),
                                        cam2_getattr(attr), frac)
            # we need to translate some values back to ParaPy types
            if not isinstance(interp_value, type_):
                # statement only reacheable for Point/Vector types
                interp_value = type_(*interp_value)
            cam_settings[attr] = interp_value

        return MinimalCamera(**cam_settings)

    @classmethod
    def copy_from_camera(cls, camera):
        """Creates a new ``cls``, which is a copy of ``camera``.

        Usage:

        >>> from parapy.geom import Point
        >>> cam = MinimalCamera(eye_location=Point(1, 2, 3))
        >>> cam_copy = MinimalCamera.copy_from_camera(cam)
        >>> cam_copy.eye_location
        Point(1, 2, 3)
        >>> cam_copy == cam
        False

        :param parapy.gui.camera.MinimalCamera camera:
        :rtype: parapy.gui.camera.MinimalCamera
        """
        return cls(viewing_center=camera.viewing_center,
                   eye_location=camera.eye_location,
                   up_direction=camera.up_direction,
                   scale=camera.scale,
                   aspect_ratio=camera.aspect_ratio)


class PositionedCamera(MinimalCamera):
    """A camera defined by a :class:`~parapy.geom.Position`, a scale and
    an aspect_ratio.

    Usage:

    >>> from parapy.geom import Position, Orientation, Point, Vector
    >>> # top-down view, camera rotated 45 degrees
    >>> eye_location = Point(0, 0, 1)
    >>> up_direction = Vector(1, 1, 0)
    >>> viewing_direction = Vector(0, 0, -1)
    >>> camera_orientation = Orientation(y=up_direction, z=viewing_direction)
    >>> camera_position = Position(location=eye_location,
    ...                            orientation=camera_orientation)
    >>> camera = PositionedCamera(position=camera_position,
    ...                           scale=3, aspect_ratio=1.5)
    """

    #: A camera position, with the location being the camera location,
    #: the y-axis is the camera 'up' direction, the z-axis is the viewing
    #: direction of the camera.
    #: :type: parapy.geom.Position
    position = Input()

    #: Defines how far the viewing center lies in front of the eye location.
    #: :type: float
    center_eye_distance = Input(1.)

    @Attribute
    def orientation(self):
        """:rtype: parapy.geom.Orientation"""
        return self.position.orientation

    @Attribute
    def up_direction(self):
        """:rtype: parapy.geom.Vector"""
        return self.orientation.y

    @Attribute
    def eye_location(self):
        """:rtype: parapy.geom.Point"""
        return self.position.location

    @Attribute
    def viewing_center(self):
        """:rtype: parapy.geom.Point"""
        eye_location = self.eye_location
        direction = self.orientation.z.normalized * self.center_eye_distance
        return eye_location + direction

    @classmethod
    def copy_from_camera(cls, camera):
        """Creates a new ``cls``, which is a copy of ``camera``.

        Usage:

        >>> from parapy.geom import Point
        >>> cam = MinimalCamera(eye_location=Point(1, 2, 3))
        >>> cam_copy = PositionedCamera.copy_from_camera(cam)
        >>> cam_copy.eye_location
        Point(1.0, 2.0, 3.0)
        >>> cam_copy == cam
        False

        :param parapy.gui.camera.MinimalCamera camera:
        :rtype: parapy.gui.camera.MinimalCamera
        """
        occ_cam = camera.occ_camera
        distance = (Point(*occ_cam.viewing_center) -
                    Point(*occ_cam.eye_location)).length

        return cls(position=camera.position,
                   scale=camera.scale,
                   aspect_ratio=camera.aspect_ratio,
                   center_eye_distance=distance)


class PlaneCamera(MinimalCamera):
    """An orthogonal camera defined by a
    :class:`~parapy.geom.RectangularSurface`. Since the camera is orthogonal,
    the surface defines what can be seen by the camera: if one would make a
    halfspace solid from the surface in the direction of the surface normal,
    everything in the halfspace solid would end up in the view.

    The surface its width and length
    define the aspect ratio of the camera. The normal of the surface points
    in the viewing direction of the camera. The camera eye will be located
    at the center of :attr:`plane`. The :attr:`viewing_center` is located
    :attr:`center_eye_distance` in front of :attr:`eye_location` in the
    :attr:`viewing_direction`.

    Usage:

    >>> from parapy.geom import RectangularSurface
    >>> srf = RectangularSurface(width=3, length=3)
    >>> camera = PlaneCamera(plane=srf)

    """

    #: A RectangularSurface used to define the camera.
    #: :type: parapy.geom.RectangularSurface
    plane = Input()

    #: Defines how far the viewing center lies in front of the eye location.
    #: :type: float
    center_eye_distance = Input(1.)

    #: Should the normal of :attr:`plane` be flipped? Does not influence
    #: the y-direction
    #: :type: bool
    flip_normal = Input(False)

    @Attribute
    def viewing_center(self):
        """:rtype: parapy.geom.Point"""
        distance = self.center_eye_distance
        return self.eye_location + (self.viewing_direction * distance)

    @Attribute
    def eye_location(self):
        """:rtype: parapy.geom.Point"""
        return self.plane.cog

    @Attribute
    def viewing_direction(self):
        """:rtype: parapy.geom.Vector"""
        direction = self.plane.position.orientation.z.normalized
        if self.flip_normal:
            return direction * -1
        else:
            return direction

    @Attribute
    def up_direction(self):
        """:rtype: parapy.geom.Vector"""
        return self.plane.position.orientation.y

    @Attribute
    def aspect_ratio(self):
        """:rtype: float"""
        plane = self.plane
        return plane.width / plane.length

    @Attribute
    def scale(self):
        """:rtype: float"""
        return self.plane.length

    @classmethod
    def copy_from_camera(cls, camera):
        """Creates a new ``cls``, which is a copy of ``camera``.

        Usage:

        >>> from parapy.geom import Point
        >>> cam = MinimalCamera(eye_location=Point(1, 2, 3))
        >>> cam_copy = PlaneCamera.copy_from_camera(cam)
        >>> cam_copy.eye_location
        Point(1.0, 2.0, 3.0)
        >>> cam_copy == cam
        False

        :param parapy.gui.camera.MinimalCamera camera:
        :rtype: parapy.gui.camera.MinimalCamera
        """
        # need to use occ camera, a lot might not be set in ParaPy class
        occ_cam = camera.occ_camera
        cam_eye = Point(*occ_cam.eye_location)
        cam_view_ctr = Point(*occ_cam.viewing_center)

        # plane position
        viewing_direction = cam_view_ctr - cam_eye
        ori = Orientation(z=viewing_direction,
                          y=Vector(*occ_cam.up_direction))
        pos = Position(location=cam_eye, orientation=ori)

        # define plane
        length = occ_cam.scale
        plane = RectangularSurface(length=length,
                                   width=length * occ_cam.aspect_ratio,
                                   position=pos)
        return cls(plane=plane,
                   center_eye_distance=abs(viewing_direction.length))


def _interpolate(a, b, frac):
    """Makes a linear interpolation between ``a`` and ``b`` at
    fraction ``frac``.

    Usage:

    >>> from parapy.geom import Point, Vector
    >>> _interpolate(1, 5, 0.5)
    3.0
    >>> _interpolate(4.3, -1.2, 0.2)  # doctest: +ELLIPSIS
    3.19...
    >>> _interpolate(Point(0, 0, 0), Point(1, 1, 1), 0.2)
    Point(0.2, 0.2, 0.2)
    >>> _interpolate(Vector(0, 0, 0), Vector(1, 1, 1), 0.2)
    Vector(0.2, 0.2, 0.2)
    >>> _interpolate((0, 0, 0), (1, 1, 1), 0.2)
    (0.2, 0.2, 0.2)
    >>> _interpolate([0, 0, 0], [1, 1, 1], 0.2)
    [0.2, 0.2, 0.2]

    .. note:: If ``a`` and ``b`` are a sized iterable, without an appropriate
        interpolate method, the result will be of the same type as ``a``. It
        will be assumed that this type will be constructable from a generator.

    :param T a: either a Number, a sized iterable,
        or an object with an interpolate method.
    :param T b: either a Number, a sized iterable,
        or an object with an interpolate method.
    :param float frac: at which fraction between ``a`` and ``b`` the
        interpolation should be.
    :rtype: T | float | tuple
    """
    try:
        return a.interpolate(b, frac=frac)
    except AttributeError:
        if isinstance(a, Number):
            return (b - a) * frac + a
        elif is_iterable(a) and is_iterable(b):
            t = type(a)
            return t(_interpolate(el_a, el_b, frac) for
                     el_a, el_b in zip(a, b))

    msg = ("Expected a Number, a sized iterable or an object having an "
           "interpolation method with signature: "
           "'interpolate(self, other, frac), got objects: {} and {}")
    raise ValueError(msg.format(a, b))


def yield_cameras_on_path(path, nb, camera, camera2=None):
    """Generate ``nb`` cameras on ``path``, using all the settings
    of ``camera`` except for the eye position.

    :param parapy.geom.Curve path: Path on which ``nb_points`` will be taken to
        form the eye positions.
    :param int nb: Number of equi-spaced points on ``path``.
    :param parapy.gui.camera.MinimalCamera camera: A camera that is used for
        the settings for all cameras, except if ``camera2` is also defined.
    :param parapy.gui.camera.MinimalCamera | None camera2: If a second camera
        is specified, an interpolation will be done of the settings
        from ``camera`` to ``camera2``. The eye of the camera will, however
        follow ``path``.
    :rtype: collections.Iterator[parapy.gui.camera.MinimalCamera]
    """
    if camera2 is None:  # make copies of camera
        copy_camera = MinimalCamera.copy_from_camera
        cameras = (copy_camera(camera) for _ in range(nb))
    else:  # interpolate
        cameras = yield_linear_sweep_cameras(camera, camera2, nb)

    for pt, camera_copy in zip(path.equispaced_points(nb), cameras):
        camera_copy.eye_location = pt
        yield camera_copy


def cameras_on_path(path, nb, camera, camera2=None):
    """List of``nb`` cameras with their eye-position on a ``path``, using all
    the settings of ``camera`` except for the eye position.

    Usage:

    >>> from parapy.geom import LineSegment, Point
    >>> line = LineSegment(Point(0, 0, 0), Point(0, 0, 1))
    >>> camera = MinimalCamera()
    >>> cameras = cameras_on_path(line, 11, camera)
    >>> len(cameras)
    11
    >>> list(cam.eye_location for cam in cameras) # doctest: +ELLIPSIS
    [Point(0.0, 0.0, 0.0), Point(0.0, 0.0, 0.1), ..., Point(0.0, 0.0, 1.0)]

    :param parapy.geom.Curve path: Path on which ``nb_points`` will be taken to
        form the eye positions.
    :param int nb: Number of equi-spaced points on ``path``.
    :param parapy.gui.camera.MinimalCamera camera: A camera that is used to
        copy all the settings from except for the eye-location.
    :param parapy.gui.camera.MinimalCamera | None camera2: If a second camera
        is specified, an interpolation will be done of the settings
        from ``camera`` to ``camera2``. The eye of the camera will, however
        follow ``path``.
    :rtype: list[parapy.gui.camera.MinimalCamera]
    """
    return list(yield_cameras_on_path(path, nb, camera, camera2=camera2))


def yield_circular_sweep_cameras(camera1, camera2, nb, rotation_center=None,
                                 shortest_path=True):
    """Yield ``nb`` cameras on a circular-shaped path from ``camera1`` to
    ``camera2``. By default, the circular path has its center at the
    midpoint between the :attr:`~MinimalCamera.viewing_center` of
    ``camera1`` and ``camera2``, respectively. It can also be explicitly
    specified through ``rotation_center``. By default, the ``shortest_path``
    will be used, viz. shortest arc on the circle bound by the
    :attr:`~MinimalCamera.eye_location` of ``camera1`` and ``camera2``,
    respectively.. Other camera settings will be interpolated between the
    two cameras.

    :param parapy.gui.camera.MinimalCamera camera1:
    :param parapy.gui.camera.MinimalCamera camera2:
    :param int nb: Number of points between camera 1 and camera 2
    :param Point | None rotation_center: optional center of rotation. By
        default, the circular path has its center at the midpoint between the
        :attr:`~MinimalCamera.viewing_center` of ``camera1`` and ``camera2``.
    :param bool shortest_path: If set to True, it will take the shortest arc
        on the circle bound by the :attr:`~MinimalCamera.eye_location` of
        ``camera1`` and ``camera2`` (default: :py:`True`).
    :rtype: collections.Iterator[parapy.gui.camera.MinimalCamera]
    :raise ValueError: If ``rotation_point`` or the constructed
        ``rotation_point`` can not be the center of a Circle through
        ``camera1`` and ``camera1``.
    """
    if rotation_center is None:
        rot_center = _interpolate(camera1.viewing_center,
                                  camera2.viewing_center, 0.5)
    else:
        rot_center = rotation_center

    cam1_eye = camera1.eye_location
    cam2_eye = camera2.eye_location
    radius1 = (cam1_eye - rot_center).length

    # check if ``rotation_center`` is at an equal distance from both cam-eyes
    radius2 = (cam2_eye - rot_center).length
    if not is_almost_equal(radius1, radius2, tol=1e-7):
        if rotation_center is None:
            msg = ("No rotation_center specified and could not deduce a "
                   "valid rotation_center that is on an "
                   "equal distance from camera1 and camera2. Please specify"
                   "a rotation_center that is.")
        else:
            msg = ("Invalid rotation_center {}: it cannot be the center of a "
                   "Circle through camera1 and camera2. Distance to camera1: "
                   "{}, distance to camera2: {}. Please "
                   "specify a rotation_center that is on an equal distance "
                   "from both camera eyes.").format(rot_center, radius1,
                                                    radius2)
        raise ValueError(msg)

    rot_plane_ori = Plane3P(cam1_eye, cam2_eye, rot_center).orientation

    full_circle = Circle(radius=radius1,
                         position=Position(location=rot_center,
                                           orientation=rot_plane_ori))

    # trim path, we do not want the full circle
    path_on_circle = TrimmedCurve(full_circle, cam1_eye, cam2_eye)
    half_circle_length = full_circle.length / 2.
    if shortest_path and path_on_circle.length > half_circle_length:
        path_on_circle = TrimmedCurve(full_circle, cam2_eye, cam1_eye)
    elif (not shortest_path) and path_on_circle.length < half_circle_length:
        path_on_circle = TrimmedCurve(full_circle, cam2_eye, cam1_eye)

    # make sure path starts on camera1.eye_location
    if not path_on_circle.start.is_almost_equal(cam1_eye):
        path_on_circle = path_on_circle.reversed

    return yield_cameras_on_path(path_on_circle, nb, camera1, camera2)


def circular_sweep_cameras(camera1, camera2, nb, rotation_center=None,
                           shortest_path=True):
    """List ``nb`` cameras on a circular-shaped path from ``camera1`` to
    ``camera2``. By default, the circular path has its center at the
    midpoint between the :attr:`~MinimalCamera.viewing_center` of
    ``camera1`` and ``camera2``, respectively. It can also be explicitly
    specified through ``rotation_center``. By default, the ``shortest_path``
    will be used, viz. shortest arc on the circle bound by the
    :attr:`~MinimalCamera.eye_location` of ``camera1`` and ``camera2``,
    respectively.. Other camera settings will be interpolated between the
    two cameras.

    >>> from parapy.gui.camera import MinimalCamera
    >>> from parapy.geom import Point
    >>>
    >>> viewing_center = Point(0, 0, 0)
    >>> cam1 = MinimalCamera(viewing_center=viewing_center,
    ...                      eye_location=Point(3, 3, 3))
    >>> cam2 = MinimalCamera(viewing_center=viewing_center,
    ...                      eye_location=Point(-3, -3, 3))
    >>> cameras = circular_sweep_cameras(cam1, cam2, 10)
    >>> len(cameras)
    10
    >>> [cam.eye_location for cam in cameras]  # doctest: +ELLIPSIS
    [Point(3.0, 3.0, 3.0), Point(2.48..., 2.48..., 3.82...), ..., Point(-3.0, -3.0, 3.0)]

    :param parapy.gui.camera.MinimalCamera camera1:
    :param parapy.gui.camera.MinimalCamera camera2:
    :param int nb: Number of points between camera 1 and camera 2.
    :param Point | None rotation_center: optional center of rotation. By
        default, the circular path has its center at the midpoint between the
        :attr:`~MinimalCamera.viewing_center` of ``camera1`` and ``camera2``.
    :param bool shortest_path: If set to True, it will take the shortest arc
        on the circle bound by the :attr:`~MinimalCamera.eye_location` of
        ``camera1`` and ``camera2`` (default: :py:`True`).
    :rtype: list[parapy.gui.camera.MinimalCamera]
    """
    return list(yield_circular_sweep_cameras(camera1, camera2, nb,
                                             rot_center=rotation_center,
                                             shortest_path=shortest_path))


def yield_linear_sweep_cameras(camera1, camera2, nb):
    """Generate ``nb`` cameras that form a linear sweep from
    ``camera1`` to ``camera2``, interpolating the settings between them.
    The sweep will include ``camera1`` and ``camera2``.

    :param parapy.gui.camera.MinimalCamera camera1:
    :param parapy.gui.camera.MinimalCamera camera2:
    :param int nb: Number of points between camera 1 and camera 2
    :rtype: collections.Iterator[parapy.gui.camera.MinimalCamera]
    """
    if nb < 2:
        raise ValueError("nb should be at least 2, but it is {}".format(nb))

    parts = nb - 1  # parts in which the line between the cameras is divided
    interp_step = 1. / parts  # normalized size of each part

    yield camera1

    cam_interp = partial(camera1.interpolate, camera2)
    for i in range(1, parts):
        frac = i * interp_step
        yield cam_interp(frac=frac)

    yield camera2


def linear_sweep_cameras(camera1, camera2, nb):
    """Return``nb`` cameras that form a linear sweep from
    ``camera1`` to ``camera2``, interpolating the settings between them.
    The sweep will include camera1 and camera2.

    Usage:

    >>> from parapy.gui.camera import MinimalCamera
    >>> from parapy.geom import Point
    >>> viewing_center = Point(0, 0, 0)
    >>> cam1 = MinimalCamera(viewing_center=viewing_center,
    ...                      eye_location=Point(3, 3, 3))
    >>> cam2 = MinimalCamera(viewing_center=viewing_center,
    ...                      eye_location=Point(-3, -3, 3))
    >>> cameras = linear_sweep_cameras(cam1, cam2, 10)
    >>> len(cameras)
    10
    >>> list(cam.eye_location for cam in cameras)  # doctest: +ELLIPSIS
    [Point(3, 3, 3), Point(2.33..., 2.33..., 3.0), ..., Point(-3, -3, 3)]

    :param parapy.gui.camera.MinimalCamera camera1:
    :param parapy.gui.camera.MinimalCamera camera2:
    :param int nb: Number of points between camera 1 and camera 2
    :rtype: list[parapy.gui.camera.MinimalCamera]
    """
    return list(yield_linear_sweep_cameras(camera1, camera2, nb))

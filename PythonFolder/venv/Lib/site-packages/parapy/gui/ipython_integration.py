#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE


def get_interactive_shell():
    """:rtype: IPython.core.interactiveshell.InteractiveShell | None"""
    try:
        from IPython import get_ipython
        return get_ipython()
    except:
        try:
            import IPython.core.ipapi
            return IPython.core.ipapi.get()
        except:
            try:
                import IPython.ipapi
                return IPython.ipapi.get()
            except:
                return None

_SECRET_KEY = "_PATCHED_IPYTHON_WX4"


def patch_ipython_wx4(interactive_shell):

    if getattr(interactive_shell, _SECRET_KEY, False):
        return  # already patched

    name = interactive_shell.__class__.__name__

    if name == "PyDevTerminalInteractiveShell":
        patch_pydev_ipython_wx4()
    else:  # TerminalInteractiveShell (regular IPython)
        patch_regular_ipython_wx4()

    setattr(interactive_shell, _SECRET_KEY, True)


# Tested on PyCharm 2019.1.1
def patch_pydev_ipython_wx4():

    import signal
    import time
    from timeit import default_timer as clock

    import wx
    from pydev_ipython.inputhook import stdin_ready

    # Adapted from https://github.com/JetBrains/intellij-community/tree/master/python/helpers/pydev/pydev_ipython
    def inputhook_wx4():
        """Run the wx event loop by processing pending events only.

        This is like inputhook_wx1, but it keeps processing pending events
        until stdin is ready.  After processing all pending events, a call to
        time.sleep is inserted.  This is needed, otherwise, CPU usage is at 100%.
        This sleep time should be tuned though for best performance.
        """
        # We need to protect against a user pressing Control-C when IPython is
        # idle and this is running. We trap KeyboardInterrupt and pass.
        try:
            app = wx.GetApp()  # @UndefinedVariable
            if app is not None:
                assert wx.IsMainThread()  # @UndefinedVariable

                # The import of wx on Linux sets the handler for signal.SIGINT
                # to 0.  This is a bug in wx or gtk.  We fix by just setting it
                # back to the Python default.
                if not callable(signal.getsignal(signal.SIGINT)):
                    signal.signal(signal.SIGINT, signal.default_int_handler)

                evtloop = wx.GUIEventLoop()  # @UndefinedVariable
                ea = wx.EventLoopActivator(evtloop)  # @UndefinedVariable
                t = clock()
                while not stdin_ready():
                    while evtloop.Pending():
                        t = clock()
                        evtloop.Dispatch()
                    evtloop.ProcessIdle()
                    # We need to sleep at this point to keep the idle CPU load
                    # low.  However, if sleep to long, GUI response is poor.  As
                    # a compromise, we watch how often GUI events are being processed
                    # and switch between a short and long sleep time.  Here are some
                    # stats useful in helping to tune this.
                    # time    CPU load
                    # 0.001   13%
                    # 0.005   3%
                    # 0.01    1.5%
                    # 0.05    0.5%
                    used_time = clock() - t
                    if used_time > 10.0:
                        # print 'Sleep for 1 s'  # dbg
                        time.sleep(1.0)
                    elif used_time > 0.1:
                        # Few GUI events coming in, so we can sleep longer
                        # print 'Sleep for 0.05 s'  # dbg
                        time.sleep(0.05)
                    else:
                        # Many GUI events coming in, so sleep only very little
                        time.sleep(0.001)
                del ea
        except KeyboardInterrupt:
            pass
        return 0

    import pydev_ipython.inputhookwx

    # print "Patching PyDev IPython for wx Phoenix integration"
    pydev_ipython.inputhookwx.inputhook_wx = inputhook_wx4


# Tested on IPython.__version__ 5.8.0
def patch_regular_ipython_wx4():

    import signal
    import time
    from timeit import default_timer as clock

    import wx

    # Adapted from https://github.com/ipython/ipython/blob/5.x/IPython/terminal/pt_inputhooks/wx.py
    def inputhook_wx4(context):
        """Run the wx event loop by processing pending events only.

        This is like inputhook_wx1, but it keeps processing pending events
        until stdin is ready.  After processing all pending events, a call to
        time.sleep is inserted.  This is needed, otherwise, CPU usage is at 100%.
        This sleep time should be tuned though for best performance.
        """
        # We need to protect against a user pressing Control-C when IPython is
        # idle and this is running. We trap KeyboardInterrupt and pass.
        try:
            app = wx.GetApp()
            if app is not None:
                assert wx.IsMainThread()

                # The import of wx on Linux sets the handler for signal.SIGINT
                # to 0.  This is a bug in wx or gtk.  We fix by just setting it
                # back to the Python default.
                if not callable(signal.getsignal(signal.SIGINT)):
                    signal.signal(signal.SIGINT, signal.default_int_handler)

                evtloop = wx.GUIEventLoop()
                ea = wx.EventLoopActivator(evtloop)
                t = clock()
                while not context.input_is_ready():
                    while evtloop.Pending():
                        t = clock()
                        evtloop.Dispatch()
                    evtloop.ProcessIdle()
                    # We need to sleep at this point to keep the idle CPU load
                    # low.  However, if sleep to long, GUI response is poor.  As
                    # a compromise, we watch how often GUI events are being processed
                    # and switch between a short and long sleep time.  Here are some
                    # stats useful in helping to tune this.
                    # time    CPU load
                    # 0.001   13%
                    # 0.005   3%
                    # 0.01    1.5%
                    # 0.05    0.5%
                    used_time = clock() - t
                    if used_time > 10.0:
                        # print 'Sleep for 1 s'  # dbg
                        time.sleep(1.0)
                    elif used_time > 0.1:
                        # Few GUI events coming in, so we can sleep longer
                        # print 'Sleep for 0.05 s'  # dbg
                        time.sleep(0.05)
                    else:
                        # Many GUI events coming in, so sleep only very little
                        time.sleep(0.001)
                del ea
        except KeyboardInterrupt:
            pass
        return 0

    import IPython.terminal.pt_inputhooks.wx

    # print "Patching IPython for wx Phoenix integration"
    IPython.terminal.pt_inputhooks.wx.inputhook = inputhook_wx4

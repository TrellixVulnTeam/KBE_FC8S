#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This file provides a wx.Panel to display parts of the object tree. This
panel can deal with configuration changes (numbers of parts changes and type
changes). This in contrast to the :class:`parapy.gui.viewer.Viewer` class,
that only managed continuous changes (shape and style).

Scenarios:
    A. Property changes:
        Shape, color or transparency changes. Handled by Viewer, after calling
        Viewer.refresh()
    B. Topology changes
        Undrawn ancestor gets replaced
            -> Object should be redrawn, if its path still exists
        Drawn object gets replaced
            -> Object should be drawn again, with the same command as with
            which it was drawn before.
"""

from itertools import chain
from weakref import WeakKeyDictionary

import wx

from parapy.core import Attribute, Base, Input, getslot
from parapy.core.abstract import DrawableParaPyObject, ParaPyObject
from parapy.core.events import broadcast_event
from parapy.gui.events import (
    EVT_LEFT_CLICK_OBJECT, EVT_RIGHT_CLICK_OBJECT, EVT_SELECTION_CHANGED,
    EVT_TOOLTIP, create_object_tooltip_event, create_selection_changed_event,
    create_selection_changing_event)
from parapy.gui.globs import CONFIGURATION
from parapy.gui.state import DrawStateTree
from parapy.gui.utilities import (
    hidable_children_generator,
    safe_drawable_children_with_path_generator as sdcwpg)
from parapy.gui.viewer import Viewer


class _WeakReffable(object):  # helper to create weak references
    __slots__ = ("__weakref__", )


class TreeViewerPanel(wx.Panel):

    LABEL = 'Geometry View'

    def __init__(self, parent, obj, autodraw=None):
        wx.Panel.__init__(self, parent)

        self.root_object = obj
        #: dictionary: {path, parapy.gui.state.DrawState}
        self.listeners = {}
        #: :type: dict[object, set[tuple[str | int]]]
        self.obj_to_path = WeakKeyDictionary()
        #: dictionary: {path: [previous iterable of children]}
        self.configuration_updates = {}
        #: :type: parapy.gui.viewer.Viewer
        self.viewer = viewer = Viewer(self)
        #: :type: OCC.gui.viewer_and_toolbar.ToolBarPanel
        self.toolbar = self.viewer.toolbar
        #: :type: DrawStateTree
        self.draw_state_tree = DrawStateTree(obj)
        #: :type: bool
        if autodraw is None:
            self.autodraw = CONFIGURATION['autodraw']
        else:
            self.autodraw = autodraw

        self.Bind(wx.EVT_WINDOW_DESTROY, self.on_destroy)

        viewer.Bind(EVT_RIGHT_CLICK_OBJECT, self.on_cast_right_click)
        viewer.Bind(EVT_LEFT_CLICK_OBJECT, self.on_cast_left_click)
        viewer.Bind(EVT_TOOLTIP, self.on_tooltip_event)

        self.init_toolbar()
        self.init_layout()

        if self.autodraw:
            self.display_all()

    def init_layout(self):
        box = wx.StaticBox(self, wx.ID_ANY, self.LABEL)
        sizer = wx.StaticBoxSizer(box, wx.VERTICAL )
        sizer.Add(self.viewer, 1, wx.EXPAND, 5)
        self.SetSizer(sizer)
        self.Layout()

    def init_toolbar(self):
        toolbar = self.toolbar

        id_btn_delete_all = toolbar.btn_delete_all.GetId()
        id_btn_refresh = toolbar.btn_refresh.GetId()

        toolbar.Unbind(wx.EVT_TOOL, id=id_btn_delete_all)
        toolbar.Unbind(wx.EVT_TOOL, id=id_btn_refresh)

        toolbar.Bind(wx.EVT_TOOL, lambda _: self.remove_all(),
                     id=id_btn_delete_all)
        toolbar.Bind(wx.EVT_TOOL, lambda _: self.refresh(),
                     id=id_btn_refresh)

    def on_button_refresh(self, evt):
        self.refresh()

    def refresh_event_handler(self, evt):
        self.refresh()

    def remove_all(self, update=True):
        self._remove_all_local(update)
        self.viewer.remove_all(update)

    def _remove_all_local(self, update=True):
        self.unregister_listeners()
        self.listeners.clear()
        self.obj_to_path.clear()
        self.draw_state_tree.clear()
        self.configuration_updates.clear()

    def unregister_listeners(self):
        for listener in self.listeners.values():
            listener.unregister()

    def refresh(self, update=True, fit=False, update_indiv=False):
        """update Base object style, update children"""
        if self.autodraw:
            self.display_all()

        # expansion_state = self.get_expansion_state(self.root_id)
        to_display = set()  # this includes ones that didn't change and new ones.
        to_remove = set()
        to_hide = set()

        currently_hidden = set(self.viewer.yield_hidden())

        for path, old_displayed in self.configuration_updates.items():
            wrapper = self.listeners.get(path)

            if wrapper:
                new_displayed = wrapper.object_to_draw
            else:  # de-register. This is to remove the stuff that is there
                new_displayed = None

            was_hidden = old_displayed in currently_hidden

            if old_displayed != new_displayed:
                to_remove.add(old_displayed)

                self._untrack_path_to_obj(old_displayed, path)
                if new_displayed:
                    self._track_objs_on_path(path)

                    to_display.add(new_displayed)
                    if was_hidden:
                        to_hide.add(new_displayed)

        self.viewer.remove(to_remove, False, False, update_indiv)
        self.viewer.display(to_display, False, False, update_indiv)
        self.viewer.hide(to_hide, False, False, update_indiv)

        # self.restore_expansion_state(expansion_state, self.root_id)
        self.configuration_updates.clear()

        self.viewer.refresh(update=update, fit=fit)

    def on_destroy(self, evt=None):
        self._remove_all_local(False)

    def _cast_object_tooltip_event(self, owner, refchains):
        evt = create_object_tooltip_event(
            source=self, owner=owner, refchain=refchains[0],
            refchain_resolver=self.get_object_paths)
        broadcast_event(self.root_object, evt.EventType, evt, refchains)
        return evt

    def _cast_selection_changing(self, owner, refchains):
        evt = create_selection_changing_event(
            source=self, owner=owner, refchain=refchains[0],
            refchain_resolver=self.get_object_paths)
        broadcast_event(self.root_object, evt.EventType, evt, refchains)
        return evt

    def cast_selection_changed(self, owner, refchains):
        """Cast a EVT_SELECTION_CHANGED event. This will first cast a
        EVT_SELECTION_CHANGING event which will allow registered listeners
        to overwrite which object will be selected. Afterwards it will cast
        a EVT_SELECTION_CHANGED event with the newly selected object.

        :param owner:
        :param collections.Iterable[tuple[int | str]] refchains: the reference
            chains referring to ``owner``.
        :return:
        """
        # notify that the selection is about to change, allow listeners to
        # Veto the selection
        evt = self._cast_selection_changing(owner, refchains)

        # if not vetoed, cast the selection_changed event
        if evt.IsAllowed:
            selected_obj = evt.owner
            obj_refchain = evt.refchain
            selection_changed_evt = create_selection_changed_event(
                source=self,
                owner=selected_obj,
                refchain=obj_refchain)

            # first cast as ParaPy event on the new owner
            if not broadcast_event(self.root_object, EVT_SELECTION_CHANGED,
                                   selection_changed_evt, (obj_refchain,)):
                selection_changed_evt.Skip(False)  # make sure that it is reset
                # all handlers skipped, or there were no handlers
                wx.PostEvent(self, selection_changed_evt)

    def cast_event(self, evt, pp_event_type):
        skip = True

        paths_per_obj = list(map(self.get_object_paths, evt.selected))
        if not all(paths_per_obj):
            # Could not resolve tree path to at least one object, so we do not
            # cast the ParaPy click events
            evt.Skip()
            return

        all_refchains = list(chain(*paths_per_obj))

        if not evt.multiple:  # cast event selection changing
            current_owner = evt.selected[0]
            self.cast_selection_changed(current_owner, all_refchains)

        # FIXME (TBD): Case where one selected object returns multiple paths
        # /fixme is supported in a way that might be unexpected: if an object
        # /fixme appears in multiple paths, events only will fire until the
        # /fixme longest common prefix after the second object was drawn.
        if broadcast_event(self.root_object, pp_event_type, evt,
                           all_refchains):
            # a handler did not skip, so we should stop with
            # propagating this event
            skip = False

        evt.Skip(skip)

    def on_cast_right_click(self, evt):
        self.cast_event(evt, EVT_RIGHT_CLICK_OBJECT)

    def on_cast_left_click(self, evt):
        self.cast_event(evt, EVT_LEFT_CLICK_OBJECT)

    def on_tooltip_event(self, evt):
        # The cursor can hover over several objects. The owner is the first
        # (ordered by depth) of the detected objects
        current_owner = evt.detected[0]
        all_refchains = self.get_object_paths(current_owner)

        if not all_refchains:
            # Could not resolve tree path, so we do not cast tooltip event
            evt.Skip()
            return

        evt = self._cast_object_tooltip_event(current_owner, all_refchains)
        owner = evt.owner

        viewer = self.viewer
        if viewer.SHOW_TOOLTIP:
            viewer.show_tooltip_obj(owner)

    def on_drawn_object_change(self, draw_state, old_object):
        """Called when the draw state of a displayed object has been changed.

        :param parapy.gui.state.DrawState draw_state:
        :param DrawableParaPyObject | None old_object:
        """
        # Notify that there are changes in what needs to be drawn
        self.configuration_updates[draw_state.tree_refchain] = old_object

    def on_refchain_unreachable(self, reference_chain):
        """Called when ``reference_chain`` was displayed, but is not part
        of the displayed ParapyMode anymore

        :param tuple[str | int] draw_state:
        """
        del self.listeners[reference_chain]

    def display(self, path, state, update=False, fit=False,
                update_indiv=False):
        """Display obj and/or children defined by ``path`` as seen from the
        root object in GUI.

        :param tuple path: for now, is path as seen from root.
        :param bool|None state: True|False|None:
            - True: this object and all children
            - False: only top object
            - None: only the children
        :param bool update: update viewer when done?
        :param bool fit: fit viewer to all contents when done?
        :param bool update: update viewer in between displaying of individual
            displayable objects?
        """
        draw_tree = self.draw_state_tree
        on_drawn_object_change = self.on_drawn_object_change
        on_refchain_unreachable = self.on_refchain_unreachable

        try:
            draw_state = self.listeners[path]
        except KeyError:
            obj_node = draw_tree._get_node(path) or draw_tree._insert(path)
            draw_state = draw_tree._get_state(obj_node)
            # register callbacks
            draw_state.on_drawn_object_change = on_drawn_object_change
            draw_state.on_unreachable = on_refchain_unreachable

        obj = draw_state.obj

        if not obj:
            return

        # get the drawable children based on state
        if state is None:  # only children
            # remove root path, it may be hidden and not part of generator
            paths = (p for p, _ in sdcwpg(obj, path) if p is not path)
        elif state:  # root and children
            paths = (p for p, _ in sdcwpg(obj, path))
        else:
            if isinstance(obj, DrawableParaPyObject):
                paths = (path,)
            else:
                return

        # Set drawable objects to 'display'
        # add draw states if necessary.
        objects = []
        for path in paths:
            path_node = draw_tree._get_node(path) or draw_tree._insert(path)
            state = draw_tree._get_state(path_node)
            state.display = True

            # register callbacks
            state.on_drawn_object_change = on_drawn_object_change
            state.on_unreachable = on_refchain_unreachable
            self.listeners[path] = state

            # trigger slot to be 'evaluated'
            draw_obj = state.object_to_draw
            # add lookup for obj to path
            self._track_objs_on_path(path)
            if draw_obj is not None:
                objects.append(draw_obj)

        self.viewer.display(objects, update, fit, update_indiv)

    def display_all(self, *args, **kwargs):
        """Display all DrawableShapes in the displayed ParaPy object."""
        self.display((), state=True, *args, **kwargs)

    def hide(self, path, state, update=False, fit=False, update_indiv=False):
        """Hide objects from display. 

        Args:
            path (tuple): for now, is path as seen from root.
            state (True|False|None):
                - True: this object and all children
                - False: only top object
                - None: only the children
        """
        obj = getslot(self.root_object, path, parse=False)
        if state or state is None:
            objects = set(hidable_children_generator(obj))
            if state is None:  # my children only, so not me
                objects.discard(obj)
        else:
            # state is False
            objects = obj,

        self.viewer.hide(objects, update, fit, update_indiv)

    def display_event_handler(self, evt):
        # print "GUI: received EVT_DISP", evt.path, evt.state
        self.display(evt.path, evt.state, update=True)

    def hide_event_handler(self, evt):
        # print "GUI: received EVT_HIDE", evt.path, evt.state
        self.hide(evt.path, evt.state, update=True)

    def get_object_paths(self, obj):
        """If ``obj`` is displayed or hidden in the viewer, return the
        `display state` paths to ``obj``. This is not the ParaPy refchain,
        but a path created by attribute referencing and item indexing from
        :attr:`root_object` to this item.

        :param object obj: An object which is displayed or hidden in the
            viewer.
        :return: The path to ``obj`` or None if ``obj`` is not displayed or
            hidden.
        :rtype: list[tuple[str | int]] | None
        """
        paths = self._get_obj_pathset(obj)
        if paths is None:
            return None
        else:
            return list(paths)

    def _get_obj_pathset(self, obj):
        """Return the set of paths pointint to ``obj`` or :py:`None` if it
        is not or cannot be tracked. It cannot be tracked if ``obj`` is not
        weakreffable and cannot have an attribute being patched into it.
        """
        obj_to_path = self.obj_to_path
        try:
            return obj_to_path.get(obj)
        except TypeError:
            try:
                wreffable = obj.__wr
            except AttributeError:
                return None
            else:
                return obj_to_path.get(wreffable)

    def _track_objs_on_path(self, path):
        """Track all objects on ``path``"""
        draw_tree = self.draw_state_tree
        # TODO (TBD): we can remove the root from prefixes, however it will
        # /todo complicate the algorithm a since we need to ensure it
        # /todo was set.
        path_prefixes_gen = (path[:i] for i in range(len(path) + 1))
        for path_prefix in path_prefixes_gen:
            node = draw_tree._get_node(path_prefix)
            if node:
                state = draw_tree._get_state(node)
                self._track_path_to_obj(state.obj, path_prefix)

    def _get_patched_weakreffable(self, obj):
        """Return weakreffable if it is already present on ``obj``, or if
        it can be patched on ``obj``. Return :py:`None` if we cannot add
        an attribute to ``obj``.

        If the weakreffable was not patched before on ``obj``, it will create
        a new one and patch it in attribute ``__wr``.

        :param object obj:
        :rtype: _WeakReffable | None
        """
        try:  # already tracked
            return obj.__wr
        except AttributeError:  # not patchable or not weakreffable
            wreffable = _WeakReffable()
            try:  # patch the wreffable
                # TODO (TBD): will go wrong if __slots__ is enforced on Base
                obj.__wr = wreffable
            except AttributeError:
                return None  # cannot patch attributes on obj: not trackable
            else:
                return wreffable

    def _track_path_to_obj(self, obj, path):
        if isinstance(obj, ParaPyObject):
            obj_to_path_setdefault = self.obj_to_path.setdefault
            try:
                branch_set = obj_to_path_setdefault(obj, set())
            except TypeError:
                # obj is not wreffable, it might have a related _WeakReffable
                # in __wr (if not, we patch it) that can be used for tracking
                wreffable = self._get_patched_weakreffable(obj)
                if wreffable is None:  # could not patch the _WeakReffable
                    return  # do not track
                branch_set = obj_to_path_setdefault(wreffable, set())
            branch_set.add(path)

    def _untrack_path_to_obj(self, obj, path):
        if isinstance(obj, ParaPyObject):
            path_set = self._get_obj_pathset(obj)

            if path_set is not None:  # obj is tracked
                path_set.remove(path)
                if not path_set:  # has become empty due to remove
                    obj_to_path = self.obj_to_path
                    try:
                        del obj_to_path[obj]
                    except TypeError:  # it was through __wr
                        # does not have to be safe, otherwise path_set was None
                        del obj_to_path[obj.__wr]


if __name__ == '__main__':
    from parapy.geom import Box, XOY, Point
    from parapy.core import Part, child

    class BoxFail(Box):
        fail = Input(False)
        @Attribute
        def TopoDS_Shape(self):
            if self.fail:
                raise KeyError()
            else:
                return super(BoxFail, self).TopoDS_Shape

    class Boxes(Base):
        #: .
        #: :type:
        num_boxes = Input(3)

        working = Input(True)  # so we can see what happens on an error

        pts_hidden = Input(False)

        box_hidden = Input(False)

        @Attribute
        def _num_boxes(self):
            if self.working:
                return self.num_boxes
            else:
                raise KeyError("WHAT?")

        @Part
        def box(self):
            return BoxFail(1, 2, 3)

        @Part
        def boxes(self):
            return Box(1, 1, 1,
                       hidden=self.box_hidden,
                       quantify=self._num_boxes,
                       position=XOY.translate(z=child.index))

        @Attribute(in_tree=True)
        def pts(self):
            h = self.pts_hidden
            pts = (Point(i, i + 1, i - 1) for i in range(self._num_boxes))

            return list((setattr(p, 'hidden', h) or p) for p in pts)


    class A(Base):
        b = Input()

        @Attribute
        def bla(self):
            return self.b()

        @bla.on_slot_change
        def on_bla_invalidate(self):
            print("CHANGGGEEEE!!!")

    bs = Boxes()
    bs2 = Boxes()
    bs3 = Boxes()
    # display(bs)

    a = A(b=lambda: bs.boxes[0])

    print("{}{}{}".format(bs, bs2, bs3))
    print("{}{}{}".format(bs.boxes[2], bs2.boxes[2], bs3.boxes[2]))

    # some profiling code:
    # import cProfile, pstats, StringIO
    #
    # pr = cProfile.Profile()
    # pr.enable()

    from parapy.gui import display
    display((bs, bs2, bs3))

    # some profiling code (ctd...):
    # pr.disable()
    # s = StringIO.StringIO()
    # sortby = 'cumulative'
    # ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
    # ps.print_stats()
    # print s.getvalue()

    print(a.get_slot_status('bla'))
    print("bla: {}".format(a.bla))
    print(a.get_slot_status('bla'))
    print("bla: {}".format(a.bla))
    bs.num_boxes = 1
    print(a.get_slot_status('bla'))
    print("bla: {}".format(a.bla))
    print(a.b)

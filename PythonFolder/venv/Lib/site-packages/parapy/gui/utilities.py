#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""Utilities."""

import importlib
import re
import typing
from collections import OrderedDict

from parapy.core import Base, Sequence
from parapy.core.abstract import DrawableParaPyObject
from parapy.core.base import DrawableBase
from parapy.core.globs import Undefined
from parapy.core.meta import basetype
from parapy.gui.logger import logger

if typing.TYPE_CHECKING:
    from parapy.core.abstractbase import AbstractBase
    from parapy.core.decorators import Method


def yield_mro_sorted_slots(cls, attr):
    """Sorted slots dict first over MRO and then creation order.

    >>> from parapy.geom import Box
    >>> gen = yield_mro_sorted_slots(Box, "_inputs")
    >>> next(gen)  # doctest: +ELLIPSIS
    (<class 'parapy.geom.occ.primitives.Box'>, [('width', <Input Box.width ...), ...])
    >>> next(gen)  # doctest: +ELLIPSIS
    (<class 'parapy.geom.occ.primitives.PrimitiveSolid'>, [('position', <Input PrimitiveSolid.position ...)])

    :param cls: Class object.
    :type cls: parapy.core.basetype.basetype
    :param str attr: attribute returning a *slot dict*, e.g. '_inputs'.
    :rtype: collections.Iterable[parapy.core.basetype.basetype, list[str, AbstractSlot]]
    """
    dct = getattr(cls, attr)
    lst = sorted(iter(dct.items()), key=lambda it: it[1]._creation_counter)
    return yield_mro_sorted(cls, lst)


def yield_mro_sorted_methods(cls, category: str = None) -> typing.Iterator[
    typing.Tuple[typing.Type['AbstractBase'],
                 typing.List[typing.Tuple[str, 'Method']]]]:
    """Sorted 'special methods' dict first over MRO and then creation order.

    >>> from parapy.core import Base
    >>> from parapy.core.decorators import action, Action
    ...
    >>> class Foo(Base):
    ...     @action
    ...     def spam(self):
    ...         pass
    ...
    >>> class Bar(Foo):
    ...     @action
    ...     def eggs(self):
    ...         pass
    ...
    >>> gen = yield_mro_sorted_methods(Bar, Action.__ppmembername__)
    >>> next(gen)  # doctest: +ELLIPSIS
    (<class 'utilities.Bar'>, [('eggs', <Action eggs ...)])
    >>> next(gen)  # doctest: +ELLIPSIS
    (<class 'utilities.Foo'>, [('spam', <Action spam ...)])

    :param cls: Class object.
    :type cls: parapy.core.basetype.basetype
    :param str attr: attribute returning a *slot dict*, e.g. '_inputs'.
    :rtype: collections.Iterable[parapy.core.basetype.basetype, list[str, AbstractSlot]]
    """
    iter_attr_to_value = cls.yield_special_methods(category)
    lst = sorted(iter_attr_to_value, key=lambda pair: pair[1]._counter)
    return yield_mro_sorted(cls, lst)


def yield_mro_sorted(cls: typing.Type['AbstractBase'], iter_attr_to_value):
    mro = [(cls, cls.__dict__, []) for cls in
           cls.__mro__ if isinstance(cls, basetype)]
    for attr_to_value in iter_attr_to_value:
        attr = attr_to_value[0]
        flag = False
        for _, classdict, pocket in mro:
            if attr in classdict:
                flag = True
                break
        if flag:
            pocket.append(attr_to_value)
        else:
            msg = "Slot key {!r} owned by {!r} not found in MRO."
            raise RuntimeError(msg.format(attr, cls))
    for cls, _, pocket in mro:
        if pocket:
            yield cls, pocket


def safe_children_dictionary(obj):
    """True children dict for GUI tree. Includes all ``_tree_slots`` and
    corresponding values. Returns an Exception object if something failed,
    GUI will know what to do.

    Returns:
        {slot_name (str): obj (ParaPyObject|Exception),
         ...
         }
    """
    child_dict = OrderedDict()
    for _, slots in yield_mro_sorted_slots(type(obj), "_tree_slots"):
        for key, slot in slots:
            try:
                child_obj = slot.__get__(obj)
            except Exception as e:
                msg = "evaluation '{:}' of {:} failed"
                logger.warning(msg.format(key, obj), exc_info=True)
                child_obj = e
            else:
                if child_obj is Undefined:
                    continue
                elif isinstance(child_obj, Base):
                    try:
                        hidden = child_obj.hidden
                    except Exception as e:
                        msg = "evaluation 'hidden' of {:} failed"
                        logger.warning(msg.format(child_obj), exc_info=True)
                        child_obj = e
                    else:
                        if hidden:
                            continue
                elif (hasattr(child_obj, "__iter__")
                      and not isinstance(child_obj, Sequence)):
                    if len(child_obj) == 0:
                        continue
            child_dict[key] = child_obj
    return child_dict


def safe_children_dictionary_sequence(obj):
    """True children dict for GUI tree. Includes all ``_tree_slots`` and
    corresponding values. Returns an Exception object if something failed,
    GUI will know what to do.

    Returns:
        {slot_name (str): obj (ParaPyObject|Exception),
         ...
         }
    """

    try:
        lst = obj._list
    except Exception as e:
        msg = "Expansion of Sequence {:} failed"
        logger.warning(msg.format(obj), exc_info=True)
        return {"-- failed --": e}
    else:
        child_dict = OrderedDict()
        for i, child_obj in enumerate(lst):
            if isinstance(child_obj, Base):
                try:
                    hidden = child_obj.hidden
                except Exception as e:
                    msg = "evaluation 'hidden' of {:} failed"
                    logger.warning(msg.format(child_obj), exc_info=True)
                    child_obj = e
                else:
                    if hidden:
                        continue
            child_dict[i] = child_obj
        return child_dict


def safe_drawable_children_generator(obj):
    """Iterable to get all drawable children from obj recursively"""

    if isinstance(obj, Base):
        try:
            hidden = obj.hidden
        except Exception as e:
            msg = "evaluation of 'hidden' on {:} failed"
            logger.warning(msg.format(repr(obj)), exc_info=True)
        else:
            if not hidden:
                if isinstance(obj, DrawableBase):
                    yield obj
                # go through children
                for slot_name, slot in obj._tree_slots.items():
                    try:
                        obj_ = slot.__get__(obj)
                    except Exception as e:
                        msg = "evaluation of slot '{:}' on {:} failed"
                        logger.warning(msg.format(slot_name, obj), exc_info=True)
                    else:
                        for item in safe_drawable_children_generator(obj_):
                            yield item

    elif isinstance(obj, Sequence):
        try:
            iter_ = iter(obj)
        except Exception as e:
            msg = "failed iterating over sequence '{:}'"
            logger.warning(msg.format(obj), exc_info=True)
        else:
            for item in safe_drawable_children_generator(iter_):
                yield item

    elif isinstance(obj, DrawableParaPyObject):
        yield obj

    elif hasattr(obj, "__iter__"):
        for obj_ in obj:
            for item in safe_drawable_children_generator(obj_):
                yield item


def safe_drawable_children_with_path_generator(obj, path):
    """Iterable to get all drawable children from obj with their path relative
    to ``obj`` recursively.

    :param parapy.core.Base | collections.Iterable[parapy.core.Base] obj:
    :param tuple[str | int] path: Path to ``obj``.
    :rtype: collections.Iterator[tuple[tuple, parapy.core.base.DrawableBase]]
    """
    sdcwpg = safe_drawable_children_with_path_generator

    if isinstance(obj, Base):
        try:
            hidden = obj.hidden
        except Exception as e:
            msg = "evaluation of 'hidden' on {:} failed"
            logger.warning(msg.format(repr(obj)), exc_info=True)
        else:
            if not hidden:
                if isinstance(obj, DrawableBase):
                    yield path, obj
                # go through children
                for slot_name, slot in obj._tree_slots.items():
                    try:
                        obj_ = slot.__get__(obj)
                    except Exception as e:
                        msg = "evaluation of slot '{:}' on {:} failed"
                        logger.warning(msg.format(slot_name, obj), exc_info=True)
                    else:
                        child_path = path + (slot_name,)
                        for item in sdcwpg(obj_, child_path):
                            yield item

    elif isinstance(obj, Sequence):
        try:
            iter_ = iter(obj)
        except Exception as e:
            msg = "failed iterating over sequence '{:}'"
            logger.warning(msg.format(obj), exc_info=True)
        else:
            for item in sdcwpg(iter_, path):
                yield item

    elif isinstance(obj, DrawableParaPyObject):
        yield path, obj

    elif hasattr(obj, "__iter__"):
        for i, obj_ in enumerate(obj):
            child_path = path + (i,)
            for item in sdcwpg(obj_, child_path):
                yield item


def hidable_children_generator(obj):
    """generator that yield all evaluated children recursively that qualify to
    be hidden"""
    if isinstance(obj, DrawableParaPyObject):
        yield obj
    if isinstance(obj, Base):
        for attr in obj._tree_slots.keys():
            if obj.get_slot_status(attr):
                for item in safe_drawable_children_generator(getattr(obj, attr)):
                    yield item
    elif isinstance(obj, Sequence):
        if obj.get_slot_status("_list"):
            for obj_ in obj:
                for item in safe_drawable_children_generator(obj_):
                    yield item
    # sequences
    elif hasattr(obj, "__iter__"):
        for obj_ in obj:
            for item in safe_drawable_children_generator(obj_):
                yield item


def truncate(s, limit):
    """Truncate string ``s`` to ``limit`` characters, unless ``limit`` is
    None.

    >>> truncate("longstring", 7)
    'long...'
    >>> truncate("longstring", 10)
    'longstring'
    >>> truncate("longstring", None)
    'longstring'
    """
    if limit is None:
        return s
    else:
        return s[:limit - 3] + "..." if len(s) > limit else s


_parse_py_float_regex = r'[\+\-]?\d+(?:\.?\d*(?:[eE][\-\+]?)?\d*)?'
_parse_point_regex = (r'\s*Point\(\s*({0})\s*,\s*({0})\s*,'
                      r'\s*({0})\s*\)\s*').format(_parse_py_float_regex)
_parse_position_regex = r'\s*Position\({}\)\s*'.format(_parse_point_regex)

_parse_float = re.compile(r'^\s*' + _parse_py_float_regex + r'\s*$')
_parse_point = re.compile('^' + _parse_point_regex + '$')
_parse_position = re.compile('^' + _parse_position_regex + '$')


def parse_point(string):
    """Parses ``string`` and returns a :class:`~parapy.geom.Point` if string
    represents a point, otherwise :py:`None`.

    :type string: str
    :rtype: parapy.geom.Point | None
    """
    matches = _parse_point.match(string)

    if matches is None:
        return None
    else:
        from parapy.geom import Point
        x = float(matches.group(1))
        y = float(matches.group(2))
        z = float(matches.group(3))
        return Point(x, y, z)


def parse_position(string, old=None):
    """Parses ``string`` and returns a :class:`~parapy.geom.Point` if string
    represents a point, otherwise :py:`None`.

    :type string: str
    :param parapy.geom.Position | None old:
    :rtype: parapy.geom.Position | None
    """
    matches = _parse_position.match(string)

    if matches is None:
        return None
    else:
        from parapy.geom import Point, Position
        x = float(matches.group(1))
        y = float(matches.group(2))
        z = float(matches.group(3))

        if old is None:
            from parapy.geom import Orientation
            ori = Orientation()
        else:
            ori = old.orientation

        return Position(orientation=ori, location=Point(x, y, z))


def generate_filenames(orig_name, subscripts, postfix_fmt='{}'):
    """Generate files where ``orig_name`` gets a subscript before the
    extension.

    Example: foo.txt -> foo_1.txt

    Usage:

    >>> list(generate_filenames("foo.txt", list(range(5))))
    ['foo_0.txt', 'foo_1.txt', 'foo_2.txt', 'foo_3.txt', 'foo_4.txt']
    >>> list(generate_filenames("foo.txt", list(range(5)), postfix_fmt='{:03d}'))
    ['foo_000.txt', 'foo_001.txt', 'foo_002.txt', 'foo_003.txt', 'foo_004.txt']

    :param str orig_name:
    :param collections.Iterable[T] subscripts:
    :param str postfix_fmt: Formatting of the postfix number, should be a
        string that can be substituted by `format`.
    :return: collections.Iterator[str]
    """
    base, ext = orig_name.rsplit('.', 1)
    pattern = '{}_' + postfix_fmt + '.{}'

    for subscript in subscripts:
        yield pattern.format(base, subscript, ext)


def locate(qualname):
    """Locate object from fully qualified name.

    >>> locate("parapy.gui.main.MainWindow")
    <class 'parapy.gui.main.MainWindow'>
    >>> locate("parapy.gui.bogus.MainWindow")
    Traceback (most recent call last):
        ...
    ImportError: No module named bogus
    >>> locate("DocTestRunner")  # doctest: +ELLIPSIS
    <class __main__.DocTestRunner at ...>

    .. warning:: only top-level module objects can be located, e.g. no nested
        classes (class defined in class)
    """
    mod_attr = qualname.rsplit(".", 1)
    if len(mod_attr) == 1:
        mod = "__main__"
        attr, = mod_attr
    else:
        mod, attr = mod_attr

    mod = importlib.import_module(mod)
    return getattr(mod, attr)


if __name__ == '__main__':
    from parapy.core import Input, Part
    from parapy.geom.occ.primitives import Cube

    class TestTree(Cube):
        """Finite recursive tree of boxes"""

        #: :type: int
        level = Input(0)

        dimension = Input(1)

        @Part
        def my_children(self):
            return TestTree(quantify=abs(self.level - 3),
                            position=self.position(x=self.level * 2),
                            level=self.level + 1)

        @Part
        def my_error_child(self):
            return Cube(quantify=0 / 0,
                        dimension=1)

    obj = TestTree()
    print(list(safe_drawable_children_generator(obj)))

    print(parse_point('Point(1, 2, 3)'))
    print(parse_point('Point(1, 2, 3)'))
    print(parse_point('Point(+1, -2, +3)'))
    print(parse_point('Point(1.2134, 1, 3)'))
    print(parse_point('Point(-23, -2, 2e12)'))
    print(parse_point('Point(2., 2.E32, 2.E+32)'))

    print(parse_point('Point(2., 2.E32) '))
    print(parse_point('Point(2., 2.E-32, 23f) '))
    print(parse_point('Point(2., 2.E32) 32'))

    print(locate("parapy.gui.main.MainWindow"))

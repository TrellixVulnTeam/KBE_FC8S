#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

import math
from functools import partial
from itertools import chain

from OCC.wrapper import TCollection_AsciiString
from OCC.wrapper.AIS import (
    AIS_AngleDimension, AIS_DiameterDimension, AIS_LengthDimension, AIS_Point,
    AIS_RadiusDimension, AIS_Shape, AIS_TOAV_Both, AIS_TOAV_First,
    AIS_TOAV_None, AIS_TOAV_Second, AIS_TOA_Exterior, AIS_TOA_Interior,
    Handle_AIS_InteractiveObject)
from OCC.wrapper.Geom import Geom_CartesianPoint
from OCC.wrapper.Graphic3d import Graphic3d_Texture2Dplane, Graphic3d_ZLayerId_Topmost
from OCC.wrapper.Prs3d import (
    Prs3d_DAO_External, Prs3d_DAO_Internal,
    Prs3d_DimensionAspect, Prs3d_ShadingAspect)
from OCC.wrapper.TCollection import TCollection_ExtendedString
from OCC.wrapper.Units import Units__Convert
from OCC.wrapper.gp import gp_Pnt, gp_Pnt2d
from OCC.gui.interactive_objects import (
    make_ais_text_label, make_ais_trihedron)
from OCC.utils.utilities import rgb_QuantityColor

from parapy.core.utilities import all_map, get_rgb_value
from parapy.geom import (
    AngleDimension, AngleDimension3Points, DiameterDimension, LengthDimension,
    Plane, RadiusDimension)
from parapy.geom.generic.positioning import AbstractPoint, Position
from parapy.geom.generic.utilities import is_3dpoint
from parapy.geom.occ.annotation import (
    ColorScale, Dimension, TextLabel)
from parapy.geom.occ.drawable import DrawableShape
from parapy.geom.occ.utilities import (
    is_circle_like, is_edge_like, is_face_like, is_shape_like, is_vertex_like)
from parapy.geom.occ.vertex import Vertex
from parapy.geom.occ.visual import TexturedShape


def xyz_to_ais_handle(xyz):
    return AIS_Point(Geom_CartesianPoint(gp_Pnt(*xyz)).handle).handle


def closure_position_to_ais_handle(**kwargs):
    def position_to_ais_handle(obj):
        """:type obj: Position"""
        return make_ais_trihedron(obj.location, obj.Vz, obj.Vx, **kwargs)

    return position_to_ais_handle


def obj_to_ais_handle(obj):
    return AIS_Shape(obj._drawable_TopoDS_Shape).handle


def vertex_to_ais_handle(obj):
    return AIS_Point(Geom_CartesianPoint(obj.gp_Pnt).handle).handle


def text_to_ais_handle(self):
    """Monkey-patched in Text._Handle_AIS_InteractiveObject.

    :type self: parapy.geom.TextLabel
    """
    position = self.position

    if self.zoom_persistent or not self.orient:
        obj = make_ais_text_label(
            self.text, position, top_most=self.overlay, height=self.size)

        if self.orient:
            gp_ax2 = position.gp_Ax2
            obj.SetOrientation3D(gp_ax2)

        obj.SetHJustification(self._ANCHOR_TO_HTA[self.anchor])
        obj.SetVJustification(self._VANCHOR_TO_VTA[self.vanchor])
        obj.SetFontAspect(self._font_aspect)
        obj.SetFont(self.font)
        obj.SetZoomable(not self.zoom_persistent)
    else:
        # because this does not work:
        # obj.SetZoomable(not self.zoom_persistent)
        obj = self.shape._Handle_AIS_InteractiveObject
        if self.overlay:
            obj.SetZLayer(Graphic3d_ZLayerId_Topmost)

    return obj


class DimensionAISAdapter(object):
    __slots__ = 'dimension_obj',

    def __init__(self, obj):
        """

        :param parapy.geom.occ.annotation.Dimension obj:
        """
        self.dimension_obj = obj

    @property
    def ais_interactive_object(self):
        ais_dimension = self._ais_dimension
        self._check_ais_dimension(ais_dimension)
        self._set_ais_dimension(ais_dimension)
        return ais_dimension

    def _set_text(self, dim_asp):
        """

        :param OCC.Prs3d.Handle_Prs3d_DimensionAspect dim_asp:
        """
        obj = self.dimension_obj
        text_size = obj.text_size
        if text_size is None:
            orig_size = dim_asp.TextAspect().Height()
            # 0.25 magic value that seems OK
            text_size = obj.dimension_scale * orig_size * 0.25
        dim_asp.TextAspect().SetHeight(text_size)

        if obj.text_in_3d:
            dim_asp.MakeText3d(True)
            dim_asp.MakeTextShaded(True)

    def _set_arrow(self, dim_asp):
        """

        :param OCC.Prs3d.Handle_Prs3d_DimensionAspect dim_asp:
        """
        obj = self.dimension_obj
        #: :type: OCC.Prs3d.Handle_Prs3d_ArrowAspect
        arrow_aspect = dim_asp.ArrowAspect()

        arrow_size = obj.arrow_size
        if arrow_size is None:
            orig_size = arrow_aspect.Length()
            arrow_size = obj.dimension_scale * orig_size
        arrow_aspect.SetLength(arrow_size)

        arrow_tail_length = obj.arrow_tail_length
        if arrow_tail_length is None:
            orig_size = dim_asp.ArrowTailSize()
            arrow_tail_length = obj.dimension_scale * orig_size
        dim_asp.SetArrowTailSize(arrow_tail_length)

        arrow_direction = obj.arrow_direction
        if arrow_direction:
            prs_dir = (Prs3d_DAO_External if arrow_direction == 'inward'
                       else Prs3d_DAO_Internal)
            dim_asp.SetArrowOrientation(prs_dir)

        arrow3d = obj.arrow_in_3d
        if arrow3d:
            dim_asp.MakeArrows3d(True)

        dim_asp.SetArrowAspect(arrow_aspect)

    def _set_visual(self, ais_dimension):
        # TODO (TBD): Make the creation of new aspects lazy.
        dim_asp = Prs3d_DimensionAspect().handle

        obj = self.dimension_obj
        append_unit = obj.append_unit
        if append_unit:
            dim_asp.MakeUnitsDisplayed(True)

        color = obj.color
        if color:
            q_color = rgb_QuantityColor(get_rgb_value(color))
            dim_asp.SetCommonColor(q_color)

        ext_size = obj.label_extension_length
        if ext_size is None:
            orig_size = dim_asp.ExtensionSize()
            ext_size = obj.dimension_scale * orig_size
        dim_asp.SetExtensionSize(ext_size)

        # set arrow and text visuals
        self._set_arrow(dim_asp)
        self._set_text(dim_asp)

        ais_dimension.SetDimensionAspect(dim_asp)

    def _set_ais_dimension(self, ais_dimension):
        """Sets the AIS_Dimension properties of an AIS_Dimension

        :param OCC.AIS.AIS_Dimension ais_dimension:
        """
        attrs = 'world_units', 'units',  # 'unit_symbol'

        def get_setter(attr):
            return getattr(ais_dimension, attr)

        def get_conv_setter(attr, conv):
            return lambda x: get_setter(attr)(conv(x))

        get_ascii_setter = partial(get_conv_setter,
                                   conv=TCollection_AsciiString)
        # get_ext_setter =  partial(get_conv_setter,
        #                               conv=lambda x:
        #                               TCollection_ExtendedString(x).Value(1))

        setters = (get_ascii_setter('SetModelUnits'),
                   get_ascii_setter('SetDisplayUnits'),
                   # get_ext_setter('SetSpecialSymbol')
                   )

        obj = self.dimension_obj
        for attr, setter in zip(attrs, setters):
            value = getattr(obj, attr)
            if value:
                setter(value)

        if obj.top_most:
            ais_dimension.SetZLayer(Graphic3d_ZLayerId_Topmost)

        fly_out = obj.fly_out
        fly_out_ratio = obj.fly_out_ratio
        if fly_out is None and fly_out_ratio is not None:
            fly_out = ais_dimension.GetValue() * obj.fly_out_ratio

        if fly_out is not None:
            ais_dimension.SetFlyout(fly_out)

        # set the text
        if obj.text:
            # we need to convert it to units of the dimension object
            world_units = ais_dimension.GetModelUnits().ToCString()
            my_units = ais_dimension.GetDisplayUnits().ToCString()
            computed_value = Units__Convert(ais_dimension.GetValue(),
                                            world_units, my_units)

            # replace any placeholds
            text = obj.text.format(value=computed_value,
                                   unit=my_units)
            ais_dimension.SetCustomValue(TCollection_ExtendedString(text))

        text_position = obj.text_location
        if text_position:
            ais_dimension.SetTextPosition(gp_Pnt(*text_position))

        self._set_visual(ais_dimension)

    def _check_ais_dimension(self, ais_dimension):
        dimension_obj = self.dimension_obj
        if not ais_dimension.IsValid():
            msg = ("Could not construct {} object! Please check the input "
                   "shape(s). Object: {}")
            raise RuntimeError(msg.format(type(dimension_obj).__name__,
                                          dimension_obj))

    def _get_in_plane_gp_pln(self):
        """Return the OCC object describing ``in_plane`` or None if it was
        nto specified.

        :rtype: OCC.gp.gp_Pln | None
        :raise TypeError: if ``in_plane`` does not meet the criteria needed
            for construction.
        """
        in_plane = self.dimension_obj.in_plane
        if not in_plane:
            return None

        if isinstance(in_plane, Plane):
            return in_plane.Handle_Geom_Surface.Pln()
        else:
            msg = ("Input 'in_plane' only allows a parapy.geom.Plane "
                   "instance, got: {}. Object: {}")
            raise TypeError(msg.format(in_plane, self.dimension_obj))

    @property
    def _ais_dimension(self):
        raise NotImplementedError("DimensionAdapter is an abstract class, "
                                  " Please implement the _ais_dimension"
                                  " property in a sub-class.")


class LengthDimensionAISAdapter(DimensionAISAdapter):
    _unsupported_conf_msg = ("Unsupported combination of 'shape', "
                             "'other_shape' and 'in_plane' Inputs. Please "
                             "refer to the documentation of LengthDimension "
                             "for an overview of the legal configurations. "
                             "shape: {}, other_shape: {}, in_plane: {}. "
                             "Object: {}.")

    @property
    def _ais_dimension(self):
        #: :type: parapy.geom.occ.annotation.LengthDimension
        dimension_obj = self.dimension_obj
        s1 = dimension_obj.shape
        s2 = dimension_obj.other_shape
        gp_pln = self._get_in_plane_gp_pln()

        if gp_pln:
            if s2 is None:
                if is_edge_like(s1):
                    args = s1.TopoDS_Edge, gp_pln
                else:
                    msg = self._unsupported_conf_msg.format(
                        s1, s2, dimension_obj.in_plane, dimension_obj)
                    raise TypeError(msg)
            elif all_map(is_shape_like, (s1, s2)):
                args = s1.TopoDS_Shape, s2.TopoDS_Shape, gp_pln
            elif is_3dpoint(s1) and is_3dpoint(s2):
                args = gp_Pnt(*s1), gp_Pnt(*s2), gp_pln
            else:
                msg = self._unsupported_conf_msg.format(
                    s1, s2, dimension_obj.in_plane, dimension_obj)
                raise TypeError(msg)
        else:
            s1_is_face = is_face_like(s1)
            s2_is_face = is_face_like(s2)
            if s1_is_face and s2_is_face:
                args = s1.TopoDS_Face, s2.TopoDS_Face
            elif s1_is_face and is_edge_like(s2):
                args = s1.TopoDS_Face, s2.TopoDS_Edge
            elif s2_is_face and is_edge_like(s1):
                args = s2.TopoDS_Face, s1.TopoDS_Edge
            else:
                msg = self._unsupported_conf_msg.format(
                    s1, s2, dimension_obj.in_plane, dimension_obj)
                raise TypeError(msg)

        return AIS_LengthDimension(*args).handle


class DiameterDimensionAISAdapter(DimensionAISAdapter):
    @property
    def _ais_dimension(self):
        #: :type: parapy.geom.occ.annotation.DiameterDimension
        dimension_obj = self.dimension_obj
        shape = dimension_obj.shape
        gp_pln = self._get_in_plane_gp_pln()

        if is_circle_like(shape):
            first_arg = shape.Handle_Geom_Curve.Circ()
        elif is_shape_like(shape):
            first_arg = shape.TopoDS_Shape
        else:
            msg = ("Cannot construct dimension for input shape {}. Is it "
                   "a shape? Object: {}")
            raise TypeError(msg.format(shape, dimension_obj))

        if gp_pln:
            args = first_arg, gp_pln
        else:
            args = first_arg,

        return AIS_DiameterDimension(*args).handle


class RadiusDimensionAISAdapter(DimensionAISAdapter):
    @property
    def _ais_dimension(self):
        #: :type: parapy.geom.occ.annotation.RadiusDimension
        dimension_obj = self.dimension_obj
        shape = dimension_obj.shape

        if is_circle_like(shape):
            args = shape.Handle_Geom_Curve.Circ(),
        elif is_shape_like(shape):
            args = shape.TopoDS_Shape,
        else:
            msg = ("Cannot construct dimension for input shape {}. Is it "
                   "a shape? Object: {}")
            raise TypeError(msg.format(shape, dimension_obj))

        ais_dimension = AIS_RadiusDimension(*args).handle

        gp_pln = self._get_in_plane_gp_pln()
        if gp_pln:
            ais_dimension.SetCustomPlane(gp_pln)

        return ais_dimension


class AngleDimensionAdapter(DimensionAISAdapter):

    _display_arrow_map = {
        'both': AIS_TOAV_Both,
        'first': AIS_TOAV_First,
        'second': AIS_TOAV_Second,
        None: AIS_TOAV_None
    }

    def _set_ais_dimension(self, ais_dimension):
        dimension_obj = self.dimension_obj
        interior_angle = dimension_obj.interior_angle
        if interior_angle:
            ais_dimension.SetType(AIS_TOA_Interior)
        else:
            # needs to happen before calling super to ensure correct
            # conversion and use of the value, opencascade forgets to
            # calculate this
            value = ais_dimension.GetValue()
            ais_dimension.SetCustomValue(math.pi * 2. - value)
            ais_dimension.SetType(AIS_TOA_Exterior)

        super(AngleDimensionAdapter, self)._set_ais_dimension(ais_dimension)

        display_arrows = dimension_obj.display_arrows
        try:
            ais_arrow_style = self._display_arrow_map[display_arrows]
        except KeyError:
            msg = "Unsupported value for 'display_arrows': {}. Object: {}"
            raise TypeError(msg.format(display_arrows, dimension_obj))
        else:
            ais_dimension.SetArrowsVisibility(ais_arrow_style)

    def _get_in_plane_gp_pln(self):
        pln = super(AngleDimensionAdapter, self)._get_in_plane_gp_pln()

        if pln:
            dimension_obj = self.dimension_obj
            shape = dimension_obj.shape
            other_shape = dimension_obj.other_shape
            in_plane = dimension_obj.in_plane

            plane_normal = in_plane.plane_normal
            if not (plane_normal.is_orthogonal(shape.plane_normal) and
                    plane_normal.is_orthogonal(other_shape.plane_normal)):
                msg = ("Cannot construct AngleDimension, "
                       "in_plane {} is not parallel to "
                       "the normals of given faces {}. Object {}.")
                raise TypeError(msg.format(in_plane, (shape, other_shape),
                                           dimension_obj))

        return pln

    @property
    def _ais_dimension(self):
        #: :type: parapy.geom.occ.annotation.AngleDimension
        dimension_obj = self.dimension_obj
        shape = dimension_obj.shape
        other_shape = dimension_obj.other_shape
        shapes = shape, other_shape

        if all_map(is_edge_like, shapes):
            args = (shape.TopoDS_Edge for shape in shapes)
        elif all_map(is_face_like, shapes):
            if shapes[0].is_planar and shapes[1].is_planar:
                args = (shape.TopoDS_Face for shape in shapes)

                gp_pln = self._get_in_plane_gp_pln()
                if gp_pln:  # add 'thePoint' argument
                    pnt = gp_pln.Position()
                    args = chain(args, iter(pnt))
            else:
                msg = ("Can only construct an AngleDimension for 2 Face "
                       "instances when both are planar, got {}. Object {}.")
                raise TypeError(msg.format(shapes, dimension_obj))
        else:
            msg = ("Can only construct an AngleDimension for "
                   "either two Face or two Edge instances. Got: "
                   "shape: {}, other_shape: {}. Object: {}")
            raise TypeError(msg.format(shapes[0], shapes[1], dimension_obj))

        return AIS_AngleDimension(*args).handle


class AngleDimension3PointsAdapter(AngleDimensionAdapter):
    @property
    def _ais_dimension(self):
        #: :type: parapy.geom.occ.annotation.AngleDimension3Points
        dimension_obj = self.dimension_obj
        points = dimension_obj.points

        # TODO (TBD): Extend to allow a mix of vertices and points.
        if all_map(is_vertex_like, points):
            args = (pt.TopoDS_Vertex for pt in points)
        elif all_map(is_3dpoint, points):
            args = (gp_Pnt(*pt) for pt in points)
        else:
            msg = ("Can only construct an AngleDimension3Points for "
                   "either three Point or two Vertex instances. Got: "
                   "point: {}, other_point: {}, rotation_point: {}. "
                   "Object: {}")
            raise TypeError(msg.format(points[0], points[2], points[1],
                                       dimension_obj))

        return AIS_AngleDimension(*args).handle


def dimension_to_ais(self):
    try:  # from cache
        ais_adapter = self.__ais_adapter
    except AttributeError:
        try:
            adapter_cls = self._ais_adapter_cls
        except AttributeError:
            msg = ("No AIS adapter class found! One should patch an "
                   "_ais_adapter_cls to the class to be visualized in order "
                   "to visualize it. Object: {}")
            raise NotImplementedError(msg.format(self))
        else:
            self.__ais_adapter = ais_adapter = adapter_cls(self)

    return ais_adapter.ais_interactive_object


def textured_rectangular_face_ais_handle(self):
    filename = TCollection_AsciiString(str(self.filename))
    texture = Graphic3d_Texture2Dplane(filename).handle
    if self.modulate_texture:
        texture.EnableModulate()
    else:
        texture.DisableModulate()

    shading_aspect = Prs3d_ShadingAspect().handle
    textured_shape = AIS_Shape(self.built_from.TopoDS_Shape).handle
    textured_shape.Attributes().SetShadingAspect(shading_aspect)
    aspect = shading_aspect.Aspect()
    aspect.SetTextureMapOn()
    aspect.SetTextureMap(texture)

    uv_origin = self.uv_origin
    if uv_origin:
        point = gp_Pnt2d(uv_origin[0], uv_origin[1])
        textured_shape.SetTextureOriginUV(point)

    repeat_u = self.repeat_u
    repeat_v = self.repeat_v
    if repeat_u or repeat_v:
        point = gp_Pnt2d(repeat_u or 1.0, repeat_v or 1.0)
        textured_shape.SetTextureRepeatUV(point)

    scale_u = self.scale_u
    scale_v = self.scale_v
    if scale_u or scale_v:
        point = gp_Pnt2d(scale_u or 1.0, scale_v or 1.0)
        textured_shape.SetTextureScaleUV(point)

    textured_shape.SynchronizeAspects()
    return textured_shape


def _apply_annotation_patches():
    # dimensioning classes are a bit more complicated to visualize. In
    # order to get them truly independent of, they use an adapter class
    # for the conversion
    Dimension._Handle_AIS_InteractiveObject = property(dimension_to_ais)

    # patch adapters in the real (non-abstract) classes
    LengthDimension._ais_adapter_cls = LengthDimensionAISAdapter
    DiameterDimension._ais_adapter_cls = DiameterDimensionAISAdapter
    RadiusDimension._ais_adapter_cls = RadiusDimensionAISAdapter
    AngleDimension._ais_adapter_cls = AngleDimensionAdapter
    AngleDimension3Points._ais_adapter_cls = AngleDimension3PointsAdapter


def scale_ais_handle(self):
    return Handle_AIS_InteractiveObject(self._AIS_ColorScale)


def apply_patch():
    AbstractPoint._Handle_AIS_InteractiveObject = property(xyz_to_ais_handle)
    DrawableShape._Handle_AIS_InteractiveObject = property(obj_to_ais_handle)
    Vertex._Handle_AIS_InteractiveObject = property(vertex_to_ais_handle)
    TextLabel._Handle_AIS_InteractiveObject = property(text_to_ais_handle)
    _apply_annotation_patches()
    TexturedShape._Handle_AIS_InteractiveObject = property(
        textured_rectangular_face_ais_handle)
    ColorScale._Handle_AIS_InteractiveObject = property(scale_ais_handle)


def apply_position_patch(**kwargs):
    fn = closure_position_to_ais_handle(**kwargs)
    Position._Handle_AIS_InteractiveObject = property(fn)


def retract_position_patch():
    try:
        del Position._Handle_AIS_InteractiveObject
    except AttributeError:
        pass

#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2016-2021 ParaPy Holding B.V.
#
# This file is subject to the terms and conditions defined in
# the license agreement that you have received with this source code
#
# THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
# PURPOSE.

"""This file is used to make the exception tracebacks involving slots look
like tracebacks involving properties. The internal calls of the descriptors
and caching mechanism are not shown.

For example:

    class Demo(Base):
    
        @Attribute
        def demo_slot(self):
            return non_existent
    
        @Attribute
        def demo_property(self):
            return non_existent
    
    # Both will raise an exception with a traceback of 2 entries: the print
    # line and the "return non_existent" line.
    print Demo().demo_slot
    print Demo().demo_property

To make this happen, this file provides a function that hooks into the
Python error and traceback mechanism. This file relies on a function
provided by jinja2.debug, which is a bit of a hack, but safe enough to use.

For more information, visit:
http://blog.sujeet.me/2013/04/python-tinkering-a-decorator-to-implement-private-methods-II.html"""

# This module contains slightly adapted code from the jinja2 debug.py module.
# Project: Jinja2
# Url: https://github.com/mitsuhiko/jinja2/
# Release: 2.7.2

import sys
import platform

#: names of modules whose frames should be removed from the traceback
from parapy.config import CONFIGURATION

MODULES = frozenset(("parapy.core.abstractslot",
                     "parapy.core.input",
                     "parapy.core.attribute"))


# on pypy we can take advantage of transparent proxies
try:
    from __pypy__ import tproxy
except ImportError:
    tproxy = None


def _init():
    """This function implements a few ugly things so that we can patch the
    traceback objects.  The function returned allows resetting `tb_next` on
    any python traceback object.  Do not attempt to use this on non cpython
    interpreters
    """
    import ctypes
    from types import TracebackType

    # figure out side of _Py_ssize_t
    if hasattr(ctypes.pythonapi, 'Py_InitModule4_64'):
        _Py_ssize_t = ctypes.c_int64
    else:
        _Py_ssize_t = ctypes.c_int

    # regular python
    class _PyObject(ctypes.Structure):
        pass
    _PyObject._fields_ = [
        ('ob_refcnt', _Py_ssize_t),
        ('ob_type', ctypes.POINTER(_PyObject))
    ]

    # python with trace
    if hasattr(sys, 'getobjects'):
        class _PyObject(ctypes.Structure):
            pass
        _PyObject._fields_ = [
            ('_ob_next', ctypes.POINTER(_PyObject)),
            ('_ob_prev', ctypes.POINTER(_PyObject)),
            ('ob_refcnt', _Py_ssize_t),
            ('ob_type', ctypes.POINTER(_PyObject))
        ]

    class _Traceback(_PyObject):
        pass
    _Traceback._fields_ = [
        ('tb_next', ctypes.POINTER(_Traceback)),
        ('tb_frame', ctypes.POINTER(_PyObject)),
        ('tb_lasti', ctypes.c_int),
        ('tb_lineno', ctypes.c_int)
    ]

    def tb_set_next(tb, next):
        """Set the tb_next attribute of a traceback object."""
        if not (isinstance(tb, TracebackType) and
                (next is None or isinstance(next, TracebackType))):
            raise TypeError('tb_set_next arguments must be traceback objects')
        obj = _Traceback.from_address(id(tb))
        if tb.tb_next is not None:
            old = _Traceback.from_address(id(tb.tb_next))
            old.ob_refcnt -= 1
        if next is None:
            obj.tb_next = ctypes.POINTER(_Traceback)()
        else:
            next = _Traceback.from_address(id(next))
            next.ob_refcnt += 1
            obj.tb_next = ctypes.pointer(next)

    return tb_set_next


# try to get a tb_set_next implementation if we don't have transparent
# proxies.
tb_set_next = None
if tproxy is None:
    try:
        tb_set_next = _init()
    except:
        pass
    del _init


_hook = [None, None]  # new hook, old hook


def skip_tb(tb):
    # don't skip very last
    if tb.tb_next:
        frame = tb.tb_frame
        module = frame.f_globals.get("__name__", None)
        return module and module in MODULES
    else:
        return False


def cleanup_traceback(traceback):
    if traceback:
        tb = traceback
        while tb.tb_next:
            tb_ = tb.tb_next
            if skip_tb(tb_):
                tb_set_next(tb, tb_.tb_next)
            else:
                tb = tb_


def get_frame(traceback, frame_num):
    """Get frame ``frame_num`` in ``traceback``."""
    for i in range(frame_num):
        traceback = traceback.tb_next
    return traceback


def install_hook():
    """Hook the traceback entries filtering code into the Python exception
    and traceback mechanism. Returns function if installed or None if
    not supported.

    :rtype: types.FunctionType | None
    """
    print("ParaPy: installing traceback hook")

    if platform.python_implementation() != "CPython":
        # Only available in CPython - tb_set_next will only work there.
        return

    if _hook[0]:
        return _hook[0]

    def excepthook(etype, value, traceback, tb_offset=None):
        if CONFIGURATION.getboolean("core.runtime", "cleanup_traceback"):
            cleanup_traceback(traceback)
        return original_excepthook(etype, value, traceback)

    original_excepthook = sys.excepthook
    sys.excepthook = excepthook
    sys.displayhook = excepthook
    _hook[:] = excepthook, original_excepthook
    return excepthook


def uninstall_hook():
    """Uninstall ParaPy trackeback hook. Returns function if uninstalled or
    None if not supported / installed.

    :rtype: types.FunctionType | None
    """

    if platform.python_implementation() != "CPython":
        # Only available in CPython - tb_set_next will only work there.
        return

    if not _hook[0]:  # nothing installed
        return
    else:
        installed_hook, original_hook = _hook
        if sys.excepthook is not installed_hook:
            msg = "Current sys.excepthook not equal to installed excepthook"
            raise RuntimeError(msg)
        else:
            sys.excepthook = original_hook
            _hook[:] = None, None
            return installed_hook


def hook_installed():
    """Was ParaPy trackeback hook installed?

    :rtype: bool
    """
    return bool(_hook[0])


class traceback_context(object):
    """Context manager in which depending on the value of ``active``,
    traceback is filtered::

        with traceback_context(True):
            # your code
    """
    def __init__(self, cleanup=True):
        self.cleanup = cleanup

    def __enter__(self):
        pass

    def __exit__(self, type, value, traceback):
        if self.cleanup:
            cleanup_traceback(traceback)
